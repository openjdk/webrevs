{"files":[{"patch":"@@ -25,5 +25,2 @@\n-from onnx.defs import (\n-    AttributeProto,\n-    OpSchema,\n-    get_all_schemas_with_history,\n-)\n+from onnx import AttributeProto\n+from onnx.defs import OpSchema, get_all_schemas_with_history\n","filename":"cr-examples\/onnx\/opgen\/onnxOpSchemaToJSON.py","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-# Run jextract\n+## Run jextract\n@@ -29,1 +29,9 @@\n-  $INCLUDE_DIR\/core\/providers\/coreml\/coreml_provider_factory.h\n\\ No newline at end of file\n+  $INCLUDE_DIR\/core\/providers\/coreml\/coreml_provider_factory.h\n+\n+#jextract --target-package oracle.code.onnx.foreign \\\n+#  -l :$LIB_PATH \\\n+#  -I $INCLUDE_DIR \\\n+#  --header-class-name onnxruntime_c_api_h \\\n+#  --use-system-load-library \\\n+#  --output $OUTPUT_DIR \\\n+#  $INCLUDE_DIR\/core\/session\/onnxruntime_c_api.h\n","filename":"cr-examples\/onnx\/opgen\/setup.sh","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            <version>1.20.0<\/version>\n+            <version>1.23.1<\/version>\n","filename":"cr-examples\/onnx\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,7 @@\n+    public record AttentionResult<T1, T2>(Tensor<T1> Y, Tensor<T1> present_key, Tensor<T2> present_value, Tensor<T1> qk_matmul_output) { }\n+    public static <T1, T2, U> AttentionResult<T1, T2> Attention(Tensor<T1> Q, Tensor<T1> K, Tensor<T2> V, Optional<Tensor<U>> attn_mask, Optional<Tensor<T1>> past_key, Optional<Tensor<T2>> past_value, Optional<Tensor<Long>> nonpad_kv_seqlen, Optional<Long> qk_matmul_output_mode, Optional<Float> softcap, Optional<Long> softmax_precision, Optional<Float> scale, Optional<Long> is_causal, Optional<Long> q_num_heads, Optional<Long> kv_num_heads) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Attention.class, List.of(Q, K, V, attn_mask, past_key, past_value, nonpad_kv_seqlen), List.of(qk_matmul_output_mode, softcap, softmax_precision, scale, is_causal, q_num_heads, kv_num_heads));\n+        Object[] resultArray = (Object[]) result;\n+        return new AttentionResult<>((Tensor<T1>)resultArray[0], (Tensor<T1>)resultArray[1], (Tensor<T2>)resultArray[2], (Tensor<T1>)resultArray[3]);\n+    }\n+\n@@ -167,2 +174,2 @@\n-    public static <T1, T2> Tensor<T2> Cast(Tensor<T1> input, Optional<Long> saturate, long to) {\n-        Object result = OnnxInterpreter.interpret(OnnxOps.Cast.class, List.of(input), List.of(saturate, to));\n+    public static <T1, T2> Tensor<T2> Cast(Tensor<T1> input, Optional<Long> saturate, long to, Optional<String> round_mode) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Cast.class, List.of(input), List.of(saturate, to, round_mode));\n@@ -172,2 +179,2 @@\n-    public static <T1, T2> Tensor<T2> CastLike(Tensor<T1> input, Tensor<T2> target_type, Optional<Long> saturate) {\n-        Object result = OnnxInterpreter.interpret(OnnxOps.CastLike.class, List.of(input, target_type), List.of(saturate));\n+    public static <T1, T2> Tensor<T2> CastLike(Tensor<T1> input, Tensor<T2> target_type, Optional<Long> saturate, Optional<String> round_mode) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.CastLike.class, List.of(input, target_type), List.of(saturate, round_mode));\n@@ -282,3 +289,3 @@\n-    public static <T1, T2> Tensor<T2> DequantizeLinear(Tensor<T1> x, Tensor<T2> x_scale, Optional<Tensor<T1>> x_zero_point, Optional<Long> axis, Optional<Long> block_size) {\n-        Object result = OnnxInterpreter.interpret(OnnxOps.DequantizeLinear.class, List.of(x, x_scale, x_zero_point), List.of(axis, block_size));\n-        return (Tensor<T2>) result;\n+    public static <T1, T2, T3> Tensor<T3> DequantizeLinear(Tensor<T1> x, Tensor<T2> x_scale, Optional<Tensor<T1>> x_zero_point, Optional<Long> output_dtype, Optional<Long> axis, Optional<Long> block_size) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.DequantizeLinear.class, List.of(x, x_scale, x_zero_point), List.of(output_dtype, axis, block_size));\n+        return (Tensor<T3>) result;\n@@ -726,3 +733,8 @@\n-    public static <T1, T2> Tensor<T2> QuantizeLinear(Tensor<T1> x, Tensor<T1> y_scale, Optional<Tensor<T2>> y_zero_point, Optional<Long> output_dtype, Optional<Long> saturate, Optional<Long> axis, Optional<Long> block_size) {\n-        Object result = OnnxInterpreter.interpret(OnnxOps.QuantizeLinear.class, List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, axis, block_size));\n-        return (Tensor<T2>) result;\n+    public static <T1, T2, T3> Tensor<T3> QuantizeLinear(Tensor<T1> x, Tensor<T2> y_scale, Optional<Tensor<T3>> y_zero_point, Optional<Long> output_dtype, Optional<Long> saturate, Optional<Long> precision, Optional<Long> axis, Optional<Long> block_size) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.QuantizeLinear.class, List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, precision, axis, block_size));\n+        return (Tensor<T3>) result;\n+    }\n+\n+    public static <T, V> Tensor<V> RMSNormalization(Tensor<T> X, Tensor<V> scale, Optional<Float> epsilon, Optional<Long> stash_type, Optional<Long> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RMSNormalization.class, List.of(X, scale), List.of(epsilon, stash_type, axis));\n+        return (Tensor<V>) result;\n@@ -848,0 +860,5 @@\n+    public static <T> Tensor<T> RotaryEmbedding(Tensor<T> X, Tensor<T> cos_cache, Tensor<T> sin_cache, Optional<Tensor<Long>> position_ids, Optional<Long> num_heads, Optional<Long> rotary_embedding_dim, Optional<Long> interleaved) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.RotaryEmbedding.class, List.of(X, cos_cache, sin_cache, position_ids), List.of(num_heads, rotary_embedding_dim, interleaved));\n+        return (Tensor<T>) result;\n+    }\n+\n@@ -1039,0 +1056,5 @@\n+    public static <T> Tensor<T> Swish(Tensor<T> X, Optional<Float> alpha) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.Swish.class, List.of(X), List.of(alpha));\n+        return (Tensor<T>) result;\n+    }\n+\n@@ -1049,0 +1071,5 @@\n+    public static <T> Tensor<T> TensorScatter(Tensor<T> past_cache, Tensor<T> update, Optional<Tensor<Long>> write_indices, Optional<String> mode, Optional<Long> axis) {\n+        Object result = OnnxInterpreter.interpret(OnnxOps.TensorScatter.class, List.of(past_cache, update, write_indices), List.of(mode, axis));\n+        return (Tensor<T>) result;\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxOperators.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+package oracle.code.onnx;\n+\n+import java.util.Map;\n+\n+public record OnnxProvider(String name, Map<String, String> options) { }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProvider.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+\n@@ -61,0 +62,5 @@\n+    static final JavaType TENSOR_RAW_TYPE = JavaType.type(Tensor.class);\n+    static final JavaType LIST_RAW_TYPE = JavaType.type(List.class);\n+    private static final CachedSessionClassValue SESSION_CACHE = new CachedSessionClassValue();\n+    private static final String LOG_ID = \"onnx-ffm-java\";\n+    private static OnnxRuntime INSTANCE;\n@@ -92,2 +98,13 @@\n-    @FunctionalInterface\n-    public interface OnnxFunction<T> extends Supplier<T>, Quotable {\n+    private final MemorySegment runtimeAddress, ret, envAddress, defaultAllocatorAddress;\n+\n+    private OnnxRuntime() {\n+        var arena = Arena.ofAuto();\n+        ret = arena.allocate(C_POINTER);\n+        \/\/  const OrtApi* ortPtr = OrtGetApiBase()->GetApi((uint32_t)apiVersion);\n+        var apiBase = OrtApiBase.reinterpret(OrtGetApiBase(), arena, null);\n+        runtimeAddress = OrtApi.reinterpret(OrtApiBase.GetApi.invoke(OrtApiBase.GetApi(apiBase), ORT_API_VERSION()), arena, null);\n+        envAddress = retAddr(OrtApi.CreateEnv.invoke(OrtApi.CreateEnv(runtimeAddress), ORT_LOGGING_LEVEL_ERROR(), arena.allocateFrom(LOG_ID), ret));\n+        defaultAllocatorAddress = retAddr(OrtApi.GetAllocatorWithDefaultOptions.invoke(OrtApi.GetAllocatorWithDefaultOptions(runtimeAddress), ret)).reinterpret(arena, null);\n+        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+            OrtApi.ReleaseEnv.invoke(OrtApi.ReleaseEnv(runtimeAddress), envAddress);\n+        }));\n@@ -114,56 +131,0 @@\n-    record SessionWithReturnType(Session session, TypeElement returnType) {}\n-\n-    static class CachedSessionClassValue extends ClassValue<SessionWithReturnType> {\n-\n-        private MethodHandles.Lookup l;\n-        private Quoted q;\n-        private SessionOptions options;\n-\n-        \/\/ Static helper for cache with options\n-        protected SessionWithReturnType computeIfAbsent(\n-                Class<?> lambdaClass, MethodHandles.Lookup l, Quoted q, SessionOptions options) {\n-            try {\n-                this.l = l;\n-                this.q = q;\n-                this.options = options;\n-                \/\/ not very nice way to pass additional arguments to computeValue method\n-                return get(lambdaClass);\n-            } finally {\n-                this.l = null;\n-                this.q = null;\n-                this.options = null;\n-            }\n-        }\n-\n-        @Override\n-        protected SessionWithReturnType computeValue(Class<?> type) {\n-            OnnxTransformer.ModuleAndInitializers mi = OnnxTransformer.transform(l, q);\n-\n-            String domainName = type.getSimpleName().split(\"\\\\$\")[0];\n-            byte[] protobufModel = OnnxProtoBuilder.buildModel(domainName, mi.module(), getInitValues(l, mi.initializers(), q.capturedValues().sequencedValues()));\n-\n-            if (DEBUG) {\n-                System.out.println(mi.module().toText());\n-\/\/                System.out.println(OnnxModel.readFrom(protobufModel).toText());\n-                try {\n-                    var export = Path.of(domainName + \".onnx\");\n-                    Files.write(export, protobufModel);\n-                    System.out.println(\"Onnx model exported to: \" + export.toAbsolutePath());\n-                } catch (IOException _) {}\n-            }\n-\n-            \/\/ cached session must be created under its own auto arena\n-            Session session = (options != null) ?\n-                    getInstance().createSession(Arena.ofAuto(), protobufModel, options) :\n-                    getInstance().createSession(Arena.ofAuto(), protobufModel);\n-\n-            return new SessionWithReturnType(\n-                    session,\n-                    mi.module().functionTable().lastEntry().getValue().invokableType().returnType());\n-\n-\n-        }\n-    }\n-\n-    private static final CachedSessionClassValue SESSION_CACHE = new CachedSessionClassValue();\n-\n@@ -178,1 +139,0 @@\n-\n@@ -184,5 +144,6 @@\n-                for (var rc : r.getClass().getRecordComponents()) try {\n-                    expandArg(rc.getAccessor().invoke(r), args);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new IllegalStateException(e);\n-                }\n+                for (var rc : r.getClass().getRecordComponents())\n+                    try {\n+                        expandArg(rc.getAccessor().invoke(r), args);\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new IllegalStateException(e);\n+                    }\n@@ -215,1 +176,1 @@\n-        var lambdaOp = ((JavaOp.LambdaOp)q.op());\n+        var lambdaOp = ((JavaOp.LambdaOp) q.op());\n@@ -245,1 +206,0 @@\n-\n@@ -256,3 +216,0 @@\n-    static final JavaType TENSOR_RAW_TYPE = JavaType.type(Tensor.class);\n-    static final JavaType LIST_RAW_TYPE = JavaType.type(List.class);\n-\n@@ -266,16 +223,25 @@\n-    private static final String LOG_ID = \"onnx-ffm-java\";\n-    private static OnnxRuntime INSTANCE;\n-\n-    private final MemorySegment runtimeAddress, ret, envAddress, defaultAllocatorAddress;\n-\n-    private OnnxRuntime() {\n-        var arena = Arena.ofAuto();\n-        ret = arena.allocate(C_POINTER);\n-        \/\/  const OrtApi* ortPtr = OrtGetApiBase()->GetApi((uint32_t)apiVersion);\n-        var apiBase = OrtApiBase.reinterpret(OrtGetApiBase(), arena, null);\n-        runtimeAddress = OrtApi.reinterpret(OrtApiBase.GetApi(apiBase, ORT_API_VERSION()), arena, null);\n-        envAddress = retAddr(OrtApi.CreateEnv(runtimeAddress, ORT_LOGGING_LEVEL_ERROR(), arena.allocateFrom(LOG_ID), ret));\n-        defaultAllocatorAddress = retAddr(OrtApi.GetAllocatorWithDefaultOptions(runtimeAddress, ret)).reinterpret(arena, null);\n-        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n-            OrtApi.ReleaseEnv(runtimeAddress, envAddress);\n-        }));\n+    private static MemorySegment autoShape(Arena arena, long[] shape, long elementsCount) {\n+        int auto = -1;\n+        long elCount = 1;\n+        for (int i = 0; i < shape.length; i++) {\n+            long dim = shape[i];\n+            if (dim == -1) {\n+                if (auto == -1) {\n+                    auto = i;\n+                } else {\n+                    throw new IllegalArgumentException(\"Multiple automatic dimensions in shape\");\n+                }\n+            } else {\n+                elCount *= dim;\n+            }\n+        }\n+        var ms = arena.allocateFrom(C_LONG_LONG, shape);\n+        if (auto != -1) {\n+            long autoDim = elementsCount \/ elCount;\n+            ms.setAtIndex(C_LONG, auto, autoDim);\n+            elCount *= autoDim;\n+        }\n+        if (elCount != elementsCount) {\n+            throw new IllegalArgumentException(\"Tensor shape does not match data\");\n+        }\n+        return ms;\n@@ -310,1 +276,1 @@\n-        return new Session(arena, retAddr(OrtApi.CreateSession(runtimeAddress, envAddress, arena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)));\n+        return new Session(arena, retAddr(OrtApi.CreateSession.invoke(OrtApi.CreateSession(runtimeAddress), envAddress, arena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)));\n@@ -318,1 +284,214 @@\n-        return new Session(arena, retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, arena.allocateFrom(ValueLayout.JAVA_BYTE, model), model.length, options.sessionOptionsAddress, ret)));\n+        return new Session(arena, retAddr(OrtApi.CreateSessionFromArray.invoke(OrtApi.CreateSessionFromArray(runtimeAddress), envAddress, arena.allocateFrom(ValueLayout.JAVA_BYTE, model), model.length, options.sessionOptionsAddress, ret)));\n+    }\n+\n+    public MemorySegment createTensor(Arena arena, MemorySegment flatData, Tensor.ElementType elementType, long[] shape) {\n+        var allocatorInfo = retAddr(OrtApi.AllocatorGetInfo.invoke(OrtApi.AllocatorGetInfo(runtimeAddress), defaultAllocatorAddress, ret));\n+        return retAddr(OrtApi.CreateTensorWithDataAsOrtValue.invoke(\n+                OrtApi.CreateTensorWithDataAsOrtValue(runtimeAddress),\n+                allocatorInfo,\n+                flatData, flatData.byteSize(),\n+                shape.length == 0 ? MemorySegment.NULL : autoShape(arena, shape, 8l * flatData.byteSize() \/ elementType.bitSize()), (long) shape.length,\n+                elementType.id,\n+                ret)).reinterpret(arena, value -> OrtApi.ReleaseValue.invoke(OrtApi.ReleaseValue(runtimeAddress), value));\n+    }\n+\n+    public Tensor.ElementType tensorElementType(MemorySegment tensorAddr) {\n+        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape.invoke(OrtApi.GetTensorTypeAndShape(runtimeAddress), tensorAddr, ret));\n+        return Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType.invoke(OrtApi.GetTensorElementType(runtimeAddress), infoAddr, ret)));\n+    }\n+\n+    public long[] tensorShape(MemorySegment tensorAddr) {\n+        try (var arena = Arena.ofConfined()) {\n+            var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape.invoke(OrtApi.GetTensorTypeAndShape(runtimeAddress), tensorAddr, ret));\n+            long dims = retLong(OrtApi.GetDimensionsCount.invoke(OrtApi.GetDimensionsCount(runtimeAddress), infoAddr, ret));\n+            var shape = arena.allocate(C_LONG_LONG, dims);\n+            checkStatus(OrtApi.GetDimensions.invoke(OrtApi.GetDimensions(runtimeAddress), infoAddr, shape, dims));\n+            return shape.toArray(C_LONG_LONG);\n+        }\n+    }\n+\n+    public MemorySegment tensorData(MemorySegment tensorAddr) {\n+        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape.invoke(OrtApi.GetTensorTypeAndShape(runtimeAddress), tensorAddr, ret));\n+        long size = retLong(OrtApi.GetTensorShapeElementCount.invoke(OrtApi.GetTensorShapeElementCount(runtimeAddress), infoAddr, ret))\n+                * Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType.invoke(OrtApi.GetTensorElementType(runtimeAddress), infoAddr, ret))).bitSize() \/ 8;\n+        return retAddr(OrtApi.GetTensorMutableData.invoke(OrtApi.GetTensorMutableData(runtimeAddress), tensorAddr, ret))\n+                .reinterpret(size);\n+    }\n+\n+    public SessionOptions createSessionOptions(Arena arena) {\n+        return new SessionOptions(retAddr(OrtApi.CreateSessionOptions.invoke(OrtApi.CreateSessionOptions(runtimeAddress), ret))\n+                .reinterpret(arena, opts -> OrtApi.ReleaseSessionOptions.invoke(OrtApi.ReleaseSessionOptions(runtimeAddress), opts)));\n+    }\n+\n+    public void appendExecutionProvider(Arena arena, SessionOptions sessionOptions, OnnxProvider provider) {\n+        ExecutionProviderOptions executionProviderOptions = toNativeOptions(arena, provider);\n+\n+        MemorySegment funcPtr = OrtApi.SessionOptionsAppendExecutionProvider(runtimeAddress);\n+        var status = OrtApi.SessionOptionsAppendExecutionProvider.invoke(\n+                funcPtr,\n+                sessionOptions.getSessionOptionsAddress(),\n+                arena.allocateFrom(provider.name()),\n+                executionProviderOptions.keySegment, executionProviderOptions.valSegment, executionProviderOptions.size);\n+        checkStatus(status);\n+    }\n+\n+    public void appendExecutionProvider_V2(Arena arena, SessionOptions sessionOptions, OnnxProvider provider) {\n+        MemorySegment getEpDevicesFn = OrtApi.GetEpDevices(runtimeAddress);\n+        MemorySegment devicesOut = arena.allocate(ValueLayout.ADDRESS);\n+        MemorySegment countOut = arena.allocate(ValueLayout.JAVA_LONG);\n+        checkStatus(OrtApi.GetEpDevices.invoke(getEpDevicesFn, envAddress, devicesOut, countOut));\n+        long numDevices = countOut.get(ValueLayout.JAVA_LONG, 0);\n+\n+        MemorySegment devicesBasePtr = devicesOut.get(ValueLayout.ADDRESS, 0);\n+        MemorySegment devicesArr = (numDevices > 0 && devicesBasePtr != MemorySegment.NULL)\n+                ? devicesBasePtr.reinterpret(numDevices * ValueLayout.ADDRESS.byteSize())\n+                : MemorySegment.NULL;\n+\n+        String target = provider.name();\n+        var matches = new java.util.ArrayList<MemorySegment>();\n+        if (devicesArr != MemorySegment.NULL) {\n+            MemorySegment epNameFn = OrtApi.EpDevice_EpName(runtimeAddress);\n+            for (int j = 0; j < numDevices; j++) {\n+                MemorySegment dev = devicesArr.getAtIndex(ValueLayout.ADDRESS, j);\n+                MemorySegment cstr = OrtApi.EpDevice_EpName.invoke(epNameFn, dev);\n+                String epName = (cstr == MemorySegment.NULL) ? \"\" : cstr.getString(0);\n+                if (target.equals(epName)) matches.add(dev);\n+            }\n+        }\n+\n+        if (matches.isEmpty()) {\n+            appendExecutionProvider(arena, sessionOptions, provider);\n+        } else {\n+            ExecutionProviderOptions executionProviderOptions = toNativeOptions(arena, provider);\n+\n+            long deviceCount = matches.size();\n+            MemorySegment deviceArrayPtr = arena.allocate(ValueLayout.ADDRESS, deviceCount);\n+            for (int j = 0; j < matches.size(); j++)\n+                deviceArrayPtr.setAtIndex(ValueLayout.ADDRESS, j, matches.get(j));\n+\n+            MemorySegment functionPtr = OrtApi.SessionOptionsAppendExecutionProvider_V2(runtimeAddress);\n+            checkStatus(OrtApi.SessionOptionsAppendExecutionProvider_V2.invoke(\n+                    functionPtr,\n+                    sessionOptions.getSessionOptionsAddress(),\n+                    envAddress,\n+                    deviceArrayPtr, deviceCount,\n+                    executionProviderOptions.keySegment(), executionProviderOptions.valSegment(), executionProviderOptions.size()\n+            ));\n+        }\n+    }\n+\n+    private static ExecutionProviderOptions toNativeOptions(Arena arena, OnnxProvider provider) {\n+        var providerOptions = provider.options();\n+        MemorySegment keySegment = MemorySegment.NULL;\n+        MemorySegment valSegment = MemorySegment.NULL;\n+        int size = 0;\n+\n+        if (Objects.nonNull(providerOptions) && !providerOptions.isEmpty()) {\n+            size = providerOptions.size();\n+            keySegment = arena.allocate(ValueLayout.ADDRESS, size);\n+            valSegment = arena.allocate(ValueLayout.ADDRESS, size);\n+            int i = 0;\n+\n+            for (Map.Entry<String, String> e : providerOptions.entrySet()) {\n+                keySegment.setAtIndex(ValueLayout.ADDRESS, i, arena.allocateFrom(e.getKey()));\n+                valSegment.setAtIndex(ValueLayout.ADDRESS, i, arena.allocateFrom(e.getValue()));\n+                i++;\n+            }\n+        }\n+        ExecutionProviderOptions executionProviderOptions = new ExecutionProviderOptions(keySegment, valSegment, size);\n+        return executionProviderOptions;\n+    }\n+\n+    private record ExecutionProviderOptions(MemorySegment keySegment, MemorySegment valSegment, int size) {}\n+\n+    private MemorySegment retAddr(MemorySegment res) {\n+        checkStatus(res);\n+        return ret.get(C_POINTER, 0);\n+    }\n+\n+    private int retInt(MemorySegment res) {\n+        checkStatus(res);\n+        return ret.get(C_INT, 0);\n+    }\n+\n+    private long retLong(MemorySegment res) {\n+        checkStatus(res);\n+        return ret.get(C_LONG_LONG, 0);\n+    }\n+\n+    private String retString(MemorySegment res) {\n+        return retAddr(res).reinterpret(Long.MAX_VALUE)\n+                .getString(0);\n+    }\n+\n+    private void checkStatus(MemorySegment status) {\n+        try {\n+            if (!status.equals(MemorySegment.NULL)) {\n+                status = status.reinterpret(Long.MAX_VALUE);\n+                if (status.get(C_INT, 0) != 0) {\n+                    throw new RuntimeException(status.getString(C_INT.byteSize()));\n+                }\n+            }\n+        } finally {\n+            OrtApi.ReleaseStatus.invoke(OrtApi.ReleaseStatus(runtimeAddress), status);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    public interface OnnxFunction<T> extends Supplier<T>, Quotable {\n+    }\n+\n+    record SessionWithReturnType(Session session, TypeElement returnType) {\n+    }\n+\n+    static class CachedSessionClassValue extends ClassValue<SessionWithReturnType> {\n+\n+        private MethodHandles.Lookup l;\n+        private Quoted q;\n+        private SessionOptions options;\n+\n+        \/\/ Static helper for cache with options\n+        protected SessionWithReturnType computeIfAbsent(\n+                Class<?> lambdaClass, MethodHandles.Lookup l, Quoted q, SessionOptions options) {\n+            try {\n+                this.l = l;\n+                this.q = q;\n+                this.options = options;\n+                \/\/ not very nice way to pass additional arguments to computeValue method\n+                return get(lambdaClass);\n+            } finally {\n+                this.l = null;\n+                this.q = null;\n+                this.options = null;\n+            }\n+        }\n+\n+        @Override\n+        protected SessionWithReturnType computeValue(Class<?> type) {\n+            OnnxTransformer.ModuleAndInitializers mi = OnnxTransformer.transform(l, q);\n+\n+            String domainName = type.getSimpleName().split(\"\\\\$\")[0];\n+            byte[] protobufModel = OnnxProtoBuilder.buildModel(domainName, mi.module(), getInitValues(l, mi.initializers(), q.capturedValues().sequencedValues()));\n+\n+            if (DEBUG) {\n+                System.out.println(mi.module().toText());\n+\/\/                System.out.println(OnnxModel.readFrom(protobufModel).toText());\n+                try {\n+                    var export = Path.of(domainName + \".onnx\");\n+                    Files.write(export, protobufModel);\n+                    System.out.println(\"Onnx model exported to: \" + export.toAbsolutePath());\n+                } catch (IOException _) {\n+                }\n+            }\n+\n+            \/\/ cached session must be created under its own auto arena\n+            Session session = (options != null) ?\n+                    getInstance().createSession(Arena.ofAuto(), protobufModel, options) :\n+                    getInstance().createSession(Arena.ofAuto(), protobufModel);\n+\n+            return new SessionWithReturnType(\n+                    session,\n+                    mi.module().functionTable().lastEntry().getValue().invokableType().returnType());\n+\n+\n+        }\n@@ -327,1 +506,1 @@\n-                    session -> OrtApi.ReleaseSession(runtimeAddress, session));\n+                    session -> OrtApi.ReleaseSession.invoke(OrtApi.ReleaseSession(runtimeAddress), session));\n@@ -331,1 +510,1 @@\n-            return retInt(OrtApi.SessionGetInputCount(runtimeAddress, sessionAddress, ret));\n+            return retInt(OrtApi.SessionGetInputCount.invoke(OrtApi.SessionGetInputCount(runtimeAddress), sessionAddress, ret));\n@@ -335,1 +514,1 @@\n-            return retString(OrtApi.SessionGetInputName(runtimeAddress, sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n+            return retString(OrtApi.SessionGetInputName.invoke(OrtApi.SessionGetInputName(runtimeAddress), sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n@@ -339,1 +518,1 @@\n-            return retInt(OrtApi.SessionGetOutputCount(runtimeAddress, sessionAddress, ret));\n+            return retInt(OrtApi.SessionGetOutputCount.invoke(OrtApi.SessionGetOutputCount(runtimeAddress), sessionAddress, ret));\n@@ -343,1 +522,1 @@\n-            return retString(OrtApi.SessionGetOutputName(runtimeAddress, sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n+            return retString(OrtApi.SessionGetOutputName.invoke(OrtApi.SessionGetOutputName(runtimeAddress), sessionAddress, inputIndex, defaultAllocatorAddress, ret));\n@@ -364,1 +543,1 @@\n-            checkStatus(OrtApi.Run(runtimeAddress, sessionAddress, runOptions, inputNames, inputs, (long)inputLen, outputNames, (long)outputLen, outputs));\n+            checkStatus(OrtApi.Run.invoke(OrtApi.Run(runtimeAddress), sessionAddress, runOptions, inputNames, inputs, (long) inputLen, outputNames, (long) outputLen, outputs));\n@@ -368,1 +547,1 @@\n-                        .reinterpret(arena, value -> OrtApi.ReleaseValue(runtimeAddress, value));\n+                        .reinterpret(arena, value -> OrtApi.ReleaseValue.invoke(OrtApi.ReleaseValue(runtimeAddress), value));\n@@ -370,1 +549,1 @@\n-                                       tensorAddr);\n+                        tensorAddr);\n@@ -376,66 +555,0 @@\n-    public MemorySegment createTensor(Arena arena, MemorySegment flatData, Tensor.ElementType elementType, long[] shape) {\n-        var allocatorInfo = retAddr(OrtApi.AllocatorGetInfo(runtimeAddress, defaultAllocatorAddress, ret));\n-        return retAddr(OrtApi.CreateTensorWithDataAsOrtValue(\n-                runtimeAddress,\n-                allocatorInfo,\n-                flatData, flatData.byteSize(),\n-                shape.length == 0 ? MemorySegment.NULL : autoShape(arena, shape, 8l * flatData.byteSize() \/ elementType.bitSize()), (long)shape.length,\n-                elementType.id,\n-                ret)).reinterpret(arena, value -> OrtApi.ReleaseValue(runtimeAddress, value));\n-    }\n-\n-    private static MemorySegment autoShape(Arena arena, long[] shape, long elementsCount) {\n-        int auto = -1;\n-        long elCount = 1;\n-        for (int i = 0; i < shape.length; i++) {\n-            long dim = shape[i];\n-            if (dim == -1) {\n-                if (auto == -1) {\n-                    auto = i;\n-                } else {\n-                    throw new IllegalArgumentException(\"Multiple automatic dimensions in shape\");\n-                }\n-            } else {\n-                elCount *= dim;\n-            }\n-        }\n-        var ms = arena.allocateFrom(C_LONG_LONG, shape);\n-        if (auto != -1) {\n-            long autoDim = elementsCount \/ elCount;\n-            ms.setAtIndex(C_LONG, auto, autoDim);\n-            elCount *= autoDim;\n-        }\n-        if (elCount != elementsCount) {\n-            throw new IllegalArgumentException(\"Tensor shape does not match data\");\n-        }\n-        return ms;\n-    }\n-\n-    public Tensor.ElementType tensorElementType(MemorySegment tensorAddr) {\n-        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n-        return Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType(runtimeAddress, infoAddr, ret)));\n-    }\n-\n-    public long[] tensorShape(MemorySegment tensorAddr) {\n-        try (var arena = Arena.ofConfined()) {\n-            var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n-            long dims = retLong(OrtApi.GetDimensionsCount(runtimeAddress, infoAddr, ret));\n-            var shape = arena.allocate(C_LONG_LONG, dims);\n-            checkStatus(OrtApi.GetDimensions(runtimeAddress, infoAddr, shape, dims));\n-            return shape.toArray(C_LONG_LONG);\n-        }\n-    }\n-\n-    public MemorySegment tensorData(MemorySegment tensorAddr) {\n-        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n-        long size = retLong(OrtApi.GetTensorShapeElementCount(runtimeAddress, infoAddr, ret))\n-                * Tensor.ElementType.fromOnnxId(retInt(OrtApi.GetTensorElementType(runtimeAddress, infoAddr, ret))).bitSize() \/ 8;\n-        return retAddr(OrtApi.GetTensorMutableData(runtimeAddress, tensorAddr, ret))\n-                .reinterpret(size);\n-    }\n-\n-    public SessionOptions createSessionOptions(Arena arena) {\n-        return new SessionOptions(retAddr(OrtApi.CreateSessionOptions(runtimeAddress, ret))\n-                .reinterpret(arena, opts -> OrtApi.ReleaseSessionOptions(runtimeAddress, opts)));\n-    }\n-\n@@ -452,1 +565,1 @@\n-            checkStatus(OrtApi.SetInterOpNumThreads(runtimeAddress, sessionOptionsAddress, numThreads));\n+            checkStatus(OrtApi.SetInterOpNumThreads.invoke(OrtApi.SetInterOpNumThreads(runtimeAddress), sessionOptionsAddress, numThreads));\n@@ -455,2 +568,2 @@\n-        public MemorySegment getSessionOptionsAddress() {\n-            return sessionOptionsAddress;\n+        public void setIntraOpNumThreads(int numThreads) {\n+            checkStatus(OrtApi.SetIntraOpNumThreads.invoke(OrtApi.SetIntraOpNumThreads(runtimeAddress), sessionOptionsAddress, numThreads));\n@@ -458,16 +571,0 @@\n-    }\n-\n-    private MemorySegment retAddr(MemorySegment res) {\n-        checkStatus(res);\n-        return ret.get(C_POINTER, 0);\n-    }\n-\n-    private int retInt(MemorySegment res) {\n-        checkStatus(res);\n-        return ret.get(C_INT, 0);\n-    }\n-\n-    private long retLong(MemorySegment res) {\n-        checkStatus(res);\n-        return ret.get(C_LONG_LONG, 0);\n-    }\n@@ -475,4 +572,3 @@\n-    private String retString(MemorySegment res) {\n-        return retAddr(res).reinterpret(Long.MAX_VALUE)\n-                .getString(0);\n-    }\n+        public void setSessionExecutionMode(int executionMode) {\n+            checkStatus(OrtApi.SetSessionExecutionMode.invoke(OrtApi.SetSessionExecutionMode(runtimeAddress), sessionOptionsAddress, executionMode));\n+        }\n@@ -480,10 +576,2 @@\n-    private void checkStatus(MemorySegment status) {\n-        try {\n-            if (!status.equals(MemorySegment.NULL)) {\n-                status = status.reinterpret(Long.MAX_VALUE);\n-                if (status.get(C_INT, 0) != 0) {\n-                    throw new RuntimeException(status.getString(C_INT.byteSize()));\n-                }\n-            }\n-        } finally {\n-            OrtApi.ReleaseStatus(runtimeAddress, status);\n+        public MemorySegment getSessionOptionsAddress() {\n+            return sessionOptionsAddress;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":282,"deletions":194,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef OrtStatus *(*EpSelectionDelegate)(const OrtEpDevice **, size_t, const OrtKeyValuePairs *, const OrtKeyValuePairs *, const OrtEpDevice **, size_t, size_t *, void *)\n+ * }\n+ *\/\n+public class EpSelectionDelegate {\n+\n+    EpSelectionDelegate() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        MemorySegment apply(MemorySegment ep_devices, long num_devices, MemorySegment model_metadata, MemorySegment runtime_metadata, MemorySegment selected, long max_selected, MemorySegment num_selected, MemorySegment state);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_LONG,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_LONG,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(EpSelectionDelegate.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(EpSelectionDelegate.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment ep_devices, long num_devices, MemorySegment model_metadata, MemorySegment runtime_metadata, MemorySegment selected, long max_selected, MemorySegment num_selected, MemorySegment state) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, ep_devices, num_devices, model_metadata, runtime_metadata, selected, max_selected, num_selected, state);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/EpSelectionDelegate.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,733 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtAllocator {\n+ *     uint32_t version;\n+ *     void *(*Alloc)(struct OrtAllocator *, size_t);\n+ *     void (*Free)(struct OrtAllocator *, void *);\n+ *     const struct OrtMemoryInfo *(*Info)(const struct OrtAllocator *);\n+ *     void *(*Reserve)(struct OrtAllocator *, size_t);\n+ *     OrtStatusPtr (*GetStats)(const struct OrtAllocator *, OrtKeyValuePairs **);\n+ *     void *(*AllocOnStream)(struct OrtAllocator *, size_t, OrtSyncStream *);\n+ * }\n+ * }\n+ *\/\n+public class OrtAllocator {\n+\n+    OrtAllocator() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_INT.withName(\"version\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Alloc\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Free\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Info\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"Reserve\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetStats\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AllocOnStream\")\n+    ).withName(\"OrtAllocator\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"version\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static final OfInt version$layout() {\n+        return version$LAYOUT;\n+    }\n+\n+    private static final long version$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static final long version$offset() {\n+        return version$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static int version(MemorySegment struct) {\n+        return struct.get(version$LAYOUT, version$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static void version(MemorySegment struct, int fieldValue) {\n+        struct.set(version$LAYOUT, version$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void *(*Alloc)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static class Alloc {\n+\n+        Alloc() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Alloc.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Alloc.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Alloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Alloc\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *(*Alloc)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout Alloc$layout() {\n+        return Alloc$LAYOUT;\n+    }\n+\n+    private static final long Alloc$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *(*Alloc)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static final long Alloc$offset() {\n+        return Alloc$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *(*Alloc)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Alloc(MemorySegment struct) {\n+        return struct.get(Alloc$LAYOUT, Alloc$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *(*Alloc)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static void Alloc(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Alloc$LAYOUT, Alloc$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*Free)(struct OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static class Free {\n+\n+        Free() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Free.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Free.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Free$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Free\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*Free)(struct OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout Free$layout() {\n+        return Free$LAYOUT;\n+    }\n+\n+    private static final long Free$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*Free)(struct OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static final long Free$offset() {\n+        return Free$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*Free)(struct OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment Free(MemorySegment struct) {\n+        return struct.get(Free$LAYOUT, Free$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*Free)(struct OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static void Free(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Free$LAYOUT, Free$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const struct OrtMemoryInfo *(*Info)(const struct OrtAllocator *)\n+     * }\n+     *\/\n+    public static class Info {\n+\n+        Info() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Info.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Info.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Info$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Info\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const struct OrtMemoryInfo *(*Info)(const struct OrtAllocator *)\n+     * }\n+     *\/\n+    public static final AddressLayout Info$layout() {\n+        return Info$LAYOUT;\n+    }\n+\n+    private static final long Info$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const struct OrtMemoryInfo *(*Info)(const struct OrtAllocator *)\n+     * }\n+     *\/\n+    public static final long Info$offset() {\n+        return Info$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const struct OrtMemoryInfo *(*Info)(const struct OrtAllocator *)\n+     * }\n+     *\/\n+    public static MemorySegment Info(MemorySegment struct) {\n+        return struct.get(Info$LAYOUT, Info$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const struct OrtMemoryInfo *(*Info)(const struct OrtAllocator *)\n+     * }\n+     *\/\n+    public static void Info(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Info$LAYOUT, Info$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void *(*Reserve)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static class Reserve {\n+\n+        Reserve() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(Reserve.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Reserve.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Reserve$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Reserve\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *(*Reserve)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout Reserve$layout() {\n+        return Reserve$LAYOUT;\n+    }\n+\n+    private static final long Reserve$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *(*Reserve)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static final long Reserve$offset() {\n+        return Reserve$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *(*Reserve)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Reserve(MemorySegment struct) {\n+        return struct.get(Reserve$LAYOUT, Reserve$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *(*Reserve)(struct OrtAllocator *, size_t)\n+     * }\n+     *\/\n+    public static void Reserve(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Reserve$LAYOUT, Reserve$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStats)(const struct OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static class GetStats {\n+\n+        GetStats() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStats.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetStats.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStats$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStats\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStats)(const struct OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetStats$layout() {\n+        return GetStats$LAYOUT;\n+    }\n+\n+    private static final long GetStats$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStats)(const struct OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static final long GetStats$offset() {\n+        return GetStats$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStats)(const struct OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static MemorySegment GetStats(MemorySegment struct) {\n+        return struct.get(GetStats$LAYOUT, GetStats$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStats)(const struct OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static void GetStats(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetStats$LAYOUT, GetStats$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void *(*AllocOnStream)(struct OrtAllocator *, size_t, OrtSyncStream *)\n+     * }\n+     *\/\n+    public static class AllocOnStream {\n+\n+        AllocOnStream() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AllocOnStream.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AllocOnStream.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocOnStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocOnStream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *(*AllocOnStream)(struct OrtAllocator *, size_t, OrtSyncStream *)\n+     * }\n+     *\/\n+    public static final AddressLayout AllocOnStream$layout() {\n+        return AllocOnStream$LAYOUT;\n+    }\n+\n+    private static final long AllocOnStream$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *(*AllocOnStream)(struct OrtAllocator *, size_t, OrtSyncStream *)\n+     * }\n+     *\/\n+    public static final long AllocOnStream$offset() {\n+        return AllocOnStream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *(*AllocOnStream)(struct OrtAllocator *, size_t, OrtSyncStream *)\n+     * }\n+     *\/\n+    public static MemorySegment AllocOnStream(MemorySegment struct) {\n+        return struct.get(AllocOnStream$LAYOUT, AllocOnStream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *(*AllocOnStream)(struct OrtAllocator *, size_t, OrtSyncStream *)\n+     * }\n+     *\/\n+    public static void AllocOnStream(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AllocOnStream$LAYOUT, AllocOnStream$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtAllocator.java","additions":733,"deletions":0,"binary":false,"changes":733,"status":"added"},{"patch":"@@ -7,0 +7,1 @@\n+import java.util.*;\n@@ -8,0 +9,1 @@\n+import java.util.stream.*;\n@@ -299,0 +301,106 @@\n+ *     void (*ReleaseValueInfo)(OrtValueInfo *);\n+ *     void (*ReleaseNode)(OrtNode *);\n+ *     void (*ReleaseGraph)(OrtGraph *);\n+ *     void (*ReleaseModel)(OrtModel *);\n+ *     OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **);\n+ *     OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **);\n+ *     const OrtModelEditorApi *(*GetModelEditorApi)(void);\n+ *     OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **);\n+ *     OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool);\n+ *     const OrtCompileApi *(*GetCompileApi)(void);\n+ *     void (*CreateKeyValuePairs)(OrtKeyValuePairs **);\n+ *     void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *);\n+ *     const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *);\n+ *     void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *);\n+ *     void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *);\n+ *     void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *);\n+ *     OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *);\n+ *     OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *);\n+ *     OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *);\n+ *     OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t);\n+ *     OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy);\n+ *     OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *);\n+ *     OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *);\n+ *     uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *);\n+ *     const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *);\n+ *     uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *);\n+ *     const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *);\n+ *     const char *(*EpDevice_EpName)(const OrtEpDevice *);\n+ *     const char *(*EpDevice_EpVendor)(const OrtEpDevice *);\n+ *     const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *);\n+ *     const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *);\n+ *     const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *);\n+ *     const OrtEpApi *(*GetEpApi)(void);\n+ *     OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *);\n+ *     OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **);\n+ *     OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **);\n+ *     OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *);\n+ *     uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *);\n+ *     OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *);\n+ *     OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *);\n+ *     OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t);\n+ *     OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **);\n+ *     OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **);\n+ *     OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *);\n+ *     OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *);\n+ *     OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *);\n+ *     OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *);\n+ *     OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *);\n+ *     OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **);\n+ *     OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **);\n+ *     OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *);\n+ *     OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *);\n+ *     OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t);\n+ *     OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *);\n+ *     OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *);\n+ *     OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *);\n+ *     OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *);\n+ *     OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t);\n+ *     OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **);\n+ *     OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **);\n+ *     OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *);\n+ *     OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **);\n+ *     OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **);\n+ *     OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **);\n+ *     OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *);\n+ *     OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *);\n+ *     OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *);\n+ *     OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *);\n+ *     OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *);\n+ *     OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t);\n+ *     OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **);\n+ *     OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **);\n+ *     OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *);\n+ *     OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **);\n+ *     OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *);\n+ *     OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **);\n+ *     OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **);\n+ *     OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **);\n+ *     void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *);\n+ *     const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *);\n+ *     int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *);\n+ *     size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *);\n+ *     const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *);\n+ *     const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType);\n+ *     OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **);\n+ *     OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **);\n+ *     OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType);\n+ *     OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **);\n+ *     OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **);\n+ *     OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t);\n+ *     OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t);\n+ *     OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t);\n+ *     OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **);\n+ *     void *(*SyncStream_GetHandle)(OrtSyncStream *);\n+ *     void (*ReleaseSyncStream)(OrtSyncStream *);\n+ *     OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t);\n+ *     OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **);\n+ *     OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *);\n+ *     OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **);\n+ *     bool (*TensorTypeAndShape_HasShape)(const OrtTensorTypeAndShapeInfo *);\n@@ -309,285 +417,391 @@\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateStatus\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetErrorCode\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetErrorMessage\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnv\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnvWithCustomLogger\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"EnableTelemetryEvents\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"DisableTelemetryEvents\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSession\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionFromArray\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"Run\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetOptimizedModelFilePath\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CloneSessionOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionExecutionMode\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"EnableProfiling\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"DisableProfiling\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"EnableMemPattern\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"DisableMemPattern\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"EnableCpuMemArena\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"DisableCpuMemArena\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionLogId\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionLogVerbosityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionLogSeverityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetSessionGraphOptimizationLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetIntraOpNumThreads\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetInterOpNumThreads\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCustomOpDomain\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CustomOpDomain_Add\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddCustomOpDomain\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterCustomOpsLibrary\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetInputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOutputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOverridableInitializerCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetInputTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOutputTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOverridableInitializerTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetInputName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOutputName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOverridableInitializerName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateRunOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetRunLogVerbosityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetRunLogSeverityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetRunTag\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsGetRunLogVerbosityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsGetRunLogSeverityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsGetRunTag\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsSetTerminate\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsUnsetTerminate\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorAsOrtValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorWithDataAsOrtValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"IsTensor\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorMutableData\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"FillStringTensor\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorDataLength\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorContent\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToTensorInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetOnnxTypeFromTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorTypeAndShapeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetTensorElementType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetDimensions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorElementType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetDimensionsCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetDimensions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSymbolicDimensions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorShapeElementCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorTypeAndShape\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetValueType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateMemoryInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCpuMemoryInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CompareMemoryInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetId\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetMemType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AllocatorAlloc\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AllocatorFree\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AllocatorGetInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetAllocatorWithDefaultOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddFreeDimensionOverride\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetValueCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOpaqueValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetOpaqueValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_float\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_int64\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_string\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetInputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetOutputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetInput\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetOutput\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseEnv\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseStatus\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseMemoryInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseSession\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseRunOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseTensorTypeAndShapeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseSessionOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseCustomOpDomain\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetDenotationFromTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToMapTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToSequenceTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetMapKeyType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetMapValueType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSequenceElementType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseMapTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseSequenceTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionEndProfiling\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetModelMetadata\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetProducerName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetGraphName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetDomain\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetDescription\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataLookupCustomMetadataMap\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetVersion\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseModelMetadata\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnvWithGlobalThreadPools\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"DisablePerSessionThreads\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateThreadingOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseThreadingOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetCustomMetadataMapKeys\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddFreeDimensionOverrideByName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetAvailableProviders\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseAvailableProviders\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorElementLength\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetStringTensorElement\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"FillStringTensorElement\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddSessionConfigEntry\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunWithBinding\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateIoBinding\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseIoBinding\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"BindInput\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"BindOutput\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"BindOutputToDevice\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetBoundOutputNames\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetBoundOutputValues\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ClearBoundInputs\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ClearBoundOutputs\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"TensorAt\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateAndRegisterAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetLanguageProjection\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetProfilingStartTimeNs\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalIntraOpNumThreads\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalInterOpNumThreads\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalSpinControl\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddInitializer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CUDA\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_ROCM\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_OpenVINO\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalDenormalAsZero\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateArenaCfg\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseArenaCfg\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ModelMetadataGetGraphDescription\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_TensorRT\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetCurrentGpuDeviceId\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetCurrentGpuDeviceId\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttributeArray_float\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttributeArray_int64\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateArenaCfgV2\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddRunConfigEntry\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreatePrepackedWeightsContainer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleasePrepackedWeightsContainer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionWithPrepackedWeightsContainer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorRTProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateTensorRTProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorRTProviderOptionsAsString\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseTensorRTProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"EnableOrtCustomOps\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UnregisterAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"IsSparseTensor\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSparseTensorAsOrtValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"FillSparseTensorCoo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"FillSparseTensorCsr\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"FillSparseTensorBlockSparse\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSparseTensorWithValuesAsOrtValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UseCooIndices\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UseCsrIndices\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UseBlockSparseIndices\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorFormat\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorValuesTypeAndShape\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorValues\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorIndicesTypeShape\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSparseTensorIndices\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"HasValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetGPUComputeStream\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorMemoryInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetExecutionProviderApi\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsSetCustomCreateThreadFn\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsSetCustomThreadCreationOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsSetCustomJoinThreadFn\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalCustomCreateThreadFn\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalCustomThreadCreationOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalCustomJoinThreadFn\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SynchronizeBoundInputs\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SynchronizeBoundOutputs\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCUDAProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateCUDAProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetCUDAProviderOptionsAsString\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseCUDAProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_MIGraphX\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddExternalInitializers\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOpAttr\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseOpAttr\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOp\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"InvokeOp\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseOp\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CopyKernelInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseKernelInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTrainingApi\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CANN\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateCANNProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateCANNProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetCANNProviderOptionsAsString\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseCANNProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"MemoryInfoGetDeviceType\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateEnvWithCustomLogLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetGlobalIntraOpThreadAffinity\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterCustomOpsLibrary_V2\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RegisterCustomOpsUsingFunction\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetInputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetOutputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetInputName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetOutputName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetInputTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetOutputTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAttribute_tensor\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"HasSessionConfigEntry\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetSessionConfigEntry\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_Dnnl\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateDnnlProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateDnnlProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetDnnlProviderOptionsAsString\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseDnnlProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetNodeName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfo_GetLogger\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetLogger\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"Logger_LogMessage\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"Logger_GetLoggingSeverityLevel\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetConstantInput_tensor\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CastTypeInfoToOptionalTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetOptionalContainedTypeInfo\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetResizedStringTensorElementBuffer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetBuildInfoString\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateROCMProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateROCMProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetROCMProviderOptionsAsString\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseROCMProviderOptions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateAndRegisterAllocatorV2\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunAsync\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateTensorRTProviderOptionsWithValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetTensorRTProviderOptionsByName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"UpdateCUDAProviderOptionsWithValue\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"GetCUDAProviderOptionsByName\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetResource\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetUserLoggingFunction\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_GetInputCount\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_GetInputTypeShape\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_GetAttribute\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ShapeInferContext_SetOutputTypeShape\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetSymbolicDimensions\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReadOpAttr\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetDeterministicCompute\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_ParallelFor\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_VitisAI\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelContext_GetScratchBuffer\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"KernelInfoGetAllocator\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"AddExternalInitializersFromFilesInMemory\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateLoraAdapter\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"CreateLoraAdapterFromArray\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseLoraAdapter\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"RunOptionsAddActiveLoraAdapter\"),\n-        onnxruntime_c_api_h.C_POINTER.withName(\"SetEpDynamicOptions\")\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateStatus\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetErrorCode\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetErrorMessage\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateEnv\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateEnvWithCustomLogger\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EnableTelemetryEvents\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"DisableTelemetryEvents\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSession\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSessionFromArray\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Run\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSessionOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetOptimizedModelFilePath\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CloneSessionOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetSessionExecutionMode\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EnableProfiling\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"DisableProfiling\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EnableMemPattern\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"DisableMemPattern\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EnableCpuMemArena\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"DisableCpuMemArena\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetSessionLogId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetSessionLogVerbosityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetSessionLogSeverityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetSessionGraphOptimizationLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetIntraOpNumThreads\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetInterOpNumThreads\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateCustomOpDomain\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CustomOpDomain_Add\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddCustomOpDomain\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RegisterCustomOpsLibrary\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetInputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetOutputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetOverridableInitializerCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetInputTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetOutputTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetOverridableInitializerTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetInputName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetOutputName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetOverridableInitializerName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateRunOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsSetRunLogVerbosityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsSetRunLogSeverityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsSetRunTag\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsGetRunLogVerbosityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsGetRunLogSeverityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsGetRunTag\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsSetTerminate\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsUnsetTerminate\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateTensorAsOrtValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateTensorWithDataAsOrtValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"IsTensor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorMutableData\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"FillStringTensor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetStringTensorDataLength\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetStringTensorContent\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CastTypeInfoToTensorInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetOnnxTypeFromTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateTensorTypeAndShapeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetTensorElementType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetDimensions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorElementType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetDimensionsCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetDimensions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSymbolicDimensions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorShapeElementCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorTypeAndShape\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetValueType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateMemoryInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateCpuMemoryInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CompareMemoryInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetMemType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AllocatorAlloc\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AllocatorFree\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AllocatorGetInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetAllocatorWithDefaultOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddFreeDimensionOverride\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetValueCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateOpaqueValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetOpaqueValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAttribute_float\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAttribute_int64\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAttribute_string\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetInputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetOutputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetInput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetOutput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseEnv\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseStatus\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseMemoryInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseSession\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseRunOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseTensorTypeAndShapeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseSessionOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseCustomOpDomain\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetDenotationFromTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CastTypeInfoToMapTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CastTypeInfoToSequenceTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetMapKeyType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetMapValueType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSequenceElementType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseMapTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseSequenceTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionEndProfiling\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetModelMetadata\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetProducerName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetGraphName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetDomain\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetDescription\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataLookupCustomMetadataMap\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetVersion\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseModelMetadata\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateEnvWithGlobalThreadPools\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"DisablePerSessionThreads\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateThreadingOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseThreadingOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetCustomMetadataMapKeys\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddFreeDimensionOverrideByName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetAvailableProviders\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseAvailableProviders\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetStringTensorElementLength\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetStringTensorElement\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"FillStringTensorElement\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddSessionConfigEntry\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunWithBinding\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateIoBinding\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseIoBinding\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"BindInput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"BindOutput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"BindOutputToDevice\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetBoundOutputNames\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetBoundOutputValues\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ClearBoundInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ClearBoundOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"TensorAt\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateAndRegisterAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetLanguageProjection\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetProfilingStartTimeNs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalIntraOpNumThreads\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalInterOpNumThreads\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalSpinControl\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddInitializer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CUDA\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_ROCM\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_OpenVINO\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalDenormalAsZero\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateArenaCfg\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseArenaCfg\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ModelMetadataGetGraphDescription\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_TensorRT\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetCurrentGpuDeviceId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetCurrentGpuDeviceId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAttributeArray_float\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAttributeArray_int64\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateArenaCfgV2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddRunConfigEntry\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreatePrepackedWeightsContainer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleasePrepackedWeightsContainer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSessionWithPrepackedWeightsContainer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateTensorRTProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateTensorRTProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorRTProviderOptionsAsString\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseTensorRTProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EnableOrtCustomOps\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RegisterAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UnregisterAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"IsSparseTensor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSparseTensorAsOrtValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"FillSparseTensorCoo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"FillSparseTensorCsr\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"FillSparseTensorBlockSparse\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSparseTensorWithValuesAsOrtValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UseCooIndices\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UseCsrIndices\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UseBlockSparseIndices\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSparseTensorFormat\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSparseTensorValuesTypeAndShape\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSparseTensorValues\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSparseTensorIndicesTypeShape\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSparseTensorIndices\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HasValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetGPUComputeStream\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorMemoryInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetExecutionProviderApi\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsSetCustomCreateThreadFn\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsSetCustomThreadCreationOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsSetCustomJoinThreadFn\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalCustomCreateThreadFn\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalCustomThreadCreationOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalCustomJoinThreadFn\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SynchronizeBoundInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SynchronizeBoundOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateCUDAProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateCUDAProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetCUDAProviderOptionsAsString\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseCUDAProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_MIGraphX\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddExternalInitializers\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateOpAttr\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseOpAttr\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateOp\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"InvokeOp\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseOp\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CopyKernelInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseKernelInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTrainingApi\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_CANN\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateCANNProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateCANNProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetCANNProviderOptionsAsString\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseCANNProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetDeviceType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateEnvWithCustomLogLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetGlobalIntraOpThreadAffinity\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RegisterCustomOpsLibrary_V2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RegisterCustomOpsUsingFunction\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetInputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetOutputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetInputName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetOutputName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetInputTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetOutputTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAttribute_tensor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HasSessionConfigEntry\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSessionConfigEntry\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_Dnnl\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateDnnlProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateDnnlProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetDnnlProviderOptionsAsString\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseDnnlProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetNodeName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfo_GetLogger\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetLogger\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Logger_LogMessage\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Logger_GetLoggingSeverityLevel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetConstantInput_tensor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CastTypeInfoToOptionalTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetOptionalContainedTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetResizedStringTensorElementBuffer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetBuildInfoString\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateROCMProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateROCMProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetROCMProviderOptionsAsString\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseROCMProviderOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateAndRegisterAllocatorV2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunAsync\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateTensorRTProviderOptionsWithValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorRTProviderOptionsByName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UpdateCUDAProviderOptionsWithValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetCUDAProviderOptionsByName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetResource\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetUserLoggingFunction\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ShapeInferContext_GetInputCount\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ShapeInferContext_GetInputTypeShape\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ShapeInferContext_GetAttribute\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ShapeInferContext_SetOutputTypeShape\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetSymbolicDimensions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReadOpAttr\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetDeterministicCompute\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_ParallelFor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_VitisAI\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelContext_GetScratchBuffer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"KernelInfoGetAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddExternalInitializersFromFilesInMemory\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateLoraAdapter\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateLoraAdapterFromArray\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseLoraAdapter\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RunOptionsAddActiveLoraAdapter\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SetEpDynamicOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseValueInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseNode\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseGraph\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseModel\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetValueInfoName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetValueInfoTypeInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetModelEditorApi\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateTensorWithDataAndDeleterAsOrtValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsSetLoadCancellationFlag\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetCompileApi\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateKeyValuePairs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AddKeyValuePair\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetKeyValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetKeyValuePairs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RemoveKeyValuePair\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseKeyValuePairs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"RegisterExecutionProviderLibrary\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"UnregisterExecutionProviderLibrary\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetEpDevices\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsAppendExecutionProvider_V2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsSetEpSelectionPolicy\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionOptionsSetEpSelectionPolicyDelegate\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HardwareDevice_Type\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HardwareDevice_VendorId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HardwareDevice_Vendor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HardwareDevice_DeviceId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"HardwareDevice_Metadata\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EpDevice_EpName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EpDevice_EpVendor\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EpDevice_EpMetadata\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EpDevice_EpOptions\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EpDevice_Device\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetEpApi\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorSizeInBytes\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"AllocatorGetStats\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateMemoryInfo_V2\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetDeviceMemType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"MemoryInfoGetVendorId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_GetValueProducer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_GetValueNumConsumers\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_GetValueConsumers\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_GetInitializerValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_GetExternalInitializerInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_IsRequiredGraphInput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_IsOptionalGraphInput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_IsGraphOutput\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_IsConstantInitializer\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ValueInfo_IsFromOuterScope\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetModelPath\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetOnnxIRVersion\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetNumOperatorSets\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetOperatorSets\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetNumInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetNumOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetNumInitializers\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetInitializers\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetNumNodes\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetNodes\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetParentNode\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetGraphView\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetId\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetOperatorType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetDomain\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetSinceVersion\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetNumInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetNumOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetNumImplicitInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetImplicitInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetNumAttributes\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetAttributes\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetAttributeByName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"OpAttr_GetTensorAttributeAsOrtValue\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"OpAttr_GetType\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"OpAttr_GetName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetNumSubgraphs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetSubgraphs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetGraph\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Node_GetEpName\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseExternalInitializerInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ExternalInitializerInfo_GetFilePath\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ExternalInitializerInfo_GetFileOffset\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ExternalInitializerInfo_GetByteSize\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetRunConfigEntry\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"EpDevice_MemoryInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSharedAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSharedAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseSharedAllocator\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetTensorData\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetSessionOptionsConfigEntries\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetMemoryInfoForInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetMemoryInfoForOutputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SessionGetEpDeviceForInputs\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateSyncStreamForEpDevice\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"SyncStream_GetHandle\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"ReleaseSyncStream\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CopyTensors\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"Graph_GetModelMetadata\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"GetModelCompatibilityForEpDevices\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"CreateExternalInitializerInfo\"),\n+        coreml_provider_factory_h.C_POINTER.withName(\"TensorTypeAndShape_HasShape\")\n@@ -608,1 +822,12 @@\n-    private static class CreateStatus {\n+    public static class CreateStatus {\n+\n+        CreateStatus() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0, MemorySegment _x1);\n+        }\n@@ -611,3 +836,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -616,0 +841,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateStatus.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateStatus.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -632,1 +874,31 @@\n-    private static final long CreateStatus$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateStatus\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateStatus$layout() {\n+        return CreateStatus$LAYOUT;\n+    }\n+\n+    private static final long CreateStatus$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)\n+     * }\n+     *\/\n+    public static final long CreateStatus$offset() {\n+        return CreateStatus$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatus *(*CreateStatus)(OrtErrorCode, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment CreateStatus(MemorySegment struct) {\n+        return struct.get(CreateStatus$LAYOUT, CreateStatus$OFFSET);\n+    }\n@@ -635,1 +907,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -640,3 +912,2 @@\n-    public static MemorySegment CreateStatus(MemorySegment struct, int _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CreateStatus$LAYOUT, CreateStatus$OFFSET);\n-        return CreateStatus.invoke(funcPtr, _x0, _x1);\n+    public static void CreateStatus(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateStatus$LAYOUT, CreateStatus$OFFSET, fieldValue);\n@@ -650,1 +921,12 @@\n-    private static class GetErrorCode {\n+    public static class GetErrorCode {\n+\n+        GetErrorCode() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n@@ -653,2 +935,2 @@\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -657,0 +939,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetErrorCode.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetErrorCode.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -673,1 +972,31 @@\n-    private static final long GetErrorCode$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetErrorCode\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetErrorCode$layout() {\n+        return GetErrorCode$LAYOUT;\n+    }\n+\n+    private static final long GetErrorCode$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static final long GetErrorCode$offset() {\n+        return GetErrorCode$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtErrorCode (*GetErrorCode)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static MemorySegment GetErrorCode(MemorySegment struct) {\n+        return struct.get(GetErrorCode$LAYOUT, GetErrorCode$OFFSET);\n+    }\n@@ -676,1 +1005,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -681,3 +1010,2 @@\n-    public static int GetErrorCode(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(GetErrorCode$LAYOUT, GetErrorCode$OFFSET);\n-        return GetErrorCode.invoke(funcPtr, _x0);\n+    public static void GetErrorCode(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetErrorCode$LAYOUT, GetErrorCode$OFFSET, fieldValue);\n@@ -691,1 +1019,12 @@\n-    private static class GetErrorMessage {\n+    public static class GetErrorMessage {\n+\n+        GetErrorMessage() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -694,2 +1033,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -698,0 +1037,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetErrorMessage.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetErrorMessage.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -714,1 +1070,31 @@\n-    private static final long GetErrorMessage$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetErrorMessage\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetErrorMessage)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetErrorMessage$layout() {\n+        return GetErrorMessage$LAYOUT;\n+    }\n+\n+    private static final long GetErrorMessage$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetErrorMessage)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static final long GetErrorMessage$offset() {\n+        return GetErrorMessage$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetErrorMessage)(const OrtStatus *)\n+     * }\n+     *\/\n+    public static MemorySegment GetErrorMessage(MemorySegment struct) {\n+        return struct.get(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET);\n+    }\n@@ -717,1 +1103,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -722,3 +1108,2 @@\n-    public static MemorySegment GetErrorMessage(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET);\n-        return GetErrorMessage.invoke(funcPtr, _x0);\n+    public static void GetErrorMessage(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetErrorMessage$LAYOUT, GetErrorMessage$OFFSET, fieldValue);\n@@ -732,1 +1117,12 @@\n-    private static class CreateEnv {\n+    public static class CreateEnv {\n+\n+        CreateEnv() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -735,4 +1131,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -741,0 +1137,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateEnv.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateEnv.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -757,1 +1170,31 @@\n-    private static final long CreateEnv$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnv\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateEnv$layout() {\n+        return CreateEnv$LAYOUT;\n+    }\n+\n+    private static final long CreateEnv$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final long CreateEnv$offset() {\n+        return CreateEnv$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnv)(OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnv(MemorySegment struct) {\n+        return struct.get(CreateEnv$LAYOUT, CreateEnv$OFFSET);\n+    }\n@@ -760,1 +1203,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -765,3 +1208,2 @@\n-    public static MemorySegment CreateEnv(MemorySegment struct, int _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(CreateEnv$LAYOUT, CreateEnv$OFFSET);\n-        return CreateEnv.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void CreateEnv(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateEnv$LAYOUT, CreateEnv$OFFSET, fieldValue);\n@@ -775,1 +1217,12 @@\n-    private static class CreateEnvWithCustomLogger {\n+    public static class CreateEnvWithCustomLogger {\n+\n+        CreateEnvWithCustomLogger() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4);\n+        }\n@@ -778,6 +1231,6 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -786,0 +1239,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateEnvWithCustomLogger.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateEnvWithCustomLogger.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -802,1 +1272,31 @@\n-    private static final long CreateEnvWithCustomLogger$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnvWithCustomLogger\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateEnvWithCustomLogger$layout() {\n+        return CreateEnvWithCustomLogger$LAYOUT;\n+    }\n+\n+    private static final long CreateEnvWithCustomLogger$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final long CreateEnvWithCustomLogger$offset() {\n+        return CreateEnvWithCustomLogger$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLogger)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnvWithCustomLogger(MemorySegment struct) {\n+        return struct.get(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET);\n+    }\n@@ -805,1 +1305,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -810,3 +1310,2 @@\n-    public static MemorySegment CreateEnvWithCustomLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET);\n-        return CreateEnvWithCustomLogger.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static void CreateEnvWithCustomLogger(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateEnvWithCustomLogger$LAYOUT, CreateEnvWithCustomLogger$OFFSET, fieldValue);\n@@ -820,1 +1319,12 @@\n-    private static class EnableTelemetryEvents {\n+    public static class EnableTelemetryEvents {\n+\n+        EnableTelemetryEvents() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -823,2 +1333,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -827,0 +1337,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EnableTelemetryEvents.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EnableTelemetryEvents.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -843,1 +1370,31 @@\n-    private static final long EnableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableTelemetryEvents\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    public static final AddressLayout EnableTelemetryEvents$layout() {\n+        return EnableTelemetryEvents$LAYOUT;\n+    }\n+\n+    private static final long EnableTelemetryEvents$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    public static final long EnableTelemetryEvents$offset() {\n+        return EnableTelemetryEvents$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableTelemetryEvents(MemorySegment struct) {\n+        return struct.get(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET);\n+    }\n@@ -846,1 +1403,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -851,3 +1408,2 @@\n-    public static MemorySegment EnableTelemetryEvents(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET);\n-        return EnableTelemetryEvents.invoke(funcPtr, _x0);\n+    public static void EnableTelemetryEvents(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EnableTelemetryEvents$LAYOUT, EnableTelemetryEvents$OFFSET, fieldValue);\n@@ -861,1 +1417,12 @@\n-    private static class DisableTelemetryEvents {\n+    public static class DisableTelemetryEvents {\n+\n+        DisableTelemetryEvents() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -864,2 +1431,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -868,0 +1435,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(DisableTelemetryEvents.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(DisableTelemetryEvents.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -884,2 +1468,0 @@\n-    private static final long DisableTelemetryEvents$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableTelemetryEvents\"));\n-\n@@ -887,1 +1469,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -892,3 +1474,2 @@\n-    public static MemorySegment DisableTelemetryEvents(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET);\n-        return DisableTelemetryEvents.invoke(funcPtr, _x0);\n+    public static final AddressLayout DisableTelemetryEvents$layout() {\n+        return DisableTelemetryEvents$LAYOUT;\n@@ -897,0 +1478,2 @@\n+    private static final long DisableTelemetryEvents$OFFSET = 48;\n+\n@@ -898,0 +1481,1 @@\n+     * Offset for field:\n@@ -899,1 +1483,1 @@\n-     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)\n@@ -902,22 +1486,2 @@\n-    private static class CreateSession {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long DisableTelemetryEvents$offset() {\n+        return DisableTelemetryEvents$OFFSET;\n@@ -926,4 +1490,0 @@\n-    private static final AddressLayout CreateSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSession\"));\n-\n-    private static final long CreateSession$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSession\"));\n-\n@@ -931,1 +1491,1 @@\n-     * Invoker for field:\n+     * Getter for field:\n@@ -933,1 +1493,1 @@\n-     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)\n@@ -936,3 +1496,2 @@\n-    public static MemorySegment CreateSession(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(CreateSession$LAYOUT, CreateSession$OFFSET);\n-        return CreateSession.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static MemorySegment DisableTelemetryEvents(MemorySegment struct) {\n+        return struct.get(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET);\n@@ -942,0 +1501,1 @@\n+     * Setter for field:\n@@ -943,1 +1503,10 @@\n-     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * OrtStatusPtr (*DisableTelemetryEvents)(const OrtEnv *)\n+     * }\n+     *\/\n+    public static void DisableTelemetryEvents(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(DisableTelemetryEvents$LAYOUT, DisableTelemetryEvents$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n@@ -946,1 +1515,12 @@\n-    private static class CreateSessionFromArray {\n+    public static class CreateSession {\n+\n+        CreateSession() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n@@ -949,6 +1529,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -957,0 +1536,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSession.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSession.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -962,1 +1558,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n@@ -964,1 +1560,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -971,3 +1567,1 @@\n-    private static final AddressLayout CreateSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromArray\"));\n-\n-    private static final long CreateSessionFromArray$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionFromArray\"));\n+    private static final AddressLayout CreateSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSession\"));\n@@ -976,1 +1570,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -978,1 +1572,1 @@\n-     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n@@ -981,3 +1575,2 @@\n-    public static MemorySegment CreateSessionFromArray(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET);\n-        return CreateSessionFromArray.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout CreateSession$layout() {\n+        return CreateSession$LAYOUT;\n@@ -986,0 +1579,2 @@\n+    private static final long CreateSession$OFFSET = 56;\n+\n@@ -987,0 +1582,1 @@\n+     * Offset for field:\n@@ -988,1 +1584,1 @@\n-     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n@@ -991,26 +1587,2 @@\n-    private static class Run {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateSession$offset() {\n+        return CreateSession$OFFSET;\n@@ -1019,3 +1591,9 @@\n-    private static final AddressLayout Run$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Run\"));\n-\n-    private static final long Run$OFFSET = $LAYOUT.byteOffset(groupElement(\"Run\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSession(MemorySegment struct) {\n+        return struct.get(CreateSession$LAYOUT, CreateSession$OFFSET);\n+    }\n@@ -1024,1 +1602,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1026,1 +1604,1 @@\n-     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n+     * OrtStatusPtr (*CreateSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n@@ -1029,3 +1607,2 @@\n-    public static MemorySegment Run(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n-        var funcPtr = struct.get(Run$LAYOUT, Run$OFFSET);\n-        return Run.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+    public static void CreateSession(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSession$LAYOUT, CreateSession$OFFSET, fieldValue);\n@@ -1036,1 +1613,1 @@\n-     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n@@ -1039,1 +1616,12 @@\n-    private static class CreateSessionOptions {\n+    public static class CreateSessionFromArray {\n+\n+        CreateSessionFromArray() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4);\n+        }\n@@ -1042,2 +1630,6 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1046,0 +1638,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSessionFromArray.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSessionFromArray.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1051,1 +1660,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {\n@@ -1053,1 +1662,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n@@ -1060,3 +1669,1 @@\n-    private static final AddressLayout CreateSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionOptions\"));\n-\n-    private static final long CreateSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionOptions\"));\n+    private static final AddressLayout CreateSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromArray\"));\n@@ -1065,1 +1672,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1067,1 +1674,1 @@\n-     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n@@ -1070,3 +1677,2 @@\n-    public static MemorySegment CreateSessionOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET);\n-        return CreateSessionOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout CreateSessionFromArray$layout() {\n+        return CreateSessionFromArray$LAYOUT;\n@@ -1075,0 +1681,2 @@\n+    private static final long CreateSessionFromArray$OFFSET = 64;\n+\n@@ -1076,0 +1684,1 @@\n+     * Offset for field:\n@@ -1077,1 +1686,1 @@\n-     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n@@ -1080,20 +1689,2 @@\n-    private static class SetOptimizedModelFilePath {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateSessionFromArray$offset() {\n+        return CreateSessionFromArray$OFFSET;\n@@ -1102,3 +1693,9 @@\n-    private static final AddressLayout SetOptimizedModelFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetOptimizedModelFilePath\"));\n-\n-    private static final long SetOptimizedModelFilePath$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetOptimizedModelFilePath\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionFromArray(MemorySegment struct) {\n+        return struct.get(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET);\n+    }\n@@ -1107,1 +1704,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1109,1 +1706,1 @@\n-     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*CreateSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n@@ -1112,3 +1709,2 @@\n-    public static MemorySegment SetOptimizedModelFilePath(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET);\n-        return SetOptimizedModelFilePath.invoke(funcPtr, _x0, _x1);\n+    public static void CreateSessionFromArray(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSessionFromArray$LAYOUT, CreateSessionFromArray$OFFSET, fieldValue);\n@@ -1119,1 +1715,1 @@\n-     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n@@ -1122,1 +1718,12 @@\n-    private static class CloneSessionOptions {\n+    public static class Run {\n+\n+        Run() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7);\n+        }\n@@ -1125,3 +1732,9 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1130,0 +1743,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Run.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Run.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1135,1 +1765,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n@@ -1137,1 +1767,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n@@ -1144,3 +1774,1 @@\n-    private static final AddressLayout CloneSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CloneSessionOptions\"));\n-\n-    private static final long CloneSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CloneSessionOptions\"));\n+    private static final AddressLayout Run$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Run\"));\n@@ -1149,1 +1777,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1151,1 +1779,1 @@\n-     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n@@ -1154,3 +1782,2 @@\n-    public static MemorySegment CloneSessionOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET);\n-        return CloneSessionOptions.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Run$layout() {\n+        return Run$LAYOUT;\n@@ -1159,0 +1786,2 @@\n+    private static final long Run$OFFSET = 72;\n+\n@@ -1160,0 +1789,1 @@\n+     * Offset for field:\n@@ -1161,1 +1791,1 @@\n-     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n@@ -1164,20 +1794,2 @@\n-    private static class SetSessionExecutionMode {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Run$offset() {\n+        return Run$OFFSET;\n@@ -1186,3 +1798,9 @@\n-    private static final AddressLayout SetSessionExecutionMode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionExecutionMode\"));\n-\n-    private static final long SetSessionExecutionMode$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionExecutionMode\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment Run(MemorySegment struct) {\n+        return struct.get(Run$LAYOUT, Run$OFFSET);\n+    }\n@@ -1191,1 +1809,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1193,1 +1811,1 @@\n-     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n+     * OrtStatusPtr (*Run)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **)\n@@ -1196,3 +1814,2 @@\n-    public static MemorySegment SetSessionExecutionMode(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET);\n-        return SetSessionExecutionMode.invoke(funcPtr, _x0, _x1);\n+    public static void Run(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Run$LAYOUT, Run$OFFSET, fieldValue);\n@@ -1203,1 +1820,1 @@\n-     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n@@ -1206,1 +1823,12 @@\n-    private static class EnableProfiling {\n+    public static class CreateSessionOptions {\n+\n+        CreateSessionOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -1209,3 +1837,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1214,0 +1841,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSessionOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSessionOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1219,1 +1863,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -1221,1 +1865,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -1228,3 +1872,1 @@\n-    private static final AddressLayout EnableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableProfiling\"));\n-\n-    private static final long EnableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableProfiling\"));\n+    private static final AddressLayout CreateSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionOptions\"));\n@@ -1233,1 +1875,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1235,1 +1877,1 @@\n-     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n@@ -1238,3 +1880,2 @@\n-    public static MemorySegment EnableProfiling(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(EnableProfiling$LAYOUT, EnableProfiling$OFFSET);\n-        return EnableProfiling.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout CreateSessionOptions$layout() {\n+        return CreateSessionOptions$LAYOUT;\n@@ -1243,0 +1884,2 @@\n+    private static final long CreateSessionOptions$OFFSET = 80;\n+\n@@ -1244,0 +1887,1 @@\n+     * Offset for field:\n@@ -1245,1 +1889,1 @@\n-     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n@@ -1248,19 +1892,2 @@\n-    private static class DisableProfiling {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateSessionOptions$offset() {\n+        return CreateSessionOptions$OFFSET;\n@@ -1269,3 +1896,9 @@\n-    private static final AddressLayout DisableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableProfiling\"));\n-\n-    private static final long DisableProfiling$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableProfiling\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionOptions(MemorySegment struct) {\n+        return struct.get(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET);\n+    }\n@@ -1274,1 +1907,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1276,1 +1909,1 @@\n-     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n+     * OrtStatusPtr (*CreateSessionOptions)(OrtSessionOptions **)\n@@ -1279,3 +1912,2 @@\n-    public static MemorySegment DisableProfiling(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(DisableProfiling$LAYOUT, DisableProfiling$OFFSET);\n-        return DisableProfiling.invoke(funcPtr, _x0);\n+    public static void CreateSessionOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSessionOptions$LAYOUT, CreateSessionOptions$OFFSET, fieldValue);\n@@ -1286,1 +1918,1 @@\n-     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n@@ -1289,1 +1921,12 @@\n-    private static class EnableMemPattern {\n+    public static class SetOptimizedModelFilePath {\n+\n+        SetOptimizedModelFilePath() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -1292,2 +1935,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1296,0 +1940,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetOptimizedModelFilePath.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetOptimizedModelFilePath.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1301,1 +1962,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -1303,1 +1964,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -1310,3 +1971,1 @@\n-    private static final AddressLayout EnableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableMemPattern\"));\n-\n-    private static final long EnableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableMemPattern\"));\n+    private static final AddressLayout SetOptimizedModelFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetOptimizedModelFilePath\"));\n@@ -1315,1 +1974,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1317,1 +1976,1 @@\n-     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n@@ -1320,3 +1979,2 @@\n-    public static MemorySegment EnableMemPattern(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET);\n-        return EnableMemPattern.invoke(funcPtr, _x0);\n+    public static final AddressLayout SetOptimizedModelFilePath$layout() {\n+        return SetOptimizedModelFilePath$LAYOUT;\n@@ -1325,0 +1983,2 @@\n+    private static final long SetOptimizedModelFilePath$OFFSET = 88;\n+\n@@ -1326,0 +1986,1 @@\n+     * Offset for field:\n@@ -1327,1 +1988,1 @@\n-     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n@@ -1330,19 +1991,2 @@\n-    private static class DisableMemPattern {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetOptimizedModelFilePath$offset() {\n+        return SetOptimizedModelFilePath$OFFSET;\n@@ -1351,3 +1995,9 @@\n-    private static final AddressLayout DisableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableMemPattern\"));\n-\n-    private static final long DisableMemPattern$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableMemPattern\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment SetOptimizedModelFilePath(MemorySegment struct) {\n+        return struct.get(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET);\n+    }\n@@ -1356,1 +2006,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1358,1 +2008,1 @@\n-     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n+     * OrtStatusPtr (*SetOptimizedModelFilePath)(OrtSessionOptions *, const char *)\n@@ -1361,3 +2011,2 @@\n-    public static MemorySegment DisableMemPattern(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET);\n-        return DisableMemPattern.invoke(funcPtr, _x0);\n+    public static void SetOptimizedModelFilePath(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetOptimizedModelFilePath$LAYOUT, SetOptimizedModelFilePath$OFFSET, fieldValue);\n@@ -1368,1 +2017,1 @@\n-     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n@@ -1371,1 +2020,12 @@\n-    private static class EnableCpuMemArena {\n+    public static class CloneSessionOptions {\n+\n+        CloneSessionOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -1374,2 +2034,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1378,0 +2039,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CloneSessionOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CloneSessionOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1383,1 +2061,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -1385,1 +2063,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -1392,3 +2070,1 @@\n-    private static final AddressLayout EnableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableCpuMemArena\"));\n-\n-    private static final long EnableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableCpuMemArena\"));\n+    private static final AddressLayout CloneSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CloneSessionOptions\"));\n@@ -1397,1 +2073,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1399,1 +2075,1 @@\n-     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n@@ -1402,3 +2078,2 @@\n-    public static MemorySegment EnableCpuMemArena(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET);\n-        return EnableCpuMemArena.invoke(funcPtr, _x0);\n+    public static final AddressLayout CloneSessionOptions$layout() {\n+        return CloneSessionOptions$LAYOUT;\n@@ -1407,0 +2082,2 @@\n+    private static final long CloneSessionOptions$OFFSET = 96;\n+\n@@ -1408,0 +2085,1 @@\n+     * Offset for field:\n@@ -1409,1 +2087,1 @@\n-     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n@@ -1412,19 +2090,2 @@\n-    private static class DisableCpuMemArena {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CloneSessionOptions$offset() {\n+        return CloneSessionOptions$OFFSET;\n@@ -1433,3 +2094,9 @@\n-    private static final AddressLayout DisableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableCpuMemArena\"));\n-\n-    private static final long DisableCpuMemArena$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisableCpuMemArena\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CloneSessionOptions(MemorySegment struct) {\n+        return struct.get(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET);\n+    }\n@@ -1438,1 +2105,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1440,1 +2107,1 @@\n-     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n+     * OrtStatusPtr (*CloneSessionOptions)(const OrtSessionOptions *, OrtSessionOptions **)\n@@ -1443,3 +2110,2 @@\n-    public static MemorySegment DisableCpuMemArena(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET);\n-        return DisableCpuMemArena.invoke(funcPtr, _x0);\n+    public static void CloneSessionOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CloneSessionOptions$LAYOUT, CloneSessionOptions$OFFSET, fieldValue);\n@@ -1450,1 +2116,1 @@\n-     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n@@ -1453,1 +2119,12 @@\n-    private static class SetSessionLogId {\n+    public static class SetSessionExecutionMode {\n+\n+        SetSessionExecutionMode() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -1456,3 +2133,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -1461,0 +2138,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetSessionExecutionMode.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetSessionExecutionMode.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1466,1 +2160,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n@@ -1475,3 +2169,1 @@\n-    private static final AddressLayout SetSessionLogId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogId\"));\n-\n-    private static final long SetSessionLogId$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionLogId\"));\n+    private static final AddressLayout SetSessionExecutionMode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionExecutionMode\"));\n@@ -1480,1 +2172,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1482,1 +2174,1 @@\n-     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n@@ -1485,3 +2177,2 @@\n-    public static MemorySegment SetSessionLogId(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET);\n-        return SetSessionLogId.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SetSessionExecutionMode$layout() {\n+        return SetSessionExecutionMode$LAYOUT;\n@@ -1490,0 +2181,2 @@\n+    private static final long SetSessionExecutionMode$OFFSET = 104;\n+\n@@ -1491,0 +2184,1 @@\n+     * Offset for field:\n@@ -1492,1 +2186,1 @@\n-     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n@@ -1495,20 +2189,2 @@\n-    private static class SetSessionLogVerbosityLevel {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetSessionExecutionMode$offset() {\n+        return SetSessionExecutionMode$OFFSET;\n@@ -1517,3 +2193,9 @@\n-    private static final AddressLayout SetSessionLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogVerbosityLevel\"));\n-\n-    private static final long SetSessionLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionLogVerbosityLevel\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionExecutionMode(MemorySegment struct) {\n+        return struct.get(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET);\n+    }\n@@ -1522,1 +2204,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1524,1 +2206,1 @@\n-     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*SetSessionExecutionMode)(OrtSessionOptions *, ExecutionMode)\n@@ -1527,3 +2209,2 @@\n-    public static MemorySegment SetSessionLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET);\n-        return SetSessionLogVerbosityLevel.invoke(funcPtr, _x0, _x1);\n+    public static void SetSessionExecutionMode(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetSessionExecutionMode$LAYOUT, SetSessionExecutionMode$OFFSET, fieldValue);\n@@ -1534,1 +2215,1 @@\n-     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n@@ -1537,1 +2218,12 @@\n-    private static class SetSessionLogSeverityLevel {\n+    public static class EnableProfiling {\n+\n+        EnableProfiling() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -1540,3 +2232,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1545,0 +2237,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EnableProfiling.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EnableProfiling.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1550,1 +2259,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -1559,3 +2268,1 @@\n-    private static final AddressLayout SetSessionLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogSeverityLevel\"));\n-\n-    private static final long SetSessionLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionLogSeverityLevel\"));\n+    private static final AddressLayout EnableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableProfiling\"));\n@@ -1564,1 +2271,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1566,1 +2273,1 @@\n-     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n@@ -1569,3 +2276,2 @@\n-    public static MemorySegment SetSessionLogSeverityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET);\n-        return SetSessionLogSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout EnableProfiling$layout() {\n+        return EnableProfiling$LAYOUT;\n@@ -1574,0 +2280,2 @@\n+    private static final long EnableProfiling$OFFSET = 112;\n+\n@@ -1575,0 +2283,1 @@\n+     * Offset for field:\n@@ -1576,1 +2285,1 @@\n-     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n@@ -1579,20 +2288,2 @@\n-    private static class SetSessionGraphOptimizationLevel {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EnableProfiling$offset() {\n+        return EnableProfiling$OFFSET;\n@@ -1601,3 +2292,9 @@\n-    private static final AddressLayout SetSessionGraphOptimizationLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionGraphOptimizationLevel\"));\n-\n-    private static final long SetSessionGraphOptimizationLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSessionGraphOptimizationLevel\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableProfiling(MemorySegment struct) {\n+        return struct.get(EnableProfiling$LAYOUT, EnableProfiling$OFFSET);\n+    }\n@@ -1606,1 +2303,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1608,1 +2305,1 @@\n-     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n+     * OrtStatusPtr (*EnableProfiling)(OrtSessionOptions *, const char *)\n@@ -1611,3 +2308,2 @@\n-    public static MemorySegment SetSessionGraphOptimizationLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET);\n-        return SetSessionGraphOptimizationLevel.invoke(funcPtr, _x0, _x1);\n+    public static void EnableProfiling(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EnableProfiling$LAYOUT, EnableProfiling$OFFSET, fieldValue);\n@@ -1618,1 +2314,1 @@\n-     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n@@ -1621,1 +2317,12 @@\n-    private static class SetIntraOpNumThreads {\n+    public static class DisableProfiling {\n+\n+        DisableProfiling() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -1624,3 +2331,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1629,0 +2335,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(DisableProfiling.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(DisableProfiling.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1634,1 +2357,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -1636,1 +2359,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -1643,3 +2366,1 @@\n-    private static final AddressLayout SetIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetIntraOpNumThreads\"));\n-\n-    private static final long SetIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetIntraOpNumThreads\"));\n+    private static final AddressLayout DisableProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableProfiling\"));\n@@ -1648,1 +2369,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1650,1 +2371,1 @@\n-     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n@@ -1653,3 +2374,2 @@\n-    public static MemorySegment SetIntraOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET);\n-        return SetIntraOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout DisableProfiling$layout() {\n+        return DisableProfiling$LAYOUT;\n@@ -1658,0 +2378,2 @@\n+    private static final long DisableProfiling$OFFSET = 120;\n+\n@@ -1659,0 +2381,1 @@\n+     * Offset for field:\n@@ -1660,1 +2383,1 @@\n-     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n@@ -1663,20 +2386,2 @@\n-    private static class SetInterOpNumThreads {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long DisableProfiling$offset() {\n+        return DisableProfiling$OFFSET;\n@@ -1685,3 +2390,9 @@\n-    private static final AddressLayout SetInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetInterOpNumThreads\"));\n-\n-    private static final long SetInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetInterOpNumThreads\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableProfiling(MemorySegment struct) {\n+        return struct.get(DisableProfiling$LAYOUT, DisableProfiling$OFFSET);\n+    }\n@@ -1690,1 +2401,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1692,1 +2403,1 @@\n-     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * OrtStatusPtr (*DisableProfiling)(OrtSessionOptions *)\n@@ -1695,3 +2406,2 @@\n-    public static MemorySegment SetInterOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET);\n-        return SetInterOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    public static void DisableProfiling(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(DisableProfiling$LAYOUT, DisableProfiling$OFFSET, fieldValue);\n@@ -1702,1 +2412,1 @@\n-     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n@@ -1705,1 +2415,12 @@\n-    private static class CreateCustomOpDomain {\n+    public static class EnableMemPattern {\n+\n+        EnableMemPattern() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -1708,3 +2429,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1713,1 +2433,8 @@\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EnableMemPattern.Function.class, \"apply\", $DESC);\n@@ -1716,1 +2443,2 @@\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n@@ -1718,6 +2446,2 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n+        public static MemorySegment allocate(EnableMemPattern.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n@@ -1725,29 +2449,0 @@\n-    }\n-\n-    private static final AddressLayout CreateCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCustomOpDomain\"));\n-\n-    private static final long CreateCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCustomOpDomain\"));\n-\n-    \/**\n-     * Invoker for field:\n-     * {@snippet lang=c :\n-     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n-     * }\n-     *\/\n-    public static MemorySegment CreateCustomOpDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET);\n-        return CreateCustomOpDomain.invoke(funcPtr, _x0, _x1);\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n-     * }\n-     *\/\n-    private static class CustomOpDomain_Add {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n@@ -1760,1 +2455,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -1762,1 +2457,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -1769,3 +2464,1 @@\n-    private static final AddressLayout CustomOpDomain_Add$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CustomOpDomain_Add\"));\n-\n-    private static final long CustomOpDomain_Add$OFFSET = $LAYOUT.byteOffset(groupElement(\"CustomOpDomain_Add\"));\n+    private static final AddressLayout EnableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableMemPattern\"));\n@@ -1774,1 +2467,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1776,1 +2469,1 @@\n-     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n@@ -1779,3 +2472,2 @@\n-    public static MemorySegment CustomOpDomain_Add(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET);\n-        return CustomOpDomain_Add.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout EnableMemPattern$layout() {\n+        return EnableMemPattern$LAYOUT;\n@@ -1784,0 +2476,2 @@\n+    private static final long EnableMemPattern$OFFSET = 128;\n+\n@@ -1785,0 +2479,1 @@\n+     * Offset for field:\n@@ -1786,1 +2481,1 @@\n-     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n@@ -1789,20 +2484,2 @@\n-    private static class AddCustomOpDomain {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EnableMemPattern$offset() {\n+        return EnableMemPattern$OFFSET;\n@@ -1811,3 +2488,9 @@\n-    private static final AddressLayout AddCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddCustomOpDomain\"));\n-\n-    private static final long AddCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddCustomOpDomain\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableMemPattern(MemorySegment struct) {\n+        return struct.get(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET);\n+    }\n@@ -1816,1 +2499,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1818,1 +2501,1 @@\n-     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * OrtStatusPtr (*EnableMemPattern)(OrtSessionOptions *)\n@@ -1821,3 +2504,2 @@\n-    public static MemorySegment AddCustomOpDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET);\n-        return AddCustomOpDomain.invoke(funcPtr, _x0, _x1);\n+    public static void EnableMemPattern(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EnableMemPattern$LAYOUT, EnableMemPattern$OFFSET, fieldValue);\n@@ -1828,1 +2510,1 @@\n-     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n@@ -1831,1 +2513,12 @@\n-    private static class RegisterCustomOpsLibrary {\n+    public static class DisableMemPattern {\n+\n+        DisableMemPattern() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -1834,4 +2527,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1840,0 +2531,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(DisableMemPattern.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(DisableMemPattern.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1845,1 +2553,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -1847,1 +2555,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -1854,3 +2562,1 @@\n-    private static final AddressLayout RegisterCustomOpsLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsLibrary\"));\n-\n-    private static final long RegisterCustomOpsLibrary$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterCustomOpsLibrary\"));\n+    private static final AddressLayout DisableMemPattern$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableMemPattern\"));\n@@ -1859,1 +2565,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1861,1 +2567,1 @@\n-     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n@@ -1864,3 +2570,2 @@\n-    public static MemorySegment RegisterCustomOpsLibrary(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET);\n-        return RegisterCustomOpsLibrary.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout DisableMemPattern$layout() {\n+        return DisableMemPattern$LAYOUT;\n@@ -1869,0 +2574,2 @@\n+    private static final long DisableMemPattern$OFFSET = 136;\n+\n@@ -1870,0 +2577,1 @@\n+     * Offset for field:\n@@ -1871,1 +2579,1 @@\n-     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n@@ -1874,20 +2582,2 @@\n-    private static class SessionGetInputCount {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long DisableMemPattern$offset() {\n+        return DisableMemPattern$OFFSET;\n@@ -1896,3 +2586,9 @@\n-    private static final AddressLayout SessionGetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputCount\"));\n-\n-    private static final long SessionGetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetInputCount\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableMemPattern(MemorySegment struct) {\n+        return struct.get(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET);\n+    }\n@@ -1901,1 +2597,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1903,1 +2599,1 @@\n-     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * OrtStatusPtr (*DisableMemPattern)(OrtSessionOptions *)\n@@ -1906,3 +2602,2 @@\n-    public static MemorySegment SessionGetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET);\n-        return SessionGetInputCount.invoke(funcPtr, _x0, _x1);\n+    public static void DisableMemPattern(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(DisableMemPattern$LAYOUT, DisableMemPattern$OFFSET, fieldValue);\n@@ -1913,1 +2608,1 @@\n-     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n@@ -1916,1 +2611,12 @@\n-    private static class SessionGetOutputCount {\n+    public static class EnableCpuMemArena {\n+\n+        EnableCpuMemArena() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -1919,3 +2625,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -1924,0 +2629,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EnableCpuMemArena.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EnableCpuMemArena.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -1929,1 +2651,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -1931,1 +2653,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -1938,3 +2660,1 @@\n-    private static final AddressLayout SessionGetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputCount\"));\n-\n-    private static final long SessionGetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOutputCount\"));\n+    private static final AddressLayout EnableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableCpuMemArena\"));\n@@ -1943,1 +2663,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -1945,1 +2665,1 @@\n-     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n@@ -1948,3 +2668,2 @@\n-    public static MemorySegment SessionGetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET);\n-        return SessionGetOutputCount.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout EnableCpuMemArena$layout() {\n+        return EnableCpuMemArena$LAYOUT;\n@@ -1953,0 +2672,2 @@\n+    private static final long EnableCpuMemArena$OFFSET = 144;\n+\n@@ -1954,0 +2675,1 @@\n+     * Offset for field:\n@@ -1955,1 +2677,1 @@\n-     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n@@ -1958,20 +2680,2 @@\n-    private static class SessionGetOverridableInitializerCount {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EnableCpuMemArena$offset() {\n+        return EnableCpuMemArena$OFFSET;\n@@ -1980,3 +2684,9 @@\n-    private static final AddressLayout SessionGetOverridableInitializerCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerCount\"));\n-\n-    private static final long SessionGetOverridableInitializerCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOverridableInitializerCount\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableCpuMemArena(MemorySegment struct) {\n+        return struct.get(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET);\n+    }\n@@ -1985,1 +2695,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -1987,1 +2697,1 @@\n-     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * OrtStatusPtr (*EnableCpuMemArena)(OrtSessionOptions *)\n@@ -1990,3 +2700,2 @@\n-    public static MemorySegment SessionGetOverridableInitializerCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET);\n-        return SessionGetOverridableInitializerCount.invoke(funcPtr, _x0, _x1);\n+    public static void EnableCpuMemArena(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EnableCpuMemArena$LAYOUT, EnableCpuMemArena$OFFSET, fieldValue);\n@@ -1997,1 +2706,1 @@\n-     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n@@ -2000,1 +2709,12 @@\n-    private static class SessionGetInputTypeInfo {\n+    public static class DisableCpuMemArena {\n+\n+        DisableCpuMemArena() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -2003,4 +2723,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2009,0 +2727,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(DisableCpuMemArena.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(DisableCpuMemArena.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2014,1 +2749,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -2016,1 +2751,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -2023,3 +2758,1 @@\n-    private static final AddressLayout SessionGetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputTypeInfo\"));\n-\n-    private static final long SessionGetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetInputTypeInfo\"));\n+    private static final AddressLayout DisableCpuMemArena$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisableCpuMemArena\"));\n@@ -2028,1 +2761,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2030,1 +2763,1 @@\n-     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n@@ -2033,3 +2766,2 @@\n-    public static MemorySegment SessionGetInputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET);\n-        return SessionGetInputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout DisableCpuMemArena$layout() {\n+        return DisableCpuMemArena$LAYOUT;\n@@ -2038,0 +2770,2 @@\n+    private static final long DisableCpuMemArena$OFFSET = 152;\n+\n@@ -2039,0 +2773,1 @@\n+     * Offset for field:\n@@ -2040,1 +2775,1 @@\n-     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n@@ -2043,21 +2778,2 @@\n-    private static class SessionGetOutputTypeInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long DisableCpuMemArena$offset() {\n+        return DisableCpuMemArena$OFFSET;\n@@ -2066,3 +2782,9 @@\n-    private static final AddressLayout SessionGetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputTypeInfo\"));\n-\n-    private static final long SessionGetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOutputTypeInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisableCpuMemArena(MemorySegment struct) {\n+        return struct.get(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET);\n+    }\n@@ -2071,1 +2793,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2073,1 +2795,1 @@\n-     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*DisableCpuMemArena)(OrtSessionOptions *)\n@@ -2076,3 +2798,2 @@\n-    public static MemorySegment SessionGetOutputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET);\n-        return SessionGetOutputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void DisableCpuMemArena(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(DisableCpuMemArena$LAYOUT, DisableCpuMemArena$OFFSET, fieldValue);\n@@ -2083,1 +2804,1 @@\n-     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n@@ -2086,1 +2807,12 @@\n-    private static class SessionGetOverridableInitializerTypeInfo {\n+    public static class SetSessionLogId {\n+\n+        SetSessionLogId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -2089,4 +2821,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2095,0 +2826,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetSessionLogId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetSessionLogId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2100,1 +2848,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -2102,1 +2850,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -2109,3 +2857,1 @@\n-    private static final AddressLayout SessionGetOverridableInitializerTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerTypeInfo\"));\n-\n-    private static final long SessionGetOverridableInitializerTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOverridableInitializerTypeInfo\"));\n+    private static final AddressLayout SetSessionLogId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogId\"));\n@@ -2114,1 +2860,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2116,1 +2862,1 @@\n-     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n@@ -2119,3 +2865,2 @@\n-    public static MemorySegment SessionGetOverridableInitializerTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET);\n-        return SessionGetOverridableInitializerTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout SetSessionLogId$layout() {\n+        return SetSessionLogId$LAYOUT;\n@@ -2124,0 +2869,2 @@\n+    private static final long SetSessionLogId$OFFSET = 160;\n+\n@@ -2125,0 +2872,1 @@\n+     * Offset for field:\n@@ -2126,1 +2874,1 @@\n-     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n@@ -2129,22 +2877,2 @@\n-    private static class SessionGetInputName {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetSessionLogId$offset() {\n+        return SetSessionLogId$OFFSET;\n@@ -2153,3 +2881,9 @@\n-    private static final AddressLayout SessionGetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputName\"));\n-\n-    private static final long SessionGetInputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetInputName\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionLogId(MemorySegment struct) {\n+        return struct.get(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET);\n+    }\n@@ -2158,1 +2892,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2160,1 +2894,1 @@\n-     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * OrtStatusPtr (*SetSessionLogId)(OrtSessionOptions *, const char *)\n@@ -2163,3 +2897,2 @@\n-    public static MemorySegment SessionGetInputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET);\n-        return SessionGetInputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void SetSessionLogId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetSessionLogId$LAYOUT, SetSessionLogId$OFFSET, fieldValue);\n@@ -2170,1 +2903,1 @@\n-     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n@@ -2173,1 +2906,12 @@\n-    private static class SessionGetOutputName {\n+    public static class SetSessionLogVerbosityLevel {\n+\n+        SetSessionLogVerbosityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -2176,5 +2920,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -2183,0 +2925,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetSessionLogVerbosityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetSessionLogVerbosityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2188,1 +2947,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n@@ -2190,1 +2949,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -2197,3 +2956,1 @@\n-    private static final AddressLayout SessionGetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputName\"));\n-\n-    private static final long SessionGetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOutputName\"));\n+    private static final AddressLayout SetSessionLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogVerbosityLevel\"));\n@@ -2202,1 +2959,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2204,1 +2961,1 @@\n-     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n@@ -2207,3 +2964,2 @@\n-    public static MemorySegment SessionGetOutputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET);\n-        return SessionGetOutputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout SetSessionLogVerbosityLevel$layout() {\n+        return SetSessionLogVerbosityLevel$LAYOUT;\n@@ -2212,0 +2968,2 @@\n+    private static final long SetSessionLogVerbosityLevel$OFFSET = 168;\n+\n@@ -2213,0 +2971,1 @@\n+     * Offset for field:\n@@ -2214,1 +2973,1 @@\n-     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n@@ -2217,22 +2976,2 @@\n-    private static class SessionGetOverridableInitializerName {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetSessionLogVerbosityLevel$offset() {\n+        return SetSessionLogVerbosityLevel$OFFSET;\n@@ -2241,3 +2980,9 @@\n-    private static final AddressLayout SessionGetOverridableInitializerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerName\"));\n-\n-    private static final long SessionGetOverridableInitializerName$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetOverridableInitializerName\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionLogVerbosityLevel(MemorySegment struct) {\n+        return struct.get(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET);\n+    }\n@@ -2246,1 +2991,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2248,1 +2993,1 @@\n-     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * OrtStatusPtr (*SetSessionLogVerbosityLevel)(OrtSessionOptions *, int)\n@@ -2251,3 +2996,2 @@\n-    public static MemorySegment SessionGetOverridableInitializerName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET);\n-        return SessionGetOverridableInitializerName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void SetSessionLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetSessionLogVerbosityLevel$LAYOUT, SetSessionLogVerbosityLevel$OFFSET, fieldValue);\n@@ -2258,1 +3002,1 @@\n-     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n@@ -2261,1 +3005,12 @@\n-    private static class CreateRunOptions {\n+    public static class SetSessionLogSeverityLevel {\n+\n+        SetSessionLogSeverityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -2264,2 +3019,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -2268,0 +3024,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetSessionLogSeverityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetSessionLogSeverityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2273,1 +3046,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n@@ -2275,1 +3048,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -2282,3 +3055,1 @@\n-    private static final AddressLayout CreateRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateRunOptions\"));\n-\n-    private static final long CreateRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateRunOptions\"));\n+    private static final AddressLayout SetSessionLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionLogSeverityLevel\"));\n@@ -2287,1 +3058,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2289,1 +3060,1 @@\n-     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n@@ -2292,3 +3063,2 @@\n-    public static MemorySegment CreateRunOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET);\n-        return CreateRunOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout SetSessionLogSeverityLevel$layout() {\n+        return SetSessionLogSeverityLevel$LAYOUT;\n@@ -2297,0 +3067,2 @@\n+    private static final long SetSessionLogSeverityLevel$OFFSET = 176;\n+\n@@ -2298,0 +3070,1 @@\n+     * Offset for field:\n@@ -2299,1 +3072,1 @@\n-     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n@@ -2302,20 +3075,2 @@\n-    private static class RunOptionsSetRunLogVerbosityLevel {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetSessionLogSeverityLevel$offset() {\n+        return SetSessionLogSeverityLevel$OFFSET;\n@@ -2324,3 +3079,9 @@\n-    private static final AddressLayout RunOptionsSetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunLogVerbosityLevel\"));\n-\n-    private static final long RunOptionsSetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetRunLogVerbosityLevel\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionLogSeverityLevel(MemorySegment struct) {\n+        return struct.get(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET);\n+    }\n@@ -2329,1 +3090,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2331,1 +3092,1 @@\n-     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * OrtStatusPtr (*SetSessionLogSeverityLevel)(OrtSessionOptions *, int)\n@@ -2334,3 +3095,2 @@\n-    public static MemorySegment RunOptionsSetRunLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET);\n-        return RunOptionsSetRunLogVerbosityLevel.invoke(funcPtr, _x0, _x1);\n+    public static void SetSessionLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetSessionLogSeverityLevel$LAYOUT, SetSessionLogSeverityLevel$OFFSET, fieldValue);\n@@ -2341,1 +3101,1 @@\n-     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n@@ -2344,1 +3104,12 @@\n-    private static class RunOptionsSetRunLogSeverityLevel {\n+    public static class SetSessionGraphOptimizationLevel {\n+\n+        SetSessionGraphOptimizationLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -2347,3 +3118,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -2352,0 +3123,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetSessionGraphOptimizationLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetSessionGraphOptimizationLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2366,3 +3154,1 @@\n-    private static final AddressLayout RunOptionsSetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunLogSeverityLevel\"));\n-\n-    private static final long RunOptionsSetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetRunLogSeverityLevel\"));\n+    private static final AddressLayout SetSessionGraphOptimizationLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSessionGraphOptimizationLevel\"));\n@@ -2371,1 +3157,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2373,1 +3159,1 @@\n-     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n@@ -2376,3 +3162,2 @@\n-    public static MemorySegment RunOptionsSetRunLogSeverityLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET);\n-        return RunOptionsSetRunLogSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SetSessionGraphOptimizationLevel$layout() {\n+        return SetSessionGraphOptimizationLevel$LAYOUT;\n@@ -2381,0 +3166,2 @@\n+    private static final long SetSessionGraphOptimizationLevel$OFFSET = 184;\n+\n@@ -2382,0 +3169,1 @@\n+     * Offset for field:\n@@ -2383,1 +3171,1 @@\n-     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n@@ -2386,20 +3174,2 @@\n-    private static class RunOptionsSetRunTag {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetSessionGraphOptimizationLevel$offset() {\n+        return SetSessionGraphOptimizationLevel$OFFSET;\n@@ -2408,3 +3178,9 @@\n-    private static final AddressLayout RunOptionsSetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunTag\"));\n-\n-    private static final long RunOptionsSetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetRunTag\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static MemorySegment SetSessionGraphOptimizationLevel(MemorySegment struct) {\n+        return struct.get(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET);\n+    }\n@@ -2413,1 +3189,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2415,1 +3191,1 @@\n-     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * OrtStatusPtr (*SetSessionGraphOptimizationLevel)(OrtSessionOptions *, GraphOptimizationLevel)\n@@ -2418,3 +3194,2 @@\n-    public static MemorySegment RunOptionsSetRunTag(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET);\n-        return RunOptionsSetRunTag.invoke(funcPtr, _x0, _x1);\n+    public static void SetSessionGraphOptimizationLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetSessionGraphOptimizationLevel$LAYOUT, SetSessionGraphOptimizationLevel$OFFSET, fieldValue);\n@@ -2425,1 +3200,1 @@\n-     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n@@ -2428,1 +3203,12 @@\n-    private static class RunOptionsGetRunLogVerbosityLevel {\n+    public static class SetIntraOpNumThreads {\n+\n+        SetIntraOpNumThreads() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -2431,3 +3217,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -2436,0 +3222,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetIntraOpNumThreads.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetIntraOpNumThreads.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2441,1 +3244,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n@@ -2450,1 +3253,11 @@\n-    private static final AddressLayout RunOptionsGetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunLogVerbosityLevel\"));\n+    private static final AddressLayout SetIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetIntraOpNumThreads\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout SetIntraOpNumThreads$layout() {\n+        return SetIntraOpNumThreads$LAYOUT;\n+    }\n@@ -2452,1 +3265,1 @@\n-    private static final long RunOptionsGetRunLogVerbosityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsGetRunLogVerbosityLevel\"));\n+    private static final long SetIntraOpNumThreads$OFFSET = 192;\n@@ -2455,1 +3268,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -2457,1 +3270,1 @@\n-     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n@@ -2460,3 +3273,2 @@\n-    public static MemorySegment RunOptionsGetRunLogVerbosityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET);\n-        return RunOptionsGetRunLogVerbosityLevel.invoke(funcPtr, _x0, _x1);\n+    public static final long SetIntraOpNumThreads$offset() {\n+        return SetIntraOpNumThreads$OFFSET;\n@@ -2466,0 +3278,1 @@\n+     * Getter for field:\n@@ -2467,1 +3280,20 @@\n-     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetIntraOpNumThreads(MemorySegment struct) {\n+        return struct.get(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetIntraOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static void SetIntraOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetIntraOpNumThreads$LAYOUT, SetIntraOpNumThreads$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n@@ -2470,1 +3302,12 @@\n-    private static class RunOptionsGetRunLogSeverityLevel {\n+    public static class SetInterOpNumThreads {\n+\n+        SetInterOpNumThreads() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -2473,3 +3316,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -2478,0 +3321,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetInterOpNumThreads.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetInterOpNumThreads.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2483,1 +3343,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n@@ -2492,3 +3352,1 @@\n-    private static final AddressLayout RunOptionsGetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunLogSeverityLevel\"));\n-\n-    private static final long RunOptionsGetRunLogSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsGetRunLogSeverityLevel\"));\n+    private static final AddressLayout SetInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetInterOpNumThreads\"));\n@@ -2497,1 +3355,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2499,1 +3357,1 @@\n-     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n@@ -2502,3 +3360,2 @@\n-    public static MemorySegment RunOptionsGetRunLogSeverityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET);\n-        return RunOptionsGetRunLogSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SetInterOpNumThreads$layout() {\n+        return SetInterOpNumThreads$LAYOUT;\n@@ -2507,0 +3364,2 @@\n+    private static final long SetInterOpNumThreads$OFFSET = 200;\n+\n@@ -2508,0 +3367,1 @@\n+     * Offset for field:\n@@ -2509,1 +3369,30 @@\n-     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static final long SetInterOpNumThreads$offset() {\n+        return SetInterOpNumThreads$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetInterOpNumThreads(MemorySegment struct) {\n+        return struct.get(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetInterOpNumThreads)(OrtSessionOptions *, int)\n+     * }\n+     *\/\n+    public static void SetInterOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetInterOpNumThreads$LAYOUT, SetInterOpNumThreads$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n@@ -2512,1 +3401,12 @@\n-    private static class RunOptionsGetRunTag {\n+    public static class CreateCustomOpDomain {\n+\n+        CreateCustomOpDomain() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -2515,3 +3415,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2520,0 +3420,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateCustomOpDomain.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateCustomOpDomain.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2534,1 +3451,11 @@\n-    private static final AddressLayout RunOptionsGetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunTag\"));\n+    private static final AddressLayout CreateCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCustomOpDomain\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateCustomOpDomain$layout() {\n+        return CreateCustomOpDomain$LAYOUT;\n+    }\n@@ -2536,1 +3463,1 @@\n-    private static final long RunOptionsGetRunTag$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsGetRunTag\"));\n+    private static final long CreateCustomOpDomain$OFFSET = 208;\n@@ -2539,1 +3466,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -2541,1 +3468,1 @@\n-     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n@@ -2544,3 +3471,2 @@\n-    public static MemorySegment RunOptionsGetRunTag(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET);\n-        return RunOptionsGetRunTag.invoke(funcPtr, _x0, _x1);\n+    public static final long CreateCustomOpDomain$offset() {\n+        return CreateCustomOpDomain$OFFSET;\n@@ -2550,0 +3476,1 @@\n+     * Getter for field:\n@@ -2551,1 +3478,20 @@\n-     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCustomOpDomain(MemorySegment struct) {\n+        return struct.get(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCustomOpDomain)(const char *, OrtCustomOpDomain **)\n+     * }\n+     *\/\n+    public static void CreateCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateCustomOpDomain$LAYOUT, CreateCustomOpDomain$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n@@ -2554,1 +3500,12 @@\n-    private static class RunOptionsSetTerminate {\n+    public static class CustomOpDomain_Add {\n+\n+        CustomOpDomain_Add() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -2557,2 +3514,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2561,0 +3519,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CustomOpDomain_Add.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CustomOpDomain_Add.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2566,1 +3541,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -2568,1 +3543,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -2575,1 +3550,1 @@\n-    private static final AddressLayout RunOptionsSetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetTerminate\"));\n+    private static final AddressLayout CustomOpDomain_Add$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CustomOpDomain_Add\"));\n@@ -2577,1 +3552,11 @@\n-    private static final long RunOptionsSetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsSetTerminate\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout CustomOpDomain_Add$layout() {\n+        return CustomOpDomain_Add$LAYOUT;\n+    }\n+\n+    private static final long CustomOpDomain_Add$OFFSET = 216;\n@@ -2580,1 +3565,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -2582,1 +3567,1 @@\n-     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n@@ -2585,3 +3570,2 @@\n-    public static MemorySegment RunOptionsSetTerminate(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET);\n-        return RunOptionsSetTerminate.invoke(funcPtr, _x0);\n+    public static final long CustomOpDomain_Add$offset() {\n+        return CustomOpDomain_Add$OFFSET;\n@@ -2591,0 +3575,1 @@\n+     * Getter for field:\n@@ -2592,1 +3577,119 @@\n-     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment CustomOpDomain_Add(MemorySegment struct) {\n+        return struct.get(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CustomOpDomain_Add)(OrtCustomOpDomain *, const OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void CustomOpDomain_Add(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CustomOpDomain_Add$LAYOUT, CustomOpDomain_Add$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static class AddCustomOpDomain {\n+\n+        AddCustomOpDomain() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddCustomOpDomain.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddCustomOpDomain.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddCustomOpDomain\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static final AddressLayout AddCustomOpDomain$layout() {\n+        return AddCustomOpDomain$LAYOUT;\n+    }\n+\n+    private static final long AddCustomOpDomain$OFFSET = 224;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static final long AddCustomOpDomain$offset() {\n+        return AddCustomOpDomain$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static MemorySegment AddCustomOpDomain(MemorySegment struct) {\n+        return struct.get(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddCustomOpDomain)(OrtSessionOptions *, OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static void AddCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddCustomOpDomain$LAYOUT, AddCustomOpDomain$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n@@ -2595,1 +3698,12 @@\n-    private static class RunOptionsUnsetTerminate {\n+    public static class RegisterCustomOpsLibrary {\n+\n+        RegisterCustomOpsLibrary() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -2598,2 +3712,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2602,0 +3718,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RegisterCustomOpsLibrary.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RegisterCustomOpsLibrary.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2607,1 +3740,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -2609,1 +3742,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -2616,1 +3749,11 @@\n-    private static final AddressLayout RunOptionsUnsetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsUnsetTerminate\"));\n+    private static final AddressLayout RegisterCustomOpsLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsLibrary\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout RegisterCustomOpsLibrary$layout() {\n+        return RegisterCustomOpsLibrary$LAYOUT;\n+    }\n@@ -2618,1 +3761,1 @@\n-    private static final long RunOptionsUnsetTerminate$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsUnsetTerminate\"));\n+    private static final long RegisterCustomOpsLibrary$OFFSET = 232;\n@@ -2621,1 +3764,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -2623,1 +3766,1 @@\n-     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n@@ -2626,3 +3769,2 @@\n-    public static MemorySegment RunOptionsUnsetTerminate(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET);\n-        return RunOptionsUnsetTerminate.invoke(funcPtr, _x0);\n+    public static final long RegisterCustomOpsLibrary$offset() {\n+        return RegisterCustomOpsLibrary$OFFSET;\n@@ -2632,0 +3774,1 @@\n+     * Getter for field:\n@@ -2633,1 +3776,20 @@\n-     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterCustomOpsLibrary(MemorySegment struct) {\n+        return struct.get(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary)(OrtSessionOptions *, const char *, void **)\n+     * }\n+     *\/\n+    public static void RegisterCustomOpsLibrary(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RegisterCustomOpsLibrary$LAYOUT, RegisterCustomOpsLibrary$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n@@ -2636,1 +3798,23226 @@\n-    private static class CreateTensorAsOrtValue {\n+    public static class SessionGetInputCount {\n+\n+        SessionGetInputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetInputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetInputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetInputCount$layout() {\n+        return SessionGetInputCount$LAYOUT;\n+    }\n+\n+    private static final long SessionGetInputCount$OFFSET = 240;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static final long SessionGetInputCount$offset() {\n+        return SessionGetInputCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetInputCount(MemorySegment struct) {\n+        return struct.get(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static void SessionGetInputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetInputCount$LAYOUT, SessionGetInputCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static class SessionGetOutputCount {\n+\n+        SessionGetOutputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetOutputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOutputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOutputCount$layout() {\n+        return SessionGetOutputCount$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOutputCount$OFFSET = 248;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static final long SessionGetOutputCount$offset() {\n+        return SessionGetOutputCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOutputCount(MemorySegment struct) {\n+        return struct.get(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static void SessionGetOutputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOutputCount$LAYOUT, SessionGetOutputCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static class SessionGetOverridableInitializerCount {\n+\n+        SessionGetOverridableInitializerCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetOverridableInitializerCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOverridableInitializerCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOverridableInitializerCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOverridableInitializerCount$layout() {\n+        return SessionGetOverridableInitializerCount$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOverridableInitializerCount$OFFSET = 256;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static final long SessionGetOverridableInitializerCount$offset() {\n+        return SessionGetOverridableInitializerCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOverridableInitializerCount(MemorySegment struct) {\n+        return struct.get(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerCount)(const OrtSession *, size_t *)\n+     * }\n+     *\/\n+    public static void SessionGetOverridableInitializerCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOverridableInitializerCount$LAYOUT, SessionGetOverridableInitializerCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class SessionGetInputTypeInfo {\n+\n+        SessionGetInputTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetInputTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetInputTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetInputTypeInfo$layout() {\n+        return SessionGetInputTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long SessionGetInputTypeInfo$OFFSET = 264;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long SessionGetInputTypeInfo$offset() {\n+        return SessionGetInputTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetInputTypeInfo(MemorySegment struct) {\n+        return struct.get(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void SessionGetInputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetInputTypeInfo$LAYOUT, SessionGetInputTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class SessionGetOutputTypeInfo {\n+\n+        SessionGetOutputTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetOutputTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOutputTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOutputTypeInfo$layout() {\n+        return SessionGetOutputTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOutputTypeInfo$OFFSET = 272;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long SessionGetOutputTypeInfo$offset() {\n+        return SessionGetOutputTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOutputTypeInfo(MemorySegment struct) {\n+        return struct.get(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void SessionGetOutputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOutputTypeInfo$LAYOUT, SessionGetOutputTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class SessionGetOverridableInitializerTypeInfo {\n+\n+        SessionGetOverridableInitializerTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetOverridableInitializerTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOverridableInitializerTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOverridableInitializerTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOverridableInitializerTypeInfo$layout() {\n+        return SessionGetOverridableInitializerTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOverridableInitializerTypeInfo$OFFSET = 280;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long SessionGetOverridableInitializerTypeInfo$offset() {\n+        return SessionGetOverridableInitializerTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOverridableInitializerTypeInfo(MemorySegment struct) {\n+        return struct.get(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerTypeInfo)(const OrtSession *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void SessionGetOverridableInitializerTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOverridableInitializerTypeInfo$LAYOUT, SessionGetOverridableInitializerTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class SessionGetInputName {\n+\n+        SessionGetInputName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetInputName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetInputName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetInputName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetInputName$layout() {\n+        return SessionGetInputName$LAYOUT;\n+    }\n+\n+    private static final long SessionGetInputName$OFFSET = 288;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long SessionGetInputName$offset() {\n+        return SessionGetInputName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetInputName(MemorySegment struct) {\n+        return struct.get(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetInputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void SessionGetInputName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetInputName$LAYOUT, SessionGetInputName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class SessionGetOutputName {\n+\n+        SessionGetOutputName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetOutputName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOutputName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOutputName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOutputName$layout() {\n+        return SessionGetOutputName$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOutputName$OFFSET = 296;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long SessionGetOutputName$offset() {\n+        return SessionGetOutputName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOutputName(MemorySegment struct) {\n+        return struct.get(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOutputName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void SessionGetOutputName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOutputName$LAYOUT, SessionGetOutputName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class SessionGetOverridableInitializerName {\n+\n+        SessionGetOverridableInitializerName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetOverridableInitializerName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOverridableInitializerName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOverridableInitializerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOverridableInitializerName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOverridableInitializerName$layout() {\n+        return SessionGetOverridableInitializerName$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOverridableInitializerName$OFFSET = 304;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long SessionGetOverridableInitializerName$offset() {\n+        return SessionGetOverridableInitializerName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOverridableInitializerName(MemorySegment struct) {\n+        return struct.get(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOverridableInitializerName)(const OrtSession *, size_t, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void SessionGetOverridableInitializerName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOverridableInitializerName$LAYOUT, SessionGetOverridableInitializerName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    public static class CreateRunOptions {\n+\n+        CreateRunOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateRunOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateRunOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateRunOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateRunOptions$layout() {\n+        return CreateRunOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateRunOptions$OFFSET = 312;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    public static final long CreateRunOptions$offset() {\n+        return CreateRunOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateRunOptions(MemorySegment struct) {\n+        return struct.get(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateRunOptions)(OrtRunOptions **)\n+     * }\n+     *\/\n+    public static void CreateRunOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateRunOptions$LAYOUT, CreateRunOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static class RunOptionsSetRunLogVerbosityLevel {\n+\n+        RunOptionsSetRunLogVerbosityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsSetRunLogVerbosityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsSetRunLogVerbosityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunLogVerbosityLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsSetRunLogVerbosityLevel$layout() {\n+        return RunOptionsSetRunLogVerbosityLevel$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsSetRunLogVerbosityLevel$OFFSET = 320;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static final long RunOptionsSetRunLogVerbosityLevel$offset() {\n+        return RunOptionsSetRunLogVerbosityLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetRunLogVerbosityLevel(MemorySegment struct) {\n+        return struct.get(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogVerbosityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static void RunOptionsSetRunLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsSetRunLogVerbosityLevel$LAYOUT, RunOptionsSetRunLogVerbosityLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static class RunOptionsSetRunLogSeverityLevel {\n+\n+        RunOptionsSetRunLogSeverityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsSetRunLogSeverityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsSetRunLogSeverityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunLogSeverityLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsSetRunLogSeverityLevel$layout() {\n+        return RunOptionsSetRunLogSeverityLevel$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsSetRunLogSeverityLevel$OFFSET = 328;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static final long RunOptionsSetRunLogSeverityLevel$offset() {\n+        return RunOptionsSetRunLogSeverityLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetRunLogSeverityLevel(MemorySegment struct) {\n+        return struct.get(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunLogSeverityLevel)(OrtRunOptions *, int)\n+     * }\n+     *\/\n+    public static void RunOptionsSetRunLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsSetRunLogSeverityLevel$LAYOUT, RunOptionsSetRunLogSeverityLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static class RunOptionsSetRunTag {\n+\n+        RunOptionsSetRunTag() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsSetRunTag.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsSetRunTag.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetRunTag\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsSetRunTag$layout() {\n+        return RunOptionsSetRunTag$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsSetRunTag$OFFSET = 336;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static final long RunOptionsSetRunTag$offset() {\n+        return RunOptionsSetRunTag$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetRunTag(MemorySegment struct) {\n+        return struct.get(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetRunTag)(OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static void RunOptionsSetRunTag(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsSetRunTag$LAYOUT, RunOptionsSetRunTag$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static class RunOptionsGetRunLogVerbosityLevel {\n+\n+        RunOptionsGetRunLogVerbosityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsGetRunLogVerbosityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsGetRunLogVerbosityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsGetRunLogVerbosityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunLogVerbosityLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsGetRunLogVerbosityLevel$layout() {\n+        return RunOptionsGetRunLogVerbosityLevel$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsGetRunLogVerbosityLevel$OFFSET = 344;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static final long RunOptionsGetRunLogVerbosityLevel$offset() {\n+        return RunOptionsGetRunLogVerbosityLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsGetRunLogVerbosityLevel(MemorySegment struct) {\n+        return struct.get(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogVerbosityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static void RunOptionsGetRunLogVerbosityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsGetRunLogVerbosityLevel$LAYOUT, RunOptionsGetRunLogVerbosityLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static class RunOptionsGetRunLogSeverityLevel {\n+\n+        RunOptionsGetRunLogSeverityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsGetRunLogSeverityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsGetRunLogSeverityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsGetRunLogSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunLogSeverityLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsGetRunLogSeverityLevel$layout() {\n+        return RunOptionsGetRunLogSeverityLevel$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsGetRunLogSeverityLevel$OFFSET = 352;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static final long RunOptionsGetRunLogSeverityLevel$offset() {\n+        return RunOptionsGetRunLogSeverityLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsGetRunLogSeverityLevel(MemorySegment struct) {\n+        return struct.get(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunLogSeverityLevel)(const OrtRunOptions *, int *)\n+     * }\n+     *\/\n+    public static void RunOptionsGetRunLogSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsGetRunLogSeverityLevel$LAYOUT, RunOptionsGetRunLogSeverityLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    public static class RunOptionsGetRunTag {\n+\n+        RunOptionsGetRunTag() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsGetRunTag.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsGetRunTag.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsGetRunTag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsGetRunTag\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsGetRunTag$layout() {\n+        return RunOptionsGetRunTag$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsGetRunTag$OFFSET = 360;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    public static final long RunOptionsGetRunTag$offset() {\n+        return RunOptionsGetRunTag$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsGetRunTag(MemorySegment struct) {\n+        return struct.get(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsGetRunTag)(const OrtRunOptions *, const char **)\n+     * }\n+     *\/\n+    public static void RunOptionsGetRunTag(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsGetRunTag$LAYOUT, RunOptionsGetRunTag$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static class RunOptionsSetTerminate {\n+\n+        RunOptionsSetTerminate() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsSetTerminate.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsSetTerminate.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsSetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsSetTerminate\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsSetTerminate$layout() {\n+        return RunOptionsSetTerminate$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsSetTerminate$OFFSET = 368;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static final long RunOptionsSetTerminate$offset() {\n+        return RunOptionsSetTerminate$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsSetTerminate(MemorySegment struct) {\n+        return struct.get(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsSetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static void RunOptionsSetTerminate(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsSetTerminate$LAYOUT, RunOptionsSetTerminate$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static class RunOptionsUnsetTerminate {\n+\n+        RunOptionsUnsetTerminate() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsUnsetTerminate.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsUnsetTerminate.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunOptionsUnsetTerminate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsUnsetTerminate\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunOptionsUnsetTerminate$layout() {\n+        return RunOptionsUnsetTerminate$LAYOUT;\n+    }\n+\n+    private static final long RunOptionsUnsetTerminate$OFFSET = 376;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static final long RunOptionsUnsetTerminate$offset() {\n+        return RunOptionsUnsetTerminate$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsUnsetTerminate(MemorySegment struct) {\n+        return struct.get(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsUnsetTerminate)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static void RunOptionsUnsetTerminate(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsUnsetTerminate$LAYOUT, RunOptionsUnsetTerminate$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static class CreateTensorAsOrtValue {\n+\n+        CreateTensorAsOrtValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateTensorAsOrtValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateTensorAsOrtValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorAsOrtValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateTensorAsOrtValue$layout() {\n+        return CreateTensorAsOrtValue$LAYOUT;\n+    }\n+\n+    private static final long CreateTensorAsOrtValue$OFFSET = 384;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateTensorAsOrtValue$offset() {\n+        return CreateTensorAsOrtValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorAsOrtValue(MemorySegment struct) {\n+        return struct.get(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static void CreateTensorAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static class CreateTensorWithDataAsOrtValue {\n+\n+        CreateTensorWithDataAsOrtValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateTensorWithDataAsOrtValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateTensorWithDataAsOrtValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorWithDataAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorWithDataAsOrtValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateTensorWithDataAsOrtValue$layout() {\n+        return CreateTensorWithDataAsOrtValue$LAYOUT;\n+    }\n+\n+    private static final long CreateTensorWithDataAsOrtValue$OFFSET = 392;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateTensorWithDataAsOrtValue$offset() {\n+        return CreateTensorWithDataAsOrtValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorWithDataAsOrtValue(MemorySegment struct) {\n+        return struct.get(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static void CreateTensorWithDataAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static class IsTensor {\n+\n+        IsTensor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(IsTensor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(IsTensor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout IsTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"IsTensor\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout IsTensor$layout() {\n+        return IsTensor$LAYOUT;\n+    }\n+\n+    private static final long IsTensor$OFFSET = 400;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static final long IsTensor$offset() {\n+        return IsTensor$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment IsTensor(MemorySegment struct) {\n+        return struct.get(IsTensor$LAYOUT, IsTensor$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static void IsTensor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(IsTensor$LAYOUT, IsTensor$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    public static class GetTensorMutableData {\n+\n+        GetTensorMutableData() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorMutableData.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorMutableData.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorMutableData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorMutableData\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorMutableData$layout() {\n+        return GetTensorMutableData$LAYOUT;\n+    }\n+\n+    private static final long GetTensorMutableData$OFFSET = 408;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    public static final long GetTensorMutableData$offset() {\n+        return GetTensorMutableData$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorMutableData(MemorySegment struct) {\n+        return struct.get(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * }\n+     *\/\n+    public static void GetTensorMutableData(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class FillStringTensor {\n+\n+        FillStringTensor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(FillStringTensor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(FillStringTensor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillStringTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillStringTensor\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout FillStringTensor$layout() {\n+        return FillStringTensor$LAYOUT;\n+    }\n+\n+    private static final long FillStringTensor$OFFSET = 416;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long FillStringTensor$offset() {\n+        return FillStringTensor$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillStringTensor(MemorySegment struct) {\n+        return struct.get(FillStringTensor$LAYOUT, FillStringTensor$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void FillStringTensor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(FillStringTensor$LAYOUT, FillStringTensor$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static class GetStringTensorDataLength {\n+\n+        GetStringTensorDataLength() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetStringTensorDataLength.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetStringTensorDataLength.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorDataLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorDataLength\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetStringTensorDataLength$layout() {\n+        return GetStringTensorDataLength$LAYOUT;\n+    }\n+\n+    private static final long GetStringTensorDataLength$OFFSET = 424;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static final long GetStringTensorDataLength$offset() {\n+        return GetStringTensorDataLength$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorDataLength(MemorySegment struct) {\n+        return struct.get(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static void GetStringTensorDataLength(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    public static class GetStringTensorContent {\n+\n+        GetStringTensorContent() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetStringTensorContent.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetStringTensorContent.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorContent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorContent\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetStringTensorContent$layout() {\n+        return GetStringTensorContent$LAYOUT;\n+    }\n+\n+    private static final long GetStringTensorContent$OFFSET = 432;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    public static final long GetStringTensorContent$offset() {\n+        return GetStringTensorContent$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorContent(MemorySegment struct) {\n+        return struct.get(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * }\n+     *\/\n+    public static void GetStringTensorContent(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static class CastTypeInfoToTensorInfo {\n+\n+        CastTypeInfoToTensorInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CastTypeInfoToTensorInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CastTypeInfoToTensorInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToTensorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToTensorInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CastTypeInfoToTensorInfo$layout() {\n+        return CastTypeInfoToTensorInfo$LAYOUT;\n+    }\n+\n+    private static final long CastTypeInfoToTensorInfo$OFFSET = 440;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final long CastTypeInfoToTensorInfo$offset() {\n+        return CastTypeInfoToTensorInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToTensorInfo(MemorySegment struct) {\n+        return struct.get(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static void CastTypeInfoToTensorInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static class GetOnnxTypeFromTypeInfo {\n+\n+        GetOnnxTypeFromTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetOnnxTypeFromTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetOnnxTypeFromTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOnnxTypeFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOnnxTypeFromTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetOnnxTypeFromTypeInfo$layout() {\n+        return GetOnnxTypeFromTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long GetOnnxTypeFromTypeInfo$OFFSET = 448;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static final long GetOnnxTypeFromTypeInfo$offset() {\n+        return GetOnnxTypeFromTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetOnnxTypeFromTypeInfo(MemorySegment struct) {\n+        return struct.get(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static void GetOnnxTypeFromTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static class CreateTensorTypeAndShapeInfo {\n+\n+        CreateTensorTypeAndShapeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateTensorTypeAndShapeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateTensorTypeAndShapeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorTypeAndShapeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateTensorTypeAndShapeInfo$layout() {\n+        return CreateTensorTypeAndShapeInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateTensorTypeAndShapeInfo$OFFSET = 456;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final long CreateTensorTypeAndShapeInfo$offset() {\n+        return CreateTensorTypeAndShapeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorTypeAndShapeInfo(MemorySegment struct) {\n+        return struct.get(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static void CreateTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    public static class SetTensorElementType {\n+\n+        SetTensorElementType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetTensorElementType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetTensorElementType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetTensorElementType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    public static final AddressLayout SetTensorElementType$layout() {\n+        return SetTensorElementType$LAYOUT;\n+    }\n+\n+    private static final long SetTensorElementType$OFFSET = 464;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    public static final long SetTensorElementType$offset() {\n+        return SetTensorElementType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    public static MemorySegment SetTensorElementType(MemorySegment struct) {\n+        return struct.get(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * }\n+     *\/\n+    public static void SetTensorElementType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static class SetDimensions {\n+\n+        SetDimensions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetDimensions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetDimensions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetDimensions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout SetDimensions$layout() {\n+        return SetDimensions$LAYOUT;\n+    }\n+\n+    private static final long SetDimensions$OFFSET = 472;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final long SetDimensions$offset() {\n+        return SetDimensions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetDimensions(MemorySegment struct) {\n+        return struct.get(SetDimensions$LAYOUT, SetDimensions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static void SetDimensions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetDimensions$LAYOUT, SetDimensions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static class GetTensorElementType {\n+\n+        GetTensorElementType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorElementType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorElementType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorElementType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorElementType$layout() {\n+        return GetTensorElementType$LAYOUT;\n+    }\n+\n+    private static final long GetTensorElementType$OFFSET = 480;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static final long GetTensorElementType$offset() {\n+        return GetTensorElementType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorElementType(MemorySegment struct) {\n+        return struct.get(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static void GetTensorElementType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static class GetDimensionsCount {\n+\n+        GetDimensionsCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetDimensionsCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetDimensionsCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDimensionsCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDimensionsCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetDimensionsCount$layout() {\n+        return GetDimensionsCount$LAYOUT;\n+    }\n+\n+    private static final long GetDimensionsCount$OFFSET = 488;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final long GetDimensionsCount$offset() {\n+        return GetDimensionsCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetDimensionsCount(MemorySegment struct) {\n+        return struct.get(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static void GetDimensionsCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static class GetDimensions {\n+\n+        GetDimensions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetDimensions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetDimensions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDimensions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetDimensions$layout() {\n+        return GetDimensions$LAYOUT;\n+    }\n+\n+    private static final long GetDimensions$OFFSET = 496;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final long GetDimensions$offset() {\n+        return GetDimensions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetDimensions(MemorySegment struct) {\n+        return struct.get(GetDimensions$LAYOUT, GetDimensions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static void GetDimensions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetDimensions$LAYOUT, GetDimensions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static class GetSymbolicDimensions {\n+\n+        GetSymbolicDimensions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSymbolicDimensions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSymbolicDimensions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSymbolicDimensions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSymbolicDimensions$layout() {\n+        return GetSymbolicDimensions$LAYOUT;\n+    }\n+\n+    private static final long GetSymbolicDimensions$OFFSET = 504;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static final long GetSymbolicDimensions$offset() {\n+        return GetSymbolicDimensions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetSymbolicDimensions(MemorySegment struct) {\n+        return struct.get(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static void GetSymbolicDimensions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static class GetTensorShapeElementCount {\n+\n+        GetTensorShapeElementCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorShapeElementCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorShapeElementCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorShapeElementCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorShapeElementCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorShapeElementCount$layout() {\n+        return GetTensorShapeElementCount$LAYOUT;\n+    }\n+\n+    private static final long GetTensorShapeElementCount$OFFSET = 512;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final long GetTensorShapeElementCount$offset() {\n+        return GetTensorShapeElementCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorShapeElementCount(MemorySegment struct) {\n+        return struct.get(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * }\n+     *\/\n+    public static void GetTensorShapeElementCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static class GetTensorTypeAndShape {\n+\n+        GetTensorTypeAndShape() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorTypeAndShape.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorTypeAndShape.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorTypeAndShape\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorTypeAndShape$layout() {\n+        return GetTensorTypeAndShape$LAYOUT;\n+    }\n+\n+    private static final long GetTensorTypeAndShape$OFFSET = 520;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final long GetTensorTypeAndShape$offset() {\n+        return GetTensorTypeAndShape$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorTypeAndShape(MemorySegment struct) {\n+        return struct.get(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static void GetTensorTypeAndShape(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class GetTypeInfo {\n+\n+        GetTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTypeInfo$layout() {\n+        return GetTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long GetTypeInfo$OFFSET = 528;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long GetTypeInfo$offset() {\n+        return GetTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTypeInfo(MemorySegment struct) {\n+        return struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void GetTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static class GetValueType {\n+\n+        GetValueType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetValueType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetValueType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetValueType$layout() {\n+        return GetValueType$LAYOUT;\n+    }\n+\n+    private static final long GetValueType$OFFSET = 536;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static final long GetValueType$offset() {\n+        return GetValueType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetValueType(MemorySegment struct) {\n+        return struct.get(GetValueType$LAYOUT, GetValueType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * }\n+     *\/\n+    public static void GetValueType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetValueType$LAYOUT, GetValueType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static class CreateMemoryInfo {\n+\n+        CreateMemoryInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateMemoryInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateMemoryInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateMemoryInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateMemoryInfo$layout() {\n+        return CreateMemoryInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateMemoryInfo$OFFSET = 544;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final long CreateMemoryInfo$offset() {\n+        return CreateMemoryInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateMemoryInfo(MemorySegment struct) {\n+        return struct.get(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static void CreateMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static class CreateCpuMemoryInfo {\n+\n+        CreateCpuMemoryInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0, int _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateCpuMemoryInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateCpuMemoryInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCpuMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCpuMemoryInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateCpuMemoryInfo$layout() {\n+        return CreateCpuMemoryInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateCpuMemoryInfo$OFFSET = 552;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final long CreateCpuMemoryInfo$offset() {\n+        return CreateCpuMemoryInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCpuMemoryInfo(MemorySegment struct) {\n+        return struct.get(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static void CreateCpuMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static class CompareMemoryInfo {\n+\n+        CompareMemoryInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CompareMemoryInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CompareMemoryInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CompareMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CompareMemoryInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout CompareMemoryInfo$layout() {\n+        return CompareMemoryInfo$LAYOUT;\n+    }\n+\n+    private static final long CompareMemoryInfo$OFFSET = 560;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static final long CompareMemoryInfo$offset() {\n+        return CompareMemoryInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment CompareMemoryInfo(MemorySegment struct) {\n+        return struct.get(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static void CompareMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    public static class MemoryInfoGetName {\n+\n+        MemoryInfoGetName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    public static final AddressLayout MemoryInfoGetName$layout() {\n+        return MemoryInfoGetName$LAYOUT;\n+    }\n+\n+    private static final long MemoryInfoGetName$OFFSET = 568;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    public static final long MemoryInfoGetName$offset() {\n+        return MemoryInfoGetName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetName(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * }\n+     *\/\n+    public static void MemoryInfoGetName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static class MemoryInfoGetId {\n+\n+        MemoryInfoGetId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetId\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout MemoryInfoGetId$layout() {\n+        return MemoryInfoGetId$LAYOUT;\n+    }\n+\n+    private static final long MemoryInfoGetId$OFFSET = 576;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static final long MemoryInfoGetId$offset() {\n+        return MemoryInfoGetId$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetId(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * }\n+     *\/\n+    public static void MemoryInfoGetId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    public static class MemoryInfoGetMemType {\n+\n+        MemoryInfoGetMemType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetMemType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetMemType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetMemType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    public static final AddressLayout MemoryInfoGetMemType$layout() {\n+        return MemoryInfoGetMemType$LAYOUT;\n+    }\n+\n+    private static final long MemoryInfoGetMemType$OFFSET = 584;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    public static final long MemoryInfoGetMemType$offset() {\n+        return MemoryInfoGetMemType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetMemType(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * }\n+     *\/\n+    public static void MemoryInfoGetMemType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    public static class MemoryInfoGetType {\n+\n+        MemoryInfoGetType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    public static final AddressLayout MemoryInfoGetType$layout() {\n+        return MemoryInfoGetType$LAYOUT;\n+    }\n+\n+    private static final long MemoryInfoGetType$OFFSET = 592;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    public static final long MemoryInfoGetType$offset() {\n+        return MemoryInfoGetType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetType(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * }\n+     *\/\n+    public static void MemoryInfoGetType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    public static class AllocatorAlloc {\n+\n+        AllocatorAlloc() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AllocatorAlloc.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AllocatorAlloc.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocatorAlloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorAlloc\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout AllocatorAlloc$layout() {\n+        return AllocatorAlloc$LAYOUT;\n+    }\n+\n+    private static final long AllocatorAlloc$OFFSET = 600;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    public static final long AllocatorAlloc$offset() {\n+        return AllocatorAlloc$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorAlloc(MemorySegment struct) {\n+        return struct.get(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * }\n+     *\/\n+    public static void AllocatorAlloc(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static class AllocatorFree {\n+\n+        AllocatorFree() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AllocatorFree.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AllocatorFree.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocatorFree$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorFree\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout AllocatorFree$layout() {\n+        return AllocatorFree$LAYOUT;\n+    }\n+\n+    private static final long AllocatorFree$OFFSET = 608;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static final long AllocatorFree$offset() {\n+        return AllocatorFree$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorFree(MemorySegment struct) {\n+        return struct.get(AllocatorFree$LAYOUT, AllocatorFree$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * }\n+     *\/\n+    public static void AllocatorFree(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AllocatorFree$LAYOUT, AllocatorFree$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static class AllocatorGetInfo {\n+\n+        AllocatorGetInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AllocatorGetInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AllocatorGetInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AllocatorGetInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorGetInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout AllocatorGetInfo$layout() {\n+        return AllocatorGetInfo$LAYOUT;\n+    }\n+\n+    private static final long AllocatorGetInfo$OFFSET = 616;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final long AllocatorGetInfo$offset() {\n+        return AllocatorGetInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorGetInfo(MemorySegment struct) {\n+        return struct.get(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static void AllocatorGetInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    public static class GetAllocatorWithDefaultOptions {\n+\n+        GetAllocatorWithDefaultOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetAllocatorWithDefaultOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetAllocatorWithDefaultOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetAllocatorWithDefaultOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAllocatorWithDefaultOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetAllocatorWithDefaultOptions$layout() {\n+        return GetAllocatorWithDefaultOptions$LAYOUT;\n+    }\n+\n+    private static final long GetAllocatorWithDefaultOptions$OFFSET = 624;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    public static final long GetAllocatorWithDefaultOptions$offset() {\n+        return GetAllocatorWithDefaultOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment GetAllocatorWithDefaultOptions(MemorySegment struct) {\n+        return struct.get(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * }\n+     *\/\n+    public static void GetAllocatorWithDefaultOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static class AddFreeDimensionOverride {\n+\n+        AddFreeDimensionOverride() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddFreeDimensionOverride.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddFreeDimensionOverride.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddFreeDimensionOverride$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddFreeDimensionOverride\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static final AddressLayout AddFreeDimensionOverride$layout() {\n+        return AddFreeDimensionOverride$LAYOUT;\n+    }\n+\n+    private static final long AddFreeDimensionOverride$OFFSET = 632;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static final long AddFreeDimensionOverride$offset() {\n+        return AddFreeDimensionOverride$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddFreeDimensionOverride(MemorySegment struct) {\n+        return struct.get(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static void AddFreeDimensionOverride(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static class GetValue {\n+\n+        GetValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetValue$layout() {\n+        return GetValue$LAYOUT;\n+    }\n+\n+    private static final long GetValue$OFFSET = 640;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static final long GetValue$offset() {\n+        return GetValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment GetValue(MemorySegment struct) {\n+        return struct.get(GetValue$LAYOUT, GetValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static void GetValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetValue$LAYOUT, GetValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static class GetValueCount {\n+\n+        GetValueCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetValueCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetValueCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetValueCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetValueCount$layout() {\n+        return GetValueCount$LAYOUT;\n+    }\n+\n+    private static final long GetValueCount$OFFSET = 648;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static final long GetValueCount$offset() {\n+        return GetValueCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetValueCount(MemorySegment struct) {\n+        return struct.get(GetValueCount$LAYOUT, GetValueCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static void GetValueCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetValueCount$LAYOUT, GetValueCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    public static class CreateValue {\n+\n+        CreateValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, int _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateValue$layout() {\n+        return CreateValue$LAYOUT;\n+    }\n+\n+    private static final long CreateValue$OFFSET = 656;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateValue$offset() {\n+        return CreateValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateValue(MemorySegment struct) {\n+        return struct.get(CreateValue$LAYOUT, CreateValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * }\n+     *\/\n+    public static void CreateValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateValue$LAYOUT, CreateValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static class CreateOpaqueValue {\n+\n+        CreateOpaqueValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateOpaqueValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateOpaqueValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOpaqueValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateOpaqueValue$layout() {\n+        return CreateOpaqueValue$LAYOUT;\n+    }\n+\n+    private static final long CreateOpaqueValue$OFFSET = 664;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateOpaqueValue$offset() {\n+        return CreateOpaqueValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOpaqueValue(MemorySegment struct) {\n+        return struct.get(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static void CreateOpaqueValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    public static class GetOpaqueValue {\n+\n+        GetOpaqueValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetOpaqueValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetOpaqueValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOpaqueValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetOpaqueValue$layout() {\n+        return GetOpaqueValue$LAYOUT;\n+    }\n+\n+    private static final long GetOpaqueValue$OFFSET = 672;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    public static final long GetOpaqueValue$offset() {\n+        return GetOpaqueValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetOpaqueValue(MemorySegment struct) {\n+        return struct.get(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * }\n+     *\/\n+    public static void GetOpaqueValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    public static class KernelInfoGetAttribute_float {\n+\n+        KernelInfoGetAttribute_float() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAttribute_float.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAttribute_float.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_float\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetAttribute_float$layout() {\n+        return KernelInfoGetAttribute_float$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetAttribute_float$OFFSET = 680;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetAttribute_float$offset() {\n+        return KernelInfoGetAttribute_float$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_float(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * }\n+     *\/\n+    public static void KernelInfoGetAttribute_float(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    public static class KernelInfoGetAttribute_int64 {\n+\n+        KernelInfoGetAttribute_int64() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAttribute_int64.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAttribute_int64.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_int64\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetAttribute_int64$layout() {\n+        return KernelInfoGetAttribute_int64$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetAttribute_int64$OFFSET = 688;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetAttribute_int64$offset() {\n+        return KernelInfoGetAttribute_int64$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_int64(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * }\n+     *\/\n+    public static void KernelInfoGetAttribute_int64(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfoGetAttribute_string {\n+\n+        KernelInfoGetAttribute_string() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAttribute_string.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAttribute_string.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_string\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetAttribute_string$layout() {\n+        return KernelInfoGetAttribute_string$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetAttribute_string$OFFSET = 696;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetAttribute_string$offset() {\n+        return KernelInfoGetAttribute_string$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_string(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfoGetAttribute_string(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelContext_GetInputCount {\n+\n+        KernelContext_GetInputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetInputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetInputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetInputCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetInputCount$layout() {\n+        return KernelContext_GetInputCount$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetInputCount$OFFSET = 704;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetInputCount$offset() {\n+        return KernelContext_GetInputCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetInputCount(MemorySegment struct) {\n+        return struct.get(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelContext_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelContext_GetOutputCount {\n+\n+        KernelContext_GetOutputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetOutputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetOutputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetOutputCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetOutputCount$layout() {\n+        return KernelContext_GetOutputCount$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetOutputCount$OFFSET = 712;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetOutputCount$offset() {\n+        return KernelContext_GetOutputCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetOutputCount(MemorySegment struct) {\n+        return struct.get(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelContext_GetOutputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    public static class KernelContext_GetInput {\n+\n+        KernelContext_GetInput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetInput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetInput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetInput\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetInput$layout() {\n+        return KernelContext_GetInput$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetInput$OFFSET = 720;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetInput$offset() {\n+        return KernelContext_GetInput$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetInput(MemorySegment struct) {\n+        return struct.get(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * }\n+     *\/\n+    public static void KernelContext_GetInput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static class KernelContext_GetOutput {\n+\n+        KernelContext_GetOutput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetOutput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetOutput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetOutput\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetOutput$layout() {\n+        return KernelContext_GetOutput$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetOutput$OFFSET = 728;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetOutput$offset() {\n+        return KernelContext_GetOutput$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetOutput(MemorySegment struct) {\n+        return struct.get(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * }\n+     *\/\n+    public static void KernelContext_GetOutput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    public static class ReleaseEnv {\n+\n+        ReleaseEnv() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseEnv.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseEnv.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseEnv\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseEnv$layout() {\n+        return ReleaseEnv$LAYOUT;\n+    }\n+\n+    private static final long ReleaseEnv$OFFSET = 736;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    public static final long ReleaseEnv$offset() {\n+        return ReleaseEnv$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseEnv(MemorySegment struct) {\n+        return struct.get(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseEnv)(OrtEnv *)\n+     * }\n+     *\/\n+    public static void ReleaseEnv(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    public static class ReleaseStatus {\n+\n+        ReleaseStatus() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseStatus.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseStatus.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseStatus\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseStatus$layout() {\n+        return ReleaseStatus$LAYOUT;\n+    }\n+\n+    private static final long ReleaseStatus$OFFSET = 744;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    public static final long ReleaseStatus$offset() {\n+        return ReleaseStatus$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseStatus(MemorySegment struct) {\n+        return struct.get(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseStatus)(OrtStatus *)\n+     * }\n+     *\/\n+    public static void ReleaseStatus(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static class ReleaseMemoryInfo {\n+\n+        ReleaseMemoryInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseMemoryInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseMemoryInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMemoryInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseMemoryInfo$layout() {\n+        return ReleaseMemoryInfo$LAYOUT;\n+    }\n+\n+    private static final long ReleaseMemoryInfo$OFFSET = 752;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static final long ReleaseMemoryInfo$offset() {\n+        return ReleaseMemoryInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseMemoryInfo(MemorySegment struct) {\n+        return struct.get(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    public static class ReleaseSession {\n+\n+        ReleaseSession() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseSession.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseSession.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSession\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseSession$layout() {\n+        return ReleaseSession$LAYOUT;\n+    }\n+\n+    private static final long ReleaseSession$OFFSET = 760;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    public static final long ReleaseSession$offset() {\n+        return ReleaseSession$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseSession(MemorySegment struct) {\n+        return struct.get(ReleaseSession$LAYOUT, ReleaseSession$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSession)(OrtSession *)\n+     * }\n+     *\/\n+    public static void ReleaseSession(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseSession$LAYOUT, ReleaseSession$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    public static class ReleaseValue {\n+\n+        ReleaseValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseValue$layout() {\n+        return ReleaseValue$LAYOUT;\n+    }\n+\n+    private static final long ReleaseValue$OFFSET = 768;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    public static final long ReleaseValue$offset() {\n+        return ReleaseValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseValue(MemorySegment struct) {\n+        return struct.get(ReleaseValue$LAYOUT, ReleaseValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValue)(OrtValue *)\n+     * }\n+     *\/\n+    public static void ReleaseValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseValue$LAYOUT, ReleaseValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseRunOptions {\n+\n+        ReleaseRunOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseRunOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseRunOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseRunOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseRunOptions$layout() {\n+        return ReleaseRunOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseRunOptions$OFFSET = 776;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseRunOptions$offset() {\n+        return ReleaseRunOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseRunOptions(MemorySegment struct) {\n+        return struct.get(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseRunOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    public static class ReleaseTypeInfo {\n+\n+        ReleaseTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseTypeInfo$layout() {\n+        return ReleaseTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long ReleaseTypeInfo$OFFSET = 784;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    public static final long ReleaseTypeInfo$offset() {\n+        return ReleaseTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseTypeInfo(MemorySegment struct) {\n+        return struct.get(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static class ReleaseTensorTypeAndShapeInfo {\n+\n+        ReleaseTensorTypeAndShapeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseTensorTypeAndShapeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseTensorTypeAndShapeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTensorTypeAndShapeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseTensorTypeAndShapeInfo$layout() {\n+        return ReleaseTensorTypeAndShapeInfo$LAYOUT;\n+    }\n+\n+    private static final long ReleaseTensorTypeAndShapeInfo$OFFSET = 792;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static final long ReleaseTensorTypeAndShapeInfo$offset() {\n+        return ReleaseTensorTypeAndShapeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseTensorTypeAndShapeInfo(MemorySegment struct) {\n+        return struct.get(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseSessionOptions {\n+\n+        ReleaseSessionOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseSessionOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseSessionOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSessionOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseSessionOptions$layout() {\n+        return ReleaseSessionOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseSessionOptions$OFFSET = 800;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseSessionOptions$offset() {\n+        return ReleaseSessionOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseSessionOptions(MemorySegment struct) {\n+        return struct.get(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseSessionOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static class ReleaseCustomOpDomain {\n+\n+        ReleaseCustomOpDomain() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseCustomOpDomain.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseCustomOpDomain.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCustomOpDomain\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseCustomOpDomain$layout() {\n+        return ReleaseCustomOpDomain$LAYOUT;\n+    }\n+\n+    private static final long ReleaseCustomOpDomain$OFFSET = 808;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static final long ReleaseCustomOpDomain$offset() {\n+        return ReleaseCustomOpDomain$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseCustomOpDomain(MemorySegment struct) {\n+        return struct.get(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * }\n+     *\/\n+    public static void ReleaseCustomOpDomain(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    public static class GetDenotationFromTypeInfo {\n+\n+        GetDenotationFromTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetDenotationFromTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetDenotationFromTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDenotationFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDenotationFromTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetDenotationFromTypeInfo$layout() {\n+        return GetDenotationFromTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long GetDenotationFromTypeInfo$OFFSET = 816;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    public static final long GetDenotationFromTypeInfo$offset() {\n+        return GetDenotationFromTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetDenotationFromTypeInfo(MemorySegment struct) {\n+        return struct.get(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * }\n+     *\/\n+    public static void GetDenotationFromTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    public static class CastTypeInfoToMapTypeInfo {\n+\n+        CastTypeInfoToMapTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CastTypeInfoToMapTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CastTypeInfoToMapTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToMapTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CastTypeInfoToMapTypeInfo$layout() {\n+        return CastTypeInfoToMapTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CastTypeInfoToMapTypeInfo$OFFSET = 824;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CastTypeInfoToMapTypeInfo$offset() {\n+        return CastTypeInfoToMapTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToMapTypeInfo(MemorySegment struct) {\n+        return struct.get(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * }\n+     *\/\n+    public static void CastTypeInfoToMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    public static class CastTypeInfoToSequenceTypeInfo {\n+\n+        CastTypeInfoToSequenceTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CastTypeInfoToSequenceTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CastTypeInfoToSequenceTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToSequenceTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CastTypeInfoToSequenceTypeInfo$layout() {\n+        return CastTypeInfoToSequenceTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CastTypeInfoToSequenceTypeInfo$OFFSET = 832;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CastTypeInfoToSequenceTypeInfo$offset() {\n+        return CastTypeInfoToSequenceTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToSequenceTypeInfo(MemorySegment struct) {\n+        return struct.get(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * }\n+     *\/\n+    public static void CastTypeInfoToSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static class GetMapKeyType {\n+\n+        GetMapKeyType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetMapKeyType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetMapKeyType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetMapKeyType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMapKeyType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetMapKeyType$layout() {\n+        return GetMapKeyType$LAYOUT;\n+    }\n+\n+    private static final long GetMapKeyType$OFFSET = 840;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static final long GetMapKeyType$offset() {\n+        return GetMapKeyType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static MemorySegment GetMapKeyType(MemorySegment struct) {\n+        return struct.get(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * }\n+     *\/\n+    public static void GetMapKeyType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class GetMapValueType {\n+\n+        GetMapValueType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetMapValueType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetMapValueType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetMapValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMapValueType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetMapValueType$layout() {\n+        return GetMapValueType$LAYOUT;\n+    }\n+\n+    private static final long GetMapValueType$OFFSET = 848;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long GetMapValueType$offset() {\n+        return GetMapValueType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetMapValueType(MemorySegment struct) {\n+        return struct.get(GetMapValueType$LAYOUT, GetMapValueType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void GetMapValueType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetMapValueType$LAYOUT, GetMapValueType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class GetSequenceElementType {\n+\n+        GetSequenceElementType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSequenceElementType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSequenceElementType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSequenceElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSequenceElementType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSequenceElementType$layout() {\n+        return GetSequenceElementType$LAYOUT;\n+    }\n+\n+    private static final long GetSequenceElementType$OFFSET = 856;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long GetSequenceElementType$offset() {\n+        return GetSequenceElementType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSequenceElementType(MemorySegment struct) {\n+        return struct.get(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void GetSequenceElementType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    public static class ReleaseMapTypeInfo {\n+\n+        ReleaseMapTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseMapTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseMapTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMapTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseMapTypeInfo$layout() {\n+        return ReleaseMapTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long ReleaseMapTypeInfo$OFFSET = 864;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    public static final long ReleaseMapTypeInfo$offset() {\n+        return ReleaseMapTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseMapTypeInfo(MemorySegment struct) {\n+        return struct.get(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    public static class ReleaseSequenceTypeInfo {\n+\n+        ReleaseSequenceTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseSequenceTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseSequenceTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSequenceTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseSequenceTypeInfo$layout() {\n+        return ReleaseSequenceTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long ReleaseSequenceTypeInfo$OFFSET = 872;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    public static final long ReleaseSequenceTypeInfo$offset() {\n+        return ReleaseSequenceTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseSequenceTypeInfo(MemorySegment struct) {\n+        return struct.get(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class SessionEndProfiling {\n+\n+        SessionEndProfiling() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionEndProfiling.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionEndProfiling.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionEndProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionEndProfiling\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionEndProfiling$layout() {\n+        return SessionEndProfiling$LAYOUT;\n+    }\n+\n+    private static final long SessionEndProfiling$OFFSET = 880;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long SessionEndProfiling$offset() {\n+        return SessionEndProfiling$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionEndProfiling(MemorySegment struct) {\n+        return struct.get(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void SessionEndProfiling(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static class SessionGetModelMetadata {\n+\n+        SessionGetModelMetadata() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetModelMetadata.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetModelMetadata.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetModelMetadata\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetModelMetadata$layout() {\n+        return SessionGetModelMetadata$LAYOUT;\n+    }\n+\n+    private static final long SessionGetModelMetadata$OFFSET = 888;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static final long SessionGetModelMetadata$offset() {\n+        return SessionGetModelMetadata$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetModelMetadata(MemorySegment struct) {\n+        return struct.get(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static void SessionGetModelMetadata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetProducerName {\n+\n+        ModelMetadataGetProducerName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetProducerName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetProducerName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetProducerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetProducerName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetProducerName$layout() {\n+        return ModelMetadataGetProducerName$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetProducerName$OFFSET = 896;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetProducerName$offset() {\n+        return ModelMetadataGetProducerName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetProducerName(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetProducerName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetGraphName {\n+\n+        ModelMetadataGetGraphName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetGraphName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetGraphName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetGraphName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetGraphName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetGraphName$layout() {\n+        return ModelMetadataGetGraphName$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetGraphName$OFFSET = 904;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetGraphName$offset() {\n+        return ModelMetadataGetGraphName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetGraphName(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetGraphName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetDomain {\n+\n+        ModelMetadataGetDomain() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetDomain.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetDomain.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetDomain\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetDomain$layout() {\n+        return ModelMetadataGetDomain$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetDomain$OFFSET = 912;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetDomain$offset() {\n+        return ModelMetadataGetDomain$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetDomain(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetDomain(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetDescription {\n+\n+        ModelMetadataGetDescription() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetDescription.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetDescription.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetDescription\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetDescription$layout() {\n+        return ModelMetadataGetDescription$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetDescription$OFFSET = 920;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetDescription$offset() {\n+        return ModelMetadataGetDescription$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetDescription(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetDescription(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    public static class ModelMetadataLookupCustomMetadataMap {\n+\n+        ModelMetadataLookupCustomMetadataMap() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataLookupCustomMetadataMap.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataLookupCustomMetadataMap.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataLookupCustomMetadataMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataLookupCustomMetadataMap\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataLookupCustomMetadataMap$layout() {\n+        return ModelMetadataLookupCustomMetadataMap$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataLookupCustomMetadataMap$OFFSET = 928;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    public static final long ModelMetadataLookupCustomMetadataMap$offset() {\n+        return ModelMetadataLookupCustomMetadataMap$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataLookupCustomMetadataMap(MemorySegment struct) {\n+        return struct.get(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * }\n+     *\/\n+    public static void ModelMetadataLookupCustomMetadataMap(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetVersion {\n+\n+        ModelMetadataGetVersion() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetVersion.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetVersion.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetVersion\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetVersion$layout() {\n+        return ModelMetadataGetVersion$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetVersion$OFFSET = 936;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetVersion$offset() {\n+        return ModelMetadataGetVersion$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetVersion(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetVersion(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    public static class ReleaseModelMetadata {\n+\n+        ReleaseModelMetadata() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseModelMetadata.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseModelMetadata.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseModelMetadata\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseModelMetadata$layout() {\n+        return ReleaseModelMetadata$LAYOUT;\n+    }\n+\n+    private static final long ReleaseModelMetadata$OFFSET = 944;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    public static final long ReleaseModelMetadata$offset() {\n+        return ReleaseModelMetadata$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseModelMetadata(MemorySegment struct) {\n+        return struct.get(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * }\n+     *\/\n+    public static void ReleaseModelMetadata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static class CreateEnvWithGlobalThreadPools {\n+\n+        CreateEnvWithGlobalThreadPools() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateEnvWithGlobalThreadPools.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateEnvWithGlobalThreadPools.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateEnvWithGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithGlobalThreadPools\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateEnvWithGlobalThreadPools$layout() {\n+        return CreateEnvWithGlobalThreadPools$LAYOUT;\n+    }\n+\n+    private static final long CreateEnvWithGlobalThreadPools$OFFSET = 952;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final long CreateEnvWithGlobalThreadPools$offset() {\n+        return CreateEnvWithGlobalThreadPools$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnvWithGlobalThreadPools(MemorySegment struct) {\n+        return struct.get(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static void CreateEnvWithGlobalThreadPools(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static class DisablePerSessionThreads {\n+\n+        DisablePerSessionThreads() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(DisablePerSessionThreads.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(DisablePerSessionThreads.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout DisablePerSessionThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisablePerSessionThreads\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout DisablePerSessionThreads$layout() {\n+        return DisablePerSessionThreads$LAYOUT;\n+    }\n+\n+    private static final long DisablePerSessionThreads$OFFSET = 960;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static final long DisablePerSessionThreads$offset() {\n+        return DisablePerSessionThreads$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment DisablePerSessionThreads(MemorySegment struct) {\n+        return struct.get(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static void DisablePerSessionThreads(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    public static class CreateThreadingOptions {\n+\n+        CreateThreadingOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateThreadingOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateThreadingOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateThreadingOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateThreadingOptions$layout() {\n+        return CreateThreadingOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateThreadingOptions$OFFSET = 968;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    public static final long CreateThreadingOptions$offset() {\n+        return CreateThreadingOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateThreadingOptions(MemorySegment struct) {\n+        return struct.get(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * }\n+     *\/\n+    public static void CreateThreadingOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseThreadingOptions {\n+\n+        ReleaseThreadingOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseThreadingOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseThreadingOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseThreadingOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseThreadingOptions$layout() {\n+        return ReleaseThreadingOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseThreadingOptions$OFFSET = 976;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseThreadingOptions$offset() {\n+        return ReleaseThreadingOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseThreadingOptions(MemorySegment struct) {\n+        return struct.get(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseThreadingOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetCustomMetadataMapKeys {\n+\n+        ModelMetadataGetCustomMetadataMapKeys() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetCustomMetadataMapKeys.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetCustomMetadataMapKeys.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetCustomMetadataMapKeys\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$layout() {\n+        return ModelMetadataGetCustomMetadataMapKeys$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetCustomMetadataMapKeys$OFFSET = 984;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetCustomMetadataMapKeys$offset() {\n+        return ModelMetadataGetCustomMetadataMapKeys$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static class AddFreeDimensionOverrideByName {\n+\n+        AddFreeDimensionOverrideByName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddFreeDimensionOverrideByName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddFreeDimensionOverrideByName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddFreeDimensionOverrideByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddFreeDimensionOverrideByName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static final AddressLayout AddFreeDimensionOverrideByName$layout() {\n+        return AddFreeDimensionOverrideByName$LAYOUT;\n+    }\n+\n+    private static final long AddFreeDimensionOverrideByName$OFFSET = 992;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static final long AddFreeDimensionOverrideByName$offset() {\n+        return AddFreeDimensionOverrideByName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddFreeDimensionOverrideByName(MemorySegment struct) {\n+        return struct.get(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * }\n+     *\/\n+    public static void AddFreeDimensionOverrideByName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    public static class GetAvailableProviders {\n+\n+        GetAvailableProviders() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetAvailableProviders.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetAvailableProviders.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAvailableProviders\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetAvailableProviders$layout() {\n+        return GetAvailableProviders$LAYOUT;\n+    }\n+\n+    private static final long GetAvailableProviders$OFFSET = 1000;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    public static final long GetAvailableProviders$offset() {\n+        return GetAvailableProviders$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    public static MemorySegment GetAvailableProviders(MemorySegment struct) {\n+        return struct.get(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * }\n+     *\/\n+    public static void GetAvailableProviders(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    public static class ReleaseAvailableProviders {\n+\n+        ReleaseAvailableProviders() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseAvailableProviders.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseAvailableProviders.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAvailableProviders\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseAvailableProviders$layout() {\n+        return ReleaseAvailableProviders$LAYOUT;\n+    }\n+\n+    private static final long ReleaseAvailableProviders$OFFSET = 1008;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    public static final long ReleaseAvailableProviders$offset() {\n+        return ReleaseAvailableProviders$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseAvailableProviders(MemorySegment struct) {\n+        return struct.get(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * }\n+     *\/\n+    public static void ReleaseAvailableProviders(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static class GetStringTensorElementLength {\n+\n+        GetStringTensorElementLength() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetStringTensorElementLength.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetStringTensorElementLength.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorElementLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorElementLength\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetStringTensorElementLength$layout() {\n+        return GetStringTensorElementLength$LAYOUT;\n+    }\n+\n+    private static final long GetStringTensorElementLength$OFFSET = 1016;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static final long GetStringTensorElementLength$offset() {\n+        return GetStringTensorElementLength$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorElementLength(MemorySegment struct) {\n+        return struct.get(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static void GetStringTensorElementLength(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static class GetStringTensorElement {\n+\n+        GetStringTensorElement() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetStringTensorElement.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetStringTensorElement.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorElement\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetStringTensorElement$layout() {\n+        return GetStringTensorElement$LAYOUT;\n+    }\n+\n+    private static final long GetStringTensorElement$OFFSET = 1024;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static final long GetStringTensorElement$offset() {\n+        return GetStringTensorElement$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStringTensorElement(MemorySegment struct) {\n+        return struct.get(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static void GetStringTensorElement(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    public static class FillStringTensorElement {\n+\n+        FillStringTensorElement() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(FillStringTensorElement.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(FillStringTensorElement.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillStringTensorElement\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout FillStringTensorElement$layout() {\n+        return FillStringTensorElement$LAYOUT;\n+    }\n+\n+    private static final long FillStringTensorElement$OFFSET = 1032;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    public static final long FillStringTensorElement$offset() {\n+        return FillStringTensorElement$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillStringTensorElement(MemorySegment struct) {\n+        return struct.get(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * }\n+     *\/\n+    public static void FillStringTensorElement(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static class AddSessionConfigEntry {\n+\n+        AddSessionConfigEntry() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddSessionConfigEntry.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddSessionConfigEntry.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddSessionConfigEntry\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout AddSessionConfigEntry$layout() {\n+        return AddSessionConfigEntry$LAYOUT;\n+    }\n+\n+    private static final long AddSessionConfigEntry$OFFSET = 1040;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final long AddSessionConfigEntry$offset() {\n+        return AddSessionConfigEntry$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment AddSessionConfigEntry(MemorySegment struct) {\n+        return struct.get(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static void AddSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static class CreateAllocator {\n+\n+        CreateAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAllocator\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateAllocator$layout() {\n+        return CreateAllocator$LAYOUT;\n+    }\n+\n+    private static final long CreateAllocator$OFFSET = 1048;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static final long CreateAllocator$offset() {\n+        return CreateAllocator$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateAllocator(MemorySegment struct) {\n+        return struct.get(CreateAllocator$LAYOUT, CreateAllocator$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static void CreateAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateAllocator$LAYOUT, CreateAllocator$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    public static class ReleaseAllocator {\n+\n+        ReleaseAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAllocator\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseAllocator$layout() {\n+        return ReleaseAllocator$LAYOUT;\n+    }\n+\n+    private static final long ReleaseAllocator$OFFSET = 1056;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    public static final long ReleaseAllocator$offset() {\n+        return ReleaseAllocator$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseAllocator(MemorySegment struct) {\n+        return struct.get(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * }\n+     *\/\n+    public static void ReleaseAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    public static class RunWithBinding {\n+\n+        RunWithBinding() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunWithBinding.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunWithBinding.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunWithBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunWithBinding\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunWithBinding$layout() {\n+        return RunWithBinding$LAYOUT;\n+    }\n+\n+    private static final long RunWithBinding$OFFSET = 1064;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final long RunWithBinding$offset() {\n+        return RunWithBinding$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment RunWithBinding(MemorySegment struct) {\n+        return struct.get(RunWithBinding$LAYOUT, RunWithBinding$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void RunWithBinding(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunWithBinding$LAYOUT, RunWithBinding$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    public static class CreateIoBinding {\n+\n+        CreateIoBinding() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateIoBinding.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateIoBinding.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateIoBinding\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateIoBinding$layout() {\n+        return CreateIoBinding$LAYOUT;\n+    }\n+\n+    private static final long CreateIoBinding$OFFSET = 1072;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    public static final long CreateIoBinding$offset() {\n+        return CreateIoBinding$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateIoBinding(MemorySegment struct) {\n+        return struct.get(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * }\n+     *\/\n+    public static void CreateIoBinding(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static class ReleaseIoBinding {\n+\n+        ReleaseIoBinding() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseIoBinding.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseIoBinding.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseIoBinding\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseIoBinding$layout() {\n+        return ReleaseIoBinding$LAYOUT;\n+    }\n+\n+    private static final long ReleaseIoBinding$OFFSET = 1080;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final long ReleaseIoBinding$offset() {\n+        return ReleaseIoBinding$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseIoBinding(MemorySegment struct) {\n+        return struct.get(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void ReleaseIoBinding(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static class BindInput {\n+\n+        BindInput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(BindInput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(BindInput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout BindInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindInput\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static final AddressLayout BindInput$layout() {\n+        return BindInput$LAYOUT;\n+    }\n+\n+    private static final long BindInput$OFFSET = 1088;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static final long BindInput$offset() {\n+        return BindInput$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment BindInput(MemorySegment struct) {\n+        return struct.get(BindInput$LAYOUT, BindInput$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static void BindInput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(BindInput$LAYOUT, BindInput$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static class BindOutput {\n+\n+        BindOutput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(BindOutput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(BindOutput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout BindOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindOutput\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static final AddressLayout BindOutput$layout() {\n+        return BindOutput$LAYOUT;\n+    }\n+\n+    private static final long BindOutput$OFFSET = 1096;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static final long BindOutput$offset() {\n+        return BindOutput$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment BindOutput(MemorySegment struct) {\n+        return struct.get(BindOutput$LAYOUT, BindOutput$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static void BindOutput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(BindOutput$LAYOUT, BindOutput$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static class BindOutputToDevice {\n+\n+        BindOutputToDevice() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(BindOutputToDevice.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(BindOutputToDevice.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout BindOutputToDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindOutputToDevice\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout BindOutputToDevice$layout() {\n+        return BindOutputToDevice$LAYOUT;\n+    }\n+\n+    private static final long BindOutputToDevice$OFFSET = 1104;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static final long BindOutputToDevice$offset() {\n+        return BindOutputToDevice$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment BindOutputToDevice(MemorySegment struct) {\n+        return struct.get(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static void BindOutputToDevice(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    public static class GetBoundOutputNames {\n+\n+        GetBoundOutputNames() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetBoundOutputNames.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetBoundOutputNames.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetBoundOutputNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBoundOutputNames\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetBoundOutputNames$layout() {\n+        return GetBoundOutputNames$LAYOUT;\n+    }\n+\n+    private static final long GetBoundOutputNames$OFFSET = 1112;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    public static final long GetBoundOutputNames$offset() {\n+        return GetBoundOutputNames$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetBoundOutputNames(MemorySegment struct) {\n+        return struct.get(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * }\n+     *\/\n+    public static void GetBoundOutputNames(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    public static class GetBoundOutputValues {\n+\n+        GetBoundOutputValues() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetBoundOutputValues.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetBoundOutputValues.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetBoundOutputValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBoundOutputValues\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetBoundOutputValues$layout() {\n+        return GetBoundOutputValues$LAYOUT;\n+    }\n+\n+    private static final long GetBoundOutputValues$OFFSET = 1120;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    public static final long GetBoundOutputValues$offset() {\n+        return GetBoundOutputValues$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetBoundOutputValues(MemorySegment struct) {\n+        return struct.get(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * }\n+     *\/\n+    public static void GetBoundOutputValues(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static class ClearBoundInputs {\n+\n+        ClearBoundInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ClearBoundInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ClearBoundInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ClearBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ClearBoundInputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final AddressLayout ClearBoundInputs$layout() {\n+        return ClearBoundInputs$LAYOUT;\n+    }\n+\n+    private static final long ClearBoundInputs$OFFSET = 1128;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final long ClearBoundInputs$offset() {\n+        return ClearBoundInputs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment ClearBoundInputs(MemorySegment struct) {\n+        return struct.get(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void ClearBoundInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static class ClearBoundOutputs {\n+\n+        ClearBoundOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ClearBoundOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ClearBoundOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ClearBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ClearBoundOutputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final AddressLayout ClearBoundOutputs$layout() {\n+        return ClearBoundOutputs$LAYOUT;\n+    }\n+\n+    private static final long ClearBoundOutputs$OFFSET = 1136;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final long ClearBoundOutputs$offset() {\n+        return ClearBoundOutputs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment ClearBoundOutputs(MemorySegment struct) {\n+        return struct.get(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void ClearBoundOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    public static class TensorAt {\n+\n+        TensorAt() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(TensorAt.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(TensorAt.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout TensorAt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"TensorAt\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout TensorAt$layout() {\n+        return TensorAt$LAYOUT;\n+    }\n+\n+    private static final long TensorAt$OFFSET = 1144;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    public static final long TensorAt$offset() {\n+        return TensorAt$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    public static MemorySegment TensorAt(MemorySegment struct) {\n+        return struct.get(TensorAt$LAYOUT, TensorAt$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * }\n+     *\/\n+    public static void TensorAt(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(TensorAt$LAYOUT, TensorAt$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static class CreateAndRegisterAllocator {\n+\n+        CreateAndRegisterAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateAndRegisterAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateAndRegisterAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateAndRegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAndRegisterAllocator\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateAndRegisterAllocator$layout() {\n+        return CreateAndRegisterAllocator$LAYOUT;\n+    }\n+\n+    private static final long CreateAndRegisterAllocator$OFFSET = 1152;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static final long CreateAndRegisterAllocator$offset() {\n+        return CreateAndRegisterAllocator$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static MemorySegment CreateAndRegisterAllocator(MemorySegment struct) {\n+        return struct.get(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static void CreateAndRegisterAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    public static class SetLanguageProjection {\n+\n+        SetLanguageProjection() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetLanguageProjection.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetLanguageProjection.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetLanguageProjection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetLanguageProjection\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    public static final AddressLayout SetLanguageProjection$layout() {\n+        return SetLanguageProjection$LAYOUT;\n+    }\n+\n+    private static final long SetLanguageProjection$OFFSET = 1160;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    public static final long SetLanguageProjection$offset() {\n+        return SetLanguageProjection$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    public static MemorySegment SetLanguageProjection(MemorySegment struct) {\n+        return struct.get(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * }\n+     *\/\n+    public static void SetLanguageProjection(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    public static class SessionGetProfilingStartTimeNs {\n+\n+        SessionGetProfilingStartTimeNs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetProfilingStartTimeNs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetProfilingStartTimeNs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetProfilingStartTimeNs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetProfilingStartTimeNs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetProfilingStartTimeNs$layout() {\n+        return SessionGetProfilingStartTimeNs$LAYOUT;\n+    }\n+\n+    private static final long SessionGetProfilingStartTimeNs$OFFSET = 1168;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    public static final long SessionGetProfilingStartTimeNs$offset() {\n+        return SessionGetProfilingStartTimeNs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetProfilingStartTimeNs(MemorySegment struct) {\n+        return struct.get(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * }\n+     *\/\n+    public static void SessionGetProfilingStartTimeNs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static class SetGlobalIntraOpNumThreads {\n+\n+        SetGlobalIntraOpNumThreads() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalIntraOpNumThreads.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalIntraOpNumThreads.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalIntraOpNumThreads\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalIntraOpNumThreads$layout() {\n+        return SetGlobalIntraOpNumThreads$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalIntraOpNumThreads$OFFSET = 1176;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static final long SetGlobalIntraOpNumThreads$offset() {\n+        return SetGlobalIntraOpNumThreads$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalIntraOpNumThreads(MemorySegment struct) {\n+        return struct.get(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static void SetGlobalIntraOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static class SetGlobalInterOpNumThreads {\n+\n+        SetGlobalInterOpNumThreads() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalInterOpNumThreads.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalInterOpNumThreads.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalInterOpNumThreads\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalInterOpNumThreads$layout() {\n+        return SetGlobalInterOpNumThreads$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalInterOpNumThreads$OFFSET = 1184;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static final long SetGlobalInterOpNumThreads$offset() {\n+        return SetGlobalInterOpNumThreads$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalInterOpNumThreads(MemorySegment struct) {\n+        return struct.get(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static void SetGlobalInterOpNumThreads(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static class SetGlobalSpinControl {\n+\n+        SetGlobalSpinControl() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalSpinControl.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalSpinControl.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalSpinControl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalSpinControl\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalSpinControl$layout() {\n+        return SetGlobalSpinControl$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalSpinControl$OFFSET = 1192;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static final long SetGlobalSpinControl$offset() {\n+        return SetGlobalSpinControl$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalSpinControl(MemorySegment struct) {\n+        return struct.get(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * }\n+     *\/\n+    public static void SetGlobalSpinControl(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static class AddInitializer {\n+\n+        AddInitializer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddInitializer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddInitializer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddInitializer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static final AddressLayout AddInitializer$layout() {\n+        return AddInitializer$LAYOUT;\n+    }\n+\n+    private static final long AddInitializer$OFFSET = 1200;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static final long AddInitializer$offset() {\n+        return AddInitializer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static MemorySegment AddInitializer(MemorySegment struct) {\n+        return struct.get(AddInitializer$LAYOUT, AddInitializer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * }\n+     *\/\n+    public static void AddInitializer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddInitializer$LAYOUT, AddInitializer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static class CreateEnvWithCustomLoggerAndGlobalThreadPools {\n+\n+        CreateEnvWithCustomLoggerAndGlobalThreadPools() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateEnvWithCustomLoggerAndGlobalThreadPools.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateEnvWithCustomLoggerAndGlobalThreadPools.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$layout() {\n+        return CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT;\n+    }\n+\n+    private static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET = 1208;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$offset() {\n+        return CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct) {\n+        return struct.get(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * }\n+     *\/\n+    public static void CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_CUDA {\n+\n+        SessionOptionsAppendExecutionProvider_CUDA() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_CUDA.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CUDA.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$layout() {\n+        return SessionOptionsAppendExecutionProvider_CUDA$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_CUDA$OFFSET = 1216;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_CUDA$offset() {\n+        return SessionOptionsAppendExecutionProvider_CUDA$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_ROCM {\n+\n+        SessionOptionsAppendExecutionProvider_ROCM() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_ROCM.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_ROCM.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_ROCM\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$layout() {\n+        return SessionOptionsAppendExecutionProvider_ROCM$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_ROCM$OFFSET = 1224;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_ROCM$offset() {\n+        return SessionOptionsAppendExecutionProvider_ROCM$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_OpenVINO {\n+\n+        SessionOptionsAppendExecutionProvider_OpenVINO() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_OpenVINO.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_OpenVINO.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$layout() {\n+        return SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET = 1232;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_OpenVINO$offset() {\n+        return SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static class SetGlobalDenormalAsZero {\n+\n+        SetGlobalDenormalAsZero() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalDenormalAsZero.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalDenormalAsZero.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalDenormalAsZero$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalDenormalAsZero\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalDenormalAsZero$layout() {\n+        return SetGlobalDenormalAsZero$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalDenormalAsZero$OFFSET = 1240;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static final long SetGlobalDenormalAsZero$offset() {\n+        return SetGlobalDenormalAsZero$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalDenormalAsZero(MemorySegment struct) {\n+        return struct.get(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * }\n+     *\/\n+    public static void SetGlobalDenormalAsZero(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static class CreateArenaCfg {\n+\n+        CreateArenaCfg() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(long _x0, int _x1, int _x2, int _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateArenaCfg.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateArenaCfg.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateArenaCfg\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateArenaCfg$layout() {\n+        return CreateArenaCfg$LAYOUT;\n+    }\n+\n+    private static final long CreateArenaCfg$OFFSET = 1248;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static final long CreateArenaCfg$offset() {\n+        return CreateArenaCfg$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateArenaCfg(MemorySegment struct) {\n+        return struct.get(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static void CreateArenaCfg(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static class ReleaseArenaCfg {\n+\n+        ReleaseArenaCfg() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseArenaCfg.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseArenaCfg.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseArenaCfg\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseArenaCfg$layout() {\n+        return ReleaseArenaCfg$LAYOUT;\n+    }\n+\n+    private static final long ReleaseArenaCfg$OFFSET = 1256;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static final long ReleaseArenaCfg$offset() {\n+        return ReleaseArenaCfg$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseArenaCfg(MemorySegment struct) {\n+        return struct.get(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * }\n+     *\/\n+    public static void ReleaseArenaCfg(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class ModelMetadataGetGraphDescription {\n+\n+        ModelMetadataGetGraphDescription() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ModelMetadataGetGraphDescription.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelMetadataGetGraphDescription.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelMetadataGetGraphDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetGraphDescription\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelMetadataGetGraphDescription$layout() {\n+        return ModelMetadataGetGraphDescription$LAYOUT;\n+    }\n+\n+    private static final long ModelMetadataGetGraphDescription$OFFSET = 1264;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long ModelMetadataGetGraphDescription$offset() {\n+        return ModelMetadataGetGraphDescription$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment ModelMetadataGetGraphDescription(MemorySegment struct) {\n+        return struct.get(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void ModelMetadataGetGraphDescription(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_TensorRT {\n+\n+        SessionOptionsAppendExecutionProvider_TensorRT() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_TensorRT.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_TensorRT.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$layout() {\n+        return SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_TensorRT$OFFSET = 1272;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_TensorRT$offset() {\n+        return SessionOptionsAppendExecutionProvider_TensorRT$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    public static class SetCurrentGpuDeviceId {\n+\n+        SetCurrentGpuDeviceId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetCurrentGpuDeviceId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetCurrentGpuDeviceId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetCurrentGpuDeviceId\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    public static final AddressLayout SetCurrentGpuDeviceId$layout() {\n+        return SetCurrentGpuDeviceId$LAYOUT;\n+    }\n+\n+    private static final long SetCurrentGpuDeviceId$OFFSET = 1280;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    public static final long SetCurrentGpuDeviceId$offset() {\n+        return SetCurrentGpuDeviceId$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    public static MemorySegment SetCurrentGpuDeviceId(MemorySegment struct) {\n+        return struct.get(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * }\n+     *\/\n+    public static void SetCurrentGpuDeviceId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    public static class GetCurrentGpuDeviceId {\n+\n+        GetCurrentGpuDeviceId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetCurrentGpuDeviceId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetCurrentGpuDeviceId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCurrentGpuDeviceId\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetCurrentGpuDeviceId$layout() {\n+        return GetCurrentGpuDeviceId$LAYOUT;\n+    }\n+\n+    private static final long GetCurrentGpuDeviceId$OFFSET = 1288;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    public static final long GetCurrentGpuDeviceId$offset() {\n+        return GetCurrentGpuDeviceId$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    public static MemorySegment GetCurrentGpuDeviceId(MemorySegment struct) {\n+        return struct.get(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * }\n+     *\/\n+    public static void GetCurrentGpuDeviceId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfoGetAttributeArray_float {\n+\n+        KernelInfoGetAttributeArray_float() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAttributeArray_float.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAttributeArray_float.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttributeArray_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttributeArray_float\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetAttributeArray_float$layout() {\n+        return KernelInfoGetAttributeArray_float$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetAttributeArray_float$OFFSET = 1296;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetAttributeArray_float$offset() {\n+        return KernelInfoGetAttributeArray_float$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttributeArray_float(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfoGetAttributeArray_float(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfoGetAttributeArray_int64 {\n+\n+        KernelInfoGetAttributeArray_int64() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAttributeArray_int64.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAttributeArray_int64.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttributeArray_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttributeArray_int64\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetAttributeArray_int64$layout() {\n+        return KernelInfoGetAttributeArray_int64$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetAttributeArray_int64$OFFSET = 1304;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetAttributeArray_int64$offset() {\n+        return KernelInfoGetAttributeArray_int64$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttributeArray_int64(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfoGetAttributeArray_int64(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static class CreateArenaCfgV2 {\n+\n+        CreateArenaCfgV2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateArenaCfgV2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateArenaCfgV2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateArenaCfgV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateArenaCfgV2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateArenaCfgV2$layout() {\n+        return CreateArenaCfgV2$LAYOUT;\n+    }\n+\n+    private static final long CreateArenaCfgV2$OFFSET = 1312;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static final long CreateArenaCfgV2$offset() {\n+        return CreateArenaCfgV2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateArenaCfgV2(MemorySegment struct) {\n+        return struct.get(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * }\n+     *\/\n+    public static void CreateArenaCfgV2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static class AddRunConfigEntry {\n+\n+        AddRunConfigEntry() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddRunConfigEntry.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddRunConfigEntry.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddRunConfigEntry\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout AddRunConfigEntry$layout() {\n+        return AddRunConfigEntry$LAYOUT;\n+    }\n+\n+    private static final long AddRunConfigEntry$OFFSET = 1320;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final long AddRunConfigEntry$offset() {\n+        return AddRunConfigEntry$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment AddRunConfigEntry(MemorySegment struct) {\n+        return struct.get(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static void AddRunConfigEntry(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    public static class CreatePrepackedWeightsContainer {\n+\n+        CreatePrepackedWeightsContainer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreatePrepackedWeightsContainer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreatePrepackedWeightsContainer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreatePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreatePrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreatePrepackedWeightsContainer$layout() {\n+        return CreatePrepackedWeightsContainer$LAYOUT;\n+    }\n+\n+    private static final long CreatePrepackedWeightsContainer$OFFSET = 1328;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    public static final long CreatePrepackedWeightsContainer$offset() {\n+        return CreatePrepackedWeightsContainer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    public static MemorySegment CreatePrepackedWeightsContainer(MemorySegment struct) {\n+        return struct.get(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * }\n+     *\/\n+    public static void CreatePrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static class ReleasePrepackedWeightsContainer {\n+\n+        ReleasePrepackedWeightsContainer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleasePrepackedWeightsContainer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleasePrepackedWeightsContainer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleasePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleasePrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleasePrepackedWeightsContainer$layout() {\n+        return ReleasePrepackedWeightsContainer$LAYOUT;\n+    }\n+\n+    private static final long ReleasePrepackedWeightsContainer$OFFSET = 1336;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static final long ReleasePrepackedWeightsContainer$offset() {\n+        return ReleasePrepackedWeightsContainer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleasePrepackedWeightsContainer(MemorySegment struct) {\n+        return struct.get(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static void ReleasePrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static class CreateSessionWithPrepackedWeightsContainer {\n+\n+        CreateSessionWithPrepackedWeightsContainer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSessionWithPrepackedWeightsContainer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSessionWithPrepackedWeightsContainer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionWithPrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSessionWithPrepackedWeightsContainer$layout() {\n+        return CreateSessionWithPrepackedWeightsContainer$LAYOUT;\n+    }\n+\n+    private static final long CreateSessionWithPrepackedWeightsContainer$OFFSET = 1344;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static final long CreateSessionWithPrepackedWeightsContainer$offset() {\n+        return CreateSessionWithPrepackedWeightsContainer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionWithPrepackedWeightsContainer(MemorySegment struct) {\n+        return struct.get(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static void CreateSessionWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static class CreateSessionFromArrayWithPrepackedWeightsContainer {\n+\n+        CreateSessionFromArrayWithPrepackedWeightsContainer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSessionFromArrayWithPrepackedWeightsContainer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSessionFromArrayWithPrepackedWeightsContainer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$layout() {\n+        return CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT;\n+    }\n+\n+    private static final long CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET = 1352;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static final long CreateSessionFromArrayWithPrepackedWeightsContainer$offset() {\n+        return CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct) {\n+        return struct.get(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * }\n+     *\/\n+    public static void CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_TensorRT_V2 {\n+\n+        SessionOptionsAppendExecutionProvider_TensorRT_V2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_TensorRT_V2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_TensorRT_V2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$layout() {\n+        return SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET = 1360;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$offset() {\n+        return SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static class CreateTensorRTProviderOptions {\n+\n+        CreateTensorRTProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateTensorRTProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateTensorRTProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorRTProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateTensorRTProviderOptions$layout() {\n+        return CreateTensorRTProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateTensorRTProviderOptions$OFFSET = 1368;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static final long CreateTensorRTProviderOptions$offset() {\n+        return CreateTensorRTProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorRTProviderOptions(MemorySegment struct) {\n+        return struct.get(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static void CreateTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class UpdateTensorRTProviderOptions {\n+\n+        UpdateTensorRTProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateTensorRTProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateTensorRTProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateTensorRTProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateTensorRTProviderOptions$layout() {\n+        return UpdateTensorRTProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long UpdateTensorRTProviderOptions$OFFSET = 1376;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long UpdateTensorRTProviderOptions$offset() {\n+        return UpdateTensorRTProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateTensorRTProviderOptions(MemorySegment struct) {\n+        return struct.get(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void UpdateTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class GetTensorRTProviderOptionsAsString {\n+\n+        GetTensorRTProviderOptionsAsString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorRTProviderOptionsAsString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorRTProviderOptionsAsString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorRTProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorRTProviderOptionsAsString\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorRTProviderOptionsAsString$layout() {\n+        return GetTensorRTProviderOptionsAsString$LAYOUT;\n+    }\n+\n+    private static final long GetTensorRTProviderOptionsAsString$OFFSET = 1384;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long GetTensorRTProviderOptionsAsString$offset() {\n+        return GetTensorRTProviderOptionsAsString$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorRTProviderOptionsAsString(MemorySegment struct) {\n+        return struct.get(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void GetTensorRTProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static class ReleaseTensorRTProviderOptions {\n+\n+        ReleaseTensorRTProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseTensorRTProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseTensorRTProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTensorRTProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseTensorRTProviderOptions$layout() {\n+        return ReleaseTensorRTProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseTensorRTProviderOptions$OFFSET = 1392;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final long ReleaseTensorRTProviderOptions$offset() {\n+        return ReleaseTensorRTProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseTensorRTProviderOptions(MemorySegment struct) {\n+        return struct.get(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static void ReleaseTensorRTProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static class EnableOrtCustomOps {\n+\n+        EnableOrtCustomOps() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EnableOrtCustomOps.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EnableOrtCustomOps.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout EnableOrtCustomOps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableOrtCustomOps\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout EnableOrtCustomOps$layout() {\n+        return EnableOrtCustomOps$LAYOUT;\n+    }\n+\n+    private static final long EnableOrtCustomOps$OFFSET = 1400;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static final long EnableOrtCustomOps$offset() {\n+        return EnableOrtCustomOps$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment EnableOrtCustomOps(MemorySegment struct) {\n+        return struct.get(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * }\n+     *\/\n+    public static void EnableOrtCustomOps(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    public static class RegisterAllocator {\n+\n+        RegisterAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RegisterAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RegisterAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterAllocator\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    public static final AddressLayout RegisterAllocator$layout() {\n+        return RegisterAllocator$LAYOUT;\n+    }\n+\n+    private static final long RegisterAllocator$OFFSET = 1408;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    public static final long RegisterAllocator$offset() {\n+        return RegisterAllocator$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterAllocator(MemorySegment struct) {\n+        return struct.get(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * }\n+     *\/\n+    public static void RegisterAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static class UnregisterAllocator {\n+\n+        UnregisterAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UnregisterAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UnregisterAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UnregisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UnregisterAllocator\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout UnregisterAllocator$layout() {\n+        return UnregisterAllocator$LAYOUT;\n+    }\n+\n+    private static final long UnregisterAllocator$OFFSET = 1416;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static final long UnregisterAllocator$offset() {\n+        return UnregisterAllocator$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment UnregisterAllocator(MemorySegment struct) {\n+        return struct.get(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static void UnregisterAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static class IsSparseTensor {\n+\n+        IsSparseTensor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(IsSparseTensor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(IsSparseTensor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout IsSparseTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"IsSparseTensor\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout IsSparseTensor$layout() {\n+        return IsSparseTensor$LAYOUT;\n+    }\n+\n+    private static final long IsSparseTensor$OFFSET = 1424;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static final long IsSparseTensor$offset() {\n+        return IsSparseTensor$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment IsSparseTensor(MemorySegment struct) {\n+        return struct.get(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static void IsSparseTensor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static class CreateSparseTensorAsOrtValue {\n+\n+        CreateSparseTensorAsOrtValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSparseTensorAsOrtValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSparseTensorAsOrtValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSparseTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorAsOrtValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSparseTensorAsOrtValue$layout() {\n+        return CreateSparseTensorAsOrtValue$LAYOUT;\n+    }\n+\n+    private static final long CreateSparseTensorAsOrtValue$OFFSET = 1432;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateSparseTensorAsOrtValue$offset() {\n+        return CreateSparseTensorAsOrtValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSparseTensorAsOrtValue(MemorySegment struct) {\n+        return struct.get(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static void CreateSparseTensorAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static class FillSparseTensorCoo {\n+\n+        FillSparseTensorCoo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(FillSparseTensorCoo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(FillSparseTensorCoo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillSparseTensorCoo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorCoo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout FillSparseTensorCoo$layout() {\n+        return FillSparseTensorCoo$LAYOUT;\n+    }\n+\n+    private static final long FillSparseTensorCoo$OFFSET = 1440;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final long FillSparseTensorCoo$offset() {\n+        return FillSparseTensorCoo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillSparseTensorCoo(MemorySegment struct) {\n+        return struct.get(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static void FillSparseTensorCoo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static class FillSparseTensorCsr {\n+\n+        FillSparseTensorCsr() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(FillSparseTensorCsr.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(FillSparseTensorCsr.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillSparseTensorCsr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorCsr\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout FillSparseTensorCsr$layout() {\n+        return FillSparseTensorCsr$LAYOUT;\n+    }\n+\n+    private static final long FillSparseTensorCsr$OFFSET = 1448;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final long FillSparseTensorCsr$offset() {\n+        return FillSparseTensorCsr$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment FillSparseTensorCsr(MemorySegment struct) {\n+        return struct.get(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * }\n+     *\/\n+    public static void FillSparseTensorCsr(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    public static class FillSparseTensorBlockSparse {\n+\n+        FillSparseTensorBlockSparse() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(FillSparseTensorBlockSparse.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(FillSparseTensorBlockSparse.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FillSparseTensorBlockSparse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorBlockSparse\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout FillSparseTensorBlockSparse$layout() {\n+        return FillSparseTensorBlockSparse$LAYOUT;\n+    }\n+\n+    private static final long FillSparseTensorBlockSparse$OFFSET = 1456;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    public static final long FillSparseTensorBlockSparse$offset() {\n+        return FillSparseTensorBlockSparse$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    public static MemorySegment FillSparseTensorBlockSparse(MemorySegment struct) {\n+        return struct.get(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * }\n+     *\/\n+    public static void FillSparseTensorBlockSparse(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static class CreateSparseTensorWithValuesAsOrtValue {\n+\n+        CreateSparseTensorWithValuesAsOrtValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSparseTensorWithValuesAsOrtValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSparseTensorWithValuesAsOrtValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorWithValuesAsOrtValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$layout() {\n+        return CreateSparseTensorWithValuesAsOrtValue$LAYOUT;\n+    }\n+\n+    private static final long CreateSparseTensorWithValuesAsOrtValue$OFFSET = 1464;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateSparseTensorWithValuesAsOrtValue$offset() {\n+        return CreateSparseTensorWithValuesAsOrtValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct) {\n+        return struct.get(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static void CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static class UseCooIndices {\n+\n+        UseCooIndices() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UseCooIndices.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UseCooIndices.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UseCooIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseCooIndices\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UseCooIndices$layout() {\n+        return UseCooIndices$LAYOUT;\n+    }\n+\n+    private static final long UseCooIndices$OFFSET = 1472;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final long UseCooIndices$offset() {\n+        return UseCooIndices$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UseCooIndices(MemorySegment struct) {\n+        return struct.get(UseCooIndices$LAYOUT, UseCooIndices$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static void UseCooIndices(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UseCooIndices$LAYOUT, UseCooIndices$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static class UseCsrIndices {\n+\n+        UseCsrIndices() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UseCsrIndices.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UseCsrIndices.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UseCsrIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseCsrIndices\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UseCsrIndices$layout() {\n+        return UseCsrIndices$LAYOUT;\n+    }\n+\n+    private static final long UseCsrIndices$OFFSET = 1480;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static final long UseCsrIndices$offset() {\n+        return UseCsrIndices$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UseCsrIndices(MemorySegment struct) {\n+        return struct.get(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static void UseCsrIndices(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    public static class UseBlockSparseIndices {\n+\n+        UseBlockSparseIndices() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UseBlockSparseIndices.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UseBlockSparseIndices.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UseBlockSparseIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseBlockSparseIndices\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout UseBlockSparseIndices$layout() {\n+        return UseBlockSparseIndices$LAYOUT;\n+    }\n+\n+    private static final long UseBlockSparseIndices$OFFSET = 1488;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    public static final long UseBlockSparseIndices$offset() {\n+        return UseBlockSparseIndices$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    public static MemorySegment UseBlockSparseIndices(MemorySegment struct) {\n+        return struct.get(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * }\n+     *\/\n+    public static void UseBlockSparseIndices(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    public static class GetSparseTensorFormat {\n+\n+        GetSparseTensorFormat() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSparseTensorFormat.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSparseTensorFormat.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorFormat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorFormat\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSparseTensorFormat$layout() {\n+        return GetSparseTensorFormat$LAYOUT;\n+    }\n+\n+    private static final long GetSparseTensorFormat$OFFSET = 1496;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    public static final long GetSparseTensorFormat$offset() {\n+        return GetSparseTensorFormat$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorFormat(MemorySegment struct) {\n+        return struct.get(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * }\n+     *\/\n+    public static void GetSparseTensorFormat(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static class GetSparseTensorValuesTypeAndShape {\n+\n+        GetSparseTensorValuesTypeAndShape() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSparseTensorValuesTypeAndShape.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSparseTensorValuesTypeAndShape.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorValuesTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorValuesTypeAndShape\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSparseTensorValuesTypeAndShape$layout() {\n+        return GetSparseTensorValuesTypeAndShape$LAYOUT;\n+    }\n+\n+    private static final long GetSparseTensorValuesTypeAndShape$OFFSET = 1504;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final long GetSparseTensorValuesTypeAndShape$offset() {\n+        return GetSparseTensorValuesTypeAndShape$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorValuesTypeAndShape(MemorySegment struct) {\n+        return struct.get(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static void GetSparseTensorValuesTypeAndShape(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static class GetSparseTensorValues {\n+\n+        GetSparseTensorValues() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSparseTensorValues.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSparseTensorValues.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorValues\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSparseTensorValues$layout() {\n+        return GetSparseTensorValues$LAYOUT;\n+    }\n+\n+    private static final long GetSparseTensorValues$OFFSET = 1512;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static final long GetSparseTensorValues$offset() {\n+        return GetSparseTensorValues$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorValues(MemorySegment struct) {\n+        return struct.get(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static void GetSparseTensorValues(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static class GetSparseTensorIndicesTypeShape {\n+\n+        GetSparseTensorIndicesTypeShape() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSparseTensorIndicesTypeShape.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSparseTensorIndicesTypeShape.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorIndicesTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorIndicesTypeShape\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSparseTensorIndicesTypeShape$layout() {\n+        return GetSparseTensorIndicesTypeShape$LAYOUT;\n+    }\n+\n+    private static final long GetSparseTensorIndicesTypeShape$OFFSET = 1520;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static final long GetSparseTensorIndicesTypeShape$offset() {\n+        return GetSparseTensorIndicesTypeShape$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorIndicesTypeShape(MemorySegment struct) {\n+        return struct.get(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static void GetSparseTensorIndicesTypeShape(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    public static class GetSparseTensorIndices {\n+\n+        GetSparseTensorIndices() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSparseTensorIndices.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSparseTensorIndices.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSparseTensorIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorIndices\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSparseTensorIndices$layout() {\n+        return GetSparseTensorIndices$LAYOUT;\n+    }\n+\n+    private static final long GetSparseTensorIndices$OFFSET = 1528;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    public static final long GetSparseTensorIndices$offset() {\n+        return GetSparseTensorIndices$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSparseTensorIndices(MemorySegment struct) {\n+        return struct.get(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * }\n+     *\/\n+    public static void GetSparseTensorIndices(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static class HasValue {\n+\n+        HasValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HasValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HasValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout HasValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HasValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout HasValue$layout() {\n+        return HasValue$LAYOUT;\n+    }\n+\n+    private static final long HasValue$OFFSET = 1536;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static final long HasValue$offset() {\n+        return HasValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment HasValue(MemorySegment struct) {\n+        return struct.get(HasValue$LAYOUT, HasValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * }\n+     *\/\n+    public static void HasValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HasValue$LAYOUT, HasValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    public static class KernelContext_GetGPUComputeStream {\n+\n+        KernelContext_GetGPUComputeStream() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetGPUComputeStream.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetGPUComputeStream.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetGPUComputeStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetGPUComputeStream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetGPUComputeStream$layout() {\n+        return KernelContext_GetGPUComputeStream$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetGPUComputeStream$OFFSET = 1544;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetGPUComputeStream$offset() {\n+        return KernelContext_GetGPUComputeStream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetGPUComputeStream(MemorySegment struct) {\n+        return struct.get(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * }\n+     *\/\n+    public static void KernelContext_GetGPUComputeStream(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static class GetTensorMemoryInfo {\n+\n+        GetTensorMemoryInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorMemoryInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorMemoryInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorMemoryInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorMemoryInfo$layout() {\n+        return GetTensorMemoryInfo$LAYOUT;\n+    }\n+\n+    private static final long GetTensorMemoryInfo$OFFSET = 1552;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final long GetTensorMemoryInfo$offset() {\n+        return GetTensorMemoryInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorMemoryInfo(MemorySegment struct) {\n+        return struct.get(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static void GetTensorMemoryInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    public static class GetExecutionProviderApi {\n+\n+        GetExecutionProviderApi() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetExecutionProviderApi.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetExecutionProviderApi.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetExecutionProviderApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetExecutionProviderApi\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetExecutionProviderApi$layout() {\n+        return GetExecutionProviderApi$LAYOUT;\n+    }\n+\n+    private static final long GetExecutionProviderApi$OFFSET = 1560;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    public static final long GetExecutionProviderApi$offset() {\n+        return GetExecutionProviderApi$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetExecutionProviderApi(MemorySegment struct) {\n+        return struct.get(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * }\n+     *\/\n+    public static void GetExecutionProviderApi(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static class SessionOptionsSetCustomCreateThreadFn {\n+\n+        SessionOptionsSetCustomCreateThreadFn() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsSetCustomCreateThreadFn.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsSetCustomCreateThreadFn.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsSetCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomCreateThreadFn\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsSetCustomCreateThreadFn$layout() {\n+        return SessionOptionsSetCustomCreateThreadFn$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsSetCustomCreateThreadFn$OFFSET = 1568;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static final long SessionOptionsSetCustomCreateThreadFn$offset() {\n+        return SessionOptionsSetCustomCreateThreadFn$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetCustomCreateThreadFn(MemorySegment struct) {\n+        return struct.get(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static void SessionOptionsSetCustomCreateThreadFn(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    public static class SessionOptionsSetCustomThreadCreationOptions {\n+\n+        SessionOptionsSetCustomThreadCreationOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsSetCustomThreadCreationOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsSetCustomThreadCreationOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomThreadCreationOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$layout() {\n+        return SessionOptionsSetCustomThreadCreationOptions$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsSetCustomThreadCreationOptions$OFFSET = 1576;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsSetCustomThreadCreationOptions$offset() {\n+        return SessionOptionsSetCustomThreadCreationOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct) {\n+        return struct.get(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * }\n+     *\/\n+    public static void SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static class SessionOptionsSetCustomJoinThreadFn {\n+\n+        SessionOptionsSetCustomJoinThreadFn() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsSetCustomJoinThreadFn.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsSetCustomJoinThreadFn.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsSetCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomJoinThreadFn\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsSetCustomJoinThreadFn$layout() {\n+        return SessionOptionsSetCustomJoinThreadFn$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsSetCustomJoinThreadFn$OFFSET = 1584;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static final long SessionOptionsSetCustomJoinThreadFn$offset() {\n+        return SessionOptionsSetCustomJoinThreadFn$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetCustomJoinThreadFn(MemorySegment struct) {\n+        return struct.get(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static void SessionOptionsSetCustomJoinThreadFn(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static class SetGlobalCustomCreateThreadFn {\n+\n+        SetGlobalCustomCreateThreadFn() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalCustomCreateThreadFn.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalCustomCreateThreadFn.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomCreateThreadFn\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalCustomCreateThreadFn$layout() {\n+        return SetGlobalCustomCreateThreadFn$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalCustomCreateThreadFn$OFFSET = 1592;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static final long SetGlobalCustomCreateThreadFn$offset() {\n+        return SetGlobalCustomCreateThreadFn$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalCustomCreateThreadFn(MemorySegment struct) {\n+        return struct.get(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * }\n+     *\/\n+    public static void SetGlobalCustomCreateThreadFn(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    public static class SetGlobalCustomThreadCreationOptions {\n+\n+        SetGlobalCustomThreadCreationOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalCustomThreadCreationOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalCustomThreadCreationOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomThreadCreationOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalCustomThreadCreationOptions$layout() {\n+        return SetGlobalCustomThreadCreationOptions$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalCustomThreadCreationOptions$OFFSET = 1600;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    public static final long SetGlobalCustomThreadCreationOptions$offset() {\n+        return SetGlobalCustomThreadCreationOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalCustomThreadCreationOptions(MemorySegment struct) {\n+        return struct.get(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * }\n+     *\/\n+    public static void SetGlobalCustomThreadCreationOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static class SetGlobalCustomJoinThreadFn {\n+\n+        SetGlobalCustomJoinThreadFn() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalCustomJoinThreadFn.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalCustomJoinThreadFn.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomJoinThreadFn\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalCustomJoinThreadFn$layout() {\n+        return SetGlobalCustomJoinThreadFn$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalCustomJoinThreadFn$OFFSET = 1608;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static final long SetGlobalCustomJoinThreadFn$offset() {\n+        return SetGlobalCustomJoinThreadFn$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalCustomJoinThreadFn(MemorySegment struct) {\n+        return struct.get(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * }\n+     *\/\n+    public static void SetGlobalCustomJoinThreadFn(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static class SynchronizeBoundInputs {\n+\n+        SynchronizeBoundInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SynchronizeBoundInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SynchronizeBoundInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SynchronizeBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SynchronizeBoundInputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final AddressLayout SynchronizeBoundInputs$layout() {\n+        return SynchronizeBoundInputs$LAYOUT;\n+    }\n+\n+    private static final long SynchronizeBoundInputs$OFFSET = 1616;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final long SynchronizeBoundInputs$offset() {\n+        return SynchronizeBoundInputs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment SynchronizeBoundInputs(MemorySegment struct) {\n+        return struct.get(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void SynchronizeBoundInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static class SynchronizeBoundOutputs {\n+\n+        SynchronizeBoundOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SynchronizeBoundOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SynchronizeBoundOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SynchronizeBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SynchronizeBoundOutputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final AddressLayout SynchronizeBoundOutputs$layout() {\n+        return SynchronizeBoundOutputs$LAYOUT;\n+    }\n+\n+    private static final long SynchronizeBoundOutputs$OFFSET = 1624;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static final long SynchronizeBoundOutputs$offset() {\n+        return SynchronizeBoundOutputs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static MemorySegment SynchronizeBoundOutputs(MemorySegment struct) {\n+        return struct.get(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * }\n+     *\/\n+    public static void SynchronizeBoundOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_CUDA_V2 {\n+\n+        SessionOptionsAppendExecutionProvider_CUDA_V2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_CUDA_V2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CUDA_V2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$layout() {\n+        return SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET = 1632;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_CUDA_V2$offset() {\n+        return SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static class CreateCUDAProviderOptions {\n+\n+        CreateCUDAProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateCUDAProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateCUDAProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCUDAProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateCUDAProviderOptions$layout() {\n+        return CreateCUDAProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateCUDAProviderOptions$OFFSET = 1640;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static final long CreateCUDAProviderOptions$offset() {\n+        return CreateCUDAProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCUDAProviderOptions(MemorySegment struct) {\n+        return struct.get(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * }\n+     *\/\n+    public static void CreateCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class UpdateCUDAProviderOptions {\n+\n+        UpdateCUDAProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateCUDAProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateCUDAProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCUDAProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateCUDAProviderOptions$layout() {\n+        return UpdateCUDAProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long UpdateCUDAProviderOptions$OFFSET = 1648;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long UpdateCUDAProviderOptions$offset() {\n+        return UpdateCUDAProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateCUDAProviderOptions(MemorySegment struct) {\n+        return struct.get(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void UpdateCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class GetCUDAProviderOptionsAsString {\n+\n+        GetCUDAProviderOptionsAsString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetCUDAProviderOptionsAsString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetCUDAProviderOptionsAsString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCUDAProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCUDAProviderOptionsAsString\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetCUDAProviderOptionsAsString$layout() {\n+        return GetCUDAProviderOptionsAsString$LAYOUT;\n+    }\n+\n+    private static final long GetCUDAProviderOptionsAsString$OFFSET = 1656;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long GetCUDAProviderOptionsAsString$offset() {\n+        return GetCUDAProviderOptionsAsString$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetCUDAProviderOptionsAsString(MemorySegment struct) {\n+        return struct.get(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void GetCUDAProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static class ReleaseCUDAProviderOptions {\n+\n+        ReleaseCUDAProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseCUDAProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseCUDAProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCUDAProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseCUDAProviderOptions$layout() {\n+        return ReleaseCUDAProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseCUDAProviderOptions$OFFSET = 1664;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static final long ReleaseCUDAProviderOptions$offset() {\n+        return ReleaseCUDAProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseCUDAProviderOptions(MemorySegment struct) {\n+        return struct.get(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * }\n+     *\/\n+    public static void ReleaseCUDAProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_MIGraphX {\n+\n+        SessionOptionsAppendExecutionProvider_MIGraphX() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_MIGraphX.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_MIGraphX.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_MIGraphX\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$layout() {\n+        return SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET = 1672;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_MIGraphX$offset() {\n+        return SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    public static class AddExternalInitializers {\n+\n+        AddExternalInitializers() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddExternalInitializers.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddExternalInitializers.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddExternalInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddExternalInitializers\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout AddExternalInitializers$layout() {\n+        return AddExternalInitializers$LAYOUT;\n+    }\n+\n+    private static final long AddExternalInitializers$OFFSET = 1680;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    public static final long AddExternalInitializers$offset() {\n+        return AddExternalInitializers$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddExternalInitializers(MemorySegment struct) {\n+        return struct.get(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * }\n+     *\/\n+    public static void AddExternalInitializers(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    public static class CreateOpAttr {\n+\n+        CreateOpAttr() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateOpAttr.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateOpAttr.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOpAttr\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateOpAttr$layout() {\n+        return CreateOpAttr$LAYOUT;\n+    }\n+\n+    private static final long CreateOpAttr$OFFSET = 1688;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    public static final long CreateOpAttr$offset() {\n+        return CreateOpAttr$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOpAttr(MemorySegment struct) {\n+        return struct.get(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * }\n+     *\/\n+    public static void CreateOpAttr(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    public static class ReleaseOpAttr {\n+\n+        ReleaseOpAttr() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseOpAttr.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseOpAttr.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseOpAttr\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseOpAttr$layout() {\n+        return ReleaseOpAttr$LAYOUT;\n+    }\n+\n+    private static final long ReleaseOpAttr$OFFSET = 1696;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    public static final long ReleaseOpAttr$offset() {\n+        return ReleaseOpAttr$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseOpAttr(MemorySegment struct) {\n+        return struct.get(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * }\n+     *\/\n+    public static void ReleaseOpAttr(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    public static class CreateOp {\n+\n+        CreateOp() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateOp.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateOp.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOp\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateOp$layout() {\n+        return CreateOp$LAYOUT;\n+    }\n+\n+    private static final long CreateOp$OFFSET = 1704;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    public static final long CreateOp$offset() {\n+        return CreateOp$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOp(MemorySegment struct) {\n+        return struct.get(CreateOp$LAYOUT, CreateOp$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * }\n+     *\/\n+    public static void CreateOp(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateOp$LAYOUT, CreateOp$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    public static class InvokeOp {\n+\n+        InvokeOp() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(InvokeOp.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(InvokeOp.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout InvokeOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"InvokeOp\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    public static final AddressLayout InvokeOp$layout() {\n+        return InvokeOp$LAYOUT;\n+    }\n+\n+    private static final long InvokeOp$OFFSET = 1712;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    public static final long InvokeOp$offset() {\n+        return InvokeOp$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    public static MemorySegment InvokeOp(MemorySegment struct) {\n+        return struct.get(InvokeOp$LAYOUT, InvokeOp$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * }\n+     *\/\n+    public static void InvokeOp(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(InvokeOp$LAYOUT, InvokeOp$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    public static class ReleaseOp {\n+\n+        ReleaseOp() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseOp.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseOp.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseOp\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseOp$layout() {\n+        return ReleaseOp$LAYOUT;\n+    }\n+\n+    private static final long ReleaseOp$OFFSET = 1720;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    public static final long ReleaseOp$offset() {\n+        return ReleaseOp$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseOp(MemorySegment struct) {\n+        return struct.get(ReleaseOp$LAYOUT, ReleaseOp$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseOp)(OrtOp *)\n+     * }\n+     *\/\n+    public static void ReleaseOp(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseOp$LAYOUT, ReleaseOp$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider {\n+\n+        SessionOptionsAppendExecutionProvider() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider$layout() {\n+        return SessionOptionsAppendExecutionProvider$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider$OFFSET = 1728;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider$offset() {\n+        return SessionOptionsAppendExecutionProvider$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    public static class CopyKernelInfo {\n+\n+        CopyKernelInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CopyKernelInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CopyKernelInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CopyKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CopyKernelInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CopyKernelInfo$layout() {\n+        return CopyKernelInfo$LAYOUT;\n+    }\n+\n+    private static final long CopyKernelInfo$OFFSET = 1736;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    public static final long CopyKernelInfo$offset() {\n+        return CopyKernelInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CopyKernelInfo(MemorySegment struct) {\n+        return struct.get(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * }\n+     *\/\n+    public static void CopyKernelInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static class ReleaseKernelInfo {\n+\n+        ReleaseKernelInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseKernelInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseKernelInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseKernelInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseKernelInfo$layout() {\n+        return ReleaseKernelInfo$LAYOUT;\n+    }\n+\n+    private static final long ReleaseKernelInfo$OFFSET = 1744;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static final long ReleaseKernelInfo$offset() {\n+        return ReleaseKernelInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseKernelInfo(MemorySegment struct) {\n+        return struct.get(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static void ReleaseKernelInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    public static class GetTrainingApi {\n+\n+        GetTrainingApi() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTrainingApi.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTrainingApi.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTrainingApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTrainingApi\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTrainingApi$layout() {\n+        return GetTrainingApi$LAYOUT;\n+    }\n+\n+    private static final long GetTrainingApi$OFFSET = 1752;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    public static final long GetTrainingApi$offset() {\n+        return GetTrainingApi$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetTrainingApi(MemorySegment struct) {\n+        return struct.get(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * }\n+     *\/\n+    public static void GetTrainingApi(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_CANN {\n+\n+        SessionOptionsAppendExecutionProvider_CANN() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_CANN.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_CANN.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CANN\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$layout() {\n+        return SessionOptionsAppendExecutionProvider_CANN$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_CANN$OFFSET = 1760;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_CANN$offset() {\n+        return SessionOptionsAppendExecutionProvider_CANN$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    public static class CreateCANNProviderOptions {\n+\n+        CreateCANNProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateCANNProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateCANNProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCANNProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateCANNProviderOptions$layout() {\n+        return CreateCANNProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateCANNProviderOptions$OFFSET = 1768;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    public static final long CreateCANNProviderOptions$offset() {\n+        return CreateCANNProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateCANNProviderOptions(MemorySegment struct) {\n+        return struct.get(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * }\n+     *\/\n+    public static void CreateCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class UpdateCANNProviderOptions {\n+\n+        UpdateCANNProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateCANNProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateCANNProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCANNProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateCANNProviderOptions$layout() {\n+        return UpdateCANNProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long UpdateCANNProviderOptions$OFFSET = 1776;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long UpdateCANNProviderOptions$offset() {\n+        return UpdateCANNProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateCANNProviderOptions(MemorySegment struct) {\n+        return struct.get(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void UpdateCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class GetCANNProviderOptionsAsString {\n+\n+        GetCANNProviderOptionsAsString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetCANNProviderOptionsAsString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetCANNProviderOptionsAsString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetCANNProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCANNProviderOptionsAsString\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetCANNProviderOptionsAsString$layout() {\n+        return GetCANNProviderOptionsAsString$LAYOUT;\n+    }\n+\n+    private static final long GetCANNProviderOptionsAsString$OFFSET = 1784;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long GetCANNProviderOptionsAsString$offset() {\n+        return GetCANNProviderOptionsAsString$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetCANNProviderOptionsAsString(MemorySegment struct) {\n+        return struct.get(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void GetCANNProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseCANNProviderOptions {\n+\n+        ReleaseCANNProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseCANNProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseCANNProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCANNProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseCANNProviderOptions$layout() {\n+        return ReleaseCANNProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseCANNProviderOptions$OFFSET = 1792;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseCANNProviderOptions$offset() {\n+        return ReleaseCANNProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseCANNProviderOptions(MemorySegment struct) {\n+        return struct.get(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseCANNProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    public static class MemoryInfoGetDeviceType {\n+\n+        MemoryInfoGetDeviceType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetDeviceType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetDeviceType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout MemoryInfoGetDeviceType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetDeviceType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    public static final AddressLayout MemoryInfoGetDeviceType$layout() {\n+        return MemoryInfoGetDeviceType$LAYOUT;\n+    }\n+\n+    private static final long MemoryInfoGetDeviceType$OFFSET = 1800;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    public static final long MemoryInfoGetDeviceType$offset() {\n+        return MemoryInfoGetDeviceType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetDeviceType(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * }\n+     *\/\n+    public static void MemoryInfoGetDeviceType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    public static class UpdateEnvWithCustomLogLevel {\n+\n+        UpdateEnvWithCustomLogLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateEnvWithCustomLogLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateEnvWithCustomLogLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateEnvWithCustomLogLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateEnvWithCustomLogLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateEnvWithCustomLogLevel$layout() {\n+        return UpdateEnvWithCustomLogLevel$LAYOUT;\n+    }\n+\n+    private static final long UpdateEnvWithCustomLogLevel$OFFSET = 1808;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    public static final long UpdateEnvWithCustomLogLevel$offset() {\n+        return UpdateEnvWithCustomLogLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateEnvWithCustomLogLevel(MemorySegment struct) {\n+        return struct.get(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * }\n+     *\/\n+    public static void UpdateEnvWithCustomLogLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    public static class SetGlobalIntraOpThreadAffinity {\n+\n+        SetGlobalIntraOpThreadAffinity() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetGlobalIntraOpThreadAffinity.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGlobalIntraOpThreadAffinity.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGlobalIntraOpThreadAffinity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalIntraOpThreadAffinity\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGlobalIntraOpThreadAffinity$layout() {\n+        return SetGlobalIntraOpThreadAffinity$LAYOUT;\n+    }\n+\n+    private static final long SetGlobalIntraOpThreadAffinity$OFFSET = 1816;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    public static final long SetGlobalIntraOpThreadAffinity$offset() {\n+        return SetGlobalIntraOpThreadAffinity$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment SetGlobalIntraOpThreadAffinity(MemorySegment struct) {\n+        return struct.get(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * }\n+     *\/\n+    public static void SetGlobalIntraOpThreadAffinity(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static class RegisterCustomOpsLibrary_V2 {\n+\n+        RegisterCustomOpsLibrary_V2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RegisterCustomOpsLibrary_V2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RegisterCustomOpsLibrary_V2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterCustomOpsLibrary_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsLibrary_V2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout RegisterCustomOpsLibrary_V2$layout() {\n+        return RegisterCustomOpsLibrary_V2$LAYOUT;\n+    }\n+\n+    private static final long RegisterCustomOpsLibrary_V2$OFFSET = 1824;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static final long RegisterCustomOpsLibrary_V2$offset() {\n+        return RegisterCustomOpsLibrary_V2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterCustomOpsLibrary_V2(MemorySegment struct) {\n+        return struct.get(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static void RegisterCustomOpsLibrary_V2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static class RegisterCustomOpsUsingFunction {\n+\n+        RegisterCustomOpsUsingFunction() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RegisterCustomOpsUsingFunction.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RegisterCustomOpsUsingFunction.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RegisterCustomOpsUsingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsUsingFunction\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout RegisterCustomOpsUsingFunction$layout() {\n+        return RegisterCustomOpsUsingFunction$LAYOUT;\n+    }\n+\n+    private static final long RegisterCustomOpsUsingFunction$OFFSET = 1832;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static final long RegisterCustomOpsUsingFunction$offset() {\n+        return RegisterCustomOpsUsingFunction$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterCustomOpsUsingFunction(MemorySegment struct) {\n+        return struct.get(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * }\n+     *\/\n+    public static void RegisterCustomOpsUsingFunction(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetInputCount {\n+\n+        KernelInfo_GetInputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetInputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetInputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetInputCount$layout() {\n+        return KernelInfo_GetInputCount$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetInputCount$OFFSET = 1840;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetInputCount$offset() {\n+        return KernelInfo_GetInputCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetInputCount(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetOutputCount {\n+\n+        KernelInfo_GetOutputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetOutputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetOutputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetOutputCount$layout() {\n+        return KernelInfo_GetOutputCount$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetOutputCount$OFFSET = 1848;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetOutputCount$offset() {\n+        return KernelInfo_GetOutputCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetOutputCount(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetOutputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetInputName {\n+\n+        KernelInfo_GetInputName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetInputName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetInputName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetInputName$layout() {\n+        return KernelInfo_GetInputName$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetInputName$OFFSET = 1856;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetInputName$offset() {\n+        return KernelInfo_GetInputName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetInputName(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetInputName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetOutputName {\n+\n+        KernelInfo_GetOutputName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetOutputName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetOutputName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetOutputName$layout() {\n+        return KernelInfo_GetOutputName$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetOutputName$OFFSET = 1864;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetOutputName$offset() {\n+        return KernelInfo_GetOutputName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetOutputName(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetOutputName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetInputTypeInfo {\n+\n+        KernelInfo_GetInputTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetInputTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetInputTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetInputTypeInfo$layout() {\n+        return KernelInfo_GetInputTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetInputTypeInfo$OFFSET = 1872;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetInputTypeInfo$offset() {\n+        return KernelInfo_GetInputTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetInputTypeInfo(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetInputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetOutputTypeInfo {\n+\n+        KernelInfo_GetOutputTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetOutputTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetOutputTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetOutputTypeInfo$layout() {\n+        return KernelInfo_GetOutputTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetOutputTypeInfo$OFFSET = 1880;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetOutputTypeInfo$offset() {\n+        return KernelInfo_GetOutputTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetOutputTypeInfo(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetOutputTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static class KernelInfoGetAttribute_tensor {\n+\n+        KernelInfoGetAttribute_tensor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAttribute_tensor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAttribute_tensor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetAttribute_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_tensor\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetAttribute_tensor$layout() {\n+        return KernelInfoGetAttribute_tensor$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetAttribute_tensor$OFFSET = 1888;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetAttribute_tensor$offset() {\n+        return KernelInfoGetAttribute_tensor$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAttribute_tensor(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * }\n+     *\/\n+    public static void KernelInfoGetAttribute_tensor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    public static class HasSessionConfigEntry {\n+\n+        HasSessionConfigEntry() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HasSessionConfigEntry.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HasSessionConfigEntry.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout HasSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HasSessionConfigEntry\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout HasSessionConfigEntry$layout() {\n+        return HasSessionConfigEntry$LAYOUT;\n+    }\n+\n+    private static final long HasSessionConfigEntry$OFFSET = 1896;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    public static final long HasSessionConfigEntry$offset() {\n+        return HasSessionConfigEntry$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment HasSessionConfigEntry(MemorySegment struct) {\n+        return struct.get(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * }\n+     *\/\n+    public static void HasSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static class GetSessionConfigEntry {\n+\n+        GetSessionConfigEntry() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSessionConfigEntry.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSessionConfigEntry.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSessionConfigEntry\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSessionConfigEntry$layout() {\n+        return GetSessionConfigEntry$LAYOUT;\n+    }\n+\n+    private static final long GetSessionConfigEntry$OFFSET = 1904;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static final long GetSessionConfigEntry$offset() {\n+        return GetSessionConfigEntry$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetSessionConfigEntry(MemorySegment struct) {\n+        return struct.get(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * }\n+     *\/\n+    public static void GetSessionConfigEntry(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static class SessionOptionsAppendExecutionProvider_Dnnl {\n+\n+        SessionOptionsAppendExecutionProvider_Dnnl() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_Dnnl.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_Dnnl.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_Dnnl\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$layout() {\n+        return SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT;\n+    }\n+\n+    private static final long SessionOptionsAppendExecutionProvider_Dnnl$OFFSET = 1912;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static final long SessionOptionsAppendExecutionProvider_Dnnl$offset() {\n+        return SessionOptionsAppendExecutionProvider_Dnnl$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static void SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    public static class CreateDnnlProviderOptions {\n+\n+        CreateDnnlProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateDnnlProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateDnnlProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateDnnlProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateDnnlProviderOptions$layout() {\n+        return CreateDnnlProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateDnnlProviderOptions$OFFSET = 1920;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    public static final long CreateDnnlProviderOptions$offset() {\n+        return CreateDnnlProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateDnnlProviderOptions(MemorySegment struct) {\n+        return struct.get(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * }\n+     *\/\n+    public static void CreateDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class UpdateDnnlProviderOptions {\n+\n+        UpdateDnnlProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateDnnlProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateDnnlProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateDnnlProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateDnnlProviderOptions$layout() {\n+        return UpdateDnnlProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long UpdateDnnlProviderOptions$OFFSET = 1928;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long UpdateDnnlProviderOptions$offset() {\n+        return UpdateDnnlProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateDnnlProviderOptions(MemorySegment struct) {\n+        return struct.get(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void UpdateDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class GetDnnlProviderOptionsAsString {\n+\n+        GetDnnlProviderOptionsAsString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetDnnlProviderOptionsAsString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetDnnlProviderOptionsAsString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetDnnlProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDnnlProviderOptionsAsString\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetDnnlProviderOptionsAsString$layout() {\n+        return GetDnnlProviderOptionsAsString$LAYOUT;\n+    }\n+\n+    private static final long GetDnnlProviderOptionsAsString$OFFSET = 1936;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long GetDnnlProviderOptionsAsString$offset() {\n+        return GetDnnlProviderOptionsAsString$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetDnnlProviderOptionsAsString(MemorySegment struct) {\n+        return struct.get(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void GetDnnlProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseDnnlProviderOptions {\n+\n+        ReleaseDnnlProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseDnnlProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseDnnlProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseDnnlProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseDnnlProviderOptions$layout() {\n+        return ReleaseDnnlProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseDnnlProviderOptions$OFFSET = 1944;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseDnnlProviderOptions$offset() {\n+        return ReleaseDnnlProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseDnnlProviderOptions(MemorySegment struct) {\n+        return struct.get(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseDnnlProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetNodeName {\n+\n+        KernelInfo_GetNodeName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetNodeName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetNodeName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetNodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetNodeName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetNodeName$layout() {\n+        return KernelInfo_GetNodeName$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetNodeName$OFFSET = 1952;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetNodeName$offset() {\n+        return KernelInfo_GetNodeName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetNodeName(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetNodeName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static class KernelInfo_GetLogger {\n+\n+        KernelInfo_GetLogger() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfo_GetLogger.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfo_GetLogger.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfo_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetLogger\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfo_GetLogger$layout() {\n+        return KernelInfo_GetLogger$LAYOUT;\n+    }\n+\n+    private static final long KernelInfo_GetLogger$OFFSET = 1960;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static final long KernelInfo_GetLogger$offset() {\n+        return KernelInfo_GetLogger$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfo_GetLogger(MemorySegment struct) {\n+        return struct.get(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static void KernelInfo_GetLogger(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static class KernelContext_GetLogger {\n+\n+        KernelContext_GetLogger() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetLogger.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetLogger.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetLogger\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetLogger$layout() {\n+        return KernelContext_GetLogger$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetLogger$OFFSET = 1968;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetLogger$offset() {\n+        return KernelContext_GetLogger$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetLogger(MemorySegment struct) {\n+        return struct.get(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * }\n+     *\/\n+    public static void KernelContext_GetLogger(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    public static class Logger_LogMessage {\n+\n+        Logger_LogMessage() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Logger_LogMessage.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Logger_LogMessage.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Logger_LogMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Logger_LogMessage\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout Logger_LogMessage$layout() {\n+        return Logger_LogMessage$LAYOUT;\n+    }\n+\n+    private static final long Logger_LogMessage$OFFSET = 1976;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    public static final long Logger_LogMessage$offset() {\n+        return Logger_LogMessage$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment Logger_LogMessage(MemorySegment struct) {\n+        return struct.get(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * }\n+     *\/\n+    public static void Logger_LogMessage(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    public static class Logger_GetLoggingSeverityLevel {\n+\n+        Logger_GetLoggingSeverityLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Logger_GetLoggingSeverityLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Logger_GetLoggingSeverityLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout Logger_GetLoggingSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Logger_GetLoggingSeverityLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    public static final AddressLayout Logger_GetLoggingSeverityLevel$layout() {\n+        return Logger_GetLoggingSeverityLevel$LAYOUT;\n+    }\n+\n+    private static final long Logger_GetLoggingSeverityLevel$OFFSET = 1984;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    public static final long Logger_GetLoggingSeverityLevel$offset() {\n+        return Logger_GetLoggingSeverityLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    public static MemorySegment Logger_GetLoggingSeverityLevel(MemorySegment struct) {\n+        return struct.get(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * }\n+     *\/\n+    public static void Logger_GetLoggingSeverityLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    public static class KernelInfoGetConstantInput_tensor {\n+\n+        KernelInfoGetConstantInput_tensor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetConstantInput_tensor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetConstantInput_tensor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelInfoGetConstantInput_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetConstantInput_tensor\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelInfoGetConstantInput_tensor$layout() {\n+        return KernelInfoGetConstantInput_tensor$LAYOUT;\n+    }\n+\n+    private static final long KernelInfoGetConstantInput_tensor$OFFSET = 1992;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    public static final long KernelInfoGetConstantInput_tensor$offset() {\n+        return KernelInfoGetConstantInput_tensor$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetConstantInput_tensor(MemorySegment struct) {\n+        return struct.get(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * }\n+     *\/\n+    public static void KernelInfoGetConstantInput_tensor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    public static class CastTypeInfoToOptionalTypeInfo {\n+\n+        CastTypeInfoToOptionalTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CastTypeInfoToOptionalTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CastTypeInfoToOptionalTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CastTypeInfoToOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToOptionalTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CastTypeInfoToOptionalTypeInfo$layout() {\n+        return CastTypeInfoToOptionalTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CastTypeInfoToOptionalTypeInfo$OFFSET = 2000;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CastTypeInfoToOptionalTypeInfo$offset() {\n+        return CastTypeInfoToOptionalTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CastTypeInfoToOptionalTypeInfo(MemorySegment struct) {\n+        return struct.get(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * }\n+     *\/\n+    public static void CastTypeInfoToOptionalTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class GetOptionalContainedTypeInfo {\n+\n+        GetOptionalContainedTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetOptionalContainedTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetOptionalContainedTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOptionalContainedTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOptionalContainedTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetOptionalContainedTypeInfo$layout() {\n+        return GetOptionalContainedTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long GetOptionalContainedTypeInfo$OFFSET = 2008;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long GetOptionalContainedTypeInfo$offset() {\n+        return GetOptionalContainedTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetOptionalContainedTypeInfo(MemorySegment struct) {\n+        return struct.get(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void GetOptionalContainedTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    public static class GetResizedStringTensorElementBuffer {\n+\n+        GetResizedStringTensorElementBuffer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetResizedStringTensorElementBuffer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetResizedStringTensorElementBuffer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetResizedStringTensorElementBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetResizedStringTensorElementBuffer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetResizedStringTensorElementBuffer$layout() {\n+        return GetResizedStringTensorElementBuffer$LAYOUT;\n+    }\n+\n+    private static final long GetResizedStringTensorElementBuffer$OFFSET = 2016;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    public static final long GetResizedStringTensorElementBuffer$offset() {\n+        return GetResizedStringTensorElementBuffer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetResizedStringTensorElementBuffer(MemorySegment struct) {\n+        return struct.get(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * }\n+     *\/\n+    public static void GetResizedStringTensorElementBuffer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static class KernelContext_GetAllocator {\n+\n+        KernelContext_GetAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelContext_GetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetAllocator\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelContext_GetAllocator$layout() {\n+        return KernelContext_GetAllocator$LAYOUT;\n+    }\n+\n+    private static final long KernelContext_GetAllocator$OFFSET = 2024;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static final long KernelContext_GetAllocator$offset() {\n+        return KernelContext_GetAllocator$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetAllocator(MemorySegment struct) {\n+        return struct.get(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static void KernelContext_GetAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    public static class GetBuildInfoString {\n+\n+        GetBuildInfoString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply();\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER);\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetBuildInfoString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetBuildInfoString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetBuildInfoString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBuildInfoString\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    public static final AddressLayout GetBuildInfoString$layout() {\n+        return GetBuildInfoString$LAYOUT;\n+    }\n+\n+    private static final long GetBuildInfoString$OFFSET = 2032;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    public static final long GetBuildInfoString$offset() {\n+        return GetBuildInfoString$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    public static MemorySegment GetBuildInfoString(MemorySegment struct) {\n+        return struct.get(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetBuildInfoString)(void)\n+     * }\n+     *\/\n+    public static void GetBuildInfoString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    public static class CreateROCMProviderOptions {\n+\n+        CreateROCMProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateROCMProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateROCMProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateROCMProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateROCMProviderOptions$layout() {\n+        return CreateROCMProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateROCMProviderOptions$OFFSET = 2040;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    public static final long CreateROCMProviderOptions$offset() {\n+        return CreateROCMProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateROCMProviderOptions(MemorySegment struct) {\n+        return struct.get(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * }\n+     *\/\n+    public static void CreateROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class UpdateROCMProviderOptions {\n+\n+        UpdateROCMProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateROCMProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateROCMProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateROCMProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateROCMProviderOptions$layout() {\n+        return UpdateROCMProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long UpdateROCMProviderOptions$OFFSET = 2048;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long UpdateROCMProviderOptions$offset() {\n+        return UpdateROCMProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateROCMProviderOptions(MemorySegment struct) {\n+        return struct.get(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void UpdateROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static class GetROCMProviderOptionsAsString {\n+\n+        GetROCMProviderOptionsAsString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetROCMProviderOptionsAsString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetROCMProviderOptionsAsString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetROCMProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetROCMProviderOptionsAsString\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetROCMProviderOptionsAsString$layout() {\n+        return GetROCMProviderOptionsAsString$LAYOUT;\n+    }\n+\n+    private static final long GetROCMProviderOptionsAsString$OFFSET = 2056;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static final long GetROCMProviderOptionsAsString$offset() {\n+        return GetROCMProviderOptionsAsString$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetROCMProviderOptionsAsString(MemorySegment struct) {\n+        return struct.get(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * }\n+     *\/\n+    public static void GetROCMProviderOptionsAsString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseROCMProviderOptions {\n+\n+        ReleaseROCMProviderOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseROCMProviderOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseROCMProviderOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseROCMProviderOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseROCMProviderOptions$layout() {\n+        return ReleaseROCMProviderOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseROCMProviderOptions$OFFSET = 2064;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseROCMProviderOptions$offset() {\n+        return ReleaseROCMProviderOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseROCMProviderOptions(MemorySegment struct) {\n+        return struct.get(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseROCMProviderOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static class CreateAndRegisterAllocatorV2 {\n+\n+        CreateAndRegisterAllocatorV2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateAndRegisterAllocatorV2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateAndRegisterAllocatorV2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateAndRegisterAllocatorV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAndRegisterAllocatorV2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateAndRegisterAllocatorV2$layout() {\n+        return CreateAndRegisterAllocatorV2$LAYOUT;\n+    }\n+\n+    private static final long CreateAndRegisterAllocatorV2$OFFSET = 2072;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static final long CreateAndRegisterAllocatorV2$offset() {\n+        return CreateAndRegisterAllocatorV2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment CreateAndRegisterAllocatorV2(MemorySegment struct) {\n+        return struct.get(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static void CreateAndRegisterAllocatorV2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    public static class RunAsync {\n+\n+        RunAsync() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunAsync.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunAsync.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout RunAsync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunAsync\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout RunAsync$layout() {\n+        return RunAsync$LAYOUT;\n+    }\n+\n+    private static final long RunAsync$OFFSET = 2080;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    public static final long RunAsync$offset() {\n+        return RunAsync$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    public static MemorySegment RunAsync(MemorySegment struct) {\n+        return struct.get(RunAsync$LAYOUT, RunAsync$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * }\n+     *\/\n+    public static void RunAsync(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunAsync$LAYOUT, RunAsync$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static class UpdateTensorRTProviderOptionsWithValue {\n+\n+        UpdateTensorRTProviderOptionsWithValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateTensorRTProviderOptionsWithValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateTensorRTProviderOptionsWithValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout UpdateTensorRTProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateTensorRTProviderOptionsWithValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout UpdateTensorRTProviderOptionsWithValue$layout() {\n+        return UpdateTensorRTProviderOptionsWithValue$LAYOUT;\n+    }\n+\n+    private static final long UpdateTensorRTProviderOptionsWithValue$OFFSET = 2088;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static final long UpdateTensorRTProviderOptionsWithValue$offset() {\n+        return UpdateTensorRTProviderOptionsWithValue$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateTensorRTProviderOptionsWithValue(MemorySegment struct) {\n+        return struct.get(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static void UpdateTensorRTProviderOptionsWithValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static class GetTensorRTProviderOptionsByName {\n+\n+        GetTensorRTProviderOptionsByName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorRTProviderOptionsByName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorRTProviderOptionsByName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetTensorRTProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorRTProviderOptionsByName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetTensorRTProviderOptionsByName$layout() {\n+        return GetTensorRTProviderOptionsByName$LAYOUT;\n+    }\n+\n+    private static final long GetTensorRTProviderOptionsByName$OFFSET = 2096;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static final long GetTensorRTProviderOptionsByName$offset() {\n+        return GetTensorRTProviderOptionsByName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorRTProviderOptionsByName(MemorySegment struct) {\n+        return struct.get(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static void GetTensorRTProviderOptionsByName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static class UpdateCUDAProviderOptionsWithValue {\n+\n+        UpdateCUDAProviderOptionsWithValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n@@ -2638,8 +27025,9 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UpdateCUDAProviderOptionsWithValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UpdateCUDAProviderOptionsWithValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -2652,1 +27040,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -2654,1 +27042,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -2661,3 +27049,1 @@\n-    private static final AddressLayout CreateTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorAsOrtValue\"));\n-\n-    private static final long CreateTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorAsOrtValue\"));\n+    private static final AddressLayout UpdateCUDAProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCUDAProviderOptionsWithValue\"));\n@@ -2666,1 +27052,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2668,1 +27054,1 @@\n-     * OrtStatusPtr (*CreateTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n@@ -2671,3 +27057,2 @@\n-    public static MemorySegment CreateTensorAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateTensorAsOrtValue$LAYOUT, CreateTensorAsOrtValue$OFFSET);\n-        return CreateTensorAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout UpdateCUDAProviderOptionsWithValue$layout() {\n+        return UpdateCUDAProviderOptionsWithValue$LAYOUT;\n@@ -2676,0 +27061,2 @@\n+    private static final long UpdateCUDAProviderOptionsWithValue$OFFSET = 2104;\n+\n@@ -2677,0 +27064,1 @@\n+     * Offset for field:\n@@ -2678,1 +27066,1 @@\n-     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n@@ -2681,25 +27069,2 @@\n-    private static class CreateTensorWithDataAsOrtValue {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long UpdateCUDAProviderOptionsWithValue$offset() {\n+        return UpdateCUDAProviderOptionsWithValue$OFFSET;\n@@ -2708,3 +27073,9 @@\n-    private static final AddressLayout CreateTensorWithDataAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorWithDataAsOrtValue\"));\n-\n-    private static final long CreateTensorWithDataAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorWithDataAsOrtValue\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n+     * }\n+     *\/\n+    public static MemorySegment UpdateCUDAProviderOptionsWithValue(MemorySegment struct) {\n+        return struct.get(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET);\n+    }\n@@ -2713,1 +27084,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2715,1 +27086,1 @@\n-     * OrtStatusPtr (*CreateTensorWithDataAsOrtValue)(const OrtMemoryInfo *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n@@ -2718,3 +27089,2 @@\n-    public static MemorySegment CreateTensorWithDataAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {\n-        var funcPtr = struct.get(CreateTensorWithDataAsOrtValue$LAYOUT, CreateTensorWithDataAsOrtValue$OFFSET);\n-        return CreateTensorWithDataAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+    public static void UpdateCUDAProviderOptionsWithValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET, fieldValue);\n@@ -2725,1 +27095,1 @@\n-     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n@@ -2728,1 +27098,12 @@\n-    private static class IsTensor {\n+    public static class GetCUDAProviderOptionsByName {\n+\n+        GetCUDAProviderOptionsByName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -2731,3 +27112,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2736,0 +27118,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetCUDAProviderOptionsByName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetCUDAProviderOptionsByName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2741,1 +27140,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -2743,1 +27142,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -2750,3 +27149,1 @@\n-    private static final AddressLayout IsTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"IsTensor\"));\n-\n-    private static final long IsTensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"IsTensor\"));\n+    private static final AddressLayout GetCUDAProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCUDAProviderOptionsByName\"));\n@@ -2755,1 +27152,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2757,1 +27154,1 @@\n-     * OrtStatusPtr (*IsTensor)(const OrtValue *, int *)\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n@@ -2760,3 +27157,2 @@\n-    public static MemorySegment IsTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(IsTensor$LAYOUT, IsTensor$OFFSET);\n-        return IsTensor.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout GetCUDAProviderOptionsByName$layout() {\n+        return GetCUDAProviderOptionsByName$LAYOUT;\n@@ -2765,0 +27161,2 @@\n+    private static final long GetCUDAProviderOptionsByName$OFFSET = 2112;\n+\n@@ -2766,0 +27164,1 @@\n+     * Offset for field:\n@@ -2767,1 +27166,1 @@\n-     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n@@ -2770,20 +27169,2 @@\n-    private static class GetTensorMutableData {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetCUDAProviderOptionsByName$offset() {\n+        return GetCUDAProviderOptionsByName$OFFSET;\n@@ -2792,3 +27173,9 @@\n-    private static final AddressLayout GetTensorMutableData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorMutableData\"));\n-\n-    private static final long GetTensorMutableData$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorMutableData\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetCUDAProviderOptionsByName(MemorySegment struct) {\n+        return struct.get(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET);\n+    }\n@@ -2797,1 +27184,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2799,1 +27186,1 @@\n-     * OrtStatusPtr (*GetTensorMutableData)(OrtValue *, void **)\n+     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n@@ -2802,3 +27189,2 @@\n-    public static MemorySegment GetTensorMutableData(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetTensorMutableData$LAYOUT, GetTensorMutableData$OFFSET);\n-        return GetTensorMutableData.invoke(funcPtr, _x0, _x1);\n+    public static void GetCUDAProviderOptionsByName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET, fieldValue);\n@@ -2809,1 +27195,1 @@\n-     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n@@ -2812,1 +27198,12 @@\n-    private static class FillStringTensor {\n+    public static class KernelContext_GetResource {\n+\n+        KernelContext_GetResource() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, MemorySegment _x3);\n+        }\n@@ -2815,4 +27212,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2821,0 +27219,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetResource.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetResource.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2826,1 +27241,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {\n@@ -2828,1 +27243,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -2835,3 +27250,1 @@\n-    private static final AddressLayout FillStringTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillStringTensor\"));\n-\n-    private static final long FillStringTensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillStringTensor\"));\n+    private static final AddressLayout KernelContext_GetResource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetResource\"));\n@@ -2840,1 +27253,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2842,1 +27255,1 @@\n-     * OrtStatusPtr (*FillStringTensor)(OrtValue *, const char *const *, size_t)\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n@@ -2845,3 +27258,2 @@\n-    public static MemorySegment FillStringTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(FillStringTensor$LAYOUT, FillStringTensor$OFFSET);\n-        return FillStringTensor.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout KernelContext_GetResource$layout() {\n+        return KernelContext_GetResource$LAYOUT;\n@@ -2850,0 +27262,2 @@\n+    private static final long KernelContext_GetResource$OFFSET = 2120;\n+\n@@ -2851,0 +27265,1 @@\n+     * Offset for field:\n@@ -2852,1 +27267,1 @@\n-     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n@@ -2855,20 +27270,2 @@\n-    private static class GetStringTensorDataLength {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long KernelContext_GetResource$offset() {\n+        return KernelContext_GetResource$OFFSET;\n@@ -2877,3 +27274,9 @@\n-    private static final AddressLayout GetStringTensorDataLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorDataLength\"));\n-\n-    private static final long GetStringTensorDataLength$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorDataLength\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetResource(MemorySegment struct) {\n+        return struct.get(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET);\n+    }\n@@ -2882,1 +27285,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2884,1 +27287,1 @@\n-     * OrtStatusPtr (*GetStringTensorDataLength)(const OrtValue *, size_t *)\n+     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n@@ -2887,3 +27290,2 @@\n-    public static MemorySegment GetStringTensorDataLength(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetStringTensorDataLength$LAYOUT, GetStringTensorDataLength$OFFSET);\n-        return GetStringTensorDataLength.invoke(funcPtr, _x0, _x1);\n+    public static void KernelContext_GetResource(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET, fieldValue);\n@@ -2894,1 +27296,1 @@\n-     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n@@ -2897,1 +27299,12 @@\n-    private static class GetStringTensorContent {\n+    public static class SetUserLoggingFunction {\n+\n+        SetUserLoggingFunction() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -2900,6 +27313,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2908,0 +27319,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetUserLoggingFunction.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetUserLoggingFunction.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -2913,1 +27341,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -2915,1 +27343,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -2922,3 +27350,1 @@\n-    private static final AddressLayout GetStringTensorContent$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorContent\"));\n-\n-    private static final long GetStringTensorContent$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorContent\"));\n+    private static final AddressLayout SetUserLoggingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetUserLoggingFunction\"));\n@@ -2927,1 +27353,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -2929,1 +27355,1 @@\n-     * OrtStatusPtr (*GetStringTensorContent)(const OrtValue *, void *, size_t, size_t *, size_t)\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n@@ -2932,3 +27358,2 @@\n-    public static MemorySegment GetStringTensorContent(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n-        var funcPtr = struct.get(GetStringTensorContent$LAYOUT, GetStringTensorContent$OFFSET);\n-        return GetStringTensorContent.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout SetUserLoggingFunction$layout() {\n+        return SetUserLoggingFunction$LAYOUT;\n@@ -2937,0 +27362,2 @@\n+    private static final long SetUserLoggingFunction$OFFSET = 2128;\n+\n@@ -2938,0 +27365,1 @@\n+     * Offset for field:\n@@ -2939,1 +27367,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n@@ -2942,20 +27370,2 @@\n-    private static class CastTypeInfoToTensorInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetUserLoggingFunction$offset() {\n+        return SetUserLoggingFunction$OFFSET;\n@@ -2964,3 +27374,9 @@\n-    private static final AddressLayout CastTypeInfoToTensorInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToTensorInfo\"));\n-\n-    private static final long CastTypeInfoToTensorInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToTensorInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SetUserLoggingFunction(MemorySegment struct) {\n+        return struct.get(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET);\n+    }\n@@ -2969,1 +27385,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -2971,1 +27387,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToTensorInfo)(const OrtTypeInfo *, const OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n@@ -2974,3 +27390,2 @@\n-    public static MemorySegment CastTypeInfoToTensorInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CastTypeInfoToTensorInfo$LAYOUT, CastTypeInfoToTensorInfo$OFFSET);\n-        return CastTypeInfoToTensorInfo.invoke(funcPtr, _x0, _x1);\n+    public static void SetUserLoggingFunction(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET, fieldValue);\n@@ -2981,1 +27396,1 @@\n-     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n@@ -2984,1 +27399,12 @@\n-    private static class GetOnnxTypeFromTypeInfo {\n+    public static class ShapeInferContext_GetInputCount {\n+\n+        ShapeInferContext_GetInputCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -2987,3 +27413,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -2992,0 +27418,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ShapeInferContext_GetInputCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ShapeInferContext_GetInputCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3006,3 +27449,1 @@\n-    private static final AddressLayout GetOnnxTypeFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOnnxTypeFromTypeInfo\"));\n-\n-    private static final long GetOnnxTypeFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetOnnxTypeFromTypeInfo\"));\n+    private static final AddressLayout ShapeInferContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetInputCount\"));\n@@ -3011,1 +27452,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3013,1 +27454,1 @@\n-     * OrtStatusPtr (*GetOnnxTypeFromTypeInfo)(const OrtTypeInfo *, enum ONNXType *)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n@@ -3016,3 +27457,2 @@\n-    public static MemorySegment GetOnnxTypeFromTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetOnnxTypeFromTypeInfo$LAYOUT, GetOnnxTypeFromTypeInfo$OFFSET);\n-        return GetOnnxTypeFromTypeInfo.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout ShapeInferContext_GetInputCount$layout() {\n+        return ShapeInferContext_GetInputCount$LAYOUT;\n@@ -3021,0 +27461,2 @@\n+    private static final long ShapeInferContext_GetInputCount$OFFSET = 2136;\n+\n@@ -3022,0 +27464,1 @@\n+     * Offset for field:\n@@ -3023,1 +27466,1 @@\n-     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n@@ -3026,8 +27469,3 @@\n-    private static class CreateTensorTypeAndShapeInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+    public static final long ShapeInferContext_GetInputCount$offset() {\n+        return ShapeInferContext_GetInputCount$OFFSET;\n+    }\n@@ -3035,10 +27473,8 @@\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_GetInputCount(MemorySegment struct) {\n+        return struct.get(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET);\n@@ -3047,4 +27483,0 @@\n-    private static final AddressLayout CreateTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorTypeAndShapeInfo\"));\n-\n-    private static final long CreateTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorTypeAndShapeInfo\"));\n-\n@@ -3052,1 +27484,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3054,1 +27486,1 @@\n-     * OrtStatusPtr (*CreateTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n@@ -3057,3 +27489,2 @@\n-    public static MemorySegment CreateTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateTensorTypeAndShapeInfo$LAYOUT, CreateTensorTypeAndShapeInfo$OFFSET);\n-        return CreateTensorTypeAndShapeInfo.invoke(funcPtr, _x0);\n+    public static void ShapeInferContext_GetInputCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET, fieldValue);\n@@ -3064,1 +27495,1 @@\n-     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n@@ -3067,1 +27498,12 @@\n-    private static class SetTensorElementType {\n+    public static class ShapeInferContext_GetInputTypeShape {\n+\n+        ShapeInferContext_GetInputTypeShape() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n@@ -3070,3 +27512,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3075,0 +27518,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ShapeInferContext_GetInputTypeShape.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ShapeInferContext_GetInputTypeShape.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3080,1 +27540,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n@@ -3082,1 +27542,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -3089,3 +27549,1 @@\n-    private static final AddressLayout SetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetTensorElementType\"));\n-\n-    private static final long SetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetTensorElementType\"));\n+    private static final AddressLayout ShapeInferContext_GetInputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetInputTypeShape\"));\n@@ -3094,1 +27552,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3096,1 +27554,1 @@\n-     * OrtStatusPtr (*SetTensorElementType)(OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n@@ -3099,3 +27557,2 @@\n-    public static MemorySegment SetTensorElementType(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetTensorElementType$LAYOUT, SetTensorElementType$OFFSET);\n-        return SetTensorElementType.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout ShapeInferContext_GetInputTypeShape$layout() {\n+        return ShapeInferContext_GetInputTypeShape$LAYOUT;\n@@ -3104,0 +27561,2 @@\n+    private static final long ShapeInferContext_GetInputTypeShape$OFFSET = 2144;\n+\n@@ -3105,0 +27564,1 @@\n+     * Offset for field:\n@@ -3106,1 +27566,1 @@\n-     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n@@ -3109,21 +27569,2 @@\n-    private static class SetDimensions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ShapeInferContext_GetInputTypeShape$offset() {\n+        return ShapeInferContext_GetInputTypeShape$OFFSET;\n@@ -3132,3 +27573,9 @@\n-    private static final AddressLayout SetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetDimensions\"));\n-\n-    private static final long SetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetDimensions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_GetInputTypeShape(MemorySegment struct) {\n+        return struct.get(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET);\n+    }\n@@ -3137,1 +27584,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3139,1 +27586,1 @@\n-     * OrtStatusPtr (*SetDimensions)(OrtTensorTypeAndShapeInfo *, const int64_t *, size_t)\n+     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n@@ -3142,3 +27589,2 @@\n-    public static MemorySegment SetDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(SetDimensions$LAYOUT, SetDimensions$OFFSET);\n-        return SetDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void ShapeInferContext_GetInputTypeShape(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET, fieldValue);\n@@ -3149,1 +27595,1 @@\n-     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n@@ -3152,1 +27598,12 @@\n-    private static class GetTensorElementType {\n+    public static class ShapeInferContext_GetAttribute {\n+\n+        ShapeInferContext_GetAttribute() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -3155,3 +27612,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3160,0 +27618,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ShapeInferContext_GetAttribute.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ShapeInferContext_GetAttribute.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3165,1 +27640,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -3167,1 +27642,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -3174,3 +27649,1 @@\n-    private static final AddressLayout GetTensorElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorElementType\"));\n-\n-    private static final long GetTensorElementType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorElementType\"));\n+    private static final AddressLayout ShapeInferContext_GetAttribute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetAttribute\"));\n@@ -3179,1 +27652,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3181,1 +27654,1 @@\n-     * OrtStatusPtr (*GetTensorElementType)(const OrtTensorTypeAndShapeInfo *, enum ONNXTensorElementDataType *)\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n@@ -3184,3 +27657,2 @@\n-    public static MemorySegment GetTensorElementType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetTensorElementType$LAYOUT, GetTensorElementType$OFFSET);\n-        return GetTensorElementType.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout ShapeInferContext_GetAttribute$layout() {\n+        return ShapeInferContext_GetAttribute$LAYOUT;\n@@ -3189,0 +27661,2 @@\n+    private static final long ShapeInferContext_GetAttribute$OFFSET = 2152;\n+\n@@ -3190,0 +27664,1 @@\n+     * Offset for field:\n@@ -3191,1 +27666,1 @@\n-     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n@@ -3194,20 +27669,2 @@\n-    private static class GetDimensionsCount {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ShapeInferContext_GetAttribute$offset() {\n+        return ShapeInferContext_GetAttribute$OFFSET;\n@@ -3216,3 +27673,9 @@\n-    private static final AddressLayout GetDimensionsCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDimensionsCount\"));\n-\n-    private static final long GetDimensionsCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDimensionsCount\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_GetAttribute(MemorySegment struct) {\n+        return struct.get(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET);\n+    }\n@@ -3221,1 +27684,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3223,1 +27686,1 @@\n-     * OrtStatusPtr (*GetDimensionsCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n@@ -3226,3 +27689,2 @@\n-    public static MemorySegment GetDimensionsCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetDimensionsCount$LAYOUT, GetDimensionsCount$OFFSET);\n-        return GetDimensionsCount.invoke(funcPtr, _x0, _x1);\n+    public static void ShapeInferContext_GetAttribute(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET, fieldValue);\n@@ -3233,1 +27695,1 @@\n-     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n@@ -3236,1 +27698,12 @@\n-    private static class GetDimensions {\n+    public static class ShapeInferContext_SetOutputTypeShape {\n+\n+        ShapeInferContext_SetOutputTypeShape() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2);\n+        }\n@@ -3239,4 +27712,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3245,0 +27718,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ShapeInferContext_SetOutputTypeShape.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ShapeInferContext_SetOutputTypeShape.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3250,1 +27740,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n@@ -3259,3 +27749,1 @@\n-    private static final AddressLayout GetDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDimensions\"));\n-\n-    private static final long GetDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDimensions\"));\n+    private static final AddressLayout ShapeInferContext_SetOutputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_SetOutputTypeShape\"));\n@@ -3264,1 +27752,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3266,1 +27754,1 @@\n-     * OrtStatusPtr (*GetDimensions)(const OrtTensorTypeAndShapeInfo *, int64_t *, size_t)\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n@@ -3269,3 +27757,2 @@\n-    public static MemorySegment GetDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(GetDimensions$LAYOUT, GetDimensions$OFFSET);\n-        return GetDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout ShapeInferContext_SetOutputTypeShape$layout() {\n+        return ShapeInferContext_SetOutputTypeShape$LAYOUT;\n@@ -3274,0 +27761,2 @@\n+    private static final long ShapeInferContext_SetOutputTypeShape$OFFSET = 2160;\n+\n@@ -3275,0 +27764,1 @@\n+     * Offset for field:\n@@ -3276,1 +27766,1 @@\n-     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n@@ -3279,21 +27769,2 @@\n-    private static class GetSymbolicDimensions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ShapeInferContext_SetOutputTypeShape$offset() {\n+        return ShapeInferContext_SetOutputTypeShape$OFFSET;\n@@ -3302,3 +27773,9 @@\n-    private static final AddressLayout GetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSymbolicDimensions\"));\n-\n-    private static final long GetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSymbolicDimensions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ShapeInferContext_SetOutputTypeShape(MemorySegment struct) {\n+        return struct.get(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET);\n+    }\n@@ -3307,1 +27784,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3309,1 +27786,1 @@\n-     * OrtStatusPtr (*GetSymbolicDimensions)(const OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n@@ -3312,3 +27789,2 @@\n-    public static MemorySegment GetSymbolicDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(GetSymbolicDimensions$LAYOUT, GetSymbolicDimensions$OFFSET);\n-        return GetSymbolicDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void ShapeInferContext_SetOutputTypeShape(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET, fieldValue);\n@@ -3319,1 +27795,1 @@\n-     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n@@ -3322,1 +27798,12 @@\n-    private static class GetTensorShapeElementCount {\n+    public static class SetSymbolicDimensions {\n+\n+        SetSymbolicDimensions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -3325,3 +27812,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -3330,0 +27818,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetSymbolicDimensions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetSymbolicDimensions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3335,1 +27840,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -3337,1 +27842,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -3344,3 +27849,1 @@\n-    private static final AddressLayout GetTensorShapeElementCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorShapeElementCount\"));\n-\n-    private static final long GetTensorShapeElementCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorShapeElementCount\"));\n+    private static final AddressLayout SetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSymbolicDimensions\"));\n@@ -3349,1 +27852,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3351,1 +27854,1 @@\n-     * OrtStatusPtr (*GetTensorShapeElementCount)(const OrtTensorTypeAndShapeInfo *, size_t *)\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n@@ -3354,3 +27857,2 @@\n-    public static MemorySegment GetTensorShapeElementCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetTensorShapeElementCount$LAYOUT, GetTensorShapeElementCount$OFFSET);\n-        return GetTensorShapeElementCount.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SetSymbolicDimensions$layout() {\n+        return SetSymbolicDimensions$LAYOUT;\n@@ -3359,0 +27861,2 @@\n+    private static final long SetSymbolicDimensions$OFFSET = 2168;\n+\n@@ -3360,0 +27864,1 @@\n+     * Offset for field:\n@@ -3361,1 +27866,1 @@\n-     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n@@ -3364,20 +27869,2 @@\n-    private static class GetTensorTypeAndShape {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetSymbolicDimensions$offset() {\n+        return SetSymbolicDimensions$OFFSET;\n@@ -3386,3 +27873,9 @@\n-    private static final AddressLayout GetTensorTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorTypeAndShape\"));\n-\n-    private static final long GetTensorTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorTypeAndShape\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetSymbolicDimensions(MemorySegment struct) {\n+        return struct.get(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET);\n+    }\n@@ -3391,1 +27884,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3393,1 +27886,1 @@\n-     * OrtStatusPtr (*GetTensorTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n@@ -3396,3 +27889,2 @@\n-    public static MemorySegment GetTensorTypeAndShape(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetTensorTypeAndShape$LAYOUT, GetTensorTypeAndShape$OFFSET);\n-        return GetTensorTypeAndShape.invoke(funcPtr, _x0, _x1);\n+    public static void SetSymbolicDimensions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET, fieldValue);\n@@ -3403,1 +27895,1 @@\n-     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n@@ -3406,1 +27898,12 @@\n-    private static class GetTypeInfo {\n+    public static class ReadOpAttr {\n+\n+        ReadOpAttr() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4);\n+        }\n@@ -3409,3 +27912,6 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3414,0 +27920,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReadOpAttr.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReadOpAttr.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3419,1 +27942,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n@@ -3421,1 +27944,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n@@ -3428,1 +27951,11 @@\n-    private static final AddressLayout GetTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTypeInfo\"));\n+    private static final AddressLayout ReadOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReadOpAttr\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReadOpAttr$layout() {\n+        return ReadOpAttr$LAYOUT;\n+    }\n@@ -3430,1 +27963,1 @@\n-    private static final long GetTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTypeInfo\"));\n+    private static final long ReadOpAttr$OFFSET = 2176;\n@@ -3433,1 +27966,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -3435,1 +27968,1 @@\n-     * OrtStatusPtr (*GetTypeInfo)(const OrtValue *, OrtTypeInfo **)\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n@@ -3438,3 +27971,2 @@\n-    public static MemorySegment GetTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetTypeInfo$LAYOUT, GetTypeInfo$OFFSET);\n-        return GetTypeInfo.invoke(funcPtr, _x0, _x1);\n+    public static final long ReadOpAttr$offset() {\n+        return ReadOpAttr$OFFSET;\n@@ -3444,0 +27976,1 @@\n+     * Getter for field:\n@@ -3445,1 +27978,1 @@\n-     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n@@ -3448,20 +27981,2 @@\n-    private static class GetValueType {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static MemorySegment ReadOpAttr(MemorySegment struct) {\n+        return struct.get(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET);\n@@ -3470,4 +27985,0 @@\n-    private static final AddressLayout GetValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueType\"));\n-\n-    private static final long GetValueType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetValueType\"));\n-\n@@ -3475,1 +27986,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3477,1 +27988,1 @@\n-     * OrtStatusPtr (*GetValueType)(const OrtValue *, enum ONNXType *)\n+     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n@@ -3480,3 +27991,2 @@\n-    public static MemorySegment GetValueType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetValueType$LAYOUT, GetValueType$OFFSET);\n-        return GetValueType.invoke(funcPtr, _x0, _x1);\n+    public static void ReadOpAttr(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET, fieldValue);\n@@ -3487,1 +27997,1 @@\n-     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n@@ -3490,1 +28000,12 @@\n-    private static class CreateMemoryInfo {\n+    public static class SetDeterministicCompute {\n+\n+        SetDeterministicCompute() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, boolean _x1);\n+        }\n@@ -3493,6 +28014,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_BOOL\n@@ -3501,0 +28019,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetDeterministicCompute.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetDeterministicCompute.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3506,1 +28041,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {\n@@ -3508,1 +28043,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -3515,3 +28050,1 @@\n-    private static final AddressLayout CreateMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateMemoryInfo\"));\n-\n-    private static final long CreateMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateMemoryInfo\"));\n+    private static final AddressLayout SetDeterministicCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetDeterministicCompute\"));\n@@ -3520,1 +28053,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3522,1 +28055,1 @@\n-     * OrtStatusPtr (*CreateMemoryInfo)(const char *, enum OrtAllocatorType, int, enum OrtMemType, OrtMemoryInfo **)\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n@@ -3525,3 +28058,2 @@\n-    public static MemorySegment CreateMemoryInfo(MemorySegment struct, MemorySegment _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateMemoryInfo$LAYOUT, CreateMemoryInfo$OFFSET);\n-        return CreateMemoryInfo.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout SetDeterministicCompute$layout() {\n+        return SetDeterministicCompute$LAYOUT;\n@@ -3530,0 +28062,2 @@\n+    private static final long SetDeterministicCompute$OFFSET = 2184;\n+\n@@ -3531,0 +28065,1 @@\n+     * Offset for field:\n@@ -3532,1 +28067,1 @@\n-     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n@@ -3535,21 +28070,2 @@\n-    private static class CreateCpuMemoryInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, int _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetDeterministicCompute$offset() {\n+        return SetDeterministicCompute$OFFSET;\n@@ -3558,3 +28074,9 @@\n-    private static final AddressLayout CreateCpuMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCpuMemoryInfo\"));\n-\n-    private static final long CreateCpuMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCpuMemoryInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n+     * }\n+     *\/\n+    public static MemorySegment SetDeterministicCompute(MemorySegment struct) {\n+        return struct.get(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET);\n+    }\n@@ -3563,1 +28085,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3565,1 +28087,1 @@\n-     * OrtStatusPtr (*CreateCpuMemoryInfo)(enum OrtAllocatorType, enum OrtMemType, OrtMemoryInfo **)\n+     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n@@ -3568,3 +28090,2 @@\n-    public static MemorySegment CreateCpuMemoryInfo(MemorySegment struct, int _x0, int _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(CreateCpuMemoryInfo$LAYOUT, CreateCpuMemoryInfo$OFFSET);\n-        return CreateCpuMemoryInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void SetDeterministicCompute(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET, fieldValue);\n@@ -3575,1 +28096,1 @@\n-     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n@@ -3578,1 +28099,12 @@\n-    private static class CompareMemoryInfo {\n+    public static class KernelContext_ParallelFor {\n+\n+        KernelContext_ParallelFor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4);\n+        }\n@@ -3581,4 +28113,6 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3587,0 +28121,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_ParallelFor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_ParallelFor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3592,1 +28143,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {\n@@ -3594,1 +28145,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n@@ -3601,3 +28152,1 @@\n-    private static final AddressLayout CompareMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CompareMemoryInfo\"));\n-\n-    private static final long CompareMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CompareMemoryInfo\"));\n+    private static final AddressLayout KernelContext_ParallelFor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_ParallelFor\"));\n@@ -3606,1 +28155,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3608,1 +28157,1 @@\n-     * OrtStatusPtr (*CompareMemoryInfo)(const OrtMemoryInfo *, const OrtMemoryInfo *, int *)\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n@@ -3611,3 +28160,2 @@\n-    public static MemorySegment CompareMemoryInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(CompareMemoryInfo$LAYOUT, CompareMemoryInfo$OFFSET);\n-        return CompareMemoryInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout KernelContext_ParallelFor$layout() {\n+        return KernelContext_ParallelFor$LAYOUT;\n@@ -3616,0 +28164,2 @@\n+    private static final long KernelContext_ParallelFor$OFFSET = 2192;\n+\n@@ -3617,0 +28167,1 @@\n+     * Offset for field:\n@@ -3618,1 +28169,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n@@ -3621,20 +28172,2 @@\n-    private static class MemoryInfoGetName {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long KernelContext_ParallelFor$offset() {\n+        return KernelContext_ParallelFor$OFFSET;\n@@ -3643,3 +28176,9 @@\n-    private static final AddressLayout MemoryInfoGetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetName\"));\n-\n-    private static final long MemoryInfoGetName$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetName\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_ParallelFor(MemorySegment struct) {\n+        return struct.get(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET);\n+    }\n@@ -3648,1 +28187,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3650,1 +28189,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetName)(const OrtMemoryInfo *, const char **)\n+     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n@@ -3653,3 +28192,2 @@\n-    public static MemorySegment MemoryInfoGetName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(MemoryInfoGetName$LAYOUT, MemoryInfoGetName$OFFSET);\n-        return MemoryInfoGetName.invoke(funcPtr, _x0, _x1);\n+    public static void KernelContext_ParallelFor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET, fieldValue);\n@@ -3660,1 +28198,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3663,1 +28201,12 @@\n-    private static class MemoryInfoGetId {\n+    public static class SessionOptionsAppendExecutionProvider_OpenVINO_V2 {\n+\n+        SessionOptionsAppendExecutionProvider_OpenVINO_V2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n@@ -3666,3 +28215,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -3671,0 +28222,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_OpenVINO_V2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3676,1 +28244,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n@@ -3678,1 +28246,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -3685,3 +28253,1 @@\n-    private static final AddressLayout MemoryInfoGetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetId\"));\n-\n-    private static final long MemoryInfoGetId$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetId\"));\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"));\n@@ -3690,1 +28256,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3692,1 +28258,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetId)(const OrtMemoryInfo *, int *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3695,3 +28261,2 @@\n-    public static MemorySegment MemoryInfoGetId(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(MemoryInfoGetId$LAYOUT, MemoryInfoGetId$OFFSET);\n-        return MemoryInfoGetId.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$layout() {\n+        return SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT;\n@@ -3700,0 +28265,2 @@\n+    private static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET = 2200;\n+\n@@ -3701,0 +28268,1 @@\n+     * Offset for field:\n@@ -3702,1 +28270,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3705,20 +28273,2 @@\n-    private static class MemoryInfoGetMemType {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$offset() {\n+        return SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET;\n@@ -3727,3 +28277,9 @@\n-    private static final AddressLayout MemoryInfoGetMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetMemType\"));\n-\n-    private static final long MemoryInfoGetMemType$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetMemType\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET);\n+    }\n@@ -3732,1 +28288,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3734,1 +28290,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetMemType)(const OrtMemoryInfo *, OrtMemType *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3737,3 +28293,2 @@\n-    public static MemorySegment MemoryInfoGetMemType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(MemoryInfoGetMemType$LAYOUT, MemoryInfoGetMemType$OFFSET);\n-        return MemoryInfoGetMemType.invoke(funcPtr, _x0, _x1);\n+    public static void SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET, fieldValue);\n@@ -3744,1 +28299,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3747,1 +28302,12 @@\n-    private static class MemoryInfoGetType {\n+    public static class SessionOptionsAppendExecutionProvider_VitisAI {\n+\n+        SessionOptionsAppendExecutionProvider_VitisAI() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n@@ -3750,3 +28316,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -3755,0 +28323,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_VitisAI.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_VitisAI.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3760,1 +28345,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n@@ -3762,1 +28347,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -3769,3 +28354,1 @@\n-    private static final AddressLayout MemoryInfoGetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetType\"));\n-\n-    private static final long MemoryInfoGetType$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetType\"));\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_VitisAI\"));\n@@ -3774,1 +28357,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3776,1 +28359,1 @@\n-     * OrtStatusPtr (*MemoryInfoGetType)(const OrtMemoryInfo *, OrtAllocatorType *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3779,3 +28362,2 @@\n-    public static MemorySegment MemoryInfoGetType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(MemoryInfoGetType$LAYOUT, MemoryInfoGetType$OFFSET);\n-        return MemoryInfoGetType.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$layout() {\n+        return SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT;\n@@ -3784,0 +28366,2 @@\n+    private static final long SessionOptionsAppendExecutionProvider_VitisAI$OFFSET = 2208;\n+\n@@ -3785,0 +28369,1 @@\n+     * Offset for field:\n@@ -3786,1 +28371,1 @@\n-     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3789,21 +28374,2 @@\n-    private static class AllocatorAlloc {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionOptionsAppendExecutionProvider_VitisAI$offset() {\n+        return SessionOptionsAppendExecutionProvider_VitisAI$OFFSET;\n@@ -3812,3 +28378,9 @@\n-    private static final AddressLayout AllocatorAlloc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorAlloc\"));\n-\n-    private static final long AllocatorAlloc$OFFSET = $LAYOUT.byteOffset(groupElement(\"AllocatorAlloc\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET);\n+    }\n@@ -3817,1 +28389,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3819,1 +28391,1 @@\n-     * OrtStatusPtr (*AllocatorAlloc)(OrtAllocator *, size_t, void **)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n@@ -3822,3 +28394,2 @@\n-    public static MemorySegment AllocatorAlloc(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(AllocatorAlloc$LAYOUT, AllocatorAlloc$OFFSET);\n-        return AllocatorAlloc.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET, fieldValue);\n@@ -3829,1 +28400,1 @@\n-     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n@@ -3832,1 +28403,12 @@\n-    private static class AllocatorFree {\n+    public static class KernelContext_GetScratchBuffer {\n+\n+        KernelContext_GetScratchBuffer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n@@ -3835,3 +28417,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3840,0 +28424,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelContext_GetScratchBuffer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelContext_GetScratchBuffer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3845,1 +28446,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n@@ -3847,1 +28448,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -3854,3 +28455,1 @@\n-    private static final AddressLayout AllocatorFree$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorFree\"));\n-\n-    private static final long AllocatorFree$OFFSET = $LAYOUT.byteOffset(groupElement(\"AllocatorFree\"));\n+    private static final AddressLayout KernelContext_GetScratchBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetScratchBuffer\"));\n@@ -3859,1 +28458,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3861,1 +28460,1 @@\n-     * OrtStatusPtr (*AllocatorFree)(OrtAllocator *, void *)\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n@@ -3864,3 +28463,2 @@\n-    public static MemorySegment AllocatorFree(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(AllocatorFree$LAYOUT, AllocatorFree$OFFSET);\n-        return AllocatorFree.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout KernelContext_GetScratchBuffer$layout() {\n+        return KernelContext_GetScratchBuffer$LAYOUT;\n@@ -3869,0 +28467,2 @@\n+    private static final long KernelContext_GetScratchBuffer$OFFSET = 2216;\n+\n@@ -3870,0 +28470,1 @@\n+     * Offset for field:\n@@ -3871,1 +28472,1 @@\n-     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n@@ -3874,20 +28475,2 @@\n-    private static class AllocatorGetInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long KernelContext_GetScratchBuffer$offset() {\n+        return KernelContext_GetScratchBuffer$OFFSET;\n@@ -3896,3 +28479,9 @@\n-    private static final AddressLayout AllocatorGetInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorGetInfo\"));\n-\n-    private static final long AllocatorGetInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"AllocatorGetInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelContext_GetScratchBuffer(MemorySegment struct) {\n+        return struct.get(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET);\n+    }\n@@ -3901,1 +28490,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3903,1 +28492,1 @@\n-     * OrtStatusPtr (*AllocatorGetInfo)(const OrtAllocator *, const struct OrtMemoryInfo **)\n+     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n@@ -3906,3 +28495,2 @@\n-    public static MemorySegment AllocatorGetInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(AllocatorGetInfo$LAYOUT, AllocatorGetInfo$OFFSET);\n-        return AllocatorGetInfo.invoke(funcPtr, _x0, _x1);\n+    public static void KernelContext_GetScratchBuffer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET, fieldValue);\n@@ -3913,1 +28501,1 @@\n-     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n@@ -3916,1 +28504,12 @@\n-    private static class GetAllocatorWithDefaultOptions {\n+    public static class KernelInfoGetAllocator {\n+\n+        KernelInfoGetAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, MemorySegment _x2);\n+        }\n@@ -3919,2 +28518,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -3923,0 +28524,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(KernelInfoGetAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelInfoGetAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -3928,1 +28546,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n@@ -3930,1 +28548,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -3937,3 +28555,1 @@\n-    private static final AddressLayout GetAllocatorWithDefaultOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAllocatorWithDefaultOptions\"));\n-\n-    private static final long GetAllocatorWithDefaultOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetAllocatorWithDefaultOptions\"));\n+    private static final AddressLayout KernelInfoGetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAllocator\"));\n@@ -3942,1 +28558,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -3944,1 +28560,1 @@\n-     * OrtStatusPtr (*GetAllocatorWithDefaultOptions)(OrtAllocator **)\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n@@ -3947,3 +28563,2 @@\n-    public static MemorySegment GetAllocatorWithDefaultOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(GetAllocatorWithDefaultOptions$LAYOUT, GetAllocatorWithDefaultOptions$OFFSET);\n-        return GetAllocatorWithDefaultOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout KernelInfoGetAllocator$layout() {\n+        return KernelInfoGetAllocator$LAYOUT;\n@@ -3952,0 +28567,2 @@\n+    private static final long KernelInfoGetAllocator$OFFSET = 2224;\n+\n@@ -3953,0 +28570,1 @@\n+     * Offset for field:\n@@ -3954,1 +28572,1 @@\n-     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n@@ -3957,21 +28575,2 @@\n-    private static class AddFreeDimensionOverride {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long KernelInfoGetAllocator$offset() {\n+        return KernelInfoGetAllocator$OFFSET;\n@@ -3980,3 +28579,9 @@\n-    private static final AddressLayout AddFreeDimensionOverride$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddFreeDimensionOverride\"));\n-\n-    private static final long AddFreeDimensionOverride$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddFreeDimensionOverride\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment KernelInfoGetAllocator(MemorySegment struct) {\n+        return struct.get(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET);\n+    }\n@@ -3985,1 +28590,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -3987,1 +28592,1 @@\n-     * OrtStatusPtr (*AddFreeDimensionOverride)(OrtSessionOptions *, const char *, int64_t)\n+     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n@@ -3990,3 +28595,2 @@\n-    public static MemorySegment AddFreeDimensionOverride(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(AddFreeDimensionOverride$LAYOUT, AddFreeDimensionOverride$OFFSET);\n-        return AddFreeDimensionOverride.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void KernelInfoGetAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET, fieldValue);\n@@ -3997,1 +28601,1 @@\n-     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n@@ -4000,1 +28604,12 @@\n-    private static class GetValue {\n+    public static class AddExternalInitializersFromFilesInMemory {\n+\n+        AddExternalInitializersFromFilesInMemory() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);\n+        }\n@@ -4003,5 +28618,6 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -4010,0 +28626,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddExternalInitializersFromFilesInMemory.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddExternalInitializersFromFilesInMemory.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4015,1 +28648,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n@@ -4017,1 +28650,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n@@ -4024,3 +28657,1 @@\n-    private static final AddressLayout GetValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValue\"));\n-\n-    private static final long GetValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetValue\"));\n+    private static final AddressLayout AddExternalInitializersFromFilesInMemory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddExternalInitializersFromFilesInMemory\"));\n@@ -4029,1 +28660,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4031,1 +28662,1 @@\n-     * OrtStatusPtr (*GetValue)(const OrtValue *, int, OrtAllocator *, OrtValue **)\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n@@ -4034,3 +28665,2 @@\n-    public static MemorySegment GetValue(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(GetValue$LAYOUT, GetValue$OFFSET);\n-        return GetValue.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout AddExternalInitializersFromFilesInMemory$layout() {\n+        return AddExternalInitializersFromFilesInMemory$LAYOUT;\n@@ -4039,0 +28669,2 @@\n+    private static final long AddExternalInitializersFromFilesInMemory$OFFSET = 2232;\n+\n@@ -4040,0 +28672,1 @@\n+     * Offset for field:\n@@ -4041,1 +28674,1 @@\n-     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n@@ -4044,20 +28677,2 @@\n-    private static class GetValueCount {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long AddExternalInitializersFromFilesInMemory$offset() {\n+        return AddExternalInitializersFromFilesInMemory$OFFSET;\n@@ -4066,3 +28681,9 @@\n-    private static final AddressLayout GetValueCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueCount\"));\n-\n-    private static final long GetValueCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetValueCount\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment AddExternalInitializersFromFilesInMemory(MemorySegment struct) {\n+        return struct.get(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET);\n+    }\n@@ -4071,1 +28692,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4073,1 +28694,1 @@\n-     * OrtStatusPtr (*GetValueCount)(const OrtValue *, size_t *)\n+     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n@@ -4076,3 +28697,2 @@\n-    public static MemorySegment GetValueCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetValueCount$LAYOUT, GetValueCount$OFFSET);\n-        return GetValueCount.invoke(funcPtr, _x0, _x1);\n+    public static void AddExternalInitializersFromFilesInMemory(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET, fieldValue);\n@@ -4083,1 +28703,1 @@\n-     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n@@ -4086,1 +28706,12 @@\n-    private static class CreateValue {\n+    public static class CreateLoraAdapter {\n+\n+        CreateLoraAdapter() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -4089,5 +28720,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -4096,0 +28726,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateLoraAdapter.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateLoraAdapter.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4101,1 +28748,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -4103,1 +28750,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -4110,3 +28757,1 @@\n-    private static final AddressLayout CreateValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateValue\"));\n-\n-    private static final long CreateValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateValue\"));\n+    private static final AddressLayout CreateLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateLoraAdapter\"));\n@@ -4115,1 +28760,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4117,1 +28762,1 @@\n-     * OrtStatusPtr (*CreateValue)(const OrtValue *const *, size_t, enum ONNXType, OrtValue **)\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n@@ -4120,3 +28765,2 @@\n-    public static MemorySegment CreateValue(MemorySegment struct, MemorySegment _x0, long _x1, int _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(CreateValue$LAYOUT, CreateValue$OFFSET);\n-        return CreateValue.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout CreateLoraAdapter$layout() {\n+        return CreateLoraAdapter$LAYOUT;\n@@ -4125,0 +28769,2 @@\n+    private static final long CreateLoraAdapter$OFFSET = 2240;\n+\n@@ -4126,0 +28772,1 @@\n+     * Offset for field:\n@@ -4127,1 +28774,1 @@\n-     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n@@ -4130,23 +28777,2 @@\n-    private static class CreateOpaqueValue {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateLoraAdapter$offset() {\n+        return CreateLoraAdapter$OFFSET;\n@@ -4155,3 +28781,9 @@\n-    private static final AddressLayout CreateOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOpaqueValue\"));\n-\n-    private static final long CreateOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateOpaqueValue\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateLoraAdapter(MemorySegment struct) {\n+        return struct.get(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET);\n+    }\n@@ -4160,1 +28792,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4162,1 +28794,1 @@\n-     * OrtStatusPtr (*CreateOpaqueValue)(const char *, const char *, const void *, size_t, OrtValue **)\n+     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n@@ -4165,3 +28797,2 @@\n-    public static MemorySegment CreateOpaqueValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateOpaqueValue$LAYOUT, CreateOpaqueValue$OFFSET);\n-        return CreateOpaqueValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static void CreateLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET, fieldValue);\n@@ -4172,1 +28803,1 @@\n-     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n@@ -4175,1 +28806,12 @@\n-    private static class GetOpaqueValue {\n+    public static class CreateLoraAdapterFromArray {\n+\n+        CreateLoraAdapterFromArray() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n@@ -4178,6 +28820,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -4186,0 +28827,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateLoraAdapterFromArray.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateLoraAdapterFromArray.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4191,1 +28849,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n@@ -4193,1 +28851,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -4200,3 +28858,1 @@\n-    private static final AddressLayout GetOpaqueValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOpaqueValue\"));\n-\n-    private static final long GetOpaqueValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetOpaqueValue\"));\n+    private static final AddressLayout CreateLoraAdapterFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateLoraAdapterFromArray\"));\n@@ -4205,1 +28861,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4207,1 +28863,1 @@\n-     * OrtStatusPtr (*GetOpaqueValue)(const char *, const char *, const OrtValue *, void *, size_t)\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n@@ -4210,3 +28866,2 @@\n-    public static MemorySegment GetOpaqueValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n-        var funcPtr = struct.get(GetOpaqueValue$LAYOUT, GetOpaqueValue$OFFSET);\n-        return GetOpaqueValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout CreateLoraAdapterFromArray$layout() {\n+        return CreateLoraAdapterFromArray$LAYOUT;\n@@ -4215,0 +28870,2 @@\n+    private static final long CreateLoraAdapterFromArray$OFFSET = 2248;\n+\n@@ -4216,0 +28873,1 @@\n+     * Offset for field:\n@@ -4217,1 +28875,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n@@ -4220,10 +28878,3 @@\n-    private static class KernelInfoGetAttribute_float {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+    public static final long CreateLoraAdapterFromArray$offset() {\n+        return CreateLoraAdapterFromArray$OFFSET;\n+    }\n@@ -4231,10 +28882,8 @@\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateLoraAdapterFromArray(MemorySegment struct) {\n+        return struct.get(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET);\n@@ -4243,4 +28892,0 @@\n-    private static final AddressLayout KernelInfoGetAttribute_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_float\"));\n-\n-    private static final long KernelInfoGetAttribute_float$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_float\"));\n-\n@@ -4248,1 +28893,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4250,1 +28895,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_float)(const OrtKernelInfo *, const char *, float *)\n+     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n@@ -4253,3 +28898,2 @@\n-    public static MemorySegment KernelInfoGetAttribute_float(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelInfoGetAttribute_float$LAYOUT, KernelInfoGetAttribute_float$OFFSET);\n-        return KernelInfoGetAttribute_float.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void CreateLoraAdapterFromArray(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET, fieldValue);\n@@ -4260,1 +28904,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n@@ -4263,1 +28907,1 @@\n-    private static class KernelInfoGetAttribute_int64 {\n+    public static class ReleaseLoraAdapter {\n@@ -4265,5 +28909,13 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+        ReleaseLoraAdapter() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n@@ -4272,0 +28924,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseLoraAdapter.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseLoraAdapter.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4277,1 +28946,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -4279,1 +28948,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -4286,3 +28955,1 @@\n-    private static final AddressLayout KernelInfoGetAttribute_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_int64\"));\n-\n-    private static final long KernelInfoGetAttribute_int64$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_int64\"));\n+    private static final AddressLayout ReleaseLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseLoraAdapter\"));\n@@ -4291,1 +28958,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4293,1 +28960,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_int64)(const OrtKernelInfo *, const char *, int64_t *)\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n@@ -4296,3 +28963,2 @@\n-    public static MemorySegment KernelInfoGetAttribute_int64(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelInfoGetAttribute_int64$LAYOUT, KernelInfoGetAttribute_int64$OFFSET);\n-        return KernelInfoGetAttribute_int64.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout ReleaseLoraAdapter$layout() {\n+        return ReleaseLoraAdapter$LAYOUT;\n@@ -4301,0 +28967,2 @@\n+    private static final long ReleaseLoraAdapter$OFFSET = 2256;\n+\n@@ -4302,0 +28970,1 @@\n+     * Offset for field:\n@@ -4303,1 +28972,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n@@ -4306,22 +28975,2 @@\n-    private static class KernelInfoGetAttribute_string {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseLoraAdapter$offset() {\n+        return ReleaseLoraAdapter$OFFSET;\n@@ -4330,3 +28979,9 @@\n-    private static final AddressLayout KernelInfoGetAttribute_string$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_string\"));\n-\n-    private static final long KernelInfoGetAttribute_string$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_string\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseLoraAdapter(MemorySegment struct) {\n+        return struct.get(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET);\n+    }\n@@ -4335,1 +28990,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4337,1 +28992,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_string)(const OrtKernelInfo *, const char *, char *, size_t *)\n+     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n@@ -4340,3 +28995,2 @@\n-    public static MemorySegment KernelInfoGetAttribute_string(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfoGetAttribute_string$LAYOUT, KernelInfoGetAttribute_string$OFFSET);\n-        return KernelInfoGetAttribute_string.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void ReleaseLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET, fieldValue);\n@@ -4347,1 +29001,1 @@\n-     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n@@ -4350,1 +29004,12 @@\n-    private static class KernelContext_GetInputCount {\n+    public static class RunOptionsAddActiveLoraAdapter {\n+\n+        RunOptionsAddActiveLoraAdapter() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -4353,3 +29018,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -4358,0 +29023,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RunOptionsAddActiveLoraAdapter.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RunOptionsAddActiveLoraAdapter.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4372,3 +29054,1 @@\n-    private static final AddressLayout KernelContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetInputCount\"));\n-\n-    private static final long KernelContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetInputCount\"));\n+    private static final AddressLayout RunOptionsAddActiveLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsAddActiveLoraAdapter\"));\n@@ -4377,1 +29057,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4379,1 +29059,1 @@\n-     * OrtStatusPtr (*KernelContext_GetInputCount)(const OrtKernelContext *, size_t *)\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n@@ -4382,3 +29062,2 @@\n-    public static MemorySegment KernelContext_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelContext_GetInputCount$LAYOUT, KernelContext_GetInputCount$OFFSET);\n-        return KernelContext_GetInputCount.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout RunOptionsAddActiveLoraAdapter$layout() {\n+        return RunOptionsAddActiveLoraAdapter$LAYOUT;\n@@ -4387,0 +29066,2 @@\n+    private static final long RunOptionsAddActiveLoraAdapter$OFFSET = 2264;\n+\n@@ -4388,0 +29069,1 @@\n+     * Offset for field:\n@@ -4389,1 +29071,1 @@\n-     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n@@ -4392,20 +29074,2 @@\n-    private static class KernelContext_GetOutputCount {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long RunOptionsAddActiveLoraAdapter$offset() {\n+        return RunOptionsAddActiveLoraAdapter$OFFSET;\n@@ -4414,3 +29078,9 @@\n-    private static final AddressLayout KernelContext_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetOutputCount\"));\n-\n-    private static final long KernelContext_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetOutputCount\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n+     * }\n+     *\/\n+    public static MemorySegment RunOptionsAddActiveLoraAdapter(MemorySegment struct) {\n+        return struct.get(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET);\n+    }\n@@ -4419,1 +29089,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4421,1 +29091,1 @@\n-     * OrtStatusPtr (*KernelContext_GetOutputCount)(const OrtKernelContext *, size_t *)\n+     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n@@ -4424,3 +29094,2 @@\n-    public static MemorySegment KernelContext_GetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelContext_GetOutputCount$LAYOUT, KernelContext_GetOutputCount$OFFSET);\n-        return KernelContext_GetOutputCount.invoke(funcPtr, _x0, _x1);\n+    public static void RunOptionsAddActiveLoraAdapter(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET, fieldValue);\n@@ -4431,1 +29100,1 @@\n-     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n@@ -4434,1 +29103,12 @@\n-    private static class KernelContext_GetInput {\n+    public static class SetEpDynamicOptions {\n+\n+        SetEpDynamicOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n@@ -4437,4 +29117,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -4443,0 +29124,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SetEpDynamicOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetEpDynamicOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4448,1 +29146,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n@@ -4450,1 +29148,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -4457,3 +29155,1 @@\n-    private static final AddressLayout KernelContext_GetInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetInput\"));\n-\n-    private static final long KernelContext_GetInput$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetInput\"));\n+    private static final AddressLayout SetEpDynamicOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetEpDynamicOptions\"));\n@@ -4462,1 +29158,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4464,1 +29160,1 @@\n-     * OrtStatusPtr (*KernelContext_GetInput)(const OrtKernelContext *, size_t, const OrtValue **)\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n@@ -4467,3 +29163,2 @@\n-    public static MemorySegment KernelContext_GetInput(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelContext_GetInput$LAYOUT, KernelContext_GetInput$OFFSET);\n-        return KernelContext_GetInput.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout SetEpDynamicOptions$layout() {\n+        return SetEpDynamicOptions$LAYOUT;\n@@ -4472,0 +29167,2 @@\n+    private static final long SetEpDynamicOptions$OFFSET = 2272;\n+\n@@ -4473,0 +29170,1 @@\n+     * Offset for field:\n@@ -4474,1 +29172,1 @@\n-     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n@@ -4477,23 +29175,2 @@\n-    private static class KernelContext_GetOutput {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SetEpDynamicOptions$offset() {\n+        return SetEpDynamicOptions$OFFSET;\n@@ -4502,3 +29179,9 @@\n-    private static final AddressLayout KernelContext_GetOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetOutput\"));\n-\n-    private static final long KernelContext_GetOutput$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetOutput\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetEpDynamicOptions(MemorySegment struct) {\n+        return struct.get(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET);\n+    }\n@@ -4507,1 +29190,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4509,1 +29192,1 @@\n-     * OrtStatusPtr (*KernelContext_GetOutput)(OrtKernelContext *, size_t, const int64_t *, size_t, OrtValue **)\n+     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n@@ -4512,3 +29195,2 @@\n-    public static MemorySegment KernelContext_GetOutput(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(KernelContext_GetOutput$LAYOUT, KernelContext_GetOutput$OFFSET);\n-        return KernelContext_GetOutput.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static void SetEpDynamicOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET, fieldValue);\n@@ -4519,1 +29201,1 @@\n-     * void (*ReleaseEnv)(OrtEnv *)\n+     * void (*ReleaseValueInfo)(OrtValueInfo *)\n@@ -4522,1 +29204,12 @@\n-    private static class ReleaseEnv {\n+    public static class ReleaseValueInfo {\n+\n+        ReleaseValueInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n@@ -4525,1 +29218,1 @@\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER\n@@ -4528,0 +29221,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseValueInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseValueInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4542,1 +29252,11 @@\n-    private static final AddressLayout ReleaseEnv$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseEnv\"));\n+    private static final AddressLayout ReleaseValueInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseValueInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValueInfo)(OrtValueInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseValueInfo$layout() {\n+        return ReleaseValueInfo$LAYOUT;\n+    }\n@@ -4544,1 +29264,1 @@\n-    private static final long ReleaseEnv$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseEnv\"));\n+    private static final long ReleaseValueInfo$OFFSET = 2280;\n@@ -4547,1 +29267,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -4549,1 +29269,1 @@\n-     * void (*ReleaseEnv)(OrtEnv *)\n+     * void (*ReleaseValueInfo)(OrtValueInfo *)\n@@ -4552,3 +29272,2 @@\n-    public static void ReleaseEnv(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseEnv$LAYOUT, ReleaseEnv$OFFSET);\n-        ReleaseEnv.invoke(funcPtr, _x0);\n+    public static final long ReleaseValueInfo$offset() {\n+        return ReleaseValueInfo$OFFSET;\n@@ -4558,0 +29277,1 @@\n+     * Getter for field:\n@@ -4559,1 +29279,11 @@\n-     * void (*ReleaseStatus)(OrtStatus *)\n+     * void (*ReleaseValueInfo)(OrtValueInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseValueInfo(MemorySegment struct) {\n+        return struct.get(ReleaseValueInfo$LAYOUT, ReleaseValueInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseValueInfo)(OrtValueInfo *)\n@@ -4562,1 +29292,21 @@\n-    private static class ReleaseStatus {\n+    public static void ReleaseValueInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseValueInfo$LAYOUT, ReleaseValueInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseNode)(OrtNode *)\n+     * }\n+     *\/\n+    public static class ReleaseNode {\n+\n+        ReleaseNode() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n@@ -4565,1 +29315,1 @@\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER\n@@ -4568,0 +29318,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseNode.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseNode.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4582,1 +29349,11 @@\n-    private static final AddressLayout ReleaseStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseStatus\"));\n+    private static final AddressLayout ReleaseNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseNode\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseNode)(OrtNode *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseNode$layout() {\n+        return ReleaseNode$LAYOUT;\n+    }\n@@ -4584,1 +29361,1 @@\n-    private static final long ReleaseStatus$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseStatus\"));\n+    private static final long ReleaseNode$OFFSET = 2288;\n@@ -4587,1 +29364,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -4589,1 +29366,1 @@\n-     * void (*ReleaseStatus)(OrtStatus *)\n+     * void (*ReleaseNode)(OrtNode *)\n@@ -4592,3 +29369,2 @@\n-    public static void ReleaseStatus(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseStatus$LAYOUT, ReleaseStatus$OFFSET);\n-        ReleaseStatus.invoke(funcPtr, _x0);\n+    public static final long ReleaseNode$offset() {\n+        return ReleaseNode$OFFSET;\n@@ -4598,0 +29374,1 @@\n+     * Getter for field:\n@@ -4599,1 +29376,20 @@\n-     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * void (*ReleaseNode)(OrtNode *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseNode(MemorySegment struct) {\n+        return struct.get(ReleaseNode$LAYOUT, ReleaseNode$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseNode)(OrtNode *)\n+     * }\n+     *\/\n+    public static void ReleaseNode(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseNode$LAYOUT, ReleaseNode$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseGraph)(OrtGraph *)\n@@ -4602,1 +29398,12 @@\n-    private static class ReleaseMemoryInfo {\n+    public static class ReleaseGraph {\n+\n+        ReleaseGraph() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n@@ -4605,1 +29412,1 @@\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER\n@@ -4608,0 +29415,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseGraph.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseGraph.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4622,3 +29446,1 @@\n-    private static final AddressLayout ReleaseMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMemoryInfo\"));\n-\n-    private static final long ReleaseMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseMemoryInfo\"));\n+    private static final AddressLayout ReleaseGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseGraph\"));\n@@ -4627,1 +29449,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4629,1 +29451,1 @@\n-     * void (*ReleaseMemoryInfo)(OrtMemoryInfo *)\n+     * void (*ReleaseGraph)(OrtGraph *)\n@@ -4632,3 +29454,2 @@\n-    public static void ReleaseMemoryInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseMemoryInfo$LAYOUT, ReleaseMemoryInfo$OFFSET);\n-        ReleaseMemoryInfo.invoke(funcPtr, _x0);\n+    public static final AddressLayout ReleaseGraph$layout() {\n+        return ReleaseGraph$LAYOUT;\n@@ -4637,0 +29458,2 @@\n+    private static final long ReleaseGraph$OFFSET = 2296;\n+\n@@ -4638,0 +29461,1 @@\n+     * Offset for field:\n@@ -4639,1 +29463,1 @@\n-     * void (*ReleaseSession)(OrtSession *)\n+     * void (*ReleaseGraph)(OrtGraph *)\n@@ -4642,18 +29466,2 @@\n-    private static class ReleaseSession {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseGraph$offset() {\n+        return ReleaseGraph$OFFSET;\n@@ -4662,3 +29470,9 @@\n-    private static final AddressLayout ReleaseSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSession\"));\n-\n-    private static final long ReleaseSession$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseSession\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseGraph)(OrtGraph *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseGraph(MemorySegment struct) {\n+        return struct.get(ReleaseGraph$LAYOUT, ReleaseGraph$OFFSET);\n+    }\n@@ -4667,1 +29481,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4669,1 +29483,1 @@\n-     * void (*ReleaseSession)(OrtSession *)\n+     * void (*ReleaseGraph)(OrtGraph *)\n@@ -4672,3 +29486,2 @@\n-    public static void ReleaseSession(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseSession$LAYOUT, ReleaseSession$OFFSET);\n-        ReleaseSession.invoke(funcPtr, _x0);\n+    public static void ReleaseGraph(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseGraph$LAYOUT, ReleaseGraph$OFFSET, fieldValue);\n@@ -4679,1 +29492,1 @@\n-     * void (*ReleaseValue)(OrtValue *)\n+     * void (*ReleaseModel)(OrtModel *)\n@@ -4682,1 +29495,12 @@\n-    private static class ReleaseValue {\n+    public static class ReleaseModel {\n+\n+        ReleaseModel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n@@ -4685,1 +29509,1 @@\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER\n@@ -4688,0 +29512,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseModel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseModel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4702,3 +29543,1 @@\n-    private static final AddressLayout ReleaseValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseValue\"));\n-\n-    private static final long ReleaseValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseValue\"));\n+    private static final AddressLayout ReleaseModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseModel\"));\n@@ -4707,1 +29546,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4709,1 +29548,1 @@\n-     * void (*ReleaseValue)(OrtValue *)\n+     * void (*ReleaseModel)(OrtModel *)\n@@ -4712,3 +29551,2 @@\n-    public static void ReleaseValue(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseValue$LAYOUT, ReleaseValue$OFFSET);\n-        ReleaseValue.invoke(funcPtr, _x0);\n+    public static final AddressLayout ReleaseModel$layout() {\n+        return ReleaseModel$LAYOUT;\n@@ -4717,0 +29555,2 @@\n+    private static final long ReleaseModel$OFFSET = 2304;\n+\n@@ -4718,0 +29558,1 @@\n+     * Offset for field:\n@@ -4719,1 +29560,1 @@\n-     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * void (*ReleaseModel)(OrtModel *)\n@@ -4722,18 +29563,2 @@\n-    private static class ReleaseRunOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseModel$offset() {\n+        return ReleaseModel$OFFSET;\n@@ -4742,3 +29567,9 @@\n-    private static final AddressLayout ReleaseRunOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseRunOptions\"));\n-\n-    private static final long ReleaseRunOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseRunOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModel)(OrtModel *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseModel(MemorySegment struct) {\n+        return struct.get(ReleaseModel$LAYOUT, ReleaseModel$OFFSET);\n+    }\n@@ -4747,1 +29578,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4749,1 +29580,1 @@\n-     * void (*ReleaseRunOptions)(OrtRunOptions *)\n+     * void (*ReleaseModel)(OrtModel *)\n@@ -4752,3 +29583,2 @@\n-    public static void ReleaseRunOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseRunOptions$LAYOUT, ReleaseRunOptions$OFFSET);\n-        ReleaseRunOptions.invoke(funcPtr, _x0);\n+    public static void ReleaseModel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseModel$LAYOUT, ReleaseModel$OFFSET, fieldValue);\n@@ -4759,1 +29589,1 @@\n-     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)\n@@ -4762,1 +29592,1 @@\n-    private static class ReleaseTypeInfo {\n+    public static class GetValueInfoName {\n@@ -4764,2 +29594,15 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n+        GetValueInfoName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -4768,0 +29611,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetValueInfoName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetValueInfoName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4773,1 +29633,1 @@\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -4775,1 +29635,1 @@\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -4782,3 +29642,1 @@\n-    private static final AddressLayout ReleaseTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTypeInfo\"));\n-\n-    private static final long ReleaseTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseTypeInfo\"));\n+    private static final AddressLayout GetValueInfoName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueInfoName\"));\n@@ -4787,1 +29645,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4789,1 +29647,1 @@\n-     * void (*ReleaseTypeInfo)(OrtTypeInfo *)\n+     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)\n@@ -4792,3 +29650,2 @@\n-    public static void ReleaseTypeInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseTypeInfo$LAYOUT, ReleaseTypeInfo$OFFSET);\n-        ReleaseTypeInfo.invoke(funcPtr, _x0);\n+    public static final AddressLayout GetValueInfoName$layout() {\n+        return GetValueInfoName$LAYOUT;\n@@ -4797,0 +29654,2 @@\n+    private static final long GetValueInfoName$OFFSET = 2312;\n+\n@@ -4798,0 +29657,1 @@\n+     * Offset for field:\n@@ -4799,1 +29659,1 @@\n-     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)\n@@ -4802,18 +29662,2 @@\n-    private static class ReleaseTensorTypeAndShapeInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetValueInfoName$offset() {\n+        return GetValueInfoName$OFFSET;\n@@ -4822,3 +29666,9 @@\n-    private static final AddressLayout ReleaseTensorTypeAndShapeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTensorTypeAndShapeInfo\"));\n-\n-    private static final long ReleaseTensorTypeAndShapeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseTensorTypeAndShapeInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment GetValueInfoName(MemorySegment struct) {\n+        return struct.get(GetValueInfoName$LAYOUT, GetValueInfoName$OFFSET);\n+    }\n@@ -4827,1 +29677,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4829,1 +29679,1 @@\n-     * void (*ReleaseTensorTypeAndShapeInfo)(OrtTensorTypeAndShapeInfo *)\n+     * OrtStatusPtr (*GetValueInfoName)(const OrtValueInfo *, const char **)\n@@ -4832,3 +29682,2 @@\n-    public static void ReleaseTensorTypeAndShapeInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseTensorTypeAndShapeInfo$LAYOUT, ReleaseTensorTypeAndShapeInfo$OFFSET);\n-        ReleaseTensorTypeAndShapeInfo.invoke(funcPtr, _x0);\n+    public static void GetValueInfoName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetValueInfoName$LAYOUT, GetValueInfoName$OFFSET, fieldValue);\n@@ -4839,1 +29688,1 @@\n-     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)\n@@ -4842,1 +29691,1 @@\n-    private static class ReleaseSessionOptions {\n+    public static class GetValueInfoTypeInfo {\n@@ -4844,2 +29693,15 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n+        GetValueInfoTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -4848,0 +29710,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetValueInfoTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetValueInfoTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4853,1 +29732,1 @@\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -4855,1 +29734,1 @@\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -4862,3 +29741,1 @@\n-    private static final AddressLayout ReleaseSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSessionOptions\"));\n-\n-    private static final long ReleaseSessionOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseSessionOptions\"));\n+    private static final AddressLayout GetValueInfoTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetValueInfoTypeInfo\"));\n@@ -4867,1 +29744,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -4869,1 +29746,1 @@\n-     * void (*ReleaseSessionOptions)(OrtSessionOptions *)\n+     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)\n@@ -4872,3 +29749,2 @@\n-    public static void ReleaseSessionOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseSessionOptions$LAYOUT, ReleaseSessionOptions$OFFSET);\n-        ReleaseSessionOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout GetValueInfoTypeInfo$layout() {\n+        return GetValueInfoTypeInfo$LAYOUT;\n@@ -4877,0 +29753,2 @@\n+    private static final long GetValueInfoTypeInfo$OFFSET = 2320;\n+\n@@ -4878,0 +29756,1 @@\n+     * Offset for field:\n@@ -4879,1 +29758,1 @@\n-     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)\n@@ -4882,18 +29761,2 @@\n-    private static class ReleaseCustomOpDomain {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetValueInfoTypeInfo$offset() {\n+        return GetValueInfoTypeInfo$OFFSET;\n@@ -4902,3 +29765,9 @@\n-    private static final AddressLayout ReleaseCustomOpDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCustomOpDomain\"));\n-\n-    private static final long ReleaseCustomOpDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseCustomOpDomain\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment GetValueInfoTypeInfo(MemorySegment struct) {\n+        return struct.get(GetValueInfoTypeInfo$LAYOUT, GetValueInfoTypeInfo$OFFSET);\n+    }\n@@ -4907,1 +29776,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4909,1 +29778,1 @@\n-     * void (*ReleaseCustomOpDomain)(OrtCustomOpDomain *)\n+     * OrtStatusPtr (*GetValueInfoTypeInfo)(const OrtValueInfo *, const OrtTypeInfo **)\n@@ -4912,3 +29781,2 @@\n-    public static void ReleaseCustomOpDomain(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseCustomOpDomain$LAYOUT, ReleaseCustomOpDomain$OFFSET);\n-        ReleaseCustomOpDomain.invoke(funcPtr, _x0);\n+    public static void GetValueInfoTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetValueInfoTypeInfo$LAYOUT, GetValueInfoTypeInfo$OFFSET, fieldValue);\n@@ -4919,1 +29787,1 @@\n-     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * const OrtModelEditorApi *(*GetModelEditorApi)(void)\n@@ -4922,1 +29790,12 @@\n-    private static class GetDenotationFromTypeInfo {\n+    public static class GetModelEditorApi {\n+\n+        GetModelEditorApi() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply();\n+        }\n@@ -4925,5 +29804,18 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+            coreml_provider_factory_h.C_POINTER);\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetModelEditorApi.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetModelEditorApi.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -4936,1 +29828,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr) {\n@@ -4938,1 +29830,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n@@ -4945,1 +29837,11 @@\n-    private static final AddressLayout GetDenotationFromTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDenotationFromTypeInfo\"));\n+    private static final AddressLayout GetModelEditorApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetModelEditorApi\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const OrtModelEditorApi *(*GetModelEditorApi)(void)\n+     * }\n+     *\/\n+    public static final AddressLayout GetModelEditorApi$layout() {\n+        return GetModelEditorApi$LAYOUT;\n+    }\n@@ -4947,1 +29849,1 @@\n-    private static final long GetDenotationFromTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDenotationFromTypeInfo\"));\n+    private static final long GetModelEditorApi$OFFSET = 2328;\n@@ -4950,1 +29852,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -4952,1 +29854,1 @@\n-     * OrtStatusPtr (*GetDenotationFromTypeInfo)(const OrtTypeInfo *, const char **const, size_t *)\n+     * const OrtModelEditorApi *(*GetModelEditorApi)(void)\n@@ -4955,3 +29857,2 @@\n-    public static MemorySegment GetDenotationFromTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetDenotationFromTypeInfo$LAYOUT, GetDenotationFromTypeInfo$OFFSET);\n-        return GetDenotationFromTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final long GetModelEditorApi$offset() {\n+        return GetModelEditorApi$OFFSET;\n@@ -4961,0 +29862,1 @@\n+     * Getter for field:\n@@ -4962,1 +29864,20 @@\n-     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * const OrtModelEditorApi *(*GetModelEditorApi)(void)\n+     * }\n+     *\/\n+    public static MemorySegment GetModelEditorApi(MemorySegment struct) {\n+        return struct.get(GetModelEditorApi$LAYOUT, GetModelEditorApi$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const OrtModelEditorApi *(*GetModelEditorApi)(void)\n+     * }\n+     *\/\n+    public static void GetModelEditorApi(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetModelEditorApi$LAYOUT, GetModelEditorApi$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n@@ -4965,1 +29886,12 @@\n-    private static class CastTypeInfoToMapTypeInfo {\n+    public static class CreateTensorWithDataAndDeleterAsOrtValue {\n+\n+        CreateTensorWithDataAndDeleterAsOrtValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6);\n+        }\n@@ -4968,3 +29900,8 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -4973,0 +29910,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateTensorWithDataAndDeleterAsOrtValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateTensorWithDataAndDeleterAsOrtValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -4978,1 +29932,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4, int _x5, MemorySegment _x6) {\n@@ -4980,1 +29934,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n@@ -4987,1 +29941,23 @@\n-    private static final AddressLayout CastTypeInfoToMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToMapTypeInfo\"));\n+    private static final AddressLayout CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorWithDataAndDeleterAsOrtValue\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateTensorWithDataAndDeleterAsOrtValue$layout() {\n+        return CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT;\n+    }\n+\n+    private static final long CreateTensorWithDataAndDeleterAsOrtValue$OFFSET = 2336;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static final long CreateTensorWithDataAndDeleterAsOrtValue$offset() {\n+        return CreateTensorWithDataAndDeleterAsOrtValue$OFFSET;\n+    }\n@@ -4989,1 +29965,9 @@\n-    private static final long CastTypeInfoToMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToMapTypeInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorWithDataAndDeleterAsOrtValue(MemorySegment struct) {\n+        return struct.get(CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT, CreateTensorWithDataAndDeleterAsOrtValue$OFFSET);\n+    }\n@@ -4992,1 +29976,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -4994,1 +29978,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToMapTypeInfo)(const OrtTypeInfo *, const OrtMapTypeInfo **)\n+     * OrtStatusPtr (*CreateTensorWithDataAndDeleterAsOrtValue)(OrtAllocator *, void *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n@@ -4997,3 +29981,2 @@\n-    public static MemorySegment CastTypeInfoToMapTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CastTypeInfoToMapTypeInfo$LAYOUT, CastTypeInfoToMapTypeInfo$OFFSET);\n-        return CastTypeInfoToMapTypeInfo.invoke(funcPtr, _x0, _x1);\n+    public static void CreateTensorWithDataAndDeleterAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateTensorWithDataAndDeleterAsOrtValue$LAYOUT, CreateTensorWithDataAndDeleterAsOrtValue$OFFSET, fieldValue);\n@@ -5004,1 +29987,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)\n@@ -5007,1 +29990,12 @@\n-    private static class CastTypeInfoToSequenceTypeInfo {\n+    public static class SessionOptionsSetLoadCancellationFlag {\n+\n+        SessionOptionsSetLoadCancellationFlag() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, boolean _x1);\n+        }\n@@ -5010,3 +30004,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_BOOL\n@@ -5015,0 +30009,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsSetLoadCancellationFlag.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsSetLoadCancellationFlag.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5020,1 +30031,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {\n@@ -5029,3 +30040,1 @@\n-    private static final AddressLayout CastTypeInfoToSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToSequenceTypeInfo\"));\n-\n-    private static final long CastTypeInfoToSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToSequenceTypeInfo\"));\n+    private static final AddressLayout SessionOptionsSetLoadCancellationFlag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetLoadCancellationFlag\"));\n@@ -5034,1 +30043,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5036,1 +30045,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToSequenceTypeInfo)(const OrtTypeInfo *, const OrtSequenceTypeInfo **)\n+     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)\n@@ -5039,3 +30048,2 @@\n-    public static MemorySegment CastTypeInfoToSequenceTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CastTypeInfoToSequenceTypeInfo$LAYOUT, CastTypeInfoToSequenceTypeInfo$OFFSET);\n-        return CastTypeInfoToSequenceTypeInfo.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SessionOptionsSetLoadCancellationFlag$layout() {\n+        return SessionOptionsSetLoadCancellationFlag$LAYOUT;\n@@ -5044,0 +30052,2 @@\n+    private static final long SessionOptionsSetLoadCancellationFlag$OFFSET = 2344;\n+\n@@ -5045,0 +30055,1 @@\n+     * Offset for field:\n@@ -5046,1 +30057,1 @@\n-     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)\n@@ -5049,20 +30060,2 @@\n-    private static class GetMapKeyType {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionOptionsSetLoadCancellationFlag$offset() {\n+        return SessionOptionsSetLoadCancellationFlag$OFFSET;\n@@ -5071,3 +30064,9 @@\n-    private static final AddressLayout GetMapKeyType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMapKeyType\"));\n-\n-    private static final long GetMapKeyType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetMapKeyType\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetLoadCancellationFlag(MemorySegment struct) {\n+        return struct.get(SessionOptionsSetLoadCancellationFlag$LAYOUT, SessionOptionsSetLoadCancellationFlag$OFFSET);\n+    }\n@@ -5076,1 +30075,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5078,1 +30077,1 @@\n-     * OrtStatusPtr (*GetMapKeyType)(const OrtMapTypeInfo *, enum ONNXTensorElementDataType *)\n+     * OrtStatusPtr (*SessionOptionsSetLoadCancellationFlag)(OrtSessionOptions *, bool)\n@@ -5081,3 +30080,2 @@\n-    public static MemorySegment GetMapKeyType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetMapKeyType$LAYOUT, GetMapKeyType$OFFSET);\n-        return GetMapKeyType.invoke(funcPtr, _x0, _x1);\n+    public static void SessionOptionsSetLoadCancellationFlag(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsSetLoadCancellationFlag$LAYOUT, SessionOptionsSetLoadCancellationFlag$OFFSET, fieldValue);\n@@ -5088,1 +30086,1 @@\n-     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * const OrtCompileApi *(*GetCompileApi)(void)\n@@ -5091,1 +30089,12 @@\n-    private static class GetMapValueType {\n+    public static class GetCompileApi {\n+\n+        GetCompileApi() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply();\n+        }\n@@ -5094,4 +30103,18 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+            coreml_provider_factory_h.C_POINTER);\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetCompileApi.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetCompileApi.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -5104,1 +30127,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr) {\n@@ -5106,1 +30129,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n@@ -5113,3 +30136,1 @@\n-    private static final AddressLayout GetMapValueType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMapValueType\"));\n-\n-    private static final long GetMapValueType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetMapValueType\"));\n+    private static final AddressLayout GetCompileApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCompileApi\"));\n@@ -5118,1 +30139,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5120,1 +30141,1 @@\n-     * OrtStatusPtr (*GetMapValueType)(const OrtMapTypeInfo *, OrtTypeInfo **)\n+     * const OrtCompileApi *(*GetCompileApi)(void)\n@@ -5123,3 +30144,2 @@\n-    public static MemorySegment GetMapValueType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetMapValueType$LAYOUT, GetMapValueType$OFFSET);\n-        return GetMapValueType.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout GetCompileApi$layout() {\n+        return GetCompileApi$LAYOUT;\n@@ -5128,0 +30148,2 @@\n+    private static final long GetCompileApi$OFFSET = 2352;\n+\n@@ -5129,0 +30151,1 @@\n+     * Offset for field:\n@@ -5130,1 +30153,1 @@\n-     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * const OrtCompileApi *(*GetCompileApi)(void)\n@@ -5133,20 +30156,2 @@\n-    private static class GetSequenceElementType {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetCompileApi$offset() {\n+        return GetCompileApi$OFFSET;\n@@ -5155,3 +30160,9 @@\n-    private static final AddressLayout GetSequenceElementType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSequenceElementType\"));\n-\n-    private static final long GetSequenceElementType$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSequenceElementType\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtCompileApi *(*GetCompileApi)(void)\n+     * }\n+     *\/\n+    public static MemorySegment GetCompileApi(MemorySegment struct) {\n+        return struct.get(GetCompileApi$LAYOUT, GetCompileApi$OFFSET);\n+    }\n@@ -5160,1 +30171,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5162,1 +30173,1 @@\n-     * OrtStatusPtr (*GetSequenceElementType)(const OrtSequenceTypeInfo *, OrtTypeInfo **)\n+     * const OrtCompileApi *(*GetCompileApi)(void)\n@@ -5165,3 +30176,2 @@\n-    public static MemorySegment GetSequenceElementType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetSequenceElementType$LAYOUT, GetSequenceElementType$OFFSET);\n-        return GetSequenceElementType.invoke(funcPtr, _x0, _x1);\n+    public static void GetCompileApi(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetCompileApi$LAYOUT, GetCompileApi$OFFSET, fieldValue);\n@@ -5172,1 +30182,1 @@\n-     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)\n@@ -5175,1 +30185,12 @@\n-    private static class ReleaseMapTypeInfo {\n+    public static class CreateKeyValuePairs {\n+\n+        CreateKeyValuePairs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n@@ -5178,1 +30199,1 @@\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER\n@@ -5181,0 +30202,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateKeyValuePairs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateKeyValuePairs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5195,3 +30233,1 @@\n-    private static final AddressLayout ReleaseMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMapTypeInfo\"));\n-\n-    private static final long ReleaseMapTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseMapTypeInfo\"));\n+    private static final AddressLayout CreateKeyValuePairs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateKeyValuePairs\"));\n@@ -5200,1 +30236,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5202,1 +30238,1 @@\n-     * void (*ReleaseMapTypeInfo)(OrtMapTypeInfo *)\n+     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)\n@@ -5205,3 +30241,2 @@\n-    public static void ReleaseMapTypeInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseMapTypeInfo$LAYOUT, ReleaseMapTypeInfo$OFFSET);\n-        ReleaseMapTypeInfo.invoke(funcPtr, _x0);\n+    public static final AddressLayout CreateKeyValuePairs$layout() {\n+        return CreateKeyValuePairs$LAYOUT;\n@@ -5210,0 +30245,2 @@\n+    private static final long CreateKeyValuePairs$OFFSET = 2360;\n+\n@@ -5211,0 +30248,1 @@\n+     * Offset for field:\n@@ -5212,1 +30250,1 @@\n-     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)\n@@ -5215,18 +30253,2 @@\n-    private static class ReleaseSequenceTypeInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateKeyValuePairs$offset() {\n+        return CreateKeyValuePairs$OFFSET;\n@@ -5235,3 +30257,9 @@\n-    private static final AddressLayout ReleaseSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSequenceTypeInfo\"));\n-\n-    private static final long ReleaseSequenceTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseSequenceTypeInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateKeyValuePairs(MemorySegment struct) {\n+        return struct.get(CreateKeyValuePairs$LAYOUT, CreateKeyValuePairs$OFFSET);\n+    }\n@@ -5240,1 +30268,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5242,1 +30270,1 @@\n-     * void (*ReleaseSequenceTypeInfo)(OrtSequenceTypeInfo *)\n+     * void (*CreateKeyValuePairs)(OrtKeyValuePairs **)\n@@ -5245,3 +30273,2 @@\n-    public static void ReleaseSequenceTypeInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseSequenceTypeInfo$LAYOUT, ReleaseSequenceTypeInfo$OFFSET);\n-        ReleaseSequenceTypeInfo.invoke(funcPtr, _x0);\n+    public static void CreateKeyValuePairs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateKeyValuePairs$LAYOUT, CreateKeyValuePairs$OFFSET, fieldValue);\n@@ -5252,1 +30279,1 @@\n-     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)\n@@ -5255,1 +30282,1 @@\n-    private static class SessionEndProfiling {\n+    public static class AddKeyValuePair {\n@@ -5257,5 +30284,15 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+        AddKeyValuePair() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -5264,0 +30301,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AddKeyValuePair.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddKeyValuePair.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5269,1 +30323,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -5271,1 +30325,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -5278,3 +30332,1 @@\n-    private static final AddressLayout SessionEndProfiling$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionEndProfiling\"));\n-\n-    private static final long SessionEndProfiling$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionEndProfiling\"));\n+    private static final AddressLayout AddKeyValuePair$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddKeyValuePair\"));\n@@ -5283,1 +30335,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5285,1 +30337,1 @@\n-     * OrtStatusPtr (*SessionEndProfiling)(OrtSession *, OrtAllocator *, char **)\n+     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)\n@@ -5288,3 +30340,2 @@\n-    public static MemorySegment SessionEndProfiling(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(SessionEndProfiling$LAYOUT, SessionEndProfiling$OFFSET);\n-        return SessionEndProfiling.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout AddKeyValuePair$layout() {\n+        return AddKeyValuePair$LAYOUT;\n@@ -5293,0 +30344,2 @@\n+    private static final long AddKeyValuePair$OFFSET = 2368;\n+\n@@ -5294,0 +30347,1 @@\n+     * Offset for field:\n@@ -5295,1 +30349,1 @@\n-     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)\n@@ -5298,20 +30352,2 @@\n-    private static class SessionGetModelMetadata {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long AddKeyValuePair$offset() {\n+        return AddKeyValuePair$OFFSET;\n@@ -5320,3 +30356,9 @@\n-    private static final AddressLayout SessionGetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetModelMetadata\"));\n-\n-    private static final long SessionGetModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetModelMetadata\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment AddKeyValuePair(MemorySegment struct) {\n+        return struct.get(AddKeyValuePair$LAYOUT, AddKeyValuePair$OFFSET);\n+    }\n@@ -5325,1 +30367,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5327,1 +30369,1 @@\n-     * OrtStatusPtr (*SessionGetModelMetadata)(const OrtSession *, OrtModelMetadata **)\n+     * void (*AddKeyValuePair)(OrtKeyValuePairs *, const char *, const char *)\n@@ -5330,3 +30372,2 @@\n-    public static MemorySegment SessionGetModelMetadata(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionGetModelMetadata$LAYOUT, SessionGetModelMetadata$OFFSET);\n-        return SessionGetModelMetadata.invoke(funcPtr, _x0, _x1);\n+    public static void AddKeyValuePair(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddKeyValuePair$LAYOUT, AddKeyValuePair$OFFSET, fieldValue);\n@@ -5337,1 +30378,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)\n@@ -5340,1 +30381,12 @@\n-    private static class ModelMetadataGetProducerName {\n+    public static class GetKeyValue {\n+\n+        GetKeyValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -5343,4 +30395,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -5349,0 +30400,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetKeyValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetKeyValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5354,1 +30422,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -5356,1 +30424,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -5363,3 +30431,1 @@\n-    private static final AddressLayout ModelMetadataGetProducerName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetProducerName\"));\n-\n-    private static final long ModelMetadataGetProducerName$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetProducerName\"));\n+    private static final AddressLayout GetKeyValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetKeyValue\"));\n@@ -5368,1 +30434,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5370,1 +30436,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetProducerName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)\n@@ -5373,3 +30439,2 @@\n-    public static MemorySegment ModelMetadataGetProducerName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ModelMetadataGetProducerName$LAYOUT, ModelMetadataGetProducerName$OFFSET);\n-        return ModelMetadataGetProducerName.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout GetKeyValue$layout() {\n+        return GetKeyValue$LAYOUT;\n@@ -5378,0 +30443,2 @@\n+    private static final long GetKeyValue$OFFSET = 2376;\n+\n@@ -5379,0 +30446,1 @@\n+     * Offset for field:\n@@ -5380,1 +30448,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)\n@@ -5383,21 +30451,2 @@\n-    private static class ModelMetadataGetGraphName {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetKeyValue$offset() {\n+        return GetKeyValue$OFFSET;\n@@ -5406,3 +30455,9 @@\n-    private static final AddressLayout ModelMetadataGetGraphName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetGraphName\"));\n-\n-    private static final long ModelMetadataGetGraphName$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetGraphName\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment GetKeyValue(MemorySegment struct) {\n+        return struct.get(GetKeyValue$LAYOUT, GetKeyValue$OFFSET);\n+    }\n@@ -5411,1 +30466,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5413,1 +30468,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetGraphName)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * const char *(*GetKeyValue)(const OrtKeyValuePairs *, const char *)\n@@ -5416,3 +30471,2 @@\n-    public static MemorySegment ModelMetadataGetGraphName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ModelMetadataGetGraphName$LAYOUT, ModelMetadataGetGraphName$OFFSET);\n-        return ModelMetadataGetGraphName.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void GetKeyValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetKeyValue$LAYOUT, GetKeyValue$OFFSET, fieldValue);\n@@ -5423,1 +30477,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)\n@@ -5426,1 +30480,26 @@\n-    private static class ModelMetadataGetDomain {\n+    public static class GetKeyValuePairs {\n+\n+        GetKeyValuePairs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n@@ -5428,6 +30507,9 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetKeyValuePairs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetKeyValuePairs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -5440,1 +30522,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n@@ -5442,1 +30524,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -5449,3 +30531,1 @@\n-    private static final AddressLayout ModelMetadataGetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetDomain\"));\n-\n-    private static final long ModelMetadataGetDomain$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetDomain\"));\n+    private static final AddressLayout GetKeyValuePairs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetKeyValuePairs\"));\n@@ -5454,1 +30534,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5456,1 +30536,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetDomain)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)\n@@ -5459,3 +30539,2 @@\n-    public static MemorySegment ModelMetadataGetDomain(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ModelMetadataGetDomain$LAYOUT, ModelMetadataGetDomain$OFFSET);\n-        return ModelMetadataGetDomain.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout GetKeyValuePairs$layout() {\n+        return GetKeyValuePairs$LAYOUT;\n@@ -5464,0 +30543,2 @@\n+    private static final long GetKeyValuePairs$OFFSET = 2384;\n+\n@@ -5465,0 +30546,1 @@\n+     * Offset for field:\n@@ -5466,1 +30548,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)\n@@ -5469,21 +30551,2 @@\n-    private static class ModelMetadataGetDescription {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetKeyValuePairs$offset() {\n+        return GetKeyValuePairs$OFFSET;\n@@ -5492,3 +30555,9 @@\n-    private static final AddressLayout ModelMetadataGetDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetDescription\"));\n-\n-    private static final long ModelMetadataGetDescription$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetDescription\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetKeyValuePairs(MemorySegment struct) {\n+        return struct.get(GetKeyValuePairs$LAYOUT, GetKeyValuePairs$OFFSET);\n+    }\n@@ -5497,1 +30566,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5499,1 +30568,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * void (*GetKeyValuePairs)(const OrtKeyValuePairs *, const char *const **, const char *const **, size_t *)\n@@ -5502,3 +30571,2 @@\n-    public static MemorySegment ModelMetadataGetDescription(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ModelMetadataGetDescription$LAYOUT, ModelMetadataGetDescription$OFFSET);\n-        return ModelMetadataGetDescription.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void GetKeyValuePairs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetKeyValuePairs$LAYOUT, GetKeyValuePairs$OFFSET, fieldValue);\n@@ -5509,1 +30577,1 @@\n-     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)\n@@ -5512,1 +30580,1 @@\n-    private static class ModelMetadataLookupCustomMetadataMap {\n+    public static class RemoveKeyValuePair {\n@@ -5514,6 +30582,14 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+        RemoveKeyValuePair() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -5522,0 +30598,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RemoveKeyValuePair.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RemoveKeyValuePair.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5527,1 +30620,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -5529,1 +30622,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -5536,3 +30629,1 @@\n-    private static final AddressLayout ModelMetadataLookupCustomMetadataMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataLookupCustomMetadataMap\"));\n-\n-    private static final long ModelMetadataLookupCustomMetadataMap$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataLookupCustomMetadataMap\"));\n+    private static final AddressLayout RemoveKeyValuePair$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RemoveKeyValuePair\"));\n@@ -5541,1 +30632,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5543,1 +30634,1 @@\n-     * OrtStatusPtr (*ModelMetadataLookupCustomMetadataMap)(const OrtModelMetadata *, OrtAllocator *, const char *, char **)\n+     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)\n@@ -5546,3 +30637,2 @@\n-    public static MemorySegment ModelMetadataLookupCustomMetadataMap(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(ModelMetadataLookupCustomMetadataMap$LAYOUT, ModelMetadataLookupCustomMetadataMap$OFFSET);\n-        return ModelMetadataLookupCustomMetadataMap.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout RemoveKeyValuePair$layout() {\n+        return RemoveKeyValuePair$LAYOUT;\n@@ -5551,0 +30641,2 @@\n+    private static final long RemoveKeyValuePair$OFFSET = 2392;\n+\n@@ -5552,0 +30644,1 @@\n+     * Offset for field:\n@@ -5553,1 +30646,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)\n@@ -5556,20 +30649,2 @@\n-    private static class ModelMetadataGetVersion {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long RemoveKeyValuePair$offset() {\n+        return RemoveKeyValuePair$OFFSET;\n@@ -5578,3 +30653,9 @@\n-    private static final AddressLayout ModelMetadataGetVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetVersion\"));\n-\n-    private static final long ModelMetadataGetVersion$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetVersion\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RemoveKeyValuePair(MemorySegment struct) {\n+        return struct.get(RemoveKeyValuePair$LAYOUT, RemoveKeyValuePair$OFFSET);\n+    }\n@@ -5583,1 +30664,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5585,1 +30666,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetVersion)(const OrtModelMetadata *, int64_t *)\n+     * void (*RemoveKeyValuePair)(OrtKeyValuePairs *, const char *)\n@@ -5588,3 +30669,2 @@\n-    public static MemorySegment ModelMetadataGetVersion(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(ModelMetadataGetVersion$LAYOUT, ModelMetadataGetVersion$OFFSET);\n-        return ModelMetadataGetVersion.invoke(funcPtr, _x0, _x1);\n+    public static void RemoveKeyValuePair(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RemoveKeyValuePair$LAYOUT, RemoveKeyValuePair$OFFSET, fieldValue);\n@@ -5595,1 +30675,1 @@\n-     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)\n@@ -5598,1 +30678,12 @@\n-    private static class ReleaseModelMetadata {\n+    public static class ReleaseKeyValuePairs {\n+\n+        ReleaseKeyValuePairs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n@@ -5601,1 +30692,1 @@\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER\n@@ -5604,0 +30695,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseKeyValuePairs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseKeyValuePairs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5618,3 +30726,1 @@\n-    private static final AddressLayout ReleaseModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseModelMetadata\"));\n-\n-    private static final long ReleaseModelMetadata$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseModelMetadata\"));\n+    private static final AddressLayout ReleaseKeyValuePairs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseKeyValuePairs\"));\n@@ -5623,1 +30729,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5625,1 +30731,1 @@\n-     * void (*ReleaseModelMetadata)(OrtModelMetadata *)\n+     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)\n@@ -5628,3 +30734,2 @@\n-    public static void ReleaseModelMetadata(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseModelMetadata$LAYOUT, ReleaseModelMetadata$OFFSET);\n-        ReleaseModelMetadata.invoke(funcPtr, _x0);\n+    public static final AddressLayout ReleaseKeyValuePairs$layout() {\n+        return ReleaseKeyValuePairs$LAYOUT;\n@@ -5633,0 +30738,2 @@\n+    private static final long ReleaseKeyValuePairs$OFFSET = 2400;\n+\n@@ -5634,0 +30741,1 @@\n+     * Offset for field:\n@@ -5635,1 +30743,1 @@\n-     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)\n@@ -5638,22 +30746,2 @@\n-    private static class CreateEnvWithGlobalThreadPools {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseKeyValuePairs$offset() {\n+        return ReleaseKeyValuePairs$OFFSET;\n@@ -5662,3 +30750,9 @@\n-    private static final AddressLayout CreateEnvWithGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithGlobalThreadPools\"));\n-\n-    private static final long CreateEnvWithGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnvWithGlobalThreadPools\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseKeyValuePairs(MemorySegment struct) {\n+        return struct.get(ReleaseKeyValuePairs$LAYOUT, ReleaseKeyValuePairs$OFFSET);\n+    }\n@@ -5667,1 +30761,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5669,1 +30763,1 @@\n-     * OrtStatusPtr (*CreateEnvWithGlobalThreadPools)(OrtLoggingLevel, const char *, const OrtThreadingOptions *, OrtEnv **)\n+     * void (*ReleaseKeyValuePairs)(OrtKeyValuePairs *)\n@@ -5672,3 +30766,2 @@\n-    public static MemorySegment CreateEnvWithGlobalThreadPools(MemorySegment struct, int _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(CreateEnvWithGlobalThreadPools$LAYOUT, CreateEnvWithGlobalThreadPools$OFFSET);\n-        return CreateEnvWithGlobalThreadPools.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void ReleaseKeyValuePairs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseKeyValuePairs$LAYOUT, ReleaseKeyValuePairs$OFFSET, fieldValue);\n@@ -5679,1 +30772,1 @@\n-     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)\n@@ -5682,1 +30775,12 @@\n-    private static class DisablePerSessionThreads {\n+    public static class RegisterExecutionProviderLibrary {\n+\n+        RegisterExecutionProviderLibrary() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -5685,2 +30789,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -5689,0 +30795,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(RegisterExecutionProviderLibrary.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(RegisterExecutionProviderLibrary.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5694,1 +30817,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -5696,1 +30819,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -5703,1 +30826,11 @@\n-    private static final AddressLayout DisablePerSessionThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"DisablePerSessionThreads\"));\n+    private static final AddressLayout RegisterExecutionProviderLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterExecutionProviderLibrary\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout RegisterExecutionProviderLibrary$layout() {\n+        return RegisterExecutionProviderLibrary$LAYOUT;\n+    }\n@@ -5705,1 +30838,1 @@\n-    private static final long DisablePerSessionThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"DisablePerSessionThreads\"));\n+    private static final long RegisterExecutionProviderLibrary$OFFSET = 2408;\n@@ -5708,1 +30841,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -5710,1 +30843,1 @@\n-     * OrtStatusPtr (*DisablePerSessionThreads)(OrtSessionOptions *)\n+     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)\n@@ -5713,3 +30846,2 @@\n-    public static MemorySegment DisablePerSessionThreads(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(DisablePerSessionThreads$LAYOUT, DisablePerSessionThreads$OFFSET);\n-        return DisablePerSessionThreads.invoke(funcPtr, _x0);\n+    public static final long RegisterExecutionProviderLibrary$offset() {\n+        return RegisterExecutionProviderLibrary$OFFSET;\n@@ -5719,0 +30851,1 @@\n+     * Getter for field:\n@@ -5720,1 +30853,11 @@\n-     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment RegisterExecutionProviderLibrary(MemorySegment struct) {\n+        return struct.get(RegisterExecutionProviderLibrary$LAYOUT, RegisterExecutionProviderLibrary$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*RegisterExecutionProviderLibrary)(OrtEnv *, const char *, const char *)\n@@ -5723,1 +30866,21 @@\n-    private static class CreateThreadingOptions {\n+    public static void RegisterExecutionProviderLibrary(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(RegisterExecutionProviderLibrary$LAYOUT, RegisterExecutionProviderLibrary$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)\n+     * }\n+     *\/\n+    public static class UnregisterExecutionProviderLibrary {\n+\n+        UnregisterExecutionProviderLibrary() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -5726,2 +30889,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -5730,0 +30894,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(UnregisterExecutionProviderLibrary.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(UnregisterExecutionProviderLibrary.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5735,1 +30916,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -5737,1 +30918,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -5744,3 +30925,1 @@\n-    private static final AddressLayout CreateThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateThreadingOptions\"));\n-\n-    private static final long CreateThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateThreadingOptions\"));\n+    private static final AddressLayout UnregisterExecutionProviderLibrary$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UnregisterExecutionProviderLibrary\"));\n@@ -5749,1 +30928,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5751,1 +30930,1 @@\n-     * OrtStatusPtr (*CreateThreadingOptions)(OrtThreadingOptions **)\n+     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)\n@@ -5754,3 +30933,2 @@\n-    public static MemorySegment CreateThreadingOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateThreadingOptions$LAYOUT, CreateThreadingOptions$OFFSET);\n-        return CreateThreadingOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout UnregisterExecutionProviderLibrary$layout() {\n+        return UnregisterExecutionProviderLibrary$LAYOUT;\n@@ -5759,0 +30937,2 @@\n+    private static final long UnregisterExecutionProviderLibrary$OFFSET = 2416;\n+\n@@ -5760,0 +30940,1 @@\n+     * Offset for field:\n@@ -5761,1 +30942,1 @@\n-     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)\n@@ -5764,18 +30945,2 @@\n-    private static class ReleaseThreadingOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long UnregisterExecutionProviderLibrary$offset() {\n+        return UnregisterExecutionProviderLibrary$OFFSET;\n@@ -5784,3 +30949,9 @@\n-    private static final AddressLayout ReleaseThreadingOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseThreadingOptions\"));\n-\n-    private static final long ReleaseThreadingOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseThreadingOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment UnregisterExecutionProviderLibrary(MemorySegment struct) {\n+        return struct.get(UnregisterExecutionProviderLibrary$LAYOUT, UnregisterExecutionProviderLibrary$OFFSET);\n+    }\n@@ -5789,1 +30960,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5791,1 +30962,1 @@\n-     * void (*ReleaseThreadingOptions)(OrtThreadingOptions *)\n+     * OrtStatusPtr (*UnregisterExecutionProviderLibrary)(OrtEnv *, const char *)\n@@ -5794,3 +30965,2 @@\n-    public static void ReleaseThreadingOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseThreadingOptions$LAYOUT, ReleaseThreadingOptions$OFFSET);\n-        ReleaseThreadingOptions.invoke(funcPtr, _x0);\n+    public static void UnregisterExecutionProviderLibrary(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(UnregisterExecutionProviderLibrary$LAYOUT, UnregisterExecutionProviderLibrary$OFFSET, fieldValue);\n@@ -5801,1 +30971,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)\n@@ -5804,1 +30974,12 @@\n-    private static class ModelMetadataGetCustomMetadataMapKeys {\n+    public static class GetEpDevices {\n+\n+        GetEpDevices() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -5807,5 +30988,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -5814,0 +30994,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetEpDevices.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetEpDevices.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5819,1 +31016,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -5821,1 +31018,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -5828,1 +31025,23 @@\n-    private static final AddressLayout ModelMetadataGetCustomMetadataMapKeys$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetCustomMetadataMapKeys\"));\n+    private static final AddressLayout GetEpDevices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetEpDevices\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetEpDevices$layout() {\n+        return GetEpDevices$LAYOUT;\n+    }\n+\n+    private static final long GetEpDevices$OFFSET = 2424;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)\n+     * }\n+     *\/\n+    public static final long GetEpDevices$offset() {\n+        return GetEpDevices$OFFSET;\n+    }\n@@ -5830,1 +31049,9 @@\n-    private static final long ModelMetadataGetCustomMetadataMapKeys$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetCustomMetadataMapKeys\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetEpDevices(MemorySegment struct) {\n+        return struct.get(GetEpDevices$LAYOUT, GetEpDevices$OFFSET);\n+    }\n@@ -5833,1 +31060,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5835,1 +31062,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetCustomMetadataMapKeys)(const OrtModelMetadata *, OrtAllocator *, char ***, int64_t *)\n+     * OrtStatusPtr (*GetEpDevices)(const OrtEnv *, const OrtEpDevice *const **, size_t *)\n@@ -5838,3 +31065,2 @@\n-    public static MemorySegment ModelMetadataGetCustomMetadataMapKeys(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(ModelMetadataGetCustomMetadataMapKeys$LAYOUT, ModelMetadataGetCustomMetadataMapKeys$OFFSET);\n-        return ModelMetadataGetCustomMetadataMapKeys.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void GetEpDevices(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetEpDevices$LAYOUT, GetEpDevices$OFFSET, fieldValue);\n@@ -5845,1 +31071,1 @@\n-     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)\n@@ -5848,1 +31074,12 @@\n-    private static class AddFreeDimensionOverrideByName {\n+    public static class SessionOptionsAppendExecutionProvider_V2 {\n+\n+        SessionOptionsAppendExecutionProvider_V2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6);\n+        }\n@@ -5851,4 +31088,8 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -5857,0 +31098,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsAppendExecutionProvider_V2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsAppendExecutionProvider_V2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5862,1 +31120,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n@@ -5864,1 +31122,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n@@ -5871,3 +31129,1 @@\n-    private static final AddressLayout AddFreeDimensionOverrideByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddFreeDimensionOverrideByName\"));\n-\n-    private static final long AddFreeDimensionOverrideByName$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddFreeDimensionOverrideByName\"));\n+    private static final AddressLayout SessionOptionsAppendExecutionProvider_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_V2\"));\n@@ -5876,1 +31132,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5878,1 +31134,1 @@\n-     * OrtStatusPtr (*AddFreeDimensionOverrideByName)(OrtSessionOptions *, const char *, int64_t)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)\n@@ -5881,3 +31137,2 @@\n-    public static MemorySegment AddFreeDimensionOverrideByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(AddFreeDimensionOverrideByName$LAYOUT, AddFreeDimensionOverrideByName$OFFSET);\n-        return AddFreeDimensionOverrideByName.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout SessionOptionsAppendExecutionProvider_V2$layout() {\n+        return SessionOptionsAppendExecutionProvider_V2$LAYOUT;\n@@ -5886,0 +31141,2 @@\n+    private static final long SessionOptionsAppendExecutionProvider_V2$OFFSET = 2432;\n+\n@@ -5887,0 +31144,1 @@\n+     * Offset for field:\n@@ -5888,1 +31146,1 @@\n-     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)\n@@ -5891,20 +31149,2 @@\n-    private static class GetAvailableProviders {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionOptionsAppendExecutionProvider_V2$offset() {\n+        return SessionOptionsAppendExecutionProvider_V2$OFFSET;\n@@ -5913,3 +31153,9 @@\n-    private static final AddressLayout GetAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAvailableProviders\"));\n-\n-    private static final long GetAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetAvailableProviders\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsAppendExecutionProvider_V2(MemorySegment struct) {\n+        return struct.get(SessionOptionsAppendExecutionProvider_V2$LAYOUT, SessionOptionsAppendExecutionProvider_V2$OFFSET);\n+    }\n@@ -5918,1 +31164,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -5920,1 +31166,1 @@\n-     * OrtStatusPtr (*GetAvailableProviders)(char ***, int *)\n+     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_V2)(OrtSessionOptions *, OrtEnv *, const OrtEpDevice *const *, size_t, const char *const *, const char *const *, size_t)\n@@ -5923,3 +31169,2 @@\n-    public static MemorySegment GetAvailableProviders(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetAvailableProviders$LAYOUT, GetAvailableProviders$OFFSET);\n-        return GetAvailableProviders.invoke(funcPtr, _x0, _x1);\n+    public static void SessionOptionsAppendExecutionProvider_V2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsAppendExecutionProvider_V2$LAYOUT, SessionOptionsAppendExecutionProvider_V2$OFFSET, fieldValue);\n@@ -5930,1 +31175,1 @@\n-     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)\n@@ -5933,1 +31178,12 @@\n-    private static class ReleaseAvailableProviders {\n+    public static class SessionOptionsSetEpSelectionPolicy {\n+\n+        SessionOptionsSetEpSelectionPolicy() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -5936,3 +31192,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -5941,0 +31197,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsSetEpSelectionPolicy.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsSetEpSelectionPolicy.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -5955,3 +31228,1 @@\n-    private static final AddressLayout ReleaseAvailableProviders$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAvailableProviders\"));\n-\n-    private static final long ReleaseAvailableProviders$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseAvailableProviders\"));\n+    private static final AddressLayout SessionOptionsSetEpSelectionPolicy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetEpSelectionPolicy\"));\n@@ -5960,1 +31231,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -5962,1 +31233,1 @@\n-     * OrtStatusPtr (*ReleaseAvailableProviders)(char **, int)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)\n@@ -5965,3 +31236,2 @@\n-    public static MemorySegment ReleaseAvailableProviders(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(ReleaseAvailableProviders$LAYOUT, ReleaseAvailableProviders$OFFSET);\n-        return ReleaseAvailableProviders.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout SessionOptionsSetEpSelectionPolicy$layout() {\n+        return SessionOptionsSetEpSelectionPolicy$LAYOUT;\n@@ -5970,0 +31240,2 @@\n+    private static final long SessionOptionsSetEpSelectionPolicy$OFFSET = 2440;\n+\n@@ -5971,0 +31243,1 @@\n+     * Offset for field:\n@@ -5972,1 +31245,1 @@\n-     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)\n@@ -5975,21 +31248,2 @@\n-    private static class GetStringTensorElementLength {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionOptionsSetEpSelectionPolicy$offset() {\n+        return SessionOptionsSetEpSelectionPolicy$OFFSET;\n@@ -5998,3 +31252,9 @@\n-    private static final AddressLayout GetStringTensorElementLength$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorElementLength\"));\n-\n-    private static final long GetStringTensorElementLength$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorElementLength\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetEpSelectionPolicy(MemorySegment struct) {\n+        return struct.get(SessionOptionsSetEpSelectionPolicy$LAYOUT, SessionOptionsSetEpSelectionPolicy$OFFSET);\n+    }\n@@ -6003,1 +31263,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6005,1 +31265,1 @@\n-     * OrtStatusPtr (*GetStringTensorElementLength)(const OrtValue *, size_t, size_t *)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicy)(OrtSessionOptions *, OrtExecutionProviderDevicePolicy)\n@@ -6008,3 +31268,2 @@\n-    public static MemorySegment GetStringTensorElementLength(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetStringTensorElementLength$LAYOUT, GetStringTensorElementLength$OFFSET);\n-        return GetStringTensorElementLength.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void SessionOptionsSetEpSelectionPolicy(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsSetEpSelectionPolicy$LAYOUT, SessionOptionsSetEpSelectionPolicy$OFFSET, fieldValue);\n@@ -6015,1 +31274,1 @@\n-     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)\n@@ -6018,1 +31277,12 @@\n-    private static class GetStringTensorElement {\n+    public static class SessionOptionsSetEpSelectionPolicyDelegate {\n+\n+        SessionOptionsSetEpSelectionPolicyDelegate() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -6021,5 +31291,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6028,0 +31297,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionOptionsSetEpSelectionPolicyDelegate.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionOptionsSetEpSelectionPolicyDelegate.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6033,1 +31319,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -6035,1 +31321,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -6042,3 +31328,1 @@\n-    private static final AddressLayout GetStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStringTensorElement\"));\n-\n-    private static final long GetStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetStringTensorElement\"));\n+    private static final AddressLayout SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetEpSelectionPolicyDelegate\"));\n@@ -6047,1 +31331,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6049,1 +31333,1 @@\n-     * OrtStatusPtr (*GetStringTensorElement)(const OrtValue *, size_t, size_t, void *)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)\n@@ -6052,3 +31336,2 @@\n-    public static MemorySegment GetStringTensorElement(MemorySegment struct, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(GetStringTensorElement$LAYOUT, GetStringTensorElement$OFFSET);\n-        return GetStringTensorElement.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout SessionOptionsSetEpSelectionPolicyDelegate$layout() {\n+        return SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT;\n@@ -6057,0 +31340,2 @@\n+    private static final long SessionOptionsSetEpSelectionPolicyDelegate$OFFSET = 2448;\n+\n@@ -6058,0 +31343,1 @@\n+     * Offset for field:\n@@ -6059,1 +31345,1 @@\n-     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)\n@@ -6062,21 +31348,2 @@\n-    private static class FillStringTensorElement {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionOptionsSetEpSelectionPolicyDelegate$offset() {\n+        return SessionOptionsSetEpSelectionPolicyDelegate$OFFSET;\n@@ -6085,3 +31352,9 @@\n-    private static final AddressLayout FillStringTensorElement$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillStringTensorElement\"));\n-\n-    private static final long FillStringTensorElement$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillStringTensorElement\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionOptionsSetEpSelectionPolicyDelegate(MemorySegment struct) {\n+        return struct.get(SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT, SessionOptionsSetEpSelectionPolicyDelegate$OFFSET);\n+    }\n@@ -6090,1 +31363,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6092,1 +31365,1 @@\n-     * OrtStatusPtr (*FillStringTensorElement)(OrtValue *, const char *, size_t)\n+     * OrtStatusPtr (*SessionOptionsSetEpSelectionPolicyDelegate)(OrtSessionOptions *, EpSelectionDelegate, void *)\n@@ -6095,3 +31368,2 @@\n-    public static MemorySegment FillStringTensorElement(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(FillStringTensorElement$LAYOUT, FillStringTensorElement$OFFSET);\n-        return FillStringTensorElement.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void SessionOptionsSetEpSelectionPolicyDelegate(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionOptionsSetEpSelectionPolicyDelegate$LAYOUT, SessionOptionsSetEpSelectionPolicyDelegate$OFFSET, fieldValue);\n@@ -6102,1 +31374,1 @@\n-     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)\n@@ -6105,1 +31377,12 @@\n-    private static class AddSessionConfigEntry {\n+    public static class HardwareDevice_Type {\n+\n+        HardwareDevice_Type() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n@@ -6108,4 +31391,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6114,0 +31395,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HardwareDevice_Type.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HardwareDevice_Type.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6119,1 +31417,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6121,1 +31419,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6128,3 +31426,1 @@\n-    private static final AddressLayout AddSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddSessionConfigEntry\"));\n-\n-    private static final long AddSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddSessionConfigEntry\"));\n+    private static final AddressLayout HardwareDevice_Type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HardwareDevice_Type\"));\n@@ -6133,1 +31429,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6135,1 +31431,1 @@\n-     * OrtStatusPtr (*AddSessionConfigEntry)(OrtSessionOptions *, const char *, const char *)\n+     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)\n@@ -6138,3 +31434,2 @@\n-    public static MemorySegment AddSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(AddSessionConfigEntry$LAYOUT, AddSessionConfigEntry$OFFSET);\n-        return AddSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout HardwareDevice_Type$layout() {\n+        return HardwareDevice_Type$LAYOUT;\n@@ -6143,0 +31438,2 @@\n+    private static final long HardwareDevice_Type$OFFSET = 2456;\n+\n@@ -6144,0 +31441,1 @@\n+     * Offset for field:\n@@ -6145,1 +31443,1 @@\n-     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)\n@@ -6148,21 +31446,2 @@\n-    private static class CreateAllocator {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long HardwareDevice_Type$offset() {\n+        return HardwareDevice_Type$OFFSET;\n@@ -6171,3 +31450,9 @@\n-    private static final AddressLayout CreateAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAllocator\"));\n-\n-    private static final long CreateAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateAllocator\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment HardwareDevice_Type(MemorySegment struct) {\n+        return struct.get(HardwareDevice_Type$LAYOUT, HardwareDevice_Type$OFFSET);\n+    }\n@@ -6176,1 +31461,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6178,1 +31463,1 @@\n-     * OrtStatusPtr (*CreateAllocator)(const OrtSession *, const OrtMemoryInfo *, OrtAllocator **)\n+     * OrtHardwareDeviceType (*HardwareDevice_Type)(const OrtHardwareDevice *)\n@@ -6181,3 +31466,2 @@\n-    public static MemorySegment CreateAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(CreateAllocator$LAYOUT, CreateAllocator$OFFSET);\n-        return CreateAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void HardwareDevice_Type(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HardwareDevice_Type$LAYOUT, HardwareDevice_Type$OFFSET, fieldValue);\n@@ -6188,1 +31472,1 @@\n-     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)\n@@ -6191,1 +31475,1 @@\n-    private static class ReleaseAllocator {\n+    public static class HardwareDevice_VendorId {\n@@ -6193,2 +31477,14 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n+        HardwareDevice_VendorId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6197,0 +31493,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HardwareDevice_VendorId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HardwareDevice_VendorId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6202,1 +31515,1 @@\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6204,1 +31517,1 @@\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6211,3 +31524,1 @@\n-    private static final AddressLayout ReleaseAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAllocator\"));\n-\n-    private static final long ReleaseAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseAllocator\"));\n+    private static final AddressLayout HardwareDevice_VendorId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HardwareDevice_VendorId\"));\n@@ -6216,1 +31527,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6218,1 +31529,1 @@\n-     * void (*ReleaseAllocator)(OrtAllocator *)\n+     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)\n@@ -6221,3 +31532,2 @@\n-    public static void ReleaseAllocator(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseAllocator$LAYOUT, ReleaseAllocator$OFFSET);\n-        ReleaseAllocator.invoke(funcPtr, _x0);\n+    public static final AddressLayout HardwareDevice_VendorId$layout() {\n+        return HardwareDevice_VendorId$LAYOUT;\n@@ -6226,0 +31536,2 @@\n+    private static final long HardwareDevice_VendorId$OFFSET = 2464;\n+\n@@ -6227,0 +31539,1 @@\n+     * Offset for field:\n@@ -6228,1 +31541,1 @@\n-     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)\n@@ -6231,21 +31544,2 @@\n-    private static class RunWithBinding {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long HardwareDevice_VendorId$offset() {\n+        return HardwareDevice_VendorId$OFFSET;\n@@ -6254,3 +31548,9 @@\n-    private static final AddressLayout RunWithBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunWithBinding\"));\n-\n-    private static final long RunWithBinding$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunWithBinding\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment HardwareDevice_VendorId(MemorySegment struct) {\n+        return struct.get(HardwareDevice_VendorId$LAYOUT, HardwareDevice_VendorId$OFFSET);\n+    }\n@@ -6259,1 +31559,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6261,1 +31561,1 @@\n-     * OrtStatusPtr (*RunWithBinding)(OrtSession *, const OrtRunOptions *, const OrtIoBinding *)\n+     * uint32_t (*HardwareDevice_VendorId)(const OrtHardwareDevice *)\n@@ -6264,3 +31564,2 @@\n-    public static MemorySegment RunWithBinding(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(RunWithBinding$LAYOUT, RunWithBinding$OFFSET);\n-        return RunWithBinding.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void HardwareDevice_VendorId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HardwareDevice_VendorId$LAYOUT, HardwareDevice_VendorId$OFFSET, fieldValue);\n@@ -6271,1 +31570,1 @@\n-     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)\n@@ -6274,1 +31573,12 @@\n-    private static class CreateIoBinding {\n+    public static class HardwareDevice_Vendor {\n+\n+        HardwareDevice_Vendor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -6277,3 +31587,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6282,0 +31591,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HardwareDevice_Vendor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HardwareDevice_Vendor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6287,1 +31613,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6289,1 +31615,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6296,3 +31622,1 @@\n-    private static final AddressLayout CreateIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateIoBinding\"));\n-\n-    private static final long CreateIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateIoBinding\"));\n+    private static final AddressLayout HardwareDevice_Vendor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HardwareDevice_Vendor\"));\n@@ -6301,1 +31625,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6303,1 +31627,1 @@\n-     * OrtStatusPtr (*CreateIoBinding)(OrtSession *, OrtIoBinding **)\n+     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)\n@@ -6306,3 +31630,2 @@\n-    public static MemorySegment CreateIoBinding(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CreateIoBinding$LAYOUT, CreateIoBinding$OFFSET);\n-        return CreateIoBinding.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout HardwareDevice_Vendor$layout() {\n+        return HardwareDevice_Vendor$LAYOUT;\n@@ -6311,0 +31634,2 @@\n+    private static final long HardwareDevice_Vendor$OFFSET = 2472;\n+\n@@ -6312,0 +31637,1 @@\n+     * Offset for field:\n@@ -6313,1 +31639,1 @@\n-     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)\n@@ -6316,18 +31642,2 @@\n-    private static class ReleaseIoBinding {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long HardwareDevice_Vendor$offset() {\n+        return HardwareDevice_Vendor$OFFSET;\n@@ -6336,3 +31646,9 @@\n-    private static final AddressLayout ReleaseIoBinding$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseIoBinding\"));\n-\n-    private static final long ReleaseIoBinding$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseIoBinding\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment HardwareDevice_Vendor(MemorySegment struct) {\n+        return struct.get(HardwareDevice_Vendor$LAYOUT, HardwareDevice_Vendor$OFFSET);\n+    }\n@@ -6341,1 +31657,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6343,1 +31659,1 @@\n-     * void (*ReleaseIoBinding)(OrtIoBinding *)\n+     * const char *(*HardwareDevice_Vendor)(const OrtHardwareDevice *)\n@@ -6346,3 +31662,2 @@\n-    public static void ReleaseIoBinding(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseIoBinding$LAYOUT, ReleaseIoBinding$OFFSET);\n-        ReleaseIoBinding.invoke(funcPtr, _x0);\n+    public static void HardwareDevice_Vendor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HardwareDevice_Vendor$LAYOUT, HardwareDevice_Vendor$OFFSET, fieldValue);\n@@ -6353,1 +31668,1 @@\n-     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)\n@@ -6356,1 +31671,12 @@\n-    private static class BindInput {\n+    public static class HardwareDevice_DeviceId {\n+\n+        HardwareDevice_DeviceId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n@@ -6359,4 +31685,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6365,0 +31689,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HardwareDevice_DeviceId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HardwareDevice_DeviceId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6370,1 +31711,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6372,1 +31713,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6379,3 +31720,1 @@\n-    private static final AddressLayout BindInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindInput\"));\n-\n-    private static final long BindInput$OFFSET = $LAYOUT.byteOffset(groupElement(\"BindInput\"));\n+    private static final AddressLayout HardwareDevice_DeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HardwareDevice_DeviceId\"));\n@@ -6384,1 +31723,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6386,1 +31725,1 @@\n-     * OrtStatusPtr (*BindInput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)\n@@ -6389,3 +31728,2 @@\n-    public static MemorySegment BindInput(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(BindInput$LAYOUT, BindInput$OFFSET);\n-        return BindInput.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout HardwareDevice_DeviceId$layout() {\n+        return HardwareDevice_DeviceId$LAYOUT;\n@@ -6394,0 +31732,2 @@\n+    private static final long HardwareDevice_DeviceId$OFFSET = 2480;\n+\n@@ -6395,0 +31735,1 @@\n+     * Offset for field:\n@@ -6396,1 +31737,1 @@\n-     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)\n@@ -6399,21 +31740,2 @@\n-    private static class BindOutput {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long HardwareDevice_DeviceId$offset() {\n+        return HardwareDevice_DeviceId$OFFSET;\n@@ -6422,3 +31744,9 @@\n-    private static final AddressLayout BindOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindOutput\"));\n-\n-    private static final long BindOutput$OFFSET = $LAYOUT.byteOffset(groupElement(\"BindOutput\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment HardwareDevice_DeviceId(MemorySegment struct) {\n+        return struct.get(HardwareDevice_DeviceId$LAYOUT, HardwareDevice_DeviceId$OFFSET);\n+    }\n@@ -6427,1 +31755,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6429,1 +31757,1 @@\n-     * OrtStatusPtr (*BindOutput)(OrtIoBinding *, const char *, const OrtValue *)\n+     * uint32_t (*HardwareDevice_DeviceId)(const OrtHardwareDevice *)\n@@ -6432,3 +31760,2 @@\n-    public static MemorySegment BindOutput(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(BindOutput$LAYOUT, BindOutput$OFFSET);\n-        return BindOutput.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void HardwareDevice_DeviceId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HardwareDevice_DeviceId$LAYOUT, HardwareDevice_DeviceId$OFFSET, fieldValue);\n@@ -6439,1 +31766,1 @@\n-     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)\n@@ -6442,1 +31769,12 @@\n-    private static class BindOutputToDevice {\n+    public static class HardwareDevice_Metadata {\n+\n+        HardwareDevice_Metadata() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -6445,4 +31783,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6451,0 +31787,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(HardwareDevice_Metadata.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(HardwareDevice_Metadata.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6456,1 +31809,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6458,1 +31811,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6465,3 +31818,1 @@\n-    private static final AddressLayout BindOutputToDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"BindOutputToDevice\"));\n-\n-    private static final long BindOutputToDevice$OFFSET = $LAYOUT.byteOffset(groupElement(\"BindOutputToDevice\"));\n+    private static final AddressLayout HardwareDevice_Metadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HardwareDevice_Metadata\"));\n@@ -6470,1 +31821,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6472,1 +31823,1 @@\n-     * OrtStatusPtr (*BindOutputToDevice)(OrtIoBinding *, const char *, const OrtMemoryInfo *)\n+     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)\n@@ -6475,3 +31826,2 @@\n-    public static MemorySegment BindOutputToDevice(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(BindOutputToDevice$LAYOUT, BindOutputToDevice$OFFSET);\n-        return BindOutputToDevice.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout HardwareDevice_Metadata$layout() {\n+        return HardwareDevice_Metadata$LAYOUT;\n@@ -6480,0 +31830,2 @@\n+    private static final long HardwareDevice_Metadata$OFFSET = 2488;\n+\n@@ -6481,0 +31833,1 @@\n+     * Offset for field:\n@@ -6482,1 +31835,1 @@\n-     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)\n@@ -6485,23 +31838,2 @@\n-    private static class GetBoundOutputNames {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long HardwareDevice_Metadata$offset() {\n+        return HardwareDevice_Metadata$OFFSET;\n@@ -6510,3 +31842,9 @@\n-    private static final AddressLayout GetBoundOutputNames$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBoundOutputNames\"));\n-\n-    private static final long GetBoundOutputNames$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetBoundOutputNames\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment HardwareDevice_Metadata(MemorySegment struct) {\n+        return struct.get(HardwareDevice_Metadata$LAYOUT, HardwareDevice_Metadata$OFFSET);\n+    }\n@@ -6515,1 +31853,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6517,1 +31855,1 @@\n-     * OrtStatusPtr (*GetBoundOutputNames)(const OrtIoBinding *, OrtAllocator *, char **, size_t **, size_t *)\n+     * const OrtKeyValuePairs *(*HardwareDevice_Metadata)(const OrtHardwareDevice *)\n@@ -6520,3 +31858,2 @@\n-    public static MemorySegment GetBoundOutputNames(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(GetBoundOutputNames$LAYOUT, GetBoundOutputNames$OFFSET);\n-        return GetBoundOutputNames.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static void HardwareDevice_Metadata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(HardwareDevice_Metadata$LAYOUT, HardwareDevice_Metadata$OFFSET, fieldValue);\n@@ -6527,1 +31864,1 @@\n-     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * const char *(*EpDevice_EpName)(const OrtEpDevice *)\n@@ -6530,1 +31867,12 @@\n-    private static class GetBoundOutputValues {\n+    public static class EpDevice_EpName {\n+\n+        EpDevice_EpName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -6533,5 +31881,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6540,0 +31885,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EpDevice_EpName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EpDevice_EpName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6545,1 +31907,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6547,1 +31909,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6554,3 +31916,1 @@\n-    private static final AddressLayout GetBoundOutputValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBoundOutputValues\"));\n-\n-    private static final long GetBoundOutputValues$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetBoundOutputValues\"));\n+    private static final AddressLayout EpDevice_EpName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EpDevice_EpName\"));\n@@ -6559,1 +31919,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6561,1 +31921,1 @@\n-     * OrtStatusPtr (*GetBoundOutputValues)(const OrtIoBinding *, OrtAllocator *, OrtValue ***, size_t *)\n+     * const char *(*EpDevice_EpName)(const OrtEpDevice *)\n@@ -6564,3 +31924,2 @@\n-    public static MemorySegment GetBoundOutputValues(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(GetBoundOutputValues$LAYOUT, GetBoundOutputValues$OFFSET);\n-        return GetBoundOutputValues.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout EpDevice_EpName$layout() {\n+        return EpDevice_EpName$LAYOUT;\n@@ -6569,0 +31928,2 @@\n+    private static final long EpDevice_EpName$OFFSET = 2496;\n+\n@@ -6570,0 +31931,1 @@\n+     * Offset for field:\n@@ -6571,1 +31933,1 @@\n-     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * const char *(*EpDevice_EpName)(const OrtEpDevice *)\n@@ -6574,18 +31936,2 @@\n-    private static class ClearBoundInputs {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EpDevice_EpName$offset() {\n+        return EpDevice_EpName$OFFSET;\n@@ -6594,3 +31940,9 @@\n-    private static final AddressLayout ClearBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ClearBoundInputs\"));\n-\n-    private static final long ClearBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"ClearBoundInputs\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*EpDevice_EpName)(const OrtEpDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment EpDevice_EpName(MemorySegment struct) {\n+        return struct.get(EpDevice_EpName$LAYOUT, EpDevice_EpName$OFFSET);\n+    }\n@@ -6599,1 +31951,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6601,1 +31953,1 @@\n-     * void (*ClearBoundInputs)(OrtIoBinding *)\n+     * const char *(*EpDevice_EpName)(const OrtEpDevice *)\n@@ -6604,3 +31956,2 @@\n-    public static void ClearBoundInputs(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ClearBoundInputs$LAYOUT, ClearBoundInputs$OFFSET);\n-        ClearBoundInputs.invoke(funcPtr, _x0);\n+    public static void EpDevice_EpName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EpDevice_EpName$LAYOUT, EpDevice_EpName$OFFSET, fieldValue);\n@@ -6611,1 +31962,1 @@\n-     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)\n@@ -6614,1 +31965,1 @@\n-    private static class ClearBoundOutputs {\n+    public static class EpDevice_EpVendor {\n@@ -6616,2 +31967,14 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n+        EpDevice_EpVendor() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6620,0 +31983,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EpDevice_EpVendor.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EpDevice_EpVendor.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6625,1 +32005,1 @@\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6627,1 +32007,1 @@\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6634,3 +32014,1 @@\n-    private static final AddressLayout ClearBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ClearBoundOutputs\"));\n-\n-    private static final long ClearBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"ClearBoundOutputs\"));\n+    private static final AddressLayout EpDevice_EpVendor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EpDevice_EpVendor\"));\n@@ -6639,1 +32017,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6641,1 +32019,1 @@\n-     * void (*ClearBoundOutputs)(OrtIoBinding *)\n+     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)\n@@ -6644,3 +32022,2 @@\n-    public static void ClearBoundOutputs(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ClearBoundOutputs$LAYOUT, ClearBoundOutputs$OFFSET);\n-        ClearBoundOutputs.invoke(funcPtr, _x0);\n+    public static final AddressLayout EpDevice_EpVendor$layout() {\n+        return EpDevice_EpVendor$LAYOUT;\n@@ -6649,0 +32026,2 @@\n+    private static final long EpDevice_EpVendor$OFFSET = 2504;\n+\n@@ -6650,0 +32029,1 @@\n+     * Offset for field:\n@@ -6651,1 +32031,1 @@\n-     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)\n@@ -6654,22 +32034,2 @@\n-    private static class TensorAt {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EpDevice_EpVendor$offset() {\n+        return EpDevice_EpVendor$OFFSET;\n@@ -6678,3 +32038,9 @@\n-    private static final AddressLayout TensorAt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"TensorAt\"));\n-\n-    private static final long TensorAt$OFFSET = $LAYOUT.byteOffset(groupElement(\"TensorAt\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment EpDevice_EpVendor(MemorySegment struct) {\n+        return struct.get(EpDevice_EpVendor$LAYOUT, EpDevice_EpVendor$OFFSET);\n+    }\n@@ -6683,1 +32049,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6685,1 +32051,1 @@\n-     * OrtStatusPtr (*TensorAt)(OrtValue *, const int64_t *, size_t, void **)\n+     * const char *(*EpDevice_EpVendor)(const OrtEpDevice *)\n@@ -6688,3 +32054,2 @@\n-    public static MemorySegment TensorAt(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(TensorAt$LAYOUT, TensorAt$OFFSET);\n-        return TensorAt.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void EpDevice_EpVendor(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EpDevice_EpVendor$LAYOUT, EpDevice_EpVendor$OFFSET, fieldValue);\n@@ -6695,1 +32060,1 @@\n-     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)\n@@ -6698,1 +32063,12 @@\n-    private static class CreateAndRegisterAllocator {\n+    public static class EpDevice_EpMetadata {\n+\n+        EpDevice_EpMetadata() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -6701,4 +32077,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6707,0 +32081,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EpDevice_EpMetadata.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EpDevice_EpMetadata.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6712,1 +32103,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6714,1 +32105,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6721,3 +32112,1 @@\n-    private static final AddressLayout CreateAndRegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAndRegisterAllocator\"));\n-\n-    private static final long CreateAndRegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateAndRegisterAllocator\"));\n+    private static final AddressLayout EpDevice_EpMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EpDevice_EpMetadata\"));\n@@ -6726,1 +32115,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6728,1 +32117,1 @@\n-     * OrtStatusPtr (*CreateAndRegisterAllocator)(OrtEnv *, const OrtMemoryInfo *, const OrtArenaCfg *)\n+     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)\n@@ -6731,3 +32120,2 @@\n-    public static MemorySegment CreateAndRegisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(CreateAndRegisterAllocator$LAYOUT, CreateAndRegisterAllocator$OFFSET);\n-        return CreateAndRegisterAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout EpDevice_EpMetadata$layout() {\n+        return EpDevice_EpMetadata$LAYOUT;\n@@ -6736,0 +32124,2 @@\n+    private static final long EpDevice_EpMetadata$OFFSET = 2512;\n+\n@@ -6737,0 +32127,1 @@\n+     * Offset for field:\n@@ -6738,1 +32129,1 @@\n-     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)\n@@ -6741,20 +32132,2 @@\n-    private static class SetLanguageProjection {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EpDevice_EpMetadata$offset() {\n+        return EpDevice_EpMetadata$OFFSET;\n@@ -6763,3 +32136,9 @@\n-    private static final AddressLayout SetLanguageProjection$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetLanguageProjection\"));\n-\n-    private static final long SetLanguageProjection$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetLanguageProjection\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment EpDevice_EpMetadata(MemorySegment struct) {\n+        return struct.get(EpDevice_EpMetadata$LAYOUT, EpDevice_EpMetadata$OFFSET);\n+    }\n@@ -6768,1 +32147,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6770,1 +32149,1 @@\n-     * OrtStatusPtr (*SetLanguageProjection)(const OrtEnv *, OrtLanguageProjection)\n+     * const OrtKeyValuePairs *(*EpDevice_EpMetadata)(const OrtEpDevice *)\n@@ -6773,3 +32152,2 @@\n-    public static MemorySegment SetLanguageProjection(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetLanguageProjection$LAYOUT, SetLanguageProjection$OFFSET);\n-        return SetLanguageProjection.invoke(funcPtr, _x0, _x1);\n+    public static void EpDevice_EpMetadata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EpDevice_EpMetadata$LAYOUT, EpDevice_EpMetadata$OFFSET, fieldValue);\n@@ -6780,1 +32158,1 @@\n-     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)\n@@ -6783,1 +32161,12 @@\n-    private static class SessionGetProfilingStartTimeNs {\n+    public static class EpDevice_EpOptions {\n+\n+        EpDevice_EpOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -6786,3 +32175,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6791,0 +32179,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EpDevice_EpOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EpDevice_EpOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6796,1 +32201,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6798,1 +32203,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6805,3 +32210,1 @@\n-    private static final AddressLayout SessionGetProfilingStartTimeNs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetProfilingStartTimeNs\"));\n-\n-    private static final long SessionGetProfilingStartTimeNs$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionGetProfilingStartTimeNs\"));\n+    private static final AddressLayout EpDevice_EpOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EpDevice_EpOptions\"));\n@@ -6810,1 +32213,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6812,1 +32215,1 @@\n-     * OrtStatusPtr (*SessionGetProfilingStartTimeNs)(const OrtSession *, uint64_t *)\n+     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)\n@@ -6815,3 +32218,2 @@\n-    public static MemorySegment SessionGetProfilingStartTimeNs(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionGetProfilingStartTimeNs$LAYOUT, SessionGetProfilingStartTimeNs$OFFSET);\n-        return SessionGetProfilingStartTimeNs.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout EpDevice_EpOptions$layout() {\n+        return EpDevice_EpOptions$LAYOUT;\n@@ -6820,0 +32222,2 @@\n+    private static final long EpDevice_EpOptions$OFFSET = 2520;\n+\n@@ -6821,0 +32225,1 @@\n+     * Offset for field:\n@@ -6822,1 +32227,1 @@\n-     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)\n@@ -6825,20 +32230,2 @@\n-    private static class SetGlobalIntraOpNumThreads {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EpDevice_EpOptions$offset() {\n+        return EpDevice_EpOptions$OFFSET;\n@@ -6847,3 +32234,9 @@\n-    private static final AddressLayout SetGlobalIntraOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalIntraOpNumThreads\"));\n-\n-    private static final long SetGlobalIntraOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalIntraOpNumThreads\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment EpDevice_EpOptions(MemorySegment struct) {\n+        return struct.get(EpDevice_EpOptions$LAYOUT, EpDevice_EpOptions$OFFSET);\n+    }\n@@ -6852,1 +32245,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6854,1 +32247,1 @@\n-     * OrtStatusPtr (*SetGlobalIntraOpNumThreads)(OrtThreadingOptions *, int)\n+     * const OrtKeyValuePairs *(*EpDevice_EpOptions)(const OrtEpDevice *)\n@@ -6857,3 +32250,2 @@\n-    public static MemorySegment SetGlobalIntraOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetGlobalIntraOpNumThreads$LAYOUT, SetGlobalIntraOpNumThreads$OFFSET);\n-        return SetGlobalIntraOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    public static void EpDevice_EpOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EpDevice_EpOptions$LAYOUT, EpDevice_EpOptions$OFFSET, fieldValue);\n@@ -6864,1 +32256,1 @@\n-     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)\n@@ -6867,1 +32259,12 @@\n-    private static class SetGlobalInterOpNumThreads {\n+    public static class EpDevice_Device {\n+\n+        EpDevice_Device() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -6870,3 +32273,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -6875,0 +32277,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EpDevice_Device.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EpDevice_Device.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -6880,1 +32299,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -6882,1 +32301,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -6889,3 +32308,1 @@\n-    private static final AddressLayout SetGlobalInterOpNumThreads$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalInterOpNumThreads\"));\n-\n-    private static final long SetGlobalInterOpNumThreads$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalInterOpNumThreads\"));\n+    private static final AddressLayout EpDevice_Device$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EpDevice_Device\"));\n@@ -6894,1 +32311,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6896,1 +32313,1 @@\n-     * OrtStatusPtr (*SetGlobalInterOpNumThreads)(OrtThreadingOptions *, int)\n+     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)\n@@ -6899,3 +32316,2 @@\n-    public static MemorySegment SetGlobalInterOpNumThreads(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetGlobalInterOpNumThreads$LAYOUT, SetGlobalInterOpNumThreads$OFFSET);\n-        return SetGlobalInterOpNumThreads.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout EpDevice_Device$layout() {\n+        return EpDevice_Device$LAYOUT;\n@@ -6904,0 +32320,2 @@\n+    private static final long EpDevice_Device$OFFSET = 2528;\n+\n@@ -6905,0 +32323,1 @@\n+     * Offset for field:\n@@ -6906,1 +32325,1 @@\n-     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)\n@@ -6909,20 +32328,2 @@\n-    private static class SetGlobalSpinControl {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long EpDevice_Device$offset() {\n+        return EpDevice_Device$OFFSET;\n@@ -6931,3 +32332,9 @@\n-    private static final AddressLayout SetGlobalSpinControl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalSpinControl\"));\n-\n-    private static final long SetGlobalSpinControl$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalSpinControl\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)\n+     * }\n+     *\/\n+    public static MemorySegment EpDevice_Device(MemorySegment struct) {\n+        return struct.get(EpDevice_Device$LAYOUT, EpDevice_Device$OFFSET);\n+    }\n@@ -6936,1 +32343,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -6938,1 +32345,1 @@\n-     * OrtStatusPtr (*SetGlobalSpinControl)(OrtThreadingOptions *, int)\n+     * const OrtHardwareDevice *(*EpDevice_Device)(const OrtEpDevice *)\n@@ -6941,3 +32348,2 @@\n-    public static MemorySegment SetGlobalSpinControl(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(SetGlobalSpinControl$LAYOUT, SetGlobalSpinControl$OFFSET);\n-        return SetGlobalSpinControl.invoke(funcPtr, _x0, _x1);\n+    public static void EpDevice_Device(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EpDevice_Device$LAYOUT, EpDevice_Device$OFFSET, fieldValue);\n@@ -6948,1 +32354,1 @@\n-     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * const OrtEpApi *(*GetEpApi)(void)\n@@ -6951,1 +32357,12 @@\n-    private static class AddInitializer {\n+    public static class GetEpApi {\n+\n+        GetEpApi() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply();\n+        }\n@@ -6954,5 +32371,18 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+            coreml_provider_factory_h.C_POINTER);\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetEpApi.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetEpApi.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -6965,1 +32395,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr) {\n@@ -6967,1 +32397,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n@@ -6974,3 +32404,1 @@\n-    private static final AddressLayout AddInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddInitializer\"));\n-\n-    private static final long AddInitializer$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddInitializer\"));\n+    private static final AddressLayout GetEpApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetEpApi\"));\n@@ -6979,1 +32407,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -6981,1 +32409,1 @@\n-     * OrtStatusPtr (*AddInitializer)(OrtSessionOptions *, const char *, const OrtValue *)\n+     * const OrtEpApi *(*GetEpApi)(void)\n@@ -6984,3 +32412,2 @@\n-    public static MemorySegment AddInitializer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(AddInitializer$LAYOUT, AddInitializer$OFFSET);\n-        return AddInitializer.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout GetEpApi$layout() {\n+        return GetEpApi$LAYOUT;\n@@ -6989,0 +32416,2 @@\n+    private static final long GetEpApi$OFFSET = 2536;\n+\n@@ -6990,0 +32419,1 @@\n+     * Offset for field:\n@@ -6991,1 +32421,1 @@\n-     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * const OrtEpApi *(*GetEpApi)(void)\n@@ -6994,24 +32424,2 @@\n-    private static class CreateEnvWithCustomLoggerAndGlobalThreadPools {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetEpApi$offset() {\n+        return GetEpApi$OFFSET;\n@@ -7020,3 +32428,9 @@\n-    private static final AddressLayout CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"));\n-\n-    private static final long CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateEnvWithCustomLoggerAndGlobalThreadPools\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtEpApi *(*GetEpApi)(void)\n+     * }\n+     *\/\n+    public static MemorySegment GetEpApi(MemorySegment struct) {\n+        return struct.get(GetEpApi$LAYOUT, GetEpApi$OFFSET);\n+    }\n@@ -7025,1 +32439,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7027,1 +32441,1 @@\n-     * OrtStatusPtr (*CreateEnvWithCustomLoggerAndGlobalThreadPools)(OrtLoggingFunction, void *, OrtLoggingLevel, const char *, const struct OrtThreadingOptions *, OrtEnv **)\n+     * const OrtEpApi *(*GetEpApi)(void)\n@@ -7030,3 +32444,2 @@\n-    public static MemorySegment CreateEnvWithCustomLoggerAndGlobalThreadPools(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n-        var funcPtr = struct.get(CreateEnvWithCustomLoggerAndGlobalThreadPools$LAYOUT, CreateEnvWithCustomLoggerAndGlobalThreadPools$OFFSET);\n-        return CreateEnvWithCustomLoggerAndGlobalThreadPools.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    public static void GetEpApi(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetEpApi$LAYOUT, GetEpApi$OFFSET, fieldValue);\n@@ -7037,1 +32450,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)\n@@ -7040,1 +32453,12 @@\n-    private static class SessionOptionsAppendExecutionProvider_CUDA {\n+    public static class GetTensorSizeInBytes {\n+\n+        GetTensorSizeInBytes() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7043,3 +32467,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7048,0 +32472,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorSizeInBytes.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorSizeInBytes.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7062,3 +32503,1 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_CUDA$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA\"));\n+    private static final AddressLayout GetTensorSizeInBytes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorSizeInBytes\"));\n@@ -7067,1 +32506,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7069,1 +32508,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA)(OrtSessionOptions *, const OrtCUDAProviderOptions *)\n+     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)\n@@ -7072,3 +32511,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CUDA$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_CUDA.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout GetTensorSizeInBytes$layout() {\n+        return GetTensorSizeInBytes$LAYOUT;\n@@ -7077,0 +32515,2 @@\n+    private static final long GetTensorSizeInBytes$OFFSET = 2544;\n+\n@@ -7078,0 +32518,1 @@\n+     * Offset for field:\n@@ -7079,1 +32520,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)\n@@ -7082,20 +32523,2 @@\n-    private static class SessionOptionsAppendExecutionProvider_ROCM {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetTensorSizeInBytes$offset() {\n+        return GetTensorSizeInBytes$OFFSET;\n@@ -7104,3 +32527,9 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_ROCM$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_ROCM\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_ROCM$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_ROCM\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorSizeInBytes(MemorySegment struct) {\n+        return struct.get(GetTensorSizeInBytes$LAYOUT, GetTensorSizeInBytes$OFFSET);\n+    }\n@@ -7109,1 +32538,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7111,1 +32540,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_ROCM)(OrtSessionOptions *, const OrtROCMProviderOptions *)\n+     * OrtStatusPtr (*GetTensorSizeInBytes)(const OrtValue *, size_t *)\n@@ -7114,3 +32543,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_ROCM(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_ROCM$LAYOUT, SessionOptionsAppendExecutionProvider_ROCM$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_ROCM.invoke(funcPtr, _x0, _x1);\n+    public static void GetTensorSizeInBytes(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorSizeInBytes$LAYOUT, GetTensorSizeInBytes$OFFSET, fieldValue);\n@@ -7121,1 +32549,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)\n@@ -7124,1 +32552,12 @@\n-    private static class SessionOptionsAppendExecutionProvider_OpenVINO {\n+    public static class AllocatorGetStats {\n+\n+        AllocatorGetStats() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7127,3 +32566,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7132,0 +32571,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(AllocatorGetStats.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AllocatorGetStats.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7146,1 +32602,23 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO\"));\n+    private static final AddressLayout AllocatorGetStats$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AllocatorGetStats\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static final AddressLayout AllocatorGetStats$layout() {\n+        return AllocatorGetStats$LAYOUT;\n+    }\n+\n+    private static final long AllocatorGetStats$OFFSET = 2552;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static final long AllocatorGetStats$offset() {\n+        return AllocatorGetStats$OFFSET;\n+    }\n@@ -7148,1 +32626,9 @@\n-    private static final long SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static MemorySegment AllocatorGetStats(MemorySegment struct) {\n+        return struct.get(AllocatorGetStats$LAYOUT, AllocatorGetStats$OFFSET);\n+    }\n@@ -7151,1 +32637,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7153,1 +32639,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO)(OrtSessionOptions *, const OrtOpenVINOProviderOptions *)\n+     * OrtStatusPtr (*AllocatorGetStats)(const OrtAllocator *, OrtKeyValuePairs **)\n@@ -7156,3 +32642,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_OpenVINO$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_OpenVINO.invoke(funcPtr, _x0, _x1);\n+    public static void AllocatorGetStats(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AllocatorGetStats$LAYOUT, AllocatorGetStats$OFFSET, fieldValue);\n@@ -7163,1 +32648,1 @@\n-     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)\n@@ -7166,1 +32651,12 @@\n-    private static class SetGlobalDenormalAsZero {\n+    public static class CreateMemoryInfo_V2 {\n+\n+        CreateMemoryInfo_V2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, long _x5, int _x6, MemorySegment _x7);\n+        }\n@@ -7169,2 +32665,9 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7173,0 +32676,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateMemoryInfo_V2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateMemoryInfo_V2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7178,1 +32698,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, int _x3, int _x4, long _x5, int _x6, MemorySegment _x7) {\n@@ -7180,1 +32700,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n@@ -7187,1 +32707,11 @@\n-    private static final AddressLayout SetGlobalDenormalAsZero$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalDenormalAsZero\"));\n+    private static final AddressLayout CreateMemoryInfo_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateMemoryInfo_V2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateMemoryInfo_V2$layout() {\n+        return CreateMemoryInfo_V2$LAYOUT;\n+    }\n@@ -7189,1 +32719,1 @@\n-    private static final long SetGlobalDenormalAsZero$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalDenormalAsZero\"));\n+    private static final long CreateMemoryInfo_V2$OFFSET = 2560;\n@@ -7192,1 +32722,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -7194,1 +32724,1 @@\n-     * OrtStatusPtr (*SetGlobalDenormalAsZero)(OrtThreadingOptions *)\n+     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)\n@@ -7197,3 +32727,2 @@\n-    public static MemorySegment SetGlobalDenormalAsZero(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(SetGlobalDenormalAsZero$LAYOUT, SetGlobalDenormalAsZero$OFFSET);\n-        return SetGlobalDenormalAsZero.invoke(funcPtr, _x0);\n+    public static final long CreateMemoryInfo_V2$offset() {\n+        return CreateMemoryInfo_V2$OFFSET;\n@@ -7203,0 +32732,1 @@\n+     * Getter for field:\n@@ -7204,1 +32734,11 @@\n-     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateMemoryInfo_V2(MemorySegment struct) {\n+        return struct.get(CreateMemoryInfo_V2$LAYOUT, CreateMemoryInfo_V2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMemoryInfo_V2)(const char *, enum OrtMemoryInfoDeviceType, uint32_t, int32_t, enum OrtDeviceMemoryType, size_t, enum OrtAllocatorType, OrtMemoryInfo **)\n@@ -7207,1 +32747,21 @@\n-    private static class CreateArenaCfg {\n+    public static void CreateMemoryInfo_V2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateMemoryInfo_V2$LAYOUT, CreateMemoryInfo_V2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static class MemoryInfoGetDeviceMemType {\n+\n+        MemoryInfoGetDeviceMemType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n@@ -7210,6 +32770,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7218,0 +32774,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetDeviceMemType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetDeviceMemType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7223,1 +32796,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -7225,1 +32798,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -7232,3 +32805,1 @@\n-    private static final AddressLayout CreateArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateArenaCfg\"));\n-\n-    private static final long CreateArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateArenaCfg\"));\n+    private static final AddressLayout MemoryInfoGetDeviceMemType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetDeviceMemType\"));\n@@ -7237,1 +32808,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7239,1 +32810,1 @@\n-     * OrtStatusPtr (*CreateArenaCfg)(size_t, int, int, int, OrtArenaCfg **)\n+     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)\n@@ -7242,3 +32813,2 @@\n-    public static MemorySegment CreateArenaCfg(MemorySegment struct, long _x0, int _x1, int _x2, int _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateArenaCfg$LAYOUT, CreateArenaCfg$OFFSET);\n-        return CreateArenaCfg.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout MemoryInfoGetDeviceMemType$layout() {\n+        return MemoryInfoGetDeviceMemType$LAYOUT;\n@@ -7247,0 +32817,2 @@\n+    private static final long MemoryInfoGetDeviceMemType$OFFSET = 2568;\n+\n@@ -7248,0 +32820,1 @@\n+     * Offset for field:\n@@ -7249,1 +32822,1 @@\n-     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)\n@@ -7252,18 +32825,2 @@\n-    private static class ReleaseArenaCfg {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long MemoryInfoGetDeviceMemType$offset() {\n+        return MemoryInfoGetDeviceMemType$OFFSET;\n@@ -7272,3 +32829,9 @@\n-    private static final AddressLayout ReleaseArenaCfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseArenaCfg\"));\n-\n-    private static final long ReleaseArenaCfg$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseArenaCfg\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetDeviceMemType(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetDeviceMemType$LAYOUT, MemoryInfoGetDeviceMemType$OFFSET);\n+    }\n@@ -7277,1 +32840,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7279,1 +32842,1 @@\n-     * void (*ReleaseArenaCfg)(OrtArenaCfg *)\n+     * OrtDeviceMemoryType (*MemoryInfoGetDeviceMemType)(const OrtMemoryInfo *)\n@@ -7282,3 +32845,2 @@\n-    public static void ReleaseArenaCfg(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseArenaCfg$LAYOUT, ReleaseArenaCfg$OFFSET);\n-        ReleaseArenaCfg.invoke(funcPtr, _x0);\n+    public static void MemoryInfoGetDeviceMemType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetDeviceMemType$LAYOUT, MemoryInfoGetDeviceMemType$OFFSET, fieldValue);\n@@ -7289,1 +32851,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)\n@@ -7292,1 +32854,12 @@\n-    private static class ModelMetadataGetGraphDescription {\n+    public static class MemoryInfoGetVendorId {\n+\n+        MemoryInfoGetVendorId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n@@ -7295,4 +32868,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7301,0 +32872,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(MemoryInfoGetVendorId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(MemoryInfoGetVendorId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7306,1 +32894,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -7308,1 +32896,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -7315,3 +32903,1 @@\n-    private static final AddressLayout ModelMetadataGetGraphDescription$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelMetadataGetGraphDescription\"));\n-\n-    private static final long ModelMetadataGetGraphDescription$OFFSET = $LAYOUT.byteOffset(groupElement(\"ModelMetadataGetGraphDescription\"));\n+    private static final AddressLayout MemoryInfoGetVendorId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetVendorId\"));\n@@ -7320,1 +32906,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7322,1 +32908,1 @@\n-     * OrtStatusPtr (*ModelMetadataGetGraphDescription)(const OrtModelMetadata *, OrtAllocator *, char **)\n+     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)\n@@ -7325,3 +32911,2 @@\n-    public static MemorySegment ModelMetadataGetGraphDescription(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ModelMetadataGetGraphDescription$LAYOUT, ModelMetadataGetGraphDescription$OFFSET);\n-        return ModelMetadataGetGraphDescription.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout MemoryInfoGetVendorId$layout() {\n+        return MemoryInfoGetVendorId$LAYOUT;\n@@ -7330,0 +32915,2 @@\n+    private static final long MemoryInfoGetVendorId$OFFSET = 2576;\n+\n@@ -7331,0 +32918,1 @@\n+     * Offset for field:\n@@ -7332,1 +32920,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)\n@@ -7335,20 +32923,2 @@\n-    private static class SessionOptionsAppendExecutionProvider_TensorRT {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long MemoryInfoGetVendorId$offset() {\n+        return MemoryInfoGetVendorId$OFFSET;\n@@ -7357,3 +32927,9 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_TensorRT$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment MemoryInfoGetVendorId(MemorySegment struct) {\n+        return struct.get(MemoryInfoGetVendorId$LAYOUT, MemoryInfoGetVendorId$OFFSET);\n+    }\n@@ -7362,1 +32938,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7364,1 +32940,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT)(OrtSessionOptions *, const OrtTensorRTProviderOptions *)\n+     * uint32_t (*MemoryInfoGetVendorId)(const OrtMemoryInfo *)\n@@ -7367,3 +32943,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_TensorRT$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_TensorRT.invoke(funcPtr, _x0, _x1);\n+    public static void MemoryInfoGetVendorId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(MemoryInfoGetVendorId$LAYOUT, MemoryInfoGetVendorId$OFFSET, fieldValue);\n@@ -7374,1 +32949,1 @@\n-     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)\n@@ -7377,1 +32952,12 @@\n-    private static class SetCurrentGpuDeviceId {\n+    public static class ValueInfo_GetValueProducer {\n+\n+        ValueInfo_GetValueProducer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -7380,2 +32966,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7384,0 +32972,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_GetValueProducer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_GetValueProducer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7389,1 +32994,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -7391,1 +32996,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -7398,3 +33003,1 @@\n-    private static final AddressLayout SetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetCurrentGpuDeviceId\"));\n-\n-    private static final long SetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetCurrentGpuDeviceId\"));\n+    private static final AddressLayout ValueInfo_GetValueProducer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_GetValueProducer\"));\n@@ -7403,1 +33006,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7405,1 +33008,1 @@\n-     * OrtStatusPtr (*SetCurrentGpuDeviceId)(int)\n+     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)\n@@ -7408,3 +33011,2 @@\n-    public static MemorySegment SetCurrentGpuDeviceId(MemorySegment struct, int _x0) {\n-        var funcPtr = struct.get(SetCurrentGpuDeviceId$LAYOUT, SetCurrentGpuDeviceId$OFFSET);\n-        return SetCurrentGpuDeviceId.invoke(funcPtr, _x0);\n+    public static final AddressLayout ValueInfo_GetValueProducer$layout() {\n+        return ValueInfo_GetValueProducer$LAYOUT;\n@@ -7413,0 +33015,2 @@\n+    private static final long ValueInfo_GetValueProducer$OFFSET = 2584;\n+\n@@ -7414,0 +33018,1 @@\n+     * Offset for field:\n@@ -7415,1 +33020,1 @@\n-     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)\n@@ -7418,19 +33023,2 @@\n-    private static class GetCurrentGpuDeviceId {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_GetValueProducer$offset() {\n+        return ValueInfo_GetValueProducer$OFFSET;\n@@ -7439,3 +33027,9 @@\n-    private static final AddressLayout GetCurrentGpuDeviceId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCurrentGpuDeviceId\"));\n-\n-    private static final long GetCurrentGpuDeviceId$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCurrentGpuDeviceId\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_GetValueProducer(MemorySegment struct) {\n+        return struct.get(ValueInfo_GetValueProducer$LAYOUT, ValueInfo_GetValueProducer$OFFSET);\n+    }\n@@ -7444,1 +33038,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7446,1 +33040,1 @@\n-     * OrtStatusPtr (*GetCurrentGpuDeviceId)(int *)\n+     * OrtStatusPtr (*ValueInfo_GetValueProducer)(const OrtValueInfo *, const OrtNode **, size_t *)\n@@ -7449,3 +33043,2 @@\n-    public static MemorySegment GetCurrentGpuDeviceId(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(GetCurrentGpuDeviceId$LAYOUT, GetCurrentGpuDeviceId$OFFSET);\n-        return GetCurrentGpuDeviceId.invoke(funcPtr, _x0);\n+    public static void ValueInfo_GetValueProducer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_GetValueProducer$LAYOUT, ValueInfo_GetValueProducer$OFFSET, fieldValue);\n@@ -7456,1 +33049,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)\n@@ -7459,1 +33052,12 @@\n-    private static class KernelInfoGetAttributeArray_float {\n+    public static class ValueInfo_GetValueNumConsumers {\n+\n+        ValueInfo_GetValueNumConsumers() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7462,5 +33066,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7469,0 +33071,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_GetValueNumConsumers.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_GetValueNumConsumers.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7474,1 +33093,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -7476,1 +33095,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -7483,3 +33102,1 @@\n-    private static final AddressLayout KernelInfoGetAttributeArray_float$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttributeArray_float\"));\n-\n-    private static final long KernelInfoGetAttributeArray_float$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttributeArray_float\"));\n+    private static final AddressLayout ValueInfo_GetValueNumConsumers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_GetValueNumConsumers\"));\n@@ -7488,1 +33105,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7490,1 +33107,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttributeArray_float)(const OrtKernelInfo *, const char *, float *, size_t *)\n+     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)\n@@ -7493,3 +33110,2 @@\n-    public static MemorySegment KernelInfoGetAttributeArray_float(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfoGetAttributeArray_float$LAYOUT, KernelInfoGetAttributeArray_float$OFFSET);\n-        return KernelInfoGetAttributeArray_float.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout ValueInfo_GetValueNumConsumers$layout() {\n+        return ValueInfo_GetValueNumConsumers$LAYOUT;\n@@ -7498,0 +33114,2 @@\n+    private static final long ValueInfo_GetValueNumConsumers$OFFSET = 2592;\n+\n@@ -7499,0 +33117,1 @@\n+     * Offset for field:\n@@ -7500,1 +33119,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)\n@@ -7503,22 +33122,2 @@\n-    private static class KernelInfoGetAttributeArray_int64 {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_GetValueNumConsumers$offset() {\n+        return ValueInfo_GetValueNumConsumers$OFFSET;\n@@ -7527,3 +33126,9 @@\n-    private static final AddressLayout KernelInfoGetAttributeArray_int64$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttributeArray_int64\"));\n-\n-    private static final long KernelInfoGetAttributeArray_int64$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttributeArray_int64\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_GetValueNumConsumers(MemorySegment struct) {\n+        return struct.get(ValueInfo_GetValueNumConsumers$LAYOUT, ValueInfo_GetValueNumConsumers$OFFSET);\n+    }\n@@ -7532,1 +33137,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7534,1 +33139,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttributeArray_int64)(const OrtKernelInfo *, const char *, int64_t *, size_t *)\n+     * OrtStatusPtr (*ValueInfo_GetValueNumConsumers)(const OrtValueInfo *, size_t *)\n@@ -7537,3 +33142,2 @@\n-    public static MemorySegment KernelInfoGetAttributeArray_int64(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfoGetAttributeArray_int64$LAYOUT, KernelInfoGetAttributeArray_int64$OFFSET);\n-        return KernelInfoGetAttributeArray_int64.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void ValueInfo_GetValueNumConsumers(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_GetValueNumConsumers$LAYOUT, ValueInfo_GetValueNumConsumers$OFFSET, fieldValue);\n@@ -7544,1 +33148,1 @@\n-     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)\n@@ -7547,1 +33151,12 @@\n-    private static class CreateArenaCfgV2 {\n+    public static class ValueInfo_GetValueConsumers {\n+\n+        ValueInfo_GetValueConsumers() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n@@ -7550,5 +33165,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -7557,0 +33172,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_GetValueConsumers.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_GetValueConsumers.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7562,1 +33194,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n@@ -7571,3 +33203,1 @@\n-    private static final AddressLayout CreateArenaCfgV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateArenaCfgV2\"));\n-\n-    private static final long CreateArenaCfgV2$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateArenaCfgV2\"));\n+    private static final AddressLayout ValueInfo_GetValueConsumers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_GetValueConsumers\"));\n@@ -7576,1 +33206,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7578,1 +33208,1 @@\n-     * OrtStatusPtr (*CreateArenaCfgV2)(const char *const *, const size_t *, size_t, OrtArenaCfg **)\n+     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)\n@@ -7581,3 +33211,2 @@\n-    public static MemorySegment CreateArenaCfgV2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(CreateArenaCfgV2$LAYOUT, CreateArenaCfgV2$OFFSET);\n-        return CreateArenaCfgV2.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout ValueInfo_GetValueConsumers$layout() {\n+        return ValueInfo_GetValueConsumers$LAYOUT;\n@@ -7586,0 +33215,2 @@\n+    private static final long ValueInfo_GetValueConsumers$OFFSET = 2600;\n+\n@@ -7587,0 +33218,1 @@\n+     * Offset for field:\n@@ -7588,1 +33220,1 @@\n-     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)\n@@ -7591,21 +33223,2 @@\n-    private static class AddRunConfigEntry {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_GetValueConsumers$offset() {\n+        return ValueInfo_GetValueConsumers$OFFSET;\n@@ -7614,3 +33227,9 @@\n-    private static final AddressLayout AddRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddRunConfigEntry\"));\n-\n-    private static final long AddRunConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddRunConfigEntry\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_GetValueConsumers(MemorySegment struct) {\n+        return struct.get(ValueInfo_GetValueConsumers$LAYOUT, ValueInfo_GetValueConsumers$OFFSET);\n+    }\n@@ -7619,1 +33238,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7621,1 +33240,1 @@\n-     * OrtStatusPtr (*AddRunConfigEntry)(OrtRunOptions *, const char *, const char *)\n+     * OrtStatusPtr (*ValueInfo_GetValueConsumers)(const OrtValueInfo *, const OrtNode **, int64_t *, size_t)\n@@ -7624,3 +33243,2 @@\n-    public static MemorySegment AddRunConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(AddRunConfigEntry$LAYOUT, AddRunConfigEntry$OFFSET);\n-        return AddRunConfigEntry.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void ValueInfo_GetValueConsumers(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_GetValueConsumers$LAYOUT, ValueInfo_GetValueConsumers$OFFSET, fieldValue);\n@@ -7631,1 +33249,1 @@\n-     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)\n@@ -7634,1 +33252,12 @@\n-    private static class CreatePrepackedWeightsContainer {\n+    public static class ValueInfo_GetInitializerValue {\n+\n+        ValueInfo_GetInitializerValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7637,2 +33266,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7641,0 +33271,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_GetInitializerValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_GetInitializerValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7646,1 +33293,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -7648,1 +33295,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -7655,3 +33302,1 @@\n-    private static final AddressLayout CreatePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreatePrepackedWeightsContainer\"));\n-\n-    private static final long CreatePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreatePrepackedWeightsContainer\"));\n+    private static final AddressLayout ValueInfo_GetInitializerValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_GetInitializerValue\"));\n@@ -7660,1 +33305,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7662,1 +33307,1 @@\n-     * OrtStatusPtr (*CreatePrepackedWeightsContainer)(OrtPrepackedWeightsContainer **)\n+     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)\n@@ -7665,3 +33310,2 @@\n-    public static MemorySegment CreatePrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreatePrepackedWeightsContainer$LAYOUT, CreatePrepackedWeightsContainer$OFFSET);\n-        return CreatePrepackedWeightsContainer.invoke(funcPtr, _x0);\n+    public static final AddressLayout ValueInfo_GetInitializerValue$layout() {\n+        return ValueInfo_GetInitializerValue$LAYOUT;\n@@ -7670,0 +33314,2 @@\n+    private static final long ValueInfo_GetInitializerValue$OFFSET = 2608;\n+\n@@ -7671,0 +33317,1 @@\n+     * Offset for field:\n@@ -7672,1 +33319,1 @@\n-     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)\n@@ -7675,18 +33322,2 @@\n-    private static class ReleasePrepackedWeightsContainer {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_GetInitializerValue$offset() {\n+        return ValueInfo_GetInitializerValue$OFFSET;\n@@ -7695,3 +33326,9 @@\n-    private static final AddressLayout ReleasePrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleasePrepackedWeightsContainer\"));\n-\n-    private static final long ReleasePrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleasePrepackedWeightsContainer\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_GetInitializerValue(MemorySegment struct) {\n+        return struct.get(ValueInfo_GetInitializerValue$LAYOUT, ValueInfo_GetInitializerValue$OFFSET);\n+    }\n@@ -7700,1 +33337,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7702,1 +33339,1 @@\n-     * void (*ReleasePrepackedWeightsContainer)(OrtPrepackedWeightsContainer *)\n+     * OrtStatusPtr (*ValueInfo_GetInitializerValue)(const OrtValueInfo *, const OrtValue **)\n@@ -7705,3 +33342,2 @@\n-    public static void ReleasePrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleasePrepackedWeightsContainer$LAYOUT, ReleasePrepackedWeightsContainer$OFFSET);\n-        ReleasePrepackedWeightsContainer.invoke(funcPtr, _x0);\n+    public static void ValueInfo_GetInitializerValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_GetInitializerValue$LAYOUT, ValueInfo_GetInitializerValue$OFFSET, fieldValue);\n@@ -7712,1 +33348,1 @@\n-     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)\n@@ -7715,1 +33351,12 @@\n-    private static class CreateSessionWithPrepackedWeightsContainer {\n+    public static class ValueInfo_GetExternalInitializerInfo {\n+\n+        ValueInfo_GetExternalInitializerInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7718,6 +33365,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7726,0 +33370,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_GetExternalInitializerInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_GetExternalInitializerInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7731,1 +33392,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -7733,1 +33394,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -7740,3 +33401,1 @@\n-    private static final AddressLayout CreateSessionWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionWithPrepackedWeightsContainer\"));\n-\n-    private static final long CreateSessionWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionWithPrepackedWeightsContainer\"));\n+    private static final AddressLayout ValueInfo_GetExternalInitializerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_GetExternalInitializerInfo\"));\n@@ -7745,1 +33404,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7747,1 +33406,1 @@\n-     * OrtStatusPtr (*CreateSessionWithPrepackedWeightsContainer)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)\n@@ -7750,3 +33409,2 @@\n-    public static MemorySegment CreateSessionWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateSessionWithPrepackedWeightsContainer$LAYOUT, CreateSessionWithPrepackedWeightsContainer$OFFSET);\n-        return CreateSessionWithPrepackedWeightsContainer.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout ValueInfo_GetExternalInitializerInfo$layout() {\n+        return ValueInfo_GetExternalInitializerInfo$LAYOUT;\n@@ -7755,0 +33413,2 @@\n+    private static final long ValueInfo_GetExternalInitializerInfo$OFFSET = 2616;\n+\n@@ -7756,0 +33416,1 @@\n+     * Offset for field:\n@@ -7757,1 +33418,1 @@\n-     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)\n@@ -7760,24 +33421,2 @@\n-    private static class CreateSessionFromArrayWithPrepackedWeightsContainer {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_GetExternalInitializerInfo$offset() {\n+        return ValueInfo_GetExternalInitializerInfo$OFFSET;\n@@ -7786,3 +33425,9 @@\n-    private static final AddressLayout CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"));\n-\n-    private static final long CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSessionFromArrayWithPrepackedWeightsContainer\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_GetExternalInitializerInfo(MemorySegment struct) {\n+        return struct.get(ValueInfo_GetExternalInitializerInfo$LAYOUT, ValueInfo_GetExternalInitializerInfo$OFFSET);\n+    }\n@@ -7791,1 +33436,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7793,1 +33438,1 @@\n-     * OrtStatusPtr (*CreateSessionFromArrayWithPrepackedWeightsContainer)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtPrepackedWeightsContainer *, OrtSession **)\n+     * OrtStatusPtr (*ValueInfo_GetExternalInitializerInfo)(const OrtValueInfo *, OrtExternalInitializerInfo **)\n@@ -7796,3 +33441,2 @@\n-    public static MemorySegment CreateSessionFromArrayWithPrepackedWeightsContainer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5) {\n-        var funcPtr = struct.get(CreateSessionFromArrayWithPrepackedWeightsContainer$LAYOUT, CreateSessionFromArrayWithPrepackedWeightsContainer$OFFSET);\n-        return CreateSessionFromArrayWithPrepackedWeightsContainer.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    public static void ValueInfo_GetExternalInitializerInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_GetExternalInitializerInfo$LAYOUT, ValueInfo_GetExternalInitializerInfo$OFFSET, fieldValue);\n@@ -7803,1 +33447,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)\n@@ -7806,1 +33450,12 @@\n-    private static class SessionOptionsAppendExecutionProvider_TensorRT_V2 {\n+    public static class ValueInfo_IsRequiredGraphInput {\n+\n+        ValueInfo_IsRequiredGraphInput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7809,3 +33464,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7814,0 +33469,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_IsRequiredGraphInput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_IsRequiredGraphInput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7828,3 +33500,1 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_TensorRT_V2\"));\n+    private static final AddressLayout ValueInfo_IsRequiredGraphInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_IsRequiredGraphInput\"));\n@@ -7833,1 +33503,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7835,1 +33505,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_TensorRT_V2)(OrtSessionOptions *, const OrtTensorRTProviderOptionsV2 *)\n+     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)\n@@ -7838,3 +33508,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_TensorRT_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_TensorRT_V2$LAYOUT, SessionOptionsAppendExecutionProvider_TensorRT_V2$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_TensorRT_V2.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout ValueInfo_IsRequiredGraphInput$layout() {\n+        return ValueInfo_IsRequiredGraphInput$LAYOUT;\n@@ -7843,0 +33512,2 @@\n+    private static final long ValueInfo_IsRequiredGraphInput$OFFSET = 2624;\n+\n@@ -7844,0 +33515,1 @@\n+     * Offset for field:\n@@ -7845,1 +33517,1 @@\n-     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)\n@@ -7848,19 +33520,2 @@\n-    private static class CreateTensorRTProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_IsRequiredGraphInput$offset() {\n+        return ValueInfo_IsRequiredGraphInput$OFFSET;\n@@ -7869,3 +33524,9 @@\n-    private static final AddressLayout CreateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorRTProviderOptions\"));\n-\n-    private static final long CreateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateTensorRTProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_IsRequiredGraphInput(MemorySegment struct) {\n+        return struct.get(ValueInfo_IsRequiredGraphInput$LAYOUT, ValueInfo_IsRequiredGraphInput$OFFSET);\n+    }\n@@ -7874,1 +33535,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -7876,1 +33537,1 @@\n-     * OrtStatusPtr (*CreateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 **)\n+     * OrtStatusPtr (*ValueInfo_IsRequiredGraphInput)(const OrtValueInfo *, bool *)\n@@ -7879,3 +33540,2 @@\n-    public static MemorySegment CreateTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateTensorRTProviderOptions$LAYOUT, CreateTensorRTProviderOptions$OFFSET);\n-        return CreateTensorRTProviderOptions.invoke(funcPtr, _x0);\n+    public static void ValueInfo_IsRequiredGraphInput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_IsRequiredGraphInput$LAYOUT, ValueInfo_IsRequiredGraphInput$OFFSET, fieldValue);\n@@ -7886,1 +33546,1 @@\n-     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)\n@@ -7889,1 +33549,12 @@\n-    private static class UpdateTensorRTProviderOptions {\n+    public static class ValueInfo_IsOptionalGraphInput {\n+\n+        ValueInfo_IsOptionalGraphInput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7892,5 +33563,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7899,0 +33568,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_IsOptionalGraphInput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_IsOptionalGraphInput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7904,1 +33590,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -7906,1 +33592,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -7913,1 +33599,11 @@\n-    private static final AddressLayout UpdateTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateTensorRTProviderOptions\"));\n+    private static final AddressLayout ValueInfo_IsOptionalGraphInput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_IsOptionalGraphInput\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static final AddressLayout ValueInfo_IsOptionalGraphInput$layout() {\n+        return ValueInfo_IsOptionalGraphInput$LAYOUT;\n+    }\n@@ -7915,1 +33611,1 @@\n-    private static final long UpdateTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateTensorRTProviderOptions\"));\n+    private static final long ValueInfo_IsOptionalGraphInput$OFFSET = 2632;\n@@ -7918,1 +33614,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -7920,1 +33616,1 @@\n-     * OrtStatusPtr (*UpdateTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)\n@@ -7923,3 +33619,2 @@\n-    public static MemorySegment UpdateTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(UpdateTensorRTProviderOptions$LAYOUT, UpdateTensorRTProviderOptions$OFFSET);\n-        return UpdateTensorRTProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final long ValueInfo_IsOptionalGraphInput$offset() {\n+        return ValueInfo_IsOptionalGraphInput$OFFSET;\n@@ -7929,0 +33624,1 @@\n+     * Getter for field:\n@@ -7930,1 +33626,20 @@\n-     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_IsOptionalGraphInput(MemorySegment struct) {\n+        return struct.get(ValueInfo_IsOptionalGraphInput$LAYOUT, ValueInfo_IsOptionalGraphInput$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsOptionalGraphInput)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static void ValueInfo_IsOptionalGraphInput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_IsOptionalGraphInput$LAYOUT, ValueInfo_IsOptionalGraphInput$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)\n@@ -7933,1 +33648,12 @@\n-    private static class GetTensorRTProviderOptionsAsString {\n+    public static class ValueInfo_IsGraphOutput {\n+\n+        ValueInfo_IsGraphOutput() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -7936,4 +33662,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -7942,0 +33667,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_IsGraphOutput.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_IsGraphOutput.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -7947,1 +33689,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -7949,1 +33691,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -7956,3 +33698,1 @@\n-    private static final AddressLayout GetTensorRTProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorRTProviderOptionsAsString\"));\n-\n-    private static final long GetTensorRTProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorRTProviderOptionsAsString\"));\n+    private static final AddressLayout ValueInfo_IsGraphOutput$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_IsGraphOutput\"));\n@@ -7961,1 +33701,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -7963,1 +33703,1 @@\n-     * OrtStatusPtr (*GetTensorRTProviderOptionsAsString)(const OrtTensorRTProviderOptionsV2 *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)\n@@ -7966,3 +33706,2 @@\n-    public static MemorySegment GetTensorRTProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetTensorRTProviderOptionsAsString$LAYOUT, GetTensorRTProviderOptionsAsString$OFFSET);\n-        return GetTensorRTProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout ValueInfo_IsGraphOutput$layout() {\n+        return ValueInfo_IsGraphOutput$LAYOUT;\n@@ -7971,0 +33710,2 @@\n+    private static final long ValueInfo_IsGraphOutput$OFFSET = 2640;\n+\n@@ -7972,0 +33713,1 @@\n+     * Offset for field:\n@@ -7973,1 +33715,1 @@\n-     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)\n@@ -7976,18 +33718,2 @@\n-    private static class ReleaseTensorRTProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_IsGraphOutput$offset() {\n+        return ValueInfo_IsGraphOutput$OFFSET;\n@@ -7996,3 +33722,9 @@\n-    private static final AddressLayout ReleaseTensorRTProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseTensorRTProviderOptions\"));\n-\n-    private static final long ReleaseTensorRTProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseTensorRTProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_IsGraphOutput(MemorySegment struct) {\n+        return struct.get(ValueInfo_IsGraphOutput$LAYOUT, ValueInfo_IsGraphOutput$OFFSET);\n+    }\n@@ -8001,1 +33733,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8003,1 +33735,1 @@\n-     * void (*ReleaseTensorRTProviderOptions)(OrtTensorRTProviderOptionsV2 *)\n+     * OrtStatusPtr (*ValueInfo_IsGraphOutput)(const OrtValueInfo *, bool *)\n@@ -8006,3 +33738,2 @@\n-    public static void ReleaseTensorRTProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseTensorRTProviderOptions$LAYOUT, ReleaseTensorRTProviderOptions$OFFSET);\n-        ReleaseTensorRTProviderOptions.invoke(funcPtr, _x0);\n+    public static void ValueInfo_IsGraphOutput(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_IsGraphOutput$LAYOUT, ValueInfo_IsGraphOutput$OFFSET, fieldValue);\n@@ -8013,1 +33744,1 @@\n-     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)\n@@ -8016,1 +33747,12 @@\n-    private static class EnableOrtCustomOps {\n+    public static class ValueInfo_IsConstantInitializer {\n+\n+        ValueInfo_IsConstantInitializer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8019,2 +33761,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8023,0 +33766,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_IsConstantInitializer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_IsConstantInitializer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8028,1 +33788,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -8030,1 +33790,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -8037,3 +33797,1 @@\n-    private static final AddressLayout EnableOrtCustomOps$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EnableOrtCustomOps\"));\n-\n-    private static final long EnableOrtCustomOps$OFFSET = $LAYOUT.byteOffset(groupElement(\"EnableOrtCustomOps\"));\n+    private static final AddressLayout ValueInfo_IsConstantInitializer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_IsConstantInitializer\"));\n@@ -8042,1 +33800,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8044,1 +33802,1 @@\n-     * OrtStatusPtr (*EnableOrtCustomOps)(OrtSessionOptions *)\n+     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)\n@@ -8047,3 +33805,2 @@\n-    public static MemorySegment EnableOrtCustomOps(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(EnableOrtCustomOps$LAYOUT, EnableOrtCustomOps$OFFSET);\n-        return EnableOrtCustomOps.invoke(funcPtr, _x0);\n+    public static final AddressLayout ValueInfo_IsConstantInitializer$layout() {\n+        return ValueInfo_IsConstantInitializer$LAYOUT;\n@@ -8052,0 +33809,2 @@\n+    private static final long ValueInfo_IsConstantInitializer$OFFSET = 2648;\n+\n@@ -8053,0 +33812,1 @@\n+     * Offset for field:\n@@ -8054,1 +33814,1 @@\n-     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)\n@@ -8057,20 +33817,2 @@\n-    private static class RegisterAllocator {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ValueInfo_IsConstantInitializer$offset() {\n+        return ValueInfo_IsConstantInitializer$OFFSET;\n@@ -8079,3 +33821,9 @@\n-    private static final AddressLayout RegisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterAllocator\"));\n-\n-    private static final long RegisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterAllocator\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_IsConstantInitializer(MemorySegment struct) {\n+        return struct.get(ValueInfo_IsConstantInitializer$LAYOUT, ValueInfo_IsConstantInitializer$OFFSET);\n+    }\n@@ -8084,1 +33832,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8086,1 +33834,1 @@\n-     * OrtStatusPtr (*RegisterAllocator)(OrtEnv *, OrtAllocator *)\n+     * OrtStatusPtr (*ValueInfo_IsConstantInitializer)(const OrtValueInfo *, bool *)\n@@ -8089,3 +33837,2 @@\n-    public static MemorySegment RegisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RegisterAllocator$LAYOUT, RegisterAllocator$OFFSET);\n-        return RegisterAllocator.invoke(funcPtr, _x0, _x1);\n+    public static void ValueInfo_IsConstantInitializer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_IsConstantInitializer$LAYOUT, ValueInfo_IsConstantInitializer$OFFSET, fieldValue);\n@@ -8096,1 +33843,1 @@\n-     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)\n@@ -8099,1 +33846,12 @@\n-    private static class UnregisterAllocator {\n+    public static class ValueInfo_IsFromOuterScope {\n+\n+        ValueInfo_IsFromOuterScope() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8102,3 +33860,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8107,0 +33865,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ValueInfo_IsFromOuterScope.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ValueInfo_IsFromOuterScope.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8121,1 +33896,11 @@\n-    private static final AddressLayout UnregisterAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UnregisterAllocator\"));\n+    private static final AddressLayout ValueInfo_IsFromOuterScope$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ValueInfo_IsFromOuterScope\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static final AddressLayout ValueInfo_IsFromOuterScope$layout() {\n+        return ValueInfo_IsFromOuterScope$LAYOUT;\n+    }\n@@ -8123,1 +33908,1 @@\n-    private static final long UnregisterAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"UnregisterAllocator\"));\n+    private static final long ValueInfo_IsFromOuterScope$OFFSET = 2656;\n@@ -8126,1 +33911,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -8128,1 +33913,1 @@\n-     * OrtStatusPtr (*UnregisterAllocator)(OrtEnv *, const OrtMemoryInfo *)\n+     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)\n@@ -8131,3 +33916,2 @@\n-    public static MemorySegment UnregisterAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(UnregisterAllocator$LAYOUT, UnregisterAllocator$OFFSET);\n-        return UnregisterAllocator.invoke(funcPtr, _x0, _x1);\n+    public static final long ValueInfo_IsFromOuterScope$offset() {\n+        return ValueInfo_IsFromOuterScope$OFFSET;\n@@ -8137,0 +33921,1 @@\n+     * Getter for field:\n@@ -8138,1 +33923,11 @@\n-     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)\n+     * }\n+     *\/\n+    public static MemorySegment ValueInfo_IsFromOuterScope(MemorySegment struct) {\n+        return struct.get(ValueInfo_IsFromOuterScope$LAYOUT, ValueInfo_IsFromOuterScope$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ValueInfo_IsFromOuterScope)(const OrtValueInfo *, bool *)\n@@ -8141,1 +33936,21 @@\n-    private static class IsSparseTensor {\n+    public static void ValueInfo_IsFromOuterScope(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ValueInfo_IsFromOuterScope$LAYOUT, ValueInfo_IsFromOuterScope$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)\n+     * }\n+     *\/\n+    public static class Graph_GetName {\n+\n+        Graph_GetName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8144,3 +33959,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8149,0 +33964,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8163,3 +33995,1 @@\n-    private static final AddressLayout IsSparseTensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"IsSparseTensor\"));\n-\n-    private static final long IsSparseTensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"IsSparseTensor\"));\n+    private static final AddressLayout Graph_GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetName\"));\n@@ -8168,1 +33998,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8170,1 +34000,1 @@\n-     * OrtStatusPtr (*IsSparseTensor)(const OrtValue *, int *)\n+     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)\n@@ -8173,3 +34003,2 @@\n-    public static MemorySegment IsSparseTensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(IsSparseTensor$LAYOUT, IsSparseTensor$OFFSET);\n-        return IsSparseTensor.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Graph_GetName$layout() {\n+        return Graph_GetName$LAYOUT;\n@@ -8178,0 +34007,2 @@\n+    private static final long Graph_GetName$OFFSET = 2664;\n+\n@@ -8179,0 +34010,1 @@\n+     * Offset for field:\n@@ -8180,1 +34012,1 @@\n-     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)\n@@ -8183,23 +34015,2 @@\n-    private static class CreateSparseTensorAsOrtValue {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetName$offset() {\n+        return Graph_GetName$OFFSET;\n@@ -8208,3 +34019,9 @@\n-    private static final AddressLayout CreateSparseTensorAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorAsOrtValue\"));\n-\n-    private static final long CreateSparseTensorAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSparseTensorAsOrtValue\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetName(MemorySegment struct) {\n+        return struct.get(Graph_GetName$LAYOUT, Graph_GetName$OFFSET);\n+    }\n@@ -8213,1 +34030,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8215,1 +34032,1 @@\n-     * OrtStatusPtr (*CreateSparseTensorAsOrtValue)(OrtAllocator *, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*Graph_GetName)(const OrtGraph *, const char **)\n@@ -8218,3 +34035,2 @@\n-    public static MemorySegment CreateSparseTensorAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, int _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateSparseTensorAsOrtValue$LAYOUT, CreateSparseTensorAsOrtValue$OFFSET);\n-        return CreateSparseTensorAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static void Graph_GetName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetName$LAYOUT, Graph_GetName$OFFSET, fieldValue);\n@@ -8225,1 +34041,1 @@\n-     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)\n@@ -8228,1 +34044,12 @@\n-    private static class FillSparseTensorCoo {\n+    public static class Graph_GetModelPath {\n+\n+        Graph_GetModelPath() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8231,8 +34058,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8241,0 +34063,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetModelPath.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetModelPath.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8246,1 +34085,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -8248,1 +34087,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -8255,3 +34094,1 @@\n-    private static final AddressLayout FillSparseTensorCoo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorCoo\"));\n-\n-    private static final long FillSparseTensorCoo$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillSparseTensorCoo\"));\n+    private static final AddressLayout Graph_GetModelPath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetModelPath\"));\n@@ -8260,1 +34097,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8262,1 +34099,1 @@\n-     * OrtStatusPtr (*FillSparseTensorCoo)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)\n@@ -8265,3 +34102,2 @@\n-    public static MemorySegment FillSparseTensorCoo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n-        var funcPtr = struct.get(FillSparseTensorCoo$LAYOUT, FillSparseTensorCoo$OFFSET);\n-        return FillSparseTensorCoo.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+    public static final AddressLayout Graph_GetModelPath$layout() {\n+        return Graph_GetModelPath$LAYOUT;\n@@ -8270,0 +34106,2 @@\n+    private static final long Graph_GetModelPath$OFFSET = 2672;\n+\n@@ -8271,0 +34109,1 @@\n+     * Offset for field:\n@@ -8272,1 +34111,1 @@\n-     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)\n@@ -8275,27 +34114,2 @@\n-    private static class FillSparseTensorCsr {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetModelPath$offset() {\n+        return Graph_GetModelPath$OFFSET;\n@@ -8304,3 +34118,9 @@\n-    private static final AddressLayout FillSparseTensorCsr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorCsr\"));\n-\n-    private static final long FillSparseTensorCsr$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillSparseTensorCsr\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetModelPath(MemorySegment struct) {\n+        return struct.get(Graph_GetModelPath$LAYOUT, Graph_GetModelPath$OFFSET);\n+    }\n@@ -8309,1 +34129,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8311,1 +34131,1 @@\n-     * OrtStatusPtr (*FillSparseTensorCsr)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetModelPath)(const OrtGraph *, const char **)\n@@ -8314,3 +34134,2 @@\n-    public static MemorySegment FillSparseTensorCsr(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8) {\n-        var funcPtr = struct.get(FillSparseTensorCsr$LAYOUT, FillSparseTensorCsr$OFFSET);\n-        return FillSparseTensorCsr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8);\n+    public static void Graph_GetModelPath(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetModelPath$LAYOUT, Graph_GetModelPath$OFFSET, fieldValue);\n@@ -8321,1 +34140,1 @@\n-     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)\n@@ -8324,1 +34143,12 @@\n-    private static class FillSparseTensorBlockSparse {\n+    public static class Graph_GetOnnxIRVersion {\n+\n+        Graph_GetOnnxIRVersion() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8327,9 +34157,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8338,0 +34162,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetOnnxIRVersion.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetOnnxIRVersion.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8343,1 +34184,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -8345,1 +34186,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -8352,3 +34193,1 @@\n-    private static final AddressLayout FillSparseTensorBlockSparse$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FillSparseTensorBlockSparse\"));\n-\n-    private static final long FillSparseTensorBlockSparse$OFFSET = $LAYOUT.byteOffset(groupElement(\"FillSparseTensorBlockSparse\"));\n+    private static final AddressLayout Graph_GetOnnxIRVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetOnnxIRVersion\"));\n@@ -8357,1 +34196,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8359,1 +34198,1 @@\n-     * OrtStatusPtr (*FillSparseTensorBlockSparse)(OrtValue *, const OrtMemoryInfo *, const int64_t *, size_t, const void *, const int64_t *, size_t, const int32_t *)\n+     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)\n@@ -8362,3 +34201,2 @@\n-    public static MemorySegment FillSparseTensorBlockSparse(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, MemorySegment _x5, long _x6, MemorySegment _x7) {\n-        var funcPtr = struct.get(FillSparseTensorBlockSparse$LAYOUT, FillSparseTensorBlockSparse$OFFSET);\n-        return FillSparseTensorBlockSparse.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+    public static final AddressLayout Graph_GetOnnxIRVersion$layout() {\n+        return Graph_GetOnnxIRVersion$LAYOUT;\n@@ -8367,0 +34205,2 @@\n+    private static final long Graph_GetOnnxIRVersion$OFFSET = 2680;\n+\n@@ -8368,0 +34208,1 @@\n+     * Offset for field:\n@@ -8369,1 +34210,1 @@\n-     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)\n@@ -8372,26 +34213,2 @@\n-    private static class CreateSparseTensorWithValuesAsOrtValue {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetOnnxIRVersion$offset() {\n+        return Graph_GetOnnxIRVersion$OFFSET;\n@@ -8400,3 +34217,9 @@\n-    private static final AddressLayout CreateSparseTensorWithValuesAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorWithValuesAsOrtValue\"));\n-\n-    private static final long CreateSparseTensorWithValuesAsOrtValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateSparseTensorWithValuesAsOrtValue\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetOnnxIRVersion(MemorySegment struct) {\n+        return struct.get(Graph_GetOnnxIRVersion$LAYOUT, Graph_GetOnnxIRVersion$OFFSET);\n+    }\n@@ -8405,1 +34228,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8407,1 +34230,1 @@\n-     * OrtStatusPtr (*CreateSparseTensorWithValuesAsOrtValue)(const OrtMemoryInfo *, void *, const int64_t *, size_t, const int64_t *, size_t, ONNXTensorElementDataType, OrtValue **)\n+     * OrtStatusPtr (*Graph_GetOnnxIRVersion)(const OrtGraph *, int64_t *)\n@@ -8410,3 +34233,2 @@\n-    public static MemorySegment CreateSparseTensorWithValuesAsOrtValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3, MemorySegment _x4, long _x5, int _x6, MemorySegment _x7) {\n-        var funcPtr = struct.get(CreateSparseTensorWithValuesAsOrtValue$LAYOUT, CreateSparseTensorWithValuesAsOrtValue$OFFSET);\n-        return CreateSparseTensorWithValuesAsOrtValue.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7);\n+    public static void Graph_GetOnnxIRVersion(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetOnnxIRVersion$LAYOUT, Graph_GetOnnxIRVersion$OFFSET, fieldValue);\n@@ -8417,1 +34239,1 @@\n-     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)\n@@ -8420,1 +34242,12 @@\n-    private static class UseCooIndices {\n+    public static class Graph_GetNumOperatorSets {\n+\n+        Graph_GetNumOperatorSets() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8423,4 +34256,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8429,0 +34261,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetNumOperatorSets.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetNumOperatorSets.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8434,1 +34283,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -8436,1 +34285,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -8443,3 +34292,1 @@\n-    private static final AddressLayout UseCooIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseCooIndices\"));\n-\n-    private static final long UseCooIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"UseCooIndices\"));\n+    private static final AddressLayout Graph_GetNumOperatorSets$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetNumOperatorSets\"));\n@@ -8448,1 +34295,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8450,1 +34297,1 @@\n-     * OrtStatusPtr (*UseCooIndices)(OrtValue *, int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)\n@@ -8453,3 +34300,2 @@\n-    public static MemorySegment UseCooIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(UseCooIndices$LAYOUT, UseCooIndices$OFFSET);\n-        return UseCooIndices.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout Graph_GetNumOperatorSets$layout() {\n+        return Graph_GetNumOperatorSets$LAYOUT;\n@@ -8458,0 +34304,2 @@\n+    private static final long Graph_GetNumOperatorSets$OFFSET = 2688;\n+\n@@ -8459,0 +34307,1 @@\n+     * Offset for field:\n@@ -8460,1 +34309,1 @@\n-     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)\n@@ -8463,23 +34312,2 @@\n-    private static class UseCsrIndices {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetNumOperatorSets$offset() {\n+        return Graph_GetNumOperatorSets$OFFSET;\n@@ -8488,3 +34316,9 @@\n-    private static final AddressLayout UseCsrIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseCsrIndices\"));\n-\n-    private static final long UseCsrIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"UseCsrIndices\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetNumOperatorSets(MemorySegment struct) {\n+        return struct.get(Graph_GetNumOperatorSets$LAYOUT, Graph_GetNumOperatorSets$OFFSET);\n+    }\n@@ -8493,1 +34327,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8495,1 +34329,1 @@\n-     * OrtStatusPtr (*UseCsrIndices)(OrtValue *, int64_t *, size_t, int64_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetNumOperatorSets)(const OrtGraph *, size_t *)\n@@ -8498,3 +34332,2 @@\n-    public static MemorySegment UseCsrIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, long _x4) {\n-        var funcPtr = struct.get(UseCsrIndices$LAYOUT, UseCsrIndices$OFFSET);\n-        return UseCsrIndices.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static void Graph_GetNumOperatorSets(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetNumOperatorSets$LAYOUT, Graph_GetNumOperatorSets$OFFSET, fieldValue);\n@@ -8505,1 +34338,1 @@\n-     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)\n@@ -8508,1 +34341,12 @@\n-    private static class UseBlockSparseIndices {\n+    public static class Graph_GetOperatorSets {\n+\n+        Graph_GetOperatorSets() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3);\n+        }\n@@ -8511,5 +34355,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -8518,0 +34362,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetOperatorSets.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetOperatorSets.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8523,1 +34384,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n@@ -8532,3 +34393,1 @@\n-    private static final AddressLayout UseBlockSparseIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UseBlockSparseIndices\"));\n-\n-    private static final long UseBlockSparseIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"UseBlockSparseIndices\"));\n+    private static final AddressLayout Graph_GetOperatorSets$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetOperatorSets\"));\n@@ -8537,1 +34396,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8539,1 +34398,1 @@\n-     * OrtStatusPtr (*UseBlockSparseIndices)(OrtValue *, const int64_t *, size_t, int32_t *)\n+     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)\n@@ -8542,3 +34401,2 @@\n-    public static MemorySegment UseBlockSparseIndices(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(UseBlockSparseIndices$LAYOUT, UseBlockSparseIndices$OFFSET);\n-        return UseBlockSparseIndices.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout Graph_GetOperatorSets$layout() {\n+        return Graph_GetOperatorSets$LAYOUT;\n@@ -8547,0 +34405,2 @@\n+    private static final long Graph_GetOperatorSets$OFFSET = 2696;\n+\n@@ -8548,0 +34408,1 @@\n+     * Offset for field:\n@@ -8549,1 +34410,1 @@\n-     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)\n@@ -8552,20 +34413,2 @@\n-    private static class GetSparseTensorFormat {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetOperatorSets$offset() {\n+        return Graph_GetOperatorSets$OFFSET;\n@@ -8574,3 +34417,9 @@\n-    private static final AddressLayout GetSparseTensorFormat$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorFormat\"));\n-\n-    private static final long GetSparseTensorFormat$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorFormat\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetOperatorSets(MemorySegment struct) {\n+        return struct.get(Graph_GetOperatorSets$LAYOUT, Graph_GetOperatorSets$OFFSET);\n+    }\n@@ -8579,1 +34428,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8581,1 +34430,1 @@\n-     * OrtStatusPtr (*GetSparseTensorFormat)(const OrtValue *, enum OrtSparseFormat *)\n+     * OrtStatusPtr (*Graph_GetOperatorSets)(const OrtGraph *, const char **, int64_t *, size_t)\n@@ -8584,3 +34433,2 @@\n-    public static MemorySegment GetSparseTensorFormat(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetSparseTensorFormat$LAYOUT, GetSparseTensorFormat$OFFSET);\n-        return GetSparseTensorFormat.invoke(funcPtr, _x0, _x1);\n+    public static void Graph_GetOperatorSets(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetOperatorSets$LAYOUT, Graph_GetOperatorSets$OFFSET, fieldValue);\n@@ -8591,1 +34439,1 @@\n-     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)\n@@ -8594,1 +34442,12 @@\n-    private static class GetSparseTensorValuesTypeAndShape {\n+    public static class Graph_GetNumInputs {\n+\n+        Graph_GetNumInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8597,3 +34456,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8602,0 +34461,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetNumInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetNumInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8616,3 +34492,1 @@\n-    private static final AddressLayout GetSparseTensorValuesTypeAndShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorValuesTypeAndShape\"));\n-\n-    private static final long GetSparseTensorValuesTypeAndShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorValuesTypeAndShape\"));\n+    private static final AddressLayout Graph_GetNumInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetNumInputs\"));\n@@ -8621,1 +34495,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8623,1 +34497,1 @@\n-     * OrtStatusPtr (*GetSparseTensorValuesTypeAndShape)(const OrtValue *, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)\n@@ -8626,3 +34500,2 @@\n-    public static MemorySegment GetSparseTensorValuesTypeAndShape(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetSparseTensorValuesTypeAndShape$LAYOUT, GetSparseTensorValuesTypeAndShape$OFFSET);\n-        return GetSparseTensorValuesTypeAndShape.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Graph_GetNumInputs$layout() {\n+        return Graph_GetNumInputs$LAYOUT;\n@@ -8631,0 +34504,2 @@\n+    private static final long Graph_GetNumInputs$OFFSET = 2704;\n+\n@@ -8632,0 +34507,1 @@\n+     * Offset for field:\n@@ -8633,1 +34509,1 @@\n-     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)\n@@ -8636,20 +34512,2 @@\n-    private static class GetSparseTensorValues {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetNumInputs$offset() {\n+        return Graph_GetNumInputs$OFFSET;\n@@ -8658,3 +34516,9 @@\n-    private static final AddressLayout GetSparseTensorValues$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorValues\"));\n-\n-    private static final long GetSparseTensorValues$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorValues\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetNumInputs(MemorySegment struct) {\n+        return struct.get(Graph_GetNumInputs$LAYOUT, Graph_GetNumInputs$OFFSET);\n+    }\n@@ -8663,1 +34527,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8665,1 +34529,1 @@\n-     * OrtStatusPtr (*GetSparseTensorValues)(const OrtValue *, const void **)\n+     * OrtStatusPtr (*Graph_GetNumInputs)(const OrtGraph *, size_t *)\n@@ -8668,3 +34532,2 @@\n-    public static MemorySegment GetSparseTensorValues(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetSparseTensorValues$LAYOUT, GetSparseTensorValues$OFFSET);\n-        return GetSparseTensorValues.invoke(funcPtr, _x0, _x1);\n+    public static void Graph_GetNumInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetNumInputs$LAYOUT, Graph_GetNumInputs$OFFSET, fieldValue);\n@@ -8675,1 +34538,1 @@\n-     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8678,1 +34541,12 @@\n-    private static class GetSparseTensorIndicesTypeShape {\n+    public static class Graph_GetInputs {\n+\n+        Graph_GetInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -8681,4 +34555,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -8687,0 +34561,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8692,1 +34583,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -8701,3 +34592,1 @@\n-    private static final AddressLayout GetSparseTensorIndicesTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorIndicesTypeShape\"));\n-\n-    private static final long GetSparseTensorIndicesTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorIndicesTypeShape\"));\n+    private static final AddressLayout Graph_GetInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetInputs\"));\n@@ -8706,1 +34595,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8708,1 +34597,1 @@\n-     * OrtStatusPtr (*GetSparseTensorIndicesTypeShape)(const OrtValue *, enum OrtSparseIndicesFormat, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8711,3 +34600,2 @@\n-    public static MemorySegment GetSparseTensorIndicesTypeShape(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetSparseTensorIndicesTypeShape$LAYOUT, GetSparseTensorIndicesTypeShape$OFFSET);\n-        return GetSparseTensorIndicesTypeShape.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout Graph_GetInputs$layout() {\n+        return Graph_GetInputs$LAYOUT;\n@@ -8716,0 +34604,2 @@\n+    private static final long Graph_GetInputs$OFFSET = 2712;\n+\n@@ -8717,0 +34607,1 @@\n+     * Offset for field:\n@@ -8718,1 +34609,1 @@\n-     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8721,22 +34612,2 @@\n-    private static class GetSparseTensorIndices {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetInputs$offset() {\n+        return Graph_GetInputs$OFFSET;\n@@ -8745,3 +34616,9 @@\n-    private static final AddressLayout GetSparseTensorIndices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSparseTensorIndices\"));\n-\n-    private static final long GetSparseTensorIndices$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSparseTensorIndices\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetInputs(MemorySegment struct) {\n+        return struct.get(Graph_GetInputs$LAYOUT, Graph_GetInputs$OFFSET);\n+    }\n@@ -8750,1 +34627,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8752,1 +34629,1 @@\n-     * OrtStatusPtr (*GetSparseTensorIndices)(const OrtValue *, enum OrtSparseIndicesFormat, size_t *, const void **)\n+     * OrtStatusPtr (*Graph_GetInputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8755,3 +34632,2 @@\n-    public static MemorySegment GetSparseTensorIndices(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(GetSparseTensorIndices$LAYOUT, GetSparseTensorIndices$OFFSET);\n-        return GetSparseTensorIndices.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void Graph_GetInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetInputs$LAYOUT, Graph_GetInputs$OFFSET, fieldValue);\n@@ -8762,1 +34638,1 @@\n-     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)\n@@ -8765,1 +34641,12 @@\n-    private static class HasValue {\n+    public static class Graph_GetNumOutputs {\n+\n+        Graph_GetNumOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8768,3 +34655,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8773,0 +34660,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetNumOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetNumOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8787,1 +34691,11 @@\n-    private static final AddressLayout HasValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HasValue\"));\n+    private static final AddressLayout Graph_GetNumOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetNumOutputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout Graph_GetNumOutputs$layout() {\n+        return Graph_GetNumOutputs$LAYOUT;\n+    }\n@@ -8789,1 +34703,1 @@\n-    private static final long HasValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"HasValue\"));\n+    private static final long Graph_GetNumOutputs$OFFSET = 2720;\n@@ -8792,1 +34706,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -8794,1 +34708,1 @@\n-     * OrtStatusPtr (*HasValue)(const OrtValue *, int *)\n+     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)\n@@ -8797,3 +34711,2 @@\n-    public static MemorySegment HasValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(HasValue$LAYOUT, HasValue$OFFSET);\n-        return HasValue.invoke(funcPtr, _x0, _x1);\n+    public static final long Graph_GetNumOutputs$offset() {\n+        return Graph_GetNumOutputs$OFFSET;\n@@ -8803,0 +34716,1 @@\n+     * Getter for field:\n@@ -8804,1 +34718,20 @@\n-     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetNumOutputs(MemorySegment struct) {\n+        return struct.get(Graph_GetNumOutputs$LAYOUT, Graph_GetNumOutputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumOutputs)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static void Graph_GetNumOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetNumOutputs$LAYOUT, Graph_GetNumOutputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8807,1 +34740,12 @@\n-    private static class KernelContext_GetGPUComputeStream {\n+    public static class Graph_GetOutputs {\n+\n+        Graph_GetOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -8810,3 +34754,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -8815,0 +34760,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8820,1 +34782,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -8822,1 +34784,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -8829,1 +34791,11 @@\n-    private static final AddressLayout KernelContext_GetGPUComputeStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetGPUComputeStream\"));\n+    private static final AddressLayout Graph_GetOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetOutputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout Graph_GetOutputs$layout() {\n+        return Graph_GetOutputs$LAYOUT;\n+    }\n@@ -8831,1 +34803,1 @@\n-    private static final long KernelContext_GetGPUComputeStream$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetGPUComputeStream\"));\n+    private static final long Graph_GetOutputs$OFFSET = 2728;\n@@ -8834,1 +34806,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -8836,1 +34808,1 @@\n-     * OrtStatusPtr (*KernelContext_GetGPUComputeStream)(const OrtKernelContext *, void **)\n+     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8839,3 +34811,2 @@\n-    public static MemorySegment KernelContext_GetGPUComputeStream(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelContext_GetGPUComputeStream$LAYOUT, KernelContext_GetGPUComputeStream$OFFSET);\n-        return KernelContext_GetGPUComputeStream.invoke(funcPtr, _x0, _x1);\n+    public static final long Graph_GetOutputs$offset() {\n+        return Graph_GetOutputs$OFFSET;\n@@ -8845,0 +34816,1 @@\n+     * Getter for field:\n@@ -8846,1 +34818,20 @@\n-     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetOutputs(MemorySegment struct) {\n+        return struct.get(Graph_GetOutputs$LAYOUT, Graph_GetOutputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetOutputs)(const OrtGraph *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static void Graph_GetOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetOutputs$LAYOUT, Graph_GetOutputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)\n@@ -8849,1 +34840,25 @@\n-    private static class GetTensorMemoryInfo {\n+    public static class Graph_GetNumInitializers {\n+\n+        Graph_GetNumInitializers() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n@@ -8851,5 +34866,9 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetNumInitializers.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetNumInitializers.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -8871,1 +34890,11 @@\n-    private static final AddressLayout GetTensorMemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorMemoryInfo\"));\n+    private static final AddressLayout Graph_GetNumInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetNumInitializers\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout Graph_GetNumInitializers$layout() {\n+        return Graph_GetNumInitializers$LAYOUT;\n+    }\n@@ -8873,1 +34902,1 @@\n-    private static final long GetTensorMemoryInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorMemoryInfo\"));\n+    private static final long Graph_GetNumInitializers$OFFSET = 2736;\n@@ -8876,1 +34905,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -8878,1 +34907,1 @@\n-     * OrtStatusPtr (*GetTensorMemoryInfo)(const OrtValue *, const OrtMemoryInfo **)\n+     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)\n@@ -8881,3 +34910,2 @@\n-    public static MemorySegment GetTensorMemoryInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetTensorMemoryInfo$LAYOUT, GetTensorMemoryInfo$OFFSET);\n-        return GetTensorMemoryInfo.invoke(funcPtr, _x0, _x1);\n+    public static final long Graph_GetNumInitializers$offset() {\n+        return Graph_GetNumInitializers$OFFSET;\n@@ -8887,0 +34915,1 @@\n+     * Getter for field:\n@@ -8888,1 +34917,20 @@\n-     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetNumInitializers(MemorySegment struct) {\n+        return struct.get(Graph_GetNumInitializers$LAYOUT, Graph_GetNumInitializers$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumInitializers)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static void Graph_GetNumInitializers(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetNumInitializers$LAYOUT, Graph_GetNumInitializers$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8891,1 +34939,12 @@\n-    private static class GetExecutionProviderApi {\n+    public static class Graph_GetInitializers {\n+\n+        Graph_GetInitializers() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -8894,4 +34953,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -8900,0 +34959,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetInitializers.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetInitializers.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8905,1 +34981,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -8914,3 +34990,1 @@\n-    private static final AddressLayout GetExecutionProviderApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetExecutionProviderApi\"));\n-\n-    private static final long GetExecutionProviderApi$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetExecutionProviderApi\"));\n+    private static final AddressLayout Graph_GetInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetInitializers\"));\n@@ -8919,1 +34993,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -8921,1 +34995,1 @@\n-     * OrtStatusPtr (*GetExecutionProviderApi)(const char *, uint32_t, const void **)\n+     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8924,3 +34998,2 @@\n-    public static MemorySegment GetExecutionProviderApi(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetExecutionProviderApi$LAYOUT, GetExecutionProviderApi$OFFSET);\n-        return GetExecutionProviderApi.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout Graph_GetInitializers$layout() {\n+        return Graph_GetInitializers$LAYOUT;\n@@ -8929,0 +35002,2 @@\n+    private static final long Graph_GetInitializers$OFFSET = 2744;\n+\n@@ -8930,0 +35005,1 @@\n+     * Offset for field:\n@@ -8931,1 +35007,1 @@\n-     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8934,20 +35010,2 @@\n-    private static class SessionOptionsSetCustomCreateThreadFn {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetInitializers$offset() {\n+        return Graph_GetInitializers$OFFSET;\n@@ -8956,3 +35014,9 @@\n-    private static final AddressLayout SessionOptionsSetCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomCreateThreadFn\"));\n-\n-    private static final long SessionOptionsSetCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsSetCustomCreateThreadFn\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetInitializers(MemorySegment struct) {\n+        return struct.get(Graph_GetInitializers$LAYOUT, Graph_GetInitializers$OFFSET);\n+    }\n@@ -8961,1 +35025,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -8963,1 +35027,1 @@\n-     * OrtStatusPtr (*SessionOptionsSetCustomCreateThreadFn)(OrtSessionOptions *, OrtCustomCreateThreadFn)\n+     * OrtStatusPtr (*Graph_GetInitializers)(const OrtGraph *, const OrtValueInfo **, size_t)\n@@ -8966,3 +35030,2 @@\n-    public static MemorySegment SessionOptionsSetCustomCreateThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsSetCustomCreateThreadFn$LAYOUT, SessionOptionsSetCustomCreateThreadFn$OFFSET);\n-        return SessionOptionsSetCustomCreateThreadFn.invoke(funcPtr, _x0, _x1);\n+    public static void Graph_GetInitializers(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetInitializers$LAYOUT, Graph_GetInitializers$OFFSET, fieldValue);\n@@ -8973,1 +35036,1 @@\n-     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)\n@@ -8976,1 +35039,12 @@\n-    private static class SessionOptionsSetCustomThreadCreationOptions {\n+    public static class Graph_GetNumNodes {\n+\n+        Graph_GetNumNodes() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -8979,3 +35053,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -8984,0 +35058,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetNumNodes.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetNumNodes.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -8998,3 +35089,1 @@\n-    private static final AddressLayout SessionOptionsSetCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomThreadCreationOptions\"));\n-\n-    private static final long SessionOptionsSetCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsSetCustomThreadCreationOptions\"));\n+    private static final AddressLayout Graph_GetNumNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetNumNodes\"));\n@@ -9003,1 +35092,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9005,1 +35094,1 @@\n-     * OrtStatusPtr (*SessionOptionsSetCustomThreadCreationOptions)(OrtSessionOptions *, void *)\n+     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)\n@@ -9008,3 +35097,2 @@\n-    public static MemorySegment SessionOptionsSetCustomThreadCreationOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsSetCustomThreadCreationOptions$LAYOUT, SessionOptionsSetCustomThreadCreationOptions$OFFSET);\n-        return SessionOptionsSetCustomThreadCreationOptions.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Graph_GetNumNodes$layout() {\n+        return Graph_GetNumNodes$LAYOUT;\n@@ -9013,0 +35101,2 @@\n+    private static final long Graph_GetNumNodes$OFFSET = 2752;\n+\n@@ -9014,0 +35104,1 @@\n+     * Offset for field:\n@@ -9015,1 +35106,1 @@\n-     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)\n@@ -9018,20 +35109,2 @@\n-    private static class SessionOptionsSetCustomJoinThreadFn {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetNumNodes$offset() {\n+        return Graph_GetNumNodes$OFFSET;\n@@ -9040,3 +35113,9 @@\n-    private static final AddressLayout SessionOptionsSetCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsSetCustomJoinThreadFn\"));\n-\n-    private static final long SessionOptionsSetCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsSetCustomJoinThreadFn\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetNumNodes(MemorySegment struct) {\n+        return struct.get(Graph_GetNumNodes$LAYOUT, Graph_GetNumNodes$OFFSET);\n+    }\n@@ -9045,1 +35124,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9047,1 +35126,1 @@\n-     * OrtStatusPtr (*SessionOptionsSetCustomJoinThreadFn)(OrtSessionOptions *, OrtCustomJoinThreadFn)\n+     * OrtStatusPtr (*Graph_GetNumNodes)(const OrtGraph *, size_t *)\n@@ -9050,3 +35129,2 @@\n-    public static MemorySegment SessionOptionsSetCustomJoinThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsSetCustomJoinThreadFn$LAYOUT, SessionOptionsSetCustomJoinThreadFn$OFFSET);\n-        return SessionOptionsSetCustomJoinThreadFn.invoke(funcPtr, _x0, _x1);\n+    public static void Graph_GetNumNodes(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetNumNodes$LAYOUT, Graph_GetNumNodes$OFFSET, fieldValue);\n@@ -9057,1 +35135,1 @@\n-     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)\n@@ -9060,1 +35138,12 @@\n-    private static class SetGlobalCustomCreateThreadFn {\n+    public static class Graph_GetNodes {\n+\n+        Graph_GetNodes() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -9063,3 +35152,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -9068,0 +35158,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetNodes.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetNodes.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9073,1 +35180,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -9075,1 +35182,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -9082,3 +35189,1 @@\n-    private static final AddressLayout SetGlobalCustomCreateThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomCreateThreadFn\"));\n-\n-    private static final long SetGlobalCustomCreateThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalCustomCreateThreadFn\"));\n+    private static final AddressLayout Graph_GetNodes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetNodes\"));\n@@ -9087,1 +35192,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9089,1 +35194,1 @@\n-     * OrtStatusPtr (*SetGlobalCustomCreateThreadFn)(OrtThreadingOptions *, OrtCustomCreateThreadFn)\n+     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)\n@@ -9092,3 +35197,2 @@\n-    public static MemorySegment SetGlobalCustomCreateThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SetGlobalCustomCreateThreadFn$LAYOUT, SetGlobalCustomCreateThreadFn$OFFSET);\n-        return SetGlobalCustomCreateThreadFn.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Graph_GetNodes$layout() {\n+        return Graph_GetNodes$LAYOUT;\n@@ -9097,0 +35201,2 @@\n+    private static final long Graph_GetNodes$OFFSET = 2760;\n+\n@@ -9098,0 +35204,1 @@\n+     * Offset for field:\n@@ -9099,1 +35206,1 @@\n-     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)\n@@ -9102,20 +35209,2 @@\n-    private static class SetGlobalCustomThreadCreationOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetNodes$offset() {\n+        return Graph_GetNodes$OFFSET;\n@@ -9124,3 +35213,9 @@\n-    private static final AddressLayout SetGlobalCustomThreadCreationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomThreadCreationOptions\"));\n-\n-    private static final long SetGlobalCustomThreadCreationOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalCustomThreadCreationOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetNodes(MemorySegment struct) {\n+        return struct.get(Graph_GetNodes$LAYOUT, Graph_GetNodes$OFFSET);\n+    }\n@@ -9129,1 +35224,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9131,1 +35226,1 @@\n-     * OrtStatusPtr (*SetGlobalCustomThreadCreationOptions)(OrtThreadingOptions *, void *)\n+     * OrtStatusPtr (*Graph_GetNodes)(const OrtGraph *, const OrtNode **, size_t)\n@@ -9134,3 +35229,2 @@\n-    public static MemorySegment SetGlobalCustomThreadCreationOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SetGlobalCustomThreadCreationOptions$LAYOUT, SetGlobalCustomThreadCreationOptions$OFFSET);\n-        return SetGlobalCustomThreadCreationOptions.invoke(funcPtr, _x0, _x1);\n+    public static void Graph_GetNodes(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetNodes$LAYOUT, Graph_GetNodes$OFFSET, fieldValue);\n@@ -9141,1 +35235,1 @@\n-     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)\n@@ -9144,1 +35238,12 @@\n-    private static class SetGlobalCustomJoinThreadFn {\n+    public static class Graph_GetParentNode {\n+\n+        Graph_GetParentNode() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -9147,3 +35252,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9152,0 +35257,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetParentNode.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetParentNode.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9166,3 +35288,1 @@\n-    private static final AddressLayout SetGlobalCustomJoinThreadFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalCustomJoinThreadFn\"));\n-\n-    private static final long SetGlobalCustomJoinThreadFn$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalCustomJoinThreadFn\"));\n+    private static final AddressLayout Graph_GetParentNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetParentNode\"));\n@@ -9171,1 +35291,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9173,1 +35293,1 @@\n-     * OrtStatusPtr (*SetGlobalCustomJoinThreadFn)(OrtThreadingOptions *, OrtCustomJoinThreadFn)\n+     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)\n@@ -9176,3 +35296,2 @@\n-    public static MemorySegment SetGlobalCustomJoinThreadFn(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SetGlobalCustomJoinThreadFn$LAYOUT, SetGlobalCustomJoinThreadFn$OFFSET);\n-        return SetGlobalCustomJoinThreadFn.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Graph_GetParentNode$layout() {\n+        return Graph_GetParentNode$LAYOUT;\n@@ -9181,0 +35300,2 @@\n+    private static final long Graph_GetParentNode$OFFSET = 2768;\n+\n@@ -9182,0 +35303,1 @@\n+     * Offset for field:\n@@ -9183,1 +35305,1 @@\n-     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)\n@@ -9186,19 +35308,2 @@\n-    private static class SynchronizeBoundInputs {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetParentNode$offset() {\n+        return Graph_GetParentNode$OFFSET;\n@@ -9207,3 +35312,9 @@\n-    private static final AddressLayout SynchronizeBoundInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SynchronizeBoundInputs\"));\n-\n-    private static final long SynchronizeBoundInputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"SynchronizeBoundInputs\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetParentNode(MemorySegment struct) {\n+        return struct.get(Graph_GetParentNode$LAYOUT, Graph_GetParentNode$OFFSET);\n+    }\n@@ -9212,1 +35323,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9214,1 +35325,1 @@\n-     * OrtStatusPtr (*SynchronizeBoundInputs)(OrtIoBinding *)\n+     * OrtStatusPtr (*Graph_GetParentNode)(const OrtGraph *, const OrtNode **)\n@@ -9217,3 +35328,2 @@\n-    public static MemorySegment SynchronizeBoundInputs(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(SynchronizeBoundInputs$LAYOUT, SynchronizeBoundInputs$OFFSET);\n-        return SynchronizeBoundInputs.invoke(funcPtr, _x0);\n+    public static void Graph_GetParentNode(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetParentNode$LAYOUT, Graph_GetParentNode$OFFSET, fieldValue);\n@@ -9224,1 +35334,1 @@\n-     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)\n@@ -9227,1 +35337,12 @@\n-    private static class SynchronizeBoundOutputs {\n+    public static class Graph_GetGraphView {\n+\n+        Graph_GetGraphView() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n@@ -9230,2 +35351,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9234,0 +35358,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetGraphView.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetGraphView.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9239,1 +35380,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n@@ -9241,1 +35382,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -9248,3 +35389,1 @@\n-    private static final AddressLayout SynchronizeBoundOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SynchronizeBoundOutputs\"));\n-\n-    private static final long SynchronizeBoundOutputs$OFFSET = $LAYOUT.byteOffset(groupElement(\"SynchronizeBoundOutputs\"));\n+    private static final AddressLayout Graph_GetGraphView$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetGraphView\"));\n@@ -9253,1 +35392,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9255,1 +35394,1 @@\n-     * OrtStatusPtr (*SynchronizeBoundOutputs)(OrtIoBinding *)\n+     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)\n@@ -9258,3 +35397,2 @@\n-    public static MemorySegment SynchronizeBoundOutputs(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(SynchronizeBoundOutputs$LAYOUT, SynchronizeBoundOutputs$OFFSET);\n-        return SynchronizeBoundOutputs.invoke(funcPtr, _x0);\n+    public static final AddressLayout Graph_GetGraphView$layout() {\n+        return Graph_GetGraphView$LAYOUT;\n@@ -9263,0 +35401,2 @@\n+    private static final long Graph_GetGraphView$OFFSET = 2776;\n+\n@@ -9264,0 +35404,1 @@\n+     * Offset for field:\n@@ -9265,1 +35406,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)\n@@ -9267,21 +35408,3 @@\n-     *\/\n-    private static class SessionOptionsAppendExecutionProvider_CUDA_V2 {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+     *\/\n+    public static final long Graph_GetGraphView$offset() {\n+        return Graph_GetGraphView$OFFSET;\n@@ -9290,3 +35413,9 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_CUDA_V2\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetGraphView(MemorySegment struct) {\n+        return struct.get(Graph_GetGraphView$LAYOUT, Graph_GetGraphView$OFFSET);\n+    }\n@@ -9295,1 +35424,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9297,1 +35426,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CUDA_V2)(OrtSessionOptions *, const OrtCUDAProviderOptionsV2 *)\n+     * OrtStatusPtr (*Graph_GetGraphView)(const OrtGraph *, const OrtNode **, size_t, OrtGraph **)\n@@ -9300,3 +35429,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_CUDA_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CUDA_V2$LAYOUT, SessionOptionsAppendExecutionProvider_CUDA_V2$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_CUDA_V2.invoke(funcPtr, _x0, _x1);\n+    public static void Graph_GetGraphView(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetGraphView$LAYOUT, Graph_GetGraphView$OFFSET, fieldValue);\n@@ -9307,1 +35435,1 @@\n-     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)\n@@ -9310,1 +35438,12 @@\n-    private static class CreateCUDAProviderOptions {\n+    public static class Node_GetId {\n+\n+        Node_GetId() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -9313,2 +35452,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9317,0 +35457,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetId.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetId.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9322,1 +35479,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -9324,1 +35481,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -9331,3 +35488,1 @@\n-    private static final AddressLayout CreateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCUDAProviderOptions\"));\n-\n-    private static final long CreateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCUDAProviderOptions\"));\n+    private static final AddressLayout Node_GetId$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetId\"));\n@@ -9336,1 +35491,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9338,1 +35493,1 @@\n-     * OrtStatusPtr (*CreateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 **)\n+     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)\n@@ -9341,3 +35496,2 @@\n-    public static MemorySegment CreateCUDAProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateCUDAProviderOptions$LAYOUT, CreateCUDAProviderOptions$OFFSET);\n-        return CreateCUDAProviderOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout Node_GetId$layout() {\n+        return Node_GetId$LAYOUT;\n@@ -9346,0 +35500,2 @@\n+    private static final long Node_GetId$OFFSET = 2784;\n+\n@@ -9347,0 +35503,1 @@\n+     * Offset for field:\n@@ -9348,1 +35505,1 @@\n-     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)\n@@ -9351,22 +35508,2 @@\n-    private static class UpdateCUDAProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetId$offset() {\n+        return Node_GetId$OFFSET;\n@@ -9375,3 +35512,9 @@\n-    private static final AddressLayout UpdateCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCUDAProviderOptions\"));\n-\n-    private static final long UpdateCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateCUDAProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetId(MemorySegment struct) {\n+        return struct.get(Node_GetId$LAYOUT, Node_GetId$OFFSET);\n+    }\n@@ -9380,1 +35523,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9382,1 +35525,1 @@\n-     * OrtStatusPtr (*UpdateCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetId)(const OrtNode *, size_t *)\n@@ -9385,3 +35528,2 @@\n-    public static MemorySegment UpdateCUDAProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(UpdateCUDAProviderOptions$LAYOUT, UpdateCUDAProviderOptions$OFFSET);\n-        return UpdateCUDAProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void Node_GetId(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetId$LAYOUT, Node_GetId$OFFSET, fieldValue);\n@@ -9392,1 +35534,1 @@\n-     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)\n@@ -9395,1 +35537,12 @@\n-    private static class GetCUDAProviderOptionsAsString {\n+    public static class Node_GetName {\n+\n+        Node_GetName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -9398,4 +35551,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9404,0 +35556,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9409,1 +35578,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -9411,1 +35580,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -9418,3 +35587,1 @@\n-    private static final AddressLayout GetCUDAProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCUDAProviderOptionsAsString\"));\n-\n-    private static final long GetCUDAProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCUDAProviderOptionsAsString\"));\n+    private static final AddressLayout Node_GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetName\"));\n@@ -9423,1 +35590,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9425,1 +35592,1 @@\n-     * OrtStatusPtr (*GetCUDAProviderOptionsAsString)(const OrtCUDAProviderOptionsV2 *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)\n@@ -9428,3 +35595,2 @@\n-    public static MemorySegment GetCUDAProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetCUDAProviderOptionsAsString$LAYOUT, GetCUDAProviderOptionsAsString$OFFSET);\n-        return GetCUDAProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout Node_GetName$layout() {\n+        return Node_GetName$LAYOUT;\n@@ -9433,0 +35599,2 @@\n+    private static final long Node_GetName$OFFSET = 2792;\n+\n@@ -9434,0 +35602,1 @@\n+     * Offset for field:\n@@ -9435,1 +35604,1 @@\n-     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)\n@@ -9438,18 +35607,2 @@\n-    private static class ReleaseCUDAProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetName$offset() {\n+        return Node_GetName$OFFSET;\n@@ -9458,3 +35611,9 @@\n-    private static final AddressLayout ReleaseCUDAProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCUDAProviderOptions\"));\n-\n-    private static final long ReleaseCUDAProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseCUDAProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetName(MemorySegment struct) {\n+        return struct.get(Node_GetName$LAYOUT, Node_GetName$OFFSET);\n+    }\n@@ -9463,1 +35622,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9465,1 +35624,1 @@\n-     * void (*ReleaseCUDAProviderOptions)(OrtCUDAProviderOptionsV2 *)\n+     * OrtStatusPtr (*Node_GetName)(const OrtNode *, const char **)\n@@ -9468,3 +35627,2 @@\n-    public static void ReleaseCUDAProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseCUDAProviderOptions$LAYOUT, ReleaseCUDAProviderOptions$OFFSET);\n-        ReleaseCUDAProviderOptions.invoke(funcPtr, _x0);\n+    public static void Node_GetName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetName$LAYOUT, Node_GetName$OFFSET, fieldValue);\n@@ -9475,1 +35633,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)\n@@ -9478,1 +35636,12 @@\n-    private static class SessionOptionsAppendExecutionProvider_MIGraphX {\n+    public static class Node_GetOperatorType {\n+\n+        Node_GetOperatorType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -9481,3 +35650,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9486,0 +35655,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetOperatorType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetOperatorType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9500,3 +35686,1 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_MIGraphX\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_MIGraphX\"));\n+    private static final AddressLayout Node_GetOperatorType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetOperatorType\"));\n@@ -9505,1 +35689,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9507,1 +35691,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_MIGraphX)(OrtSessionOptions *, const OrtMIGraphXProviderOptions *)\n+     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)\n@@ -9510,3 +35694,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_MIGraphX(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_MIGraphX$LAYOUT, SessionOptionsAppendExecutionProvider_MIGraphX$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_MIGraphX.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Node_GetOperatorType$layout() {\n+        return Node_GetOperatorType$LAYOUT;\n@@ -9515,0 +35698,2 @@\n+    private static final long Node_GetOperatorType$OFFSET = 2800;\n+\n@@ -9516,0 +35701,1 @@\n+     * Offset for field:\n@@ -9517,1 +35703,1 @@\n-     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)\n@@ -9520,22 +35706,2 @@\n-    private static class AddExternalInitializers {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetOperatorType$offset() {\n+        return Node_GetOperatorType$OFFSET;\n@@ -9544,3 +35710,9 @@\n-    private static final AddressLayout AddExternalInitializers$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddExternalInitializers\"));\n-\n-    private static final long AddExternalInitializers$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddExternalInitializers\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetOperatorType(MemorySegment struct) {\n+        return struct.get(Node_GetOperatorType$LAYOUT, Node_GetOperatorType$OFFSET);\n+    }\n@@ -9549,1 +35721,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9551,1 +35723,1 @@\n-     * OrtStatusPtr (*AddExternalInitializers)(OrtSessionOptions *, const char *const *, const OrtValue *const *, size_t)\n+     * OrtStatusPtr (*Node_GetOperatorType)(const OrtNode *, const char **)\n@@ -9554,3 +35726,2 @@\n-    public static MemorySegment AddExternalInitializers(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(AddExternalInitializers$LAYOUT, AddExternalInitializers$OFFSET);\n-        return AddExternalInitializers.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void Node_GetOperatorType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetOperatorType$LAYOUT, Node_GetOperatorType$OFFSET, fieldValue);\n@@ -9561,1 +35732,1 @@\n-     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)\n@@ -9564,1 +35735,12 @@\n-    private static class CreateOpAttr {\n+    public static class Node_GetDomain {\n+\n+        Node_GetDomain() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -9567,6 +35749,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9575,0 +35754,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetDomain.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetDomain.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9580,1 +35776,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -9582,1 +35778,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -9589,3 +35785,1 @@\n-    private static final AddressLayout CreateOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOpAttr\"));\n-\n-    private static final long CreateOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateOpAttr\"));\n+    private static final AddressLayout Node_GetDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetDomain\"));\n@@ -9594,1 +35788,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9596,1 +35790,1 @@\n-     * OrtStatusPtr (*CreateOpAttr)(const char *, const void *, int, OrtOpAttrType, OrtOpAttr **)\n+     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)\n@@ -9599,3 +35793,2 @@\n-    public static MemorySegment CreateOpAttr(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(CreateOpAttr$LAYOUT, CreateOpAttr$OFFSET);\n-        return CreateOpAttr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout Node_GetDomain$layout() {\n+        return Node_GetDomain$LAYOUT;\n@@ -9604,0 +35797,2 @@\n+    private static final long Node_GetDomain$OFFSET = 2808;\n+\n@@ -9605,0 +35800,1 @@\n+     * Offset for field:\n@@ -9606,1 +35802,1 @@\n-     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)\n@@ -9609,18 +35805,2 @@\n-    private static class ReleaseOpAttr {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetDomain$offset() {\n+        return Node_GetDomain$OFFSET;\n@@ -9629,3 +35809,9 @@\n-    private static final AddressLayout ReleaseOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseOpAttr\"));\n-\n-    private static final long ReleaseOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseOpAttr\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetDomain(MemorySegment struct) {\n+        return struct.get(Node_GetDomain$LAYOUT, Node_GetDomain$OFFSET);\n+    }\n@@ -9634,1 +35820,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9636,1 +35822,1 @@\n-     * void (*ReleaseOpAttr)(OrtOpAttr *)\n+     * OrtStatusPtr (*Node_GetDomain)(const OrtNode *, const char **)\n@@ -9639,3 +35825,2 @@\n-    public static void ReleaseOpAttr(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseOpAttr$LAYOUT, ReleaseOpAttr$OFFSET);\n-        ReleaseOpAttr.invoke(funcPtr, _x0);\n+    public static void Node_GetDomain(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetDomain$LAYOUT, Node_GetDomain$OFFSET, fieldValue);\n@@ -9646,1 +35831,1 @@\n-     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)\n@@ -9649,1 +35834,12 @@\n-    private static class CreateOp {\n+    public static class Node_GetSinceVersion {\n+\n+        Node_GetSinceVersion() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -9652,13 +35848,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9667,0 +35853,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetSinceVersion.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetSinceVersion.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9672,1 +35875,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -9674,1 +35877,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -9681,1 +35884,11 @@\n-    private static final AddressLayout CreateOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOp\"));\n+    private static final AddressLayout Node_GetSinceVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetSinceVersion\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout Node_GetSinceVersion$layout() {\n+        return Node_GetSinceVersion$LAYOUT;\n+    }\n@@ -9683,1 +35896,1 @@\n-    private static final long CreateOp$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateOp\"));\n+    private static final long Node_GetSinceVersion$OFFSET = 2816;\n@@ -9686,1 +35899,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -9688,1 +35901,1 @@\n-     * OrtStatusPtr (*CreateOp)(const OrtKernelInfo *, const char *, const char *, int, const char **, const ONNXTensorElementDataType *, int, const OrtOpAttr *const *, int, int, int, OrtOp **)\n+     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)\n@@ -9691,3 +35904,2 @@\n-    public static MemorySegment CreateOp(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, MemorySegment _x5, int _x6, MemorySegment _x7, int _x8, int _x9, int _x10, MemorySegment _x11) {\n-        var funcPtr = struct.get(CreateOp$LAYOUT, CreateOp$OFFSET);\n-        return CreateOp.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10, _x11);\n+    public static final long Node_GetSinceVersion$offset() {\n+        return Node_GetSinceVersion$OFFSET;\n@@ -9697,0 +35909,1 @@\n+     * Getter for field:\n@@ -9698,1 +35911,20 @@\n-     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetSinceVersion(MemorySegment struct) {\n+        return struct.get(Node_GetSinceVersion$LAYOUT, Node_GetSinceVersion$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetSinceVersion)(const OrtNode *, int *)\n+     * }\n+     *\/\n+    public static void Node_GetSinceVersion(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetSinceVersion$LAYOUT, Node_GetSinceVersion$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)\n@@ -9701,1 +35933,27 @@\n-    private static class InvokeOp {\n+    public static class Node_GetNumInputs {\n+\n+        Node_GetNumInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetNumInputs.Function.class, \"apply\", $DESC);\n@@ -9703,9 +35961,7 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetNumInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -9718,1 +35974,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -9720,1 +35976,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -9727,3 +35983,1 @@\n-    private static final AddressLayout InvokeOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"InvokeOp\"));\n-\n-    private static final long InvokeOp$OFFSET = $LAYOUT.byteOffset(groupElement(\"InvokeOp\"));\n+    private static final AddressLayout Node_GetNumInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetNumInputs\"));\n@@ -9732,1 +35986,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9734,1 +35988,1 @@\n-     * OrtStatusPtr (*InvokeOp)(const OrtKernelContext *, const OrtOp *, const OrtValue *const *, int, OrtValue *const *, int)\n+     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)\n@@ -9737,3 +35991,2 @@\n-    public static MemorySegment InvokeOp(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, int _x3, MemorySegment _x4, int _x5) {\n-        var funcPtr = struct.get(InvokeOp$LAYOUT, InvokeOp$OFFSET);\n-        return InvokeOp.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    public static final AddressLayout Node_GetNumInputs$layout() {\n+        return Node_GetNumInputs$LAYOUT;\n@@ -9742,0 +35995,2 @@\n+    private static final long Node_GetNumInputs$OFFSET = 2824;\n+\n@@ -9743,0 +35998,1 @@\n+     * Offset for field:\n@@ -9744,1 +36000,1 @@\n-     * void (*ReleaseOp)(OrtOp *)\n+     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)\n@@ -9747,18 +36003,2 @@\n-    private static class ReleaseOp {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetNumInputs$offset() {\n+        return Node_GetNumInputs$OFFSET;\n@@ -9767,3 +36007,9 @@\n-    private static final AddressLayout ReleaseOp$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseOp\"));\n-\n-    private static final long ReleaseOp$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseOp\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetNumInputs(MemorySegment struct) {\n+        return struct.get(Node_GetNumInputs$LAYOUT, Node_GetNumInputs$OFFSET);\n+    }\n@@ -9772,1 +36018,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9774,1 +36020,1 @@\n-     * void (*ReleaseOp)(OrtOp *)\n+     * OrtStatusPtr (*Node_GetNumInputs)(const OrtNode *, size_t *)\n@@ -9777,3 +36023,2 @@\n-    public static void ReleaseOp(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseOp$LAYOUT, ReleaseOp$OFFSET);\n-        ReleaseOp.invoke(funcPtr, _x0);\n+    public static void Node_GetNumInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetNumInputs$LAYOUT, Node_GetNumInputs$OFFSET, fieldValue);\n@@ -9784,1 +36029,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9787,1 +36032,12 @@\n-    private static class SessionOptionsAppendExecutionProvider {\n+    public static class Node_GetInputs {\n+\n+        Node_GetInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -9790,6 +36046,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -9798,0 +36052,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9803,1 +36074,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -9805,1 +36076,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -9812,3 +36083,1 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider\"));\n+    private static final AddressLayout Node_GetInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetInputs\"));\n@@ -9817,1 +36086,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9819,1 +36088,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider)(OrtSessionOptions *, const char *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9822,3 +36091,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider$LAYOUT, SessionOptionsAppendExecutionProvider$OFFSET);\n-        return SessionOptionsAppendExecutionProvider.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout Node_GetInputs$layout() {\n+        return Node_GetInputs$LAYOUT;\n@@ -9827,0 +36095,2 @@\n+    private static final long Node_GetInputs$OFFSET = 2832;\n+\n@@ -9828,0 +36098,1 @@\n+     * Offset for field:\n@@ -9829,1 +36100,1 @@\n-     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9832,20 +36103,2 @@\n-    private static class CopyKernelInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetInputs$offset() {\n+        return Node_GetInputs$OFFSET;\n@@ -9854,3 +36107,9 @@\n-    private static final AddressLayout CopyKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CopyKernelInfo\"));\n-\n-    private static final long CopyKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CopyKernelInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetInputs(MemorySegment struct) {\n+        return struct.get(Node_GetInputs$LAYOUT, Node_GetInputs$OFFSET);\n+    }\n@@ -9859,1 +36118,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9861,1 +36120,1 @@\n-     * OrtStatusPtr (*CopyKernelInfo)(const OrtKernelInfo *, OrtKernelInfo **)\n+     * OrtStatusPtr (*Node_GetInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9864,3 +36123,2 @@\n-    public static MemorySegment CopyKernelInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CopyKernelInfo$LAYOUT, CopyKernelInfo$OFFSET);\n-        return CopyKernelInfo.invoke(funcPtr, _x0, _x1);\n+    public static void Node_GetInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetInputs$LAYOUT, Node_GetInputs$OFFSET, fieldValue);\n@@ -9871,1 +36129,1 @@\n-     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)\n@@ -9874,1 +36132,1 @@\n-    private static class ReleaseKernelInfo {\n+    public static class Node_GetNumOutputs {\n@@ -9876,2 +36134,15 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n+        Node_GetNumOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -9880,0 +36151,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetNumOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetNumOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9885,1 +36173,1 @@\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -9887,1 +36175,1 @@\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -9894,3 +36182,1 @@\n-    private static final AddressLayout ReleaseKernelInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseKernelInfo\"));\n-\n-    private static final long ReleaseKernelInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseKernelInfo\"));\n+    private static final AddressLayout Node_GetNumOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetNumOutputs\"));\n@@ -9899,1 +36185,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9901,1 +36187,1 @@\n-     * void (*ReleaseKernelInfo)(OrtKernelInfo *)\n+     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)\n@@ -9904,3 +36190,2 @@\n-    public static void ReleaseKernelInfo(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseKernelInfo$LAYOUT, ReleaseKernelInfo$OFFSET);\n-        ReleaseKernelInfo.invoke(funcPtr, _x0);\n+    public static final AddressLayout Node_GetNumOutputs$layout() {\n+        return Node_GetNumOutputs$LAYOUT;\n@@ -9909,0 +36194,2 @@\n+    private static final long Node_GetNumOutputs$OFFSET = 2840;\n+\n@@ -9910,0 +36197,1 @@\n+     * Offset for field:\n@@ -9911,1 +36199,1 @@\n-     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)\n@@ -9914,19 +36202,2 @@\n-    private static class GetTrainingApi {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,int _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetNumOutputs$offset() {\n+        return Node_GetNumOutputs$OFFSET;\n@@ -9935,3 +36206,9 @@\n-    private static final AddressLayout GetTrainingApi$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTrainingApi\"));\n-\n-    private static final long GetTrainingApi$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTrainingApi\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetNumOutputs(MemorySegment struct) {\n+        return struct.get(Node_GetNumOutputs$LAYOUT, Node_GetNumOutputs$OFFSET);\n+    }\n@@ -9940,1 +36217,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -9942,1 +36219,1 @@\n-     * const OrtTrainingApi *(*GetTrainingApi)(uint32_t)\n+     * OrtStatusPtr (*Node_GetNumOutputs)(const OrtNode *, size_t *)\n@@ -9945,3 +36222,2 @@\n-    public static MemorySegment GetTrainingApi(MemorySegment struct, int _x0) {\n-        var funcPtr = struct.get(GetTrainingApi$LAYOUT, GetTrainingApi$OFFSET);\n-        return GetTrainingApi.invoke(funcPtr, _x0);\n+    public static void Node_GetNumOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetNumOutputs$LAYOUT, Node_GetNumOutputs$OFFSET, fieldValue);\n@@ -9952,1 +36228,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9955,1 +36231,12 @@\n-    private static class SessionOptionsAppendExecutionProvider_CANN {\n+    public static class Node_GetOutputs {\n+\n+        Node_GetOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -9958,3 +36245,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -9963,0 +36251,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -9968,1 +36273,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -9970,1 +36275,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -9977,3 +36282,1 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_CANN$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_CANN\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_CANN$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_CANN\"));\n+    private static final AddressLayout Node_GetOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetOutputs\"));\n@@ -9982,1 +36285,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -9984,1 +36287,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_CANN)(OrtSessionOptions *, const OrtCANNProviderOptions *)\n+     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9987,3 +36290,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_CANN(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_CANN$LAYOUT, SessionOptionsAppendExecutionProvider_CANN$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_CANN.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Node_GetOutputs$layout() {\n+        return Node_GetOutputs$LAYOUT;\n@@ -9992,0 +36294,2 @@\n+    private static final long Node_GetOutputs$OFFSET = 2848;\n+\n@@ -9993,0 +36297,1 @@\n+     * Offset for field:\n@@ -9994,1 +36299,1 @@\n-     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -9997,19 +36302,2 @@\n-    private static class CreateCANNProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetOutputs$offset() {\n+        return Node_GetOutputs$OFFSET;\n@@ -10018,3 +36306,9 @@\n-    private static final AddressLayout CreateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateCANNProviderOptions\"));\n-\n-    private static final long CreateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateCANNProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetOutputs(MemorySegment struct) {\n+        return struct.get(Node_GetOutputs$LAYOUT, Node_GetOutputs$OFFSET);\n+    }\n@@ -10023,1 +36317,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10025,1 +36319,1 @@\n-     * OrtStatusPtr (*CreateCANNProviderOptions)(OrtCANNProviderOptions **)\n+     * OrtStatusPtr (*Node_GetOutputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -10028,3 +36322,2 @@\n-    public static MemorySegment CreateCANNProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateCANNProviderOptions$LAYOUT, CreateCANNProviderOptions$OFFSET);\n-        return CreateCANNProviderOptions.invoke(funcPtr, _x0);\n+    public static void Node_GetOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetOutputs$LAYOUT, Node_GetOutputs$OFFSET, fieldValue);\n@@ -10035,1 +36328,1 @@\n-     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)\n@@ -10038,1 +36331,12 @@\n-    private static class UpdateCANNProviderOptions {\n+    public static class Node_GetNumImplicitInputs {\n+\n+        Node_GetNumImplicitInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10041,5 +36345,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10048,0 +36350,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetNumImplicitInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetNumImplicitInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10053,1 +36372,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10055,1 +36374,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -10062,3 +36381,1 @@\n-    private static final AddressLayout UpdateCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCANNProviderOptions\"));\n-\n-    private static final long UpdateCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateCANNProviderOptions\"));\n+    private static final AddressLayout Node_GetNumImplicitInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetNumImplicitInputs\"));\n@@ -10067,1 +36384,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10069,1 +36386,1 @@\n-     * OrtStatusPtr (*UpdateCANNProviderOptions)(OrtCANNProviderOptions *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)\n@@ -10072,3 +36389,2 @@\n-    public static MemorySegment UpdateCANNProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(UpdateCANNProviderOptions$LAYOUT, UpdateCANNProviderOptions$OFFSET);\n-        return UpdateCANNProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout Node_GetNumImplicitInputs$layout() {\n+        return Node_GetNumImplicitInputs$LAYOUT;\n@@ -10077,0 +36393,2 @@\n+    private static final long Node_GetNumImplicitInputs$OFFSET = 2856;\n+\n@@ -10078,0 +36396,1 @@\n+     * Offset for field:\n@@ -10079,1 +36398,1 @@\n-     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)\n@@ -10082,21 +36401,2 @@\n-    private static class GetCANNProviderOptionsAsString {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetNumImplicitInputs$offset() {\n+        return Node_GetNumImplicitInputs$OFFSET;\n@@ -10105,3 +36405,9 @@\n-    private static final AddressLayout GetCANNProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCANNProviderOptionsAsString\"));\n-\n-    private static final long GetCANNProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCANNProviderOptionsAsString\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetNumImplicitInputs(MemorySegment struct) {\n+        return struct.get(Node_GetNumImplicitInputs$LAYOUT, Node_GetNumImplicitInputs$OFFSET);\n+    }\n@@ -10110,1 +36416,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10112,1 +36418,1 @@\n-     * OrtStatusPtr (*GetCANNProviderOptionsAsString)(const OrtCANNProviderOptions *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*Node_GetNumImplicitInputs)(const OrtNode *, size_t *)\n@@ -10115,3 +36421,2 @@\n-    public static MemorySegment GetCANNProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetCANNProviderOptionsAsString$LAYOUT, GetCANNProviderOptionsAsString$OFFSET);\n-        return GetCANNProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void Node_GetNumImplicitInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetNumImplicitInputs$LAYOUT, Node_GetNumImplicitInputs$OFFSET, fieldValue);\n@@ -10122,1 +36427,1 @@\n-     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -10125,1 +36430,1 @@\n-    private static class ReleaseCANNProviderOptions {\n+    public static class Node_GetImplicitInputs {\n@@ -10127,2 +36432,16 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n+        Node_GetImplicitInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -10131,0 +36450,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetImplicitInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetImplicitInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10136,1 +36472,1 @@\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -10138,1 +36474,1 @@\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -10145,3 +36481,1 @@\n-    private static final AddressLayout ReleaseCANNProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseCANNProviderOptions\"));\n-\n-    private static final long ReleaseCANNProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseCANNProviderOptions\"));\n+    private static final AddressLayout Node_GetImplicitInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetImplicitInputs\"));\n@@ -10150,1 +36484,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10152,1 +36486,1 @@\n-     * void (*ReleaseCANNProviderOptions)(OrtCANNProviderOptions *)\n+     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -10155,3 +36489,2 @@\n-    public static void ReleaseCANNProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseCANNProviderOptions$LAYOUT, ReleaseCANNProviderOptions$OFFSET);\n-        ReleaseCANNProviderOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout Node_GetImplicitInputs$layout() {\n+        return Node_GetImplicitInputs$LAYOUT;\n@@ -10160,0 +36493,2 @@\n+    private static final long Node_GetImplicitInputs$OFFSET = 2864;\n+\n@@ -10161,0 +36496,1 @@\n+     * Offset for field:\n@@ -10162,1 +36498,1 @@\n-     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -10165,19 +36501,2 @@\n-    private static class MemoryInfoGetDeviceType {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetImplicitInputs$offset() {\n+        return Node_GetImplicitInputs$OFFSET;\n@@ -10186,3 +36505,9 @@\n-    private static final AddressLayout MemoryInfoGetDeviceType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"MemoryInfoGetDeviceType\"));\n-\n-    private static final long MemoryInfoGetDeviceType$OFFSET = $LAYOUT.byteOffset(groupElement(\"MemoryInfoGetDeviceType\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetImplicitInputs(MemorySegment struct) {\n+        return struct.get(Node_GetImplicitInputs$LAYOUT, Node_GetImplicitInputs$OFFSET);\n+    }\n@@ -10191,1 +36516,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10193,1 +36518,1 @@\n-     * void (*MemoryInfoGetDeviceType)(const OrtMemoryInfo *, OrtMemoryInfoDeviceType *)\n+     * OrtStatusPtr (*Node_GetImplicitInputs)(const OrtNode *, const OrtValueInfo **, size_t)\n@@ -10196,3 +36521,2 @@\n-    public static void MemoryInfoGetDeviceType(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(MemoryInfoGetDeviceType$LAYOUT, MemoryInfoGetDeviceType$OFFSET);\n-        MemoryInfoGetDeviceType.invoke(funcPtr, _x0, _x1);\n+    public static void Node_GetImplicitInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetImplicitInputs$LAYOUT, Node_GetImplicitInputs$OFFSET, fieldValue);\n@@ -10203,1 +36527,1 @@\n-     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)\n@@ -10206,1 +36530,12 @@\n-    private static class UpdateEnvWithCustomLogLevel {\n+    public static class Node_GetNumAttributes {\n+\n+        Node_GetNumAttributes() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10209,3 +36544,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10214,0 +36549,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetNumAttributes.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetNumAttributes.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10219,1 +36571,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10228,3 +36580,1 @@\n-    private static final AddressLayout UpdateEnvWithCustomLogLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateEnvWithCustomLogLevel\"));\n-\n-    private static final long UpdateEnvWithCustomLogLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateEnvWithCustomLogLevel\"));\n+    private static final AddressLayout Node_GetNumAttributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetNumAttributes\"));\n@@ -10233,1 +36583,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10235,1 +36585,1 @@\n-     * OrtStatusPtr (*UpdateEnvWithCustomLogLevel)(OrtEnv *, OrtLoggingLevel)\n+     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)\n@@ -10238,3 +36588,2 @@\n-    public static MemorySegment UpdateEnvWithCustomLogLevel(MemorySegment struct, MemorySegment _x0, int _x1) {\n-        var funcPtr = struct.get(UpdateEnvWithCustomLogLevel$LAYOUT, UpdateEnvWithCustomLogLevel$OFFSET);\n-        return UpdateEnvWithCustomLogLevel.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Node_GetNumAttributes$layout() {\n+        return Node_GetNumAttributes$LAYOUT;\n@@ -10243,0 +36592,2 @@\n+    private static final long Node_GetNumAttributes$OFFSET = 2872;\n+\n@@ -10244,0 +36595,1 @@\n+     * Offset for field:\n@@ -10245,1 +36597,1 @@\n-     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)\n@@ -10248,20 +36600,2 @@\n-    private static class SetGlobalIntraOpThreadAffinity {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetNumAttributes$offset() {\n+        return Node_GetNumAttributes$OFFSET;\n@@ -10270,3 +36604,9 @@\n-    private static final AddressLayout SetGlobalIntraOpThreadAffinity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGlobalIntraOpThreadAffinity\"));\n-\n-    private static final long SetGlobalIntraOpThreadAffinity$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetGlobalIntraOpThreadAffinity\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetNumAttributes(MemorySegment struct) {\n+        return struct.get(Node_GetNumAttributes$LAYOUT, Node_GetNumAttributes$OFFSET);\n+    }\n@@ -10275,1 +36615,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10277,1 +36617,1 @@\n-     * OrtStatusPtr (*SetGlobalIntraOpThreadAffinity)(OrtThreadingOptions *, const char *)\n+     * OrtStatusPtr (*Node_GetNumAttributes)(const OrtNode *, size_t *)\n@@ -10280,3 +36620,2 @@\n-    public static MemorySegment SetGlobalIntraOpThreadAffinity(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SetGlobalIntraOpThreadAffinity$LAYOUT, SetGlobalIntraOpThreadAffinity$OFFSET);\n-        return SetGlobalIntraOpThreadAffinity.invoke(funcPtr, _x0, _x1);\n+    public static void Node_GetNumAttributes(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetNumAttributes$LAYOUT, Node_GetNumAttributes$OFFSET, fieldValue);\n@@ -10287,1 +36626,1 @@\n-     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)\n@@ -10290,1 +36629,12 @@\n-    private static class RegisterCustomOpsLibrary_V2 {\n+    public static class Node_GetAttributes {\n+\n+        Node_GetAttributes() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -10293,3 +36643,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -10298,0 +36649,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetAttributes.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetAttributes.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10303,1 +36671,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -10305,1 +36673,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -10312,3 +36680,1 @@\n-    private static final AddressLayout RegisterCustomOpsLibrary_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsLibrary_V2\"));\n-\n-    private static final long RegisterCustomOpsLibrary_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterCustomOpsLibrary_V2\"));\n+    private static final AddressLayout Node_GetAttributes$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetAttributes\"));\n@@ -10317,1 +36683,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10319,1 +36685,1 @@\n-     * OrtStatusPtr (*RegisterCustomOpsLibrary_V2)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)\n@@ -10322,3 +36688,2 @@\n-    public static MemorySegment RegisterCustomOpsLibrary_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RegisterCustomOpsLibrary_V2$LAYOUT, RegisterCustomOpsLibrary_V2$OFFSET);\n-        return RegisterCustomOpsLibrary_V2.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout Node_GetAttributes$layout() {\n+        return Node_GetAttributes$LAYOUT;\n@@ -10327,0 +36692,2 @@\n+    private static final long Node_GetAttributes$OFFSET = 2880;\n+\n@@ -10328,0 +36695,1 @@\n+     * Offset for field:\n@@ -10329,1 +36697,1 @@\n-     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)\n@@ -10332,20 +36700,2 @@\n-    private static class RegisterCustomOpsUsingFunction {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetAttributes$offset() {\n+        return Node_GetAttributes$OFFSET;\n@@ -10354,3 +36704,9 @@\n-    private static final AddressLayout RegisterCustomOpsUsingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RegisterCustomOpsUsingFunction\"));\n-\n-    private static final long RegisterCustomOpsUsingFunction$OFFSET = $LAYOUT.byteOffset(groupElement(\"RegisterCustomOpsUsingFunction\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetAttributes(MemorySegment struct) {\n+        return struct.get(Node_GetAttributes$LAYOUT, Node_GetAttributes$OFFSET);\n+    }\n@@ -10359,1 +36715,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10361,1 +36717,1 @@\n-     * OrtStatusPtr (*RegisterCustomOpsUsingFunction)(OrtSessionOptions *, const char *)\n+     * OrtStatusPtr (*Node_GetAttributes)(const OrtNode *, const OrtOpAttr **, size_t)\n@@ -10364,3 +36720,2 @@\n-    public static MemorySegment RegisterCustomOpsUsingFunction(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RegisterCustomOpsUsingFunction$LAYOUT, RegisterCustomOpsUsingFunction$OFFSET);\n-        return RegisterCustomOpsUsingFunction.invoke(funcPtr, _x0, _x1);\n+    public static void Node_GetAttributes(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetAttributes$LAYOUT, Node_GetAttributes$OFFSET, fieldValue);\n@@ -10371,1 +36726,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)\n@@ -10374,1 +36729,12 @@\n-    private static class KernelInfo_GetInputCount {\n+    public static class Node_GetAttributeByName {\n+\n+        Node_GetAttributeByName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -10377,3 +36743,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10382,0 +36749,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetAttributeByName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetAttributeByName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10387,1 +36771,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -10389,1 +36773,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -10396,1 +36780,11 @@\n-    private static final AddressLayout KernelInfo_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputCount\"));\n+    private static final AddressLayout Node_GetAttributeByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetAttributeByName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)\n+     * }\n+     *\/\n+    public static final AddressLayout Node_GetAttributeByName$layout() {\n+        return Node_GetAttributeByName$LAYOUT;\n+    }\n@@ -10398,1 +36792,1 @@\n-    private static final long KernelInfo_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetInputCount\"));\n+    private static final long Node_GetAttributeByName$OFFSET = 2888;\n@@ -10401,1 +36795,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -10403,1 +36797,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetInputCount)(const OrtKernelInfo *, size_t *)\n+     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)\n@@ -10406,3 +36800,2 @@\n-    public static MemorySegment KernelInfo_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelInfo_GetInputCount$LAYOUT, KernelInfo_GetInputCount$OFFSET);\n-        return KernelInfo_GetInputCount.invoke(funcPtr, _x0, _x1);\n+    public static final long Node_GetAttributeByName$offset() {\n+        return Node_GetAttributeByName$OFFSET;\n@@ -10412,0 +36805,1 @@\n+     * Getter for field:\n@@ -10413,1 +36807,20 @@\n-     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetAttributeByName(MemorySegment struct) {\n+        return struct.get(Node_GetAttributeByName$LAYOUT, Node_GetAttributeByName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetAttributeByName)(const OrtNode *, const char *, const OrtOpAttr **)\n+     * }\n+     *\/\n+    public static void Node_GetAttributeByName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetAttributeByName$LAYOUT, Node_GetAttributeByName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)\n@@ -10416,1 +36829,12 @@\n-    private static class KernelInfo_GetOutputCount {\n+    public static class OpAttr_GetTensorAttributeAsOrtValue {\n+\n+        OpAttr_GetTensorAttributeAsOrtValue() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10419,3 +36843,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10424,0 +36848,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(OpAttr_GetTensorAttributeAsOrtValue.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(OpAttr_GetTensorAttributeAsOrtValue.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10438,3 +36879,1 @@\n-    private static final AddressLayout KernelInfo_GetOutputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputCount\"));\n-\n-    private static final long KernelInfo_GetOutputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetOutputCount\"));\n+    private static final AddressLayout OpAttr_GetTensorAttributeAsOrtValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"OpAttr_GetTensorAttributeAsOrtValue\"));\n@@ -10443,1 +36882,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10445,1 +36884,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetOutputCount)(const OrtKernelInfo *, size_t *)\n+     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)\n@@ -10448,3 +36887,2 @@\n-    public static MemorySegment KernelInfo_GetOutputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelInfo_GetOutputCount$LAYOUT, KernelInfo_GetOutputCount$OFFSET);\n-        return KernelInfo_GetOutputCount.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout OpAttr_GetTensorAttributeAsOrtValue$layout() {\n+        return OpAttr_GetTensorAttributeAsOrtValue$LAYOUT;\n@@ -10453,0 +36891,2 @@\n+    private static final long OpAttr_GetTensorAttributeAsOrtValue$OFFSET = 2896;\n+\n@@ -10454,0 +36894,1 @@\n+     * Offset for field:\n@@ -10455,1 +36896,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)\n@@ -10458,22 +36899,2 @@\n-    private static class KernelInfo_GetInputName {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long OpAttr_GetTensorAttributeAsOrtValue$offset() {\n+        return OpAttr_GetTensorAttributeAsOrtValue$OFFSET;\n@@ -10482,3 +36903,9 @@\n-    private static final AddressLayout KernelInfo_GetInputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputName\"));\n-\n-    private static final long KernelInfo_GetInputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetInputName\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)\n+     * }\n+     *\/\n+    public static MemorySegment OpAttr_GetTensorAttributeAsOrtValue(MemorySegment struct) {\n+        return struct.get(OpAttr_GetTensorAttributeAsOrtValue$LAYOUT, OpAttr_GetTensorAttributeAsOrtValue$OFFSET);\n+    }\n@@ -10487,1 +36914,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10489,1 +36916,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetInputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * OrtStatusPtr (*OpAttr_GetTensorAttributeAsOrtValue)(const OrtOpAttr *, OrtValue **)\n@@ -10492,3 +36919,2 @@\n-    public static MemorySegment KernelInfo_GetInputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfo_GetInputName$LAYOUT, KernelInfo_GetInputName$OFFSET);\n-        return KernelInfo_GetInputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void OpAttr_GetTensorAttributeAsOrtValue(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(OpAttr_GetTensorAttributeAsOrtValue$LAYOUT, OpAttr_GetTensorAttributeAsOrtValue$OFFSET, fieldValue);\n@@ -10499,1 +36925,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)\n@@ -10502,1 +36928,12 @@\n-    private static class KernelInfo_GetOutputName {\n+    public static class OpAttr_GetType {\n+\n+        OpAttr_GetType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10505,5 +36942,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10512,0 +36947,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(OpAttr_GetType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(OpAttr_GetType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10517,1 +36969,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10519,1 +36971,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -10526,3 +36978,1 @@\n-    private static final AddressLayout KernelInfo_GetOutputName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputName\"));\n-\n-    private static final long KernelInfo_GetOutputName$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetOutputName\"));\n+    private static final AddressLayout OpAttr_GetType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"OpAttr_GetType\"));\n@@ -10531,1 +36981,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10533,1 +36983,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetOutputName)(const OrtKernelInfo *, size_t, char *, size_t *)\n+     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)\n@@ -10536,3 +36986,2 @@\n-    public static MemorySegment KernelInfo_GetOutputName(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfo_GetOutputName$LAYOUT, KernelInfo_GetOutputName$OFFSET);\n-        return KernelInfo_GetOutputName.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout OpAttr_GetType$layout() {\n+        return OpAttr_GetType$LAYOUT;\n@@ -10541,0 +36990,2 @@\n+    private static final long OpAttr_GetType$OFFSET = 2904;\n+\n@@ -10542,0 +36993,1 @@\n+     * Offset for field:\n@@ -10543,1 +36995,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)\n@@ -10546,24 +36998,3 @@\n-    private static class KernelInfo_GetInputTypeInfo {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n-    }\n-\n-    private static final AddressLayout KernelInfo_GetInputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetInputTypeInfo\"));\n+    public static final long OpAttr_GetType$offset() {\n+        return OpAttr_GetType$OFFSET;\n+    }\n@@ -10571,1 +37002,9 @@\n-    private static final long KernelInfo_GetInputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetInputTypeInfo\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)\n+     * }\n+     *\/\n+    public static MemorySegment OpAttr_GetType(MemorySegment struct) {\n+        return struct.get(OpAttr_GetType$LAYOUT, OpAttr_GetType$OFFSET);\n+    }\n@@ -10574,1 +37013,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10576,1 +37015,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetInputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*OpAttr_GetType)(const OrtOpAttr *, OrtOpAttrType *)\n@@ -10579,3 +37018,2 @@\n-    public static MemorySegment KernelInfo_GetInputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelInfo_GetInputTypeInfo$LAYOUT, KernelInfo_GetInputTypeInfo$OFFSET);\n-        return KernelInfo_GetInputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void OpAttr_GetType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(OpAttr_GetType$LAYOUT, OpAttr_GetType$OFFSET, fieldValue);\n@@ -10586,1 +37024,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)\n@@ -10589,1 +37027,12 @@\n-    private static class KernelInfo_GetOutputTypeInfo {\n+    public static class OpAttr_GetName {\n+\n+        OpAttr_GetName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10592,4 +37041,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10598,0 +37046,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(OpAttr_GetName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(OpAttr_GetName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10603,1 +37068,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10605,1 +37070,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -10612,3 +37077,1 @@\n-    private static final AddressLayout KernelInfo_GetOutputTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetOutputTypeInfo\"));\n-\n-    private static final long KernelInfo_GetOutputTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetOutputTypeInfo\"));\n+    private static final AddressLayout OpAttr_GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"OpAttr_GetName\"));\n@@ -10617,1 +37080,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10619,1 +37082,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetOutputTypeInfo)(const OrtKernelInfo *, size_t, OrtTypeInfo **)\n+     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)\n@@ -10622,3 +37085,2 @@\n-    public static MemorySegment KernelInfo_GetOutputTypeInfo(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelInfo_GetOutputTypeInfo$LAYOUT, KernelInfo_GetOutputTypeInfo$OFFSET);\n-        return KernelInfo_GetOutputTypeInfo.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout OpAttr_GetName$layout() {\n+        return OpAttr_GetName$LAYOUT;\n@@ -10627,0 +37089,2 @@\n+    private static final long OpAttr_GetName$OFFSET = 2912;\n+\n@@ -10628,0 +37092,1 @@\n+     * Offset for field:\n@@ -10629,1 +37094,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)\n@@ -10632,22 +37097,2 @@\n-    private static class KernelInfoGetAttribute_tensor {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long OpAttr_GetName$offset() {\n+        return OpAttr_GetName$OFFSET;\n@@ -10656,3 +37101,9 @@\n-    private static final AddressLayout KernelInfoGetAttribute_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAttribute_tensor\"));\n-\n-    private static final long KernelInfoGetAttribute_tensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAttribute_tensor\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment OpAttr_GetName(MemorySegment struct) {\n+        return struct.get(OpAttr_GetName$LAYOUT, OpAttr_GetName$OFFSET);\n+    }\n@@ -10661,1 +37112,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10663,1 +37114,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAttribute_tensor)(const OrtKernelInfo *, const char *, OrtAllocator *, OrtValue **)\n+     * OrtStatusPtr (*OpAttr_GetName)(const OrtOpAttr *, const char **)\n@@ -10666,3 +37117,2 @@\n-    public static MemorySegment KernelInfoGetAttribute_tensor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfoGetAttribute_tensor$LAYOUT, KernelInfoGetAttribute_tensor$OFFSET);\n-        return KernelInfoGetAttribute_tensor.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void OpAttr_GetName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(OpAttr_GetName$LAYOUT, OpAttr_GetName$OFFSET, fieldValue);\n@@ -10673,1 +37123,1 @@\n-     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)\n@@ -10676,1 +37126,12 @@\n-    private static class HasSessionConfigEntry {\n+    public static class Node_GetNumSubgraphs {\n+\n+        Node_GetNumSubgraphs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10679,4 +37140,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10685,0 +37145,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetNumSubgraphs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetNumSubgraphs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10690,1 +37167,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10692,1 +37169,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -10699,1 +37176,11 @@\n-    private static final AddressLayout HasSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"HasSessionConfigEntry\"));\n+    private static final AddressLayout Node_GetNumSubgraphs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetNumSubgraphs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout Node_GetNumSubgraphs$layout() {\n+        return Node_GetNumSubgraphs$LAYOUT;\n+    }\n@@ -10701,1 +37188,1 @@\n-    private static final long HasSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"HasSessionConfigEntry\"));\n+    private static final long Node_GetNumSubgraphs$OFFSET = 2920;\n@@ -10704,1 +37191,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -10706,1 +37193,1 @@\n-     * OrtStatusPtr (*HasSessionConfigEntry)(const OrtSessionOptions *, const char *, int *)\n+     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)\n@@ -10709,3 +37196,2 @@\n-    public static MemorySegment HasSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(HasSessionConfigEntry$LAYOUT, HasSessionConfigEntry$OFFSET);\n-        return HasSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final long Node_GetNumSubgraphs$offset() {\n+        return Node_GetNumSubgraphs$OFFSET;\n@@ -10715,0 +37201,1 @@\n+     * Getter for field:\n@@ -10716,1 +37203,20 @@\n-     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetNumSubgraphs(MemorySegment struct) {\n+        return struct.get(Node_GetNumSubgraphs$LAYOUT, Node_GetNumSubgraphs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetNumSubgraphs)(const OrtNode *, size_t *)\n+     * }\n+     *\/\n+    public static void Node_GetNumSubgraphs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetNumSubgraphs$LAYOUT, Node_GetNumSubgraphs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)\n@@ -10719,1 +37225,12 @@\n-    private static class GetSessionConfigEntry {\n+    public static class Node_GetSubgraphs {\n+\n+        Node_GetSubgraphs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n@@ -10722,5 +37239,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10729,0 +37246,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetSubgraphs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetSubgraphs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10734,1 +37268,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n@@ -10743,3 +37277,1 @@\n-    private static final AddressLayout GetSessionConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSessionConfigEntry\"));\n-\n-    private static final long GetSessionConfigEntry$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetSessionConfigEntry\"));\n+    private static final AddressLayout Node_GetSubgraphs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetSubgraphs\"));\n@@ -10748,1 +37280,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10750,1 +37282,1 @@\n-     * OrtStatusPtr (*GetSessionConfigEntry)(const OrtSessionOptions *, const char *, char *, size_t *)\n+     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)\n@@ -10753,3 +37285,2 @@\n-    public static MemorySegment GetSessionConfigEntry(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(GetSessionConfigEntry$LAYOUT, GetSessionConfigEntry$OFFSET);\n-        return GetSessionConfigEntry.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout Node_GetSubgraphs$layout() {\n+        return Node_GetSubgraphs$LAYOUT;\n@@ -10758,0 +37289,2 @@\n+    private static final long Node_GetSubgraphs$OFFSET = 2928;\n+\n@@ -10759,0 +37292,1 @@\n+     * Offset for field:\n@@ -10760,1 +37294,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)\n@@ -10763,20 +37297,2 @@\n-    private static class SessionOptionsAppendExecutionProvider_Dnnl {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetSubgraphs$offset() {\n+        return Node_GetSubgraphs$OFFSET;\n@@ -10785,3 +37301,9 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_Dnnl\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_Dnnl$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_Dnnl\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetSubgraphs(MemorySegment struct) {\n+        return struct.get(Node_GetSubgraphs$LAYOUT, Node_GetSubgraphs$OFFSET);\n+    }\n@@ -10790,1 +37312,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10792,1 +37314,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_Dnnl)(OrtSessionOptions *, const OrtDnnlProviderOptions *)\n+     * OrtStatusPtr (*Node_GetSubgraphs)(const OrtNode *, const OrtGraph **, size_t, const char **)\n@@ -10795,3 +37317,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_Dnnl(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_Dnnl$LAYOUT, SessionOptionsAppendExecutionProvider_Dnnl$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_Dnnl.invoke(funcPtr, _x0, _x1);\n+    public static void Node_GetSubgraphs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetSubgraphs$LAYOUT, Node_GetSubgraphs$OFFSET, fieldValue);\n@@ -10802,1 +37323,1 @@\n-     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)\n@@ -10805,1 +37326,12 @@\n-    private static class CreateDnnlProviderOptions {\n+    public static class Node_GetGraph {\n+\n+        Node_GetGraph() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10808,2 +37340,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10812,0 +37345,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetGraph.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetGraph.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10817,1 +37367,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10819,1 +37369,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -10826,3 +37376,1 @@\n-    private static final AddressLayout CreateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateDnnlProviderOptions\"));\n-\n-    private static final long CreateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateDnnlProviderOptions\"));\n+    private static final AddressLayout Node_GetGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetGraph\"));\n@@ -10831,1 +37379,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10833,1 +37381,1 @@\n-     * OrtStatusPtr (*CreateDnnlProviderOptions)(OrtDnnlProviderOptions **)\n+     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)\n@@ -10836,3 +37384,2 @@\n-    public static MemorySegment CreateDnnlProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateDnnlProviderOptions$LAYOUT, CreateDnnlProviderOptions$OFFSET);\n-        return CreateDnnlProviderOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout Node_GetGraph$layout() {\n+        return Node_GetGraph$LAYOUT;\n@@ -10841,0 +37388,2 @@\n+    private static final long Node_GetGraph$OFFSET = 2936;\n+\n@@ -10842,0 +37391,1 @@\n+     * Offset for field:\n@@ -10843,1 +37393,1 @@\n-     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)\n@@ -10846,22 +37396,2 @@\n-    private static class UpdateDnnlProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetGraph$offset() {\n+        return Node_GetGraph$OFFSET;\n@@ -10870,3 +37400,9 @@\n-    private static final AddressLayout UpdateDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateDnnlProviderOptions\"));\n-\n-    private static final long UpdateDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateDnnlProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetGraph(MemorySegment struct) {\n+        return struct.get(Node_GetGraph$LAYOUT, Node_GetGraph$OFFSET);\n+    }\n@@ -10875,1 +37411,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10877,1 +37413,1 @@\n-     * OrtStatusPtr (*UpdateDnnlProviderOptions)(OrtDnnlProviderOptions *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*Node_GetGraph)(const OrtNode *, const OrtGraph **)\n@@ -10880,3 +37416,2 @@\n-    public static MemorySegment UpdateDnnlProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(UpdateDnnlProviderOptions$LAYOUT, UpdateDnnlProviderOptions$OFFSET);\n-        return UpdateDnnlProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void Node_GetGraph(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetGraph$LAYOUT, Node_GetGraph$OFFSET, fieldValue);\n@@ -10887,1 +37422,1 @@\n-     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)\n@@ -10890,1 +37425,12 @@\n-    private static class GetDnnlProviderOptionsAsString {\n+    public static class Node_GetEpName {\n+\n+        Node_GetEpName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -10893,4 +37439,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -10899,0 +37444,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Node_GetEpName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Node_GetEpName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10904,1 +37466,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -10906,1 +37468,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -10913,3 +37475,1 @@\n-    private static final AddressLayout GetDnnlProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetDnnlProviderOptionsAsString\"));\n-\n-    private static final long GetDnnlProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetDnnlProviderOptionsAsString\"));\n+    private static final AddressLayout Node_GetEpName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Node_GetEpName\"));\n@@ -10918,1 +37478,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -10920,1 +37480,1 @@\n-     * OrtStatusPtr (*GetDnnlProviderOptionsAsString)(const OrtDnnlProviderOptions *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)\n@@ -10923,3 +37483,2 @@\n-    public static MemorySegment GetDnnlProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetDnnlProviderOptionsAsString$LAYOUT, GetDnnlProviderOptionsAsString$OFFSET);\n-        return GetDnnlProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout Node_GetEpName$layout() {\n+        return Node_GetEpName$LAYOUT;\n@@ -10928,0 +37487,2 @@\n+    private static final long Node_GetEpName$OFFSET = 2944;\n+\n@@ -10929,0 +37490,1 @@\n+     * Offset for field:\n@@ -10930,1 +37492,1 @@\n-     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)\n@@ -10933,18 +37495,2 @@\n-    private static class ReleaseDnnlProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Node_GetEpName$offset() {\n+        return Node_GetEpName$OFFSET;\n@@ -10953,3 +37499,9 @@\n-    private static final AddressLayout ReleaseDnnlProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseDnnlProviderOptions\"));\n-\n-    private static final long ReleaseDnnlProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseDnnlProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)\n+     * }\n+     *\/\n+    public static MemorySegment Node_GetEpName(MemorySegment struct) {\n+        return struct.get(Node_GetEpName$LAYOUT, Node_GetEpName$OFFSET);\n+    }\n@@ -10958,1 +37510,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -10960,1 +37512,1 @@\n-     * void (*ReleaseDnnlProviderOptions)(OrtDnnlProviderOptions *)\n+     * OrtStatusPtr (*Node_GetEpName)(const OrtNode *, const char **)\n@@ -10963,3 +37515,2 @@\n-    public static void ReleaseDnnlProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseDnnlProviderOptions$LAYOUT, ReleaseDnnlProviderOptions$OFFSET);\n-        ReleaseDnnlProviderOptions.invoke(funcPtr, _x0);\n+    public static void Node_GetEpName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Node_GetEpName$LAYOUT, Node_GetEpName$OFFSET, fieldValue);\n@@ -10970,1 +37521,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)\n@@ -10973,1 +37524,1 @@\n-    private static class KernelInfo_GetNodeName {\n+    public static class ReleaseExternalInitializerInfo {\n@@ -10975,5 +37526,13 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+        ReleaseExternalInitializerInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n@@ -10982,0 +37541,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseExternalInitializerInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseExternalInitializerInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -10987,1 +37563,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -10989,1 +37565,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -10996,3 +37572,1 @@\n-    private static final AddressLayout KernelInfo_GetNodeName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetNodeName\"));\n-\n-    private static final long KernelInfo_GetNodeName$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetNodeName\"));\n+    private static final AddressLayout ReleaseExternalInitializerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseExternalInitializerInfo\"));\n@@ -11001,1 +37575,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11003,1 +37577,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetNodeName)(const OrtKernelInfo *, char *, size_t *)\n+     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)\n@@ -11006,3 +37580,2 @@\n-    public static MemorySegment KernelInfo_GetNodeName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelInfo_GetNodeName$LAYOUT, KernelInfo_GetNodeName$OFFSET);\n-        return KernelInfo_GetNodeName.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout ReleaseExternalInitializerInfo$layout() {\n+        return ReleaseExternalInitializerInfo$LAYOUT;\n@@ -11011,0 +37584,2 @@\n+    private static final long ReleaseExternalInitializerInfo$OFFSET = 2952;\n+\n@@ -11012,0 +37587,1 @@\n+     * Offset for field:\n@@ -11013,1 +37589,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)\n@@ -11016,20 +37592,2 @@\n-    private static class KernelInfo_GetLogger {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseExternalInitializerInfo$offset() {\n+        return ReleaseExternalInitializerInfo$OFFSET;\n@@ -11038,3 +37596,9 @@\n-    private static final AddressLayout KernelInfo_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfo_GetLogger\"));\n-\n-    private static final long KernelInfo_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfo_GetLogger\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseExternalInitializerInfo(MemorySegment struct) {\n+        return struct.get(ReleaseExternalInitializerInfo$LAYOUT, ReleaseExternalInitializerInfo$OFFSET);\n+    }\n@@ -11043,1 +37607,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11045,1 +37609,1 @@\n-     * OrtStatusPtr (*KernelInfo_GetLogger)(const OrtKernelInfo *, const OrtLogger **)\n+     * void (*ReleaseExternalInitializerInfo)(OrtExternalInitializerInfo *)\n@@ -11048,3 +37612,2 @@\n-    public static MemorySegment KernelInfo_GetLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelInfo_GetLogger$LAYOUT, KernelInfo_GetLogger$OFFSET);\n-        return KernelInfo_GetLogger.invoke(funcPtr, _x0, _x1);\n+    public static void ReleaseExternalInitializerInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseExternalInitializerInfo$LAYOUT, ReleaseExternalInitializerInfo$OFFSET, fieldValue);\n@@ -11055,1 +37618,1 @@\n-     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)\n@@ -11058,1 +37621,12 @@\n-    private static class KernelContext_GetLogger {\n+    public static class ExternalInitializerInfo_GetFilePath {\n+\n+        ExternalInitializerInfo_GetFilePath() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -11061,3 +37635,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11066,0 +37639,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ExternalInitializerInfo_GetFilePath.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ExternalInitializerInfo_GetFilePath.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11071,1 +37661,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -11073,1 +37663,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -11080,3 +37670,1 @@\n-    private static final AddressLayout KernelContext_GetLogger$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetLogger\"));\n-\n-    private static final long KernelContext_GetLogger$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetLogger\"));\n+    private static final AddressLayout ExternalInitializerInfo_GetFilePath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ExternalInitializerInfo_GetFilePath\"));\n@@ -11085,1 +37673,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11087,1 +37675,1 @@\n-     * OrtStatusPtr (*KernelContext_GetLogger)(const OrtKernelContext *, const OrtLogger **)\n+     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)\n@@ -11090,3 +37678,2 @@\n-    public static MemorySegment KernelContext_GetLogger(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(KernelContext_GetLogger$LAYOUT, KernelContext_GetLogger$OFFSET);\n-        return KernelContext_GetLogger.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout ExternalInitializerInfo_GetFilePath$layout() {\n+        return ExternalInitializerInfo_GetFilePath$LAYOUT;\n@@ -11095,0 +37682,2 @@\n+    private static final long ExternalInitializerInfo_GetFilePath$OFFSET = 2960;\n+\n@@ -11096,0 +37685,1 @@\n+     * Offset for field:\n@@ -11097,1 +37687,1 @@\n-     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)\n@@ -11100,24 +37690,2 @@\n-    private static class Logger_LogMessage {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ExternalInitializerInfo_GetFilePath$offset() {\n+        return ExternalInitializerInfo_GetFilePath$OFFSET;\n@@ -11126,3 +37694,9 @@\n-    private static final AddressLayout Logger_LogMessage$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Logger_LogMessage\"));\n-\n-    private static final long Logger_LogMessage$OFFSET = $LAYOUT.byteOffset(groupElement(\"Logger_LogMessage\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ExternalInitializerInfo_GetFilePath(MemorySegment struct) {\n+        return struct.get(ExternalInitializerInfo_GetFilePath$LAYOUT, ExternalInitializerInfo_GetFilePath$OFFSET);\n+    }\n@@ -11131,1 +37705,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11133,1 +37707,1 @@\n-     * OrtStatusPtr (*Logger_LogMessage)(const OrtLogger *, OrtLoggingLevel, const char *, const char *, int, const char *)\n+     * const char *(*ExternalInitializerInfo_GetFilePath)(const OrtExternalInitializerInfo *)\n@@ -11136,3 +37710,2 @@\n-    public static MemorySegment Logger_LogMessage(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, MemorySegment _x3, int _x4, MemorySegment _x5) {\n-        var funcPtr = struct.get(Logger_LogMessage$LAYOUT, Logger_LogMessage$OFFSET);\n-        return Logger_LogMessage.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n+    public static void ExternalInitializerInfo_GetFilePath(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ExternalInitializerInfo_GetFilePath$LAYOUT, ExternalInitializerInfo_GetFilePath$OFFSET, fieldValue);\n@@ -11143,1 +37716,1 @@\n-     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)\n@@ -11146,1 +37719,12 @@\n-    private static class Logger_GetLoggingSeverityLevel {\n+    public static class ExternalInitializerInfo_GetFileOffset {\n+\n+        ExternalInitializerInfo_GetFileOffset() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            long apply(MemorySegment _x0);\n+        }\n@@ -11149,3 +37733,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_LONG_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11154,0 +37737,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ExternalInitializerInfo_GetFileOffset.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ExternalInitializerInfo_GetFileOffset.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11159,1 +37759,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -11161,1 +37761,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (long) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -11168,3 +37768,1 @@\n-    private static final AddressLayout Logger_GetLoggingSeverityLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Logger_GetLoggingSeverityLevel\"));\n-\n-    private static final long Logger_GetLoggingSeverityLevel$OFFSET = $LAYOUT.byteOffset(groupElement(\"Logger_GetLoggingSeverityLevel\"));\n+    private static final AddressLayout ExternalInitializerInfo_GetFileOffset$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ExternalInitializerInfo_GetFileOffset\"));\n@@ -11173,1 +37771,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11175,1 +37773,1 @@\n-     * OrtStatusPtr (*Logger_GetLoggingSeverityLevel)(const OrtLogger *, OrtLoggingLevel *)\n+     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)\n@@ -11178,3 +37776,2 @@\n-    public static MemorySegment Logger_GetLoggingSeverityLevel(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(Logger_GetLoggingSeverityLevel$LAYOUT, Logger_GetLoggingSeverityLevel$OFFSET);\n-        return Logger_GetLoggingSeverityLevel.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout ExternalInitializerInfo_GetFileOffset$layout() {\n+        return ExternalInitializerInfo_GetFileOffset$LAYOUT;\n@@ -11183,0 +37780,2 @@\n+    private static final long ExternalInitializerInfo_GetFileOffset$OFFSET = 2968;\n+\n@@ -11184,0 +37783,1 @@\n+     * Offset for field:\n@@ -11185,1 +37785,1 @@\n-     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)\n@@ -11188,22 +37788,2 @@\n-    private static class KernelInfoGetConstantInput_tensor {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ExternalInitializerInfo_GetFileOffset$offset() {\n+        return ExternalInitializerInfo_GetFileOffset$OFFSET;\n@@ -11212,3 +37792,9 @@\n-    private static final AddressLayout KernelInfoGetConstantInput_tensor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetConstantInput_tensor\"));\n-\n-    private static final long KernelInfoGetConstantInput_tensor$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetConstantInput_tensor\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ExternalInitializerInfo_GetFileOffset(MemorySegment struct) {\n+        return struct.get(ExternalInitializerInfo_GetFileOffset$LAYOUT, ExternalInitializerInfo_GetFileOffset$OFFSET);\n+    }\n@@ -11217,1 +37803,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11219,1 +37805,1 @@\n-     * OrtStatusPtr (*KernelInfoGetConstantInput_tensor)(const OrtKernelInfo *, size_t, int *, const OrtValue **)\n+     * int64_t (*ExternalInitializerInfo_GetFileOffset)(const OrtExternalInitializerInfo *)\n@@ -11222,3 +37808,2 @@\n-    public static MemorySegment KernelInfoGetConstantInput_tensor(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelInfoGetConstantInput_tensor$LAYOUT, KernelInfoGetConstantInput_tensor$OFFSET);\n-        return KernelInfoGetConstantInput_tensor.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void ExternalInitializerInfo_GetFileOffset(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ExternalInitializerInfo_GetFileOffset$LAYOUT, ExternalInitializerInfo_GetFileOffset$OFFSET, fieldValue);\n@@ -11229,1 +37814,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)\n@@ -11232,1 +37817,12 @@\n-    private static class CastTypeInfoToOptionalTypeInfo {\n+    public static class ExternalInitializerInfo_GetByteSize {\n+\n+        ExternalInitializerInfo_GetByteSize() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            long apply(MemorySegment _x0);\n+        }\n@@ -11235,3 +37831,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11240,0 +37835,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ExternalInitializerInfo_GetByteSize.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ExternalInitializerInfo_GetByteSize.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11245,1 +37857,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -11247,1 +37859,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (long) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -11254,1 +37866,11 @@\n-    private static final AddressLayout CastTypeInfoToOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CastTypeInfoToOptionalTypeInfo\"));\n+    private static final AddressLayout ExternalInitializerInfo_GetByteSize$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ExternalInitializerInfo_GetByteSize\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout ExternalInitializerInfo_GetByteSize$layout() {\n+        return ExternalInitializerInfo_GetByteSize$LAYOUT;\n+    }\n@@ -11256,1 +37878,1 @@\n-    private static final long CastTypeInfoToOptionalTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"CastTypeInfoToOptionalTypeInfo\"));\n+    private static final long ExternalInitializerInfo_GetByteSize$OFFSET = 2976;\n@@ -11259,1 +37881,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -11261,1 +37883,1 @@\n-     * OrtStatusPtr (*CastTypeInfoToOptionalTypeInfo)(const OrtTypeInfo *, const OrtOptionalTypeInfo **)\n+     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)\n@@ -11264,3 +37886,2 @@\n-    public static MemorySegment CastTypeInfoToOptionalTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(CastTypeInfoToOptionalTypeInfo$LAYOUT, CastTypeInfoToOptionalTypeInfo$OFFSET);\n-        return CastTypeInfoToOptionalTypeInfo.invoke(funcPtr, _x0, _x1);\n+    public static final long ExternalInitializerInfo_GetByteSize$offset() {\n+        return ExternalInitializerInfo_GetByteSize$OFFSET;\n@@ -11270,0 +37891,1 @@\n+     * Getter for field:\n@@ -11271,1 +37893,20 @@\n-     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment ExternalInitializerInfo_GetByteSize(MemorySegment struct) {\n+        return struct.get(ExternalInitializerInfo_GetByteSize$LAYOUT, ExternalInitializerInfo_GetByteSize$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t (*ExternalInitializerInfo_GetByteSize)(const OrtExternalInitializerInfo *)\n+     * }\n+     *\/\n+    public static void ExternalInitializerInfo_GetByteSize(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ExternalInitializerInfo_GetByteSize$LAYOUT, ExternalInitializerInfo_GetByteSize$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)\n@@ -11274,1 +37915,12 @@\n-    private static class GetOptionalContainedTypeInfo {\n+    public static class GetRunConfigEntry {\n+\n+        GetRunConfigEntry() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -11277,3 +37929,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11282,0 +37934,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetRunConfigEntry.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetRunConfigEntry.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11296,3 +37965,1 @@\n-    private static final AddressLayout GetOptionalContainedTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOptionalContainedTypeInfo\"));\n-\n-    private static final long GetOptionalContainedTypeInfo$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetOptionalContainedTypeInfo\"));\n+    private static final AddressLayout GetRunConfigEntry$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetRunConfigEntry\"));\n@@ -11301,1 +37968,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11303,1 +37970,1 @@\n-     * OrtStatusPtr (*GetOptionalContainedTypeInfo)(const OrtOptionalTypeInfo *, OrtTypeInfo **)\n+     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)\n@@ -11306,3 +37973,2 @@\n-    public static MemorySegment GetOptionalContainedTypeInfo(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(GetOptionalContainedTypeInfo$LAYOUT, GetOptionalContainedTypeInfo$OFFSET);\n-        return GetOptionalContainedTypeInfo.invoke(funcPtr, _x0, _x1);\n+    public static final AddressLayout GetRunConfigEntry$layout() {\n+        return GetRunConfigEntry$LAYOUT;\n@@ -11311,0 +37977,2 @@\n+    private static final long GetRunConfigEntry$OFFSET = 2984;\n+\n@@ -11312,0 +37980,1 @@\n+     * Offset for field:\n@@ -11313,1 +37982,1 @@\n-     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)\n@@ -11316,22 +37985,2 @@\n-    private static class GetResizedStringTensorElementBuffer {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetRunConfigEntry$offset() {\n+        return GetRunConfigEntry$OFFSET;\n@@ -11340,3 +37989,9 @@\n-    private static final AddressLayout GetResizedStringTensorElementBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetResizedStringTensorElementBuffer\"));\n-\n-    private static final long GetResizedStringTensorElementBuffer$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetResizedStringTensorElementBuffer\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment GetRunConfigEntry(MemorySegment struct) {\n+        return struct.get(GetRunConfigEntry$LAYOUT, GetRunConfigEntry$OFFSET);\n+    }\n@@ -11345,1 +38000,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11347,1 +38002,1 @@\n-     * OrtStatusPtr (*GetResizedStringTensorElementBuffer)(OrtValue *, size_t, size_t, char **)\n+     * const char *(*GetRunConfigEntry)(const OrtRunOptions *, const char *)\n@@ -11350,3 +38005,2 @@\n-    public static MemorySegment GetResizedStringTensorElementBuffer(MemorySegment struct, MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(GetResizedStringTensorElementBuffer$LAYOUT, GetResizedStringTensorElementBuffer$OFFSET);\n-        return GetResizedStringTensorElementBuffer.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void GetRunConfigEntry(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetRunConfigEntry$LAYOUT, GetRunConfigEntry$OFFSET, fieldValue);\n@@ -11357,1 +38011,1 @@\n-     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11360,1 +38014,12 @@\n-    private static class KernelContext_GetAllocator {\n+    public static class EpDevice_MemoryInfo {\n+\n+        EpDevice_MemoryInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n@@ -11363,4 +38028,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -11369,0 +38033,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(EpDevice_MemoryInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(EpDevice_MemoryInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11374,1 +38055,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n@@ -11376,1 +38057,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -11383,3 +38064,1 @@\n-    private static final AddressLayout KernelContext_GetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetAllocator\"));\n-\n-    private static final long KernelContext_GetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetAllocator\"));\n+    private static final AddressLayout EpDevice_MemoryInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"EpDevice_MemoryInfo\"));\n@@ -11388,1 +38067,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11390,1 +38069,1 @@\n-     * OrtStatusPtr (*KernelContext_GetAllocator)(const OrtKernelContext *, const OrtMemoryInfo *, OrtAllocator **)\n+     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11393,3 +38072,2 @@\n-    public static MemorySegment KernelContext_GetAllocator(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelContext_GetAllocator$LAYOUT, KernelContext_GetAllocator$OFFSET);\n-        return KernelContext_GetAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout EpDevice_MemoryInfo$layout() {\n+        return EpDevice_MemoryInfo$LAYOUT;\n@@ -11398,0 +38076,2 @@\n+    private static final long EpDevice_MemoryInfo$OFFSET = 2992;\n+\n@@ -11399,0 +38079,1 @@\n+     * Offset for field:\n@@ -11400,1 +38081,1 @@\n-     * const char *(*GetBuildInfoString)(void)\n+     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11402,18 +38083,3 @@\n-     *\/\n-    private static class GetBuildInfoString {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER);\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+     *\/\n+    public static final long EpDevice_MemoryInfo$offset() {\n+        return EpDevice_MemoryInfo$OFFSET;\n@@ -11422,3 +38088,9 @@\n-    private static final AddressLayout GetBuildInfoString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetBuildInfoString\"));\n-\n-    private static final long GetBuildInfoString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetBuildInfoString\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)\n+     * }\n+     *\/\n+    public static MemorySegment EpDevice_MemoryInfo(MemorySegment struct) {\n+        return struct.get(EpDevice_MemoryInfo$LAYOUT, EpDevice_MemoryInfo$OFFSET);\n+    }\n@@ -11427,1 +38099,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11429,1 +38101,1 @@\n-     * const char *(*GetBuildInfoString)(void)\n+     * const OrtMemoryInfo *(*EpDevice_MemoryInfo)(const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11432,3 +38104,2 @@\n-    public static MemorySegment GetBuildInfoString(MemorySegment struct) {\n-        var funcPtr = struct.get(GetBuildInfoString$LAYOUT, GetBuildInfoString$OFFSET);\n-        return GetBuildInfoString.invoke(funcPtr);\n+    public static void EpDevice_MemoryInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(EpDevice_MemoryInfo$LAYOUT, EpDevice_MemoryInfo$OFFSET, fieldValue);\n@@ -11439,1 +38110,1 @@\n-     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)\n@@ -11442,1 +38113,12 @@\n-    private static class CreateROCMProviderOptions {\n+    public static class CreateSharedAllocator {\n+\n+        CreateSharedAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5);\n+        }\n@@ -11445,2 +38127,7 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_INT,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11449,0 +38136,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSharedAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSharedAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11454,1 +38158,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2, int _x3, MemorySegment _x4, MemorySegment _x5) {\n@@ -11456,1 +38160,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5);\n@@ -11463,3 +38167,1 @@\n-    private static final AddressLayout CreateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateROCMProviderOptions\"));\n-\n-    private static final long CreateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateROCMProviderOptions\"));\n+    private static final AddressLayout CreateSharedAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSharedAllocator\"));\n@@ -11468,1 +38170,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11470,1 +38172,1 @@\n-     * OrtStatusPtr (*CreateROCMProviderOptions)(OrtROCMProviderOptions **)\n+     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)\n@@ -11473,3 +38175,2 @@\n-    public static MemorySegment CreateROCMProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(CreateROCMProviderOptions$LAYOUT, CreateROCMProviderOptions$OFFSET);\n-        return CreateROCMProviderOptions.invoke(funcPtr, _x0);\n+    public static final AddressLayout CreateSharedAllocator$layout() {\n+        return CreateSharedAllocator$LAYOUT;\n@@ -11478,0 +38179,2 @@\n+    private static final long CreateSharedAllocator$OFFSET = 3000;\n+\n@@ -11479,0 +38182,1 @@\n+     * Offset for field:\n@@ -11480,1 +38184,1 @@\n-     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)\n@@ -11483,22 +38187,2 @@\n-    private static class UpdateROCMProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateSharedAllocator$offset() {\n+        return CreateSharedAllocator$OFFSET;\n@@ -11507,3 +38191,9 @@\n-    private static final AddressLayout UpdateROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateROCMProviderOptions\"));\n-\n-    private static final long UpdateROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateROCMProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSharedAllocator(MemorySegment struct) {\n+        return struct.get(CreateSharedAllocator$LAYOUT, CreateSharedAllocator$OFFSET);\n+    }\n@@ -11512,1 +38202,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11514,1 +38204,1 @@\n-     * OrtStatusPtr (*UpdateROCMProviderOptions)(OrtROCMProviderOptions *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*CreateSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType, OrtAllocatorType, const OrtKeyValuePairs *, OrtAllocator **)\n@@ -11517,3 +38207,2 @@\n-    public static MemorySegment UpdateROCMProviderOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(UpdateROCMProviderOptions$LAYOUT, UpdateROCMProviderOptions$OFFSET);\n-        return UpdateROCMProviderOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void CreateSharedAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSharedAllocator$LAYOUT, CreateSharedAllocator$OFFSET, fieldValue);\n@@ -11524,1 +38213,1 @@\n-     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)\n@@ -11527,1 +38216,12 @@\n-    private static class GetROCMProviderOptionsAsString {\n+    public static class GetSharedAllocator {\n+\n+        GetSharedAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -11530,4 +38230,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11536,0 +38236,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSharedAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSharedAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11550,3 +38267,1 @@\n-    private static final AddressLayout GetROCMProviderOptionsAsString$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetROCMProviderOptionsAsString\"));\n-\n-    private static final long GetROCMProviderOptionsAsString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetROCMProviderOptionsAsString\"));\n+    private static final AddressLayout GetSharedAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSharedAllocator\"));\n@@ -11555,1 +38270,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11557,1 +38272,1 @@\n-     * OrtStatusPtr (*GetROCMProviderOptionsAsString)(const OrtROCMProviderOptions *, OrtAllocator *, char **)\n+     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)\n@@ -11560,3 +38275,2 @@\n-    public static MemorySegment GetROCMProviderOptionsAsString(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetROCMProviderOptionsAsString$LAYOUT, GetROCMProviderOptionsAsString$OFFSET);\n-        return GetROCMProviderOptionsAsString.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout GetSharedAllocator$layout() {\n+        return GetSharedAllocator$LAYOUT;\n@@ -11565,0 +38279,2 @@\n+    private static final long GetSharedAllocator$OFFSET = 3008;\n+\n@@ -11566,0 +38282,1 @@\n+     * Offset for field:\n@@ -11567,1 +38284,1 @@\n-     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)\n@@ -11570,18 +38287,2 @@\n-    private static class ReleaseROCMProviderOptions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetSharedAllocator$offset() {\n+        return GetSharedAllocator$OFFSET;\n@@ -11590,3 +38291,9 @@\n-    private static final AddressLayout ReleaseROCMProviderOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseROCMProviderOptions\"));\n-\n-    private static final long ReleaseROCMProviderOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseROCMProviderOptions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSharedAllocator(MemorySegment struct) {\n+        return struct.get(GetSharedAllocator$LAYOUT, GetSharedAllocator$OFFSET);\n+    }\n@@ -11595,1 +38302,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11597,1 +38304,1 @@\n-     * void (*ReleaseROCMProviderOptions)(OrtROCMProviderOptions *)\n+     * OrtStatusPtr (*GetSharedAllocator)(OrtEnv *, const OrtMemoryInfo *, OrtAllocator **)\n@@ -11600,3 +38307,2 @@\n-    public static void ReleaseROCMProviderOptions(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseROCMProviderOptions$LAYOUT, ReleaseROCMProviderOptions$OFFSET);\n-        ReleaseROCMProviderOptions.invoke(funcPtr, _x0);\n+    public static void GetSharedAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSharedAllocator$LAYOUT, GetSharedAllocator$OFFSET, fieldValue);\n@@ -11607,1 +38313,1 @@\n-     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11610,1 +38316,12 @@\n-    private static class CreateAndRegisterAllocatorV2 {\n+    public static class ReleaseSharedAllocator {\n+\n+        ReleaseSharedAllocator() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, int _x2);\n+        }\n@@ -11613,8 +38330,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_INT\n@@ -11623,0 +38336,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseSharedAllocator.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseSharedAllocator.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11628,1 +38358,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, int _x2) {\n@@ -11630,1 +38360,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n@@ -11637,3 +38367,1 @@\n-    private static final AddressLayout CreateAndRegisterAllocatorV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateAndRegisterAllocatorV2\"));\n-\n-    private static final long CreateAndRegisterAllocatorV2$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateAndRegisterAllocatorV2\"));\n+    private static final AddressLayout ReleaseSharedAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSharedAllocator\"));\n@@ -11642,1 +38370,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11644,1 +38372,1 @@\n-     * OrtStatusPtr (*CreateAndRegisterAllocatorV2)(OrtEnv *, const char *, const OrtMemoryInfo *, const OrtArenaCfg *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11647,3 +38375,2 @@\n-    public static MemorySegment CreateAndRegisterAllocatorV2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, MemorySegment _x4, MemorySegment _x5, long _x6) {\n-        var funcPtr = struct.get(CreateAndRegisterAllocatorV2$LAYOUT, CreateAndRegisterAllocatorV2$OFFSET);\n-        return CreateAndRegisterAllocatorV2.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6);\n+    public static final AddressLayout ReleaseSharedAllocator$layout() {\n+        return ReleaseSharedAllocator$LAYOUT;\n@@ -11652,0 +38379,2 @@\n+    private static final long ReleaseSharedAllocator$OFFSET = 3016;\n+\n@@ -11653,0 +38382,1 @@\n+     * Offset for field:\n@@ -11654,1 +38384,1 @@\n-     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11657,28 +38387,2 @@\n-    private static class RunAsync {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseSharedAllocator$offset() {\n+        return ReleaseSharedAllocator$OFFSET;\n@@ -11687,3 +38391,9 @@\n-    private static final AddressLayout RunAsync$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunAsync\"));\n-\n-    private static final long RunAsync$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunAsync\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseSharedAllocator(MemorySegment struct) {\n+        return struct.get(ReleaseSharedAllocator$LAYOUT, ReleaseSharedAllocator$OFFSET);\n+    }\n@@ -11692,1 +38402,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11694,1 +38404,1 @@\n-     * OrtStatusPtr (*RunAsync)(OrtSession *, const OrtRunOptions *, const char *const *, const OrtValue *const *, size_t, const char *const *, size_t, OrtValue **, RunAsyncCallbackFn, void *)\n+     * OrtStatusPtr (*ReleaseSharedAllocator)(OrtEnv *, const OrtEpDevice *, OrtDeviceMemoryType)\n@@ -11697,3 +38407,2 @@\n-    public static MemorySegment RunAsync(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, MemorySegment _x8, MemorySegment _x9) {\n-        var funcPtr = struct.get(RunAsync$LAYOUT, RunAsync$OFFSET);\n-        return RunAsync.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);\n+    public static void ReleaseSharedAllocator(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseSharedAllocator$LAYOUT, ReleaseSharedAllocator$OFFSET, fieldValue);\n@@ -11704,1 +38413,1 @@\n-     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)\n@@ -11707,1 +38416,12 @@\n-    private static class UpdateTensorRTProviderOptionsWithValue {\n+    public static class GetTensorData {\n+\n+        GetTensorData() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -11710,4 +38430,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11716,0 +38435,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetTensorData.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetTensorData.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11721,1 +38457,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -11723,1 +38459,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -11730,3 +38466,1 @@\n-    private static final AddressLayout UpdateTensorRTProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateTensorRTProviderOptionsWithValue\"));\n-\n-    private static final long UpdateTensorRTProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateTensorRTProviderOptionsWithValue\"));\n+    private static final AddressLayout GetTensorData$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorData\"));\n@@ -11735,1 +38469,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11737,1 +38471,1 @@\n-     * OrtStatusPtr (*UpdateTensorRTProviderOptionsWithValue)(OrtTensorRTProviderOptionsV2 *, const char *, void *)\n+     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)\n@@ -11740,3 +38474,2 @@\n-    public static MemorySegment UpdateTensorRTProviderOptionsWithValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(UpdateTensorRTProviderOptionsWithValue$LAYOUT, UpdateTensorRTProviderOptionsWithValue$OFFSET);\n-        return UpdateTensorRTProviderOptionsWithValue.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout GetTensorData$layout() {\n+        return GetTensorData$LAYOUT;\n@@ -11745,0 +38478,2 @@\n+    private static final long GetTensorData$OFFSET = 3024;\n+\n@@ -11746,0 +38481,1 @@\n+     * Offset for field:\n@@ -11747,1 +38483,1 @@\n-     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)\n@@ -11750,21 +38486,2 @@\n-    private static class GetTensorRTProviderOptionsByName {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetTensorData$offset() {\n+        return GetTensorData$OFFSET;\n@@ -11773,3 +38490,9 @@\n-    private static final AddressLayout GetTensorRTProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetTensorRTProviderOptionsByName\"));\n-\n-    private static final long GetTensorRTProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetTensorRTProviderOptionsByName\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)\n+     * }\n+     *\/\n+    public static MemorySegment GetTensorData(MemorySegment struct) {\n+        return struct.get(GetTensorData$LAYOUT, GetTensorData$OFFSET);\n+    }\n@@ -11778,1 +38501,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11780,1 +38503,1 @@\n-     * OrtStatusPtr (*GetTensorRTProviderOptionsByName)(const OrtTensorRTProviderOptionsV2 *, const char *, void **)\n+     * OrtStatusPtr (*GetTensorData)(const OrtValue *, const void **)\n@@ -11783,3 +38506,2 @@\n-    public static MemorySegment GetTensorRTProviderOptionsByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetTensorRTProviderOptionsByName$LAYOUT, GetTensorRTProviderOptionsByName$OFFSET);\n-        return GetTensorRTProviderOptionsByName.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void GetTensorData(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetTensorData$LAYOUT, GetTensorData$OFFSET, fieldValue);\n@@ -11790,1 +38512,1 @@\n-     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n+     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)\n@@ -11793,1 +38515,12 @@\n-    private static class UpdateCUDAProviderOptionsWithValue {\n+    public static class GetSessionOptionsConfigEntries {\n+\n+        GetSessionOptionsConfigEntries() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -11796,4 +38529,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -11802,0 +38534,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetSessionOptionsConfigEntries.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetSessionOptionsConfigEntries.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11807,1 +38556,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -11809,1 +38558,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -11816,1 +38565,11 @@\n-    private static final AddressLayout UpdateCUDAProviderOptionsWithValue$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"UpdateCUDAProviderOptionsWithValue\"));\n+    private static final AddressLayout GetSessionOptionsConfigEntries$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetSessionOptionsConfigEntries\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetSessionOptionsConfigEntries$layout() {\n+        return GetSessionOptionsConfigEntries$LAYOUT;\n+    }\n@@ -11818,1 +38577,1 @@\n-    private static final long UpdateCUDAProviderOptionsWithValue$OFFSET = $LAYOUT.byteOffset(groupElement(\"UpdateCUDAProviderOptionsWithValue\"));\n+    private static final long GetSessionOptionsConfigEntries$OFFSET = 3032;\n@@ -11821,1 +38580,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -11823,1 +38582,1 @@\n-     * OrtStatusPtr (*UpdateCUDAProviderOptionsWithValue)(OrtCUDAProviderOptionsV2 *, const char *, void *)\n+     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)\n@@ -11826,3 +38585,2 @@\n-    public static MemorySegment UpdateCUDAProviderOptionsWithValue(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(UpdateCUDAProviderOptionsWithValue$LAYOUT, UpdateCUDAProviderOptionsWithValue$OFFSET);\n-        return UpdateCUDAProviderOptionsWithValue.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final long GetSessionOptionsConfigEntries$offset() {\n+        return GetSessionOptionsConfigEntries$OFFSET;\n@@ -11832,0 +38590,1 @@\n+     * Getter for field:\n@@ -11833,1 +38592,20 @@\n-     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n+     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static MemorySegment GetSessionOptionsConfigEntries(MemorySegment struct) {\n+        return struct.get(GetSessionOptionsConfigEntries$LAYOUT, GetSessionOptionsConfigEntries$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetSessionOptionsConfigEntries)(const OrtSessionOptions *, OrtKeyValuePairs **)\n+     * }\n+     *\/\n+    public static void GetSessionOptionsConfigEntries(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetSessionOptionsConfigEntries$LAYOUT, GetSessionOptionsConfigEntries$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11836,1 +38614,12 @@\n-    private static class GetCUDAProviderOptionsByName {\n+    public static class SessionGetMemoryInfoForInputs {\n+\n+        SessionGetMemoryInfoForInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -11839,4 +38628,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -11845,0 +38634,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetMemoryInfoForInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetMemoryInfoForInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11850,1 +38656,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -11859,3 +38665,1 @@\n-    private static final AddressLayout GetCUDAProviderOptionsByName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetCUDAProviderOptionsByName\"));\n-\n-    private static final long GetCUDAProviderOptionsByName$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetCUDAProviderOptionsByName\"));\n+    private static final AddressLayout SessionGetMemoryInfoForInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetMemoryInfoForInputs\"));\n@@ -11864,1 +38668,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11866,1 +38670,1 @@\n-     * OrtStatusPtr (*GetCUDAProviderOptionsByName)(const OrtCUDAProviderOptionsV2 *, const char *, void **)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11869,3 +38673,2 @@\n-    public static MemorySegment GetCUDAProviderOptionsByName(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(GetCUDAProviderOptionsByName$LAYOUT, GetCUDAProviderOptionsByName$OFFSET);\n-        return GetCUDAProviderOptionsByName.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout SessionGetMemoryInfoForInputs$layout() {\n+        return SessionGetMemoryInfoForInputs$LAYOUT;\n@@ -11874,0 +38677,2 @@\n+    private static final long SessionGetMemoryInfoForInputs$OFFSET = 3040;\n+\n@@ -11875,0 +38680,1 @@\n+     * Offset for field:\n@@ -11876,1 +38682,1 @@\n-     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11879,22 +38685,2 @@\n-    private static class KernelContext_GetResource {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionGetMemoryInfoForInputs$offset() {\n+        return SessionGetMemoryInfoForInputs$OFFSET;\n@@ -11903,3 +38689,9 @@\n-    private static final AddressLayout KernelContext_GetResource$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetResource\"));\n-\n-    private static final long KernelContext_GetResource$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetResource\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetMemoryInfoForInputs(MemorySegment struct) {\n+        return struct.get(SessionGetMemoryInfoForInputs$LAYOUT, SessionGetMemoryInfoForInputs$OFFSET);\n+    }\n@@ -11908,1 +38700,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11910,1 +38702,1 @@\n-     * OrtStatusPtr (*KernelContext_GetResource)(const OrtKernelContext *, int, int, void **)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForInputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11913,3 +38705,2 @@\n-    public static MemorySegment KernelContext_GetResource(MemorySegment struct, MemorySegment _x0, int _x1, int _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelContext_GetResource$LAYOUT, KernelContext_GetResource$OFFSET);\n-        return KernelContext_GetResource.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void SessionGetMemoryInfoForInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetMemoryInfoForInputs$LAYOUT, SessionGetMemoryInfoForInputs$OFFSET, fieldValue);\n@@ -11920,1 +38711,1 @@\n-     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11923,1 +38714,12 @@\n-    private static class SetUserLoggingFunction {\n+    public static class SessionGetMemoryInfoForOutputs {\n+\n+        SessionGetMemoryInfoForOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -11926,4 +38728,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -11932,0 +38734,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetMemoryInfoForOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetMemoryInfoForOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -11937,1 +38756,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -11946,3 +38765,1 @@\n-    private static final AddressLayout SetUserLoggingFunction$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetUserLoggingFunction\"));\n-\n-    private static final long SetUserLoggingFunction$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetUserLoggingFunction\"));\n+    private static final AddressLayout SessionGetMemoryInfoForOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetMemoryInfoForOutputs\"));\n@@ -11951,1 +38768,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -11953,1 +38770,1 @@\n-     * OrtStatusPtr (*SetUserLoggingFunction)(OrtSessionOptions *, OrtLoggingFunction, void *)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11956,3 +38773,2 @@\n-    public static MemorySegment SetUserLoggingFunction(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(SetUserLoggingFunction$LAYOUT, SetUserLoggingFunction$OFFSET);\n-        return SetUserLoggingFunction.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout SessionGetMemoryInfoForOutputs$layout() {\n+        return SessionGetMemoryInfoForOutputs$LAYOUT;\n@@ -11961,0 +38777,2 @@\n+    private static final long SessionGetMemoryInfoForOutputs$OFFSET = 3048;\n+\n@@ -11962,0 +38780,1 @@\n+     * Offset for field:\n@@ -11963,1 +38782,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11966,20 +38785,2 @@\n-    private static class ShapeInferContext_GetInputCount {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionGetMemoryInfoForOutputs$offset() {\n+        return SessionGetMemoryInfoForOutputs$OFFSET;\n@@ -11988,3 +38789,9 @@\n-    private static final AddressLayout ShapeInferContext_GetInputCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetInputCount\"));\n-\n-    private static final long ShapeInferContext_GetInputCount$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_GetInputCount\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetMemoryInfoForOutputs(MemorySegment struct) {\n+        return struct.get(SessionGetMemoryInfoForOutputs$LAYOUT, SessionGetMemoryInfoForOutputs$OFFSET);\n+    }\n@@ -11993,1 +38800,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -11995,1 +38802,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_GetInputCount)(const OrtShapeInferContext *, size_t *)\n+     * OrtStatusPtr (*SessionGetMemoryInfoForOutputs)(const OrtSession *, const OrtMemoryInfo **, size_t)\n@@ -11998,3 +38805,2 @@\n-    public static MemorySegment ShapeInferContext_GetInputCount(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(ShapeInferContext_GetInputCount$LAYOUT, ShapeInferContext_GetInputCount$OFFSET);\n-        return ShapeInferContext_GetInputCount.invoke(funcPtr, _x0, _x1);\n+    public static void SessionGetMemoryInfoForOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetMemoryInfoForOutputs$LAYOUT, SessionGetMemoryInfoForOutputs$OFFSET, fieldValue);\n@@ -12005,1 +38811,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)\n@@ -12008,1 +38814,12 @@\n-    private static class ShapeInferContext_GetInputTypeShape {\n+    public static class SessionGetEpDeviceForInputs {\n+\n+        SessionGetEpDeviceForInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n@@ -12011,4 +38828,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -12017,0 +38834,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SessionGetEpDeviceForInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetEpDeviceForInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12022,1 +38856,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n@@ -12031,3 +38865,1 @@\n-    private static final AddressLayout ShapeInferContext_GetInputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetInputTypeShape\"));\n-\n-    private static final long ShapeInferContext_GetInputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_GetInputTypeShape\"));\n+    private static final AddressLayout SessionGetEpDeviceForInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetEpDeviceForInputs\"));\n@@ -12036,1 +38868,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12038,1 +38870,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_GetInputTypeShape)(const OrtShapeInferContext *, size_t, OrtTensorTypeAndShapeInfo **)\n+     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)\n@@ -12041,3 +38873,2 @@\n-    public static MemorySegment ShapeInferContext_GetInputTypeShape(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ShapeInferContext_GetInputTypeShape$LAYOUT, ShapeInferContext_GetInputTypeShape$OFFSET);\n-        return ShapeInferContext_GetInputTypeShape.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout SessionGetEpDeviceForInputs$layout() {\n+        return SessionGetEpDeviceForInputs$LAYOUT;\n@@ -12046,0 +38877,2 @@\n+    private static final long SessionGetEpDeviceForInputs$OFFSET = 3056;\n+\n@@ -12047,0 +38880,1 @@\n+     * Offset for field:\n@@ -12048,1 +38882,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n+     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)\n@@ -12051,21 +38885,2 @@\n-    private static class ShapeInferContext_GetAttribute {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SessionGetEpDeviceForInputs$offset() {\n+        return SessionGetEpDeviceForInputs$OFFSET;\n@@ -12074,3 +38889,9 @@\n-    private static final AddressLayout ShapeInferContext_GetAttribute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_GetAttribute\"));\n-\n-    private static final long ShapeInferContext_GetAttribute$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_GetAttribute\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetEpDeviceForInputs(MemorySegment struct) {\n+        return struct.get(SessionGetEpDeviceForInputs$LAYOUT, SessionGetEpDeviceForInputs$OFFSET);\n+    }\n@@ -12079,1 +38900,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -12081,1 +38902,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_GetAttribute)(const OrtShapeInferContext *, const char *, const OrtOpAttr **)\n+     * OrtStatusPtr (*SessionGetEpDeviceForInputs)(const OrtSession *, const OrtEpDevice **, size_t)\n@@ -12084,3 +38905,2 @@\n-    public static MemorySegment ShapeInferContext_GetAttribute(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ShapeInferContext_GetAttribute$LAYOUT, ShapeInferContext_GetAttribute$OFFSET);\n-        return ShapeInferContext_GetAttribute.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void SessionGetEpDeviceForInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetEpDeviceForInputs$LAYOUT, SessionGetEpDeviceForInputs$OFFSET, fieldValue);\n@@ -12091,1 +38911,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n+     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)\n@@ -12094,1 +38914,12 @@\n-    private static class ShapeInferContext_SetOutputTypeShape {\n+    public static class CreateSyncStreamForEpDevice {\n+\n+        CreateSyncStreamForEpDevice() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n@@ -12097,4 +38928,4 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -12103,0 +38934,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateSyncStreamForEpDevice.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSyncStreamForEpDevice.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12108,1 +38956,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, MemorySegment _x2) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n@@ -12117,3 +38965,1 @@\n-    private static final AddressLayout ShapeInferContext_SetOutputTypeShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ShapeInferContext_SetOutputTypeShape\"));\n-\n-    private static final long ShapeInferContext_SetOutputTypeShape$OFFSET = $LAYOUT.byteOffset(groupElement(\"ShapeInferContext_SetOutputTypeShape\"));\n+    private static final AddressLayout CreateSyncStreamForEpDevice$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSyncStreamForEpDevice\"));\n@@ -12122,1 +38968,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12124,1 +38970,1 @@\n-     * OrtStatusPtr (*ShapeInferContext_SetOutputTypeShape)(const OrtShapeInferContext *, size_t, const OrtTensorTypeAndShapeInfo *)\n+     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)\n@@ -12127,3 +38973,2 @@\n-    public static MemorySegment ShapeInferContext_SetOutputTypeShape(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(ShapeInferContext_SetOutputTypeShape$LAYOUT, ShapeInferContext_SetOutputTypeShape$OFFSET);\n-        return ShapeInferContext_SetOutputTypeShape.invoke(funcPtr, _x0, _x1, _x2);\n+    public static final AddressLayout CreateSyncStreamForEpDevice$layout() {\n+        return CreateSyncStreamForEpDevice$LAYOUT;\n@@ -12132,0 +38977,2 @@\n+    private static final long CreateSyncStreamForEpDevice$OFFSET = 3064;\n+\n@@ -12133,0 +38980,1 @@\n+     * Offset for field:\n@@ -12134,1 +38982,1 @@\n-     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)\n@@ -12137,21 +38985,2 @@\n-    private static class SetSymbolicDimensions {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CreateSyncStreamForEpDevice$offset() {\n+        return CreateSyncStreamForEpDevice$OFFSET;\n@@ -12160,3 +38989,9 @@\n-    private static final AddressLayout SetSymbolicDimensions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetSymbolicDimensions\"));\n-\n-    private static final long SetSymbolicDimensions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetSymbolicDimensions\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSyncStreamForEpDevice(MemorySegment struct) {\n+        return struct.get(CreateSyncStreamForEpDevice$LAYOUT, CreateSyncStreamForEpDevice$OFFSET);\n+    }\n@@ -12165,1 +39000,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -12167,1 +39002,1 @@\n-     * OrtStatusPtr (*SetSymbolicDimensions)(OrtTensorTypeAndShapeInfo *, const char **, size_t)\n+     * OrtStatusPtr (*CreateSyncStreamForEpDevice)(const OrtEpDevice *, const OrtKeyValuePairs *, OrtSyncStream **)\n@@ -12170,3 +39005,2 @@\n-    public static MemorySegment SetSymbolicDimensions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2) {\n-        var funcPtr = struct.get(SetSymbolicDimensions$LAYOUT, SetSymbolicDimensions$OFFSET);\n-        return SetSymbolicDimensions.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void CreateSyncStreamForEpDevice(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSyncStreamForEpDevice$LAYOUT, CreateSyncStreamForEpDevice$OFFSET, fieldValue);\n@@ -12177,1 +39011,1 @@\n-     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n+     * void *(*SyncStream_GetHandle)(OrtSyncStream *)\n@@ -12180,1 +39014,12 @@\n-    private static class ReadOpAttr {\n+    public static class SyncStream_GetHandle {\n+\n+        SyncStream_GetHandle() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n@@ -12183,6 +39028,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -12191,0 +39032,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(SyncStream_GetHandle.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SyncStream_GetHandle.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12196,1 +39054,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -12198,1 +39056,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -12205,3 +39063,1 @@\n-    private static final AddressLayout ReadOpAttr$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReadOpAttr\"));\n-\n-    private static final long ReadOpAttr$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReadOpAttr\"));\n+    private static final AddressLayout SyncStream_GetHandle$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SyncStream_GetHandle\"));\n@@ -12210,1 +39066,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12212,1 +39068,1 @@\n-     * OrtStatusPtr (*ReadOpAttr)(const OrtOpAttr *, OrtOpAttrType, void *, size_t, size_t *)\n+     * void *(*SyncStream_GetHandle)(OrtSyncStream *)\n@@ -12215,3 +39071,2 @@\n-    public static MemorySegment ReadOpAttr(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2, long _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(ReadOpAttr$LAYOUT, ReadOpAttr$OFFSET);\n-        return ReadOpAttr.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout SyncStream_GetHandle$layout() {\n+        return SyncStream_GetHandle$LAYOUT;\n@@ -12220,0 +39075,2 @@\n+    private static final long SyncStream_GetHandle$OFFSET = 3072;\n+\n@@ -12221,0 +39078,1 @@\n+     * Offset for field:\n@@ -12222,1 +39080,1 @@\n-     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n+     * void *(*SyncStream_GetHandle)(OrtSyncStream *)\n@@ -12225,20 +39083,2 @@\n-    private static class SetDeterministicCompute {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_BOOL\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long SyncStream_GetHandle$offset() {\n+        return SyncStream_GetHandle$OFFSET;\n@@ -12247,4 +39087,0 @@\n-    private static final AddressLayout SetDeterministicCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetDeterministicCompute\"));\n-\n-    private static final long SetDeterministicCompute$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetDeterministicCompute\"));\n-\n@@ -12252,1 +39088,1 @@\n-     * Invoker for field:\n+     * Getter for field:\n@@ -12254,1 +39090,1 @@\n-     * OrtStatusPtr (*SetDeterministicCompute)(OrtSessionOptions *, bool)\n+     * void *(*SyncStream_GetHandle)(OrtSyncStream *)\n@@ -12257,3 +39093,2 @@\n-    public static MemorySegment SetDeterministicCompute(MemorySegment struct, MemorySegment _x0, boolean _x1) {\n-        var funcPtr = struct.get(SetDeterministicCompute$LAYOUT, SetDeterministicCompute$OFFSET);\n-        return SetDeterministicCompute.invoke(funcPtr, _x0, _x1);\n+    public static MemorySegment SyncStream_GetHandle(MemorySegment struct) {\n+        return struct.get(SyncStream_GetHandle$LAYOUT, SyncStream_GetHandle$OFFSET);\n@@ -12263,0 +39098,1 @@\n+     * Setter for field:\n@@ -12264,1 +39100,1 @@\n-     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n+     * void *(*SyncStream_GetHandle)(OrtSyncStream *)\n@@ -12267,1 +39103,3 @@\n-    private static class KernelContext_ParallelFor {\n+    public static void SyncStream_GetHandle(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SyncStream_GetHandle$LAYOUT, SyncStream_GetHandle$OFFSET, fieldValue);\n+    }\n@@ -12269,8 +39107,6 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseSyncStream)(OrtSyncStream *)\n+     * }\n+     *\/\n+    public static class ReleaseSyncStream {\n@@ -12278,1 +39114,3 @@\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+        ReleaseSyncStream() {\n+            \/\/ Should not be called directly\n+        }\n@@ -12281,1 +39119,1 @@\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         * The function pointer signature, expressed as a functional interface\n@@ -12283,6 +39121,2 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n@@ -12290,3 +39124,0 @@\n-    }\n-\n-    private static final AddressLayout KernelContext_ParallelFor$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_ParallelFor\"));\n@@ -12294,1 +39125,3 @@\n-    private static final long KernelContext_ParallelFor$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_ParallelFor\"));\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            coreml_provider_factory_h.C_POINTER\n+        );\n@@ -12296,10 +39129,6 @@\n-    \/**\n-     * Invoker for field:\n-     * {@snippet lang=c :\n-     * OrtStatusPtr (*KernelContext_ParallelFor)(const OrtKernelContext *, void (*)(void *, size_t), size_t, size_t, void *)\n-     * }\n-     *\/\n-    public static MemorySegment KernelContext_ParallelFor(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, long _x3, MemorySegment _x4) {\n-        var funcPtr = struct.get(KernelContext_ParallelFor$LAYOUT, KernelContext_ParallelFor$OFFSET);\n-        return KernelContext_ParallelFor.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n-    }\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n@@ -12307,6 +39136,1 @@\n-    \/**\n-     * {@snippet lang=c :\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n-     * }\n-     *\/\n-    private static class SessionOptionsAppendExecutionProvider_OpenVINO_V2 {\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(ReleaseSyncStream.Function.class, \"apply\", $DESC);\n@@ -12314,7 +39138,7 @@\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseSyncStream.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n@@ -12327,1 +39151,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -12329,1 +39153,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -12336,3 +39160,1 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_OpenVINO_V2\"));\n+    private static final AddressLayout ReleaseSyncStream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseSyncStream\"));\n@@ -12341,1 +39163,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12343,1 +39165,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_OpenVINO_V2)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * void (*ReleaseSyncStream)(OrtSyncStream *)\n@@ -12346,3 +39168,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_OpenVINO_V2(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_OpenVINO_V2$LAYOUT, SessionOptionsAppendExecutionProvider_OpenVINO_V2$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_OpenVINO_V2.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout ReleaseSyncStream$layout() {\n+        return ReleaseSyncStream$LAYOUT;\n@@ -12351,0 +39172,2 @@\n+    private static final long ReleaseSyncStream$OFFSET = 3080;\n+\n@@ -12352,0 +39175,1 @@\n+     * Offset for field:\n@@ -12353,1 +39177,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * void (*ReleaseSyncStream)(OrtSyncStream *)\n@@ -12356,22 +39180,2 @@\n-    private static class SessionOptionsAppendExecutionProvider_VitisAI {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long ReleaseSyncStream$offset() {\n+        return ReleaseSyncStream$OFFSET;\n@@ -12380,3 +39184,9 @@\n-    private static final AddressLayout SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionOptionsAppendExecutionProvider_VitisAI\"));\n-\n-    private static final long SessionOptionsAppendExecutionProvider_VitisAI$OFFSET = $LAYOUT.byteOffset(groupElement(\"SessionOptionsAppendExecutionProvider_VitisAI\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseSyncStream)(OrtSyncStream *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseSyncStream(MemorySegment struct) {\n+        return struct.get(ReleaseSyncStream$LAYOUT, ReleaseSyncStream$OFFSET);\n+    }\n@@ -12385,1 +39195,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -12387,1 +39197,1 @@\n-     * OrtStatusPtr (*SessionOptionsAppendExecutionProvider_VitisAI)(OrtSessionOptions *, const char *const *, const char *const *, size_t)\n+     * void (*ReleaseSyncStream)(OrtSyncStream *)\n@@ -12390,3 +39200,2 @@\n-    public static MemorySegment SessionOptionsAppendExecutionProvider_VitisAI(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(SessionOptionsAppendExecutionProvider_VitisAI$LAYOUT, SessionOptionsAppendExecutionProvider_VitisAI$OFFSET);\n-        return SessionOptionsAppendExecutionProvider_VitisAI.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void ReleaseSyncStream(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseSyncStream$LAYOUT, ReleaseSyncStream$OFFSET, fieldValue);\n@@ -12397,1 +39206,1 @@\n-     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n+     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)\n@@ -12400,1 +39209,12 @@\n-    private static class KernelContext_GetScratchBuffer {\n+    public static class CopyTensors {\n+\n+        CopyTensors() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4);\n+        }\n@@ -12403,5 +39223,6 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG\n@@ -12410,0 +39231,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CopyTensors.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CopyTensors.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12415,1 +39253,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n@@ -12417,1 +39255,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n@@ -12424,3 +39262,1 @@\n-    private static final AddressLayout KernelContext_GetScratchBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelContext_GetScratchBuffer\"));\n-\n-    private static final long KernelContext_GetScratchBuffer$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelContext_GetScratchBuffer\"));\n+    private static final AddressLayout CopyTensors$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CopyTensors\"));\n@@ -12429,1 +39265,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12431,1 +39267,1 @@\n-     * OrtStatusPtr (*KernelContext_GetScratchBuffer)(const OrtKernelContext *, const OrtMemoryInfo *, size_t, void **)\n+     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)\n@@ -12434,3 +39270,2 @@\n-    public static MemorySegment KernelContext_GetScratchBuffer(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(KernelContext_GetScratchBuffer$LAYOUT, KernelContext_GetScratchBuffer$OFFSET);\n-        return KernelContext_GetScratchBuffer.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout CopyTensors$layout() {\n+        return CopyTensors$LAYOUT;\n@@ -12439,0 +39274,2 @@\n+    private static final long CopyTensors$OFFSET = 3088;\n+\n@@ -12440,0 +39277,1 @@\n+     * Offset for field:\n@@ -12441,1 +39279,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n+     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)\n@@ -12444,21 +39282,2 @@\n-    private static class KernelInfoGetAllocator {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_INT,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long CopyTensors$offset() {\n+        return CopyTensors$OFFSET;\n@@ -12467,3 +39286,9 @@\n-    private static final AddressLayout KernelInfoGetAllocator$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelInfoGetAllocator\"));\n-\n-    private static final long KernelInfoGetAllocator$OFFSET = $LAYOUT.byteOffset(groupElement(\"KernelInfoGetAllocator\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment CopyTensors(MemorySegment struct) {\n+        return struct.get(CopyTensors$LAYOUT, CopyTensors$OFFSET);\n+    }\n@@ -12472,1 +39297,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -12474,1 +39299,1 @@\n-     * OrtStatusPtr (*KernelInfoGetAllocator)(const OrtKernelInfo *, OrtMemType, OrtAllocator **)\n+     * OrtStatusPtr (*CopyTensors)(const OrtEnv *, const OrtValue *const *, OrtValue *const *, OrtSyncStream *, size_t)\n@@ -12477,3 +39302,2 @@\n-    public static MemorySegment KernelInfoGetAllocator(MemorySegment struct, MemorySegment _x0, int _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(KernelInfoGetAllocator$LAYOUT, KernelInfoGetAllocator$OFFSET);\n-        return KernelInfoGetAllocator.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void CopyTensors(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CopyTensors$LAYOUT, CopyTensors$OFFSET, fieldValue);\n@@ -12484,1 +39308,1 @@\n-     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)\n@@ -12487,1 +39311,12 @@\n-    private static class AddExternalInitializersFromFilesInMemory {\n+    public static class Graph_GetModelMetadata {\n+\n+        Graph_GetModelMetadata() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n@@ -12490,6 +39325,3 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -12498,0 +39330,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(Graph_GetModelMetadata.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(Graph_GetModelMetadata.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12503,1 +39352,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n@@ -12505,1 +39354,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n@@ -12512,3 +39361,1 @@\n-    private static final AddressLayout AddExternalInitializersFromFilesInMemory$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddExternalInitializersFromFilesInMemory\"));\n-\n-    private static final long AddExternalInitializersFromFilesInMemory$OFFSET = $LAYOUT.byteOffset(groupElement(\"AddExternalInitializersFromFilesInMemory\"));\n+    private static final AddressLayout Graph_GetModelMetadata$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"Graph_GetModelMetadata\"));\n@@ -12517,1 +39364,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12519,1 +39366,1 @@\n-     * OrtStatusPtr (*AddExternalInitializersFromFilesInMemory)(OrtSessionOptions *, const char *const *, char *const *, const size_t *, size_t)\n+     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)\n@@ -12522,3 +39369,2 @@\n-    public static MemorySegment AddExternalInitializersFromFilesInMemory(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4) {\n-        var funcPtr = struct.get(AddExternalInitializersFromFilesInMemory$LAYOUT, AddExternalInitializersFromFilesInMemory$OFFSET);\n-        return AddExternalInitializersFromFilesInMemory.invoke(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+    public static final AddressLayout Graph_GetModelMetadata$layout() {\n+        return Graph_GetModelMetadata$LAYOUT;\n@@ -12527,0 +39373,2 @@\n+    private static final long Graph_GetModelMetadata$OFFSET = 3096;\n+\n@@ -12528,0 +39376,1 @@\n+     * Offset for field:\n@@ -12529,1 +39378,1 @@\n-     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n+     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)\n@@ -12532,21 +39381,2 @@\n-    private static class CreateLoraAdapter {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-            try {\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long Graph_GetModelMetadata$offset() {\n+        return Graph_GetModelMetadata$OFFSET;\n@@ -12555,3 +39385,9 @@\n-    private static final AddressLayout CreateLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateLoraAdapter\"));\n-\n-    private static final long CreateLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateLoraAdapter\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)\n+     * }\n+     *\/\n+    public static MemorySegment Graph_GetModelMetadata(MemorySegment struct) {\n+        return struct.get(Graph_GetModelMetadata$LAYOUT, Graph_GetModelMetadata$OFFSET);\n+    }\n@@ -12560,1 +39396,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -12562,1 +39398,1 @@\n-     * OrtStatusPtr (*CreateLoraAdapter)(const char *, OrtAllocator *, OrtLoraAdapter **)\n+     * OrtStatusPtr (*Graph_GetModelMetadata)(const OrtGraph *, OrtModelMetadata **)\n@@ -12565,3 +39401,2 @@\n-    public static MemorySegment CreateLoraAdapter(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n-        var funcPtr = struct.get(CreateLoraAdapter$LAYOUT, CreateLoraAdapter$OFFSET);\n-        return CreateLoraAdapter.invoke(funcPtr, _x0, _x1, _x2);\n+    public static void Graph_GetModelMetadata(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(Graph_GetModelMetadata$LAYOUT, Graph_GetModelMetadata$OFFSET, fieldValue);\n@@ -12572,1 +39407,1 @@\n-     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n+     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)\n@@ -12575,1 +39410,12 @@\n-    private static class CreateLoraAdapterFromArray {\n+    public static class GetModelCompatibilityForEpDevices {\n+\n+        GetModelCompatibilityForEpDevices() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n@@ -12578,5 +39424,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER\n@@ -12585,0 +39431,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(GetModelCompatibilityForEpDevices.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetModelCompatibilityForEpDevices.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12599,3 +39462,1 @@\n-    private static final AddressLayout CreateLoraAdapterFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateLoraAdapterFromArray\"));\n-\n-    private static final long CreateLoraAdapterFromArray$OFFSET = $LAYOUT.byteOffset(groupElement(\"CreateLoraAdapterFromArray\"));\n+    private static final AddressLayout GetModelCompatibilityForEpDevices$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetModelCompatibilityForEpDevices\"));\n@@ -12604,1 +39465,1 @@\n-     * Invoker for field:\n+     * Layout for field:\n@@ -12606,1 +39467,1 @@\n-     * OrtStatusPtr (*CreateLoraAdapterFromArray)(const void *, size_t, OrtAllocator *, OrtLoraAdapter **)\n+     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)\n@@ -12609,3 +39470,2 @@\n-    public static MemorySegment CreateLoraAdapterFromArray(MemorySegment struct, MemorySegment _x0, long _x1, MemorySegment _x2, MemorySegment _x3) {\n-        var funcPtr = struct.get(CreateLoraAdapterFromArray$LAYOUT, CreateLoraAdapterFromArray$OFFSET);\n-        return CreateLoraAdapterFromArray.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static final AddressLayout GetModelCompatibilityForEpDevices$layout() {\n+        return GetModelCompatibilityForEpDevices$LAYOUT;\n@@ -12614,0 +39474,2 @@\n+    private static final long GetModelCompatibilityForEpDevices$OFFSET = 3104;\n+\n@@ -12615,0 +39477,1 @@\n+     * Offset for field:\n@@ -12616,1 +39479,1 @@\n-     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n+     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)\n@@ -12619,18 +39482,2 @@\n-    private static class ReleaseLoraAdapter {\n-\n-        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n-            onnxruntime_c_api_h.C_POINTER\n-        );\n-\n-        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n-\n-        \/**\n-         * Invoke the upcall stub {@code funcPtr}, with given parameters\n-         *\/\n-        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n-            try {\n-                 DOWN$MH.invokeExact(funcPtr, _x0);\n-            } catch (Throwable ex$) {\n-                throw new AssertionError(\"should not reach here\", ex$);\n-            }\n-        }\n+    public static final long GetModelCompatibilityForEpDevices$offset() {\n+        return GetModelCompatibilityForEpDevices$OFFSET;\n@@ -12639,3 +39486,9 @@\n-    private static final AddressLayout ReleaseLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseLoraAdapter\"));\n-\n-    private static final long ReleaseLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement(\"ReleaseLoraAdapter\"));\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)\n+     * }\n+     *\/\n+    public static MemorySegment GetModelCompatibilityForEpDevices(MemorySegment struct) {\n+        return struct.get(GetModelCompatibilityForEpDevices$LAYOUT, GetModelCompatibilityForEpDevices$OFFSET);\n+    }\n@@ -12644,1 +39497,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -12646,1 +39499,1 @@\n-     * void (*ReleaseLoraAdapter)(OrtLoraAdapter *)\n+     * OrtStatusPtr (*GetModelCompatibilityForEpDevices)(const OrtEpDevice *const *, size_t, const char *, OrtCompiledModelCompatibility *)\n@@ -12649,3 +39502,2 @@\n-    public static void ReleaseLoraAdapter(MemorySegment struct, MemorySegment _x0) {\n-        var funcPtr = struct.get(ReleaseLoraAdapter$LAYOUT, ReleaseLoraAdapter$OFFSET);\n-        ReleaseLoraAdapter.invoke(funcPtr, _x0);\n+    public static void GetModelCompatibilityForEpDevices(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetModelCompatibilityForEpDevices$LAYOUT, GetModelCompatibilityForEpDevices$OFFSET, fieldValue);\n@@ -12656,1 +39508,1 @@\n-     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n+     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)\n@@ -12659,1 +39511,12 @@\n-    private static class RunOptionsAddActiveLoraAdapter {\n+    public static class CreateExternalInitializerInfo {\n+\n+        CreateExternalInitializerInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, long _x1, long _x2, MemorySegment _x3);\n+        }\n@@ -12662,3 +39525,5 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_POINTER,\n+            coreml_provider_factory_h.C_LONG_LONG,\n+            coreml_provider_factory_h.C_LONG,\n+            coreml_provider_factory_h.C_POINTER\n@@ -12667,0 +39532,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(CreateExternalInitializerInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateExternalInitializerInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12672,1 +39554,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1, long _x2, MemorySegment _x3) {\n@@ -12674,1 +39556,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n@@ -12681,1 +39563,11 @@\n-    private static final AddressLayout RunOptionsAddActiveLoraAdapter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"RunOptionsAddActiveLoraAdapter\"));\n+    private static final AddressLayout CreateExternalInitializerInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateExternalInitializerInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateExternalInitializerInfo$layout() {\n+        return CreateExternalInitializerInfo$LAYOUT;\n+    }\n@@ -12683,1 +39575,1 @@\n-    private static final long RunOptionsAddActiveLoraAdapter$OFFSET = $LAYOUT.byteOffset(groupElement(\"RunOptionsAddActiveLoraAdapter\"));\n+    private static final long CreateExternalInitializerInfo$OFFSET = 3112;\n@@ -12686,1 +39578,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -12688,1 +39580,1 @@\n-     * OrtStatusPtr (*RunOptionsAddActiveLoraAdapter)(OrtRunOptions *, const OrtLoraAdapter *)\n+     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)\n@@ -12691,3 +39583,2 @@\n-    public static MemorySegment RunOptionsAddActiveLoraAdapter(MemorySegment struct, MemorySegment _x0, MemorySegment _x1) {\n-        var funcPtr = struct.get(RunOptionsAddActiveLoraAdapter$LAYOUT, RunOptionsAddActiveLoraAdapter$OFFSET);\n-        return RunOptionsAddActiveLoraAdapter.invoke(funcPtr, _x0, _x1);\n+    public static final long CreateExternalInitializerInfo$offset() {\n+        return CreateExternalInitializerInfo$OFFSET;\n@@ -12697,0 +39588,1 @@\n+     * Getter for field:\n@@ -12698,1 +39590,20 @@\n-     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n+     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateExternalInitializerInfo(MemorySegment struct) {\n+        return struct.get(CreateExternalInitializerInfo$LAYOUT, CreateExternalInitializerInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateExternalInitializerInfo)(const char *, int64_t, size_t, OrtExternalInitializerInfo **)\n+     * }\n+     *\/\n+    public static void CreateExternalInitializerInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateExternalInitializerInfo$LAYOUT, CreateExternalInitializerInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * bool (*TensorTypeAndShape_HasShape)(const OrtTensorTypeAndShapeInfo *)\n@@ -12701,1 +39612,12 @@\n-    private static class SetEpDynamicOptions {\n+    public static class TensorTypeAndShape_HasShape {\n+\n+        TensorTypeAndShape_HasShape() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            boolean apply(MemorySegment _x0);\n+        }\n@@ -12704,5 +39626,2 @@\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_POINTER,\n-            onnxruntime_c_api_h.C_LONG\n+            coreml_provider_factory_h.C_BOOL,\n+            coreml_provider_factory_h.C_POINTER\n@@ -12711,0 +39630,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = coreml_provider_factory_h.upcallHandle(TensorTypeAndShape_HasShape.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(TensorTypeAndShape_HasShape.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -12716,1 +39652,1 @@\n-        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n+        public static boolean invoke(MemorySegment funcPtr,MemorySegment _x0) {\n@@ -12718,1 +39654,1 @@\n-                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+                return (boolean) DOWN$MH.invokeExact(funcPtr, _x0);\n@@ -12725,1 +39661,11 @@\n-    private static final AddressLayout SetEpDynamicOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetEpDynamicOptions\"));\n+    private static final AddressLayout TensorTypeAndShape_HasShape$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"TensorTypeAndShape_HasShape\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * bool (*TensorTypeAndShape_HasShape)(const OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout TensorTypeAndShape_HasShape$layout() {\n+        return TensorTypeAndShape_HasShape$LAYOUT;\n+    }\n@@ -12727,1 +39673,1 @@\n-    private static final long SetEpDynamicOptions$OFFSET = $LAYOUT.byteOffset(groupElement(\"SetEpDynamicOptions\"));\n+    private static final long TensorTypeAndShape_HasShape$OFFSET = 3120;\n@@ -12730,1 +39676,1 @@\n-     * Invoker for field:\n+     * Offset for field:\n@@ -12732,1 +39678,21 @@\n-     * OrtStatusPtr (*SetEpDynamicOptions)(OrtSession *, const char *const *, const char *const *, size_t)\n+     * bool (*TensorTypeAndShape_HasShape)(const OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static final long TensorTypeAndShape_HasShape$offset() {\n+        return TensorTypeAndShape_HasShape$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * bool (*TensorTypeAndShape_HasShape)(const OrtTensorTypeAndShapeInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment TensorTypeAndShape_HasShape(MemorySegment struct) {\n+        return struct.get(TensorTypeAndShape_HasShape$LAYOUT, TensorTypeAndShape_HasShape$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * bool (*TensorTypeAndShape_HasShape)(const OrtTensorTypeAndShapeInfo *)\n@@ -12735,3 +39701,2 @@\n-    public static MemorySegment SetEpDynamicOptions(MemorySegment struct, MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, long _x3) {\n-        var funcPtr = struct.get(SetEpDynamicOptions$LAYOUT, SetEpDynamicOptions$OFFSET);\n-        return SetEpDynamicOptions.invoke(funcPtr, _x0, _x1, _x2, _x3);\n+    public static void TensorTypeAndShape_HasShape(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(TensorTypeAndShape_HasShape$LAYOUT, TensorTypeAndShape_HasShape$OFFSET, fieldValue);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtApi.java","additions":33391,"deletions":6426,"binary":false,"changes":39817,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+import java.util.*;\n@@ -8,0 +9,1 @@\n+import java.util.stream.*;\n@@ -42,1 +44,12 @@\n-    private static class GetApi {\n+    public static class GetApi {\n+\n+        GetApi() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0);\n+        }\n@@ -49,0 +62,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetApi.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetApi.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -65,1 +95,31 @@\n-    private static final long GetApi$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetApi\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const OrtApi *(*GetApi)(uint32_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetApi$layout() {\n+        return GetApi$LAYOUT;\n+    }\n+\n+    private static final long GetApi$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const OrtApi *(*GetApi)(uint32_t)\n+     * }\n+     *\/\n+    public static final long GetApi$offset() {\n+        return GetApi$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const OrtApi *(*GetApi)(uint32_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetApi(MemorySegment struct) {\n+        return struct.get(GetApi$LAYOUT, GetApi$OFFSET);\n+    }\n@@ -68,1 +128,1 @@\n-     * Invoker for field:\n+     * Setter for field:\n@@ -73,3 +133,2 @@\n-    public static MemorySegment GetApi(MemorySegment struct, int _x0) {\n-        var funcPtr = struct.get(GetApi$LAYOUT, GetApi$OFFSET);\n-        return GetApi.invoke(funcPtr, _x0);\n+    public static void GetApi(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetApi$LAYOUT, GetApi$OFFSET, fieldValue);\n@@ -83,1 +142,12 @@\n-    private static class GetVersionString {\n+    public static class GetVersionString {\n+\n+        GetVersionString() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply();\n+        }\n@@ -88,0 +158,17 @@\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVersionString.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetVersionString.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n@@ -104,1 +191,21 @@\n-    private static final long GetVersionString$OFFSET = $LAYOUT.byteOffset(groupElement(\"GetVersionString\"));\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetVersionString)(void)\n+     * }\n+     *\/\n+    public static final AddressLayout GetVersionString$layout() {\n+        return GetVersionString$LAYOUT;\n+    }\n+\n+    private static final long GetVersionString$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetVersionString)(void)\n+     * }\n+     *\/\n+    public static final long GetVersionString$offset() {\n+        return GetVersionString$OFFSET;\n+    }\n@@ -107,1 +214,1 @@\n-     * Invoker for field:\n+     * Getter for field:\n@@ -113,2 +220,11 @@\n-        var funcPtr = struct.get(GetVersionString$LAYOUT, GetVersionString$OFFSET);\n-        return GetVersionString.invoke(funcPtr);\n+        return struct.get(GetVersionString$LAYOUT, GetVersionString$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetVersionString)(void)\n+     * }\n+     *\/\n+    public static void GetVersionString(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetVersionString$LAYOUT, GetVersionString$OFFSET, fieldValue);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtApiBase.java","additions":127,"deletions":11,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,589 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtCUDAProviderOptions {\n+ *     int device_id;\n+ *     OrtCudnnConvAlgoSearch cudnn_conv_algo_search;\n+ *     size_t gpu_mem_limit;\n+ *     int arena_extend_strategy;\n+ *     int do_copy_in_default_stream;\n+ *     int has_user_compute_stream;\n+ *     void *user_compute_stream;\n+ *     OrtArenaCfg *default_memory_arena_cfg;\n+ *     int tunable_op_enable;\n+ *     int tunable_op_tuning_enable;\n+ *     int tunable_op_max_tuning_duration_ms;\n+ * }\n+ * }\n+ *\/\n+public class OrtCUDAProviderOptions {\n+\n+    OrtCUDAProviderOptions() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_INT.withName(\"device_id\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"cudnn_conv_algo_search\"),\n+        onnxruntime_c_api_h.C_LONG.withName(\"gpu_mem_limit\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"arena_extend_strategy\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"do_copy_in_default_stream\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"has_user_compute_stream\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"user_compute_stream\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"default_memory_arena_cfg\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"tunable_op_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"tunable_op_tuning_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"tunable_op_max_tuning_duration_ms\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"OrtCUDAProviderOptions\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt device_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"device_id\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final OfInt device_id$layout() {\n+        return device_id$LAYOUT;\n+    }\n+\n+    private static final long device_id$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final long device_id$offset() {\n+        return device_id$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static int device_id(MemorySegment struct) {\n+        return struct.get(device_id$LAYOUT, device_id$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static void device_id(MemorySegment struct, int fieldValue) {\n+        struct.set(device_id$LAYOUT, device_id$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt cudnn_conv_algo_search$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"cudnn_conv_algo_search\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtCudnnConvAlgoSearch cudnn_conv_algo_search\n+     * }\n+     *\/\n+    public static final OfInt cudnn_conv_algo_search$layout() {\n+        return cudnn_conv_algo_search$LAYOUT;\n+    }\n+\n+    private static final long cudnn_conv_algo_search$OFFSET = 4;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtCudnnConvAlgoSearch cudnn_conv_algo_search\n+     * }\n+     *\/\n+    public static final long cudnn_conv_algo_search$offset() {\n+        return cudnn_conv_algo_search$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtCudnnConvAlgoSearch cudnn_conv_algo_search\n+     * }\n+     *\/\n+    public static int cudnn_conv_algo_search(MemorySegment struct) {\n+        return struct.get(cudnn_conv_algo_search$LAYOUT, cudnn_conv_algo_search$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtCudnnConvAlgoSearch cudnn_conv_algo_search\n+     * }\n+     *\/\n+    public static void cudnn_conv_algo_search(MemorySegment struct, int fieldValue) {\n+        struct.set(cudnn_conv_algo_search$LAYOUT, cudnn_conv_algo_search$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong gpu_mem_limit$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"gpu_mem_limit\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static final OfLong gpu_mem_limit$layout() {\n+        return gpu_mem_limit$LAYOUT;\n+    }\n+\n+    private static final long gpu_mem_limit$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static final long gpu_mem_limit$offset() {\n+        return gpu_mem_limit$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static long gpu_mem_limit(MemorySegment struct) {\n+        return struct.get(gpu_mem_limit$LAYOUT, gpu_mem_limit$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static void gpu_mem_limit(MemorySegment struct, long fieldValue) {\n+        struct.set(gpu_mem_limit$LAYOUT, gpu_mem_limit$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt arena_extend_strategy$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"arena_extend_strategy\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static final OfInt arena_extend_strategy$layout() {\n+        return arena_extend_strategy$LAYOUT;\n+    }\n+\n+    private static final long arena_extend_strategy$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static final long arena_extend_strategy$offset() {\n+        return arena_extend_strategy$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static int arena_extend_strategy(MemorySegment struct) {\n+        return struct.get(arena_extend_strategy$LAYOUT, arena_extend_strategy$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static void arena_extend_strategy(MemorySegment struct, int fieldValue) {\n+        struct.set(arena_extend_strategy$LAYOUT, arena_extend_strategy$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt do_copy_in_default_stream$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"do_copy_in_default_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static final OfInt do_copy_in_default_stream$layout() {\n+        return do_copy_in_default_stream$LAYOUT;\n+    }\n+\n+    private static final long do_copy_in_default_stream$OFFSET = 20;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static final long do_copy_in_default_stream$offset() {\n+        return do_copy_in_default_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static int do_copy_in_default_stream(MemorySegment struct) {\n+        return struct.get(do_copy_in_default_stream$LAYOUT, do_copy_in_default_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static void do_copy_in_default_stream(MemorySegment struct, int fieldValue) {\n+        struct.set(do_copy_in_default_stream$LAYOUT, do_copy_in_default_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt has_user_compute_stream$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"has_user_compute_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static final OfInt has_user_compute_stream$layout() {\n+        return has_user_compute_stream$LAYOUT;\n+    }\n+\n+    private static final long has_user_compute_stream$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static final long has_user_compute_stream$offset() {\n+        return has_user_compute_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static int has_user_compute_stream(MemorySegment struct) {\n+        return struct.get(has_user_compute_stream$LAYOUT, has_user_compute_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static void has_user_compute_stream(MemorySegment struct, int fieldValue) {\n+        struct.set(has_user_compute_stream$LAYOUT, has_user_compute_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout user_compute_stream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"user_compute_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static final AddressLayout user_compute_stream$layout() {\n+        return user_compute_stream$LAYOUT;\n+    }\n+\n+    private static final long user_compute_stream$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static final long user_compute_stream$offset() {\n+        return user_compute_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static MemorySegment user_compute_stream(MemorySegment struct) {\n+        return struct.get(user_compute_stream$LAYOUT, user_compute_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static void user_compute_stream(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(user_compute_stream$LAYOUT, user_compute_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout default_memory_arena_cfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"default_memory_arena_cfg\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static final AddressLayout default_memory_arena_cfg$layout() {\n+        return default_memory_arena_cfg$LAYOUT;\n+    }\n+\n+    private static final long default_memory_arena_cfg$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static final long default_memory_arena_cfg$offset() {\n+        return default_memory_arena_cfg$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static MemorySegment default_memory_arena_cfg(MemorySegment struct) {\n+        return struct.get(default_memory_arena_cfg$LAYOUT, default_memory_arena_cfg$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static void default_memory_arena_cfg(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(default_memory_arena_cfg$LAYOUT, default_memory_arena_cfg$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tunable_op_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tunable_op_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static final OfInt tunable_op_enable$layout() {\n+        return tunable_op_enable$LAYOUT;\n+    }\n+\n+    private static final long tunable_op_enable$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static final long tunable_op_enable$offset() {\n+        return tunable_op_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static int tunable_op_enable(MemorySegment struct) {\n+        return struct.get(tunable_op_enable$LAYOUT, tunable_op_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static void tunable_op_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(tunable_op_enable$LAYOUT, tunable_op_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tunable_op_tuning_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tunable_op_tuning_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static final OfInt tunable_op_tuning_enable$layout() {\n+        return tunable_op_tuning_enable$LAYOUT;\n+    }\n+\n+    private static final long tunable_op_tuning_enable$OFFSET = 52;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static final long tunable_op_tuning_enable$offset() {\n+        return tunable_op_tuning_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static int tunable_op_tuning_enable(MemorySegment struct) {\n+        return struct.get(tunable_op_tuning_enable$LAYOUT, tunable_op_tuning_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static void tunable_op_tuning_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(tunable_op_tuning_enable$LAYOUT, tunable_op_tuning_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tunable_op_max_tuning_duration_ms$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tunable_op_max_tuning_duration_ms\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static final OfInt tunable_op_max_tuning_duration_ms$layout() {\n+        return tunable_op_max_tuning_duration_ms$LAYOUT;\n+    }\n+\n+    private static final long tunable_op_max_tuning_duration_ms$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static final long tunable_op_max_tuning_duration_ms$offset() {\n+        return tunable_op_max_tuning_duration_ms$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static int tunable_op_max_tuning_duration_ms(MemorySegment struct) {\n+        return struct.get(tunable_op_max_tuning_duration_ms$LAYOUT, tunable_op_max_tuning_duration_ms$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static void tunable_op_max_tuning_duration_ms(MemorySegment struct, int fieldValue) {\n+        struct.set(tunable_op_max_tuning_duration_ms$LAYOUT, tunable_op_max_tuning_duration_ms$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtCUDAProviderOptions.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"},{"patch":"@@ -0,0 +1,1501 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtCompileApi {\n+ *     void (*ReleaseModelCompilationOptions)(OrtModelCompilationOptions *);\n+ *     OrtStatusPtr (*CreateModelCompilationOptionsFromSessionOptions)(const OrtEnv *, const OrtSessionOptions *, OrtModelCompilationOptions **);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetInputModelPath)(OrtModelCompilationOptions *, const char *);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetInputModelFromBuffer)(OrtModelCompilationOptions *, const void *, size_t);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetOutputModelPath)(OrtModelCompilationOptions *, const char *);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetOutputModelExternalInitializersFile)(OrtModelCompilationOptions *, const char *, size_t);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetOutputModelBuffer)(OrtModelCompilationOptions *, OrtAllocator *, void **, size_t *);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetEpContextEmbedMode)(OrtModelCompilationOptions *, bool);\n+ *     OrtStatusPtr (*CompileModel)(const OrtEnv *, const OrtModelCompilationOptions *);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetFlags)(OrtModelCompilationOptions *, uint32_t);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetEpContextBinaryInformation)(OrtModelCompilationOptions *, const char *, const char *);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetGraphOptimizationLevel)(OrtModelCompilationOptions *, GraphOptimizationLevel);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetOutputModelWriteFunc)(OrtModelCompilationOptions *, OrtWriteBufferFunc, void *);\n+ *     OrtStatusPtr (*ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc)(OrtModelCompilationOptions *, OrtGetInitializerLocationFunc, void *);\n+ * }\n+ * }\n+ *\/\n+public class OrtCompileApi {\n+\n+    OrtCompileApi() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseModelCompilationOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateModelCompilationOptionsFromSessionOptions\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetInputModelPath\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetInputModelFromBuffer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetOutputModelPath\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetOutputModelExternalInitializersFile\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetOutputModelBuffer\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetEpContextEmbedMode\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CompileModel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetFlags\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetEpContextBinaryInformation\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetGraphOptimizationLevel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetOutputModelWriteFunc\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc\")\n+    ).withName(\"OrtCompileApi\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelCompilationOptions)(OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static class ReleaseModelCompilationOptions {\n+\n+        ReleaseModelCompilationOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseModelCompilationOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseModelCompilationOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseModelCompilationOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseModelCompilationOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelCompilationOptions)(OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseModelCompilationOptions$layout() {\n+        return ReleaseModelCompilationOptions$LAYOUT;\n+    }\n+\n+    private static final long ReleaseModelCompilationOptions$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelCompilationOptions)(OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static final long ReleaseModelCompilationOptions$offset() {\n+        return ReleaseModelCompilationOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelCompilationOptions)(OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseModelCompilationOptions(MemorySegment struct) {\n+        return struct.get(ReleaseModelCompilationOptions$LAYOUT, ReleaseModelCompilationOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseModelCompilationOptions)(OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static void ReleaseModelCompilationOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseModelCompilationOptions$LAYOUT, ReleaseModelCompilationOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelCompilationOptionsFromSessionOptions)(const OrtEnv *, const OrtSessionOptions *, OrtModelCompilationOptions **)\n+     * }\n+     *\/\n+    public static class CreateModelCompilationOptionsFromSessionOptions {\n+\n+        CreateModelCompilationOptionsFromSessionOptions() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModelCompilationOptionsFromSessionOptions.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateModelCompilationOptionsFromSessionOptions.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateModelCompilationOptionsFromSessionOptions$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateModelCompilationOptionsFromSessionOptions\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelCompilationOptionsFromSessionOptions)(const OrtEnv *, const OrtSessionOptions *, OrtModelCompilationOptions **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateModelCompilationOptionsFromSessionOptions$layout() {\n+        return CreateModelCompilationOptionsFromSessionOptions$LAYOUT;\n+    }\n+\n+    private static final long CreateModelCompilationOptionsFromSessionOptions$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelCompilationOptionsFromSessionOptions)(const OrtEnv *, const OrtSessionOptions *, OrtModelCompilationOptions **)\n+     * }\n+     *\/\n+    public static final long CreateModelCompilationOptionsFromSessionOptions$offset() {\n+        return CreateModelCompilationOptionsFromSessionOptions$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelCompilationOptionsFromSessionOptions)(const OrtEnv *, const OrtSessionOptions *, OrtModelCompilationOptions **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateModelCompilationOptionsFromSessionOptions(MemorySegment struct) {\n+        return struct.get(CreateModelCompilationOptionsFromSessionOptions$LAYOUT, CreateModelCompilationOptionsFromSessionOptions$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelCompilationOptionsFromSessionOptions)(const OrtEnv *, const OrtSessionOptions *, OrtModelCompilationOptions **)\n+     * }\n+     *\/\n+    public static void CreateModelCompilationOptionsFromSessionOptions(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateModelCompilationOptionsFromSessionOptions$LAYOUT, CreateModelCompilationOptionsFromSessionOptions$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetInputModelPath {\n+\n+        ModelCompilationOptions_SetInputModelPath() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetInputModelPath.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetInputModelPath.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetInputModelPath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetInputModelPath\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetInputModelPath$layout() {\n+        return ModelCompilationOptions_SetInputModelPath$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetInputModelPath$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetInputModelPath$offset() {\n+        return ModelCompilationOptions_SetInputModelPath$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetInputModelPath(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetInputModelPath$LAYOUT, ModelCompilationOptions_SetInputModelPath$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetInputModelPath(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetInputModelPath$LAYOUT, ModelCompilationOptions_SetInputModelPath$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelFromBuffer)(OrtModelCompilationOptions *, const void *, size_t)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetInputModelFromBuffer {\n+\n+        ModelCompilationOptions_SetInputModelFromBuffer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetInputModelFromBuffer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetInputModelFromBuffer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetInputModelFromBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetInputModelFromBuffer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelFromBuffer)(OrtModelCompilationOptions *, const void *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetInputModelFromBuffer$layout() {\n+        return ModelCompilationOptions_SetInputModelFromBuffer$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetInputModelFromBuffer$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelFromBuffer)(OrtModelCompilationOptions *, const void *, size_t)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetInputModelFromBuffer$offset() {\n+        return ModelCompilationOptions_SetInputModelFromBuffer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelFromBuffer)(OrtModelCompilationOptions *, const void *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetInputModelFromBuffer(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetInputModelFromBuffer$LAYOUT, ModelCompilationOptions_SetInputModelFromBuffer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetInputModelFromBuffer)(OrtModelCompilationOptions *, const void *, size_t)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetInputModelFromBuffer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetInputModelFromBuffer$LAYOUT, ModelCompilationOptions_SetInputModelFromBuffer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetOutputModelPath {\n+\n+        ModelCompilationOptions_SetOutputModelPath() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetOutputModelPath.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetOutputModelPath.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetOutputModelPath$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetOutputModelPath\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetOutputModelPath$layout() {\n+        return ModelCompilationOptions_SetOutputModelPath$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetOutputModelPath$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetOutputModelPath$offset() {\n+        return ModelCompilationOptions_SetOutputModelPath$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetOutputModelPath(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetOutputModelPath$LAYOUT, ModelCompilationOptions_SetOutputModelPath$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelPath)(OrtModelCompilationOptions *, const char *)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetOutputModelPath(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetOutputModelPath$LAYOUT, ModelCompilationOptions_SetOutputModelPath$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelExternalInitializersFile)(OrtModelCompilationOptions *, const char *, size_t)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetOutputModelExternalInitializersFile {\n+\n+        ModelCompilationOptions_SetOutputModelExternalInitializersFile() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetOutputModelExternalInitializersFile.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetOutputModelExternalInitializersFile.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetOutputModelExternalInitializersFile$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetOutputModelExternalInitializersFile\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelExternalInitializersFile)(OrtModelCompilationOptions *, const char *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetOutputModelExternalInitializersFile$layout() {\n+        return ModelCompilationOptions_SetOutputModelExternalInitializersFile$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetOutputModelExternalInitializersFile$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelExternalInitializersFile)(OrtModelCompilationOptions *, const char *, size_t)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetOutputModelExternalInitializersFile$offset() {\n+        return ModelCompilationOptions_SetOutputModelExternalInitializersFile$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelExternalInitializersFile)(OrtModelCompilationOptions *, const char *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetOutputModelExternalInitializersFile(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetOutputModelExternalInitializersFile$LAYOUT, ModelCompilationOptions_SetOutputModelExternalInitializersFile$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelExternalInitializersFile)(OrtModelCompilationOptions *, const char *, size_t)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetOutputModelExternalInitializersFile(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetOutputModelExternalInitializersFile$LAYOUT, ModelCompilationOptions_SetOutputModelExternalInitializersFile$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelBuffer)(OrtModelCompilationOptions *, OrtAllocator *, void **, size_t *)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetOutputModelBuffer {\n+\n+        ModelCompilationOptions_SetOutputModelBuffer() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetOutputModelBuffer.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetOutputModelBuffer.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetOutputModelBuffer$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetOutputModelBuffer\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelBuffer)(OrtModelCompilationOptions *, OrtAllocator *, void **, size_t *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetOutputModelBuffer$layout() {\n+        return ModelCompilationOptions_SetOutputModelBuffer$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetOutputModelBuffer$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelBuffer)(OrtModelCompilationOptions *, OrtAllocator *, void **, size_t *)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetOutputModelBuffer$offset() {\n+        return ModelCompilationOptions_SetOutputModelBuffer$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelBuffer)(OrtModelCompilationOptions *, OrtAllocator *, void **, size_t *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetOutputModelBuffer(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetOutputModelBuffer$LAYOUT, ModelCompilationOptions_SetOutputModelBuffer$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelBuffer)(OrtModelCompilationOptions *, OrtAllocator *, void **, size_t *)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetOutputModelBuffer(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetOutputModelBuffer$LAYOUT, ModelCompilationOptions_SetOutputModelBuffer$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextEmbedMode)(OrtModelCompilationOptions *, bool)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetEpContextEmbedMode {\n+\n+        ModelCompilationOptions_SetEpContextEmbedMode() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, boolean _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_BOOL\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetEpContextEmbedMode.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetEpContextEmbedMode.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, boolean _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetEpContextEmbedMode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetEpContextEmbedMode\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextEmbedMode)(OrtModelCompilationOptions *, bool)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetEpContextEmbedMode$layout() {\n+        return ModelCompilationOptions_SetEpContextEmbedMode$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetEpContextEmbedMode$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextEmbedMode)(OrtModelCompilationOptions *, bool)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetEpContextEmbedMode$offset() {\n+        return ModelCompilationOptions_SetEpContextEmbedMode$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextEmbedMode)(OrtModelCompilationOptions *, bool)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetEpContextEmbedMode(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetEpContextEmbedMode$LAYOUT, ModelCompilationOptions_SetEpContextEmbedMode$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextEmbedMode)(OrtModelCompilationOptions *, bool)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetEpContextEmbedMode(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetEpContextEmbedMode$LAYOUT, ModelCompilationOptions_SetEpContextEmbedMode$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompileModel)(const OrtEnv *, const OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static class CompileModel {\n+\n+        CompileModel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CompileModel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CompileModel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CompileModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CompileModel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompileModel)(const OrtEnv *, const OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static final AddressLayout CompileModel$layout() {\n+        return CompileModel$LAYOUT;\n+    }\n+\n+    private static final long CompileModel$OFFSET = 64;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompileModel)(const OrtEnv *, const OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static final long CompileModel$offset() {\n+        return CompileModel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompileModel)(const OrtEnv *, const OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static MemorySegment CompileModel(MemorySegment struct) {\n+        return struct.get(CompileModel$LAYOUT, CompileModel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CompileModel)(const OrtEnv *, const OrtModelCompilationOptions *)\n+     * }\n+     *\/\n+    public static void CompileModel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CompileModel$LAYOUT, CompileModel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetFlags)(OrtModelCompilationOptions *, uint32_t)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetFlags {\n+\n+        ModelCompilationOptions_SetFlags() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetFlags.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetFlags.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetFlags$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetFlags\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetFlags)(OrtModelCompilationOptions *, uint32_t)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetFlags$layout() {\n+        return ModelCompilationOptions_SetFlags$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetFlags$OFFSET = 72;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetFlags)(OrtModelCompilationOptions *, uint32_t)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetFlags$offset() {\n+        return ModelCompilationOptions_SetFlags$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetFlags)(OrtModelCompilationOptions *, uint32_t)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetFlags(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetFlags$LAYOUT, ModelCompilationOptions_SetFlags$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetFlags)(OrtModelCompilationOptions *, uint32_t)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetFlags(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetFlags$LAYOUT, ModelCompilationOptions_SetFlags$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextBinaryInformation)(OrtModelCompilationOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetEpContextBinaryInformation {\n+\n+        ModelCompilationOptions_SetEpContextBinaryInformation() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetEpContextBinaryInformation.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetEpContextBinaryInformation.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetEpContextBinaryInformation$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetEpContextBinaryInformation\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextBinaryInformation)(OrtModelCompilationOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetEpContextBinaryInformation$layout() {\n+        return ModelCompilationOptions_SetEpContextBinaryInformation$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetEpContextBinaryInformation$OFFSET = 80;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextBinaryInformation)(OrtModelCompilationOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetEpContextBinaryInformation$offset() {\n+        return ModelCompilationOptions_SetEpContextBinaryInformation$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextBinaryInformation)(OrtModelCompilationOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetEpContextBinaryInformation(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetEpContextBinaryInformation$LAYOUT, ModelCompilationOptions_SetEpContextBinaryInformation$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetEpContextBinaryInformation)(OrtModelCompilationOptions *, const char *, const char *)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetEpContextBinaryInformation(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetEpContextBinaryInformation$LAYOUT, ModelCompilationOptions_SetEpContextBinaryInformation$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetGraphOptimizationLevel)(OrtModelCompilationOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetGraphOptimizationLevel {\n+\n+        ModelCompilationOptions_SetGraphOptimizationLevel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, int _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetGraphOptimizationLevel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetGraphOptimizationLevel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, int _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetGraphOptimizationLevel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetGraphOptimizationLevel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetGraphOptimizationLevel)(OrtModelCompilationOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetGraphOptimizationLevel$layout() {\n+        return ModelCompilationOptions_SetGraphOptimizationLevel$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetGraphOptimizationLevel$OFFSET = 88;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetGraphOptimizationLevel)(OrtModelCompilationOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetGraphOptimizationLevel$offset() {\n+        return ModelCompilationOptions_SetGraphOptimizationLevel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetGraphOptimizationLevel)(OrtModelCompilationOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetGraphOptimizationLevel(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetGraphOptimizationLevel$LAYOUT, ModelCompilationOptions_SetGraphOptimizationLevel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetGraphOptimizationLevel)(OrtModelCompilationOptions *, GraphOptimizationLevel)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetGraphOptimizationLevel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetGraphOptimizationLevel$LAYOUT, ModelCompilationOptions_SetGraphOptimizationLevel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelWriteFunc)(OrtModelCompilationOptions *, OrtWriteBufferFunc, void *)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetOutputModelWriteFunc {\n+\n+        ModelCompilationOptions_SetOutputModelWriteFunc() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetOutputModelWriteFunc.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetOutputModelWriteFunc.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetOutputModelWriteFunc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetOutputModelWriteFunc\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelWriteFunc)(OrtModelCompilationOptions *, OrtWriteBufferFunc, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetOutputModelWriteFunc$layout() {\n+        return ModelCompilationOptions_SetOutputModelWriteFunc$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetOutputModelWriteFunc$OFFSET = 96;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelWriteFunc)(OrtModelCompilationOptions *, OrtWriteBufferFunc, void *)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetOutputModelWriteFunc$offset() {\n+        return ModelCompilationOptions_SetOutputModelWriteFunc$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelWriteFunc)(OrtModelCompilationOptions *, OrtWriteBufferFunc, void *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetOutputModelWriteFunc(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetOutputModelWriteFunc$LAYOUT, ModelCompilationOptions_SetOutputModelWriteFunc$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelWriteFunc)(OrtModelCompilationOptions *, OrtWriteBufferFunc, void *)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetOutputModelWriteFunc(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetOutputModelWriteFunc$LAYOUT, ModelCompilationOptions_SetOutputModelWriteFunc$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc)(OrtModelCompilationOptions *, OrtGetInitializerLocationFunc, void *)\n+     * }\n+     *\/\n+    public static class ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc {\n+\n+        ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc)(OrtModelCompilationOptions *, OrtGetInitializerLocationFunc, void *)\n+     * }\n+     *\/\n+    public static final AddressLayout ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$layout() {\n+        return ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$LAYOUT;\n+    }\n+\n+    private static final long ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$OFFSET = 104;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc)(OrtModelCompilationOptions *, OrtGetInitializerLocationFunc, void *)\n+     * }\n+     *\/\n+    public static final long ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$offset() {\n+        return ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc)(OrtModelCompilationOptions *, OrtGetInitializerLocationFunc, void *)\n+     * }\n+     *\/\n+    public static MemorySegment ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc(MemorySegment struct) {\n+        return struct.get(ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$LAYOUT, ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc)(OrtModelCompilationOptions *, OrtGetInitializerLocationFunc, void *)\n+     * }\n+     *\/\n+    public static void ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$LAYOUT, ModelCompilationOptions_SetOutputModelGetInitializerLocationFunc$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtCompileApi.java","additions":1501,"deletions":0,"binary":false,"changes":1501,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef OrtCustomThreadHandle (*OrtCustomCreateThreadFn)(void *, OrtThreadWorkerFn, void *)\n+ * }\n+ *\/\n+public class OrtCustomCreateThreadFn {\n+\n+    OrtCustomCreateThreadFn() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        MemorySegment apply(MemorySegment ort_custom_thread_creation_options, MemorySegment ort_thread_worker_fn, MemorySegment ort_worker_fn_param);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OrtCustomCreateThreadFn.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(OrtCustomCreateThreadFn.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment ort_custom_thread_creation_options, MemorySegment ort_thread_worker_fn, MemorySegment ort_worker_fn_param) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, ort_custom_thread_creation_options, ort_thread_worker_fn, ort_worker_fn_param);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtCustomCreateThreadFn.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtCustomHandleType {\n+ *     char __place_holder;\n+ * }\n+ * }\n+ *\/\n+public class OrtCustomHandleType {\n+\n+    OrtCustomHandleType() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_CHAR.withName(\"__place_holder\")\n+    ).withName(\"OrtCustomHandleType\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfByte __place_holder$LAYOUT = (OfByte)$LAYOUT.select(groupElement(\"__place_holder\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * char __place_holder\n+     * }\n+     *\/\n+    public static final OfByte __place_holder$layout() {\n+        return __place_holder$LAYOUT;\n+    }\n+\n+    private static final long __place_holder$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * char __place_holder\n+     * }\n+     *\/\n+    public static final long __place_holder$offset() {\n+        return __place_holder$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * char __place_holder\n+     * }\n+     *\/\n+    public static byte __place_holder(MemorySegment struct) {\n+        return struct.get(__place_holder$LAYOUT, __place_holder$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * char __place_holder\n+     * }\n+     *\/\n+    public static void __place_holder(MemorySegment struct, byte fieldValue) {\n+        struct.set(__place_holder$LAYOUT, __place_holder$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtCustomHandleType.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef void (*OrtCustomJoinThreadFn)(OrtCustomThreadHandle)\n+ * }\n+ *\/\n+public class OrtCustomJoinThreadFn {\n+\n+    OrtCustomJoinThreadFn() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        void apply(MemorySegment ort_custom_thread_handle);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OrtCustomJoinThreadFn.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(OrtCustomJoinThreadFn.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static void invoke(MemorySegment funcPtr,MemorySegment ort_custom_thread_handle) {\n+        try {\n+             DOWN$MH.invokeExact(funcPtr, ort_custom_thread_handle);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtCustomJoinThreadFn.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,2640 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtCustomOp {\n+ *     uint32_t version;\n+ *     void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *);\n+ *     const char *(*GetName)(const struct OrtCustomOp *);\n+ *     const char *(*GetExecutionProviderType)(const struct OrtCustomOp *);\n+ *     ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t);\n+ *     size_t (*GetInputTypeCount)(const struct OrtCustomOp *);\n+ *     ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t);\n+ *     size_t (*GetOutputTypeCount)(const struct OrtCustomOp *);\n+ *     void (*KernelCompute)(void *, OrtKernelContext *);\n+ *     void (*KernelDestroy)(void *);\n+ *     OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t);\n+ *     OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t);\n+ *     OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t);\n+ *     int (*GetVariadicInputMinArity)(const struct OrtCustomOp *);\n+ *     int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *);\n+ *     int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *);\n+ *     int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *);\n+ *     OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **);\n+ *     OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *);\n+ *     OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *);\n+ *     int (*GetStartVersion)(const struct OrtCustomOp *);\n+ *     int (*GetEndVersion)(const struct OrtCustomOp *);\n+ *     size_t (*GetMayInplace)(int **, int **);\n+ *     void (*ReleaseMayInplace)(int *, int *);\n+ *     size_t (*GetAliasMap)(int **, int **);\n+ *     void (*ReleaseAliasMap)(int *, int *);\n+ * }\n+ * }\n+ *\/\n+public class OrtCustomOp {\n+\n+    OrtCustomOp() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_INT.withName(\"version\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateKernel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetName\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetExecutionProviderType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetInputType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetInputTypeCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetOutputType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetOutputTypeCount\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelCompute\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelDestroy\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetInputCharacteristic\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetOutputCharacteristic\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetInputMemoryType\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetVariadicInputMinArity\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetVariadicInputHomogeneity\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetVariadicOutputMinArity\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetVariadicOutputHomogeneity\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateKernelV2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"KernelComputeV2\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"InferOutputShapeFn\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetStartVersion\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetEndVersion\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetMayInplace\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseMayInplace\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"GetAliasMap\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ReleaseAliasMap\")\n+    ).withName(\"OrtCustomOp\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt version$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"version\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static final OfInt version$layout() {\n+        return version$LAYOUT;\n+    }\n+\n+    private static final long version$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static final long version$offset() {\n+        return version$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static int version(MemorySegment struct) {\n+        return struct.get(version$LAYOUT, version$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * uint32_t version\n+     * }\n+     *\/\n+    public static void version(MemorySegment struct, int fieldValue) {\n+        struct.set(version$LAYOUT, version$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static class CreateKernel {\n+\n+        CreateKernel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateKernel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateKernel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateKernel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateKernel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateKernel$layout() {\n+        return CreateKernel$LAYOUT;\n+    }\n+\n+    private static final long CreateKernel$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static final long CreateKernel$offset() {\n+        return CreateKernel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static MemorySegment CreateKernel(MemorySegment struct) {\n+        return struct.get(CreateKernel$LAYOUT, CreateKernel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *(*CreateKernel)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *)\n+     * }\n+     *\/\n+    public static void CreateKernel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateKernel$LAYOUT, CreateKernel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetName)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetName {\n+\n+        GetName() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetName.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetName.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetName$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetName\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetName)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetName$layout() {\n+        return GetName$LAYOUT;\n+    }\n+\n+    private static final long GetName$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetName)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetName$offset() {\n+        return GetName$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetName)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetName(MemorySegment struct) {\n+        return struct.get(GetName$LAYOUT, GetName$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetName)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetName(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetName$LAYOUT, GetName$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetExecutionProviderType {\n+\n+        GetExecutionProviderType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetExecutionProviderType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetExecutionProviderType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetExecutionProviderType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetExecutionProviderType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetExecutionProviderType$layout() {\n+        return GetExecutionProviderType$LAYOUT;\n+    }\n+\n+    private static final long GetExecutionProviderType$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetExecutionProviderType$offset() {\n+        return GetExecutionProviderType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetExecutionProviderType(MemorySegment struct) {\n+        return struct.get(GetExecutionProviderType$LAYOUT, GetExecutionProviderType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *(*GetExecutionProviderType)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetExecutionProviderType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetExecutionProviderType$LAYOUT, GetExecutionProviderType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static class GetInputType {\n+\n+        GetInputType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetInputType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetInputType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetInputType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetInputType$layout() {\n+        return GetInputType$LAYOUT;\n+    }\n+\n+    private static final long GetInputType$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final long GetInputType$offset() {\n+        return GetInputType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetInputType(MemorySegment struct) {\n+        return struct.get(GetInputType$LAYOUT, GetInputType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetInputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static void GetInputType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetInputType$LAYOUT, GetInputType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetInputTypeCount {\n+\n+        GetInputTypeCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            long apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputTypeCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetInputTypeCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (long) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetInputTypeCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetInputTypeCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetInputTypeCount$layout() {\n+        return GetInputTypeCount$LAYOUT;\n+    }\n+\n+    private static final long GetInputTypeCount$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetInputTypeCount$offset() {\n+        return GetInputTypeCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetInputTypeCount(MemorySegment struct) {\n+        return struct.get(GetInputTypeCount$LAYOUT, GetInputTypeCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetInputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetInputTypeCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetInputTypeCount$LAYOUT, GetInputTypeCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static class GetOutputType {\n+\n+        GetOutputType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOutputType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetOutputType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOutputType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOutputType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetOutputType$layout() {\n+        return GetOutputType$LAYOUT;\n+    }\n+\n+    private static final long GetOutputType$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final long GetOutputType$offset() {\n+        return GetOutputType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetOutputType(MemorySegment struct) {\n+        return struct.get(GetOutputType$LAYOUT, GetOutputType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * ONNXTensorElementDataType (*GetOutputType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static void GetOutputType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetOutputType$LAYOUT, GetOutputType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetOutputTypeCount {\n+\n+        GetOutputTypeCount() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            long apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOutputTypeCount.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetOutputTypeCount.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static long invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (long) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOutputTypeCount$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOutputTypeCount\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetOutputTypeCount$layout() {\n+        return GetOutputTypeCount$LAYOUT;\n+    }\n+\n+    private static final long GetOutputTypeCount$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetOutputTypeCount$offset() {\n+        return GetOutputTypeCount$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetOutputTypeCount(MemorySegment struct) {\n+        return struct.get(GetOutputTypeCount$LAYOUT, GetOutputTypeCount$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetOutputTypeCount)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetOutputTypeCount(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetOutputTypeCount$LAYOUT, GetOutputTypeCount$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*KernelCompute)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static class KernelCompute {\n+\n+        KernelCompute() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelCompute.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelCompute.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelCompute$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelCompute\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*KernelCompute)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelCompute$layout() {\n+        return KernelCompute$LAYOUT;\n+    }\n+\n+    private static final long KernelCompute$OFFSET = 64;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*KernelCompute)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static final long KernelCompute$offset() {\n+        return KernelCompute$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*KernelCompute)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelCompute(MemorySegment struct) {\n+        return struct.get(KernelCompute$LAYOUT, KernelCompute$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*KernelCompute)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static void KernelCompute(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelCompute$LAYOUT, KernelCompute$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*KernelDestroy)(void *)\n+     * }\n+     *\/\n+    public static class KernelDestroy {\n+\n+        KernelDestroy() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelDestroy.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelDestroy.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelDestroy$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelDestroy\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*KernelDestroy)(void *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelDestroy$layout() {\n+        return KernelDestroy$LAYOUT;\n+    }\n+\n+    private static final long KernelDestroy$OFFSET = 72;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*KernelDestroy)(void *)\n+     * }\n+     *\/\n+    public static final long KernelDestroy$offset() {\n+        return KernelDestroy$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*KernelDestroy)(void *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelDestroy(MemorySegment struct) {\n+        return struct.get(KernelDestroy$LAYOUT, KernelDestroy$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*KernelDestroy)(void *)\n+     * }\n+     *\/\n+    public static void KernelDestroy(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelDestroy$LAYOUT, KernelDestroy$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static class GetInputCharacteristic {\n+\n+        GetInputCharacteristic() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputCharacteristic.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetInputCharacteristic.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetInputCharacteristic$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetInputCharacteristic\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetInputCharacteristic$layout() {\n+        return GetInputCharacteristic$LAYOUT;\n+    }\n+\n+    private static final long GetInputCharacteristic$OFFSET = 80;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final long GetInputCharacteristic$offset() {\n+        return GetInputCharacteristic$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetInputCharacteristic(MemorySegment struct) {\n+        return struct.get(GetInputCharacteristic$LAYOUT, GetInputCharacteristic$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetInputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static void GetInputCharacteristic(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetInputCharacteristic$LAYOUT, GetInputCharacteristic$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static class GetOutputCharacteristic {\n+\n+        GetOutputCharacteristic() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetOutputCharacteristic.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetOutputCharacteristic.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetOutputCharacteristic$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetOutputCharacteristic\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetOutputCharacteristic$layout() {\n+        return GetOutputCharacteristic$LAYOUT;\n+    }\n+\n+    private static final long GetOutputCharacteristic$OFFSET = 88;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final long GetOutputCharacteristic$offset() {\n+        return GetOutputCharacteristic$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetOutputCharacteristic(MemorySegment struct) {\n+        return struct.get(GetOutputCharacteristic$LAYOUT, GetOutputCharacteristic$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtCustomOpInputOutputCharacteristic (*GetOutputCharacteristic)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static void GetOutputCharacteristic(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetOutputCharacteristic$LAYOUT, GetOutputCharacteristic$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static class GetInputMemoryType {\n+\n+        GetInputMemoryType() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0, long _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetInputMemoryType.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetInputMemoryType.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0, long _x1) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetInputMemoryType$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetInputMemoryType\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout GetInputMemoryType$layout() {\n+        return GetInputMemoryType$LAYOUT;\n+    }\n+\n+    private static final long GetInputMemoryType$OFFSET = 96;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static final long GetInputMemoryType$offset() {\n+        return GetInputMemoryType$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment GetInputMemoryType(MemorySegment struct) {\n+        return struct.get(GetInputMemoryType$LAYOUT, GetInputMemoryType$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtMemType (*GetInputMemoryType)(const struct OrtCustomOp *, size_t)\n+     * }\n+     *\/\n+    public static void GetInputMemoryType(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetInputMemoryType$LAYOUT, GetInputMemoryType$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetVariadicInputMinArity {\n+\n+        GetVariadicInputMinArity() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicInputMinArity.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetVariadicInputMinArity.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetVariadicInputMinArity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetVariadicInputMinArity\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetVariadicInputMinArity$layout() {\n+        return GetVariadicInputMinArity$LAYOUT;\n+    }\n+\n+    private static final long GetVariadicInputMinArity$OFFSET = 104;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetVariadicInputMinArity$offset() {\n+        return GetVariadicInputMinArity$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetVariadicInputMinArity(MemorySegment struct) {\n+        return struct.get(GetVariadicInputMinArity$LAYOUT, GetVariadicInputMinArity$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetVariadicInputMinArity(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetVariadicInputMinArity$LAYOUT, GetVariadicInputMinArity$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetVariadicInputHomogeneity {\n+\n+        GetVariadicInputHomogeneity() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicInputHomogeneity.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetVariadicInputHomogeneity.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetVariadicInputHomogeneity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetVariadicInputHomogeneity\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetVariadicInputHomogeneity$layout() {\n+        return GetVariadicInputHomogeneity$LAYOUT;\n+    }\n+\n+    private static final long GetVariadicInputHomogeneity$OFFSET = 112;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetVariadicInputHomogeneity$offset() {\n+        return GetVariadicInputHomogeneity$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetVariadicInputHomogeneity(MemorySegment struct) {\n+        return struct.get(GetVariadicInputHomogeneity$LAYOUT, GetVariadicInputHomogeneity$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicInputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetVariadicInputHomogeneity(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetVariadicInputHomogeneity$LAYOUT, GetVariadicInputHomogeneity$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetVariadicOutputMinArity {\n+\n+        GetVariadicOutputMinArity() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicOutputMinArity.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetVariadicOutputMinArity.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetVariadicOutputMinArity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetVariadicOutputMinArity\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetVariadicOutputMinArity$layout() {\n+        return GetVariadicOutputMinArity$LAYOUT;\n+    }\n+\n+    private static final long GetVariadicOutputMinArity$OFFSET = 120;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetVariadicOutputMinArity$offset() {\n+        return GetVariadicOutputMinArity$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetVariadicOutputMinArity(MemorySegment struct) {\n+        return struct.get(GetVariadicOutputMinArity$LAYOUT, GetVariadicOutputMinArity$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputMinArity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetVariadicOutputMinArity(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetVariadicOutputMinArity$LAYOUT, GetVariadicOutputMinArity$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetVariadicOutputHomogeneity {\n+\n+        GetVariadicOutputHomogeneity() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetVariadicOutputHomogeneity.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetVariadicOutputHomogeneity.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetVariadicOutputHomogeneity$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetVariadicOutputHomogeneity\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetVariadicOutputHomogeneity$layout() {\n+        return GetVariadicOutputHomogeneity$LAYOUT;\n+    }\n+\n+    private static final long GetVariadicOutputHomogeneity$OFFSET = 128;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetVariadicOutputHomogeneity$offset() {\n+        return GetVariadicOutputHomogeneity$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetVariadicOutputHomogeneity(MemorySegment struct) {\n+        return struct.get(GetVariadicOutputHomogeneity$LAYOUT, GetVariadicOutputHomogeneity$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int (*GetVariadicOutputHomogeneity)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetVariadicOutputHomogeneity(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetVariadicOutputHomogeneity$LAYOUT, GetVariadicOutputHomogeneity$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)\n+     * }\n+     *\/\n+    public static class CreateKernelV2 {\n+\n+        CreateKernelV2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateKernelV2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateKernelV2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateKernelV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateKernelV2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateKernelV2$layout() {\n+        return CreateKernelV2$LAYOUT;\n+    }\n+\n+    private static final long CreateKernelV2$OFFSET = 136;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)\n+     * }\n+     *\/\n+    public static final long CreateKernelV2$offset() {\n+        return CreateKernelV2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateKernelV2(MemorySegment struct) {\n+        return struct.get(CreateKernelV2$LAYOUT, CreateKernelV2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateKernelV2)(const struct OrtCustomOp *, const OrtApi *, const OrtKernelInfo *, void **)\n+     * }\n+     *\/\n+    public static void CreateKernelV2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateKernelV2$LAYOUT, CreateKernelV2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static class KernelComputeV2 {\n+\n+        KernelComputeV2() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(KernelComputeV2.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(KernelComputeV2.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout KernelComputeV2$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"KernelComputeV2\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static final AddressLayout KernelComputeV2$layout() {\n+        return KernelComputeV2$LAYOUT;\n+    }\n+\n+    private static final long KernelComputeV2$OFFSET = 144;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static final long KernelComputeV2$offset() {\n+        return KernelComputeV2$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static MemorySegment KernelComputeV2(MemorySegment struct) {\n+        return struct.get(KernelComputeV2$LAYOUT, KernelComputeV2$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*KernelComputeV2)(void *, OrtKernelContext *)\n+     * }\n+     *\/\n+    public static void KernelComputeV2(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(KernelComputeV2$LAYOUT, KernelComputeV2$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)\n+     * }\n+     *\/\n+    public static class InferOutputShapeFn {\n+\n+        InferOutputShapeFn() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(InferOutputShapeFn.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(InferOutputShapeFn.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout InferOutputShapeFn$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"InferOutputShapeFn\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)\n+     * }\n+     *\/\n+    public static final AddressLayout InferOutputShapeFn$layout() {\n+        return InferOutputShapeFn$LAYOUT;\n+    }\n+\n+    private static final long InferOutputShapeFn$OFFSET = 152;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)\n+     * }\n+     *\/\n+    public static final long InferOutputShapeFn$offset() {\n+        return InferOutputShapeFn$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)\n+     * }\n+     *\/\n+    public static MemorySegment InferOutputShapeFn(MemorySegment struct) {\n+        return struct.get(InferOutputShapeFn$LAYOUT, InferOutputShapeFn$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*InferOutputShapeFn)(const struct OrtCustomOp *, OrtShapeInferContext *)\n+     * }\n+     *\/\n+    public static void InferOutputShapeFn(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(InferOutputShapeFn$LAYOUT, InferOutputShapeFn$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int (*GetStartVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetStartVersion {\n+\n+        GetStartVersion() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetStartVersion.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetStartVersion.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetStartVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetStartVersion\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int (*GetStartVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetStartVersion$layout() {\n+        return GetStartVersion$LAYOUT;\n+    }\n+\n+    private static final long GetStartVersion$OFFSET = 160;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int (*GetStartVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetStartVersion$offset() {\n+        return GetStartVersion$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int (*GetStartVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetStartVersion(MemorySegment struct) {\n+        return struct.get(GetStartVersion$LAYOUT, GetStartVersion$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int (*GetStartVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetStartVersion(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetStartVersion$LAYOUT, GetStartVersion$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * int (*GetEndVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static class GetEndVersion {\n+\n+        GetEndVersion() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            int apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetEndVersion.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetEndVersion.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static int invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (int) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetEndVersion$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetEndVersion\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int (*GetEndVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final AddressLayout GetEndVersion$layout() {\n+        return GetEndVersion$LAYOUT;\n+    }\n+\n+    private static final long GetEndVersion$OFFSET = 168;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int (*GetEndVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static final long GetEndVersion$offset() {\n+        return GetEndVersion$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int (*GetEndVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static MemorySegment GetEndVersion(MemorySegment struct) {\n+        return struct.get(GetEndVersion$LAYOUT, GetEndVersion$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int (*GetEndVersion)(const struct OrtCustomOp *)\n+     * }\n+     *\/\n+    public static void GetEndVersion(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetEndVersion$LAYOUT, GetEndVersion$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t (*GetMayInplace)(int **, int **)\n+     * }\n+     *\/\n+    public static class GetMayInplace {\n+\n+        GetMayInplace() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            long apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetMayInplace.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetMayInplace.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetMayInplace$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetMayInplace\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetMayInplace)(int **, int **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetMayInplace$layout() {\n+        return GetMayInplace$LAYOUT;\n+    }\n+\n+    private static final long GetMayInplace$OFFSET = 176;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetMayInplace)(int **, int **)\n+     * }\n+     *\/\n+    public static final long GetMayInplace$offset() {\n+        return GetMayInplace$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetMayInplace)(int **, int **)\n+     * }\n+     *\/\n+    public static MemorySegment GetMayInplace(MemorySegment struct) {\n+        return struct.get(GetMayInplace$LAYOUT, GetMayInplace$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetMayInplace)(int **, int **)\n+     * }\n+     *\/\n+    public static void GetMayInplace(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetMayInplace$LAYOUT, GetMayInplace$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseMayInplace)(int *, int *)\n+     * }\n+     *\/\n+    public static class ReleaseMayInplace {\n+\n+        ReleaseMayInplace() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseMayInplace.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseMayInplace.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseMayInplace$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseMayInplace\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMayInplace)(int *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseMayInplace$layout() {\n+        return ReleaseMayInplace$LAYOUT;\n+    }\n+\n+    private static final long ReleaseMayInplace$OFFSET = 184;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMayInplace)(int *, int *)\n+     * }\n+     *\/\n+    public static final long ReleaseMayInplace$offset() {\n+        return ReleaseMayInplace$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMayInplace)(int *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseMayInplace(MemorySegment struct) {\n+        return struct.get(ReleaseMayInplace$LAYOUT, ReleaseMayInplace$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseMayInplace)(int *, int *)\n+     * }\n+     *\/\n+    public static void ReleaseMayInplace(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseMayInplace$LAYOUT, ReleaseMayInplace$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * size_t (*GetAliasMap)(int **, int **)\n+     * }\n+     *\/\n+    public static class GetAliasMap {\n+\n+        GetAliasMap() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            long apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(GetAliasMap.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(GetAliasMap.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static long invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (long) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout GetAliasMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"GetAliasMap\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetAliasMap)(int **, int **)\n+     * }\n+     *\/\n+    public static final AddressLayout GetAliasMap$layout() {\n+        return GetAliasMap$LAYOUT;\n+    }\n+\n+    private static final long GetAliasMap$OFFSET = 192;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetAliasMap)(int **, int **)\n+     * }\n+     *\/\n+    public static final long GetAliasMap$offset() {\n+        return GetAliasMap$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetAliasMap)(int **, int **)\n+     * }\n+     *\/\n+    public static MemorySegment GetAliasMap(MemorySegment struct) {\n+        return struct.get(GetAliasMap$LAYOUT, GetAliasMap$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t (*GetAliasMap)(int **, int **)\n+     * }\n+     *\/\n+    public static void GetAliasMap(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(GetAliasMap$LAYOUT, GetAliasMap$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * void (*ReleaseAliasMap)(int *, int *)\n+     * }\n+     *\/\n+    public static class ReleaseAliasMap {\n+\n+        ReleaseAliasMap() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            void apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ReleaseAliasMap.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ReleaseAliasMap.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static void invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                 DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ReleaseAliasMap$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ReleaseAliasMap\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAliasMap)(int *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout ReleaseAliasMap$layout() {\n+        return ReleaseAliasMap$LAYOUT;\n+    }\n+\n+    private static final long ReleaseAliasMap$OFFSET = 200;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAliasMap)(int *, int *)\n+     * }\n+     *\/\n+    public static final long ReleaseAliasMap$offset() {\n+        return ReleaseAliasMap$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAliasMap)(int *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment ReleaseAliasMap(MemorySegment struct) {\n+        return struct.get(ReleaseAliasMap$LAYOUT, ReleaseAliasMap$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void (*ReleaseAliasMap)(int *, int *)\n+     * }\n+     *\/\n+    public static void ReleaseAliasMap(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ReleaseAliasMap$LAYOUT, ReleaseAliasMap$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtCustomOp.java","additions":2640,"deletions":0,"binary":false,"changes":2640,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef OrtStatus *(*OrtGetInitializerLocationFunc)(void *, const char *, const OrtValue *, const OrtExternalInitializerInfo *, OrtExternalInitializerInfo **)\n+ * }\n+ *\/\n+public class OrtGetInitializerLocationFunc {\n+\n+    OrtGetInitializerLocationFunc() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        MemorySegment apply(MemorySegment state, MemorySegment initializer_name, MemorySegment initializer_value, MemorySegment external_info, MemorySegment new_external_info);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OrtGetInitializerLocationFunc.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(OrtGetInitializerLocationFunc.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment state, MemorySegment initializer_name, MemorySegment initializer_value, MemorySegment external_info, MemorySegment new_external_info) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, state, initializer_name, initializer_value, external_info, new_external_info);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtGetInitializerLocationFunc.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef void (*OrtLoggingFunction)(void *, OrtLoggingLevel, const char *, const char *, const char *, const char *)\n+ * }\n+ *\/\n+public class OrtLoggingFunction {\n+\n+    OrtLoggingFunction() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        void apply(MemorySegment param, int severity, MemorySegment category, MemorySegment logid, MemorySegment code_location, MemorySegment message);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_INT,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OrtLoggingFunction.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(OrtLoggingFunction.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static void invoke(MemorySegment funcPtr,MemorySegment param, int severity, MemorySegment category, MemorySegment logid, MemorySegment code_location, MemorySegment message) {\n+        try {\n+             DOWN$MH.invokeExact(funcPtr, param, severity, category, logid, code_location, message);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtLoggingFunction.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,684 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtMIGraphXProviderOptions {\n+ *     int device_id;\n+ *     int migraphx_fp16_enable;\n+ *     int migraphx_fp8_enable;\n+ *     int migraphx_int8_enable;\n+ *     int migraphx_use_native_calibration_table;\n+ *     const char *migraphx_int8_calibration_table_name;\n+ *     int migraphx_save_compiled_model;\n+ *     const char *migraphx_save_model_path;\n+ *     int migraphx_load_compiled_model;\n+ *     const char *migraphx_load_model_path;\n+ *     bool migraphx_exhaustive_tune;\n+ *     size_t migraphx_mem_limit;\n+ *     int migraphx_arena_extend_strategy;\n+ * }\n+ * }\n+ *\/\n+public class OrtMIGraphXProviderOptions {\n+\n+    OrtMIGraphXProviderOptions() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_INT.withName(\"device_id\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_fp16_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_fp8_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_int8_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_use_native_calibration_table\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"migraphx_int8_calibration_table_name\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_save_compiled_model\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"migraphx_save_model_path\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_load_compiled_model\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"migraphx_load_model_path\"),\n+        onnxruntime_c_api_h.C_BOOL.withName(\"migraphx_exhaustive_tune\"),\n+        MemoryLayout.paddingLayout(7),\n+        onnxruntime_c_api_h.C_LONG.withName(\"migraphx_mem_limit\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"migraphx_arena_extend_strategy\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"OrtMIGraphXProviderOptions\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt device_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"device_id\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final OfInt device_id$layout() {\n+        return device_id$LAYOUT;\n+    }\n+\n+    private static final long device_id$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final long device_id$offset() {\n+        return device_id$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static int device_id(MemorySegment struct) {\n+        return struct.get(device_id$LAYOUT, device_id$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static void device_id(MemorySegment struct, int fieldValue) {\n+        struct.set(device_id$LAYOUT, device_id$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_fp16_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_fp16_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp16_enable\n+     * }\n+     *\/\n+    public static final OfInt migraphx_fp16_enable$layout() {\n+        return migraphx_fp16_enable$LAYOUT;\n+    }\n+\n+    private static final long migraphx_fp16_enable$OFFSET = 4;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp16_enable\n+     * }\n+     *\/\n+    public static final long migraphx_fp16_enable$offset() {\n+        return migraphx_fp16_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp16_enable\n+     * }\n+     *\/\n+    public static int migraphx_fp16_enable(MemorySegment struct) {\n+        return struct.get(migraphx_fp16_enable$LAYOUT, migraphx_fp16_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp16_enable\n+     * }\n+     *\/\n+    public static void migraphx_fp16_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_fp16_enable$LAYOUT, migraphx_fp16_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_fp8_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_fp8_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp8_enable\n+     * }\n+     *\/\n+    public static final OfInt migraphx_fp8_enable$layout() {\n+        return migraphx_fp8_enable$LAYOUT;\n+    }\n+\n+    private static final long migraphx_fp8_enable$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp8_enable\n+     * }\n+     *\/\n+    public static final long migraphx_fp8_enable$offset() {\n+        return migraphx_fp8_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp8_enable\n+     * }\n+     *\/\n+    public static int migraphx_fp8_enable(MemorySegment struct) {\n+        return struct.get(migraphx_fp8_enable$LAYOUT, migraphx_fp8_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_fp8_enable\n+     * }\n+     *\/\n+    public static void migraphx_fp8_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_fp8_enable$LAYOUT, migraphx_fp8_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_int8_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_int8_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_int8_enable\n+     * }\n+     *\/\n+    public static final OfInt migraphx_int8_enable$layout() {\n+        return migraphx_int8_enable$LAYOUT;\n+    }\n+\n+    private static final long migraphx_int8_enable$OFFSET = 12;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_int8_enable\n+     * }\n+     *\/\n+    public static final long migraphx_int8_enable$offset() {\n+        return migraphx_int8_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_int8_enable\n+     * }\n+     *\/\n+    public static int migraphx_int8_enable(MemorySegment struct) {\n+        return struct.get(migraphx_int8_enable$LAYOUT, migraphx_int8_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_int8_enable\n+     * }\n+     *\/\n+    public static void migraphx_int8_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_int8_enable$LAYOUT, migraphx_int8_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_use_native_calibration_table$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_use_native_calibration_table\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_use_native_calibration_table\n+     * }\n+     *\/\n+    public static final OfInt migraphx_use_native_calibration_table$layout() {\n+        return migraphx_use_native_calibration_table$LAYOUT;\n+    }\n+\n+    private static final long migraphx_use_native_calibration_table$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_use_native_calibration_table\n+     * }\n+     *\/\n+    public static final long migraphx_use_native_calibration_table$offset() {\n+        return migraphx_use_native_calibration_table$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_use_native_calibration_table\n+     * }\n+     *\/\n+    public static int migraphx_use_native_calibration_table(MemorySegment struct) {\n+        return struct.get(migraphx_use_native_calibration_table$LAYOUT, migraphx_use_native_calibration_table$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_use_native_calibration_table\n+     * }\n+     *\/\n+    public static void migraphx_use_native_calibration_table(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_use_native_calibration_table$LAYOUT, migraphx_use_native_calibration_table$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout migraphx_int8_calibration_table_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"migraphx_int8_calibration_table_name\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static final AddressLayout migraphx_int8_calibration_table_name$layout() {\n+        return migraphx_int8_calibration_table_name$LAYOUT;\n+    }\n+\n+    private static final long migraphx_int8_calibration_table_name$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static final long migraphx_int8_calibration_table_name$offset() {\n+        return migraphx_int8_calibration_table_name$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static MemorySegment migraphx_int8_calibration_table_name(MemorySegment struct) {\n+        return struct.get(migraphx_int8_calibration_table_name$LAYOUT, migraphx_int8_calibration_table_name$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static void migraphx_int8_calibration_table_name(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(migraphx_int8_calibration_table_name$LAYOUT, migraphx_int8_calibration_table_name$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_save_compiled_model$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_save_compiled_model\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_save_compiled_model\n+     * }\n+     *\/\n+    public static final OfInt migraphx_save_compiled_model$layout() {\n+        return migraphx_save_compiled_model$LAYOUT;\n+    }\n+\n+    private static final long migraphx_save_compiled_model$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_save_compiled_model\n+     * }\n+     *\/\n+    public static final long migraphx_save_compiled_model$offset() {\n+        return migraphx_save_compiled_model$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_save_compiled_model\n+     * }\n+     *\/\n+    public static int migraphx_save_compiled_model(MemorySegment struct) {\n+        return struct.get(migraphx_save_compiled_model$LAYOUT, migraphx_save_compiled_model$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_save_compiled_model\n+     * }\n+     *\/\n+    public static void migraphx_save_compiled_model(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_save_compiled_model$LAYOUT, migraphx_save_compiled_model$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout migraphx_save_model_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"migraphx_save_model_path\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_save_model_path\n+     * }\n+     *\/\n+    public static final AddressLayout migraphx_save_model_path$layout() {\n+        return migraphx_save_model_path$LAYOUT;\n+    }\n+\n+    private static final long migraphx_save_model_path$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_save_model_path\n+     * }\n+     *\/\n+    public static final long migraphx_save_model_path$offset() {\n+        return migraphx_save_model_path$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_save_model_path\n+     * }\n+     *\/\n+    public static MemorySegment migraphx_save_model_path(MemorySegment struct) {\n+        return struct.get(migraphx_save_model_path$LAYOUT, migraphx_save_model_path$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_save_model_path\n+     * }\n+     *\/\n+    public static void migraphx_save_model_path(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(migraphx_save_model_path$LAYOUT, migraphx_save_model_path$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_load_compiled_model$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_load_compiled_model\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_load_compiled_model\n+     * }\n+     *\/\n+    public static final OfInt migraphx_load_compiled_model$layout() {\n+        return migraphx_load_compiled_model$LAYOUT;\n+    }\n+\n+    private static final long migraphx_load_compiled_model$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_load_compiled_model\n+     * }\n+     *\/\n+    public static final long migraphx_load_compiled_model$offset() {\n+        return migraphx_load_compiled_model$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_load_compiled_model\n+     * }\n+     *\/\n+    public static int migraphx_load_compiled_model(MemorySegment struct) {\n+        return struct.get(migraphx_load_compiled_model$LAYOUT, migraphx_load_compiled_model$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_load_compiled_model\n+     * }\n+     *\/\n+    public static void migraphx_load_compiled_model(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_load_compiled_model$LAYOUT, migraphx_load_compiled_model$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout migraphx_load_model_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"migraphx_load_model_path\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_load_model_path\n+     * }\n+     *\/\n+    public static final AddressLayout migraphx_load_model_path$layout() {\n+        return migraphx_load_model_path$LAYOUT;\n+    }\n+\n+    private static final long migraphx_load_model_path$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_load_model_path\n+     * }\n+     *\/\n+    public static final long migraphx_load_model_path$offset() {\n+        return migraphx_load_model_path$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_load_model_path\n+     * }\n+     *\/\n+    public static MemorySegment migraphx_load_model_path(MemorySegment struct) {\n+        return struct.get(migraphx_load_model_path$LAYOUT, migraphx_load_model_path$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *migraphx_load_model_path\n+     * }\n+     *\/\n+    public static void migraphx_load_model_path(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(migraphx_load_model_path$LAYOUT, migraphx_load_model_path$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfBoolean migraphx_exhaustive_tune$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement(\"migraphx_exhaustive_tune\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * bool migraphx_exhaustive_tune\n+     * }\n+     *\/\n+    public static final OfBoolean migraphx_exhaustive_tune$layout() {\n+        return migraphx_exhaustive_tune$LAYOUT;\n+    }\n+\n+    private static final long migraphx_exhaustive_tune$OFFSET = 64;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * bool migraphx_exhaustive_tune\n+     * }\n+     *\/\n+    public static final long migraphx_exhaustive_tune$offset() {\n+        return migraphx_exhaustive_tune$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * bool migraphx_exhaustive_tune\n+     * }\n+     *\/\n+    public static boolean migraphx_exhaustive_tune(MemorySegment struct) {\n+        return struct.get(migraphx_exhaustive_tune$LAYOUT, migraphx_exhaustive_tune$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * bool migraphx_exhaustive_tune\n+     * }\n+     *\/\n+    public static void migraphx_exhaustive_tune(MemorySegment struct, boolean fieldValue) {\n+        struct.set(migraphx_exhaustive_tune$LAYOUT, migraphx_exhaustive_tune$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong migraphx_mem_limit$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"migraphx_mem_limit\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t migraphx_mem_limit\n+     * }\n+     *\/\n+    public static final OfLong migraphx_mem_limit$layout() {\n+        return migraphx_mem_limit$LAYOUT;\n+    }\n+\n+    private static final long migraphx_mem_limit$OFFSET = 72;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t migraphx_mem_limit\n+     * }\n+     *\/\n+    public static final long migraphx_mem_limit$offset() {\n+        return migraphx_mem_limit$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t migraphx_mem_limit\n+     * }\n+     *\/\n+    public static long migraphx_mem_limit(MemorySegment struct) {\n+        return struct.get(migraphx_mem_limit$LAYOUT, migraphx_mem_limit$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t migraphx_mem_limit\n+     * }\n+     *\/\n+    public static void migraphx_mem_limit(MemorySegment struct, long fieldValue) {\n+        struct.set(migraphx_mem_limit$LAYOUT, migraphx_mem_limit$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt migraphx_arena_extend_strategy$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"migraphx_arena_extend_strategy\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int migraphx_arena_extend_strategy\n+     * }\n+     *\/\n+    public static final OfInt migraphx_arena_extend_strategy$layout() {\n+        return migraphx_arena_extend_strategy$LAYOUT;\n+    }\n+\n+    private static final long migraphx_arena_extend_strategy$OFFSET = 80;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int migraphx_arena_extend_strategy\n+     * }\n+     *\/\n+    public static final long migraphx_arena_extend_strategy$offset() {\n+        return migraphx_arena_extend_strategy$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_arena_extend_strategy\n+     * }\n+     *\/\n+    public static int migraphx_arena_extend_strategy(MemorySegment struct) {\n+        return struct.get(migraphx_arena_extend_strategy$LAYOUT, migraphx_arena_extend_strategy$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int migraphx_arena_extend_strategy\n+     * }\n+     *\/\n+    public static void migraphx_arena_extend_strategy(MemorySegment struct, int fieldValue) {\n+        struct.set(migraphx_arena_extend_strategy$LAYOUT, migraphx_arena_extend_strategy$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtMIGraphXProviderOptions.java","additions":684,"deletions":0,"binary":false,"changes":684,"status":"added"},{"patch":"@@ -0,0 +1,2125 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtModelEditorApi {\n+ *     OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **);\n+ *     OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **);\n+ *     OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **);\n+ *     OrtStatusPtr (*CreateGraph)(OrtGraph **);\n+ *     OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t);\n+ *     OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool);\n+ *     OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *);\n+ *     OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **);\n+ *     OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *);\n+ *     OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **);\n+ *     OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **);\n+ *     OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **);\n+ *     OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *);\n+ *     OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *);\n+ *     OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *);\n+ * }\n+ * }\n+ *\/\n+public class OrtModelEditorApi {\n+\n+    OrtModelEditorApi() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateTensorTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSparseTensorTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateMapTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSequenceTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateOptionalTypeInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateValueInfo\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateNode\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateGraph\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGraphInputs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SetGraphOutputs\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddInitializerToGraph\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddNodeToGraph\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateModel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"AddGraphToModel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateSessionFromModel\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateModelEditorSession\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"CreateModelEditorSessionFromArray\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"SessionGetOpsetForDomain\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"ApplyModelToModelEditorSession\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"FinalizeModelEditorSession\")\n+    ).withName(\"OrtModelEditorApi\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class CreateTensorTypeInfo {\n+\n+        CreateTensorTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateTensorTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateTensorTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateTensorTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateTensorTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateTensorTypeInfo$layout() {\n+        return CreateTensorTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateTensorTypeInfo$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CreateTensorTypeInfo$offset() {\n+        return CreateTensorTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateTensorTypeInfo(MemorySegment struct) {\n+        return struct.get(CreateTensorTypeInfo$LAYOUT, CreateTensorTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void CreateTensorTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateTensorTypeInfo$LAYOUT, CreateTensorTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class CreateSparseTensorTypeInfo {\n+\n+        CreateSparseTensorTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSparseTensorTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSparseTensorTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSparseTensorTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSparseTensorTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSparseTensorTypeInfo$layout() {\n+        return CreateSparseTensorTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateSparseTensorTypeInfo$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CreateSparseTensorTypeInfo$offset() {\n+        return CreateSparseTensorTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSparseTensorTypeInfo(MemorySegment struct) {\n+        return struct.get(CreateSparseTensorTypeInfo$LAYOUT, CreateSparseTensorTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSparseTensorTypeInfo)(const OrtTensorTypeAndShapeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void CreateSparseTensorTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSparseTensorTypeInfo$LAYOUT, CreateSparseTensorTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class CreateMapTypeInfo {\n+\n+        CreateMapTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(int _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_INT,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateMapTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateMapTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,int _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateMapTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateMapTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateMapTypeInfo$layout() {\n+        return CreateMapTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateMapTypeInfo$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CreateMapTypeInfo$offset() {\n+        return CreateMapTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateMapTypeInfo(MemorySegment struct) {\n+        return struct.get(CreateMapTypeInfo$LAYOUT, CreateMapTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateMapTypeInfo)(ONNXTensorElementDataType, const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void CreateMapTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateMapTypeInfo$LAYOUT, CreateMapTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class CreateSequenceTypeInfo {\n+\n+        CreateSequenceTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSequenceTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSequenceTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSequenceTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSequenceTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSequenceTypeInfo$layout() {\n+        return CreateSequenceTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateSequenceTypeInfo$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CreateSequenceTypeInfo$offset() {\n+        return CreateSequenceTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSequenceTypeInfo(MemorySegment struct) {\n+        return struct.get(CreateSequenceTypeInfo$LAYOUT, CreateSequenceTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSequenceTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void CreateSequenceTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSequenceTypeInfo$LAYOUT, CreateSequenceTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static class CreateOptionalTypeInfo {\n+\n+        CreateOptionalTypeInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateOptionalTypeInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateOptionalTypeInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateOptionalTypeInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateOptionalTypeInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateOptionalTypeInfo$layout() {\n+        return CreateOptionalTypeInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateOptionalTypeInfo$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static final long CreateOptionalTypeInfo$offset() {\n+        return CreateOptionalTypeInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateOptionalTypeInfo(MemorySegment struct) {\n+        return struct.get(CreateOptionalTypeInfo$LAYOUT, CreateOptionalTypeInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateOptionalTypeInfo)(const OrtTypeInfo *, OrtTypeInfo **)\n+     * }\n+     *\/\n+    public static void CreateOptionalTypeInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateOptionalTypeInfo$LAYOUT, CreateOptionalTypeInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)\n+     * }\n+     *\/\n+    public static class CreateValueInfo {\n+\n+        CreateValueInfo() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateValueInfo.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateValueInfo.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateValueInfo$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateValueInfo\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateValueInfo$layout() {\n+        return CreateValueInfo$LAYOUT;\n+    }\n+\n+    private static final long CreateValueInfo$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)\n+     * }\n+     *\/\n+    public static final long CreateValueInfo$offset() {\n+        return CreateValueInfo$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateValueInfo(MemorySegment struct) {\n+        return struct.get(CreateValueInfo$LAYOUT, CreateValueInfo$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateValueInfo)(const char *, const OrtTypeInfo *, OrtValueInfo **)\n+     * }\n+     *\/\n+    public static void CreateValueInfo(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateValueInfo$LAYOUT, CreateValueInfo$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)\n+     * }\n+     *\/\n+    public static class CreateNode {\n+\n+        CreateNode() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8, MemorySegment _x9);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateNode.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateNode.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3, long _x4, MemorySegment _x5, long _x6, MemorySegment _x7, long _x8, MemorySegment _x9) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateNode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateNode\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateNode$layout() {\n+        return CreateNode$LAYOUT;\n+    }\n+\n+    private static final long CreateNode$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)\n+     * }\n+     *\/\n+    public static final long CreateNode$offset() {\n+        return CreateNode$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateNode(MemorySegment struct) {\n+        return struct.get(CreateNode$LAYOUT, CreateNode$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateNode)(const char *, const char *, const char *, const char *const *, size_t, const char *const *, size_t, OrtOpAttr **, size_t, OrtNode **)\n+     * }\n+     *\/\n+    public static void CreateNode(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateNode$LAYOUT, CreateNode$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateGraph)(OrtGraph **)\n+     * }\n+     *\/\n+    public static class CreateGraph {\n+\n+        CreateGraph() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateGraph.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateGraph.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateGraph\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateGraph)(OrtGraph **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateGraph$layout() {\n+        return CreateGraph$LAYOUT;\n+    }\n+\n+    private static final long CreateGraph$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateGraph)(OrtGraph **)\n+     * }\n+     *\/\n+    public static final long CreateGraph$offset() {\n+        return CreateGraph$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateGraph)(OrtGraph **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateGraph(MemorySegment struct) {\n+        return struct.get(CreateGraph$LAYOUT, CreateGraph$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateGraph)(OrtGraph **)\n+     * }\n+     *\/\n+    public static void CreateGraph(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateGraph$LAYOUT, CreateGraph$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static class SetGraphInputs {\n+\n+        SetGraphInputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGraphInputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGraphInputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGraphInputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGraphInputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGraphInputs$layout() {\n+        return SetGraphInputs$LAYOUT;\n+    }\n+\n+    private static final long SetGraphInputs$OFFSET = 64;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static final long SetGraphInputs$offset() {\n+        return SetGraphInputs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetGraphInputs(MemorySegment struct) {\n+        return struct.get(SetGraphInputs$LAYOUT, SetGraphInputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphInputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static void SetGraphInputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGraphInputs$LAYOUT, SetGraphInputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static class SetGraphOutputs {\n+\n+        SetGraphOutputs() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SetGraphOutputs.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SetGraphOutputs.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SetGraphOutputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SetGraphOutputs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static final AddressLayout SetGraphOutputs$layout() {\n+        return SetGraphOutputs$LAYOUT;\n+    }\n+\n+    private static final long SetGraphOutputs$OFFSET = 72;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static final long SetGraphOutputs$offset() {\n+        return SetGraphOutputs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static MemorySegment SetGraphOutputs(MemorySegment struct) {\n+        return struct.get(SetGraphOutputs$LAYOUT, SetGraphOutputs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SetGraphOutputs)(OrtGraph *, OrtValueInfo **, size_t)\n+     * }\n+     *\/\n+    public static void SetGraphOutputs(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SetGraphOutputs$LAYOUT, SetGraphOutputs$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)\n+     * }\n+     *\/\n+    public static class AddInitializerToGraph {\n+\n+        AddInitializerToGraph() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, boolean _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_BOOL\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddInitializerToGraph.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddInitializerToGraph.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, boolean _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddInitializerToGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddInitializerToGraph\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)\n+     * }\n+     *\/\n+    public static final AddressLayout AddInitializerToGraph$layout() {\n+        return AddInitializerToGraph$LAYOUT;\n+    }\n+\n+    private static final long AddInitializerToGraph$OFFSET = 80;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)\n+     * }\n+     *\/\n+    public static final long AddInitializerToGraph$offset() {\n+        return AddInitializerToGraph$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)\n+     * }\n+     *\/\n+    public static MemorySegment AddInitializerToGraph(MemorySegment struct) {\n+        return struct.get(AddInitializerToGraph$LAYOUT, AddInitializerToGraph$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddInitializerToGraph)(OrtGraph *, const char *, OrtValue *, bool)\n+     * }\n+     *\/\n+    public static void AddInitializerToGraph(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddInitializerToGraph$LAYOUT, AddInitializerToGraph$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)\n+     * }\n+     *\/\n+    public static class AddNodeToGraph {\n+\n+        AddNodeToGraph() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddNodeToGraph.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddNodeToGraph.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddNodeToGraph$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddNodeToGraph\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)\n+     * }\n+     *\/\n+    public static final AddressLayout AddNodeToGraph$layout() {\n+        return AddNodeToGraph$LAYOUT;\n+    }\n+\n+    private static final long AddNodeToGraph$OFFSET = 88;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)\n+     * }\n+     *\/\n+    public static final long AddNodeToGraph$offset() {\n+        return AddNodeToGraph$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)\n+     * }\n+     *\/\n+    public static MemorySegment AddNodeToGraph(MemorySegment struct) {\n+        return struct.get(AddNodeToGraph$LAYOUT, AddNodeToGraph$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddNodeToGraph)(OrtGraph *, OrtNode *)\n+     * }\n+     *\/\n+    public static void AddNodeToGraph(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddNodeToGraph$LAYOUT, AddNodeToGraph$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)\n+     * }\n+     *\/\n+    public static class CreateModel {\n+\n+        CreateModel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateModel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateModel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateModel$layout() {\n+        return CreateModel$LAYOUT;\n+    }\n+\n+    private static final long CreateModel$OFFSET = 96;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)\n+     * }\n+     *\/\n+    public static final long CreateModel$offset() {\n+        return CreateModel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateModel(MemorySegment struct) {\n+        return struct.get(CreateModel$LAYOUT, CreateModel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModel)(const char *const *, const int *, size_t, OrtModel **)\n+     * }\n+     *\/\n+    public static void CreateModel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateModel$LAYOUT, CreateModel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)\n+     * }\n+     *\/\n+    public static class AddGraphToModel {\n+\n+        AddGraphToModel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(AddGraphToModel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(AddGraphToModel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout AddGraphToModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"AddGraphToModel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)\n+     * }\n+     *\/\n+    public static final AddressLayout AddGraphToModel$layout() {\n+        return AddGraphToModel$LAYOUT;\n+    }\n+\n+    private static final long AddGraphToModel$OFFSET = 104;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)\n+     * }\n+     *\/\n+    public static final long AddGraphToModel$offset() {\n+        return AddGraphToModel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)\n+     * }\n+     *\/\n+    public static MemorySegment AddGraphToModel(MemorySegment struct) {\n+        return struct.get(AddGraphToModel$LAYOUT, AddGraphToModel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*AddGraphToModel)(OrtModel *, OrtGraph *)\n+     * }\n+     *\/\n+    public static void AddGraphToModel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(AddGraphToModel$LAYOUT, AddGraphToModel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static class CreateSessionFromModel {\n+\n+        CreateSessionFromModel() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateSessionFromModel.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateSessionFromModel.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateSessionFromModel$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateSessionFromModel\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateSessionFromModel$layout() {\n+        return CreateSessionFromModel$LAYOUT;\n+    }\n+\n+    private static final long CreateSessionFromModel$OFFSET = 112;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static final long CreateSessionFromModel$offset() {\n+        return CreateSessionFromModel$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateSessionFromModel(MemorySegment struct) {\n+        return struct.get(CreateSessionFromModel$LAYOUT, CreateSessionFromModel$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateSessionFromModel)(const OrtEnv *, const OrtModel *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static void CreateSessionFromModel(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateSessionFromModel$LAYOUT, CreateSessionFromModel$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static class CreateModelEditorSession {\n+\n+        CreateModelEditorSession() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModelEditorSession.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateModelEditorSession.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2, MemorySegment _x3) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateModelEditorSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateModelEditorSession\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateModelEditorSession$layout() {\n+        return CreateModelEditorSession$LAYOUT;\n+    }\n+\n+    private static final long CreateModelEditorSession$OFFSET = 120;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static final long CreateModelEditorSession$offset() {\n+        return CreateModelEditorSession$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateModelEditorSession(MemorySegment struct) {\n+        return struct.get(CreateModelEditorSession$LAYOUT, CreateModelEditorSession$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSession)(const OrtEnv *, const char *, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static void CreateModelEditorSession(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateModelEditorSession$LAYOUT, CreateModelEditorSession$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static class CreateModelEditorSessionFromArray {\n+\n+        CreateModelEditorSessionFromArray() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_LONG,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(CreateModelEditorSessionFromArray.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(CreateModelEditorSessionFromArray.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, long _x2, MemorySegment _x3, MemorySegment _x4) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2, _x3, _x4);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout CreateModelEditorSessionFromArray$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"CreateModelEditorSessionFromArray\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static final AddressLayout CreateModelEditorSessionFromArray$layout() {\n+        return CreateModelEditorSessionFromArray$LAYOUT;\n+    }\n+\n+    private static final long CreateModelEditorSessionFromArray$OFFSET = 128;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static final long CreateModelEditorSessionFromArray$offset() {\n+        return CreateModelEditorSessionFromArray$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static MemorySegment CreateModelEditorSessionFromArray(MemorySegment struct) {\n+        return struct.get(CreateModelEditorSessionFromArray$LAYOUT, CreateModelEditorSessionFromArray$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*CreateModelEditorSessionFromArray)(const OrtEnv *, const void *, size_t, const OrtSessionOptions *, OrtSession **)\n+     * }\n+     *\/\n+    public static void CreateModelEditorSessionFromArray(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(CreateModelEditorSessionFromArray$LAYOUT, CreateModelEditorSessionFromArray$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)\n+     * }\n+     *\/\n+    public static class SessionGetOpsetForDomain {\n+\n+        SessionGetOpsetForDomain() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(SessionGetOpsetForDomain.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(SessionGetOpsetForDomain.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout SessionGetOpsetForDomain$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"SessionGetOpsetForDomain\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)\n+     * }\n+     *\/\n+    public static final AddressLayout SessionGetOpsetForDomain$layout() {\n+        return SessionGetOpsetForDomain$LAYOUT;\n+    }\n+\n+    private static final long SessionGetOpsetForDomain$OFFSET = 136;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)\n+     * }\n+     *\/\n+    public static final long SessionGetOpsetForDomain$offset() {\n+        return SessionGetOpsetForDomain$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)\n+     * }\n+     *\/\n+    public static MemorySegment SessionGetOpsetForDomain(MemorySegment struct) {\n+        return struct.get(SessionGetOpsetForDomain$LAYOUT, SessionGetOpsetForDomain$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*SessionGetOpsetForDomain)(const OrtSession *, const char *, int *)\n+     * }\n+     *\/\n+    public static void SessionGetOpsetForDomain(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(SessionGetOpsetForDomain$LAYOUT, SessionGetOpsetForDomain$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)\n+     * }\n+     *\/\n+    public static class ApplyModelToModelEditorSession {\n+\n+        ApplyModelToModelEditorSession() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(ApplyModelToModelEditorSession.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(ApplyModelToModelEditorSession.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout ApplyModelToModelEditorSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"ApplyModelToModelEditorSession\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)\n+     * }\n+     *\/\n+    public static final AddressLayout ApplyModelToModelEditorSession$layout() {\n+        return ApplyModelToModelEditorSession$LAYOUT;\n+    }\n+\n+    private static final long ApplyModelToModelEditorSession$OFFSET = 144;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)\n+     * }\n+     *\/\n+    public static final long ApplyModelToModelEditorSession$offset() {\n+        return ApplyModelToModelEditorSession$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)\n+     * }\n+     *\/\n+    public static MemorySegment ApplyModelToModelEditorSession(MemorySegment struct) {\n+        return struct.get(ApplyModelToModelEditorSession$LAYOUT, ApplyModelToModelEditorSession$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*ApplyModelToModelEditorSession)(OrtSession *, OrtModel *)\n+     * }\n+     *\/\n+    public static void ApplyModelToModelEditorSession(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(ApplyModelToModelEditorSession$LAYOUT, ApplyModelToModelEditorSession$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static class FinalizeModelEditorSession {\n+\n+        FinalizeModelEditorSession() {\n+            \/\/ Should not be called directly\n+        }\n+\n+        \/**\n+         * The function pointer signature, expressed as a functional interface\n+         *\/\n+        public interface Function {\n+            MemorySegment apply(MemorySegment _x0, MemorySegment _x1, MemorySegment _x2);\n+        }\n+\n+        private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER,\n+            onnxruntime_c_api_h.C_POINTER\n+        );\n+\n+        \/**\n+         * The descriptor of this function pointer\n+         *\/\n+        public static FunctionDescriptor descriptor() {\n+            return $DESC;\n+        }\n+\n+        private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(FinalizeModelEditorSession.Function.class, \"apply\", $DESC);\n+\n+        \/**\n+         * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+         * The lifetime of the returned segment is managed by {@code arena}\n+         *\/\n+        public static MemorySegment allocate(FinalizeModelEditorSession.Function fi, Arena arena) {\n+            return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+        }\n+\n+        private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+        \/**\n+         * Invoke the upcall stub {@code funcPtr}, with given parameters\n+         *\/\n+        public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment _x0, MemorySegment _x1, MemorySegment _x2) {\n+            try {\n+                return (MemorySegment) DOWN$MH.invokeExact(funcPtr, _x0, _x1, _x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        }\n+    }\n+\n+    private static final AddressLayout FinalizeModelEditorSession$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"FinalizeModelEditorSession\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static final AddressLayout FinalizeModelEditorSession$layout() {\n+        return FinalizeModelEditorSession$LAYOUT;\n+    }\n+\n+    private static final long FinalizeModelEditorSession$OFFSET = 152;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static final long FinalizeModelEditorSession$offset() {\n+        return FinalizeModelEditorSession$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static MemorySegment FinalizeModelEditorSession(MemorySegment struct) {\n+        return struct.get(FinalizeModelEditorSession$LAYOUT, FinalizeModelEditorSession$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtStatusPtr (*FinalizeModelEditorSession)(OrtSession *, const OrtSessionOptions *, OrtPrepackedWeightsContainer *)\n+     * }\n+     *\/\n+    public static void FinalizeModelEditorSession(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(FinalizeModelEditorSession$LAYOUT, FinalizeModelEditorSession$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtModelEditorApi.java","additions":2125,"deletions":0,"binary":false,"changes":2125,"status":"added"},{"patch":"@@ -0,0 +1,451 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtOpenVINOProviderOptions {\n+ *     const char *device_type;\n+ *     unsigned char enable_npu_fast_compile;\n+ *     const char *device_id;\n+ *     size_t num_of_threads;\n+ *     const char *cache_dir;\n+ *     void *context;\n+ *     unsigned char enable_opencl_throttling;\n+ *     unsigned char enable_dynamic_shapes;\n+ * }\n+ * }\n+ *\/\n+public class OrtOpenVINOProviderOptions {\n+\n+    OrtOpenVINOProviderOptions() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_POINTER.withName(\"device_type\"),\n+        onnxruntime_c_api_h.C_CHAR.withName(\"enable_npu_fast_compile\"),\n+        MemoryLayout.paddingLayout(7),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"device_id\"),\n+        onnxruntime_c_api_h.C_LONG.withName(\"num_of_threads\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"cache_dir\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"context\"),\n+        onnxruntime_c_api_h.C_CHAR.withName(\"enable_opencl_throttling\"),\n+        onnxruntime_c_api_h.C_CHAR.withName(\"enable_dynamic_shapes\"),\n+        MemoryLayout.paddingLayout(6)\n+    ).withName(\"OrtOpenVINOProviderOptions\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final AddressLayout device_type$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"device_type\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *device_type\n+     * }\n+     *\/\n+    public static final AddressLayout device_type$layout() {\n+        return device_type$LAYOUT;\n+    }\n+\n+    private static final long device_type$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *device_type\n+     * }\n+     *\/\n+    public static final long device_type$offset() {\n+        return device_type$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *device_type\n+     * }\n+     *\/\n+    public static MemorySegment device_type(MemorySegment struct) {\n+        return struct.get(device_type$LAYOUT, device_type$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *device_type\n+     * }\n+     *\/\n+    public static void device_type(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(device_type$LAYOUT, device_type$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfByte enable_npu_fast_compile$LAYOUT = (OfByte)$LAYOUT.select(groupElement(\"enable_npu_fast_compile\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_npu_fast_compile\n+     * }\n+     *\/\n+    public static final OfByte enable_npu_fast_compile$layout() {\n+        return enable_npu_fast_compile$LAYOUT;\n+    }\n+\n+    private static final long enable_npu_fast_compile$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_npu_fast_compile\n+     * }\n+     *\/\n+    public static final long enable_npu_fast_compile$offset() {\n+        return enable_npu_fast_compile$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_npu_fast_compile\n+     * }\n+     *\/\n+    public static byte enable_npu_fast_compile(MemorySegment struct) {\n+        return struct.get(enable_npu_fast_compile$LAYOUT, enable_npu_fast_compile$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_npu_fast_compile\n+     * }\n+     *\/\n+    public static void enable_npu_fast_compile(MemorySegment struct, byte fieldValue) {\n+        struct.set(enable_npu_fast_compile$LAYOUT, enable_npu_fast_compile$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout device_id$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"device_id\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *device_id\n+     * }\n+     *\/\n+    public static final AddressLayout device_id$layout() {\n+        return device_id$LAYOUT;\n+    }\n+\n+    private static final long device_id$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *device_id\n+     * }\n+     *\/\n+    public static final long device_id$offset() {\n+        return device_id$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *device_id\n+     * }\n+     *\/\n+    public static MemorySegment device_id(MemorySegment struct) {\n+        return struct.get(device_id$LAYOUT, device_id$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *device_id\n+     * }\n+     *\/\n+    public static void device_id(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(device_id$LAYOUT, device_id$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong num_of_threads$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"num_of_threads\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t num_of_threads\n+     * }\n+     *\/\n+    public static final OfLong num_of_threads$layout() {\n+        return num_of_threads$LAYOUT;\n+    }\n+\n+    private static final long num_of_threads$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t num_of_threads\n+     * }\n+     *\/\n+    public static final long num_of_threads$offset() {\n+        return num_of_threads$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t num_of_threads\n+     * }\n+     *\/\n+    public static long num_of_threads(MemorySegment struct) {\n+        return struct.get(num_of_threads$LAYOUT, num_of_threads$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t num_of_threads\n+     * }\n+     *\/\n+    public static void num_of_threads(MemorySegment struct, long fieldValue) {\n+        struct.set(num_of_threads$LAYOUT, num_of_threads$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout cache_dir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"cache_dir\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *cache_dir\n+     * }\n+     *\/\n+    public static final AddressLayout cache_dir$layout() {\n+        return cache_dir$LAYOUT;\n+    }\n+\n+    private static final long cache_dir$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *cache_dir\n+     * }\n+     *\/\n+    public static final long cache_dir$offset() {\n+        return cache_dir$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *cache_dir\n+     * }\n+     *\/\n+    public static MemorySegment cache_dir(MemorySegment struct) {\n+        return struct.get(cache_dir$LAYOUT, cache_dir$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *cache_dir\n+     * }\n+     *\/\n+    public static void cache_dir(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(cache_dir$LAYOUT, cache_dir$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout context$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"context\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *context\n+     * }\n+     *\/\n+    public static final AddressLayout context$layout() {\n+        return context$LAYOUT;\n+    }\n+\n+    private static final long context$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *context\n+     * }\n+     *\/\n+    public static final long context$offset() {\n+        return context$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *context\n+     * }\n+     *\/\n+    public static MemorySegment context(MemorySegment struct) {\n+        return struct.get(context$LAYOUT, context$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *context\n+     * }\n+     *\/\n+    public static void context(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(context$LAYOUT, context$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfByte enable_opencl_throttling$LAYOUT = (OfByte)$LAYOUT.select(groupElement(\"enable_opencl_throttling\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_opencl_throttling\n+     * }\n+     *\/\n+    public static final OfByte enable_opencl_throttling$layout() {\n+        return enable_opencl_throttling$LAYOUT;\n+    }\n+\n+    private static final long enable_opencl_throttling$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_opencl_throttling\n+     * }\n+     *\/\n+    public static final long enable_opencl_throttling$offset() {\n+        return enable_opencl_throttling$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_opencl_throttling\n+     * }\n+     *\/\n+    public static byte enable_opencl_throttling(MemorySegment struct) {\n+        return struct.get(enable_opencl_throttling$LAYOUT, enable_opencl_throttling$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_opencl_throttling\n+     * }\n+     *\/\n+    public static void enable_opencl_throttling(MemorySegment struct, byte fieldValue) {\n+        struct.set(enable_opencl_throttling$LAYOUT, enable_opencl_throttling$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfByte enable_dynamic_shapes$LAYOUT = (OfByte)$LAYOUT.select(groupElement(\"enable_dynamic_shapes\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_dynamic_shapes\n+     * }\n+     *\/\n+    public static final OfByte enable_dynamic_shapes$layout() {\n+        return enable_dynamic_shapes$LAYOUT;\n+    }\n+\n+    private static final long enable_dynamic_shapes$OFFSET = 49;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_dynamic_shapes\n+     * }\n+     *\/\n+    public static final long enable_dynamic_shapes$offset() {\n+        return enable_dynamic_shapes$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_dynamic_shapes\n+     * }\n+     *\/\n+    public static byte enable_dynamic_shapes(MemorySegment struct) {\n+        return struct.get(enable_dynamic_shapes$LAYOUT, enable_dynamic_shapes$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * unsigned char enable_dynamic_shapes\n+     * }\n+     *\/\n+    public static void enable_dynamic_shapes(MemorySegment struct, byte fieldValue) {\n+        struct.set(enable_dynamic_shapes$LAYOUT, enable_dynamic_shapes$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtOpenVINOProviderOptions.java","additions":451,"deletions":0,"binary":false,"changes":451,"status":"added"},{"patch":"@@ -0,0 +1,634 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtROCMProviderOptions {\n+ *     int device_id;\n+ *     int miopen_conv_exhaustive_search;\n+ *     size_t gpu_mem_limit;\n+ *     int arena_extend_strategy;\n+ *     int do_copy_in_default_stream;\n+ *     int has_user_compute_stream;\n+ *     void *user_compute_stream;\n+ *     OrtArenaCfg *default_memory_arena_cfg;\n+ *     int enable_hip_graph;\n+ *     int tunable_op_enable;\n+ *     int tunable_op_tuning_enable;\n+ *     int tunable_op_max_tuning_duration_ms;\n+ * }\n+ * }\n+ *\/\n+public class OrtROCMProviderOptions {\n+\n+    OrtROCMProviderOptions() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_INT.withName(\"device_id\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"miopen_conv_exhaustive_search\"),\n+        onnxruntime_c_api_h.C_LONG.withName(\"gpu_mem_limit\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"arena_extend_strategy\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"do_copy_in_default_stream\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"has_user_compute_stream\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"user_compute_stream\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"default_memory_arena_cfg\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"enable_hip_graph\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"tunable_op_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"tunable_op_tuning_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"tunable_op_max_tuning_duration_ms\")\n+    ).withName(\"OrtROCMProviderOptions\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt device_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"device_id\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final OfInt device_id$layout() {\n+        return device_id$LAYOUT;\n+    }\n+\n+    private static final long device_id$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final long device_id$offset() {\n+        return device_id$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static int device_id(MemorySegment struct) {\n+        return struct.get(device_id$LAYOUT, device_id$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static void device_id(MemorySegment struct, int fieldValue) {\n+        struct.set(device_id$LAYOUT, device_id$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt miopen_conv_exhaustive_search$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"miopen_conv_exhaustive_search\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int miopen_conv_exhaustive_search\n+     * }\n+     *\/\n+    public static final OfInt miopen_conv_exhaustive_search$layout() {\n+        return miopen_conv_exhaustive_search$LAYOUT;\n+    }\n+\n+    private static final long miopen_conv_exhaustive_search$OFFSET = 4;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int miopen_conv_exhaustive_search\n+     * }\n+     *\/\n+    public static final long miopen_conv_exhaustive_search$offset() {\n+        return miopen_conv_exhaustive_search$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int miopen_conv_exhaustive_search\n+     * }\n+     *\/\n+    public static int miopen_conv_exhaustive_search(MemorySegment struct) {\n+        return struct.get(miopen_conv_exhaustive_search$LAYOUT, miopen_conv_exhaustive_search$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int miopen_conv_exhaustive_search\n+     * }\n+     *\/\n+    public static void miopen_conv_exhaustive_search(MemorySegment struct, int fieldValue) {\n+        struct.set(miopen_conv_exhaustive_search$LAYOUT, miopen_conv_exhaustive_search$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong gpu_mem_limit$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"gpu_mem_limit\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static final OfLong gpu_mem_limit$layout() {\n+        return gpu_mem_limit$LAYOUT;\n+    }\n+\n+    private static final long gpu_mem_limit$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static final long gpu_mem_limit$offset() {\n+        return gpu_mem_limit$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static long gpu_mem_limit(MemorySegment struct) {\n+        return struct.get(gpu_mem_limit$LAYOUT, gpu_mem_limit$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t gpu_mem_limit\n+     * }\n+     *\/\n+    public static void gpu_mem_limit(MemorySegment struct, long fieldValue) {\n+        struct.set(gpu_mem_limit$LAYOUT, gpu_mem_limit$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt arena_extend_strategy$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"arena_extend_strategy\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static final OfInt arena_extend_strategy$layout() {\n+        return arena_extend_strategy$LAYOUT;\n+    }\n+\n+    private static final long arena_extend_strategy$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static final long arena_extend_strategy$offset() {\n+        return arena_extend_strategy$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static int arena_extend_strategy(MemorySegment struct) {\n+        return struct.get(arena_extend_strategy$LAYOUT, arena_extend_strategy$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int arena_extend_strategy\n+     * }\n+     *\/\n+    public static void arena_extend_strategy(MemorySegment struct, int fieldValue) {\n+        struct.set(arena_extend_strategy$LAYOUT, arena_extend_strategy$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt do_copy_in_default_stream$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"do_copy_in_default_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static final OfInt do_copy_in_default_stream$layout() {\n+        return do_copy_in_default_stream$LAYOUT;\n+    }\n+\n+    private static final long do_copy_in_default_stream$OFFSET = 20;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static final long do_copy_in_default_stream$offset() {\n+        return do_copy_in_default_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static int do_copy_in_default_stream(MemorySegment struct) {\n+        return struct.get(do_copy_in_default_stream$LAYOUT, do_copy_in_default_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int do_copy_in_default_stream\n+     * }\n+     *\/\n+    public static void do_copy_in_default_stream(MemorySegment struct, int fieldValue) {\n+        struct.set(do_copy_in_default_stream$LAYOUT, do_copy_in_default_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt has_user_compute_stream$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"has_user_compute_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static final OfInt has_user_compute_stream$layout() {\n+        return has_user_compute_stream$LAYOUT;\n+    }\n+\n+    private static final long has_user_compute_stream$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static final long has_user_compute_stream$offset() {\n+        return has_user_compute_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static int has_user_compute_stream(MemorySegment struct) {\n+        return struct.get(has_user_compute_stream$LAYOUT, has_user_compute_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static void has_user_compute_stream(MemorySegment struct, int fieldValue) {\n+        struct.set(has_user_compute_stream$LAYOUT, has_user_compute_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout user_compute_stream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"user_compute_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static final AddressLayout user_compute_stream$layout() {\n+        return user_compute_stream$LAYOUT;\n+    }\n+\n+    private static final long user_compute_stream$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static final long user_compute_stream$offset() {\n+        return user_compute_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static MemorySegment user_compute_stream(MemorySegment struct) {\n+        return struct.get(user_compute_stream$LAYOUT, user_compute_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static void user_compute_stream(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(user_compute_stream$LAYOUT, user_compute_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout default_memory_arena_cfg$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"default_memory_arena_cfg\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static final AddressLayout default_memory_arena_cfg$layout() {\n+        return default_memory_arena_cfg$LAYOUT;\n+    }\n+\n+    private static final long default_memory_arena_cfg$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static final long default_memory_arena_cfg$offset() {\n+        return default_memory_arena_cfg$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static MemorySegment default_memory_arena_cfg(MemorySegment struct) {\n+        return struct.get(default_memory_arena_cfg$LAYOUT, default_memory_arena_cfg$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * OrtArenaCfg *default_memory_arena_cfg\n+     * }\n+     *\/\n+    public static void default_memory_arena_cfg(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(default_memory_arena_cfg$LAYOUT, default_memory_arena_cfg$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt enable_hip_graph$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"enable_hip_graph\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int enable_hip_graph\n+     * }\n+     *\/\n+    public static final OfInt enable_hip_graph$layout() {\n+        return enable_hip_graph$LAYOUT;\n+    }\n+\n+    private static final long enable_hip_graph$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int enable_hip_graph\n+     * }\n+     *\/\n+    public static final long enable_hip_graph$offset() {\n+        return enable_hip_graph$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int enable_hip_graph\n+     * }\n+     *\/\n+    public static int enable_hip_graph(MemorySegment struct) {\n+        return struct.get(enable_hip_graph$LAYOUT, enable_hip_graph$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int enable_hip_graph\n+     * }\n+     *\/\n+    public static void enable_hip_graph(MemorySegment struct, int fieldValue) {\n+        struct.set(enable_hip_graph$LAYOUT, enable_hip_graph$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tunable_op_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tunable_op_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static final OfInt tunable_op_enable$layout() {\n+        return tunable_op_enable$LAYOUT;\n+    }\n+\n+    private static final long tunable_op_enable$OFFSET = 52;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static final long tunable_op_enable$offset() {\n+        return tunable_op_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static int tunable_op_enable(MemorySegment struct) {\n+        return struct.get(tunable_op_enable$LAYOUT, tunable_op_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_enable\n+     * }\n+     *\/\n+    public static void tunable_op_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(tunable_op_enable$LAYOUT, tunable_op_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tunable_op_tuning_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tunable_op_tuning_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static final OfInt tunable_op_tuning_enable$layout() {\n+        return tunable_op_tuning_enable$LAYOUT;\n+    }\n+\n+    private static final long tunable_op_tuning_enable$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static final long tunable_op_tuning_enable$offset() {\n+        return tunable_op_tuning_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static int tunable_op_tuning_enable(MemorySegment struct) {\n+        return struct.get(tunable_op_tuning_enable$LAYOUT, tunable_op_tuning_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_tuning_enable\n+     * }\n+     *\/\n+    public static void tunable_op_tuning_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(tunable_op_tuning_enable$LAYOUT, tunable_op_tuning_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt tunable_op_max_tuning_duration_ms$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"tunable_op_max_tuning_duration_ms\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static final OfInt tunable_op_max_tuning_duration_ms$layout() {\n+        return tunable_op_max_tuning_duration_ms$LAYOUT;\n+    }\n+\n+    private static final long tunable_op_max_tuning_duration_ms$OFFSET = 60;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static final long tunable_op_max_tuning_duration_ms$offset() {\n+        return tunable_op_max_tuning_duration_ms$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static int tunable_op_max_tuning_duration_ms(MemorySegment struct) {\n+        return struct.get(tunable_op_max_tuning_duration_ms$LAYOUT, tunable_op_max_tuning_duration_ms$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int tunable_op_max_tuning_duration_ms\n+     * }\n+     *\/\n+    public static void tunable_op_max_tuning_duration_ms(MemorySegment struct, int fieldValue) {\n+        struct.set(tunable_op_max_tuning_duration_ms$LAYOUT, tunable_op_max_tuning_duration_ms$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtROCMProviderOptions.java","additions":634,"deletions":0,"binary":false,"changes":634,"status":"added"},{"patch":"@@ -0,0 +1,912 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * struct OrtTensorRTProviderOptions {\n+ *     int device_id;\n+ *     int has_user_compute_stream;\n+ *     void *user_compute_stream;\n+ *     int trt_max_partition_iterations;\n+ *     int trt_min_subgraph_size;\n+ *     size_t trt_max_workspace_size;\n+ *     int trt_fp16_enable;\n+ *     int trt_int8_enable;\n+ *     const char *trt_int8_calibration_table_name;\n+ *     int trt_int8_use_native_calibration_table;\n+ *     int trt_dla_enable;\n+ *     int trt_dla_core;\n+ *     int trt_dump_subgraphs;\n+ *     int trt_engine_cache_enable;\n+ *     const char *trt_engine_cache_path;\n+ *     int trt_engine_decryption_enable;\n+ *     const char *trt_engine_decryption_lib_path;\n+ *     int trt_force_sequential_engine_build;\n+ * }\n+ * }\n+ *\/\n+public class OrtTensorRTProviderOptions {\n+\n+    OrtTensorRTProviderOptions() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n+        onnxruntime_c_api_h.C_INT.withName(\"device_id\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"has_user_compute_stream\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"user_compute_stream\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_max_partition_iterations\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_min_subgraph_size\"),\n+        onnxruntime_c_api_h.C_LONG.withName(\"trt_max_workspace_size\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_fp16_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_int8_enable\"),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"trt_int8_calibration_table_name\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_int8_use_native_calibration_table\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_dla_enable\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_dla_core\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_dump_subgraphs\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_engine_cache_enable\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"trt_engine_cache_path\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_engine_decryption_enable\"),\n+        MemoryLayout.paddingLayout(4),\n+        onnxruntime_c_api_h.C_POINTER.withName(\"trt_engine_decryption_lib_path\"),\n+        onnxruntime_c_api_h.C_INT.withName(\"trt_force_sequential_engine_build\"),\n+        MemoryLayout.paddingLayout(4)\n+    ).withName(\"OrtTensorRTProviderOptions\");\n+\n+    \/**\n+     * The layout of this struct\n+     *\/\n+    public static final GroupLayout layout() {\n+        return $LAYOUT;\n+    }\n+\n+    private static final OfInt device_id$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"device_id\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final OfInt device_id$layout() {\n+        return device_id$LAYOUT;\n+    }\n+\n+    private static final long device_id$OFFSET = 0;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static final long device_id$offset() {\n+        return device_id$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static int device_id(MemorySegment struct) {\n+        return struct.get(device_id$LAYOUT, device_id$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int device_id\n+     * }\n+     *\/\n+    public static void device_id(MemorySegment struct, int fieldValue) {\n+        struct.set(device_id$LAYOUT, device_id$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt has_user_compute_stream$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"has_user_compute_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static final OfInt has_user_compute_stream$layout() {\n+        return has_user_compute_stream$LAYOUT;\n+    }\n+\n+    private static final long has_user_compute_stream$OFFSET = 4;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static final long has_user_compute_stream$offset() {\n+        return has_user_compute_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static int has_user_compute_stream(MemorySegment struct) {\n+        return struct.get(has_user_compute_stream$LAYOUT, has_user_compute_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int has_user_compute_stream\n+     * }\n+     *\/\n+    public static void has_user_compute_stream(MemorySegment struct, int fieldValue) {\n+        struct.set(has_user_compute_stream$LAYOUT, has_user_compute_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout user_compute_stream$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"user_compute_stream\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static final AddressLayout user_compute_stream$layout() {\n+        return user_compute_stream$LAYOUT;\n+    }\n+\n+    private static final long user_compute_stream$OFFSET = 8;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static final long user_compute_stream$offset() {\n+        return user_compute_stream$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static MemorySegment user_compute_stream(MemorySegment struct) {\n+        return struct.get(user_compute_stream$LAYOUT, user_compute_stream$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * void *user_compute_stream\n+     * }\n+     *\/\n+    public static void user_compute_stream(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(user_compute_stream$LAYOUT, user_compute_stream$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_max_partition_iterations$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_max_partition_iterations\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_max_partition_iterations\n+     * }\n+     *\/\n+    public static final OfInt trt_max_partition_iterations$layout() {\n+        return trt_max_partition_iterations$LAYOUT;\n+    }\n+\n+    private static final long trt_max_partition_iterations$OFFSET = 16;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_max_partition_iterations\n+     * }\n+     *\/\n+    public static final long trt_max_partition_iterations$offset() {\n+        return trt_max_partition_iterations$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_max_partition_iterations\n+     * }\n+     *\/\n+    public static int trt_max_partition_iterations(MemorySegment struct) {\n+        return struct.get(trt_max_partition_iterations$LAYOUT, trt_max_partition_iterations$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_max_partition_iterations\n+     * }\n+     *\/\n+    public static void trt_max_partition_iterations(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_max_partition_iterations$LAYOUT, trt_max_partition_iterations$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_min_subgraph_size$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_min_subgraph_size\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_min_subgraph_size\n+     * }\n+     *\/\n+    public static final OfInt trt_min_subgraph_size$layout() {\n+        return trt_min_subgraph_size$LAYOUT;\n+    }\n+\n+    private static final long trt_min_subgraph_size$OFFSET = 20;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_min_subgraph_size\n+     * }\n+     *\/\n+    public static final long trt_min_subgraph_size$offset() {\n+        return trt_min_subgraph_size$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_min_subgraph_size\n+     * }\n+     *\/\n+    public static int trt_min_subgraph_size(MemorySegment struct) {\n+        return struct.get(trt_min_subgraph_size$LAYOUT, trt_min_subgraph_size$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_min_subgraph_size\n+     * }\n+     *\/\n+    public static void trt_min_subgraph_size(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_min_subgraph_size$LAYOUT, trt_min_subgraph_size$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfLong trt_max_workspace_size$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"trt_max_workspace_size\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * size_t trt_max_workspace_size\n+     * }\n+     *\/\n+    public static final OfLong trt_max_workspace_size$layout() {\n+        return trt_max_workspace_size$LAYOUT;\n+    }\n+\n+    private static final long trt_max_workspace_size$OFFSET = 24;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * size_t trt_max_workspace_size\n+     * }\n+     *\/\n+    public static final long trt_max_workspace_size$offset() {\n+        return trt_max_workspace_size$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * size_t trt_max_workspace_size\n+     * }\n+     *\/\n+    public static long trt_max_workspace_size(MemorySegment struct) {\n+        return struct.get(trt_max_workspace_size$LAYOUT, trt_max_workspace_size$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * size_t trt_max_workspace_size\n+     * }\n+     *\/\n+    public static void trt_max_workspace_size(MemorySegment struct, long fieldValue) {\n+        struct.set(trt_max_workspace_size$LAYOUT, trt_max_workspace_size$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_fp16_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_fp16_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_fp16_enable\n+     * }\n+     *\/\n+    public static final OfInt trt_fp16_enable$layout() {\n+        return trt_fp16_enable$LAYOUT;\n+    }\n+\n+    private static final long trt_fp16_enable$OFFSET = 32;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_fp16_enable\n+     * }\n+     *\/\n+    public static final long trt_fp16_enable$offset() {\n+        return trt_fp16_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_fp16_enable\n+     * }\n+     *\/\n+    public static int trt_fp16_enable(MemorySegment struct) {\n+        return struct.get(trt_fp16_enable$LAYOUT, trt_fp16_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_fp16_enable\n+     * }\n+     *\/\n+    public static void trt_fp16_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_fp16_enable$LAYOUT, trt_fp16_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_int8_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_int8_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_enable\n+     * }\n+     *\/\n+    public static final OfInt trt_int8_enable$layout() {\n+        return trt_int8_enable$LAYOUT;\n+    }\n+\n+    private static final long trt_int8_enable$OFFSET = 36;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_enable\n+     * }\n+     *\/\n+    public static final long trt_int8_enable$offset() {\n+        return trt_int8_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_enable\n+     * }\n+     *\/\n+    public static int trt_int8_enable(MemorySegment struct) {\n+        return struct.get(trt_int8_enable$LAYOUT, trt_int8_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_enable\n+     * }\n+     *\/\n+    public static void trt_int8_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_int8_enable$LAYOUT, trt_int8_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout trt_int8_calibration_table_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"trt_int8_calibration_table_name\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *trt_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static final AddressLayout trt_int8_calibration_table_name$layout() {\n+        return trt_int8_calibration_table_name$LAYOUT;\n+    }\n+\n+    private static final long trt_int8_calibration_table_name$OFFSET = 40;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *trt_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static final long trt_int8_calibration_table_name$offset() {\n+        return trt_int8_calibration_table_name$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *trt_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static MemorySegment trt_int8_calibration_table_name(MemorySegment struct) {\n+        return struct.get(trt_int8_calibration_table_name$LAYOUT, trt_int8_calibration_table_name$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *trt_int8_calibration_table_name\n+     * }\n+     *\/\n+    public static void trt_int8_calibration_table_name(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(trt_int8_calibration_table_name$LAYOUT, trt_int8_calibration_table_name$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_int8_use_native_calibration_table$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_int8_use_native_calibration_table\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_use_native_calibration_table\n+     * }\n+     *\/\n+    public static final OfInt trt_int8_use_native_calibration_table$layout() {\n+        return trt_int8_use_native_calibration_table$LAYOUT;\n+    }\n+\n+    private static final long trt_int8_use_native_calibration_table$OFFSET = 48;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_use_native_calibration_table\n+     * }\n+     *\/\n+    public static final long trt_int8_use_native_calibration_table$offset() {\n+        return trt_int8_use_native_calibration_table$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_use_native_calibration_table\n+     * }\n+     *\/\n+    public static int trt_int8_use_native_calibration_table(MemorySegment struct) {\n+        return struct.get(trt_int8_use_native_calibration_table$LAYOUT, trt_int8_use_native_calibration_table$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_int8_use_native_calibration_table\n+     * }\n+     *\/\n+    public static void trt_int8_use_native_calibration_table(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_int8_use_native_calibration_table$LAYOUT, trt_int8_use_native_calibration_table$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_dla_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_dla_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_enable\n+     * }\n+     *\/\n+    public static final OfInt trt_dla_enable$layout() {\n+        return trt_dla_enable$LAYOUT;\n+    }\n+\n+    private static final long trt_dla_enable$OFFSET = 52;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_enable\n+     * }\n+     *\/\n+    public static final long trt_dla_enable$offset() {\n+        return trt_dla_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_enable\n+     * }\n+     *\/\n+    public static int trt_dla_enable(MemorySegment struct) {\n+        return struct.get(trt_dla_enable$LAYOUT, trt_dla_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_enable\n+     * }\n+     *\/\n+    public static void trt_dla_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_dla_enable$LAYOUT, trt_dla_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_dla_core$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_dla_core\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_core\n+     * }\n+     *\/\n+    public static final OfInt trt_dla_core$layout() {\n+        return trt_dla_core$LAYOUT;\n+    }\n+\n+    private static final long trt_dla_core$OFFSET = 56;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_core\n+     * }\n+     *\/\n+    public static final long trt_dla_core$offset() {\n+        return trt_dla_core$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_core\n+     * }\n+     *\/\n+    public static int trt_dla_core(MemorySegment struct) {\n+        return struct.get(trt_dla_core$LAYOUT, trt_dla_core$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_dla_core\n+     * }\n+     *\/\n+    public static void trt_dla_core(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_dla_core$LAYOUT, trt_dla_core$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_dump_subgraphs$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_dump_subgraphs\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_dump_subgraphs\n+     * }\n+     *\/\n+    public static final OfInt trt_dump_subgraphs$layout() {\n+        return trt_dump_subgraphs$LAYOUT;\n+    }\n+\n+    private static final long trt_dump_subgraphs$OFFSET = 60;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_dump_subgraphs\n+     * }\n+     *\/\n+    public static final long trt_dump_subgraphs$offset() {\n+        return trt_dump_subgraphs$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_dump_subgraphs\n+     * }\n+     *\/\n+    public static int trt_dump_subgraphs(MemorySegment struct) {\n+        return struct.get(trt_dump_subgraphs$LAYOUT, trt_dump_subgraphs$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_dump_subgraphs\n+     * }\n+     *\/\n+    public static void trt_dump_subgraphs(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_dump_subgraphs$LAYOUT, trt_dump_subgraphs$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_engine_cache_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_engine_cache_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_cache_enable\n+     * }\n+     *\/\n+    public static final OfInt trt_engine_cache_enable$layout() {\n+        return trt_engine_cache_enable$LAYOUT;\n+    }\n+\n+    private static final long trt_engine_cache_enable$OFFSET = 64;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_cache_enable\n+     * }\n+     *\/\n+    public static final long trt_engine_cache_enable$offset() {\n+        return trt_engine_cache_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_cache_enable\n+     * }\n+     *\/\n+    public static int trt_engine_cache_enable(MemorySegment struct) {\n+        return struct.get(trt_engine_cache_enable$LAYOUT, trt_engine_cache_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_cache_enable\n+     * }\n+     *\/\n+    public static void trt_engine_cache_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_engine_cache_enable$LAYOUT, trt_engine_cache_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout trt_engine_cache_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"trt_engine_cache_path\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_cache_path\n+     * }\n+     *\/\n+    public static final AddressLayout trt_engine_cache_path$layout() {\n+        return trt_engine_cache_path$LAYOUT;\n+    }\n+\n+    private static final long trt_engine_cache_path$OFFSET = 72;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_cache_path\n+     * }\n+     *\/\n+    public static final long trt_engine_cache_path$offset() {\n+        return trt_engine_cache_path$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_cache_path\n+     * }\n+     *\/\n+    public static MemorySegment trt_engine_cache_path(MemorySegment struct) {\n+        return struct.get(trt_engine_cache_path$LAYOUT, trt_engine_cache_path$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_cache_path\n+     * }\n+     *\/\n+    public static void trt_engine_cache_path(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(trt_engine_cache_path$LAYOUT, trt_engine_cache_path$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_engine_decryption_enable$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_engine_decryption_enable\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_decryption_enable\n+     * }\n+     *\/\n+    public static final OfInt trt_engine_decryption_enable$layout() {\n+        return trt_engine_decryption_enable$LAYOUT;\n+    }\n+\n+    private static final long trt_engine_decryption_enable$OFFSET = 80;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_decryption_enable\n+     * }\n+     *\/\n+    public static final long trt_engine_decryption_enable$offset() {\n+        return trt_engine_decryption_enable$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_decryption_enable\n+     * }\n+     *\/\n+    public static int trt_engine_decryption_enable(MemorySegment struct) {\n+        return struct.get(trt_engine_decryption_enable$LAYOUT, trt_engine_decryption_enable$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_engine_decryption_enable\n+     * }\n+     *\/\n+    public static void trt_engine_decryption_enable(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_engine_decryption_enable$LAYOUT, trt_engine_decryption_enable$OFFSET, fieldValue);\n+    }\n+\n+    private static final AddressLayout trt_engine_decryption_lib_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"trt_engine_decryption_lib_path\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_decryption_lib_path\n+     * }\n+     *\/\n+    public static final AddressLayout trt_engine_decryption_lib_path$layout() {\n+        return trt_engine_decryption_lib_path$LAYOUT;\n+    }\n+\n+    private static final long trt_engine_decryption_lib_path$OFFSET = 88;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_decryption_lib_path\n+     * }\n+     *\/\n+    public static final long trt_engine_decryption_lib_path$offset() {\n+        return trt_engine_decryption_lib_path$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_decryption_lib_path\n+     * }\n+     *\/\n+    public static MemorySegment trt_engine_decryption_lib_path(MemorySegment struct) {\n+        return struct.get(trt_engine_decryption_lib_path$LAYOUT, trt_engine_decryption_lib_path$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * const char *trt_engine_decryption_lib_path\n+     * }\n+     *\/\n+    public static void trt_engine_decryption_lib_path(MemorySegment struct, MemorySegment fieldValue) {\n+        struct.set(trt_engine_decryption_lib_path$LAYOUT, trt_engine_decryption_lib_path$OFFSET, fieldValue);\n+    }\n+\n+    private static final OfInt trt_force_sequential_engine_build$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"trt_force_sequential_engine_build\"));\n+\n+    \/**\n+     * Layout for field:\n+     * {@snippet lang=c :\n+     * int trt_force_sequential_engine_build\n+     * }\n+     *\/\n+    public static final OfInt trt_force_sequential_engine_build$layout() {\n+        return trt_force_sequential_engine_build$LAYOUT;\n+    }\n+\n+    private static final long trt_force_sequential_engine_build$OFFSET = 96;\n+\n+    \/**\n+     * Offset for field:\n+     * {@snippet lang=c :\n+     * int trt_force_sequential_engine_build\n+     * }\n+     *\/\n+    public static final long trt_force_sequential_engine_build$offset() {\n+        return trt_force_sequential_engine_build$OFFSET;\n+    }\n+\n+    \/**\n+     * Getter for field:\n+     * {@snippet lang=c :\n+     * int trt_force_sequential_engine_build\n+     * }\n+     *\/\n+    public static int trt_force_sequential_engine_build(MemorySegment struct) {\n+        return struct.get(trt_force_sequential_engine_build$LAYOUT, trt_force_sequential_engine_build$OFFSET);\n+    }\n+\n+    \/**\n+     * Setter for field:\n+     * {@snippet lang=c :\n+     * int trt_force_sequential_engine_build\n+     * }\n+     *\/\n+    public static void trt_force_sequential_engine_build(MemorySegment struct, int fieldValue) {\n+        struct.set(trt_force_sequential_engine_build$LAYOUT, trt_force_sequential_engine_build$OFFSET, fieldValue);\n+    }\n+\n+    \/**\n+     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n+     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n+     *\/\n+    public static MemorySegment asSlice(MemorySegment array, long index) {\n+        return array.asSlice(layout().byteSize() * index);\n+    }\n+\n+    \/**\n+     * The size (in bytes) of this struct\n+     *\/\n+    public static long sizeof() { return layout().byteSize(); }\n+\n+    \/**\n+     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n+     *\/\n+    public static MemorySegment allocate(SegmentAllocator allocator) {\n+        return allocator.allocate(layout());\n+    }\n+\n+    \/**\n+     * Allocate an array of size {@code elementCount} using {@code allocator}.\n+     * The returned segment has size {@code elementCount * layout().byteSize()}.\n+     *\/\n+    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return reinterpret(addr, 1, arena, cleanup);\n+    }\n+\n+    \/**\n+     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n+     * The returned segment has size {@code elementCount * layout().byteSize()}\n+     *\/\n+    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n+        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtTensorRTProviderOptions.java","additions":912,"deletions":0,"binary":false,"changes":912,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef void (*OrtThreadWorkerFn)(void *)\n+ * }\n+ *\/\n+public class OrtThreadWorkerFn {\n+\n+    OrtThreadWorkerFn() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        void apply(MemorySegment ort_worker_fn_param);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OrtThreadWorkerFn.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(OrtThreadWorkerFn.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static void invoke(MemorySegment funcPtr,MemorySegment ort_worker_fn_param) {\n+        try {\n+             DOWN$MH.invokeExact(funcPtr, ort_worker_fn_param);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtThreadWorkerFn.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef OrtStatus *(*OrtWriteBufferFunc)(void *, const void *, size_t)\n+ * }\n+ *\/\n+public class OrtWriteBufferFunc {\n+\n+    OrtWriteBufferFunc() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        MemorySegment apply(MemorySegment state, MemorySegment buffer, long buffer_num_bytes);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_LONG\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(OrtWriteBufferFunc.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(OrtWriteBufferFunc.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment state, MemorySegment buffer, long buffer_num_bytes) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, state, buffer, buffer_num_bytes);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/OrtWriteBufferFunc.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef OrtStatus *(*RegisterCustomOpsFn)(OrtSessionOptions *, const OrtApiBase *)\n+ * }\n+ *\/\n+public class RegisterCustomOpsFn {\n+\n+    RegisterCustomOpsFn() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        MemorySegment apply(MemorySegment options, MemorySegment api);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.of(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RegisterCustomOpsFn.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(RegisterCustomOpsFn.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static MemorySegment invoke(MemorySegment funcPtr,MemorySegment options, MemorySegment api) {\n+        try {\n+            return (MemorySegment) DOWN$MH.invokeExact(funcPtr, options, api);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/RegisterCustomOpsFn.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/\/ Generated by jextract\n+\n+package oracle.code.onnx.foreign;\n+\n+import java.lang.invoke.*;\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import java.util.*;\n+import java.util.function.*;\n+import java.util.stream.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.*;\n+\n+\/**\n+ * {@snippet lang=c :\n+ * typedef void (*RunAsyncCallbackFn)(void *, OrtValue **, size_t, OrtStatusPtr)\n+ * }\n+ *\/\n+public class RunAsyncCallbackFn {\n+\n+    RunAsyncCallbackFn() {\n+        \/\/ Should not be called directly\n+    }\n+\n+    \/**\n+     * The function pointer signature, expressed as a functional interface\n+     *\/\n+    public interface Function {\n+        void apply(MemorySegment user_data, MemorySegment outputs, long num_outputs, MemorySegment status);\n+    }\n+\n+    private static final FunctionDescriptor $DESC = FunctionDescriptor.ofVoid(\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_POINTER,\n+        onnxruntime_c_api_h.C_LONG,\n+        onnxruntime_c_api_h.C_POINTER\n+    );\n+\n+    \/**\n+     * The descriptor of this function pointer\n+     *\/\n+    public static FunctionDescriptor descriptor() {\n+        return $DESC;\n+    }\n+\n+    private static final MethodHandle UP$MH = onnxruntime_c_api_h.upcallHandle(RunAsyncCallbackFn.Function.class, \"apply\", $DESC);\n+\n+    \/**\n+     * Allocates a new upcall stub, whose implementation is defined by {@code fi}.\n+     * The lifetime of the returned segment is managed by {@code arena}\n+     *\/\n+    public static MemorySegment allocate(RunAsyncCallbackFn.Function fi, Arena arena) {\n+        return Linker.nativeLinker().upcallStub(UP$MH.bindTo(fi), $DESC, arena);\n+    }\n+\n+    private static final MethodHandle DOWN$MH = Linker.nativeLinker().downcallHandle($DESC);\n+\n+    \/**\n+     * Invoke the upcall stub {@code funcPtr}, with given parameters\n+     *\/\n+    public static void invoke(MemorySegment funcPtr,MemorySegment user_data, MemorySegment outputs, long num_outputs, MemorySegment status) {\n+        try {\n+             DOWN$MH.invokeExact(funcPtr, user_data, outputs, num_outputs, status);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+}\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/RunAsyncCallbackFn.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -8,0 +8,1 @@\n+import java.util.function.*;\n@@ -10,0 +11,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -12,0 +15,1 @@\n+    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n@@ -22,1 +26,10 @@\n-        return SYMBOL_LOOKUP.findOrThrow(symbol);\n+        return SYMBOL_LOOKUP.find(symbol)\n+            .orElseThrow(() -> new UnsatisfiedLinkError(\"unresolved symbol: \" + symbol));\n+    }\n+\n+    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n@@ -25,0 +38,16 @@\n+    static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+\n+\n+\n@@ -37,1 +66,2 @@\n-    private static final int ORT_API_VERSION = (int)20L;\n+\n+    private static final int true_ = (int)1L;\n@@ -40,1 +70,28 @@\n-     * #define ORT_API_VERSION 20\n+     * #define true 1\n+     * }\n+     *\/\n+    public static int true_() {\n+        return true_;\n+    }\n+    private static final int false_ = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define false 0\n+     * }\n+     *\/\n+    public static int false_() {\n+        return false_;\n+    }\n+    private static final int __bool_true_false_are_defined = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define __bool_true_false_are_defined 1\n+     * }\n+     *\/\n+    public static int __bool_true_false_are_defined() {\n+        return __bool_true_false_are_defined;\n+    }\n+    private static final int ORT_API_VERSION = (int)23L;\n+    \/**\n+     * {@snippet lang=c :\n+     * #define ORT_API_VERSION 23\n@@ -253,0 +310,9 @@\n+    private static final int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT4E2M1 = (int)23L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum ONNXTensorElementDataType.ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT4E2M1 = 23\n+     * }\n+     *\/\n+    public static int ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT4E2M1() {\n+        return ONNX_TENSOR_ELEMENT_DATA_TYPE_FLOAT4E2M1;\n+    }\n@@ -541,0 +607,27 @@\n+    private static final int ORT_MODEL_LOAD_CANCELED = (int)12L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_MODEL_LOAD_CANCELED = 12\n+     * }\n+     *\/\n+    public static int ORT_MODEL_LOAD_CANCELED() {\n+        return ORT_MODEL_LOAD_CANCELED;\n+    }\n+    private static final int ORT_MODEL_REQUIRES_COMPILATION = (int)13L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_MODEL_REQUIRES_COMPILATION = 13\n+     * }\n+     *\/\n+    public static int ORT_MODEL_REQUIRES_COMPILATION() {\n+        return ORT_MODEL_REQUIRES_COMPILATION;\n+    }\n+    private static final int ORT_NOT_FOUND = (int)14L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtErrorCode.ORT_NOT_FOUND = 14\n+     * }\n+     *\/\n+    public static int ORT_NOT_FOUND() {\n+        return ORT_NOT_FOUND;\n+    }\n@@ -604,0 +697,18 @@\n+    private static final int ORT_OP_ATTR_GRAPH = (int)7L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_GRAPH = 7\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_GRAPH() {\n+        return ORT_OP_ATTR_GRAPH;\n+    }\n+    private static final int ORT_OP_ATTR_TENSOR = (int)8L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtOpAttrType.ORT_OP_ATTR_TENSOR = 8\n+     * }\n+     *\/\n+    public static int ORT_OP_ATTR_TENSOR() {\n+        return ORT_OP_ATTR_TENSOR;\n+    }\n@@ -637,0 +748,9 @@\n+    private static final int ORT_ENABLE_LAYOUT = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum GraphOptimizationLevel.ORT_ENABLE_LAYOUT = 3\n+     * }\n+     *\/\n+    public static int ORT_ENABLE_LAYOUT() {\n+        return ORT_ENABLE_LAYOUT;\n+    }\n@@ -754,0 +874,9 @@\n+    private static final int OrtReadOnlyAllocator = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtAllocatorType.OrtReadOnlyAllocator = 2\n+     * }\n+     *\/\n+    public static int OrtReadOnlyAllocator() {\n+        return OrtReadOnlyAllocator;\n+    }\n@@ -790,0 +919,18 @@\n+    private static final int OrtDeviceMemoryType_DEFAULT = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtDeviceMemoryType.OrtDeviceMemoryType_DEFAULT = 0\n+     * }\n+     *\/\n+    public static int OrtDeviceMemoryType_DEFAULT() {\n+        return OrtDeviceMemoryType_DEFAULT;\n+    }\n+    private static final int OrtDeviceMemoryType_HOST_ACCESSIBLE = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtDeviceMemoryType.OrtDeviceMemoryType_HOST_ACCESSIBLE = 5\n+     * }\n+     *\/\n+    public static int OrtDeviceMemoryType_HOST_ACCESSIBLE() {\n+        return OrtDeviceMemoryType_HOST_ACCESSIBLE;\n+    }\n@@ -817,0 +964,99 @@\n+    private static final int OrtMemoryInfoDeviceType_NPU = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtMemoryInfoDeviceType.OrtMemoryInfoDeviceType_NPU = 3\n+     * }\n+     *\/\n+    public static int OrtMemoryInfoDeviceType_NPU() {\n+        return OrtMemoryInfoDeviceType_NPU;\n+    }\n+    private static final int OrtHardwareDeviceType_CPU = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtHardwareDeviceType.OrtHardwareDeviceType_CPU = 0\n+     * }\n+     *\/\n+    public static int OrtHardwareDeviceType_CPU() {\n+        return OrtHardwareDeviceType_CPU;\n+    }\n+    private static final int OrtHardwareDeviceType_GPU = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtHardwareDeviceType.OrtHardwareDeviceType_GPU = 1\n+     * }\n+     *\/\n+    public static int OrtHardwareDeviceType_GPU() {\n+        return OrtHardwareDeviceType_GPU;\n+    }\n+    private static final int OrtHardwareDeviceType_NPU = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtHardwareDeviceType.OrtHardwareDeviceType_NPU = 2\n+     * }\n+     *\/\n+    public static int OrtHardwareDeviceType_NPU() {\n+        return OrtHardwareDeviceType_NPU;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_DEFAULT = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_DEFAULT = 0\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_DEFAULT() {\n+        return OrtExecutionProviderDevicePolicy_DEFAULT;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_PREFER_CPU = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_PREFER_CPU = 1\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_PREFER_CPU() {\n+        return OrtExecutionProviderDevicePolicy_PREFER_CPU;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_PREFER_NPU = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_PREFER_NPU = 2\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_PREFER_NPU() {\n+        return OrtExecutionProviderDevicePolicy_PREFER_NPU;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_PREFER_GPU = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_PREFER_GPU = 3\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_PREFER_GPU() {\n+        return OrtExecutionProviderDevicePolicy_PREFER_GPU;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_MAX_PERFORMANCE = (int)4L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_MAX_PERFORMANCE = 4\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_MAX_PERFORMANCE() {\n+        return OrtExecutionProviderDevicePolicy_MAX_PERFORMANCE;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_MAX_EFFICIENCY = (int)5L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_MAX_EFFICIENCY = 5\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_MAX_EFFICIENCY() {\n+        return OrtExecutionProviderDevicePolicy_MAX_EFFICIENCY;\n+    }\n+    private static final int OrtExecutionProviderDevicePolicy_MIN_OVERALL_POWER = (int)6L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtExecutionProviderDevicePolicy.OrtExecutionProviderDevicePolicy_MIN_OVERALL_POWER = 6\n+     * }\n+     *\/\n+    public static int OrtExecutionProviderDevicePolicy_MIN_OVERALL_POWER() {\n+        return OrtExecutionProviderDevicePolicy_MIN_OVERALL_POWER;\n+    }\n@@ -908,0 +1154,36 @@\n+    private static final int OrtCompiledModelCompatibility_EP_NOT_APPLICABLE = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompiledModelCompatibility.OrtCompiledModelCompatibility_EP_NOT_APPLICABLE = 0\n+     * }\n+     *\/\n+    public static int OrtCompiledModelCompatibility_EP_NOT_APPLICABLE() {\n+        return OrtCompiledModelCompatibility_EP_NOT_APPLICABLE;\n+    }\n+    private static final int OrtCompiledModelCompatibility_EP_SUPPORTED_OPTIMAL = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompiledModelCompatibility.OrtCompiledModelCompatibility_EP_SUPPORTED_OPTIMAL = 1\n+     * }\n+     *\/\n+    public static int OrtCompiledModelCompatibility_EP_SUPPORTED_OPTIMAL() {\n+        return OrtCompiledModelCompatibility_EP_SUPPORTED_OPTIMAL;\n+    }\n+    private static final int OrtCompiledModelCompatibility_EP_SUPPORTED_PREFER_RECOMPILATION = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompiledModelCompatibility.OrtCompiledModelCompatibility_EP_SUPPORTED_PREFER_RECOMPILATION = 2\n+     * }\n+     *\/\n+    public static int OrtCompiledModelCompatibility_EP_SUPPORTED_PREFER_RECOMPILATION() {\n+        return OrtCompiledModelCompatibility_EP_SUPPORTED_PREFER_RECOMPILATION;\n+    }\n+    private static final int OrtCompiledModelCompatibility_EP_UNSUPPORTED = (int)3L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompiledModelCompatibility.OrtCompiledModelCompatibility_EP_UNSUPPORTED = 3\n+     * }\n+     *\/\n+    public static int OrtCompiledModelCompatibility_EP_UNSUPPORTED() {\n+        return OrtCompiledModelCompatibility_EP_UNSUPPORTED;\n+    }\n@@ -935,0 +1217,27 @@\n+    private static final int OrtCompileApiFlags_NONE = (int)0L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompileApiFlags.OrtCompileApiFlags_NONE = 0\n+     * }\n+     *\/\n+    public static int OrtCompileApiFlags_NONE() {\n+        return OrtCompileApiFlags_NONE;\n+    }\n+    private static final int OrtCompileApiFlags_ERROR_IF_NO_NODES_COMPILED = (int)1L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompileApiFlags.OrtCompileApiFlags_ERROR_IF_NO_NODES_COMPILED = 1\n+     * }\n+     *\/\n+    public static int OrtCompileApiFlags_ERROR_IF_NO_NODES_COMPILED() {\n+        return OrtCompileApiFlags_ERROR_IF_NO_NODES_COMPILED;\n+    }\n+    private static final int OrtCompileApiFlags_ERROR_IF_OUTPUT_FILE_EXISTS = (int)2L;\n+    \/**\n+     * {@snippet lang=c :\n+     * enum OrtCompileApiFlags.OrtCompileApiFlags_ERROR_IF_OUTPUT_FILE_EXISTS = 2\n+     * }\n+     *\/\n+    public static int OrtCompileApiFlags_ERROR_IF_OUTPUT_FILE_EXISTS() {\n+        return OrtCompileApiFlags_ERROR_IF_OUTPUT_FILE_EXISTS;\n+    }\n@@ -1230,0 +1539,12 @@\n+    \/**\n+     * {@snippet lang=c :\n+     * #define ORT_FILE \"\/var\/folders\/20\/84x77j_x7p7fb3fmm0n_b0n40000gn\/T\/jextract$17571614317986694339.h\"\n+     * }\n+     *\/\n+    public static MemorySegment ORT_FILE() {\n+        class Holder {\n+            static final MemorySegment ORT_FILE\n+                = onnxruntime_c_api_h.LIBRARY_ARENA.allocateFrom(\"\/var\/folders\/20\/84x77j_x7p7fb3fmm0n_b0n40000gn\/T\/jextract$17571614317986694339.h\");\n+        }\n+        return Holder.ORT_FILE;\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/foreign\/onnxruntime_c_api_h.java","additions":324,"deletions":3,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.code.extern.OpFactory;\n@@ -2012,0 +2011,220 @@\n+    @OpFactoryHelper.OpDeclaration(Attention.NAME)\n+    public static final class Attention extends OnnxOp {\n+        public static final String NAME = \"Attention\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            qk_matmul_output_mode(Long.class, true, 0),\n+            softcap(Float.class, true, 0.0f),\n+            softmax_precision(Long.class, true, null),\n+            scale(Float.class, true, null),\n+            is_causal(Long.class, true, 0),\n+            q_num_heads(Long.class, true, null),\n+            kv_num_heads(Long.class, true, null),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            U(new OnnxType.TypeVariable(\"U\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bool())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            Q(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            K(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            V(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            attn_mask(TypeConstraint.U.typeVariable(), Quantifier.OPTIONAL),\n+            past_key(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            past_value(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            nonpad_kv_seqlen(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n+            present_key(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            present_value(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            qk_matmul_output(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Attention(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Attention(Attention that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Attention transform(CopyContext cc, OpTransformer ot) {\n+            return new Attention(this, cc);\n+        }\n+\n+        Attention(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value Q, Value K, Value V, java.util.Optional<Value> attn_mask, java.util.Optional<Value> past_key, java.util.Optional<Value> past_value, java.util.Optional<Value> nonpad_kv_seqlen, java.util.Optional<Long> qk_matmul_output_mode, java.util.Optional<Float> softcap, java.util.Optional<Long> softmax_precision, java.util.Optional<Float> scale, java.util.Optional<Long> is_causal, java.util.Optional<Long> q_num_heads, java.util.Optional<Long> kv_num_heads) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(Q, K, V, attn_mask, past_key, past_value, nonpad_kv_seqlen), List.of(qk_matmul_output_mode, softcap, softmax_precision, scale, is_causal, q_num_heads, kv_num_heads));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(Q(), K(), V(), attn_mask(), past_key(), past_value(), nonpad_kv_seqlen()));\n+        }\n+\n+        public Value Q() {\n+            return operands().get(0);\n+        }\n+\n+        public Value K() {\n+            return operands().get(1);\n+        }\n+\n+        public Value V() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> attn_mask() {\n+            int i = optionalInputArguments.indexOf(InputParameter.attn_mask);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> past_key() {\n+            int i = optionalInputArguments.indexOf(InputParameter.past_key);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> past_value() {\n+            int i = optionalInputArguments.indexOf(InputParameter.past_value);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> nonpad_kv_seqlen() {\n+            int i = optionalInputArguments.indexOf(InputParameter.nonpad_kv_seqlen);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Long> qk_matmul_output_mode() {\n+            Long qk_matmul_output_mode = Attribute.qk_matmul_output_mode.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(qk_matmul_output_mode);\n+        }\n+\n+        public java.util.Optional<Float> softcap() {\n+            Float softcap = Attribute.softcap.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(softcap);\n+        }\n+\n+        public java.util.Optional<Long> softmax_precision() {\n+            Long softmax_precision = Attribute.softmax_precision.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(softmax_precision);\n+        }\n+\n+        public java.util.Optional<Float> scale() {\n+            Float scale = Attribute.scale.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(scale);\n+        }\n+\n+        public java.util.Optional<Long> is_causal() {\n+            Long is_causal = Attribute.is_causal.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(is_causal);\n+        }\n+\n+        public java.util.Optional<Long> q_num_heads() {\n+            Long q_num_heads = Attribute.q_num_heads.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(q_num_heads);\n+        }\n+\n+        public java.util.Optional<Long> kv_num_heads() {\n+            Long kv_num_heads = Attribute.kv_num_heads.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(kv_num_heads);\n+        }\n+\n+    }\n+\n+    public static Attention Attention(TypeElement resultType, Set<Attention.OutputParameter> optionalOutputs, Value Q, Value K, Value V, java.util.Optional<Value> attn_mask, java.util.Optional<Value> past_key, java.util.Optional<Value> past_value, java.util.Optional<Value> nonpad_kv_seqlen, java.util.Optional<Long> qk_matmul_output_mode, java.util.Optional<Float> softcap, java.util.Optional<Long> softmax_precision, java.util.Optional<Float> scale, java.util.Optional<Long> is_causal, java.util.Optional<Long> q_num_heads, java.util.Optional<Long> kv_num_heads) {\n+        return new Attention(resultType, optionalOutputs, Q, K, V, attn_mask, past_key, past_value, nonpad_kv_seqlen, qk_matmul_output_mode, softcap, softmax_precision, scale, is_causal, q_num_heads, kv_num_heads);\n+    }\n+\n@@ -3451,0 +3670,1 @@\n+            round_mode(String.class, true, \"up\"),\n@@ -3478,2 +3698,2 @@\n-            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n-            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -3562,2 +3782,2 @@\n-        Cast(TypeElement resultType, Value input, java.util.Optional<Long> saturate, long to) {\n-            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(saturate, to));\n+        Cast(TypeElement resultType, Value input, java.util.Optional<Long> saturate, long to, java.util.Optional<String> round_mode) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input), List.of(saturate, to, round_mode));\n@@ -3590,0 +3810,5 @@\n+        public java.util.Optional<String> round_mode() {\n+            String round_mode = Attribute.round_mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(round_mode);\n+        }\n+\n@@ -3592,2 +3817,2 @@\n-    public static Cast Cast(TypeElement resultType, Value input, java.util.Optional<Long> saturate, long to) {\n-        return new Cast(resultType, input, saturate, to);\n+    public static Cast Cast(TypeElement resultType, Value input, java.util.Optional<Long> saturate, long to, java.util.Optional<String> round_mode) {\n+        return new Cast(resultType, input, saturate, to, round_mode);\n@@ -3602,0 +3827,1 @@\n+            round_mode(String.class, true, \"up\"),\n@@ -3629,2 +3855,2 @@\n-            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n-            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -3714,2 +3940,2 @@\n-        CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Long> saturate) {\n-            super(SCHEMA, resultType, Set.of(), List.of(input, target_type), List.of(saturate));\n+        CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Long> saturate, java.util.Optional<String> round_mode) {\n+            super(SCHEMA, resultType, Set.of(), List.of(input, target_type), List.of(saturate, round_mode));\n@@ -3741,0 +3967,5 @@\n+        public java.util.Optional<String> round_mode() {\n+            String round_mode = Attribute.round_mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(round_mode);\n+        }\n+\n@@ -3743,2 +3974,2 @@\n-    public static CastLike CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Long> saturate) {\n-        return new CastLike(resultType, input, target_type, saturate);\n+    public static CastLike CastLike(TypeElement resultType, Value input, Value target_type, java.util.Optional<Long> saturate, java.util.Optional<String> round_mode) {\n+        return new CastLike(resultType, input, target_type, saturate, round_mode);\n@@ -5260,1 +5491,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -5416,1 +5647,1 @@\n-            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -7008,0 +7239,1 @@\n+            output_dtype(Long.class, true, 0),\n@@ -7038,1 +7270,2 @@\n-            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float8e8m0())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),\n@@ -7080,1 +7313,1 @@\n-            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n@@ -7123,2 +7356,2 @@\n-        DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n-            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point), List.of(axis, block_size));\n+        DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, x_scale, x_zero_point), List.of(output_dtype, axis, block_size));\n@@ -7150,0 +7383,5 @@\n+        public java.util.Optional<Long> output_dtype() {\n+            Long output_dtype = Attribute.output_dtype.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(output_dtype);\n+        }\n+\n@@ -7162,2 +7400,2 @@\n-    public static DequantizeLinear DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n-        return new DequantizeLinear(resultType, x, x_scale, x_zero_point, axis, block_size);\n+    public static DequantizeLinear DequantizeLinear(TypeElement resultType, Value x, Value x_scale, java.util.Optional<Value> x_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n+        return new DequantizeLinear(resultType, x, x_scale, x_zero_point, output_dtype, axis, block_size);\n@@ -8915,1 +9153,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -11951,1 +12189,1 @@\n-            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128())), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128()))))),\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0()), OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128())), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.uint64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int8()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.int64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float16()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float32()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.float64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.string()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.bool()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex64()))), OnnxType.optional(OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))), OnnxType.optional(OnnxType.tensor(OnnxType.uint8())), OnnxType.optional(OnnxType.tensor(OnnxType.uint16())), OnnxType.optional(OnnxType.tensor(OnnxType.uint32())), OnnxType.optional(OnnxType.tensor(OnnxType.uint64())), OnnxType.optional(OnnxType.tensor(OnnxType.int8())), OnnxType.optional(OnnxType.tensor(OnnxType.int16())), OnnxType.optional(OnnxType.tensor(OnnxType.int32())), OnnxType.optional(OnnxType.tensor(OnnxType.int64())), OnnxType.optional(OnnxType.tensor(OnnxType.float16())), OnnxType.optional(OnnxType.tensor(OnnxType.float32())), OnnxType.optional(OnnxType.tensor(OnnxType.float64())), OnnxType.optional(OnnxType.tensor(OnnxType.string())), OnnxType.optional(OnnxType.tensor(OnnxType.bool())), OnnxType.optional(OnnxType.tensor(OnnxType.complex64())), OnnxType.optional(OnnxType.tensor(OnnxType.complex128()))))),\n@@ -18778,1 +19016,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -19406,0 +19644,1 @@\n+            precision(Long.class, true, 0),\n@@ -19436,1 +19675,2 @@\n-            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T2(new OnnxType.TypeVariable(\"T2\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.float8e8m0())))),\n+            T3(new OnnxType.TypeVariable(\"T3\", List.of(OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n@@ -19454,2 +19694,2 @@\n-            y_scale(TypeConstraint.T1.typeVariable(), Quantifier.REQUIRED),\n-            y_zero_point(TypeConstraint.T2.typeVariable(), Quantifier.OPTIONAL),\n+            y_scale(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            y_zero_point(TypeConstraint.T3.typeVariable(), Quantifier.OPTIONAL),\n@@ -19478,1 +19718,1 @@\n-            y(TypeConstraint.T2.typeVariable(), Quantifier.REQUIRED),\n+            y(TypeConstraint.T3.typeVariable(), Quantifier.REQUIRED),\n@@ -19521,2 +19761,2 @@\n-        QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> saturate, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n-            super(SCHEMA, resultType, Set.of(), List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, axis, block_size));\n+        QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> saturate, java.util.Optional<Long> precision, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n+            super(SCHEMA, resultType, Set.of(), List.of(x, y_scale, y_zero_point), List.of(output_dtype, saturate, precision, axis, block_size));\n@@ -19558,0 +19798,5 @@\n+        public java.util.Optional<Long> precision() {\n+            Long precision = Attribute.precision.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(precision);\n+        }\n+\n@@ -19570,2 +19815,2 @@\n-    public static QuantizeLinear QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> saturate, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n-        return new QuantizeLinear(resultType, x, y_scale, y_zero_point, output_dtype, saturate, axis, block_size);\n+    public static QuantizeLinear QuantizeLinear(TypeElement resultType, Value x, Value y_scale, java.util.Optional<Value> y_zero_point, java.util.Optional<Long> output_dtype, java.util.Optional<Long> saturate, java.util.Optional<Long> precision, java.util.Optional<Long> axis, java.util.Optional<Long> block_size) {\n+        return new QuantizeLinear(resultType, x, y_scale, y_zero_point, output_dtype, saturate, precision, axis, block_size);\n@@ -19574,3 +19819,3 @@\n-    @OpFactoryHelper.OpDeclaration(RNN.NAME)\n-    public static final class RNN extends OnnxOp {\n-        public static final String NAME = \"RNN\";\n+    @OpFactoryHelper.OpDeclaration(RMSNormalization.NAME)\n+    public static final class RMSNormalization extends OnnxOp {\n+        public static final String NAME = \"RMSNormalization\";\n@@ -19579,7 +19824,3 @@\n-            layout(Long.class, true, 0),\n-            activation_alpha(float[].class, true, null),\n-            hidden_size(Long.class, true, null),\n-            activation_beta(float[].class, true, null),\n-            activations(String[].class, true, null),\n-            clip(Float.class, true, null),\n-            direction(String.class, true, \"forward\"),\n+            epsilon(Float.class, true, 1.0E-5f),\n+            stash_type(Long.class, true, 1),\n+            axis(Long.class, true, -1),\n@@ -19613,2 +19854,2 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n-            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            V(new OnnxType.TypeVariable(\"V\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n@@ -19632,5 +19873,1 @@\n-            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n-            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n-            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n-            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n-            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            scale(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),\n@@ -19659,2 +19896,1 @@\n-            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n-            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            Y(TypeConstraint.V.typeVariable(), Quantifier.REQUIRED),\n@@ -19690,1 +19926,1 @@\n-        public RNN(ExternalizedOp def) {\n+        public RMSNormalization(ExternalizedOp def) {\n@@ -19694,1 +19930,1 @@\n-        RNN(RNN that, CopyContext cc) {\n+        RMSNormalization(RMSNormalization that, CopyContext cc) {\n@@ -19699,2 +19935,2 @@\n-        public RNN transform(CopyContext cc, OpTransformer ot) {\n-            return new RNN(this, cc);\n+        public RMSNormalization transform(CopyContext cc, OpTransformer ot) {\n+            return new RMSNormalization(this, cc);\n@@ -19703,2 +19939,2 @@\n-        RNN(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Long> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n-            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction));\n+        RMSNormalization(TypeElement resultType, Value X, Value scale, java.util.Optional<Float> epsilon, java.util.Optional<Long> stash_type, java.util.Optional<Long> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, scale), List.of(epsilon, stash_type, axis));\n@@ -19714,1 +19950,1 @@\n-            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));\n+            return onnxInputs(SCHEMA, List.of(X(), scale()));\n@@ -19721,1 +19957,1 @@\n-        public Value W() {\n+        public Value scale() {\n@@ -19725,12 +19961,3 @@\n-        public Value R() {\n-            return operands().get(2);\n-        }\n-\n-        public java.util.Optional<Value> B() {\n-            int i = optionalInputArguments.indexOf(InputParameter.B);\n-            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n-        }\n-\n-        public java.util.Optional<Value> sequence_lens() {\n-            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);\n-            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        public java.util.Optional<Float> epsilon() {\n+            Float epsilon = Attribute.epsilon.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(epsilon);\n@@ -19739,3 +19966,3 @@\n-        public java.util.Optional<Value> initial_h() {\n-            int i = optionalInputArguments.indexOf(InputParameter.initial_h);\n-            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        public java.util.Optional<Long> stash_type() {\n+            Long stash_type = Attribute.stash_type.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(stash_type);\n@@ -19744,3 +19971,3 @@\n-        public java.util.Optional<Long> layout() {\n-            Long layout = Attribute.layout.access(Long.class, onnxAttributes);\n-            return java.util.Optional.ofNullable(layout);\n+        public java.util.Optional<Long> axis() {\n+            Long axis = Attribute.axis.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n@@ -19749,4 +19976,1 @@\n-        public java.util.Optional<float[]> activation_alpha() {\n-            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);\n-            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);\n-        }\n+    }\n@@ -19754,4 +19978,3 @@\n-        public java.util.Optional<Long> hidden_size() {\n-            Long hidden_size = Attribute.hidden_size.access(Long.class, onnxAttributes);\n-            return java.util.Optional.ofNullable(hidden_size);\n-        }\n+    public static RMSNormalization RMSNormalization(TypeElement resultType, Value X, Value scale, java.util.Optional<Float> epsilon, java.util.Optional<Long> stash_type, java.util.Optional<Long> axis) {\n+        return new RMSNormalization(resultType, X, scale, epsilon, stash_type, axis);\n+    }\n@@ -19759,4 +19982,3 @@\n-        public java.util.Optional<float[]> activation_beta() {\n-            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);\n-            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);\n-        }\n+    @OpFactoryHelper.OpDeclaration(RNN.NAME)\n+    public static final class RNN extends OnnxOp {\n+        public static final String NAME = \"RNN\";\n@@ -19764,2 +19986,188 @@\n-        public java.util.Optional<String[]> activations() {\n-            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);\n+        public enum Attribute implements OnnxAttribute {\n+            layout(Long.class, true, 0),\n+            activation_alpha(float[].class, true, null),\n+            hidden_size(Long.class, true, null),\n+            activation_beta(float[].class, true, null),\n+            activations(String[].class, true, null),\n+            clip(Float.class, true, null),\n+            direction(String.class, true, \"forward\"),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T1(new OnnxType.TypeVariable(\"T1\", List.of(OnnxType.tensor(OnnxType.int32())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            W(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            R(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            B(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            sequence_lens(TypeConstraint.T1.typeVariable(), Quantifier.OPTIONAL),\n+            initial_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            Y_h(TypeConstraint.T.typeVariable(), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public RNN(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        RNN(RNN that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RNN transform(CopyContext cc, OpTransformer ot) {\n+            return new RNN(this, cc);\n+        }\n+\n+        RNN(TypeElement resultType, Set<OutputParameter> optionalOutputs, Value X, Value W, Value R, java.util.Optional<Value> B, java.util.Optional<Value> sequence_lens, java.util.Optional<Value> initial_h, java.util.Optional<Long> layout, java.util.Optional<float[]> activation_alpha, java.util.Optional<Long> hidden_size, java.util.Optional<float[]> activation_beta, java.util.Optional<String[]> activations, java.util.Optional<Float> clip, java.util.Optional<String> direction) {\n+            super(SCHEMA, resultType, optionalOutputs, List.of(X, W, R, B, sequence_lens, initial_h), List.of(layout, activation_alpha, hidden_size, activation_beta, activations, clip, direction));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X(), W(), R(), B(), sequence_lens(), initial_h()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public Value W() {\n+            return operands().get(1);\n+        }\n+\n+        public Value R() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> B() {\n+            int i = optionalInputArguments.indexOf(InputParameter.B);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> sequence_lens() {\n+            int i = optionalInputArguments.indexOf(InputParameter.sequence_lens);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Value> initial_h() {\n+            int i = optionalInputArguments.indexOf(InputParameter.initial_h);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Long> layout() {\n+            Long layout = Attribute.layout.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(layout);\n+        }\n+\n+        public java.util.Optional<float[]> activation_alpha() {\n+            float[] activation_alpha = Attribute.activation_alpha.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_alpha).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<Long> hidden_size() {\n+            Long hidden_size = Attribute.hidden_size.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(hidden_size);\n+        }\n+\n+        public java.util.Optional<float[]> activation_beta() {\n+            float[] activation_beta = Attribute.activation_beta.access(float[].class, onnxAttributes);\n+            return java.util.Optional.ofNullable(activation_beta).map(float[]::clone);\n+        }\n+\n+        public java.util.Optional<String[]> activations() {\n+            String[] activations = Attribute.activations.access(String[].class, onnxAttributes);\n@@ -22502,1 +22910,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -23173,3 +23581,3 @@\n-    @OpFactoryHelper.OpDeclaration(Round.NAME)\n-    public static final class Round extends OnnxOp {\n-        public static final String NAME = \"Round\";\n+    @OpFactoryHelper.OpDeclaration(RotaryEmbedding.NAME)\n+    public static final class RotaryEmbedding extends OnnxOp {\n+        public static final String NAME = \"RotaryEmbedding\";\n@@ -23177,1 +23585,29 @@\n-        public enum Attribute implements OnnxAttribute.None { }\n+        public enum Attribute implements OnnxAttribute {\n+            num_heads(Long.class, true, null),\n+            rotary_embedding_dim(Long.class, true, 0),\n+            interleaved(Long.class, true, 0),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n@@ -23180,1 +23616,2 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.bfloat16())))),\n+            M(new OnnxType.TypeVariable(\"M\", List.of(OnnxType.tensor(OnnxType.int64())))),\n@@ -23198,0 +23635,3 @@\n+            cos_cache(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            sin_cache(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            position_ids(TypeConstraint.M.typeVariable(), Quantifier.OPTIONAL),\n@@ -23250,1 +23690,1 @@\n-        public Round(ExternalizedOp def) {\n+        public RotaryEmbedding(ExternalizedOp def) {\n@@ -23254,1 +23694,1 @@\n-        Round(Round that, CopyContext cc) {\n+        RotaryEmbedding(RotaryEmbedding that, CopyContext cc) {\n@@ -23259,2 +23699,2 @@\n-        public Round transform(CopyContext cc, OpTransformer ot) {\n-            return new Round(this, cc);\n+        public RotaryEmbedding transform(CopyContext cc, OpTransformer ot) {\n+            return new RotaryEmbedding(this, cc);\n@@ -23263,2 +23703,2 @@\n-        Round(TypeElement resultType, Value X) {\n-            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        RotaryEmbedding(TypeElement resultType, Value X, Value cos_cache, Value sin_cache, java.util.Optional<Value> position_ids, java.util.Optional<Long> num_heads, java.util.Optional<Long> rotary_embedding_dim, java.util.Optional<Long> interleaved) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X, cos_cache, sin_cache, position_ids), List.of(num_heads, rotary_embedding_dim, interleaved));\n@@ -23274,1 +23714,1 @@\n-            return onnxInputs(SCHEMA, List.of(X()));\n+            return onnxInputs(SCHEMA, List.of(X(), cos_cache(), sin_cache(), position_ids()));\n@@ -23281,0 +23721,28 @@\n+        public Value cos_cache() {\n+            return operands().get(1);\n+        }\n+\n+        public Value sin_cache() {\n+            return operands().get(2);\n+        }\n+\n+        public java.util.Optional<Value> position_ids() {\n+            int i = optionalInputArguments.indexOf(InputParameter.position_ids);\n+            return i != -1 ? java.util.Optional.of(operands().get(3 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<Long> num_heads() {\n+            Long num_heads = Attribute.num_heads.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(num_heads);\n+        }\n+\n+        public java.util.Optional<Long> rotary_embedding_dim() {\n+            Long rotary_embedding_dim = Attribute.rotary_embedding_dim.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(rotary_embedding_dim);\n+        }\n+\n+        public java.util.Optional<Long> interleaved() {\n+            Long interleaved = Attribute.interleaved.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(interleaved);\n+        }\n+\n@@ -23283,2 +23751,2 @@\n-    public static Round Round(TypeElement resultType, Value X) {\n-        return new Round(resultType, X);\n+    public static RotaryEmbedding RotaryEmbedding(TypeElement resultType, Value X, Value cos_cache, Value sin_cache, java.util.Optional<Value> position_ids, java.util.Optional<Long> num_heads, java.util.Optional<Long> rotary_embedding_dim, java.util.Optional<Long> interleaved) {\n+        return new RotaryEmbedding(resultType, X, cos_cache, sin_cache, position_ids, num_heads, rotary_embedding_dim, interleaved);\n@@ -23287,3 +23755,3 @@\n-    @OpFactoryHelper.OpDeclaration(STFT.NAME)\n-    public static final class STFT extends OnnxOp {\n-        public static final String NAME = \"STFT\";\n+    @OpFactoryHelper.OpDeclaration(Round.NAME)\n+    public static final class Round extends OnnxOp {\n+        public static final String NAME = \"Round\";\n@@ -23291,2 +23759,4 @@\n-        public enum Attribute implements OnnxAttribute {\n-            onesided(Long.class, true, 1),\n+        public enum Attribute implements OnnxAttribute.None { }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n@@ -23295,1 +23765,113 @@\n-                final Class<?> t;\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Round(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Round(Round that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Round transform(CopyContext cc, OpTransformer ot) {\n+            return new Round(this, cc);\n+        }\n+\n+        Round(TypeElement resultType, Value X) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of());\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+    }\n+\n+    public static Round Round(TypeElement resultType, Value X) {\n+        return new Round(resultType, X);\n+    }\n+\n+    @OpFactoryHelper.OpDeclaration(STFT.NAME)\n+    public static final class STFT extends OnnxOp {\n+        public static final String NAME = \"STFT\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            onesided(Long.class, true, 1),\n+            ;\n+\n+                final Class<?> t;\n@@ -25372,1 +25954,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -26104,1 +26686,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -27222,1 +27804,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128())))),\n@@ -27224,1 +27806,1 @@\n-            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n+            S(new OnnxType.TypeVariable(\"S\", List.of(OnnxType.seq(OnnxType.tensor(OnnxType.uint8())), OnnxType.seq(OnnxType.tensor(OnnxType.uint16())), OnnxType.seq(OnnxType.tensor(OnnxType.uint32())), OnnxType.seq(OnnxType.tensor(OnnxType.uint64())), OnnxType.seq(OnnxType.tensor(OnnxType.int8())), OnnxType.seq(OnnxType.tensor(OnnxType.int16())), OnnxType.seq(OnnxType.tensor(OnnxType.int32())), OnnxType.seq(OnnxType.tensor(OnnxType.int64())), OnnxType.seq(OnnxType.tensor(OnnxType.bfloat16())), OnnxType.seq(OnnxType.tensor(OnnxType.float16())), OnnxType.seq(OnnxType.tensor(OnnxType.float32())), OnnxType.seq(OnnxType.tensor(OnnxType.float64())), OnnxType.seq(OnnxType.tensor(OnnxType.string())), OnnxType.seq(OnnxType.tensor(OnnxType.bool())), OnnxType.seq(OnnxType.tensor(OnnxType.complex64())), OnnxType.seq(OnnxType.tensor(OnnxType.complex128()))))),\n@@ -27468,1 +28050,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -28235,0 +28817,145 @@\n+    @OpFactoryHelper.OpDeclaration(Swish.NAME)\n+    public static final class Swish extends OnnxOp {\n+        public static final String NAME = \"Swish\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            alpha(Float.class, true, 1.0f),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float64())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            X(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            Y(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public Swish(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        Swish(Swish that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Swish transform(CopyContext cc, OpTransformer ot) {\n+            return new Swish(this, cc);\n+        }\n+\n+        Swish(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+            super(SCHEMA, resultType, Set.of(), List.of(X), List.of(alpha));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(X()));\n+        }\n+\n+        public Value X() {\n+            return operands().get(0);\n+        }\n+\n+        public java.util.Optional<Float> alpha() {\n+            Float alpha = Attribute.alpha.access(Float.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(alpha);\n+        }\n+\n+    }\n+\n+    public static Swish Swish(TypeElement resultType, Value X, java.util.Optional<Float> alpha) {\n+        return new Swish(resultType, X, alpha);\n+    }\n+\n@@ -28463,0 +29190,162 @@\n+    @OpFactoryHelper.OpDeclaration(TensorScatter.NAME)\n+    public static final class TensorScatter extends OnnxOp {\n+        public static final String NAME = \"TensorScatter\";\n+\n+        public enum Attribute implements OnnxAttribute {\n+            mode(String.class, true, \"linear\"),\n+            axis(Long.class, true, -2),\n+            ;\n+\n+                final Class<?> t;\n+                final boolean optional;\n+                final Object defaultValue;\n+\n+                Attribute(Class<?> type, boolean optional, Object defaultValue) {\n+                    this.t = type;\n+                    this.optional = optional;\n+                    this.defaultValue = defaultValue;\n+                    assert optional || defaultValue == null;\n+                }\n+\n+                public Class<?> type() {\n+                    return t;\n+                }\n+\n+                public boolean isOptional() {\n+                    return optional;\n+                }\n+\n+                public Object defaultValue() {\n+                    return defaultValue;\n+                }\n+        }\n+\n+        public enum TypeConstraint implements OnnxTypeConstraint {\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n+            ;\n+\n+            final OnnxType.TypeVariable typeVariable;\n+\n+            TypeConstraint(OnnxType.TypeVariable typeVariable) {\n+                assert typeVariable.name().equals(name());\n+                this.typeVariable = typeVariable;\n+            }\n+\n+            @Override\n+            public OnnxType.TypeVariable typeVariable() {\n+                return typeVariable;\n+            }\n+        }\n+\n+        public enum InputParameter implements OnnxParameter {\n+            past_cache(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            update(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            write_indices(OnnxType.tensor(OnnxType.int64()), Quantifier.OPTIONAL),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            InputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public enum OutputParameter implements OnnxParameter {\n+            present_cache(TypeConstraint.T.typeVariable(), Quantifier.REQUIRED),\n+            ;\n+\n+            final OnnxType type;\n+            final Quantifier quantifier;\n+\n+            OutputParameter(OnnxType type, Quantifier quantifier) {\n+                this.type = type;\n+                this.quantifier = quantifier;\n+            }\n+\n+            @Override\n+            public OnnxType type() {\n+                return type;\n+            }\n+\n+            @Override\n+            public Quantifier quantifier() {\n+                return quantifier;\n+            }\n+        }\n+\n+        public static final OnnxSchema SCHEMA = new OnnxSchemaRecord(\n+                NAME,\n+                List.of(Attribute.values()),\n+                List.of(TypeConstraint.values()),\n+                List.of(InputParameter.values()),\n+                List.of(OutputParameter.values())\n+        );\n+\n+        public TensorScatter(ExternalizedOp def) {\n+            super(SCHEMA, def);\n+        }\n+\n+        TensorScatter(TensorScatter that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TensorScatter transform(CopyContext cc, OpTransformer ot) {\n+            return new TensorScatter(this, cc);\n+        }\n+\n+        TensorScatter(TypeElement resultType, Value past_cache, Value update, java.util.Optional<Value> write_indices, java.util.Optional<String> mode, java.util.Optional<Long> axis) {\n+            super(SCHEMA, resultType, Set.of(), List.of(past_cache, update, write_indices), List.of(mode, axis));\n+        }\n+\n+        @Override\n+        public SequencedSet<OnnxParameter> onnxOutputs() {\n+            return onnxOutputs(SCHEMA);\n+        }\n+\n+        @Override\n+        public SequencedMap<OnnxParameter, Object> onnxInputs() {\n+            return onnxInputs(SCHEMA, List.of(past_cache(), update(), write_indices()));\n+        }\n+\n+        public Value past_cache() {\n+            return operands().get(0);\n+        }\n+\n+        public Value update() {\n+            return operands().get(1);\n+        }\n+\n+        public java.util.Optional<Value> write_indices() {\n+            int i = optionalInputArguments.indexOf(InputParameter.write_indices);\n+            return i != -1 ? java.util.Optional.of(operands().get(2 + i)) : java.util.Optional.empty();\n+        }\n+\n+        public java.util.Optional<String> mode() {\n+            String mode = Attribute.mode.access(String.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(mode);\n+        }\n+\n+        public java.util.Optional<Long> axis() {\n+            Long axis = Attribute.axis.access(Long.class, onnxAttributes);\n+            return java.util.Optional.ofNullable(axis);\n+        }\n+\n+    }\n+\n+    public static TensorScatter TensorScatter(TypeElement resultType, Value past_cache, Value update, java.util.Optional<Value> write_indices, java.util.Optional<String> mode, java.util.Optional<Long> axis) {\n+        return new TensorScatter(resultType, past_cache, update, write_indices, mode, axis);\n+    }\n+\n@@ -28957,1 +29846,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.bfloat16())))),\n@@ -29119,1 +30008,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n@@ -30310,1 +31199,1 @@\n-            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1())))),\n+            T(new OnnxType.TypeVariable(\"T\", List.of(OnnxType.tensor(OnnxType.uint8()), OnnxType.tensor(OnnxType.uint16()), OnnxType.tensor(OnnxType.uint32()), OnnxType.tensor(OnnxType.uint64()), OnnxType.tensor(OnnxType.int8()), OnnxType.tensor(OnnxType.int16()), OnnxType.tensor(OnnxType.int32()), OnnxType.tensor(OnnxType.int64()), OnnxType.tensor(OnnxType.bfloat16()), OnnxType.tensor(OnnxType.float16()), OnnxType.tensor(OnnxType.float32()), OnnxType.tensor(OnnxType.float64()), OnnxType.tensor(OnnxType.string()), OnnxType.tensor(OnnxType.bool()), OnnxType.tensor(OnnxType.complex64()), OnnxType.tensor(OnnxType.complex128()), OnnxType.tensor(OnnxType.float8e4m3fn()), OnnxType.tensor(OnnxType.float8e4m3fnuz()), OnnxType.tensor(OnnxType.float8e5m2()), OnnxType.tensor(OnnxType.float8e5m2fnuz()), OnnxType.tensor(OnnxType.uint4()), OnnxType.tensor(OnnxType.int4()), OnnxType.tensor(OnnxType.float4e2m1()), OnnxType.tensor(OnnxType.float8e8m0())))),\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOps.java","additions":1009,"deletions":120,"binary":false,"changes":1129,"status":"modified"},{"patch":"@@ -612,0 +612,18 @@\n+\n+    public static final class Float8e8m0Type extends OnnxElementType {\n+        static final String NAME = \"float8e8m0\";\n+\n+        Float8e8m0Type() {\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of());\n+        }\n+\n+        @Override\n+        public int id() {\n+            return 23;\n+        }\n+    }\n+\n@@ -887,0 +905,1 @@\n+    public static final Float8e8m0Type FLOAT8E8M0 = new Float8e8m0Type();\n@@ -917,0 +936,1 @@\n+    public static final TensorType TENSOR_FLOAT8E8M0 = new TensorType(FLOAT8E8M0);\n@@ -951,0 +971,1 @@\n+    public static Float8e8m0Type float8e8m0() { return FLOAT8E8M0; }\n@@ -982,1 +1003,2 @@\n-            case Float8e5m2fnuzType float8e5m2fnuzType -> OnnxType.TENSOR_FLOAT8E5M2FNUZ;\n+            case Float8e5m2fnuzType t -> OnnxType.TENSOR_FLOAT8E5M2FNUZ;\n+            case Float8e8m0Type t -> OnnxType.TENSOR_FLOAT8E8M0;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -172,0 +172,84 @@\n+\n+        \/\/\/ Configuration of multi-device annotations.\n+        public NodeProto deviceConfigurations(NodeDeviceConfigurationProto deviceConfigurations) {return _f(10, deviceConfigurations);}\n+    }\n+\n+    \/\/\/ IntIntListEntryProto follows the pattern for cross-proto-version maps.\n+    \/\/\/ See https:\/\/developers.google.com\/protocol-buffers\/docs\/proto3#maps\n+    public static final class IntIntListEntryProto extends OnnxBuilder<IntIntListEntryProto> {\n+\n+        public IntIntListEntryProto key(long key) {return _f(1, key);}\n+\n+        public IntIntListEntryProto value(long... value) {return _f(2, value);}\n+    }\n+\n+    \/\/\/ Multi-device configuration proto for NodeProto.\n+    public static final class NodeDeviceConfigurationProto extends OnnxBuilder<NodeDeviceConfigurationProto> {\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ ID of the configuration. MUST match the name of a DeviceConfigurationProto.\n+        public NodeDeviceConfigurationProto configurationId(String configurationId) {return _f(1, configurationId);}\n+\n+        \/\/\/ Sharding spec for the node.\n+        public NodeDeviceConfigurationProto shardingSpec(ShardingSpecProto shardingSpec) {return _f(2, shardingSpec);}\n+\n+        \/\/\/ Pipeline stage of this node.\n+        public NodeDeviceConfigurationProto pipelineStage(int pipelineStage) {return _f(3, pipelineStage);}\n+    }\n+\n+    \/\/\/ ShardingSpecProto: This describes the sharding spec for a specific\n+    \/\/\/ input or output tensor of a node.\n+    public static final class ShardingSpecProto extends OnnxBuilder<ShardingSpecProto> {\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Identifies the input or output of the node that is being sharded.\n+        \/\/\/ Required to match a name specified in the node's input or output list of ValueInfoProtos.\n+        \/\/\/ It is called `logical tensor` in subsequent descriptions.\n+        public ShardingSpecProto tensorName(String tensorName) {return _f(1, tensorName);}\n+\n+        \/\/\/ The following is the list of devices across which the logical\n+        \/\/\/ tensor is sharded or replicated.\n+        public ShardingSpecProto device(long... device) {return _f(2, device);}\n+\n+        \/\/\/ Each element v in above field devices may represent either a\n+        \/\/\/ device or a set of devices (when we want the same shard\/tensor\n+        \/\/\/ to be replicated across a subset of devices), as indicated by\n+        \/\/\/ the following optional map. If the map contains an entry for v,\n+        \/\/\/ then v represents a device group, and the map indicates the set\n+        \/\/\/ of devices in that group.\n+        public ShardingSpecProto indexToDeviceGroupMap(IntIntListEntryProto indexToDeviceGroupMap) {return _f(3, indexToDeviceGroupMap);}\n+\n+        \/\/\/ The following is the sharded-shape of the tensor, consisting of\n+        \/\/\/ the sharding-spec for each axis of the tensor.\n+        public ShardingSpecProto shardedDim(ShardedDimProto shardedDim) {return _f(4, shardedDim);}\n+    }\n+\n+    \/\/\/ ShardedDimProto: This describes the sharding spec for a single\n+    \/\/\/ axis of a sharded tensor.\n+    public static final class ShardedDimProto extends OnnxBuilder<ShardedDimProto> {\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ The axis this sharding corresponds to. Must be in the range of\n+        \/\/\/ [-r, r - 1], where r is the rank of the tensor. Negative axis values means\n+        \/\/\/ counting from the back.\n+        public ShardedDimProto axis(long axis) {return _f(1, axis);}\n+\n+        \/\/\/ Describes how the tensor on the provided axis is sharded.\n+        \/\/\/ The common-case is described by a single instance of SimpleShardedDimProto.\n+        \/\/\/ Multiple instances can be used to handle cases where a sharded\n+        \/\/\/ tensor is reshaped, fusing multiple axes into one.\n+        public ShardedDimProto simpleSharding(SimpleShardedDimProto simpleSharding) {return _f(2, simpleSharding);}\n+    }\n+\n+    \/\/\/ SimpleShardedDimProto: Indicates that N blocks are divided into M shards.\n+    \/\/\/ N is allowed to be symbolic where M is required to be a constant.\n+    public static final class SimpleShardedDimProto extends OnnxBuilder<SimpleShardedDimProto> {\n+\n+        \/\/\/ Dimension value to be sharded.\n+        public SimpleShardedDimProto dimValue(long dimValue) {return _f(1, dimValue);}\n+\n+        public SimpleShardedDimProto dimParam(String dimParam) {return _f(2, dimParam);}\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Number of shards to split dim into.\n+        public SimpleShardedDimProto numShards(long numShards) {return _f(3, numShards);}\n@@ -360,1 +444,1 @@\n-        \/\/\/ or standard operator sets are given higher priotity or this is treated as error) is defined by\n+        \/\/\/ or standard operator sets are given higher priority or this is treated as error) is defined by\n@@ -373,0 +457,19 @@\n+\n+        \/\/\/ Describes different target configurations for a multi-device use case.\n+        \/\/\/ A model MAY describe multiple multi-device configurations for execution.\n+        public ModelProto configuration(DeviceConfigurationProto configuration) {return _f(26, configuration);}\n+    }\n+\n+    \/\/\/ DeviceConfigurationProto describes a multi-device configuration for a model.\n+    public static final class DeviceConfigurationProto extends OnnxBuilder<DeviceConfigurationProto> {\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Name of the configuration.\n+        public DeviceConfigurationProto name(String name) {return _f(1, name);}\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Number of devices inside this configuration.\n+        public DeviceConfigurationProto numDevices(int numDevices) {return _f(2, numDevices);}\n+\n+        \/\/\/ Optional names of the devices. MUST be length of num_devices if provided.\n+        public DeviceConfigurationProto device(String device) {return _f(3, device);}\n@@ -486,1 +589,1 @@\n-        \/\/\/ INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1\n+        \/\/\/ INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT8E8M0, FLOAT4E2M1\n@@ -560,1 +663,1 @@\n-        \/\/\/ The sequence of non-default values are encoded as a tensor of shape \\[NNZ].\n+        \/\/\/ The sequence of non-default values are encoded as a tensor of shape [NNZ].\n@@ -569,1 +672,1 @@\n-        \/\/\/ (b) Indices can be a tensor of shape \\[NNZ], in which case the i-th value\n+        \/\/\/ (b) Indices can be a tensor of shape [NNZ], in which case the i-th value\n@@ -633,1 +736,1 @@\n-            \/\/\/ This field MUST refer to an integral type (\\[U]INT{8|16|32|64}) or STRING\n+            \/\/\/ This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/proto\/OnnxBuilder.java","additions":108,"deletions":5,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        \/\/\/ - Add support to allow function body graph to rely on multiple external opreator sets.\n+        \/\/\/ - Add support to allow function body graph to rely on multiple external operator sets.\n@@ -103,1 +103,1 @@\n-        \/\/\/ Added UINT4, INT4.\n+        \/\/\/ Added UINT4, INT4, overload field for functions and metadata_props on multiple proto definitions.\n@@ -106,3 +106,7 @@\n-        \/\/\/ IR VERSION 11 published on TBD\n-        \/\/\/ Added FLOAT4E2M1.\n-        IR_VERSION(0x000000000000000B),\n+        \/\/\/ IR VERSION 11 published on May 12, 2025\n+        \/\/\/ Added FLOAT4E2M1, multi-device protobuf classes.\n+        IR_VERSION_2025_05_12(0x000000000000000B),\n+\n+        \/\/\/ IR VERSION 12 published on TBD\n+        \/\/\/ Added FLOAT8E8M0.\n+        IR_VERSION(0x000000000000000C),\n@@ -250,0 +254,4 @@\n+\n+        \/\/\/ E8M0 type used as the scale for microscaling (MX) formats:\n+        \/\/\/ https:\/\/www.opencompute.org\/documents\/ocp-microscaling-formats-mx-v1-0-spec-final-pdf\n+        FLOAT8E8M0(24),\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/proto\/OnnxConstants.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -182,1 +182,85 @@\n-        @f(9) List<StringStringEntryProto> metadataProps) implements OnnxModel {\n+        @f(9) List<StringStringEntryProto> metadataProps,\n+\n+        \/\/\/ Configuration of multi-device annotations.\n+        @f(10) List<NodeDeviceConfigurationProto> deviceConfigurations) implements OnnxModel {\n+    }\n+\n+    \/\/\/ IntIntListEntryProto follows the pattern for cross-proto-version maps.\n+    \/\/\/ See https:\/\/developers.google.com\/protocol-buffers\/docs\/proto3#maps\n+    public record IntIntListEntryProto (\n+\n+        @f(1) Long key,\n+\n+        @f(2) List<long[]> value) implements OnnxModel {\n+    }\n+\n+    \/\/\/ Multi-device configuration proto for NodeProto.\n+    public record NodeDeviceConfigurationProto (\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ ID of the configuration. MUST match the name of a DeviceConfigurationProto.\n+        @f(1) String configurationId,\n+\n+        \/\/\/ Sharding spec for the node.\n+        @f(2) List<ShardingSpecProto> shardingSpec,\n+\n+        \/\/\/ Pipeline stage of this node.\n+        @f(3) Integer pipelineStage) implements OnnxModel {\n+    }\n+\n+    \/\/\/ ShardingSpecProto: This describes the sharding spec for a specific\n+    \/\/\/ input or output tensor of a node.\n+    public record ShardingSpecProto (\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Identifies the input or output of the node that is being sharded.\n+        \/\/\/ Required to match a name specified in the node's input or output list of ValueInfoProtos.\n+        \/\/\/ It is called `logical tensor` in subsequent descriptions.\n+        @f(1) String tensorName,\n+\n+        \/\/\/ The following is the list of devices across which the logical\n+        \/\/\/ tensor is sharded or replicated.\n+        @f(2) List<long[]> device,\n+\n+        \/\/\/ Each element v in above field devices may represent either a\n+        \/\/\/ device or a set of devices (when we want the same shard\/tensor\n+        \/\/\/ to be replicated across a subset of devices), as indicated by\n+        \/\/\/ the following optional map. If the map contains an entry for v,\n+        \/\/\/ then v represents a device group, and the map indicates the set\n+        \/\/\/ of devices in that group.\n+        @f(3) List<IntIntListEntryProto> indexToDeviceGroupMap,\n+\n+        \/\/\/ The following is the sharded-shape of the tensor, consisting of\n+        \/\/\/ the sharding-spec for each axis of the tensor.\n+        @f(4) List<ShardedDimProto> shardedDim) implements OnnxModel {\n+    }\n+\n+    \/\/\/ ShardedDimProto: This describes the sharding spec for a single\n+    \/\/\/ axis of a sharded tensor.\n+    public record ShardedDimProto (\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ The axis this sharding corresponds to. Must be in the range of\n+        \/\/\/ [-r, r - 1], where r is the rank of the tensor. Negative axis values means\n+        \/\/\/ counting from the back.\n+        @f(1) Long axis,\n+\n+        \/\/\/ Describes how the tensor on the provided axis is sharded.\n+        \/\/\/ The common-case is described by a single instance of SimpleShardedDimProto.\n+        \/\/\/ Multiple instances can be used to handle cases where a sharded\n+        \/\/\/ tensor is reshaped, fusing multiple axes into one.\n+        @f(2) List<SimpleShardedDimProto> simpleSharding) implements OnnxModel {\n+    }\n+\n+    \/\/\/ SimpleShardedDimProto: Indicates that N blocks are divided into M shards.\n+    \/\/\/ N is allowed to be symbolic where M is required to be a constant.\n+    public record SimpleShardedDimProto (\n+\n+        \/\/\/ Dimension value to be sharded.\n+        @f(1) Long dimValue,\n+\n+        @f(2) String dimParam,\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Number of shards to split dim into.\n+        @f(3) Long numShards) implements OnnxModel {\n@@ -371,1 +455,1 @@\n-        \/\/\/ or standard operator sets are given higher priotity or this is treated as error) is defined by\n+        \/\/\/ or standard operator sets are given higher priority or this is treated as error) is defined by\n@@ -383,1 +467,20 @@\n-        @f(25) List<FunctionProto> functions) implements OnnxModel {\n+        @f(25) List<FunctionProto> functions,\n+\n+        \/\/\/ Describes different target configurations for a multi-device use case.\n+        \/\/\/ A model MAY describe multiple multi-device configurations for execution.\n+        @f(26) List<DeviceConfigurationProto> configuration) implements OnnxModel {\n+    }\n+\n+    \/\/\/ DeviceConfigurationProto describes a multi-device configuration for a model.\n+    public record DeviceConfigurationProto (\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Name of the configuration.\n+        @f(1) String name,\n+\n+        \/\/\/ This field MUST be present for this version of the IR.\n+        \/\/\/ Number of devices inside this configuration.\n+        @f(2) Integer numDevices,\n+\n+        \/\/\/ Optional names of the devices. MUST be length of num_devices if provided.\n+        @f(3) List<String> device) implements OnnxModel {\n@@ -487,1 +590,1 @@\n-        \/\/\/ INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT4E2M1\n+        \/\/\/ INT32, INT16, INT8, INT4, UINT16, UINT8, UINT4, BOOL, FLOAT16, BFLOAT16, FLOAT8E4M3FN, FLOAT8E4M3FNUZ, FLOAT8E5M2, FLOAT8E5M2FNUZ, FLOAT8E8M0, FLOAT4E2M1\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/proto\/OnnxModel.java","additions":107,"deletions":4,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.onnx.provider;\n-\n-import oracle.code.onnx.OnnxRuntime;\n-\n-import java.util.logging.Logger;\n-import java.util.logging.Level;\n-\n-import static oracle.code.onnx.foreign.coreml_provider_factory_h.*;\n-\n-public final class CoreMLProvider implements OnnxProvider {\n-    private static final Logger logger = Logger.getLogger(CoreMLProvider.class.getName());\n-\n-    private int flags;\n-\n-    public CoreMLProvider(int flags) {\n-        this.flags = flags;\n-    }\n-\n-    @Override\n-    public void configure(OnnxRuntime.SessionOptions sessionOptions) {\n-        var sessionOptionsAddress = sessionOptions.getSessionOptionsAddress();\n-\n-        try {\n-            var status = OrtSessionOptionsAppendExecutionProvider_CoreML(sessionOptionsAddress, flags);\n-\n-            if (status == null || status.address() == 0) {\n-                logger.info(\"CoreML execution provider enabled successfully!\");\n-            } else {\n-                logger.warning(\"CoreML EP returned status: \" + status.address());\n-\n-                status = OrtSessionOptionsAppendExecutionProvider_CoreML(\n-                        sessionOptionsAddress,\n-                        COREML_FLAG_USE_CPU_ONLY());\n-                if (status == null || status.address() == 0) {\n-                    logger.info(\"CoreML execution provider enabled with CPU_ONLY fallback!\");\n-                } else {\n-                    logger.severe(\"CoreML EP failed with all flags - \" + status.address());\n-                }\n-            }\n-        } catch (UnsatisfiedLinkError e) {\n-            logger.severe(\"CoreML execution provider is not available in the native ONNX Runtime library\");\n-            throw new RuntimeException(\"CoreML execution provider is not available in the native ONNX Runtime library (symbol missing).\", e);\n-        } catch (Throwable t) {\n-            logger.log(Level.SEVERE, \"Unexpected error while enabling CoreML EP: \" + t.getMessage(), t);\n-            throw new RuntimeException(\"Unexpected error while enabling CoreML EP: \" + t.getMessage(), t);\n-        }\n-    }\n-}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/provider\/CoreMLProvider.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package oracle.code.onnx.provider;\n-\n-import oracle.code.onnx.OnnxRuntime;\n-\n-public sealed interface OnnxProvider permits CoreMLProvider {\n-    void configure(OnnxRuntime.SessionOptions sessionOptions);\n-}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/provider\/OnnxProvider.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -110,1 +110,1 @@\n-        Tensor<Float> inputImage = Cast(ubyteImage, empty(), Tensor.ElementType.FLOAT.id);\n+        Tensor<Float> inputImage = Cast(ubyteImage, empty(), Tensor.ElementType.FLOAT.id, empty());\n@@ -189,1 +189,3 @@\n-                    OnnxType.TENSOR_FLOAT32.eType().id()));\n+                    OnnxType.TENSOR_FLOAT32.eType().id(),\n+                    empty()\n+            ));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,0 +51,48 @@\n+                    List.of(tensorInfo(\"a\", FLOAT.id), tensorInfo(\"b\", FLOAT.id)),\n+                    List.of(node(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n+                    List.of(\"y\")));\n+\n+            assertEquals(1, absOp.getNumberOfInputs());\n+            assertEquals(1, absOp.getNumberOfOutputs());\n+\n+            assertEquals(2, addOp.getNumberOfInputs());\n+            assertEquals(1, addOp.getNumberOfOutputs());\n+\n+            var inputTensor = Tensor.ofFlat(arena, -1f, 2, -3, 4, -5, 6);\n+\n+            var absExpectedTensor = Tensor.ofFlat(arena, 1f, 2, 3, 4, 5, 6);\n+\n+            var absResult = absOp.run(arena, List.of(inputTensor));\n+\n+            assertEquals(1, absResult.size());\n+\n+            var absOutputTensor = absResult.getFirst();\n+\n+            SimpleTest.assertEquals(absExpectedTensor, absOutputTensor);\n+\n+            var addResult = addOp.run(arena, List.of(inputTensor, absOutputTensor));\n+\n+            assertEquals(1, addResult.size());\n+\n+            var addOutputTensor = addResult.getFirst();\n+\n+            var addExpectedTensor = Tensor.ofFlat(arena, 0f, 4, 0, 8, 0, 12);\n+\n+            SimpleTest.assertEquals(addExpectedTensor, addOutputTensor);\n+        }\n+    }\n+\n+    @Test\n+    public void testExecutionProvider() throws Exception {\n+        var ort = OnnxRuntime.getInstance();\n+        try (Arena arena = Arena.ofConfined()) {\n+            var sessionOptions = ort.createSessionOptions(arena);\n+            ort.appendExecutionProvider_V2(arena, sessionOptions,  new OnnxProvider(\"WebGpuExecutionProvider\", null));\n+            var absOp = ort.createSession(arena, buildModel(\n+                    List.of(),\n+                    List.of(tensorInfo(\"x\", FLOAT.id)),\n+                    List.of(node(\"Abs\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n+                    List.of(\"y\")));\n+\n+            var addOp = ort.createSession(arena, buildModel(\n+                    List.of(),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        return Equal(CastLike(Slice(maze, pos, Add(pos, oneOne), empty(), empty()), wall, empty()), wall);\n+        return Equal(CastLike(Slice(maze, pos, Add(pos, oneOne), empty(), empty()), wall, empty(), empty()), wall);\n@@ -149,1 +149,1 @@\n-        return Concat(List.of(path, Cast(direction, empty(), 2)), 0);\n+        return Concat(List.of(path, Cast(direction, empty(), 2, empty())), 0);\n@@ -156,1 +156,1 @@\n-        var initData = new LoopData(homePos, directionEast, Cast(directionEast, empty(), 2));\n+        var initData = new LoopData(homePos, directionEast, Cast(directionEast, empty(), 2, empty()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import oracle.code.onnx.provider.CoreMLProvider;\n-\n@@ -42,0 +40,1 @@\n+import java.util.Map;\n@@ -46,1 +45,1 @@\n-import static oracle.code.onnx.foreign.coreml_provider_factory_h.*;\n+import oracle.code.onnx.OnnxProvider;\n@@ -68,1 +67,1 @@\n-    private FERCoreMLDemo(boolean useCondensedModel) throws IOException {\n+    private FERCoreMLDemo(boolean useCondensedModel) {\n@@ -201,1 +200,5 @@\n-                CoreMLProvider provider = new CoreMLProvider(COREML_FLAG_USE_CPU_AND_GPU());\n+                Map<String, String> options = Map.of(\"ModelFormat\", \"MLProgram\",\n+                        \"MLComputeUnits\", \"CPUAndGPU\", \"EnableOnSubgraphs\", \"1\",\n+                        \"AllowLowPrecisionAccumulationOnGPU\", \"1\",\n+                        \"ModelCacheDirectory\", FERCoreMLDemo.class.getResource(BASE_PATH).getPath());\n+                OnnxProvider provider = new OnnxProvider(\"CoreML\", options);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/fer\/FERCoreMLDemo.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import oracle.code.onnx.OnnxProvider;\n@@ -27,1 +28,0 @@\n-import oracle.code.onnx.provider.OnnxProvider;\n@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -38,0 +39,1 @@\n+import static oracle.code.onnx.foreign.onnxruntime_c_api_h.*;\n@@ -51,2 +53,3 @@\n-        if (Objects.nonNull(provider))\n-            provider.configure(sessionOptions);\n+        if (Objects.nonNull(provider)) {\n+            runtime.appendExecutionProvider(arena, sessionOptions, provider);\n+        }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/fer\/FERInference.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n-        Tensor<Integer> amSL = Cast(Sub(ReduceSum(attentionMask, of(flat1), empty(), empty()), flat1), empty(), OnnxType.INT32.id());\n-        Tensor<Integer> amTSL = Cast(Gather(Shape(attentionMask, empty(), empty()), scalar1, of(0l)), empty(), OnnxType.INT32.id());\n+        Tensor<Integer> amSL = Cast(Sub(ReduceSum(attentionMask, of(flat1), empty(), empty()), flat1), empty(), OnnxType.INT32.id(), empty());\n+        Tensor<Integer> amTSL = Cast(Gather(Shape(attentionMask, empty(), empty()), scalar1, of(0l)), empty(), OnnxType.INT32.id(), empty());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/llm\/LlamaModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}