{"files":[{"patch":"@@ -441,1 +441,1 @@\n-        return new Trxfmr(funcOp).transform(_->true,(block, op) -> {\n+        return Trxfmr.of(funcOp).transform(_->true,(block, op) -> {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-        var here = CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n@@ -136,2 +135,3 @@\n-            transformedFuncOp = new Trxfmr(computeMethod.funcOp()).transform(_->true,(bldr, op) -> {\n-                if (invokeOpHelper(lookup(),op) instanceof Invoke invoke ) {\n+            transformedFuncOp =Trxfmr.of(computeMethod.funcOp())\n+                    .transform(ce->ce instanceof JavaOp.InvokeOp ,(bldr, invokeOp) -> {\n+                var invoke = invokeOpHelper(lookup(),invokeOp);\n@@ -142,1 +142,1 @@\n-                        bldr.op(invoke.op());                                              \/\/ iface.v(newV);\n+                        bldr.op(invoke.op());                                           \/\/ iface.v(newV);\n@@ -144,8 +144,1 @@\n-                    } else if (invoke.isMappableIface()\n-                            && (\n-                                    invoke.returnsClassType()\n-                                            && classTypeToTypeOrThrow(lookup(), (ClassType)invoke.returnType()) instanceof Class<?> type\n-                                            && Buffer.class.isAssignableFrom(type)\n-                                ||\n-                                            invoke.returnsPrimitive()\n-                               )\n+                    } else if (invoke.isMappableIface() && ( invoke.returns(Buffer.class) || invoke.returnsPrimitive())\n@@ -156,1 +149,1 @@\n-                        bldr.op(invoke.op());                                             \/\/ iface.v();\n+                        bldr.op(invoke.op());                                           \/\/ iface.v();\n@@ -163,3 +156,0 @@\n-                          \/\/  System.out.println(\"Escape! with args \" +invokeOp.toText());\n-                            \/\/ We need to check\n-\n@@ -167,1 +157,0 @@\n-\n@@ -172,3 +161,1 @@\n-                                typeAndAccesses.add(TypeAndAccess.of(\n-                                        parameterAnnotations[i - (isVirtual ? 1 : 0)],\n-                                        list.get(i)));\n+                                typeAndAccesses.add(TypeAndAccess.of(parameterAnnotations[i - (isVirtual ? 1 : 0)], list.get(i)));\n@@ -200,4 +187,0 @@\n-                } else {\n-                    bldr.op(op);\n-                }\n-                return bldr;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            return new Trxfmr(funcOp).transform( (blockBuilder, op) -> {\n+            return Trxfmr.of(funcOp).transform( (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        return new Trxfmr(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n@@ -247,1 +247,1 @@\n-        return  new Trxfmr(funcOp).transform(ce->nodesInvolved.contains(ce),(blockBuilder, op) -> {\n+        return  Trxfmr.of(funcOp).transform(ce->nodesInvolved.contains(ce),(blockBuilder, op) -> {\n@@ -275,4 +275,2 @@\n-        return new Trxfmr(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n-            if (!reducedFloatsType.containsKey(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+        return Trxfmr.of(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -297,1 +295,1 @@\n-        return new Trxfmr(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        return new Trxfmr(funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n@@ -208,1 +208,1 @@\n-            return new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+            return Trxfmr.of(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        return new Trxfmr(funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n+        return Trxfmr.of(funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -43,0 +44,1 @@\n+import java.util.HashSet;\n@@ -241,24 +243,14 @@\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (invokeOpHelper(lookup(),result.op()) instanceof Invoke invoke) {\n-                                    if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)){\n-                                          \/\/  isVectorOperation(invokeOpHelper(lookup(),invokeOp))) {\n-                                        \/\/ Associate both ops to the vectorTypeInfo for easy\n-                                        \/\/ access to type and lanes\n-                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n-                                        vectorMetaData.put(invoke.op(), vectorTypeInfo);\n-                                        vectorMetaData.put(varOp, vectorTypeInfo);\n-                                        consumer.accept(invoke.op());\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+         funcOp.elements()\n+                 .filter(ce->ce instanceof CoreOp.VarOp)\n+                 .map(ce->(CoreOp.VarOp)ce)\n+                 .forEach(varOp-> varOp.operands().stream()\n+                      .filter(operand->operand instanceof Op.Result result && result.op() instanceof JavaOp.InvokeOp)\n+                      .map(operand->invokeOpHelper(lookup(),((Op.Result)operand).op()))\n+                      .filter(invoke ->  invoke.returns(_V.class) && invoke.named(vectorOperation.methodName))\n+                      .forEach(invoke -> {\n+                           \/\/ Associate both ops to the vectorTypeInfo for easy access to type and lanes\n+                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(), invoke.op());\n+                            vectorMetaData.put(invoke.op(), vectorTypeInfo);\n+                            vectorMetaData.put(varOp, vectorTypeInfo);\n+                      })\n+                );\n@@ -266,1 +258,1 @@\n-        return new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform(vectorMetaData::containsKey, (blockBuilder, op) -> {\n@@ -268,2 +260,0 @@\n-                Op.Result result = invokeOp.result();\n-                List<Op.Result> collect = result.uses().stream().toList();\n@@ -271,0 +261,1 @@\n+                List<Op.Result> collect = invokeOp.result().uses().stream().toList();\n@@ -305,1 +296,1 @@\n-        return new Trxfmr(funcOp).transform(_->true, (blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -346,1 +337,1 @@\n-        return new Trxfmr(funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -385,1 +376,1 @@\n-        funcOp = new Trxfmr(funcOp).transform(_->true, (blockBuilder, op) -> {\n+        funcOp = Trxfmr.of(funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -426,1 +417,1 @@\n-            funcOp = new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+            funcOp = Trxfmr.of(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":22,"deletions":31,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        return new Trxfmr(funcOp).transform(ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n+        return Trxfmr.of(funcOp).transform(ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-           return new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+           return Trxfmr.of(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import optkl.Trxfmr;\n@@ -43,0 +42,1 @@\n+import optkl.Trxfmr;\n@@ -155,1 +155,1 @@\n-                   \/\/ var arg = builder.parameters().getFirst();\n+                    \/\/ var arg = builder.parameters().getFirst();\n@@ -166,1 +166,1 @@\n-        System.out.println( OpCodeBuilder.toText(rsqrtFuncOp));\n+        System.out.println(OpCodeBuilder.toText(rsqrtFuncOp));\n@@ -168,32 +168,39 @@\n-        var trxfmr = new Trxfmr(rsqrtFuncOp);\n-        trxfmr.transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n-            c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n-                var lhs = b.op(CoreOp.constant(JavaType.BOOLEAN, false));\n-                var rhs = b.op(CoreOp.constant(JavaType.BOOLEAN, true));\n-                b.op(CoreOp.core_yield(b.op(JavaOp.or(lhs, rhs))));\n-            }).then(b -> {\n-                var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then\"));\n-                b.op(new Pre(List.of()));\n-                b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n-                b.op(new Post(List.of()));\n-                b.op(CoreOp.core_yield());\n-            }).else_(b -> {\n-                var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Else\"));\n-                b.op(new Pre(List.of()));\n-                b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n-                b.op(new Post(List.of()));\n-                b.op(CoreOp.core_yield());\n-            }));\n-             c.add(new Pre(List.of()));\n-             c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand(0)));\n-             c.add(new Post(List.of()));\n-        });\n-        System.out.println( OpCodeBuilder.toText(trxfmr.funcOp()));\n-\n-        \/\/ We need to remove our injected ops from the model to execute\n-        trxfmr.transform(ce -> ce instanceof Inject, c -> c.remove()).funcOp();\n-\n-        var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup,trxfmr.funcOp());\n-        System.out.println(javaCodeBuilder.toText());\n-        System.out.println( OpCodeBuilder.toText(trxfmr.funcOp()));\n-        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(lookup, trxfmr.funcOp()).invoke(100));\n+        Trxfmr.of(rsqrtFuncOp)\n+                .transform(ce -> ce instanceof JavaOp.InvokeOp, c -> {\n+                    c.add(JavaOp.if_(c.builder().parentBody()).if_(b -> {\n+                        var lhs = b.op(CoreOp.constant(JavaType.BOOLEAN, false));\n+                        var rhs = b.op(CoreOp.constant(JavaType.BOOLEAN, true));\n+                        b.op(CoreOp.core_yield(b.op(JavaOp.or(lhs, rhs))));\n+                    }).then(b -> {\n+                        var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Then\"));\n+                        b.op(new Pre(List.of()));\n+                        b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n+                        b.op(new Post(List.of()));\n+                        b.op(CoreOp.core_yield());\n+                    }).else_(b -> {\n+                        var msg = b.op(CoreOp.constant(JavaType.J_L_STRING, \"Else\"));\n+                        b.op(new Pre(List.of()));\n+                        b.op(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.VOID, Println, msg));\n+                        b.op(new Post(List.of()));\n+                        b.op(CoreOp.core_yield());\n+                    }));\n+                    c.add(new Pre(List.of()));\n+                    c.replace(JavaOp.invoke(InvokeKind.STATIC, false, JavaType.DOUBLE, MathAbs, c.mappedOperand(0)));\n+                    c.add(new Post(List.of()));\n+                })\n+                .toText()\n+                \/\/ We need to remove our injected ops from the model to execute\n+                .transform(ce -> ce instanceof Inject, c -> c.remove())\n+                .toText()\n+                .run(trxfmr -> {\n+                    var javaCodeBuilder = new JavaHATCodeBuilder<>(lookup, trxfmr.funcOp());\n+                    System.out.println(javaCodeBuilder.toText());\n+                    System.out.println(OpCodeBuilder.toText(trxfmr.funcOp()));\n+                    try {\n+                        System.out.println(\" 1\/abs(100) = \" + BytecodeGenerator.generate(lookup, trxfmr.funcOp()).invoke(100));\n+                    } catch (Throwable throwable) {\n+                        throw new RuntimeException(throwable);\n+                    }\n+                });\n+\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CreateFuncOp.java","additions":42,"deletions":35,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-import java.lang.reflect.Method;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.Trxfmr;\n-import optkl.util.CallSite;\n-\n-import java.util.List;\n-\n-\n-public class DNA {\n-    static int myFunc(int i) {\n-        return 0;\n-    }\n-\n-    @Reflect\n-    public static void addMul(int add, int mul) {\n-        int len = myFunc(add);\n-    }\n-\n-    public static class DNAOp extends Op { \/\/ externalized\n-        private final String opName;\n-        private final TypeElement type;\n-\n-        DNAOp(String opName, TypeElement type, List<Value> operands) {\n-            super(operands);\n-            this.opName = opName;\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public Op transform(CodeContext copyContext, CodeTransformer opTransformer) {\n-            throw new IllegalStateException(\"in transform\");\n-            \/\/  return null;\n-        }\n-\n-\n-        @Override\n-        public TypeElement resultType() {\n-            System.out.println(\"in result type\");\n-            return type;\n-        }\n-    }\n-\n-\n-    static public void main(String[] args) throws Exception {\n-        Method method = DNA.class.getDeclaredMethod(\"addMul\", int.class, int.class);\n-        var funcOp = Op.ofMethod(method).get();\n-        var here = CallSite.of(DNA.class, \"main\");\n-        var transformed = new Trxfmr(funcOp).transform(_->true,(builder, op) -> {\n-            CodeContext cc = builder.context();\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-               \/\/ List<Value> operands = new ArrayList<>();\n-                \/\/builder.op(new DNAOp(\"dna\", JavaType.INT, operands));\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = cc.getValues(inputOperands);\n-                Op.Result inputResult = invokeOp.result();\n-                Op.Result outputResult = builder.op(new DNAOp(\"dna\", JavaType.INT, outputOperands));\n-                cc.mapValue(inputResult, outputResult);\n-            } else {\n-                builder.op(op);\n-            }\n-            return builder;\n-        }).funcOp();\n-\n-\n-        System.out.println(transformed.toText());\n-\n-    }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package experiments;\n-\n-\n-import java.lang.reflect.Method;\n-\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.CodeTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import optkl.Trxfmr;\n-import optkl.util.CallSite;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-import static jdk.incubator.code.dialect.core.CoreType.FUNCTION_TYPE_VOID;\n-\n-public class Transform {\n-        @Reflect\n-        public static void removeMe(int size, int x, int y) {\n-\n-        }\n-\n-        @Reflect\n-        public static void matrixMultiply(float[] a, float[] b, float[] c, int size) {\n-            for (int i = 0; i < size; i++) {\n-                for (int j = 0; j < size; j++) {\n-                    float sum = 0f;\n-                    for (int k = 0; k < size; k++) {\n-                        sum += a[i * size + k] * b[k * size + j];\n-                    }\n-                    removeMe(1, 2, 3);\n-\n-                    c[i * size + j] = sum;\n-\n-                }\n-            }\n-        }\n-\n-        public static abstract class MyOp extends Op {\n-            private final String opName;\n-            private final TypeElement type;\n-\n-            MyOp(String opName) {\n-                super(List.of());\n-                this.opName = opName;\n-                this.type = FUNCTION_TYPE_VOID;\n-            }\n-\n-            MyOp(String opName, TypeElement type, List<Value> operands) {\n-                super(operands);\n-                this.opName = opName;\n-                this.type = type;\n-            }\n-\n-            MyOp(String opName, TypeElement type, List<Value> operands, Map<String, Object> attributes) {\n-                super(operands);\n-                this.opName = opName;\n-                this.type = type;\n-            }\n-\n-            MyOp(MyOp that, CodeContext cc) {\n-                super(that, cc);\n-                this.opName = that.opName;\n-                this.type = that.type;\n-            }\n-\n-            @Override\n-            public TypeElement resultType() {\n-                return type;\n-            }\n-        }\n-\n-\n-        public static class RootOp extends MyOp {\n-            public RootOp() {\n-                super(\"Root\");\n-            }\n-\n-            public RootOp(MyOp that, CodeContext cc) {\n-                super(that, cc);\n-            }\n-\n-            @Override\n-            public Op transform(CodeContext cc, CodeTransformer ot) {\n-                return new RootOp(this, cc);\n-            }\n-        }\n-\n-        public static void pre() {\n-        }\n-\n-        ;\n-\n-        public static void post() {\n-        }\n-\n-        ;\n-\n-        public static final MethodRef PRE = MethodRef.method(Transform.class, \"pre\", void.class);\n-        public static final MethodRef POST = MethodRef.method(Transform.class, \"post\", void.class);\n-\n-        static public void main(String[] args) throws Exception {\n-            String methodName = \"matrixMultiply\";\n-            Method method = Transform.class.getDeclaredMethod(methodName, float[].class, float[].class, float[].class, int.class);\n-\n-            CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n-\n-            var here = CallSite.of(Transform.class, \"main\");\n-            CoreOp.FuncOp transformed = new Trxfmr(javaFunc).transform(_->true,(builder, op) -> {\n-                if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    \/\/  CodeContext cc = builder.context();\n-                    \/\/  Block.Builder bb = builder;\n-                    \/\/ var invokePre = CoreOp.invoke(PRE);\n-                    RootOp rootOp = new RootOp();\n-                   \/\/ builder.body(op.bodies().getFirst(),List.of(), this);\n-                    builder.op(op);\n-                    \/\/ builder.op(rootOp);\n-                    \/\/  builder.op(invokeOp);\n-                    \/\/  builder.op(CoreOp.invoke(POST));\n-                } else {\n-                    builder.op(op);\n-                }\n-                return builder;\n-            }).funcOp();\n-\n-            System.out.println(transformed.toText());\n-\n-        }\n-}\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -36,0 +36,1 @@\n+import optkl.util.OpCodeBuilder;\n@@ -40,0 +41,1 @@\n+import java.util.function.Function;\n@@ -68,0 +70,4 @@\n+    public Trxfmr toText() {\n+         return run(trxfmr -> System.out.println(OpCodeBuilder.toText(trxfmr.funcOp())));\n+    }\n+\n@@ -264,1 +270,1 @@\n-    public Trxfmr(CoreOp.FuncOp funcOp) {\n+    private  Trxfmr(CoreOp.FuncOp funcOp) {\n@@ -266,1 +272,0 @@\n-\n@@ -269,0 +274,4 @@\n+    public Trxfmr run(Consumer<Trxfmr> action){\n+        action.accept(this);\n+        return this;\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}