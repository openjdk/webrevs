{"files":[{"patch":"@@ -244,1 +244,1 @@\n-        jdk.jshell;\n+        jdk.jshell, jdk.incubator.code;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,228 +0,0 @@\n-package jdk.incubator.code.internal;\n-\n-import com.sun.tools.javac.code.*;\n-import com.sun.tools.javac.code.Symbol.MethodSymbol;\n-import com.sun.tools.javac.code.Symbol.VarSymbol;\n-import com.sun.tools.javac.comp.AttrContext;\n-import com.sun.tools.javac.comp.Env;\n-import com.sun.tools.javac.comp.Resolve;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.JCExpression;\n-import com.sun.tools.javac.tree.TreeInfo;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.util.*;\n-import com.sun.tools.javac.util.List;\n-import jdk.incubator.code.*;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.java.*;\n-\n-import java.util.*;\n-\n-import static com.sun.tools.javac.code.Flags.*;\n-\n-public class CodeModelToAST {\n-    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n-            Op.Result.class, Op.class);\n-    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n-            Block.Parameter.class, TypeElement.class);\n-\n-    private final TreeMaker treeMaker;\n-    private final Names names;\n-    private final Symtab syms;\n-    private final Env<AttrContext> attrEnv;\n-    private final Resolve resolve;\n-    private final Types types;\n-    private final Map<Value, JCTree> valueToTree = new HashMap<>();\n-    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n-\n-    public CodeModelToAST(TreeMaker treeMaker, Names names, Symtab syms, Resolve resolve,\n-                          Types types, Env<AttrContext> attrEnv) {\n-        this.treeMaker = treeMaker;\n-        this.names = names;\n-        this.syms = syms;\n-        this.resolve = resolve;\n-        this.types = types;\n-        this.attrEnv = attrEnv;\n-    }\n-\n-    private Type typeElementToType(TypeElement jt) {\n-        return switch (jt) {\n-            case PrimitiveType pt when pt == JavaType.BOOLEAN -> syms.booleanType;\n-            case PrimitiveType pt when pt == JavaType.BYTE -> syms.byteType;\n-            case PrimitiveType pt when pt == JavaType.CHAR -> syms.charType;\n-            case PrimitiveType pt when pt == JavaType.INT -> syms.intType;\n-            case PrimitiveType pt when pt == JavaType.LONG -> syms.longType;\n-            case PrimitiveType pt when pt == JavaType.FLOAT -> syms.floatType;\n-            case PrimitiveType pt when pt == JavaType.DOUBLE -> syms.doubleType;\n-            case ClassType ct when ct.hasTypeArguments() -> {\n-                Type enclosing = ct.enclosingType().map(this::typeElementToType).orElse(Type.noType);\n-                List<Type> typeArgs = List.from(ct.typeArguments()).map(this::typeElementToType);\n-                yield new Type.ClassType(enclosing, typeArgs, typeElementToType(ct.rawType()).tsym);\n-            }\n-            case ClassType ct -> types.erasure(syms.enterClass(attrEnv.toplevel.modle, ct.toClassName()));\n-            case ArrayType at -> new Type.ArrayType(typeElementToType(at.componentType()), syms.arrayClass);\n-            default -> throw new IllegalStateException(\"Unsupported type: \" + jt);\n-        };\n-    }\n-\n-    private JCExpression toExpr(JCTree t) {\n-        return switch (t) {\n-            case JCExpression e -> e;\n-            case JCTree.JCVariableDecl vd -> treeMaker.Ident(vd);\n-            case null, default -> throw new IllegalArgumentException();\n-        };\n-    }\n-\n-    private JCTree invokeOpToJCMethodInvocation(JavaOp.InvokeOp invokeOp) {\n-        Value receiver = (invokeOp.invokeKind() == JavaOp.InvokeOp.InvokeKind.INSTANCE) ?\n-                invokeOp.operands().get(0) : null;\n-        List<Value> arguments = invokeOp.operands().stream()\n-                .skip(receiver == null ? 0 : 1)\n-                .collect(List.collector());\n-        var methodSym = methodDescriptorToSymbol(invokeOp.invokeDescriptor());\n-        var meth = (receiver == null) ?\n-                treeMaker.Ident(methodSym) :\n-                treeMaker.Select(toExpr(opToTree(receiver)), methodSym);\n-        var args = new ListBuffer<JCTree.JCExpression>();\n-        for (Value operand : arguments) {\n-            args.add(toExpr(opToTree(operand)));\n-        }\n-        var methodInvocation = treeMaker.App(meth, args.toList());\n-        if (invokeOp.isVarArgs()) {\n-            setVarargs(methodInvocation, invokeOp.invokeDescriptor().type());\n-        }\n-        return methodInvocation;\n-    }\n-\n-    void setVarargs(JCExpression tree, FunctionType type) {\n-        var lastParam = type.parameterTypes().getLast();\n-        if (lastParam instanceof ArrayType varargType) {\n-            TreeInfo.setVarargsElement(tree, typeElementToType(varargType.componentType()));\n-        } else {\n-            Assert.error(\"Expected trailing array type: \" + type);\n-        }\n-    }\n-\n-    public JCTree.JCStatement transformFuncOpToAST(CoreOp.FuncOp funcOp, MethodSymbol ms) {\n-        Assert.check(funcOp.parameters().isEmpty());\n-        Assert.check(funcOp.body().blocks().size() == 1);\n-\n-        java.util.List<Value> rootValues = funcOp.traverse(new ArrayList<>(), (l, ce) -> {\n-            boolean isRoot = switch (ce) {\n-                case JavaOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n-                        || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM) -> true;\n-                case CoreOp.ReturnOp _, JavaOp.ArrayAccessOp.ArrayStoreOp _ -> true;\n-                case Op op when op.result() != null && op.result().uses().size() > 1 -> true;\n-                default -> false;\n-            };\n-            if (isRoot) {\n-                l.add(((Op) ce).result());\n-            }\n-            return l;\n-        });\n-\n-        var stats = new ListBuffer<JCTree.JCStatement>();\n-        for (Value root : rootValues) {\n-            JCTree tree = opToTree(root);\n-            if (tree instanceof JCExpression e) {\n-                if (!root.uses().isEmpty()) {\n-                    var vs = new Symbol.VarSymbol(LocalVarFlags | SYNTHETIC, names.fromString(\"_$\" + localVarCount++), tree.type, ms);\n-                    tree = treeMaker.VarDef(vs, e);\n-                    valueToTree.put(root, tree);\n-                } else {\n-                    tree = treeMaker.Exec(e);\n-                }\n-            }\n-            stats.add((JCTree.JCStatement) tree);\n-        }\n-        var mb = treeMaker.Block(0, stats.toList());\n-\n-        return mb;\n-    }\n-\n-    private JCTree opToTree(Value v) {\n-        if (valueToTree.containsKey(v)) {\n-            return valueToTree.get(v);\n-        }\n-        Op op = ((Op.Result) v).op();\n-        JCTree tree = switch (op) {\n-            case CoreOp.ConstantOp constantOp when constantOp.value() == null ->\n-                    treeMaker.Literal(TypeTag.BOT, null).setType(syms.botType);\n-            case CoreOp.ConstantOp constantOp -> treeMaker.Literal(constantOp.value());\n-            case JavaOp.InvokeOp invokeOp -> invokeOpToJCMethodInvocation(invokeOp);\n-            case JavaOp.NewOp newOp when newOp.resultType() instanceof ArrayType at -> {\n-                var elemType = treeMaker.Ident(typeElementToType(at.componentType()).tsym);\n-                var dims = new ListBuffer<JCTree.JCExpression>();\n-                for (int d = 0; d < at.dimensions(); d++) {\n-                    dims.add(toExpr(opToTree(newOp.operands().get(d))));\n-                }\n-                var na = treeMaker.NewArray(elemType, dims.toList(), null);\n-                na.type = typeElementToType(at);\n-                yield na;\n-            }\n-            case JavaOp.NewOp newOp -> {\n-                var ownerType = typeElementToType(newOp.constructorDescriptor().refType());\n-                var clazz = treeMaker.Ident(ownerType.tsym);\n-                var args = new ListBuffer<JCTree.JCExpression>();\n-                for (Value operand : newOp.operands()) {\n-                    args.add(toExpr(opToTree(operand)));\n-                }\n-                var nc = treeMaker.NewClass(null, null, clazz, args.toList(), null);\n-                if (newOp.isVarargs()) {\n-                    setVarargs(nc, newOp.constructorDescriptor().type());\n-                }\n-                nc.type = ownerType;\n-                nc.constructor = constructorDescriptorToSymbol(newOp.constructorDescriptor());\n-                nc.constructorType = nc.constructor.type;\n-                yield nc;\n-            }\n-            case CoreOp.ReturnOp returnOp ->\n-                    treeMaker.Return(toExpr(opToTree(returnOp.returnValue())));\n-            case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n-                var sym = fieldDescriptorToSymbol(fieldLoadOp.fieldDescriptor());\n-                Assert.check(sym.isStatic());\n-                yield treeMaker.Select(treeMaker.Ident(sym.owner), sym);\n-            }\n-            case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n-                var array = arrayStoreOp.operands().get(0);\n-                var index = arrayStoreOp.operands().get(1);\n-                var val = arrayStoreOp.operands().get(2);\n-                var as = treeMaker.Assign(\n-                        treeMaker.Indexed(\n-                                toExpr(opToTree(array)), toExpr(opToTree(index))), toExpr(opToTree(val))\n-                );\n-                as.type = typeElementToType(((ArrayType) array.type()).componentType());\n-                yield as;\n-            }\n-            default -> throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n-        };\n-        valueToTree.put(v, tree);\n-        return tree;\n-    }\n-\n-    VarSymbol fieldDescriptorToSymbol(FieldRef fieldRef) {\n-        Name name = names.fromString(fieldRef.name());\n-        Type site = typeElementToType(fieldRef.refType());\n-        return resolve.resolveInternalField(attrEnv.enclClass, attrEnv, site, name);\n-    }\n-\n-    MethodSymbol methodDescriptorToSymbol(MethodRef methodRef) {\n-        Name name = names.fromString(methodRef.name());\n-        Type site = typeElementToType(methodRef.refType());\n-        List<Type> argtypes = methodRef.type().parameterTypes().stream()\n-                .map(this::typeElementToType).collect(List.collector());\n-        return resolve.resolveInternalMethod(attrEnv.enclClass, attrEnv, site, name, argtypes, List.nil());\n-    }\n-\n-    MethodSymbol constructorDescriptorToSymbol(ConstructorRef constructorRef) {\n-        Type site = typeElementToType(constructorRef.refType());\n-        List<Type> argtypes = constructorRef.type().parameterTypes().stream()\n-                .map(this::typeElementToType).collect(List.collector());\n-        return resolve.resolveInternalConstructor(attrEnv.enclClass, attrEnv, site, argtypes, List.nil());\n-    }\n-\n-    \/\/ TODO: generate AST in SSA form\n-    \/\/ TODO: drop addVarsWhenNecessary\n-    \/\/ TODO: maybe move back into ReflectMethods\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -42,0 +42,4 @@\n+\/**\n+ * This class (lazily) initialized the symbols in the jdk.incubator.code module,\n+ * whose symbol is not yet available when Symtab is first constructed.\n+ *\/\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import com.sun.tools.javac.code.Type.ClassType;\n@@ -40,2 +39,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n-import com.sun.tools.javac.code.Type.WildcardType;\n@@ -44,0 +41,1 @@\n+import com.sun.tools.javac.comp.AttrContext;\n@@ -46,0 +44,1 @@\n+import com.sun.tools.javac.comp.Env;\n@@ -79,0 +78,1 @@\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -83,1 +83,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Note;\n@@ -111,0 +110,2 @@\n+import static com.sun.tools.javac.resources.CompilerProperties.Notes.*;\n+\n@@ -140,1 +141,0 @@\n-    \/\/ @@@ Separate out mutable state\n@@ -143,1 +143,0 @@\n-    \/\/ Also used by BodyScanner\n@@ -168,29 +167,0 @@\n-    \/\/ Cannot compute within constructor due to circular dependencies on bootstrap compilation\n-    \/\/ syms.objectType == null\n-    private Map<JavaType, Type> primitiveAndBoxTypeMap;\n-    Map<JavaType, Type> primitiveAndBoxTypeMap() {\n-        Map<JavaType, Type> m = primitiveAndBoxTypeMap;\n-        if (m == null) {\n-            m = primitiveAndBoxTypeMap = Map.ofEntries(\n-                    Map.entry(JavaType.BOOLEAN, syms.booleanType),\n-                    Map.entry(JavaType.BYTE, syms.byteType),\n-                    Map.entry(JavaType.SHORT, syms.shortType),\n-                    Map.entry(JavaType.CHAR, syms.charType),\n-                    Map.entry(JavaType.INT, syms.intType),\n-                    Map.entry(JavaType.LONG, syms.longType),\n-                    Map.entry(JavaType.FLOAT, syms.floatType),\n-                    Map.entry(JavaType.DOUBLE, syms.doubleType),\n-                    Map.entry(JavaType.J_L_OBJECT, syms.objectType),\n-                    Map.entry(JavaType.J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n-                    Map.entry(JavaType.J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n-                    Map.entry(JavaType.J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n-                    Map.entry(JavaType.J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n-                    Map.entry(JavaType.J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n-                    Map.entry(JavaType.J_L_LONG, types.boxedTypeOrType(syms.longType)),\n-                    Map.entry(JavaType.J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n-                    Map.entry(JavaType.J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n-            );\n-        }\n-        return m;\n-    }\n-\n@@ -209,1 +179,1 @@\n-                classOps.add(opMethodDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n+                classOps.add(opMethodDecl(methodName(symbolToMethodRef(tree.sym)), funcOp, codeModelStorageOption));\n@@ -424,2 +394,2 @@\n-                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym));\n-                yield cmToASTTransformer.transformFuncOpToAST(opBuilder, ms);\n+                var codeModelTranslator = new CodeModelTranslator();\n+                yield codeModelTranslator.translateFuncOp(opBuilder, ms);\n@@ -436,2 +406,1 @@\n-        JCTree res = translate(cdef);\n-        return res;\n+        return translate(cdef);\n@@ -490,1 +459,1 @@\n-    class BodyScanner extends FilterScanner {\n+    class BodyScanner extends TreeScanner {\n@@ -501,29 +470,1 @@\n-        private Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n-\n-        \/\/ unsupported tree nodes\n-        private static final EnumSet<JCTree.Tag> UNSUPPORTED_TAGS = EnumSet.of(\n-                \/\/ the nodes below are not as relevant, either because they have already\n-                \/\/ been handled by an earlier compiler pass, or because they are typically\n-                \/\/ not handled directly, but in the context of some enclosing statement.\n-\n-                \/\/ modifiers (these are already turned into symbols by Attr and should not be dealt with directly)\n-                Tag.ANNOTATION, Tag.TYPE_ANNOTATION, Tag.MODIFIERS,\n-                \/\/ toplevel (likely outside the scope for code models)\n-                Tag.TOPLEVEL, Tag.PACKAGEDEF, Tag.IMPORT, Tag.METHODDEF,\n-                \/\/ modules (likely outside the scope for code models)\n-                Tag.MODULEDEF, Tag.EXPORTS, Tag.OPENS, Tag.PROVIDES, Tag.REQUIRES, Tag.USES,\n-                \/\/ classes, ignore local class definitions (allows access to but does not model the definition)\n-                \/\/ Tag.CLASSDEF,\n-                \/\/ switch labels (these are handled by the enclosing construct, SWITCH or SWITCH_EXPRESSION)\n-                Tag.CASE, Tag.DEFAULTCASELABEL, Tag.CONSTANTCASELABEL, Tag.PATTERNCASELABEL,\n-                \/\/ patterns (these are handled by the enclosing construct, like IF, SWITCH_EXPRESSION, TYPETEST)\n-                Tag.ANYPATTERN, Tag.BINDINGPATTERN, Tag.RECORDPATTERN,\n-                \/\/ catch (already handled as part of TRY)\n-                Tag.CATCH,\n-                \/\/ types (these are used to parse types and should not be dealt with directly)\n-                Tag.TYPEAPPLY, Tag.TYPEUNION, Tag.TYPEINTERSECTION, Tag.TYPEPARAMETER, Tag.WILDCARD,\n-                Tag.TYPEBOUNDKIND, Tag.ANNOTATED_TYPE,\n-                \/\/ internal (these are synthetic nodes generated by javac)\n-                Tag.NO_TAG, Tag.ERRONEOUS, Tag.NULLCHK, Tag.LETEXPR);\n-\n-        private static final Set<JCTree.Tag> SUPPORTED_TAGS = EnumSet.complementOf(UNSUPPORTED_TAGS);\n+        private final Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n@@ -536,2 +477,0 @@\n-            super(SUPPORTED_TAGS);\n-\n@@ -553,1 +492,1 @@\n-            tree.sym.type.getParameterTypes().stream().map(this::typeToTypeElement).forEach(parameters::add);\n+            tree.sym.type.getParameterTypes().stream().map(ReflectMethods.this::typeToTypeElement).forEach(parameters::add);\n@@ -572,2 +511,1 @@\n-            super(SUPPORTED_TAGS);\n-            assert kind != FunctionalExpressionKind.NOT_QUOTED;\n+            Assert.check(kind != FunctionalExpressionKind.NOT_QUOTED);\n@@ -598,1 +536,1 @@\n-                    mtype.getParameterTypes().map(this::typeToTypeElement));\n+                    mtype.getParameterTypes().map(ReflectMethods.this::typeToTypeElement));\n@@ -884,6 +822,0 @@\n-        @Override\n-        protected void skip(JCTree tree) {\n-            \/\/ this method is called for unsupported AST nodes (see 'SUPPORTED_TAGS')\n-            throw unsupported(tree);\n-        }\n-\n@@ -1133,3 +1065,2 @@\n-            return varOp.type() instanceof VarType ?\n-                    append(CoreOp.varLoad(varOp)) : \/\/ regular var\n-                    varOp;                          \/\/ captured value\n+            Assert.check(varOp.type() instanceof VarType);\n+            return append(CoreOp.varLoad(varOp));\n@@ -1227,1 +1158,1 @@\n-                    MethodRef mr = symbolToErasedMethodRef(sym, symbolSiteType(sym));\n+                    MethodRef mr = symbolToMethodRef(sym, symbolSiteType(sym));\n@@ -1258,1 +1189,1 @@\n-                    MethodRef mr = symbolToErasedMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n+                    MethodRef mr = symbolToMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n@@ -1489,1 +1420,1 @@\n-            MethodRef methodRef = symbolToErasedMethodRef(tree.constructor);\n+            MethodRef methodRef = symbolToMethodRef(tree.constructor);\n@@ -2570,116 +2501,0 @@\n-        JavaType symbolToErasedDesc(Symbol s) {\n-            return typeToTypeElement(s.erasure(types));\n-        }\n-\n-        JavaType typeToTypeElement(Type t) {\n-            t = normalizeType(t);\n-            return switch (t.getTag()) {\n-                case VOID -> JavaType.VOID;\n-                case CHAR -> JavaType.CHAR;\n-                case BOOLEAN -> JavaType.BOOLEAN;\n-                case BYTE -> JavaType.BYTE;\n-                case SHORT -> JavaType.SHORT;\n-                case INT -> JavaType.INT;\n-                case FLOAT -> JavaType.FLOAT;\n-                case LONG -> JavaType.LONG;\n-                case DOUBLE -> JavaType.DOUBLE;\n-                case ARRAY -> {\n-                    Type et = ((ArrayType)t).elemtype;\n-                    yield JavaType.array(typeToTypeElement(et));\n-                }\n-                case WILDCARD -> {\n-                    Type.WildcardType wt = (Type.WildcardType)t;\n-                    yield wt.isUnbound() ?\n-                            JavaType.wildcard() :\n-                            JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n-                }\n-                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n-                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n-                                typeToTypeElement(t.getUpperBound())) :\n-                        JavaType.typeVarRef(t.tsym.name.toString(),\n-                                (jdk.incubator.code.dialect.java.ClassType)symbolToErasedDesc(t.tsym.owner),\n-                                typeToTypeElement(t.getUpperBound()));\n-                case CLASS -> {\n-                    Assert.check(!t.isIntersection() && !t.isUnion());\n-                    JavaType typ;\n-                    if (t.getEnclosingType() != Type.noType) {\n-                        Name innerName = t.tsym.flatName().subName(t.getEnclosingType().tsym.flatName().length() + 1);\n-                        typ = JavaType.qualified(typeToTypeElement(t.getEnclosingType()), innerName.toString());\n-                    } else {\n-                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n-                    }\n-\n-                    List<JavaType> typeArguments;\n-                    if (t.getTypeArguments().nonEmpty()) {\n-                        typeArguments = new ArrayList<>();\n-                        for (Type ta : t.getTypeArguments()) {\n-                            typeArguments.add(typeToTypeElement(ta));\n-                        }\n-                    } else {\n-                        typeArguments = List.of();\n-                    }\n-\n-                    \/\/ Use flat name to ensure demarcation of nested classes\n-                    yield JavaType.parameterized(typ, typeArguments);\n-                }\n-                default -> {\n-                    throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n-                }\n-            };\n-        }\n-\n-        Type symbolSiteType(Symbol s) {\n-            boolean isMember = s.owner == syms.predefClass ||\n-                    s.isMemberOf(currentClassSym, types);\n-            return isMember ? currentClassSym.type : s.owner.type;\n-        }\n-\n-        FieldRef symbolToFieldRef(Symbol s, Type site) {\n-            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n-            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n-            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n-            return symbolToErasedFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n-        }\n-\n-        FieldRef symbolToErasedFieldRef(Symbol s) {\n-            Type erasedType = s.erasure(types);\n-            return FieldRef.field(\n-                    typeToTypeElement(s.owner.erasure(types)),\n-                    s.name.toString(),\n-                    typeToTypeElement(erasedType));\n-        }\n-\n-        MethodRef symbolToErasedMethodRef(Symbol s, Type site) {\n-            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n-            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n-            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n-            return symbolToErasedMethodRef(gen.binaryQualifier(s, types.erasure(site)));\n-        }\n-\n-        MethodRef symbolToErasedMethodRef(Symbol s) {\n-            Type erasedType = s.erasure(types);\n-            return MethodRef.method(\n-                    typeToTypeElement(s.owner.erasure(types)),\n-                    s.name.toString(),\n-                    typeToTypeElement(erasedType.getReturnType()),\n-                    erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n-        }\n-\n-        FunctionType symbolToFunctionType(Symbol s) {\n-            return typeToFunctionType(s.type);\n-        }\n-\n-        FunctionType typeToFunctionType(Type t) {\n-            return CoreType.functionType(\n-                    typeToTypeElement(t.getReturnType()),\n-                    t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n-        }\n-\n-        RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n-            TypeElement recordType = typeToTypeElement(s.type);\n-            List<RecordTypeRef.ComponentRef> components = s.getRecordComponents().stream()\n-                    .map(rc -> new RecordTypeRef.ComponentRef(typeToTypeElement(rc.type), rc.name.toString()))\n-                    .toList();\n-            return RecordTypeRef.recordType(recordType, components);\n-        }\n-\n@@ -2708,61 +2523,0 @@\n-\n-        Type normalizeType(Type t) {\n-            Assert.check(!t.hasTag(METHOD));\n-            return types.upward(t, false, types.captures(t));\n-        }\n-\n-        Type typeElementToType(TypeElement desc) {\n-            return primitiveAndBoxTypeMap().getOrDefault(desc, Type.noType);\n-        }\n-\n-        public boolean checkDenotableInTypeDesc(Type t) {\n-            return denotableChecker.visit(t, null);\n-        }\n-        \/\/ where\n-\n-        \/**\n-         * A type visitor that descends into the given type looking for types that are non-denotable\n-         * in code model types. Examples of such types are: type-variables (regular or captured),\n-         * wildcard type argument, intersection types, union types. The visit methods return false\n-         * as soon as a non-denotable type is encountered and true otherwise. (see {@link Check#checkDenotable(Type)}.\n-         *\/\n-        private static final Types.SimpleVisitor<Boolean, Void> denotableChecker = new Types.SimpleVisitor<>() {\n-            @Override\n-            public Boolean visitType(Type t, Void s) {\n-                return true;\n-            }\n-            @Override\n-            public Boolean visitClassType(ClassType t, Void s) {\n-                if (t.isUnion() || t.isIntersection()) {\n-                    \/\/ union and intersections cannot be denoted in code model types\n-                    return false;\n-                }\n-                \/\/ @@@ What about enclosing types?\n-                for (Type targ : t.getTypeArguments()) {\n-                    \/\/ propagate into type arguments\n-                    if (!visit(targ, s)) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-\n-            @Override\n-            public Boolean visitTypeVar(TypeVar t, Void s) {\n-                \/\/ type variables cannot be denoted in code model types\n-                return false;\n-            }\n-\n-            @Override\n-            public Boolean visitWildcardType(WildcardType t, Void s) {\n-                \/\/ wildcards cannot de denoted in code model types\n-                return false;\n-            }\n-\n-            @Override\n-            public Boolean visitArrayType(ArrayType t, Void s) {\n-                \/\/ propagate into element type\n-                return visit(t.elemtype, s);\n-            }\n-        };\n-\n@@ -2972,7 +2726,5 @@\n-    \/**\n-     * compiler.note.quoted.ir.dump=\\\n-     *    code reflection enabled for method quoted lambda\\n\\\n-     *    {0}\n-     *\/\n-    public static Note QuotedIrDump(String arg0) {\n-        return new Note(\"compiler\", \"quoted.ir.dump\", arg0);\n+    public static class Provider implements CodeReflectionTransformer {\n+        @Override\n+        public JCTree translateTopLevelClass(Context context, JCTree tree, TreeMaker make) {\n+            return ReflectMethods.instance(context).translateTopLevelClass(tree, make);\n+        }\n@@ -2982,2 +2734,2 @@\n-     * compiler.note.quoted.ir.skip=\\\n-     *    unsupported code reflection node {0} found in quoted lambda\n+     * Translate a code model (a function op) into the corresponding AST.\n+     * The input function op is assumed to be generated by {@code OpBuilder}.\n@@ -2985,2 +2737,143 @@\n-    public static Note QuotedIrSkip(String arg0) {\n-        return new Note(\"compiler\", \"quoted.ir.skip\", arg0);\n+    class CodeModelTranslator {\n+        private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+                Op.Result.class, Op.class);\n+        private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n+                Block.Parameter.class, TypeElement.class);\n+\n+        private final Map<Value, JCTree> valueToTree = new HashMap<>();\n+        private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n+\n+        private JCExpression toExpr(JCTree t) {\n+            return switch (t) {\n+                case JCExpression e -> e;\n+                case JCTree.JCVariableDecl vd -> make.Ident(vd);\n+                case null, default -> throw new IllegalArgumentException();\n+            };\n+        }\n+\n+        private JCTree translateInvokeOp(JavaOp.InvokeOp invokeOp) {\n+            Value receiver = (invokeOp.invokeKind() == JavaOp.InvokeOp.InvokeKind.INSTANCE) ?\n+                    invokeOp.operands().get(0) : null;\n+            com.sun.tools.javac.util.List<Value> arguments = invokeOp.operands().stream()\n+                    .skip(receiver == null ? 0 : 1)\n+                    .collect(com.sun.tools.javac.util.List.collector());\n+            var methodSym = methodDescriptorToSymbol(invokeOp.invokeDescriptor());\n+            var meth = (receiver == null) ?\n+                    make.Ident(methodSym) :\n+                    make.Select(toExpr(translateOp(receiver)), methodSym);\n+            var args = new ListBuffer<JCTree.JCExpression>();\n+            for (Value operand : arguments) {\n+                args.add(toExpr(translateOp(operand)));\n+            }\n+            var methodInvocation = make.App(meth, args.toList());\n+            if (invokeOp.isVarArgs()) {\n+                setVarargs(methodInvocation, invokeOp.invokeDescriptor().type());\n+            }\n+            return methodInvocation;\n+        }\n+\n+        private void setVarargs(JCExpression tree, FunctionType type) {\n+            var lastParam = type.parameterTypes().getLast();\n+            if (lastParam instanceof jdk.incubator.code.dialect.java.ArrayType varargType) {\n+                TreeInfo.setVarargsElement(tree, typeElementToType(varargType.componentType()));\n+            } else {\n+                Assert.error(\"Expected trailing array type: \" + type);\n+            }\n+        }\n+\n+        public JCTree.JCStatement translateFuncOp(CoreOp.FuncOp funcOp, MethodSymbol ms) {\n+            Assert.check(funcOp.parameters().isEmpty());\n+            Assert.check(funcOp.body().blocks().size() == 1);\n+\n+            java.util.List<Value> rootValues = funcOp.traverse(new ArrayList<>(), (l, ce) -> {\n+                boolean isRoot = switch (ce) {\n+                    case JavaOp.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n+                            || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM) -> true;\n+                    case CoreOp.ReturnOp _, JavaOp.ArrayAccessOp.ArrayStoreOp _ -> true;\n+                    case Op op when op.result() != null && op.result().uses().size() > 1 -> true;\n+                    default -> false;\n+                };\n+                if (isRoot) {\n+                    l.add(((Op) ce).result());\n+                }\n+                return l;\n+            });\n+\n+            var stats = new ListBuffer<JCTree.JCStatement>();\n+            for (Value root : rootValues) {\n+                JCTree tree = translateOp(root);\n+                if (tree instanceof JCExpression e) {\n+                    if (!root.uses().isEmpty()) {\n+                        var vs = new Symbol.VarSymbol(LocalVarFlags | SYNTHETIC, names.fromString(\"_$\" + localVarCount++), tree.type, ms);\n+                        tree = make.VarDef(vs, e);\n+                        valueToTree.put(root, tree);\n+                    } else {\n+                        tree = make.Exec(e);\n+                    }\n+                }\n+                stats.add((JCTree.JCStatement) tree);\n+            }\n+            var mb = make.Block(0, stats.toList());\n+\n+            return mb;\n+        }\n+\n+        private JCTree translateOp(Value v) {\n+            if (valueToTree.containsKey(v)) {\n+                return valueToTree.get(v);\n+            }\n+            Op op = ((Op.Result) v).op();\n+            JCTree tree = switch (op) {\n+                case CoreOp.ConstantOp constantOp when constantOp.value() == null ->\n+                        make.Literal(TypeTag.BOT, null).setType(syms.botType);\n+                case CoreOp.ConstantOp constantOp -> make.Literal(constantOp.value());\n+                case JavaOp.InvokeOp invokeOp -> translateInvokeOp(invokeOp);\n+                case JavaOp.NewOp newOp when newOp.resultType() instanceof jdk.incubator.code.dialect.java.ArrayType at -> {\n+                    var elemType = make.Ident(typeElementToType(at.componentType()).tsym);\n+                    var dims = new ListBuffer<JCTree.JCExpression>();\n+                    for (int d = 0; d < at.dimensions(); d++) {\n+                        dims.add(toExpr(translateOp(newOp.operands().get(d))));\n+                    }\n+                    var na = make.NewArray(elemType, dims.toList(), null);\n+                    na.type = typeElementToType(at);\n+                    yield na;\n+                }\n+                case JavaOp.NewOp newOp -> {\n+                    var ownerType = typeElementToType(newOp.constructorDescriptor().refType());\n+                    var clazz = make.Ident(ownerType.tsym);\n+                    var args = new ListBuffer<JCTree.JCExpression>();\n+                    for (Value operand : newOp.operands()) {\n+                        args.add(toExpr(translateOp(operand)));\n+                    }\n+                    var nc = make.NewClass(null, null, clazz, args.toList(), null);\n+                    if (newOp.isVarargs()) {\n+                        setVarargs(nc, newOp.constructorDescriptor().type());\n+                    }\n+                    nc.type = ownerType;\n+                    nc.constructor = constructorDescriptorToSymbol(newOp.constructorDescriptor());\n+                    nc.constructorType = nc.constructor.type;\n+                    yield nc;\n+                }\n+                case CoreOp.ReturnOp returnOp -> make.Return(toExpr(translateOp(returnOp.returnValue())));\n+                case JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp -> {\n+                    var sym = fieldDescriptorToSymbol(fieldLoadOp.fieldDescriptor());\n+                    Assert.check(sym.isStatic());\n+                    yield make.Select(make.Ident(sym.owner), sym);\n+                }\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+                    var array = arrayStoreOp.operands().get(0);\n+                    var index = arrayStoreOp.operands().get(1);\n+                    var val = arrayStoreOp.operands().get(2);\n+                    var as = make.Assign(\n+                            make.Indexed(\n+                                    toExpr(translateOp(array)), toExpr(translateOp(index))), toExpr(translateOp(val))\n+                    );\n+                    as.type = typeElementToType(((jdk.incubator.code.dialect.java.ArrayType) array.type()).componentType());\n+                    yield as;\n+                }\n+                default ->\n+                        throw new IllegalStateException(\"Op -> JCTree not supported for :\" + op.getClass().getName());\n+            };\n+            valueToTree.put(v, tree);\n+            return tree;\n+        }\n@@ -2989,7 +2882,4 @@\n-    \/**\n-     * compiler.note.method.ir.dump=\\\n-     *    code reflection enabled for method {0}.{1}\\n\\\n-     *    {2}\n-     *\/\n-    public static Note MethodIrDump(Symbol arg0, Symbol arg1, String arg2) {\n-        return new Note(\"compiler\", \"method.ir.dump\", arg0, arg1, arg2);\n+    \/\/ type and ref conversion utils\n+\n+    JavaType symbolToErasedDesc(Symbol s) {\n+        return typeToTypeElement(s.erasure(types));\n@@ -2998,6 +2888,54 @@\n-    \/**\n-     * compiler.note.method.ir.skip=\\\n-     *    unsupported code reflection node {2} found in method {0}.{1}\n-     *\/\n-    public static Note MethodIrSkip(Symbol arg0, Symbol arg1, String arg2) {\n-        return new Note(\"compiler\", \"method.ir.skip\", arg0, arg1, arg2);\n+    JavaType typeToTypeElement(Type t) {\n+        Assert.check(!t.hasTag(METHOD));\n+        t = types.upward(t, false, types.captures(t));\n+        return switch (t.getTag()) {\n+            case VOID -> JavaType.VOID;\n+            case CHAR -> JavaType.CHAR;\n+            case BOOLEAN -> JavaType.BOOLEAN;\n+            case BYTE -> JavaType.BYTE;\n+            case SHORT -> JavaType.SHORT;\n+            case INT -> JavaType.INT;\n+            case FLOAT -> JavaType.FLOAT;\n+            case LONG -> JavaType.LONG;\n+            case DOUBLE -> JavaType.DOUBLE;\n+            case ARRAY -> {\n+                Type et = ((ArrayType)t).elemtype;\n+                yield JavaType.array(typeToTypeElement(et));\n+            }\n+            case WILDCARD -> {\n+                Type.WildcardType wt = (Type.WildcardType)t;\n+                yield wt.isUnbound() ?\n+                        JavaType.wildcard() :\n+                        JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n+            }\n+            case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                    JavaType.typeVarRef(t.tsym.name.toString(), symbolToMethodRef(t.tsym.owner),\n+                            typeToTypeElement(t.getUpperBound())) :\n+                    JavaType.typeVarRef(t.tsym.name.toString(),\n+                            (jdk.incubator.code.dialect.java.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                            typeToTypeElement(t.getUpperBound()));\n+            case CLASS -> {\n+                Assert.check(!t.isIntersection() && !t.isUnion());\n+                JavaType typ;\n+                if (t.getEnclosingType() != Type.noType) {\n+                    Name innerName = t.tsym.flatName().subName(t.getEnclosingType().tsym.flatName().length() + 1);\n+                    typ = JavaType.qualified(typeToTypeElement(t.getEnclosingType()), innerName.toString());\n+                } else {\n+                    typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                }\n+\n+                List<JavaType> typeArguments;\n+                if (t.getTypeArguments().nonEmpty()) {\n+                    typeArguments = new ArrayList<>();\n+                    for (Type ta : t.getTypeArguments()) {\n+                        typeArguments.add(typeToTypeElement(ta));\n+                    }\n+                } else {\n+                    typeArguments = List.of();\n+                }\n+\n+                \/\/ Use flat name to ensure demarcation of nested classes\n+                yield JavaType.parameterized(typ, typeArguments);\n+            }\n+            default -> throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n+        };\n@@ -3006,5 +2944,95 @@\n-    public static class Provider implements CodeReflectionTransformer {\n-        @Override\n-        public JCTree translateTopLevelClass(Context context, JCTree tree, TreeMaker make) {\n-            return ReflectMethods.instance(context).translateTopLevelClass(tree, make);\n-        }\n+    Type typeElementToType(TypeElement jt) {\n+        return switch (jt) {\n+            case PrimitiveType pt when pt == JavaType.BOOLEAN -> syms.booleanType;\n+            case PrimitiveType pt when pt == JavaType.CHAR -> syms.charType;\n+            case PrimitiveType pt when pt == JavaType.BYTE -> syms.byteType;\n+            case PrimitiveType pt when pt == JavaType.SHORT -> syms.shortType;\n+            case PrimitiveType pt when pt == JavaType.INT -> syms.intType;\n+            case PrimitiveType pt when pt == JavaType.LONG -> syms.longType;\n+            case PrimitiveType pt when pt == JavaType.FLOAT -> syms.floatType;\n+            case PrimitiveType pt when pt == JavaType.DOUBLE -> syms.doubleType;\n+            case ClassType ct when ct.hasTypeArguments() -> {\n+                Type enclosing = ct.enclosingType().map(this::typeElementToType).orElse(Type.noType);\n+                com.sun.tools.javac.util.List<Type> typeArgs = com.sun.tools.javac.util.List.from(ct.typeArguments()).map(this::typeElementToType);\n+                yield new Type.ClassType(enclosing, typeArgs, typeElementToType(ct.rawType()).tsym);\n+            }\n+            case ClassType ct -> types.erasure(syms.enterClass(attrEnv().toplevel.modle, ct.toClassName()));\n+            case jdk.incubator.code.dialect.java.ArrayType at -> new Type.ArrayType(typeElementToType(at.componentType()), syms.arrayClass);\n+            default -> Type.noType;\n+        };\n+    }\n+\n+    Type symbolSiteType(Symbol s) {\n+        boolean isMember = s.owner == syms.predefClass ||\n+                s.isMemberOf(currentClassSym, types);\n+        return isMember ? currentClassSym.type : s.owner.type;\n+    }\n+\n+    FieldRef symbolToFieldRef(Symbol s, Type site) {\n+        \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+        \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+        \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+        return symbolFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n+    }\n+\n+    FieldRef symbolFieldRef(Symbol s) {\n+        Type erasedType = s.erasure(types);\n+        return FieldRef.field(\n+                typeToTypeElement(s.owner.erasure(types)),\n+                s.name.toString(),\n+                typeToTypeElement(erasedType));\n+    }\n+\n+    MethodRef symbolToMethodRef(Symbol s, Type site) {\n+        \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+        \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+        \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+        return symbolToMethodRef(gen.binaryQualifier(s, types.erasure(site)));\n+    }\n+\n+    MethodRef symbolToMethodRef(Symbol s) {\n+        Type erasedType = s.erasure(types);\n+        return MethodRef.method(\n+                typeToTypeElement(s.owner.erasure(types)),\n+                s.name.toString(),\n+                typeToTypeElement(erasedType.getReturnType()),\n+                erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+    }\n+\n+    FunctionType typeToFunctionType(Type t) {\n+        return CoreType.functionType(\n+                typeToTypeElement(t.getReturnType()),\n+                t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+    }\n+\n+    RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n+        TypeElement recordType = typeToTypeElement(s.type);\n+        List<RecordTypeRef.ComponentRef> components = s.getRecordComponents().stream()\n+                .map(rc -> new RecordTypeRef.ComponentRef(typeToTypeElement(rc.type), rc.name.toString()))\n+                .toList();\n+        return RecordTypeRef.recordType(recordType, components);\n+    }\n+\n+    Env<AttrContext> attrEnv() {\n+        return typeEnvs.get(currentClassSym);\n+    }\n+\n+    VarSymbol fieldDescriptorToSymbol(FieldRef fieldRef) {\n+        Name name = names.fromString(fieldRef.name());\n+        Type site = typeElementToType(fieldRef.refType());\n+        return resolve.resolveInternalField(attrEnv().enclClass, attrEnv(), site, name);\n+    }\n+\n+    MethodSymbol methodDescriptorToSymbol(MethodRef methodRef) {\n+        Name name = names.fromString(methodRef.name());\n+        Type site = typeElementToType(methodRef.refType());\n+        com.sun.tools.javac.util.List<Type> argtypes = methodRef.type().parameterTypes().stream()\n+                .map(this::typeElementToType).collect(com.sun.tools.javac.util.List.collector());\n+        return resolve.resolveInternalMethod(attrEnv().enclClass, attrEnv(), site, name, argtypes, com.sun.tools.javac.util.List.nil());\n+    }\n+\n+    MethodSymbol constructorDescriptorToSymbol(ConstructorRef constructorRef) {\n+        Type site = typeElementToType(constructorRef.refType());\n+        com.sun.tools.javac.util.List<Type> argtypes = constructorRef.type().parameterTypes().stream()\n+                .map(this::typeElementToType).collect(com.sun.tools.javac.util.List.collector());\n+        return resolve.resolveInternalConstructor(attrEnv().enclClass, attrEnv(), site, argtypes, com.sun.tools.javac.util.List.nil());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":322,"deletions":294,"binary":false,"changes":616,"status":"modified"}]}