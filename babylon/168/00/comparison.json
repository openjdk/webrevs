{"files":[{"patch":"@@ -1,126 +0,0 @@\n-package experiments;\n-\n-import hat.ComputeContext;\n-import hat.NDRange;\n-import hat.backend.Backend;\n-import hat.buffer.Buffer;\n-import hat.callgraph.KernelCallGraph;\n-import hat.callgraph.KernelEntrypoint;\n-import hat.ifacemapper.SegmentMapper;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.op.CoreOp;\n-\n-class DebugBackend implements Backend {\n-    @Override\n-    public void computeContextHandoff(ComputeContext computeContext) {\n-\n-    }\n-\n-    @Override\n-    public void dispatchCompute(ComputeContext computeContext, Object... args) {\n-        enum HowToRunCompute{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE}\n-        HowToRunCompute howToRun= HowToRunCompute.REFLECT;\n-\n-        switch (howToRun){\n-            case REFLECT: {\n-                try {\n-                    computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n-                } catch (IllegalAccessException | InvocationTargetException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                break;\n-            }\n-            case BABYLON_INTERPRETER:{\n-                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n-                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n-                }\n-                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op(), args);\n-                break;\n-            }\n-            case BABYLON_CLASSFILE:{\n-                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n-                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n-                }\n-                try {\n-                    if (computeContext.computeCallGraph.entrypoint.mh == null) {\n-                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op());\n-                    }\n-                    computeContext.computeCallGraph.entrypoint.mh.invokeWithArguments(args);\n-                } catch (Throwable e) {\n-                    computeContext.computeCallGraph.entrypoint.lowered.op().writeTo(System.out);\n-                    throw new RuntimeException(e);\n-                }\n-                break;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-        enum HowToRunKernel{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE, LOWER_TO_SSA}\n-        HowToRunKernel howToRun= HowToRunKernel.LOWER_TO_SSA;\n-        switch (howToRun){\n-            case REFLECT: {\n-                KernelEntrypoint kernelEntrypoint = kernelCallGraph.entrypoint;\n-                for (ndRange.kid.x = 0; ndRange.kid.x < ndRange.kid.maxX; ndRange.kid.x++) {\n-                    try {\n-                        args[0] = ndRange.kid;\n-                        kernelEntrypoint.method.invoke(null, args);\n-                    } catch (IllegalAccessException e) {\n-                        throw new RuntimeException(e);\n-                    } catch (InvocationTargetException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-                break;\n-            }\n-            case BABYLON_INTERPRETER:{\n-                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n-                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered.op(), args);\n-                break;\n-            }\n-            case BABYLON_CLASSFILE:{\n-                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n-                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered.op());\n-                try {\n-                    mh.invokeWithArguments(args);\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-                break;\n-            }\n-\n-            case LOWER_TO_SSA:{\n-                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n-                System.out.println(\"Initial code model\");\n-                System.out.println(highLevelForm.toText());\n-                System.out.println(\"------------------\");\n-\n-                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n-                System.out.println(\"Lowered form which maintains original invokes and args\");\n-                System.out.println(loweredForm.toText());\n-                System.out.println(\"-------------- ----\");\n-\n-                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n-                System.out.println(\"SSA form which maintains original invokes and args\");\n-                System.out.println(ssaInvokeForm.toText());\n-                System.out.println(\"------------------\");\n-\n-            }\n-        }\n-\n-\n-    }\n-\n-    @Override\n-    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper) {\n-        return segmentMapper.allocate(Arena.global());\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DebugBackend.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -0,0 +1,70 @@\n+package experiments;\n+\n+\n+import hat.HatPtr;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import  hat.HatPtr;\n+\n+public class InvokeToPtr {\n+\n+    @CodeReflection\n+    static float testMethod(PointyHat.ColoredWeightedPoint coloredWeightedPoint) {\n+        \/\/ StructOne* s1\n+        \/\/ s1 -> i\n+        int color = coloredWeightedPoint.color();\n+        \/\/ s1 -> *s2\n+        PointyHat.ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n+        \/\/ s2 -> i\n+        PointyHat.ColoredWeightedPoint.WeightedPoint.Point point = weightedPoint.point();\n+        color += point.x();\n+        coloredWeightedPoint.color(color);\n+        \/\/ s2 -> f\n+        float weight = weightedPoint.weight();\n+        return color + weight;\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        System.out.println(PointyHat.ColoredWeightedPoint.LAYOUT);\n+        System.out.println(PointyHat.ColoredWeightedPoint.schema.boundSchema().groupLayout);\n+        Optional<Method> om = Stream.of(InvokeToPtr.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(\"testMethod\"))\n+                .findFirst();\n+\n+        Method m = om.orElseThrow();\n+        CoreOp.FuncOp highLevelForm = m.getCodeModel().orElseThrow();\n+\n+        System.out.println(\"Initial code model\");\n+        System.out.println(highLevelForm.toText());\n+        System.out.println(\"------------------\");\n+\n+        CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        System.out.println(\"Lowered form which maintains original invokes and args\");\n+        System.out.println(loweredForm.toText());\n+        System.out.println(\"-------------- ----\");\n+\n+        CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+        System.out.println(\"SSA form which maintains original invokes and args\");\n+        System.out.println(ssaInvokeForm.toText());\n+        System.out.println(\"------------------\");\n+\n+        FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+        System.out.println(\"SSA form with types transformed args\");\n+        System.out.println(ssaInvokeForm.toText());\n+        System.out.println(\"------------------\");\n+\n+        CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+        System.out.println(\"SSA form with invokes replaced by ptrs\");\n+        System.out.println(ssaPtrForm.toText());\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/InvokeToPtr.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.backend.DebugBackend;\n@@ -36,0 +37,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -37,1 +39,0 @@\n-import java.lang.foreign.StructLayout;\n@@ -58,0 +59,1 @@\n+\n@@ -74,0 +76,1 @@\n+\n@@ -82,10 +85,10 @@\n-        static StructLayout getLayout() {\n-            return MemoryLayout.structLayout(\n-                    JAVA_INT.withName(\"points\"),\n-                    MemoryLayout.sequenceLayout(100,\n-                            MemoryLayout.structLayout(\n-                                    JAVA_INT.withName(\"x\"),\n-                                    JAVA_INT.withName(\"y\"),\n-                                    JAVA_INT.withName(\"z\")\n-                            ).withName(Point3D.class.getSimpleName())\n-                    ).withName(\"point\"),\n+\n+         GroupLayout LAYOUT = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"points\"),\n+                MemoryLayout.sequenceLayout(100,\n+                MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"x\"),\n+                JAVA_INT.withName(\"y\"),\n+                JAVA_INT.withName(\"z\")\n+                ).withName(Point3D.class.getSimpleName())\n+                ).withName(\"point\"),\n@@ -93,1 +96,1 @@\n-                    MemoryLayout.sequenceLayout(10,\n+                            MemoryLayout.sequenceLayout(10,\n@@ -95,2 +98,2 @@\n-                                    JAVA_INT.withName(\"from\"),\n-                                    JAVA_INT.withName(\"to\")\n+                            JAVA_INT.withName(\"from\"),\n+                            JAVA_INT.withName(\"to\")\n@@ -98,1 +101,1 @@\n-                    ).withName(\"vertex\")\n+                ).withName(\"vertex\")\n@@ -100,0 +103,3 @@\n+\n+        static GroupLayout getLayout() {\n+            return LAYOUT;\n@@ -133,1 +139,3 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend());\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),new DebugBackend(\n+                DebugBackend.HowToRunCompute.REFLECT,\n+                DebugBackend.HowToRunKernel.BABYLON_INTERPRETER));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+import hat.backend.DebugBackend;\n@@ -23,0 +24,2 @@\n+        interface WeightedPoint extends Buffer.StructChild {\n+            interface Point extends Buffer.StructChild {\n@@ -24,2 +27,1 @@\n-       public interface WeightedPoint extends Buffer.StructChild {\n-            int x();\n+                int x();\n@@ -27,1 +29,1 @@\n-            void x(int x);\n+                void x(int x);\n@@ -29,1 +31,1 @@\n-            int y();\n+                int y();\n@@ -31,1 +33,8 @@\n-            void y(int y);\n+                void y(int y);\n+\n+                GroupLayout LAYOUT = MemoryLayout.structLayout(\n+\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                );\n+            }\n@@ -37,0 +46,2 @@\n+            Point point();\n+\n@@ -39,2 +50,1 @@\n-                    ValueLayout.JAVA_INT.withName(\"x\"),\n-                    ValueLayout.JAVA_INT.withName(\"y\")\n+                    Point.LAYOUT.withName(\"point\")\n@@ -57,2 +67,6 @@\n-        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (cwp)-> cwp\n-                .field(\"weightedPoint\", (wp)-> wp.fields(\"weight\",\"x\",\"y\"))\n+        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (colouredWeightedPoint)-> colouredWeightedPoint\n+                .field(\"weightedPoint\", (weightedPoint)-> weightedPoint\n+                        .field(\"weight\", point->point\n+                                .field(\"x\")\n+                                .field(\"y\"))\n+                )\n@@ -82,1 +96,2 @@\n-            color += weightedPoint.x();\n+            ColoredWeightedPoint.WeightedPoint.Point point = weightedPoint.point();\n+            color += point.x();\n@@ -98,1 +113,4 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new PtrDebugBackend());\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new DebugBackend(\n+                DebugBackend.HowToRunCompute.REFLECT,\n+                DebugBackend.HowToRunKernel.LOWER_TO_SSA_AND_MAP_PTRS)\n+        );\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+package experiments;\n+\n+\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.Schema;\n+import hat.backend.DebugBackend;\n+import hat.buffer.BufferAllocator;\n+import hat.buffer.CompleteBuffer;\n+import hat.ifacemapper.HatData;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.runtime.CodeReflection;\n+\n+public class PointyHatArray {\n+    public interface PointArray extends CompleteBuffer {\n+        interface Point extends StructChild {\n+\n+            int x();\n+\n+            void x(int x);\n+\n+            int y();\n+\n+            void y(int y);\n+\n+            GroupLayout LAYOUT = MemoryLayout.structLayout(\n+\n+                    ValueLayout.JAVA_INT.withName(\"x\"),\n+                    ValueLayout.JAVA_INT.withName(\"y\")\n+            );\n+        }\n+\n+        int length();\n+\n+        void length(int length);\n+\n+        Point point(long idx);\n+\n+        GroupLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"length\"),\n+                MemoryLayout.sequenceLayout(100, Point.LAYOUT.withName(Point.class.getSimpleName())).withName(\"point\")\n+        ).withName(PointArray.class.getSimpleName());\n+\n+\n+        Schema<PointArray> schema = Schema.of(PointArray.class, (pointArray)-> pointArray\n+                .arrayLen(\"length\").array(\"point\", (point)-> point\n+\n+                                .field(\"x\")\n+                                .field(\"y\")\n+                )\n+        );\n+\n+        static PointArray create(BufferAllocator bufferAllocator, int len) {\n+            System.out.println(LAYOUT);\n+            System.out.println(schema.boundSchema(100).groupLayout);\n+            HatData hatData = new HatData() {\n+            };\n+            PointArray pointArray = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), PointArray.class, LAYOUT,hatData));\n+            pointArray.length(100);\n+            return pointArray;\n+        }\n+    }\n+\n+    static class Compute {\n+\n+\n+        @CodeReflection\n+        static void testMethodKernel(KernelContext kc, PointArray pointArray) {\n+\n+            int len = pointArray.length();\n+            PointArray.Point point = pointArray.point(4);\n+            point.x(1);\n+\n+\n+        }\n+\n+        @CodeReflection\n+        static void compute(ComputeContext cc, PointArray pointArray) {\n+            cc.dispatchKernel(1, kc -> Compute.testMethodKernel(kc, pointArray));\n+        }\n+\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), new DebugBackend(\n+                DebugBackend.HowToRunCompute.REFLECT,DebugBackend.HowToRunKernel.LOWER_TO_SSA_AND_MAP_PTRS));\n+        var pointArray = PointArray.create(accelerator,100);\n+        accelerator.compute(cc -> Compute.compute(cc, pointArray));\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -1,95 +0,0 @@\n-\n-\n-\n-    \/*\n-     * Copyright (c) 2024 Intel Corporation. All rights reserved.\n-     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-     *\n-     * This code is free software; you can redistribute it and\/or modify it\n-     * under the terms of the GNU General Public License version 2 only, as\n-     * published by the Free Software Foundation.  Oracle designates this\n-     * particular file as subject to the \"Classpath\" exception as provided\n-     * by Oracle in the LICENSE file that accompanied this code.\n-     *\n-     * This code is distributed in the hope that it will be useful, but WITHOUT\n-     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-     * version 2 for more details (a copy is included in the LICENSE file that\n-     * accompanied this code).\n-     *\n-     * You should have received a copy of the GNU General Public License version\n-     * 2 along with this work; if not, write to the Free Software Foundation,\n-     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-     *\n-     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-     * or visit www.oracle.com if you need additional information or have any\n-     * questions.\n-     *\/\n-\n-    package experiments;\n-\n-\n-    import hat.HatOps;\n-    import hat.buffer.KernelContext;\n-    import hat.buffer.S32Array;\n-    import hat.optools.FuncOpWrapper;\n-    import hat.optools.InvokeOpWrapper;\n-\n-    import java.lang.reflect.Method;\n-    import java.lang.runtime.CodeReflection;\n-    import java.util.List;\n-\n-    public class Ptr {\n-\n-\n-        @CodeReflection\n-        public static void mulAdd(KernelContext kernelContext, S32Array s32Array, int mul, int add) {\n-            s32Array.array(kernelContext.x(), s32Array.array(kernelContext.x()) * mul + add);\n-        }\n-\n-\n-        static public void main(String[] args) throws Exception {\n-            Method method = Ptr.class.getDeclaredMethod(\"mulAdd\", KernelContext.class, S32Array.class, int.class, int.class);\n-\n-            FuncOpWrapper funcOpWrapper = new FuncOpWrapper(method.getCodeModel().get());\n-            System.out.println(funcOpWrapper.toText());\n-\n-            \/*\n-            FuncOpWrapper transformedFuncOpWrapper1 = funcOpWrapper.findMapAndReplace(\n-                    (w)-> w instanceof InvokeOpWrapper invokeOpWrapper&& invokeOpWrapper.isIfaceBufferMethod(),  \/\/ Selector\n-                    (iw)-> (InvokeOpWrapper)iw,            \/\/ Mapper (so that wb.current() is type we want)\n-                    (wr) -> {\n-                if (wr.current().isIfaceBufferMethod()) {\n-                    if (wr.current().isIfaceAccessor()) {\n-                        if (wr.current().isKernelContextAccessor()) {\n-                           wr.replace(new HatOps.HatKernelContextOp(wr.current().name(),wr));\n-                        } else {\n-                            wr.replace(new HatOps.HatPtrLoadOp(wr));\n-                        }\n-                    } else {\n-                        wr.replace(new HatOps.HatPtrStoreOp(wr));\n-                    }\n-                }\n-            }); *\/\n-            FuncOpWrapper transformedFuncOpWrapper = funcOpWrapper.replace((wr) -> {\n-                        if (wr.current()  instanceof InvokeOpWrapper invokeOpWrapper&& invokeOpWrapper.isIfaceBufferMethod()) {\n-                            if (invokeOpWrapper.isIfaceAccessor()) {\n-                                if (invokeOpWrapper.isKernelContextAccessor()) {\n-                                    wr.replace(new HatOps.HatKernelContextOp(invokeOpWrapper.name(),wr));\n-                                } else {\n-                                    wr.replace(new HatOps.HatPtrLoadOp(wr));\n-                                }\n-                            } else {\n-                                wr.replace(new HatOps.HatPtrStoreOp(wr));\n-                            }\n-                        }\n-                    });\n-\n-            System.out.println(transformedFuncOpWrapper.toText());\n-            var loweredFuncOpWrapper = transformedFuncOpWrapper.lower();\n-            System.out.println(loweredFuncOpWrapper.toText());\n-            var ssa = loweredFuncOpWrapper.ssa();\n-            System.out.println(ssa.toText());\n-        }\n-    }\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Ptr.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,349 +0,0 @@\n-package experiments;\n-\n-import experiments.ifaceinvoketoptr.InvokeToPtr;\n-import hat.NDRange;\n-import hat.buffer.Buffer;\n-import hat.buffer.MappableIface;\n-import hat.callgraph.KernelCallGraph;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.OpWrapper;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import java.lang.constant.ClassDesc;\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.PrimitiveType;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-class PtrDebugBackend extends DebugBackend {\n-\n-    static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        try {\n-            return (typeElement instanceof JavaType jt\n-                    && jt.resolve(lookup) instanceof Class<?> possiblyMappableIface\n-                    && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        return getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz\n-                ? new PtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz))\n-                : typeElement;\n-    }\n-\n-\n-    static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        List<TypeElement> transformedTypeElements = new ArrayList<>();\n-        for (Block.Parameter parameter : funcOp.parameters()) {\n-            transformedTypeElements.add(convertToPtrTypeIfPossible(lookup, parameter.type()));\n-        }\n-        return FunctionType.functionType(convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType()), transformedTypeElements);\n-    }\n-\n-    static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n-                                                                          CoreOp.FuncOp ssaForm, FunctionType functionType) {\n-        return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n-            funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n-                \/*\n-                   We are looking for\n-                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                         T foo();\n-                         void foo(T foo);\n-                      }\n-                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n-                 *\/\n-\n-                if (op instanceof CoreOp.InvokeOp invokeOp\n-                        && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n-                        && invokeOpWrapper.hasOperands()\n-                        && invokeOpWrapper.isIfaceBufferMethod()\n-                        && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n-                        && getMappableClassOrNull(lookup, iface.type()) != null\n-                ) {\n-                    Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n-                    PtrOp<T> ptrOp = new PtrOp<>(ifaceValue, invokeOpWrapper.name());         \/\/ Create ptrOp to replace invokeOp\n-                    Op.Result ptrResult = builder.op(ptrOp);\/\/ replace and capture the result of the invoke\n-                    if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n-                        \/*\n-                          this turns into a load\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              T foo();\n-                          }\n-                         *\/\n-                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n-                            PtrLoadValue primitiveLoad = new PtrLoadValue(iface.type(), ptrResult);\n-                            Op.Result replacedReturnValue = builder.op(primitiveLoad);\n-                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                        } else {                                                 \/\/ pointing to another iface mappable\n-                            builder.context().mapValue(invokeOp.result(), ptrResult);\n-                        }\n-                    } else if (invokeOpWrapper.operandCount() == 2) {\n-                         \/*\n-                          This turns into a store\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              void foo(T);\n-                          }\n-                         *\/\n-                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n-                            Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n-                            PtrStoreValue primitiveStore = new PtrStoreValue(iface.type(), ptrResult, valueToStore);\n-                            Op.Result replacedReturnValue = builder.op(primitiveStore);\n-                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                        } else {                                                 \/\/ pointing to another iface mappable\n-                            builder.context().mapValue(invokeOp.result(), ptrResult);\n-                        }\n-                    } else {\n-                        builder.op(op);\n-                    }\n-                } else {\n-                    builder.op(op);\n-                }\n-                return builder; \/\/ why? oh why?\n-            });\n-        });\n-    }\n-\n-    static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n-        try {\n-            return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static final class PtrType<T extends MappableIface> implements TypeElement {\n-        static final String NAME = \"ptrType\";\n-        final Class<T> mappableIface;\n-        final MemoryLayout layout;\n-        final JavaType referringType;\n-\n-        public PtrType(Class<T> mappableIface, MemoryLayout layout) {\n-            this.mappableIface = mappableIface;\n-            this.layout = layout;\n-            this.referringType = switch (layout) {\n-                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n-                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n-                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            };\n-        }\n-\n-        public JavaType referringType() {\n-            return referringType;\n-        }\n-\n-        public MemoryLayout layout() {\n-            return layout;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            PtrType<T> ptrType = (PtrType<T>) o;\n-            return Objects.equals(layout, ptrType.layout);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(layout);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrOp.NAME)\n-    public static final class PtrOp<T extends MappableIface> extends ExternalizableOp {\n-        public static final String NAME = \"ptr.to.member\";\n-        public static final String ATTRIBUTE_OFFSET = \"offset\";\n-        final PtrType<T> ptrType;\n-        final PtrType<T> resultType;\n-        final String simpleMemberName;\n-        final long memberOffset;\n-\n-\n-        PtrOp(PtrOp<T> that, CopyContext cc) {\n-            super(that, cc);\n-            this.ptrType = that.ptrType;\n-            this.resultType = that.resultType;\n-            this.simpleMemberName = that.simpleMemberName;\n-            this.memberOffset = that.memberOffset;\n-\n-        }\n-\n-        @Override\n-        public PtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrOp<T>(this, cc);\n-        }\n-\n-        public PtrOp(Value ptr, String simpleMemberName) {\n-            super(NAME, List.of(ptr));\n-\n-            this.simpleMemberName = simpleMemberName;\n-            if (ptr.type() instanceof PtrType<?> ptrType) {\n-\n-                if (ptrType.layout() instanceof StructLayout structLayout) {\n-                    this.ptrType = (PtrType<T>) ptrType;\n-                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n-                    this.memberOffset = structLayout.byteOffset(memberPathElement);\n-                    MemoryLayout memberLayout = structLayout.select(memberPathElement);\n-                    \/\/ So we need a type for simpleMemberName ?\n-\n-\n-                    \/\/   Arrays.stream(ptrType.mappableIface.getDeclaredMethods()).forEach(m->{\n-\n-                    \/\/    System.out.println(simpleMemberName+\" \"+memberLayout.name() + \" \"+m.getName()+\" \"+m.getReturnType());\n-                    \/\/  });\n-                    this.resultType = new PtrType<>((Class<T>) ptrType.mappableIface, memberLayout);\n-                } else {\n-                    throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-        }\n-\n-\n-        @Override\n-        public PtrType<T> resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", simpleMemberName);\n-            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n-            return attrs;\n-        }\n-    }\n-\n-\n-    public static abstract class PtrAccessValue extends Op {\n-        final String name;\n-        final JavaType resultType;\n-        final TypeElement typeElement;\n-\n-        PtrAccessValue(String name, TypeElement typeElement, PtrAccessValue that, CopyContext cc) {\n-            super(that, cc);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = that.resultType;\n-        }\n-\n-        public PtrAccessValue(String name, TypeElement typeElement, JavaType resultType, List<Value> values) {\n-            super(name, values);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrLoadValue.NAME)\n-    public static final class PtrLoadValue extends PtrAccessValue {\n-        public static final String NAME = \"ptr.load.value\";\n-\n-        PtrLoadValue(TypeElement typeElement, PtrLoadValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-\n-        @Override\n-        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrLoadValue(typeElement, this, cc);\n-        }\n-\n-        public PtrLoadValue(TypeElement typeElement, Value ptr) {\n-            super(NAME, typeElement, ((PtrType<?>) ptr.type()).referringType(), List.of(ptr));\n-        }\n-\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrStoreValue.NAME)\n-    public static final class PtrStoreValue extends PtrAccessValue {\n-        public static final String NAME = \"ptr.store.value\";\n-\n-        PtrStoreValue(TypeElement typeElement, PtrStoreValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-\n-        @Override\n-        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrStoreValue(typeElement, this, cc);\n-        }\n-\n-        public PtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n-            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n-        }\n-    }\n-\n-\n-    @Override\n-    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n-\n-        var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n-        System.out.println(\"Initial code model\");\n-        System.out.println(highLevelForm.toText());\n-        System.out.println(\"------------------\");\n-        CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(\"Lowered form which maintains original invokes and args\");\n-        System.out.println(loweredForm.toText());\n-        System.out.println(\"-------------- ----\");\n-        \/\/ highLevelForm.lower();\n-        CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n-        System.out.println(\"SSA form which maintains original invokes and args\");\n-        System.out.println(ssaInvokeForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        FunctionType functionType = transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n-        System.out.println(\"SSA form with types transformed args\");\n-        System.out.println(ssaInvokeForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n-        System.out.println(\"SSA form with invokes replaced by ptrs\");\n-        System.out.println(ssaPtrForm.toText());\n-    }\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PtrDebugBackend.java","additions":0,"deletions":349,"binary":false,"changes":349,"status":"deleted"},{"patch":"@@ -1,403 +0,0 @@\n-package experiments.ifaceinvoketoptr;\n-\n-\n-import hat.Schema;\n-import hat.buffer.Buffer;\n-import hat.buffer.CompleteBuffer;\n-import hat.buffer.MappableIface;\n-import hat.optools.InvokeOpWrapper;\n-import hat.optools.OpWrapper;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.foreign.AddressLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.reflect.code.op.ExternalizableOp;\n-import java.lang.reflect.code.op.OpFactory;\n-import java.lang.reflect.code.type.FunctionType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.runtime.CodeReflection;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-public class InvokeToPtr {\n-    public interface ColoredWeightedPoint extends CompleteBuffer {\n-\n-        interface WeightedPoint extends Buffer.StructChild {\n-            int x();\n-\n-            void x(int x);\n-\n-            int y();\n-\n-            void y(int y);\n-\n-            float weight();\n-\n-            void weight(float weight);\n-\n-            MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                    ValueLayout.JAVA_FLOAT.withName(\"weight\"),\n-                    ValueLayout.JAVA_INT.withName(\"x\"),\n-                    ValueLayout.JAVA_INT.withName(\"y\")\n-            );\n-        }\n-\n-        WeightedPoint weightedPoint();\n-\n-        int color();\n-\n-        void color(int color);\n-\n-        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n-                WeightedPoint.LAYOUT.withName(\"weightedPoint\"),\n-                ValueLayout.JAVA_INT.withName(\"color\")\n-        ).withName(ColoredWeightedPoint.class.getSimpleName());\n-\n-        Schema<ColoredWeightedPoint> schema = Schema.of(ColoredWeightedPoint.class, (cwp) -> cwp\n-                .field(\"weightedPoint\", (wp) -> wp.fields(\"weight\", \"x\", \"y\"))\n-                .field(\"color\")\n-        );\n-    }\n-\n-    @CodeReflection\n-    static float testMethod(ColoredWeightedPoint coloredWeightedPoint) {\n-        \/\/ StructOne* s1\n-        \/\/ s1 -> i\n-        int color = coloredWeightedPoint.color();\n-        \/\/ s1 -> *s2\n-        ColoredWeightedPoint.WeightedPoint weightedPoint = coloredWeightedPoint.weightedPoint();\n-        \/\/ s2 -> i\n-        color += weightedPoint.x();\n-        coloredWeightedPoint.color(color);\n-        \/\/ s2 -> f\n-        float weight = weightedPoint.weight();\n-        return color + weight;\n-    }\n-\n-\n-    public static void main(String[] args) {\n-        System.out.println(ColoredWeightedPoint.LAYOUT);\n-        System.out.println(ColoredWeightedPoint.schema.boundSchema().groupLayout);\n-        Optional<Method> om = Stream.of(InvokeToPtr.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(\"testMethod\"))\n-                .findFirst();\n-\n-        Method m = om.orElseThrow();\n-        CoreOp.FuncOp highLevelForm = m.getCodeModel().orElseThrow();\n-\n-        System.out.println(\"Initial code model\");\n-        System.out.println(highLevelForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n-        System.out.println(\"Lowered form which maintains original invokes and args\");\n-        System.out.println(loweredForm.toText());\n-        System.out.println(\"-------------- ----\");\n-\n-        CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n-        System.out.println(\"SSA form which maintains original invokes and args\");\n-        System.out.println(ssaInvokeForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        FunctionType functionType = transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n-        System.out.println(\"SSA form with types transformed args\");\n-        System.out.println(ssaInvokeForm.toText());\n-        System.out.println(\"------------------\");\n-\n-        CoreOp.FuncOp ssaPtrForm = transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n-        System.out.println(\"SSA form with invokes replaced by ptrs\");\n-        System.out.println(ssaPtrForm.toText());\n-    }\n-\n-    static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        try {\n-            return (typeElement instanceof JavaType jt\n-                    && jt.resolve(lookup) instanceof Class<?> possiblyMappableIface\n-                    && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        return getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz\n-                ? new PtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz))\n-                : typeElement;\n-    }\n-\n-\n-    static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        List<TypeElement> transformedTypeElements = new ArrayList<>();\n-        for (Block.Parameter parameter : funcOp.parameters()) {\n-            transformedTypeElements.add(convertToPtrTypeIfPossible(lookup, parameter.type()));\n-        }\n-        return FunctionType.functionType(convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType()), transformedTypeElements);\n-    }\n-\n-    static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n-                                                                          CoreOp.FuncOp ssaForm, FunctionType functionType) {\n-        return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n-            funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n-                \/*\n-                   We are looking for\n-                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                         T foo();\n-                         void foo(T foo);\n-                      }\n-                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n-                 *\/\n-\n-                if (op instanceof CoreOp.InvokeOp invokeOp\n-                        && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n-                        && invokeOpWrapper.hasOperands()\n-                        && invokeOpWrapper.isIfaceBufferMethod()\n-                        && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n-                        && getMappableClassOrNull(lookup, iface.type()) != null\n-                ) {\n-                    Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n-                    PtrOp<T> ptrOp = new PtrOp<>(ifaceValue, invokeOpWrapper.name());         \/\/ Create ptrOp to replace invokeOp\n-                    Op.Result ptrResult = builder.op(ptrOp);\/\/ replace and capture the result of the invoke\n-                    if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n-                        \/*\n-                          this turns into a load\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              T foo();\n-                          }\n-                         *\/\n-                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n-                            PtrLoadValue primitiveLoad = new PtrLoadValue(iface.type(), ptrResult);\n-                            Op.Result replacedReturnValue = builder.op(primitiveLoad);\n-                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                        } else {                                                 \/\/ pointing to another iface mappable\n-                            builder.context().mapValue(invokeOp.result(), ptrResult);\n-                        }\n-                    } else if (invokeOpWrapper.operandCount() == 2) {\n-                         \/*\n-                          This turns into a store\n-                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n-                              void foo(T);\n-                          }\n-                         *\/\n-                        if (ptrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n-                            Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n-                            PtrStoreValue primitiveStore = new PtrStoreValue(iface.type(), ptrResult, valueToStore);\n-                            Op.Result replacedReturnValue = builder.op(primitiveStore);\n-                            builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n-                        } else {                                                 \/\/ pointing to another iface mappable\n-                            builder.context().mapValue(invokeOp.result(), ptrResult);\n-                        }\n-                    } else {\n-                        builder.op(op);\n-                    }\n-                } else {\n-                    builder.op(op);\n-                }\n-                return builder; \/\/ why? oh why?\n-            });\n-        });\n-    }\n-\n-    static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n-        try {\n-            return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static final class PtrType<T extends MappableIface> implements TypeElement {\n-        static final String NAME = \"ptrType\";\n-        final Class<T> mappableIface;\n-        final MemoryLayout layout;\n-        final JavaType referringType;\n-\n-        public PtrType(Class<T> mappableIface, MemoryLayout layout) {\n-            this.mappableIface = mappableIface;\n-            this.layout = layout;\n-            this.referringType = switch (layout) {\n-                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n-                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n-                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n-            };\n-        }\n-\n-        public JavaType referringType() {\n-            return referringType;\n-        }\n-\n-        public MemoryLayout layout() {\n-            return layout;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            PtrType<T> ptrType = (PtrType<T>) o;\n-            return Objects.equals(layout, ptrType.layout);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(layout);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrOp.NAME)\n-    public static final class PtrOp<T extends MappableIface> extends ExternalizableOp {\n-        public static final String NAME = \"ptr.to.member\";\n-        public static final String ATTRIBUTE_OFFSET = \"offset\";\n-        final PtrType<T> ptrType;\n-        final PtrType<T> resultType;\n-        final String simpleMemberName;\n-        final long memberOffset;\n-\n-\n-        PtrOp(PtrOp<T> that, CopyContext cc) {\n-            super(that, cc);\n-            this.ptrType = that.ptrType;\n-            this.resultType = that.resultType;\n-            this.simpleMemberName = that.simpleMemberName;\n-            this.memberOffset = that.memberOffset;\n-\n-        }\n-\n-        @Override\n-        public PtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrOp<T>(this, cc);\n-        }\n-\n-        public PtrOp(Value ptr, String simpleMemberName) {\n-            super(NAME, List.of(ptr));\n-\n-            this.simpleMemberName = simpleMemberName;\n-            if (ptr.type() instanceof PtrType<?> ptrType) {\n-\n-                if (ptrType.layout() instanceof StructLayout structLayout) {\n-                    this.ptrType = (PtrType<T>) ptrType;\n-                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n-                    this.memberOffset = structLayout.byteOffset(memberPathElement);\n-                    MemoryLayout memberLayout = structLayout.select(memberPathElement);\n-                    \/\/ So we need a type for simpleMemberName ?\n-\n-\n-                    \/\/   Arrays.stream(ptrType.mappableIface.getDeclaredMethods()).forEach(m->{\n-\n-                    \/\/    System.out.println(simpleMemberName+\" \"+memberLayout.name() + \" \"+m.getName()+\" \"+m.getReturnType());\n-                    \/\/  });\n-                    this.resultType = new PtrType<>((Class<T>) ptrType.mappableIface, memberLayout);\n-                } else {\n-                    throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n-                }\n-            } else {\n-                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n-            }\n-        }\n-\n-\n-        @Override\n-        public PtrType<T> resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", simpleMemberName);\n-            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n-            return attrs;\n-        }\n-    }\n-\n-\n-    public static abstract class PtrAccessValue extends Op {\n-        final String name;\n-        final JavaType resultType;\n-        final TypeElement typeElement;\n-\n-        PtrAccessValue(String name, TypeElement typeElement, PtrAccessValue that, CopyContext cc) {\n-            super(that, cc);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = that.resultType;\n-        }\n-\n-        public PtrAccessValue(String name, TypeElement typeElement, JavaType resultType, List<Value> values) {\n-            super(name, values);\n-            this.name = name;\n-            this.typeElement = typeElement;\n-            this.resultType = resultType;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrLoadValue.NAME)\n-    public static final class PtrLoadValue extends PtrAccessValue {\n-        public static final String NAME = \"ptr.load.value\";\n-\n-        PtrLoadValue(TypeElement typeElement, PtrLoadValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-\n-        @Override\n-        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrLoadValue(typeElement, this, cc);\n-        }\n-\n-        public PtrLoadValue(TypeElement typeElement, Value ptr) {\n-            super(NAME, typeElement, ((PtrType<?>) ptr.type()).referringType(), List.of(ptr));\n-        }\n-\n-    }\n-\n-    @OpFactory.OpDeclaration(PtrStoreValue.NAME)\n-    public static final class PtrStoreValue extends PtrAccessValue {\n-        public static final String NAME = \"ptr.store.value\";\n-\n-        PtrStoreValue(TypeElement typeElement, PtrStoreValue that, CopyContext cc) {\n-            super(NAME, typeElement, that, cc);\n-        }\n-\n-        @Override\n-        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n-            return new PtrStoreValue(typeElement, this, cc);\n-        }\n-\n-        public PtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n-            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n-        }\n-    }\n-\n-}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ifaceinvoketoptr\/InvokeToPtr.java","additions":0,"deletions":403,"binary":false,"changes":403,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-package hat;\n-\n-import hat.optools.FuncOpWrapper;\n-\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.OpTransformer;\n-import java.lang.reflect.code.TypeElement;\n-import java.lang.reflect.code.Value;\n-import java.util.List;\n-\n-public class HatOps {\n-    public abstract sealed static class HatOp extends Op permits HatPtrOp, HatKernelContextOp{\n-        private final TypeElement type;\n-\n-        HatOp(String opName, TypeElement type, List<Value> operands) {\n-            super(opName, operands);\n-            this.type = type;\n-        }\n-\n-        HatOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-            this.type = that.type;\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return type;\n-        }\n-    }\n-    public final static class HatKernelContextOp extends HatOp {\n-        public final static String NAME=\"hat.kc.op\";\n-        public final String fieldName;\n-        public HatKernelContextOp(String fieldName, TypeElement typeElement, List<Value> operands) {\n-            super(NAME+\".\"+fieldName, typeElement, operands);\n-            this.fieldName=fieldName;\n-        }\n-        public HatKernelContextOp(String fieldName, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME+\".\"+fieldName, replacer.currentResultType(), replacer.currentOperandValues());\n-            this.fieldName=fieldName;\n-\n-        }\n-        public HatKernelContextOp(String fieldName,TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME+\".\"+fieldName, typeElement, replacer.currentOperandValues());\n-            this.fieldName=fieldName;\n-        }\n-        public HatKernelContextOp(HatKernelContextOp that, CopyContext cc) {\n-            super(that, cc); this.fieldName = that.fieldName;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatKernelContextOp(this, cc);\n-        }\n-    }\n-\n-\n-    public abstract static sealed class HatPtrOp extends HatOp permits HatPtrStoreOp,HatPtrLoadOp {\n-\n-        public HatPtrOp(String name, TypeElement typeElement, List<Value> operands) {\n-            super(name, typeElement, operands);\n-        }\n-        public HatPtrOp(String name, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(name, replacer.currentResultType(), replacer.currentOperandValues());\n-        }\n-        public HatPtrOp(String name, TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(name, typeElement, replacer.currentOperandValues());\n-        }\n-\n-        public HatPtrOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-\n-    }\n-    public final static class HatPtrStoreOp extends HatPtrOp {\n-        public final static String NAME=\"hat.ptr.store\";\n-        public HatPtrStoreOp(TypeElement typeElement, List<Value> operands) {\n-            super(NAME, typeElement, operands);\n-        }\n-        public HatPtrStoreOp(FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, replacer);\n-        }\n-        public HatPtrStoreOp(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement,replacer);\n-        }\n-        public HatPtrStoreOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrStoreOp(this, cc);\n-        }\n-    }\n-    public final static class HatPtrLoadOp extends HatPtrOp {\n-        public final static String NAME=\"hat.ptr.load\";\n-        public HatPtrLoadOp(TypeElement typeElement, List<Value> operands) {\n-            super(NAME, typeElement, operands);\n-        }\n-        public HatPtrLoadOp(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME, typeElement, replacer);\n-        }\n-        public HatPtrLoadOp( FuncOpWrapper.WrappedOpReplacer replacer) {\n-            super(NAME,  replacer);\n-        }\n-        public HatPtrLoadOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new HatPtrStoreOp(this, cc);\n-        }\n-    }\n-\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatOps.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -0,0 +1,487 @@\n+package hat;\n+\n+import hat.buffer.MappableIface;\n+import hat.optools.FuncOpWrapper;\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.OpWrapper;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class HatPtr {\n+\n+        public static <T extends MappableIface> TypeElement convertToPtrTypeIfPossible(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+            return getMappableClassOrNull(lookup, typeElement) instanceof Class<?> clazz\n+                    ? new HatPtr.HatPtrType<>((Class<T>) clazz, getLayout((Class<T>) clazz))\n+                    : typeElement;\n+        }\n+\n+        public static <T extends MappableIface> MemoryLayout getLayout(Class<T> mappableIface) {\n+            try {\n+                return (MemoryLayout) mappableIface.getDeclaredField(\"LAYOUT\").get(null);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public static <T extends MappableIface> Class<T> getMappableClassOrNull(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+            try {\n+                return (typeElement instanceof JavaType jt\n+                        && jt.resolve(lookup) instanceof Class<?> possiblyMappableIface\n+                        && MappableIface.class.isAssignableFrom(possiblyMappableIface)) ? (Class<T>) possiblyMappableIface : null;\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public static FunctionType transformTypes(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n+            List<TypeElement> transformedTypeElements = new ArrayList<>();\n+            for (Block.Parameter parameter : funcOp.parameters()) {\n+                transformedTypeElements.add(convertToPtrTypeIfPossible(lookup, parameter.type()));\n+            }\n+            return FunctionType.functionType(convertToPtrTypeIfPossible(lookup, funcOp.invokableType().returnType()), transformedTypeElements);\n+        }\n+\n+        public static <T extends MappableIface> CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup lookup,\n+                                                                                     CoreOp.FuncOp ssaForm, FunctionType functionType) {\n+            return CoreOp.func(ssaForm.funcName(), functionType).body(funcBlock -> {\n+                funcBlock.transformBody(ssaForm.body(), funcBlock.parameters(), (builder, op) -> {\n+                \/*\n+                   We are looking for\n+                      interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                         T foo();\n+                         void foo(T foo);\n+                      }\n+                   Were T is either a primitive or a nested iface mapping and foo matches the field name\n+                 *\/\n+\n+                    if (op instanceof CoreOp.InvokeOp invokeOp\n+                            && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper\n+                            && invokeOpWrapper.hasOperands()\n+                            && invokeOpWrapper.isIfaceBufferMethod()\n+                            && invokeOpWrapper.getReceiver() instanceof Value iface \/\/ Is there a containing iface type Iface\n+                            && getMappableClassOrNull(lookup, iface.type()) != null\n+                    ) {\n+                        Value ifaceValue = builder.context().getValue(iface);     \/\/ ? Ensure we have an output value for the iface\n+                        HatPtr.HatPtrOp<T> hatPtrOp = new HatPtr.HatPtrOp<>(ifaceValue, invokeOpWrapper.name());         \/\/ Create ptrOp to replace invokeOp\n+                        Op.Result ptrResult = builder.op(hatPtrOp);\/\/ replace and capture the result of the invoke\n+                        if (invokeOpWrapper.operandCount() == 1) {                  \/\/ No args (operand(0)==containing iface))\n+                        \/*\n+                          this turns into a load\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              T foo();\n+                          }\n+                         *\/\n+                            if (hatPtrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n+                                HatPtr.HatPtrLoadValue primitiveLoad = new HatPtr.HatPtrLoadValue(iface.type(), ptrResult);\n+                                Op.Result replacedReturnValue = builder.op(primitiveLoad);\n+                                builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                            } else {                                                 \/\/ pointing to another iface mappable\n+                                builder.context().mapValue(invokeOp.result(), ptrResult);\n+                            }\n+                        } else if (invokeOpWrapper.operandCount() == 2) {\n+                         \/*\n+                          This turns into a store\n+                          interface Iface extends Buffer \/\/ or Buffer.StructChild\n+                              void foo(T);\n+                          }\n+                         *\/\n+                            if (hatPtrOp.resultType().layout() instanceof ValueLayout) { \/\/ are we pointing to a primitive\n+                                Value valueToStore = builder.context().getValue(invokeOpWrapper.operandNAsValue(1));\n+                                HatPtr.HatPtrStoreValue primitiveStore = new HatPtr.HatPtrStoreValue(iface.type(), ptrResult, valueToStore);\n+                                Op.Result replacedReturnValue = builder.op(primitiveStore);\n+                                builder.context().mapValue(invokeOp.result(), replacedReturnValue);\n+                            } else {                                                 \/\/ pointing to another iface mappable\n+                                builder.context().mapValue(invokeOp.result(), ptrResult);\n+                            }\n+                        } else {\n+                            builder.op(op);\n+                        }\n+                    } else {\n+                        builder.op(op);\n+                    }\n+                    return builder; \/\/ why? oh why?\n+                });\n+            });\n+        }\n+\n+\n+    public abstract  static class HatOp extends Op {\n+        private final TypeElement type;\n+\n+        HatOp(String opName, TypeElement type, List<Value> operands) {\n+            super(opName, operands);\n+            this.type = type;\n+        }\n+\n+        HatOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.type = that.type;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n+\n+\n+    public final static class HatKernelContextOp extends HatOp {\n+        public final static String NAME=\"hat.kc.op\";\n+        public final String fieldName;\n+        public HatKernelContextOp(String fieldName, TypeElement typeElement, List<Value> operands) {\n+            super(NAME+\".\"+fieldName, typeElement, operands);\n+            this.fieldName=fieldName;\n+        }\n+        public HatKernelContextOp(String fieldName, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME+\".\"+fieldName, replacer.currentResultType(), replacer.currentOperandValues());\n+            this.fieldName=fieldName;\n+\n+        }\n+        public HatKernelContextOp(String fieldName,TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME+\".\"+fieldName, typeElement, replacer.currentOperandValues());\n+            this.fieldName=fieldName;\n+        }\n+        public HatKernelContextOp(HatKernelContextOp that, CopyContext cc) {\n+            super(that, cc); this.fieldName = that.fieldName;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatKernelContextOp(this, cc);\n+        }\n+    }\n+\n+\/*\n+    public abstract static  class HatPtrOp extends HatOp {\n+\n+        public HatPtrOp(String name, TypeElement typeElement, List<Value> operands) {\n+            super(name, typeElement, operands);\n+        }\n+        public HatPtrOp(String name, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(name, replacer.currentResultType(), replacer.currentOperandValues());\n+        }\n+        public HatPtrOp(String name, TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(name, typeElement, replacer.currentOperandValues());\n+        }\n+\n+        public HatPtrOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+    }\n+    public final static class HatPtrStoreOp extends HatPtrOp {\n+        public final static String NAME=\"hat.ptr.store\";\n+        public HatPtrStoreOp(TypeElement typeElement, List<Value> operands) {\n+            super(NAME, typeElement, operands);\n+        }\n+        public HatPtrStoreOp(FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, replacer);\n+        }\n+        public HatPtrStoreOp(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement,replacer);\n+        }\n+        public HatPtrStoreOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrStoreOp(this, cc);\n+        }\n+    }\n+    public final static class HatPtrLoadOp extends HatPtrOp {\n+        public final static String NAME=\"hat.ptr.load\";\n+        public HatPtrLoadOp(TypeElement typeElement, List<Value> operands) {\n+            super(NAME, typeElement, operands);\n+        }\n+        public HatPtrLoadOp(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement, replacer);\n+        }\n+        public HatPtrLoadOp( FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME,  replacer);\n+        }\n+        public HatPtrLoadOp(HatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrStoreOp(this, cc);\n+        }\n+    }\n+\n+*\/\n+\n+\n+\n+    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n+        String name;\n+        HatType(String name){\n+            this.name = name;\n+        }\n+    }\n+\n+    public static final class HatPtrType<T extends MappableIface> extends HatType {\n+        static final String NAME = \"ptrType\";\n+        public final Class<T> mappableIface;\n+        final MemoryLayout layout;\n+        final JavaType referringType;\n+\n+        public HatPtrType(Class<T> mappableIface, MemoryLayout layout) {\n+            super(NAME);\n+            this.mappableIface = mappableIface;\n+            this.layout = layout;\n+            if (layout instanceof StructLayout structLayout){\n+                this.referringType =  JavaType.type(ClassDesc.of(structLayout.name().orElseThrow()));\n+            }else if  (layout instanceof ValueLayout valueLayout) {\n+                this.referringType = JavaType.type(valueLayout.carrier());\n+            }else    if (layout instanceof SequenceLayout sequenceLayout){\n+                this.referringType =  JavaType.type(ClassDesc.of(sequenceLayout.name().orElseThrow()));\n+            }else {\n+                throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+            }\n+        }\n+\n+        public JavaType referringType() {\n+            return referringType;\n+        }\n+\n+        public MemoryLayout layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            HatPtrType<T> hatPtrType = (HatPtrType<T>) o;\n+            return Objects.equals(layout, hatPtrType.layout);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(layout);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(referringType.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    }\n+\n+\n+   \/* public static final class HatPtrType extends HatType {\n+        static final String NAME = \"hat.ptr\";\n+        final TypeElement type;\n+\n+        public HatPtrType(TypeElement type) {\n+            super(NAME);\n+            this.type = type;\n+\n+        }\n+\n+        public TypeElement type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            HatPtrType hatPtrType = (HatPtrType) o;\n+            return Objects.equals(type, hatPtrType.type);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(type);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(type.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    } *\/\n+\n+\n+\n+    @OpFactory.OpDeclaration(HatPtrOp.NAME)\n+    public static final class HatPtrOp<T extends MappableIface> extends ExternalizableOp {\n+        public static final String NAME = \"ptr.to.member\";\n+        public static final String ATTRIBUTE_OFFSET = \"offset\";\n+        final HatPtr.HatPtrType<T> hatPtrType;\n+        final HatPtr.HatPtrType<T> resultType;\n+        final String simpleMemberName;\n+        final long memberOffset;\n+\n+\n+        HatPtrOp(HatPtrOp<T> that, CopyContext cc) {\n+            super(that, cc);\n+            this.hatPtrType = that.hatPtrType;\n+            this.resultType = that.resultType;\n+            this.simpleMemberName = that.simpleMemberName;\n+            this.memberOffset = that.memberOffset;\n+\n+        }\n+\n+        @Override\n+        public HatPtrOp<T> transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrOp<T>(this, cc);\n+        }\n+\n+        public HatPtrOp(Value ptr, String simpleMemberName) {\n+            super(NAME, List.of(ptr));\n+\n+            this.simpleMemberName = simpleMemberName;\n+            if (ptr.type() instanceof HatPtr.HatPtrType<?> hatPtrType) {\n+\n+                if (hatPtrType.layout() instanceof StructLayout structLayout) {\n+                    this.hatPtrType = (HatPtr.HatPtrType<T>) hatPtrType;\n+                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n+                    this.memberOffset = structLayout.byteOffset(memberPathElement);\n+                    MemoryLayout memberLayout = structLayout.select(memberPathElement);\n+                    this.resultType = new HatPtr.HatPtrType<>((Class<T>) hatPtrType.mappableIface, memberLayout);\n+                }else   if (hatPtrType.layout() instanceof SequenceLayout sequenceLayout) {\n+                    this.hatPtrType = (HatPtr.HatPtrType<T>) hatPtrType;\n+                    MemoryLayout.PathElement memberPathElement = MemoryLayout.PathElement.groupElement(simpleMemberName);\n+                    this.memberOffset = sequenceLayout.byteOffset(memberPathElement);\n+                    MemoryLayout memberLayout = sequenceLayout.select(memberPathElement);\n+                    this.resultType = new HatPtr.HatPtrType<>((Class<T>) hatPtrType.mappableIface, memberLayout);\n+                } else {\n+                    throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + hatPtrType.layout());\n+                }\n+            } else {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+        }\n+\n+\n+        @Override\n+        public HatPtr.HatPtrType<T> resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", simpleMemberName);\n+            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n+            return attrs;\n+        }\n+    }\n+\n+\n+    public static abstract class HatPtrAccessValue extends Op {\n+        final String name;\n+        final TypeElement resultType;\n+        final TypeElement typeElement;\n+\n+        HatPtrAccessValue(String name, TypeElement typeElement, HatPtrAccessValue that, CopyContext cc) {\n+            super(that, cc);\n+            this.name = name;\n+            this.typeElement = typeElement;\n+            this.resultType = that.resultType;\n+        }\n+\n+        public HatPtrAccessValue(String name, TypeElement typeElement, TypeElement resultType, List<Value> values) {\n+            super(name, values);\n+            this.name = name;\n+            this.typeElement = typeElement;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(HatPtrLoadValue.NAME)\n+    public static final class HatPtrLoadValue extends HatPtrAccessValue {\n+        public static final String NAME = \"ptr.load.value\";\n+\n+        HatPtrLoadValue(TypeElement typeElement, HatPtrLoadValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n+        }\n+        public HatPtrLoadValue(TypeElement typeElement, Value ptr) {\n+            super(NAME, typeElement, ((HatPtr.HatPtrType<?>) ptr.type()).referringType(), List.of(ptr));\n+        }\n+        \/\/  public HatPtrLoadValue(String name,TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+        \/\/    super(name, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n+        \/\/  }\n+        public HatPtrLoadValue(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n+        }\n+\n+        @Override\n+        public HatPtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrLoadValue(typeElement, this, cc);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(HatPtrStoreValue.NAME)\n+    public static final class HatPtrStoreValue extends HatPtrAccessValue {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        public HatPtrStoreValue(TypeElement typeElement, HatPtrStoreValue that, CopyContext cc) {\n+            super(NAME, typeElement, that, cc);\n+        }\n+        public HatPtrStoreValue(TypeElement typeElement, PrimitiveType resultType, List<Value> operandValues) {\n+            super(NAME, typeElement, resultType, operandValues);\n+        }\n+        public HatPtrStoreValue(TypeElement typeElement, Value ptr, Value arg1) {\n+            super(NAME, typeElement, JavaType.VOID, List.of(ptr, arg1));\n+        }\n+      \/\/  public HatPtrStoreValue(String name,TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+        \/\/    super(name, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n+      \/\/  }\n+        public HatPtrStoreValue(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement, replacer.currentResultType(), replacer.currentOperandValues());\n+        }\n+\n+\n+        @Override\n+        public HatPtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new HatPtrStoreValue(typeElement, this, cc);\n+        }\n+\n+\n+    }\n+\n+\n+\n+\n+\n+\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatPtr.java","additions":487,"deletions":0,"binary":false,"changes":487,"status":"added"},{"patch":"@@ -1,52 +0,0 @@\n-package hat;\n-\n-import java.lang.reflect.code.TypeElement;\n-import java.util.List;\n-import java.util.Objects;\n-\n-public class HatTypes {\n-    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n-        String name;\n-        HatType(String name){\n-            this.name = name;\n-        }\n-    }\n-\n-    public static final class HatPtrType extends HatType {\n-        static final String NAME = \"hat.ptr\";\n-        final TypeElement type;\n-\n-        public HatPtrType(TypeElement type) {\n-            super(NAME);\n-            this.type = type;\n-\n-        }\n-\n-        public TypeElement type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            HatPtrType hatPtrType = (HatPtrType) o;\n-            return Objects.equals(type, hatPtrType.type);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(type);\n-        }\n-\n-        @Override\n-        public ExternalizedTypeElement externalize() {\n-            return new ExternalizedTypeElement(NAME, List.of(type.externalize()));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return externalize().toString();\n-        }\n-    }\n-}\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatTypes.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -0,0 +1,159 @@\n+package hat.backend;\n+\n+import hat.ComputeContext;\n+import hat.HatPtr;\n+import hat.NDRange;\n+import hat.buffer.Buffer;\n+import hat.callgraph.KernelCallGraph;\n+import hat.callgraph.KernelEntrypoint;\n+import hat.ifacemapper.SegmentMapper;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n+\n+public class DebugBackend implements Backend {\n+    public enum HowToRunCompute{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE}\n+    public HowToRunCompute howToRunCompute=HowToRunCompute.REFLECT;\n+    public enum HowToRunKernel{REFLECT, BABYLON_INTERPRETER, BABYLON_CLASSFILE, LOWER_TO_SSA,LOWER_TO_SSA_AND_MAP_PTRS}\n+    HowToRunKernel howToRunKernel = HowToRunKernel.LOWER_TO_SSA_AND_MAP_PTRS;\n+    public DebugBackend(HowToRunCompute howToRunCompute, HowToRunKernel howToRunKernel){\n+        this.howToRunCompute = howToRunCompute;\n+        this.howToRunKernel = howToRunKernel;\n+    }\n+\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n+    }\n+\n+    @Override\n+    public void dispatchCompute(ComputeContext computeContext, Object... args) {\n+\n+        switch (howToRunCompute){\n+            case REFLECT: {\n+                try {\n+                    computeContext.computeCallGraph.entrypoint.method.invoke(null, args);\n+                } catch (IllegalAccessException | InvocationTargetException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                break;\n+            }\n+            case BABYLON_INTERPRETER:{\n+                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n+                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+                }\n+                Interpreter.invoke(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op(), args);\n+                break;\n+            }\n+            case BABYLON_CLASSFILE:{\n+                if (computeContext.computeCallGraph.entrypoint.lowered == null) {\n+                    computeContext.computeCallGraph.entrypoint.lowered = computeContext.computeCallGraph.entrypoint.funcOpWrapper().lower();\n+                }\n+                try {\n+                    if (computeContext.computeCallGraph.entrypoint.mh == null) {\n+                        computeContext.computeCallGraph.entrypoint.mh = BytecodeGenerator.generate(computeContext.accelerator.lookup, computeContext.computeCallGraph.entrypoint.lowered.op());\n+                    }\n+                    computeContext.computeCallGraph.entrypoint.mh.invokeWithArguments(args);\n+                } catch (Throwable e) {\n+                    computeContext.computeCallGraph.entrypoint.lowered.op().writeTo(System.out);\n+                    throw new RuntimeException(e);\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+\n+        switch (howToRunKernel){\n+            case REFLECT: {\n+                KernelEntrypoint kernelEntrypoint = kernelCallGraph.entrypoint;\n+                for (ndRange.kid.x = 0; ndRange.kid.x < ndRange.kid.maxX; ndRange.kid.x++) {\n+                    try {\n+                        args[0] = ndRange.kid;\n+                        kernelEntrypoint.method.invoke(null, args);\n+                    } catch (IllegalAccessException e) {\n+                        throw new RuntimeException(e);\n+                    } catch (InvocationTargetException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                break;\n+            }\n+            case BABYLON_INTERPRETER:{\n+                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n+                Interpreter.invoke(kernelCallGraph.computeContext.accelerator.lookup, lowered.op(), args);\n+                break;\n+            }\n+            case BABYLON_CLASSFILE:{\n+                var lowered = kernelCallGraph.entrypoint.funcOpWrapper().lower();\n+                var mh = BytecodeGenerator.generate(kernelCallGraph.computeContext.accelerator.lookup, lowered.op());\n+                try {\n+                    mh.invokeWithArguments(args);\n+                } catch (Throwable e) {\n+                    throw new RuntimeException(e);\n+                }\n+                break;\n+            }\n+\n+            case LOWER_TO_SSA:{\n+                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+\n+\n+                System.out.println(\"Initial code model\");\n+                System.out.println(highLevelForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                System.out.println(\"Lowered form which maintains original invokes and args\");\n+                System.out.println(loweredForm.toText());\n+                System.out.println(\"-------------- ----\");\n+\n+                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+                System.out.println(\"SSA form which maintains original invokes and args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+            }\n+\n+            case LOWER_TO_SSA_AND_MAP_PTRS:{\n+                var highLevelForm = kernelCallGraph.entrypoint.method.getCodeModel().orElseThrow();\n+                System.out.println(\"Initial code model\");\n+                System.out.println(highLevelForm.toText());\n+                System.out.println(\"------------------\");\n+                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                System.out.println(\"Lowered form which maintains original invokes and args\");\n+                System.out.println(loweredForm.toText());\n+                System.out.println(\"-------------- ----\");\n+                \/\/ highLevelForm.lower();\n+                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+                System.out.println(\"SSA form which maintains original invokes and args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                FunctionType functionType = HatPtr.transformTypes(MethodHandles.lookup(), ssaInvokeForm);\n+                System.out.println(\"SSA form with types transformed args\");\n+                System.out.println(ssaInvokeForm.toText());\n+                System.out.println(\"------------------\");\n+\n+                CoreOp.FuncOp ssaPtrForm = HatPtr.transformInvokesToPtrs(MethodHandles.lookup(), ssaInvokeForm, functionType);\n+                System.out.println(\"SSA form with invokes replaced by ptrs\");\n+                System.out.println(ssaPtrForm.toText());\n+            }\n+        }\n+\n+\n+    }\n+\n+    @Override\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper) {\n+        return segmentMapper.allocate(Arena.global());\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -27,3 +27,1 @@\n-import hat.HatOps;\n-import hat.KernelContext;\n-import hat.buffer.Buffer;\n+import hat.HatPtr;\n@@ -228,1 +226,1 @@\n-    public BiMap<Block.Parameter, HatOps.HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n+    public BiMap<Block.Parameter, HatPtr.HatPtrOp> parameterHatPtrOpMap = new BiMap<>();\n@@ -240,1 +238,1 @@\n-                }else if (resultOp instanceof HatOps.HatPtrOp hatPtrOp) {\n+                }else if (resultOp instanceof HatPtr.HatPtrOp hatPtrOp) {\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}