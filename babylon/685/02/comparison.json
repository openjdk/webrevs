{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -83,1 +83,2 @@\n-    public interface IfBody<T> extends Quotable {\n+    @CodeReflection\n+    public interface IfBody<T> {\n@@ -92,1 +93,3 @@\n-    public interface LoopBody<T> extends Quotable {\n+\n+    @CodeReflection\n+    public interface LoopBody<T> {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ExplicitOnnxOperators.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -441,1 +441,2 @@\n-    public interface OnnxFunction<T> extends Supplier<T>, Quotable {\n+    @CodeReflection\n+    public interface OnnxFunction<T> extends Supplier<T> {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -40,1 +41,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -167,1 +167,2 @@\n-    public interface QuotableComputeContextConsumer extends Quotable, Consumer<ComputeContext> {\n+    @CodeReflection\n+    public interface QuotableComputeContextConsumer extends Consumer<ComputeContext> {\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -36,1 +37,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -176,1 +176,2 @@\n-    public interface QuotableKernelContextConsumer extends Quotable, Consumer<KernelContext> { }\n+    @CodeReflection\n+    public interface QuotableKernelContextConsumer extends Consumer<KernelContext> { }\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -29,1 +30,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -49,1 +49,2 @@\n-        interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable {\n+        @CodeReflection\n+        interface QuotableIntUnaryOperator extends IntUnaryOperator {\n@@ -52,1 +53,2 @@\n-        interface QuotableFunction<T, R> extends Function<T, R>, Quotable {\n+        @CodeReflection\n+        interface QuotableFunction<T, R> extends Function<T, R> {\n@@ -55,1 +57,2 @@\n-        interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R>, Quotable {\n+        @CodeReflection\n+        interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R> {\n@@ -135,1 +138,1 @@\n-        static void isMethodRef(Quotable q) {\n+        static void isMethodRef(Object q) {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/TestQuoted.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -28,1 +29,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -34,1 +34,2 @@\n-        public interface QuotableComputeConsumer extends Quotable, Consumer<ComputeClosureProxy> {\n+        @CodeReflection\n+        public interface QuotableComputeConsumer extends Consumer<ComputeClosureProxy> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/Bad.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -501,1 +501,0 @@\n-        static final Class<?> QUOTABLE_CLASS;\n@@ -510,1 +509,0 @@\n-                QUOTABLE_CLASS = cl.loadClass(\"jdk.incubator.code.Quotable\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-     * must be a {@code Quotable} object, inspectable using code reflection. *\/\n+     * must be inspectable using code reflection. *\/\n@@ -448,3 +448,0 @@\n-     * <p>When FLAG_QUOTABLE is set in {@code flags}, the function objects\n-     * will implement {@code Quotable}.\n-     *\n@@ -540,2 +537,0 @@\n-            altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n-            altInterfaces[altInterfaces.length-1] = InnerClassLambdaMetafactory.CodeReflectionSupport.QUOTABLE_CLASS;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5415,15 +5415,0 @@\n-\n-    \/\/ code reflection\n-\n-    \/\/ The predicates below do not use a predefined symbol in Symtab.\n-    \/\/ This is deliberate, as we cannot initialize symbols in modules\n-    \/\/ other than java.base at startup.\n-\n-    public boolean isQuotable(Type type) {\n-        Symbol s = type.tsym;\n-        return s != null &&\n-                s.kind == TYP &&\n-                s.name.equals(names.quotable) &&\n-                s.packge().fullname.equals(names.jdk_incubator_code) &&\n-                s.packge().modle.name.equals(names.jdk_incubator_code);\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -451,0 +451,2 @@\n+            annotate.queueScanTreeAndTypeAnnotate(tree.body, env, tree.sym);\n+            annotate.flush();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-     * <li>lambdas or method references whose target type is {@code Quoted}; and\n-     * <li>lambdas or method references whose target is an intersection type that contains {@code Quotable}.\n+     * <li>lambdas or method references whose target type is a functional interface annotated with {@code CodeReflection}; and\n+     * <li>lambdas or method references whose target is a cast that contains the {@code CodeReflection} annotation.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CodeReflectionTransformer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -855,1 +855,0 @@\n-                        !types.isQuotable(t) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-    public final Name quotable;\n@@ -425,1 +424,0 @@\n-        quotable = fromString(\"Quotable\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@Target({ElementType.METHOD})\n+@Target({ElementType.METHOD, ElementType.TYPE_USE, ElementType.TYPE})\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/CodeReflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-    public static Optional<Quoted> ofQuotable(Quotable q) {\n+    public static Optional<Quoted> ofQuotable(Object q) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code;\n-\n-\/**\n- * Classes implementing this interface support code reflection. That is, they can obtain\n- * a {@link Quoted} object using {@link Op#ofQuotable(Quotable)}, which returns the intermediate\n- * representation associated with a lambda expression or method reference.\n- *\/\n-public interface Quotable {\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Quotable.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.incubator.code.Quotable;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-    public final Type quotableType;\n@@ -60,1 +59,0 @@\n-        quotableType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.Quotable\");\n@@ -69,1 +67,0 @@\n-        syms.synthesizeEmptyInterfaceIfMissing(quotableType);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.tools.javac.code.Type.IntersectionClassType;\n@@ -73,0 +74,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCTypeCast;\n@@ -78,2 +80,0 @@\n-import com.sun.tools.javac.tree.TreeScanner;\n-import com.sun.tools.javac.tree.TreeTranslator;\n@@ -119,1 +119,1 @@\n-public class ReflectMethods extends TreeTranslator {\n+public class ReflectMethods extends TreeScannerPrev {\n@@ -211,1 +211,0 @@\n-            result = tree;\n@@ -218,1 +217,1 @@\n-        if (isReflectable(tree)) {\n+        if (isQuotable(tree, prevNode())) {\n@@ -222,1 +221,0 @@\n-                result = tree;\n@@ -246,1 +244,0 @@\n-        JCVariableDecl recvDecl = memberReferenceToLambda.receiverVar();\n@@ -249,1 +246,1 @@\n-        if (isReflectable(tree)) {\n+        if (isQuotable(tree, prevNode())) {\n@@ -253,1 +250,0 @@\n-                result = tree;\n@@ -268,26 +264,0 @@\n-            super.visitReference(tree);\n-            if (recvDecl != null) {\n-                result = copyReferenceWithReceiverVar(tree, recvDecl);\n-            }\n-        } else {\n-            super.visitReference(tree);\n-        }\n-    }\n-\n-    \/\/ @@@: Only used for quoted lambda, not quotable ones. Remove?\n-    ListBuffer<JCExpression> quotedCapturedArgs(DiagnosticPosition pos, BodyScanner bodyScanner) {\n-        ListBuffer<JCExpression> capturedArgs = new ListBuffer<>();\n-        for (Symbol capturedSym : bodyScanner.stack.localToOp.keySet()) {\n-            if (capturedSym.kind == Kind.VAR) {\n-                \/\/ captured var\n-                VarSymbol var = (VarSymbol)capturedSym;\n-                if (var.getConstValue() == null) {\n-                    capturedArgs.add(make.at(pos).Ident(capturedSym));\n-                }\n-            } else {\n-                throw new AssertionError(\"Unexpected captured symbol: \" + capturedSym);\n-            }\n-        }\n-        if (capturedArgs.size() < bodyScanner.top.body.entryBlock().parameters().size()) {\n-            \/\/ needs to capture 'this'\n-            capturedArgs.prepend(make.at(pos).This(currentClassSym.type));\n@@ -295,22 +265,1 @@\n-        return capturedArgs;\n-    }\n-\n-    \/*\n-     * Creates a let expression of the kind:\n-     * let $recv in $recv::memberRef\n-     *\n-     * This is required to make sure that LambdaToMethod doesn't end up emitting the\n-     * code for capturing the bound method reference receiver twice.\n-     *\/\n-    JCExpression copyReferenceWithReceiverVar(JCMemberReference ref, JCVariableDecl recvDecl) {\n-        JCMemberReference newRef = make.at(ref).Reference(ref.mode, ref.name, make.Ident(recvDecl.sym), ref.typeargs);\n-        newRef.type = ref.type;\n-        newRef.target = ref.target;\n-        newRef.refPolyKind = ref.refPolyKind;\n-        newRef.referentType = ref.referentType;\n-        newRef.kind = ref.kind;\n-        newRef.varargsElement = ref.varargsElement;\n-        newRef.ownerAccessible = ref.ownerAccessible;\n-        newRef.sym = ref.sym;\n-        newRef.codeModel = ref.codeModel;\n-        return make.at(ref).LetExpr(recvDecl, newRef).setType(newRef.type);\n+        super.visitReference(tree);\n@@ -369,1 +318,2 @@\n-        return translate(cdef);\n+        scan(cdef);\n+        return cdef;\n@@ -378,2 +328,2 @@\n-            BodyScanner bodyScanner = new BodyScanner(methodDecl, attributedBody);\n-            return bodyScanner.scanMethod();\n+            BodyScanner bodyScanner = new BodyScanner(methodDecl);\n+            return bodyScanner.scanMethod(attributedBody);\n@@ -422,2 +372,2 @@\n-    class BodyScanner extends TreeScanner {\n-        private final JCTree body;\n+    class BodyScanner extends TreeScannerPrev {\n+        private final JCTree tree;\n@@ -432,1 +382,0 @@\n-        private JCTree currentNode;\n@@ -436,6 +385,1 @@\n-            this(tree, tree.body);\n-        }\n-\n-        BodyScanner(JCMethodDecl tree, JCBlock body) {\n-            this.currentNode = tree;\n-            this.body = body;\n+            this.tree = tree;\n@@ -474,2 +418,1 @@\n-            this.currentNode = tree;\n-            this.body = tree;\n+            this.tree = tree;\n@@ -583,11 +526,0 @@\n-        @Override\n-        public void scan(JCTree tree) {\n-            JCTree prev = currentNode;\n-            currentNode = tree;\n-            try {\n-                super.scan(tree);\n-            } finally {\n-                currentNode = prev;\n-            }\n-        }\n-\n@@ -630,0 +562,5 @@\n+        private DiagnosticPosition pos() {\n+            JCTree current = currentNode();\n+            return current != null ? current : tree;\n+        }\n+\n@@ -631,1 +568,1 @@\n-            return append(op, generateLocation(currentNode, false), stack);\n+            return append(op, generateLocation(pos(), false), stack);\n@@ -644,1 +581,1 @@\n-        Location generateLocation(JCTree node, boolean includeSourceReference) {\n+        Location generateLocation(DiagnosticPosition pos, boolean includeSourceReference) {\n@@ -649,3 +586,3 @@\n-            int pos = node.getStartPosition();\n-            int line = log.currentSource().getLineNumber(pos);\n-            int col = log.currentSource().getColumnNumber(pos, false);\n+            int startPos = pos.getStartPosition();\n+            int line = log.currentSource().getLineNumber(startPos);\n+            int col = log.currentSource().getColumnNumber(startPos, false);\n@@ -1438,3 +1375,1 @@\n-            \/\/ a lambda targeted to Quoted is always going to have its model wrapped in QuotedOp, regardless of whether\n-            \/\/ we are producing the model of the method that contain it or we are producing the model of the lambda itself\n-            \/\/ on the other hand, a lambda targeted to a subtype of Quotable is going to have its model wrapped in QuotedOp\n+            \/\/ a quotable lambda is going to have its model wrapped in QuotedOp\n@@ -1445,1 +1380,1 @@\n-            boolean toQuote = (isQuoted && body == tree);\n+            boolean toQuote = (isQuoted && this.tree == tree);\n@@ -1485,1 +1420,1 @@\n-            Op lambdaOp = JavaOp.lambda(fiType, stack.body, isReflectable(tree));\n+            Op lambdaOp = JavaOp.lambda(fiType, stack.body, isQuotable(tree, prevNode()));\n@@ -2452,2 +2387,2 @@\n-        CoreOp.FuncOp scanMethod() {\n-            scan(body);\n+        CoreOp.FuncOp scanMethod(JCBlock body) {\n+            scan(body, ReflectMethods.this.currentNode());\n@@ -2456,1 +2391,1 @@\n-            func.setLocation(generateLocation(currentNode, true));\n+            func.setLocation(generateLocation(tree, true));\n@@ -2460,0 +2395,4 @@\n+        CoreOp.FuncOp scanMethod() {\n+            return scanMethod(((JCMethodDecl)tree).body);\n+        }\n+\n@@ -2461,1 +2400,1 @@\n-            scan(body);\n+            scan(tree, ReflectMethods.this.prevNode());\n@@ -2504,2 +2443,14 @@\n-    boolean isReflectable(JCFunctionalExpression functionalExpression) {\n-        return types.asSuper(functionalExpression.target, crSyms.quotableType.tsym) != null;\n+    boolean isQuotable(JCFunctionalExpression expr, JCTree prev) {\n+        return isQuotable(expr.target, true) ||\n+                (prev instanceof JCTypeCast castTree && isQuotable(castTree.clazz.type, false));\n+    }\n+\n+    boolean isQuotable(Type target, boolean declAnnos) {\n+        if (target.isCompound()) {\n+            return ((IntersectionClassType)target).getComponents().stream()\n+                    .anyMatch(t -> isQuotable(t, declAnnos));\n+        } else {\n+            return declAnnos ?\n+                    target.tsym.attribute(crSyms.codeReflectionType.tsym) != null :\n+                    target.getAnnotationMirrors().stream().anyMatch(tc -> tc.type.tsym == crSyms.codeReflectionType.tsym);\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":49,"deletions":98,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+package jdk.incubator.code.internal;\n+\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.TreeScanner;\n+\n+public class TreeScannerPrev extends TreeScanner {\n+\n+    private JCTree currentNode;\n+    private JCTree prevNode;\n+\n+    @Override\n+    public void scan(JCTree tree) {\n+        JCTree prevPrevNode = prevNode;\n+        prevNode = currentNode;\n+        currentNode = tree;\n+        try {\n+            super.scan(tree);\n+        } finally {\n+            currentNode = prevNode;\n+            prevNode = prevPrevNode;\n+        }\n+    }\n+\n+    public void scan(JCTree tree, JCTree prevNode) {\n+        this.prevNode = null;\n+        currentNode = prevNode;\n+        scan(tree);\n+    }\n+\n+    JCTree currentNode() {\n+        return prevNode;\n+    }\n+\n+    JCTree prevNode() {\n+        return prevNode;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/TreeScannerPrev.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -27,1 +28,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -51,3 +51,2 @@\n-        IntBinaryOperator ibo = (IntBinaryOperator & Quotable) (a, b) -> a + b;\n-        Quotable iboq = (Quotable) ibo;\n-        return SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(iboq).get().op());\n+        IntBinaryOperator ibo = (@CodeReflection IntBinaryOperator) (a, b) -> a + b;\n+        return SSA.transform((JavaOp.LambdaOp) Op.ofQuotable(ibo).get().op());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) -> a + b;\n+        IntBinaryOperator q = (@CodeReflection IntBinaryOperator)(int a, int b) -> a + b;\n@@ -74,1 +74,1 @@\n-        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) -> a + b;\n+        IntBinaryOperator q = (@CodeReflection IntBinaryOperator)(int a, int b) -> a + b;\n@@ -103,1 +103,1 @@\n-        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) ->  {\n+        IntBinaryOperator q = (@CodeReflection IntBinaryOperator)(int a, int b) ->  {\n@@ -132,1 +132,1 @@\n-        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) ->  {\n+        IntBinaryOperator q = (@CodeReflection IntBinaryOperator)(int a, int b) ->  {\n@@ -167,1 +167,1 @@\n-        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) ->  {\n+        IntBinaryOperator q = (@CodeReflection IntBinaryOperator)(int a, int b) ->  {\n@@ -196,1 +196,1 @@\n-        Quotable q = (Consumer<int[]> & Quotable) (int[] a) -> {\n+        Consumer<int[]> q = (@CodeReflection Consumer<int[]>) (int[] a) -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-        Quotable quotable = (Runnable & Quotable) () -> {};\n+        Runnable quotable = (@CodeReflection Runnable) () -> {};\n@@ -163,1 +163,2 @@\n-    public interface QuotableIntSupplier extends IntSupplier, Quotable {\n+    @CodeReflection\n+    public interface QuotableIntSupplier extends IntSupplier {\n@@ -215,1 +216,2 @@\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable {}\n+    @CodeReflection\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator {}\n@@ -217,1 +219,2 @@\n-    interface QuotableFunction<T, R> extends Function<T, R>, Quotable {}\n+    @CodeReflection\n+    interface QuotableFunction<T, R> extends Function<T, R> {}\n@@ -219,1 +222,2 @@\n-    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R>, Quotable {}\n+    @CodeReflection\n+    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R> {}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -49,1 +49,2 @@\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable {}\n+    @CodeReflection\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator {}\n@@ -51,1 +52,2 @@\n-    interface QuotableFunction<T, R> extends Function<T, R>, Quotable {}\n+    @CodeReflection\n+    interface QuotableFunction<T, R> extends Function<T, R> {}\n@@ -53,1 +55,2 @@\n-    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R>, Quotable {}\n+    @CodeReflection\n+    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R> {}\n@@ -55,1 +58,1 @@\n-    List<Quotable> methodRefLambdas() {\n+    List<Object> methodRefLambdas() {\n@@ -68,1 +71,1 @@\n-    public void testIsMethodReference(Quotable q) {\n+    public void testIsMethodReference(Object q) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestMethodRefLambda.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        Quotable q = (IntUnaryOperator & Quotable) x -> x + y + z + hashCode();\n+        IntUnaryOperator q = (@CodeReflection IntUnaryOperator) x -> x + y + z + hashCode();\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuoteOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        Quotable q = (IntUnaryOperator & Quotable) i -> i \/ 2;\n+        IntUnaryOperator q = (@CodeReflection IntUnaryOperator) i -> i \/ 2;\n@@ -60,1 +60,1 @@\n-        Quotable q = (IntBinaryOperator & Quotable)(int a, int b) -> {\n+        IntBinaryOperator q = (@CodeReflection IntBinaryOperator)(int a, int b) -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSealOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -378,1 +378,2 @@\n-    public interface QuotableFunc extends Quotable {\n+    @CodeReflection\n+    public interface QuotableFunc {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -49,1 +48,2 @@\n-    interface QIntSupplier extends IntSupplier, Quotable {\n+    @CodeReflection\n+    interface QIntSupplier extends IntSupplier {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNestedCapturingLambda.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -379,1 +379,2 @@\n-    public interface QuotableFunc extends Quotable {\n+    @CodeReflection\n+    public interface QuotableFunc {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestBytecodeLift.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,5 +24,1 @@\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.Quotable;\n-import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.*;\n@@ -50,1 +46,1 @@\n-        JavaOp.LambdaOp lf = generate((Quotable & DoubleUnaryOperator) (double a) -> a + 0.0);\n+        JavaOp.LambdaOp lf = generate((@CodeReflection DoubleUnaryOperator) (double a) -> a + 0.0);\n@@ -57,1 +53,1 @@\n-        JavaOp.LambdaOp lf = generate((Quotable & DoubleBinaryOperator) (double a, double b) -> -a + b);\n+        JavaOp.LambdaOp lf = generate((@CodeReflection DoubleBinaryOperator) (double a, double b) -> -a + b);\n@@ -62,1 +58,1 @@\n-    static JavaOp.LambdaOp generate(Quotable q) {\n+    static JavaOp.LambdaOp generate(Object q) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.CodeReflection;\n@@ -28,1 +28,2 @@\n-public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+@CodeReflection\n+public interface QuotableFunction<T, R> extends Function<T, R> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotableFunction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.incubator.code.Quotable;\n+import jdk.incubator.code.CodeReflection;\n@@ -28,1 +28,2 @@\n-public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+@CodeReflection\n+public interface QuotablePredicate<T> extends Predicate<T> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotablePredicate.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+    @CodeReflection\n+    public interface QuotablePredicate<T> extends Predicate<T> {\n@@ -48,1 +49,2 @@\n-    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+    @CodeReflection\n+    public interface QuotableFunction<T, R> extends Function<T, R> {\n@@ -51,1 +53,2 @@\n-    public interface QuotableSupplier<T> extends Quotable, Supplier<T> {\n+    @CodeReflection\n+    public interface QuotableSupplier<T> extends Supplier<T> {\n@@ -54,1 +57,2 @@\n-    public interface QuotableConsumer<T> extends Quotable, Consumer<T> {\n+    @CodeReflection\n+    public interface QuotableConsumer<T> extends Consumer<T> {\n@@ -57,1 +61,2 @@\n-    public interface QuotableBiConsumer<T, U> extends Quotable, BiConsumer<T, U> {\n+    @CodeReflection\n+    public interface QuotableBiConsumer<T, U> extends BiConsumer<T, U> {\n@@ -75,1 +80,1 @@\n-            StreamOp(Quotable quotedLambda) {\n+            StreamOp(Object quotedLambda) {\n@@ -91,1 +96,1 @@\n-            public MapStreamOp(Quotable quotedLambda) {\n+            public MapStreamOp(Object quotedLambda) {\n@@ -97,1 +102,1 @@\n-            public FlatMapStreamOp(Quotable quotedLambda) {\n+            public FlatMapStreamOp(Object quotedLambda) {\n@@ -103,1 +108,1 @@\n-            public FilterStreamOp(Quotable quotedLambda) {\n+            public FilterStreamOp(Object quotedLambda) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -114,2 +114,3 @@\n-        } else if (Quotable.class.isAssignableFrom(field.getType())) {\n-            Quotable quotable = (Quotable) field.get(null);\n+        } else {\n+            \/\/ quotable\n+            Object quotable = field.get(null);\n@@ -119,3 +120,0 @@\n-        } else {\n-            error(\"Field annotated with @IR should be of a quotable type (Quoted\/Quotable)\");\n-            return;\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -2,1 +3,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -18,2 +18,2 @@\n-    Quotable f() {\n-        return (Runnable & Quotable) () -> {\n+    Runnable f() {\n+        return (@CodeReflection Runnable) () -> {\n@@ -26,2 +26,2 @@\n-        Quotable q1 = f();\n-        Quotable q2 = f();\n+        Runnable q1 = f();\n+        Runnable q2 = f();\n@@ -35,2 +35,2 @@\n-        Quotable q1 = f();\n-        Quotable q2 = f();\n+        Runnable q1 = f();\n+        Runnable q2 = f();\n@@ -41,2 +41,2 @@\n-    static Quotable g(int i) {\n-        return (IntUnaryOperator & Quotable) j -> j + i;\n+    static IntUnaryOperator g(int i) {\n+        return (@CodeReflection IntUnaryOperator) j -> j + i;\n@@ -47,2 +47,2 @@\n-        Quotable q1 = g(1);\n-        Quotable q2 = g(2);\n+        IntUnaryOperator q1 = g(1);\n+        IntUnaryOperator q2 = g(2);\n@@ -56,2 +56,2 @@\n-        Quotable q1 = g(1);\n-        Quotable q2 = g(2);\n+        IntUnaryOperator q1 = g(1);\n+        IntUnaryOperator q2 = g(2);\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaModelUniquenessTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -43,1 +42,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -49,1 +48,1 @@\n-    static final Quotable QUOTED_NO_PARAM_VOID = (Quotable & Runnable) () -> {\n+    static final Runnable QUOTED_NO_PARAM_VOID = (@CodeReflection Runnable) () -> {\n@@ -54,1 +53,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true ()java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"int\" -> {\n@@ -61,1 +60,1 @@\n-    static final Quotable QUOTED_NO_PARAM_CONST = (Quotable & IntSupplier) () -> 1;\n+    static final IntSupplier QUOTED_NO_PARAM_CONST = (@CodeReflection IntSupplier) () -> 1;\n@@ -65,1 +64,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n@@ -73,1 +72,1 @@\n-    static final Quotable QUOTED_ID = (Quotable & IntUnaryOperator) x -> x;\n+    static final IntUnaryOperator QUOTED_ID = (@CodeReflection IntUnaryOperator) x -> x;\n@@ -77,1 +76,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntBinaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -88,1 +87,1 @@\n-    static final Quotable QUOTED_PLUS = (Quotable & IntBinaryOperator) (x, y) -> x + y;\n+    static final IntBinaryOperator QUOTED_PLUS = (@CodeReflection IntBinaryOperator) (x, y) -> x + y;\n@@ -92,1 +91,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -99,1 +98,1 @@\n-    static final Quotable QUOTED_THROW_NO_PARAM = (Quotable & Runnable) () -> {\n+    static final Runnable QUOTED_THROW_NO_PARAM = (@CodeReflection Runnable) () -> {\n@@ -105,1 +104,1 @@\n-                %1 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -115,3 +114,3 @@\n-    static final Quotable QUOTED_CAPTURE_PARAM = new Object() {\n-        Quotable captureContext(int x) {\n-            return (Quotable & IntUnaryOperator) y -> x + y;\n+    static final IntUnaryOperator QUOTED_CAPTURE_PARAM = new Object() {\n+        IntUnaryOperator captureContext(int x) {\n+            return (@CodeReflection IntUnaryOperator) y -> x + y;\n@@ -124,2 +123,2 @@\n-        Quotable capture() {\n-            return (Quotable & IntUnaryOperator) z -> x + y + z;\n+        IntUnaryOperator capture() {\n+            return (@CodeReflection IntUnaryOperator) z -> x + y + z;\n@@ -131,1 +130,1 @@\n-                %1 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -143,1 +142,1 @@\n-    static final Quotable QUOTED_CAPTURE_FIELD = new Context().capture();\n+    static final IntUnaryOperator QUOTED_CAPTURE_FIELD = new Context().capture();\n@@ -161,1 +160,1 @@\n-        IntUnaryOperator op = (IntUnaryOperator & Quotable) y -> x + y;\n+        IntUnaryOperator op = (@CodeReflection IntUnaryOperator) y -> x + y;\n@@ -183,1 +182,1 @@\n-        IntUnaryOperator op = (IntUnaryOperator & Quotable) z -> x + y + z;\n+        IntUnaryOperator op = (@CodeReflection IntUnaryOperator) z -> x + y + z;\n@@ -191,1 +190,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n+                %0 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -198,1 +197,1 @@\n-    static final Quotable QUOTED_NO_PARAM_VOID_REF = (Quotable & Runnable) QuotableIntersectionTest::m;\n+    static final Runnable QUOTED_NO_PARAM_VOID_REF = (@CodeReflection Runnable) QuotableIntersectionTest::m;\n@@ -206,1 +205,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n@@ -215,1 +214,1 @@\n-    static final Quotable QUOTED_INT_PARAM_INT_RET_REF = (Quotable & IntUnaryOperator) QuotableIntersectionTest::g;\n+    static final IntUnaryOperator QUOTED_INT_PARAM_INT_RET_REF = (@CodeReflection IntUnaryOperator) QuotableIntersectionTest::g;\n@@ -219,1 +218,1 @@\n-                %0 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int[]\" -> {\n+                %0 : java.type:\"java.util.function.IntFunction<int[]>\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int[]\" -> {\n@@ -228,1 +227,1 @@\n-    static final Quotable QUOTED_INT_PARAM_ARR_RET_REF = (Quotable & IntFunction<int[]>) int[]::new;\n+    static final IntFunction<int[]> QUOTED_INT_PARAM_ARR_RET_REF = (@CodeReflection IntFunction<int[]>) int[]::new;\n@@ -235,2 +234,2 @@\n-        Quotable capture() {\n-            return (Quotable & IntUnaryOperator) this::g;\n+        IntUnaryOperator capture() {\n+            return (@CodeReflection IntUnaryOperator) this::g;\n@@ -242,1 +241,1 @@\n-                %1 : java.type:\"jdk.incubator.code.Quotable\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n+                %1 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n@@ -251,1 +250,1 @@\n-    static final Quotable QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n+    static final IntUnaryOperator QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","additions":30,"deletions":31,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -42,1 +41,2 @@\n-    interface QuotableRunnable extends Runnable, Quotable { }\n+    @CodeReflection\n+    interface QuotableRunnable extends Runnable { }\n@@ -54,1 +54,2 @@\n-    interface QuotableIntSupplier extends IntSupplier, Quotable { }\n+    @CodeReflection\n+    interface QuotableIntSupplier extends IntSupplier { }\n@@ -67,1 +68,2 @@\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n+    @CodeReflection\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator { }\n@@ -81,1 +83,2 @@\n-    interface QuotableIntBinaryOperator extends IntBinaryOperator, Quotable { }\n+    @CodeReflection\n+    interface QuotableIntBinaryOperator extends IntBinaryOperator { }\n@@ -219,1 +222,2 @@\n-    interface QuotableIntFunction<A> extends Quotable, IntFunction<A> { }\n+    @CodeReflection\n+    interface QuotableIntFunction<A> extends IntFunction<A> { }\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -23,1 +22,1 @@\n-    private static final Quotable q1 = (Quotable & Runnable) () -> {\n+    private static final Runnable q1 = (@CodeReflection Runnable) () -> {\n@@ -31,1 +30,2 @@\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n+    @CodeReflection\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator { }\n@@ -42,1 +42,0 @@\n-    public interface QuotableIntSupplier extends IntSupplier, Quotable {}\n@@ -44,1 +43,3 @@\n-    static Quotable q() {\n+    public interface QuotableIntSupplier extends IntSupplier {}\n+    @CodeReflection\n+    static QuotableIntSupplier q() {\n@@ -53,1 +54,1 @@\n-        Quotable quotable = (Quotable) Interpreter.invoke(MethodHandles.lookup(), q);\n+        QuotableIntSupplier quotable = (QuotableIntSupplier) Interpreter.invoke(MethodHandles.lookup(), q);\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.code.CodeReflection;\n@@ -37,1 +38,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -56,1 +56,1 @@\n-        Quotable quotable = (Quotable & IntUnaryOperator)y -> x + y;\n+        IntUnaryOperator quotable = (@CodeReflection IntUnaryOperator) y -> x + y;\n@@ -72,1 +72,1 @@\n-        Quotable quotable = (Quotable & ToIntFunction<Number>)y -> y.intValue() + hashCode() + hello.length() + x;\n+        ToIntFunction<Number> quotable = (@CodeReflection ToIntFunction<Number>)y -> y.intValue() + hashCode() + hello.length() + x;\n@@ -89,1 +89,1 @@\n-        Quotable quotable = (Quotable & ToIntFunction<Number>)y -> y.intValue() + Integer.valueOf(hashCode());\n+        ToIntFunction<Number> quotable = (@CodeReflection ToIntFunction<Number>)y -> y.intValue() + Integer.valueOf(hashCode());\n@@ -106,1 +106,1 @@\n-        Quotable quotable = (Quotable & ToIntFunction<Number>)y -> y.intValue() + new R(hashCode()).i;\n+        ToIntFunction<Number> quotable = (@CodeReflection ToIntFunction<Number>)y -> y.intValue() + new R(hashCode()).i;\n@@ -131,1 +131,1 @@\n-        Quotable quotable = (Quotable & IntSupplier) () -> i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8;\n+        IntSupplier quotable = (@CodeReflection IntSupplier) () -> i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8;\n@@ -150,2 +150,2 @@\n-        Quotable quotable() {\n-            return (Quotable & IntUnaryOperator) y -> x + y;\n+        IntUnaryOperator quotable() {\n+            return (@CodeReflection IntUnaryOperator) y -> x + y;\n@@ -159,1 +159,1 @@\n-        Quotable quotable = context.quotable();\n+        IntUnaryOperator quotable = context.quotable();\n@@ -179,1 +179,1 @@\n-        Quotable quotable = (Quotable & IntUnaryOperator)new Box(i)::add;\n+        IntUnaryOperator quotable = (@CodeReflection IntUnaryOperator)new Box(i)::add;\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestCaptureQuotable.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-            Quotable q = (Runnable & Quotable) () -> { };\n+            Runnable q = (@CodeReflection Runnable) () -> { };\n@@ -19,1 +19,1 @@\n-            Quotable q = (Runnable & Quotable) this::test2;\n+            Runnable q = (@CodeReflection Runnable) this::test2;\n@@ -22,1 +22,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,3 +2,3 @@\n-TestNoCodeReflectionInInnerClasses.java:15:48: compiler.err.quoted.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-TestNoCodeReflectionInInnerClasses.java:19:48: compiler.err.quoted.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-3 errors\n\\ No newline at end of file\n+TestNoCodeReflectionInInnerClasses.java:15:53: compiler.err.quoted.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+TestNoCodeReflectionInInnerClasses.java:19:53: compiler.err.quoted.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import jdk.incubator.code.Quotable;\n@@ -199,1 +198,1 @@\n-    static final Quotable QUOTABLE_TEST = (IntUnaryOperator & Quotable) (int i) -> {\n+    static final IntUnaryOperator QUOTABLE_TEST = (@CodeReflection IntUnaryOperator) (int i) -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnreachableTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}