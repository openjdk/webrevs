{"files":[{"patch":"@@ -361,1 +361,1 @@\n-        this(Config.of(configSpec));\n+        this(FFIConfig.of(configSpec));\n@@ -365,1 +365,1 @@\n-        this(Config.of());\n+        this(FFIConfig.of());\n@@ -368,1 +368,1 @@\n-    public CudaBackend(Config config) {\n+    public CudaBackend(FFIConfig config) {\n@@ -380,2 +380,2 @@\n-            String code = config.isPTX() ? createPTX(kernelCallGraph,  args) : createC99(kernelCallGraph, args);\n-            if (config.isSHOW_CODE()) {\n+            String code = FFIConfig.PTX.isSet(config.bits()) ? createPTX(kernelCallGraph,  args) : createC99(kernelCallGraph, args);\n+            if (FFIConfig.SHOW_CODE.isSet(config.bits())) {\n@@ -441,1 +441,1 @@\n-        if (config.isSHOW_KERNEL_MODEL()){\n+        if (FFIConfig.SHOW_KERNEL_MODEL.isSet(config.bits())){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        super(\"mock_backend\", Config.of(0));\n+        super(\"mock_backend\", FFIConfig.of(0));\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        this(Config.of(configSpec));\n+        this(FFIConfig.of(configSpec));\n@@ -39,1 +39,1 @@\n-        this(Config.of());\n+        this(FFIConfig.of());\n@@ -42,1 +42,1 @@\n-    public OpenCLBackend(Config config) {\n+    public OpenCLBackend(FFIConfig config) {\n@@ -56,1 +56,1 @@\n-            if (config.isSHOW_CODE()) {\n+            if (FFIConfig.SHOW_CODE.isSet(config.bits())) {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -49,1 +48,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -63,1 +61,1 @@\n-    public C99FFIBackend(String libName, Config config) {\n+    public C99FFIBackend(String libName, FFIConfig config) {\n@@ -265,1 +263,1 @@\n-        if (config.isSHOW_KERNEL_MODEL()) {\n+        if (FFIConfig.SHOW_KERNEL_MODEL.isSet(config.bits())) {\n@@ -282,1 +280,1 @@\n-                if (config.isSHOW_STATE()) {\n+                if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -289,1 +287,1 @@\n-                if (config.isSHOW_STATE()) {\n+                if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -293,1 +291,1 @@\n-                if (config.isSHOW_STATE()) {\n+                if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -305,1 +303,1 @@\n-        if (config.isSHOW_STATE()) {\n+        if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -311,1 +309,1 @@\n-        if (config.isSHOW_STATE()) {\n+        if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -323,1 +321,1 @@\n-                if (config.isSHOW_STATE()) {\n+                if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -331,1 +329,1 @@\n-                if (config.isSHOW_STATE()) {\n+                if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -335,1 +333,1 @@\n-                if (config.isSHOW_STATE()) {\n+                if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n@@ -348,1 +346,1 @@\n-        if (config.isSHOW_STATE()) {\n+        if (FFIConfig.SHOW_STATE.isSet(config.bits())) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,409 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package hat.backend.ffi;\n-\n-import hat.codebuilders.HATCodeBuilder;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-public record Config(int bits) {\n-    record Bit(int index, String name) {\n-    }\n-\n-    \/\/ These must sync with hat\/backends\/ffi\/opencl\/include\/opencl_backend.h\n-    \/\/ Bits 0-3 select platform id 0..5\n-    \/\/ Bits 4-7 select device id 0..15\n-    private static final int START_BIT_IDX = 16;\n-    private static final int MINIMIZE_COPIES_BIT = 1 << START_BIT_IDX;\n-    private static final int TRACE_BIT = 1 << 17;\n-    private static final int PROFILE_BIT = 1 << 18;\n-    private static final int SHOW_CODE_BIT = 1 << 19;\n-    private static final int SHOW_KERNEL_MODEL_BIT = 1 << 20;\n-    private static final int SHOW_COMPUTE_MODEL_BIT = 1 << 21;\n-    private static final int INFO_BIT = 1 << 22;\n-    private static final int TRACE_COPIES_BIT = 1 << 23;\n-    private static final int TRACE_SKIPPED_COPIES_BIT = 1 << 24;\n-    private static final int TRACE_ENQUEUES_BIT = 1 << 25;\n-    private static final int TRACE_CALLS_BIT = 1 << 26;\n-    private static final int SHOW_WHY_BIT = 1 << 27;\n-    private static final int SHOW_STATE_BIT = 1 << 28;\n-    private static final int PTX_BIT = 1 << 29;\n-    private static final int INTERPRET_BIT = 1 << 30;\n-    private static final int END_BIT_IDX = 31;\n-\n-    private static String[] bitNames = {\n-            \"MINIMIZE_COPIES\",\n-            \"TRACE\",\n-            \"PROFILE\",\n-            \"SHOW_CODE\",\n-            \"SHOW_KERNEL_MODEL\",\n-            \"SHOW_COMPUTE_MODEL\",\n-            \"INFO\",\n-            \"TRACE_COPIES\",\n-            \"TRACE_SKIPPED_COPIES\",\n-            \"TRACE_ENQUEUES\",\n-            \"TRACE_CALLS\",\n-            \"SHOW_WHY\",\n-            \"SHOW_STATE\",\n-            \"PTX\",\n-            \"INTERPRET\",\n-    };\n-\n-    public static Config of() {\n-        if (System.getenv(\"HAT\") instanceof String opts) {\n-            System.out.println(\"From env \" + opts);\n-            return of(opts);\n-        }\n-        if (System.getProperty(\"HAT\") instanceof String opts) {\n-            System.out.println(\"From prop \" + opts);\n-            return of(opts);\n-        }\n-        return of(\"\");\n-    }\n-\n-    public static Config of(int bits) {\n-        return new Config(bits);\n-    }\n-\n-    public static Config of(List<Config> configs) {\n-        int allBits = 0;\n-        for (Config config : configs) {\n-            allBits |= config.bits;\n-        }\n-        return new Config(allBits);\n-    }\n-\n-    public static Config of(Config... configs) {\n-        return of(List.of(configs));\n-    }\n-\n-    public Config and(Config... configs) {\n-        return Config.of(Config.of(List.of(configs)).bits & bits);\n-    }\n-\n-    public Config or(Config... configs) {\n-        return Config.of(Config.of(List.of(configs)).bits | bits);\n-    }\n-\n-    public static Config of(String name) {\n-        if (name == null || name.equals(\"\")) {\n-            return Config.of(0);\n-        }\n-        for (int i = 0; i < bitNames.length; i++) {\n-            if (bitNames[i].equals(name)) {\n-                return new Config(1 << (i + START_BIT_IDX));\n-            }\n-        }\n-        if (name.contains(\",\")) {\n-            List<Config> configs = new ArrayList<>();\n-            Arrays.stream(name.split(\",\")).forEach(opt ->\n-                    configs.add(of(opt))\n-            );\n-            return of(configs);\n-        } else if (name.contains(\":\")) {\n-            var tokens = name.split(\":\");\n-            if (tokens.length == 2) {\n-                var token = tokens[0];\n-                if (token.equals(\"PLATFORM\") || token.equals(\"DEVICE\")) {\n-                    int value = Integer.parseInt(tokens[1]);\n-                    return new Config(value << (token.equals(\"DEVICE\") ? 4 : 0));\n-                } else {\n-                    System.out.println(\"Unexpected opt '\" + name + \"'\");\n-                    return Config.of(0);\n-                }\n-            } else {\n-                System.out.println(\"Unexpected opt '\" + name + \"'\");\n-                return Config.of(0);\n-            }\n-        } else {\n-            System.out.println(\"Unexpected opt '\" + name + \"'\");\n-            System.exit(1);\n-            return Config.of(0);\n-        }\n-    }\n-\n-    public static Config PTX() {\n-        return new Config(PTX_BIT);\n-    }\n-\n-    public boolean isINTERPRET() {\n-        return (bits & INTERPRET_BIT) == INTERPRET_BIT;\n-    }\n-\n-    public static Config INTERPRET() {\n-        return new Config(INTERPRET_BIT);\n-    }\n-\n-    public boolean isPTX() {\n-        return (bits & PTX_BIT) == PTX_BIT;\n-    }\n-\n-    public static Config SHOW_STATE() {\n-        return new Config(SHOW_STATE_BIT);\n-    }\n-\n-    public boolean isSHOW_STATE() {\n-        return (bits & SHOW_STATE_BIT) == SHOW_STATE_BIT;\n-    }\n-\n-    public static Config SHOW_WHY() {\n-        return new Config(SHOW_WHY_BIT);\n-    }\n-\n-    public boolean isSHOW_WHY() {\n-        return (bits & SHOW_WHY_BIT) == SHOW_WHY_BIT;\n-    }\n-\n-    public static Config TRACE_COPIES() {\n-        return new Config(TRACE_COPIES_BIT);\n-    }\n-\n-    public boolean isTRACE_COPIES() {\n-        return (bits & TRACE_COPIES_BIT) == TRACE_COPIES_BIT;\n-    }\n-\n-    public static Config TRACE_CALLS() {\n-        return new Config(TRACE_CALLS_BIT);\n-    }\n-\n-    public boolean isTRACE_CALLS() {\n-        return (bits & TRACE_CALLS_BIT) == TRACE_CALLS_BIT;\n-    }\n-\n-    public static Config TRACE_ENQUEUES() {\n-        return new Config(TRACE_ENQUEUES_BIT);\n-    }\n-\n-    public boolean isTRACE_ENQUEUES() {\n-        return (bits & TRACE_ENQUEUES_BIT) == TRACE_ENQUEUES_BIT;\n-    }\n-\n-\n-    public static Config TRACE_SKIPPED_COPIES() {\n-        return new Config(TRACE_SKIPPED_COPIES_BIT);\n-    }\n-\n-    public boolean isTRACE_SKIPPED_COPIES() {\n-        return (bits & TRACE_SKIPPED_COPIES_BIT) == TRACE_SKIPPED_COPIES_BIT;\n-    }\n-\n-    public static Config INFO() {\n-        return new Config(INFO_BIT);\n-    }\n-\n-    public boolean isINFO() {\n-        return (bits & INFO_BIT) == INFO_BIT;\n-    }\n-\n-\n-    public static Config PROFILE() {\n-        return new Config(PROFILE_BIT);\n-    }\n-\n-    public boolean isPROFILE() {\n-        return (bits & PROFILE_BIT) == PROFILE_BIT;\n-    }\n-\n-    public static Config TRACE() {\n-        return new Config(TRACE_BIT);\n-    }\n-\n-    public boolean isTRACE() {\n-        return (bits & TRACE_BIT) == TRACE_BIT;\n-    }\n-\n-    public static Config MINIMIZE_COPIES() {\n-        return new Config(MINIMIZE_COPIES_BIT);\n-    }\n-\n-    public boolean isMINIMIZE_COPIES() {\n-        return (bits & MINIMIZE_COPIES_BIT) == MINIMIZE_COPIES_BIT;\n-    }\n-\n-    public static Config SHOW_CODE() {\n-        return new Config(SHOW_CODE_BIT);\n-    }\n-\n-    public boolean isSHOW_CODE() {\n-        return (bits & SHOW_CODE_BIT) == SHOW_CODE_BIT;\n-    }\n-\n-    public static Config SHOW_KERNEL_MODEL() {\n-        return new Config(SHOW_KERNEL_MODEL_BIT);\n-    }\n-\n-    public boolean isSHOW_KERNEL_MODEL() {\n-        return (bits & SHOW_KERNEL_MODEL_BIT) == SHOW_KERNEL_MODEL_BIT;\n-    }\n-\n-    public static Config SHOW_COMPUTE_MODEL() {\n-        return new Config(SHOW_COMPUTE_MODEL_BIT);\n-    }\n-\n-    public boolean isSHOW_COMPUTE_MODEL() {\n-        return (bits & SHOW_COMPUTE_MODEL_BIT) == SHOW_COMPUTE_MODEL_BIT;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-        for (int bitIdx = START_BIT_IDX; bitIdx < END_BIT_IDX; bitIdx++) {\n-            if ((bits & (1 << bitIdx)) == (1 << bitIdx)) {\n-                if (!builder.isEmpty()) {\n-                    builder.append(\"|\");\n-                }\n-                builder.append(bitNames[bitIdx - START_BIT_IDX]);\n-\n-            }\n-        }\n-        return builder.toString();\n-    }\n-\n-    public static class Main {\n-        public static class ConfigBuilder extends HATCodeBuilder<ConfigBuilder> {\n-\n-            ConfigBuilder staticConstInt(String name, int padWidth, int value) {\n-                staticKeyword().space().constexprKeyword().space().intType().space().identifier(name, padWidth).space().equals().space().intHexValue(value).semicolon().nl();\n-                return this;\n-            }\n-\n-            ConfigBuilder staticConstIntShiftedOne(String name, int padWidth, int shift) {\n-                staticKeyword().space().constexprKeyword().space().intType().space().identifier(name, padWidth).space().equals().space().intValue(1).leftShift().intHexValue(shift).semicolon().nl();\n-                return this;\n-            }\n-\n-            ConfigBuilder className() {\n-                return identifier(\"BasicConfig\");\n-            }\n-\n-            ConfigBuilder bitNamesVar() {\n-                return identifier(\"bitNames\");\n-            }\n-\n-            ConfigBuilder configBitsVar() {\n-                return identifier(\"configBits\");\n-            }\n-\n-            ConfigBuilder configBitsAnd() {\n-                return configBitsVar().space().ampersand().space();\n-            }\n-\n-            ConfigBuilder configBitsAndBitName(String bitName) {\n-                return configBitsAnd().identifier(bitName + \"_BIT\");\n-            }\n-\n-            static String toCamelExceptFirst(String s) {\n-                String[] parts = s.split(\"_\");\n-                StringBuilder camelCaseString = new StringBuilder(\"\");\n-                for (String part : parts) {\n-                    camelCaseString.append(camelCaseString.isEmpty()\n-                            ? part.toLowerCase()\n-                            : part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());\n-                }\n-                return camelCaseString.toString();\n-            }\n-\n-            ConfigBuilder camelExceptFirst(String s) {\n-                return identifier(toCamelExceptFirst(s));\n-            }\n-\n-            ConfigBuilder std(String s) {\n-                return identifier(\"std\").colon().colon().identifier(s);\n-            }\n-\n-            ConfigBuilder stdEndl() {\n-                return std(\"endl\");\n-            }\n-\n-            ConfigBuilder stdCout(String s) {\n-                return std(\"cout\").space().leftShift().space().dquote().literal(s).dquote();\n-            }\n-        }\n-\n-        public static void main(String[] args) {\n-            Config c = Config.of(\"INFO,PTX\");\n-            ConfigBuilder cb = new ConfigBuilder();\n-\n-            cb.lineComment(\"Auto generated from  \" + Config.class.getName());\n-            cb.pragma(\"once\").nl();\n-            cb.includeSys(\"iostream\").nl();\n-            final int START_BIT_INDEX = 0x10;\n-\n-            cb.structKeyword().space().className().braceNlIndented((_) -> {\n-                cb.staticConstInt(\"START_BIT_IDX\", 32, START_BIT_INDEX);\n-                int i = START_BIT_INDEX;\n-                for (var bitname : Config.bitNames) {\n-                    cb.staticConstIntShiftedOne(bitname + \"_BIT\", 32, i++);\n-                }\n-                cb.staticConstInt(\"END_BIT_IDX\", 32, i);\n-                cb.constKeyword().space().staticKeyword().space().charType().space().asterisk().bitNamesVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n-                cb.intType().space().identifier(\"configBits\").semicolon().nl();\n-\n-                for (var bitName : Config.bitNames) {\n-                    cb.identifier(\"bool\").space().camelExceptFirst(bitName).semicolon().nl();\n-                }\n-\n-                cb.intType().space().identifier(\"platform\").semicolon().nl();\n-                cb.intType().space().identifier(\"device\").semicolon().nl();\n-                cb.identifier(\"bool\").space().identifier(\"alwaysCopy\").semicolon().nl();\n-\/\/Constructor\n-                cb.explicitKeyword().space().className().paren((_) -> cb.intType().space().configBitsVar()).colon().nl().indent((_) -> {\n-                    cb.configBitsVar().paren((_) -> cb.configBitsVar()).comma().nl();\n-                    for (var bitName : Config.bitNames) {\n-                        cb.camelExceptFirst(bitName).paren((_) -> cb.paren((_) -> cb.configBitsAndBitName(bitName)).eq().identifier(bitName + \"_BIT\")).comma().nl();\n-\n-                    }\n-                    cb.identifier(\"platform\").paren((_) -> cb.configBitsAnd().intHexValue(0xf)).comma().nl();\n-                    cb.identifier(\"alwaysCopy\").paren(_->cb.pling().camelExceptFirst(\"MINIMIZE_COPIES\")).comma().nl();\n-                    cb.identifier(\"device\").paren(_ ->\n-                            cb.paren(_ -> cb.configBitsAnd().intHexValue(0xf0)).space().rightShift().space().intValue(4)).braceNlIndented(_ ->\n-                            cb.ifKeyword().paren(_ -> cb.identifier(\"info\")).braceNlIndented(_ -> {\n-                                for (var bitName : Config.bitNames) {\n-                                    cb.stdCout(\"native \" + ConfigBuilder.toCamelExceptFirst(bitName) + \" \").space().leftShift().space().camelExceptFirst(bitName).space().leftShift().space().stdEndl().semicolon().nl();\n-                                }\n-                            })\n-                    );\n-                }).nl().nl();\n-\n-                cb.virtualKeyword().space().tilde().className().paren((_) -> {\n-                }).equals().space().defaultKeyword().semicolon();\n-            }).semicolon().nl().nl();\n-\n-\n-            cb.hashIfdef(\"shared_cpp\", (_) -> {\n-                cb.constKeyword().space().charType().space().asterisk().className().colon().colon().bitNamesVar().sbrace(_ -> {}).equals().brace((_) -> {\n-                    cb.nl();\n-                    for (var bitName : Config.bitNames) {\n-                        cb.dquote().identifier(bitName + \"_BIT\").dquote().comma().nl();\n-                    }\n-                }).semicolon().nl();\n-            });\n-            System.out.println(cb);\n-        }\n-    }\n-}\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/Config.java","additions":0,"deletions":409,"binary":false,"changes":409,"status":"deleted"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.incubator.code.CopyContext;\n@@ -63,1 +62,1 @@\n-    public FFIBackend(String libName, Config config) {\n+    public FFIBackend(String libName, FFIConfig config) {\n@@ -74,1 +73,1 @@\n-        if (config.isINTERPRET()) {\n+        if (FFIConfig.INTERPRET.isSet(config.bits())) {\n@@ -132,2 +131,2 @@\n-        if (config.isMINIMIZE_COPIES()) {\n-            if (config.isSHOW_COMPUTE_MODEL()) {\n+        if (FFIConfig.MINIMIZE_COPIES.isSet(config.bits())) {\n+            if (FFIConfig.SHOW_COMPUTE_MODEL.isSet(config.bits())) {\n@@ -205,1 +204,1 @@\n-            if (config.isSHOW_COMPUTE_MODEL()) {\n+            if (FFIConfig.SHOW_COMPUTE_MODEL.isSet(config.bits())) {\n@@ -210,1 +209,1 @@\n-            if (config.isSHOW_COMPUTE_MODEL()) {\n+            if (FFIConfig.SHOW_COMPUTE_MODEL.isSet(config.bits())) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    protected final Config config;\n+    protected final FFIConfig config;\n@@ -113,1 +113,1 @@\n-        BackendBridge(FFILib ffiLib, Config config) {\n+        BackendBridge(FFILib ffiLib, FFIConfig config) {\n@@ -167,1 +167,1 @@\n-    public FFIBackendDriver(String libName, Config config) {\n+    public FFIBackendDriver(String libName, FFIConfig config) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackendDriver.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,320 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package hat.backend.ffi;\n+\n+import hat.Config;\n+import hat.codebuilders.HATCodeBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class FFIConfig implements Config {\n+    private int bits;\n+    static private List<Bit> bitList;\n+\n+    @Override\n+    public int bits(){\n+        return bits;\n+    }\n+    @Override\n+    public void bits(int bits){\n+        this.bits = bits;\n+    }\n+\n+\n+    FFIConfig(int bits){\n+        bits(bits);\n+    }\n+\n+    \/\/ These must sync with hat\/backends\/ffi\/shared\/include\/config.h\n+    \/\/ We can create the above config by running main() below...\n+    \/\/ Bits 0-3 select platform id 0..5\n+    \/\/ Bits 4-7 select device id 0..15\n+    \/\/ Bits 8-15 unused at present.\n+    \/\/ These bits start at 16\n+\n+    public static final Bit MINIMIZE_COPIES =  Bit.of(16, \"MINIMIZE_COPIES\");\n+    public static final Bit TRACE = Bit.nextBit(MINIMIZE_COPIES,\"TRACE\");\n+    public static final Bit PROFILE = Bit.nextBit(TRACE, \"PROFILE\");\n+    public static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\");\n+    public static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\");\n+    public static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\");\n+    public static final Bit INFO = Bit.nextBit(SHOW_COMPUTE_MODEL, \"INFO\");\n+    public static final Bit TRACE_COPIES = Bit.nextBit(INFO, \"TRACE_COPIES\");\n+    public static final Bit TRACE_SKIPPED_COPIES = Bit.nextBit(TRACE_COPIES, \"TRACE_SKIPPED_COPIES\");\n+    public static final Bit TRACE_ENQUEUES = Bit.nextBit(TRACE_SKIPPED_COPIES,\"TRACE_ENQUEUES\");\n+    public static final Bit TRACE_CALLS= Bit.nextBit(TRACE_ENQUEUES, \"TRACE_CALLS\");\n+    public static final Bit SHOW_WHY = Bit.nextBit(TRACE_CALLS, \"SHOW_WHY\");\n+    public static final Bit SHOW_STATE = Bit.nextBit(SHOW_WHY, \"SHOW_STATE\");\n+    public static final Bit PTX = Bit.nextBit(SHOW_STATE, \"PTX\");\n+    public static final Bit INTERPRET = Bit.nextBit(PTX, \"INTERPRET\");\n+\n+    static {\n+        bitList = List.of(\n+                MINIMIZE_COPIES,\n+                TRACE,\n+                PROFILE,\n+                SHOW_CODE,\n+                SHOW_KERNEL_MODEL,\n+                SHOW_COMPUTE_MODEL,\n+                INFO,\n+                TRACE_COPIES,\n+                TRACE_SKIPPED_COPIES,\n+                TRACE_ENQUEUES,\n+                TRACE_CALLS,\n+                SHOW_WHY,\n+                SHOW_STATE,\n+                PTX,\n+                INTERPRET\n+        );\n+    }\n+\n+    public static FFIConfig of() {\n+        if (System.getenv(\"HAT\") instanceof String opts) {\n+            System.out.println(\"From env \" + opts);\n+            return of(opts);\n+        }\n+        if (System.getProperty(\"HAT\") instanceof String opts) {\n+            System.out.println(\"From prop \" + opts);\n+            return of(opts);\n+        }\n+        return of(\"\");\n+    }\n+\n+    public static FFIConfig of(int bits) {\n+        return new FFIConfig(bits);\n+    }\n+\n+    public static FFIConfig of(List<Config.Bit> configBits) {\n+        int allBits = 0;\n+        for (Config.Bit configBit : configBits) {\n+            allBits |= configBit.shifted();\n+        }\n+        return new FFIConfig(allBits);\n+    }\n+\n+    public static FFIConfig of(Config.Bit... configBits) {\n+        return of(List.of(configBits));\n+    }\n+\n+    public FFIConfig and(Config.Bit... configBits) {\n+        return FFIConfig.of(FFIConfig.of(List.of(configBits)).bits & bits);\n+    }\n+\n+    public FFIConfig or(Config.Bit... configBits) {\n+        return FFIConfig.of(FFIConfig.of(List.of(configBits)).bits | bits);\n+    }\n+\n+    public static FFIConfig of(String name) {\n+        if (name == null || name.equals(\"\")) {\n+            return FFIConfig.of(0);\n+        }\n+\n+        for (Bit bit:bitList) {\n+            if (bit.name().equals(name)) {\n+                return new FFIConfig(bit.shifted());\n+            }\n+        }\n+        if (name.contains(\",\")) {\n+            List<Config.Bit> configBits = new ArrayList<>();\n+            Arrays.stream(name.split(\",\")).forEach(opt -> {\n+                   boolean found = false;\n+                   for (var bit:FFIConfig.bitList) {\n+                       if (bit.name().equals(opt)) {\n+                           configBits.add(bit);\n+                           found = true;\n+                           break;\n+                       }\n+                   }\n+                   if (!found){\n+                       throw new IllegalStateException(\"WHAT HAT OPT ?\"+opt);\n+\n+                   }\n+            }\n+            );\n+            return of(configBits);\n+        } else if (name.contains(\":\")) {\n+            var tokens = name.split(\":\");\n+            if (tokens.length == 2) {\n+                var token = tokens[0];\n+                if (token.equals(\"PLATFORM\") || token.equals(\"DEVICE\")) {\n+                    int value = Integer.parseInt(tokens[1]);\n+                    return new FFIConfig(value << (token.equals(\"DEVICE\") ? 4 : 0));\n+                } else {\n+                    System.out.println(\"Unexpected opt '\" + name + \"'\");\n+                    return FFIConfig.of(0);\n+                }\n+            } else {\n+                System.out.println(\"Unexpected opt '\" + name + \"'\");\n+                return FFIConfig.of(0);\n+            }\n+        } else {\n+            System.out.println(\"Unexpected opt '\" + name + \"'\");\n+            System.exit(1);\n+            return FFIConfig.of(0);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder builder = new StringBuilder();\n+        for (Bit bit:bitList){\n+            if (bit.isSet(bits)) {\n+                if (!builder.isEmpty()) {\n+                    builder.append(\"|\");\n+                }\n+                builder.append(bit.name());\n+\n+            }\n+        }\n+        return builder.toString();\n+    }\n+\n+    public static class Main {\n+        public static class ConfigBuilder extends HATCodeBuilder<ConfigBuilder> {\n+\n+            ConfigBuilder staticConstInt(String name, int padWidth, int value) {\n+                staticKeyword().space().constexprKeyword().space().intType().space().identifier(name, padWidth).space().equals().space().intHexValue(value).semicolon().nl();\n+                return this;\n+            }\n+\n+            ConfigBuilder staticConstIntShiftedOne(String name, int padWidth, int shift) {\n+                staticKeyword().space().constexprKeyword().space().intType().space().identifier(name, padWidth).space().equals().space().intValue(1).leftShift().intHexValue(shift).semicolon().nl();\n+                return this;\n+            }\n+\n+            ConfigBuilder className() {\n+                return identifier(\"BasicConfig\");\n+            }\n+\n+            ConfigBuilder bitNamesVar() {\n+                return identifier(\"bitNames\");\n+            }\n+\n+            ConfigBuilder configBitsVar() {\n+                return identifier(\"configBits\");\n+            }\n+\n+            ConfigBuilder configBitsAnd() {\n+                return configBitsVar().space().ampersand().space();\n+            }\n+\n+            ConfigBuilder configBitsAndBitName(String bitName) {\n+                return configBitsAnd().identifier(bitName + \"_BIT\");\n+            }\n+\n+            static String toCamelExceptFirst(String s) {\n+                String[] parts = s.split(\"_\");\n+                StringBuilder camelCaseString = new StringBuilder(\"\");\n+                for (String part : parts) {\n+                    camelCaseString.append(camelCaseString.isEmpty()\n+                            ? part.toLowerCase()\n+                            : part.substring(0, 1).toUpperCase() + part.substring(1).toLowerCase());\n+                }\n+                return camelCaseString.toString();\n+            }\n+\n+            ConfigBuilder camelExceptFirst(String s) {\n+                return identifier(toCamelExceptFirst(s));\n+            }\n+\n+            ConfigBuilder std(String s) {\n+                return identifier(\"std\").colon().colon().identifier(s);\n+            }\n+\n+            ConfigBuilder stdEndl() {\n+                return std(\"endl\");\n+            }\n+\n+            ConfigBuilder stdCout(String s) {\n+                return std(\"cout\").space().leftShift().space().dquote().literal(s).dquote();\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            FFIConfig c = FFIConfig.of(\"INFO,PTX\");\n+            ConfigBuilder cb = new ConfigBuilder();\n+\n+            cb.lineComment(\"Auto generated from  \" + FFIConfig.class.getName());\n+            cb.pragma(\"once\").nl();\n+            cb.includeSys(\"iostream\").nl();\n+            final int START_BIT_INDEX = 0x10;\n+\n+            cb.structKeyword().space().className().braceNlIndented((_) -> {\n+                cb.staticConstInt(\"START_BIT_IDX\", 32, START_BIT_INDEX);\n+                int i = START_BIT_INDEX;\n+                for (var bit : FFIConfig.bitList) {\n+                    cb.staticConstIntShiftedOne(bit.name() + \"_BIT\", 32, i++);\n+                }\n+                cb.staticConstInt(\"END_BIT_IDX\", 32, i);\n+                cb.constKeyword().space().staticKeyword().space().charType().space().asterisk().bitNamesVar().osbrace().csbrace().semicolon().space().lineComment(\"See below for initialization\");\n+                cb.intType().space().identifier(\"configBits\").semicolon().nl();\n+\n+                for (var bit : FFIConfig.bitList) {\n+                    cb.identifier(\"bool\").space().camelExceptFirst(bit.name()).semicolon().nl();\n+                }\n+\n+                cb.intType().space().identifier(\"platform\").semicolon().nl();\n+                cb.intType().space().identifier(\"device\").semicolon().nl();\n+                cb.identifier(\"bool\").space().identifier(\"alwaysCopy\").semicolon().nl();\n+\/\/Constructor\n+                cb.explicitKeyword().space().className().paren((_) -> cb.intType().space().configBitsVar()).colon().nl().indent((_) -> {\n+                    cb.configBitsVar().paren((_) -> cb.configBitsVar()).comma().nl();\n+                    for (var bit : FFIConfig.bitList) {\n+                        cb.camelExceptFirst(bit.name()).paren((_) -> cb.paren((_) -> cb.configBitsAndBitName(bit.name())).eq().identifier(bit.name() + \"_BIT\")).comma().nl();\n+\n+                    }\n+                    cb.identifier(\"platform\").paren((_) -> cb.configBitsAnd().intHexValue(0xf)).comma().nl();\n+                    cb.identifier(\"alwaysCopy\").paren(_->cb.pling().camelExceptFirst(\"MINIMIZE_COPIES\")).comma().nl();\n+                    cb.identifier(\"device\").paren(_ ->\n+                            cb.paren(_ -> cb.configBitsAnd().intHexValue(0xf0)).space().rightShift().space().intValue(4)).braceNlIndented(_ ->\n+                            cb.ifKeyword().paren(_ -> cb.identifier(\"info\")).braceNlIndented(_ -> {\n+                                for (var bit : FFIConfig.bitList) {\n+                                    cb.stdCout(\"native \" + ConfigBuilder.toCamelExceptFirst(bit.name()) + \" \").space().leftShift().space().camelExceptFirst(bit.name()).space().leftShift().space().stdEndl().semicolon().nl();\n+                                }\n+                            })\n+                    );\n+                }).nl().nl();\n+\n+                cb.virtualKeyword().space().tilde().className().paren((_) -> {\n+                }).equals().space().defaultKeyword().semicolon();\n+            }).semicolon().nl().nl();\n+\n+\n+            cb.hashIfdef(\"shared_cpp\", (_) -> {\n+                cb.constKeyword().space().charType().space().asterisk().className().colon().colon().bitNamesVar().sbrace(_ -> {}).equals().brace((_) -> {\n+                    cb.nl();\n+                    for (var bit : FFIConfig.bitList) {\n+                        cb.dquote().identifier(bit.name() + \"_BIT\").dquote().comma().nl();\n+                    }\n+                }).semicolon().nl();\n+            });\n+            System.out.println(cb);\n+        }\n+    }\n+}\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIConfig.java","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+public interface Config {\n+    int bits();\n+    void bits(int bits);\n+    record Bit(int index, int size, String name) implements Comparable<Bit> {\n+        static Bit of(int index, int size, String name){\n+            return new Bit(index,size,name);\n+        }\n+        public static Bit of(int index, String name){\n+            return new Bit(index,1,name);\n+        }\n+        public static Bit nextBit(Bit bit, String name){\n+            return new Bit(bit.index+1,1,name);\n+        }\n+\n+        @Override\n+        public int compareTo(Bit bit) {\n+            return Integer.compare(index, bit.index);\n+        }\n+\n+        public boolean isSet(int bits){\n+            return (shifted()&bits) == shifted();\n+        }\n+        public int shifted(){\n+            return 1<<index;\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/Config.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.backend.ffi.FFIConfig;\n@@ -31,1 +32,1 @@\n-import static hat.backend.ffi.Config.*;\n+import static hat.backend.ffi.FFIConfig.*;\n@@ -140,1 +141,1 @@\n-                ,new OpenCLBackend(of(PROFILE(),  TRACE())));\n+                ,new OpenCLBackend(of(FFIConfig.PROFILE,  FFIConfig.TRACE)));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.backend.ffi.FFIConfig;\n@@ -37,1 +38,1 @@\n-import static hat.backend.ffi.Config.*;\n+import static hat.backend.ffi.FFIConfig.*;\n@@ -62,3 +63,2 @@\n-                      \/\/  TRACE(),\n-                        TRACE_COPIES(),\n-                        MINIMIZE_COPIES()\n+                        FFIConfig.TRACE_COPIES,\n+                        FFIConfig.MINIMIZE_COPIES\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}