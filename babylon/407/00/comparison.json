{"files":[{"patch":"@@ -58,1 +58,1 @@\n-     * @param attributes      the operation's specific content as an attributes map, modifiable\n+     * @param attributes      the operation's specific content as an attributes map\n@@ -70,0 +70,4 @@\n+        public ExternalizedOp {\n+            attributes = Map.copyOf(attributes);\n+        }\n+\n@@ -71,1 +75,1 @@\n-         * Removes an attribute value from the attributes map, converts the value by applying it\n+         * Gets an attribute value from the attributes map, converts the value by applying it\n@@ -75,1 +79,1 @@\n-         * remove the attribute whose name is the empty string, otherwise if there is no such\n+         * get the attribute whose name is the empty string, otherwise if there is no such\n@@ -77,1 +81,1 @@\n-         * attempts to remove the attribute with the given name.\n+         * attempts to get the attribute with the given name.\n@@ -79,1 +83,1 @@\n-         * <p>On successful removal of the attribute its value is converted by applying the value\n+         * <p>On successfully obtaining the attribute its value is converted by applying the value\n@@ -93,1 +97,1 @@\n-                value = attributes.remove(\"\");\n+                value = attributes.get(\"\");\n@@ -98,1 +102,1 @@\n-                value = attributes.remove(name);\n+                value = attributes.get(name);\n@@ -122,1 +126,1 @@\n-                    op instanceof ExternalizableOp exop ? new HashMap<>(exop.attributes()) : new HashMap<>(),\n+                    op instanceof ExternalizableOp exop ? exop.attributes() : Map.of(),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/op\/ExternalizableOp.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -101,2 +101,0 @@\n-    static final JavaType J_U_HASH_MAP = type(HashMap.class);\n-\n@@ -108,3 +106,0 @@\n-    static final MethodRef MAP_OF = MethodRef.method(J_U_MAP, \"of\",\n-            J_U_MAP);\n-\n@@ -114,3 +109,0 @@\n-    static final MethodRef MAP_PUT = MethodRef.method(J_U_MAP, \"put\",\n-            J_L_OBJECT, J_L_OBJECT, J_L_OBJECT);\n-\n@@ -361,2 +353,4 @@\n-        if (keysAndValues.isEmpty()) {\n-            return builder.op(invoke(MAP_OF));\n+        if (keysAndValues.size() < 21) {\n+            MethodRef mapOf = MethodRef.method(J_U_MAP, \"of\",\n+                    J_U_MAP, Collections.nCopies(keysAndValues.size(), J_L_OBJECT));\n+            return builder.op(invoke(mapType, mapOf, keysAndValues));\n@@ -364,2 +358,2 @@\n-            ConstructorRef constructorRef = ConstructorRef.constructor(HashMap.class);\n-            Value map = builder.op(_new(mapType, constructorRef));\n+            JavaType mapEntryType = parameterized(J_U_MAP_ENTRY, keyType, valueType);\n+            List<Value> elements = new ArrayList<>(keysAndValues.size() \/ 2);\n@@ -369,1 +363,2 @@\n-                builder.op(invoke(MAP_PUT, map, key, value));\n+                Value entry = builder.op(invoke(mapEntryType, MAP_ENTRY, key, value));\n+                elements.add(entry);\n@@ -371,1 +366,2 @@\n-            return map;\n+            Value array = buildArray(mapEntryType, elements);\n+            return builder.op(invoke(mapType, MAP_OF_ARRAY, array));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"}]}