{"files":[{"patch":"@@ -55,2 +55,1 @@\n-            var outTensors = OnnxRuntime.getInstance().runOp(\n-                    schema.name(),\n+            var outTensors = OnnxRuntime.getInstance().runOp(Arena.ofAuto(), schema.name(),\n@@ -61,1 +60,1 @@\n-                    attributeMap, Arena.ofAuto());\n+                    attributeMap);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-    public static <T> Tensor<T> execute(MethodHandles.Lookup l, OnnxFunction<Tensor<T>> codeLambda) {\n-        return execute(l, Arena.ofAuto(), codeLambda);\n+    public static <T> Tensor<T> execute(MethodHandles.Lookup lookup, OnnxFunction<Tensor<T>> codeLambda) {\n+        return execute(Arena.ofAuto(), lookup, codeLambda);\n@@ -138,1 +138,1 @@\n-    public static <T> Tensor<T> execute(MethodHandles.Lookup l, Arena sessionArena, OnnxFunction<Tensor<T>> codeLambda) {\n+    public static <T> Tensor<T> execute(Arena arena, MethodHandles.Lookup lookup, OnnxFunction<Tensor<T>> codeLambda) {\n@@ -141,1 +141,1 @@\n-        var model = MODEL_CACHE.computeIfAbsent(codeLambda.getClass(), l, q);\n+        var model = MODEL_CACHE.computeIfAbsent(codeLambda.getClass(), lookup, q);\n@@ -151,2 +151,2 @@\n-            var session = getInstance().createSession(model.protoModel(), sessionArena);\n-            return session.run(arguments).getFirst();\n+            var session = getInstance().createSession(arena, model.protoModel());\n+            return session.run(arena, arguments).getFirst();\n@@ -260,1 +260,0 @@\n-    private final Arena         arena;\n@@ -264,1 +263,1 @@\n-        arena = Arena.ofAuto();\n+        var arena = Arena.ofAuto();\n@@ -270,1 +269,1 @@\n-        defaultAllocatorAddress = retAddr(OrtApi.GetAllocatorWithDefaultOptions(runtimeAddress, ret));\n+        defaultAllocatorAddress = retAddr(OrtApi.GetAllocatorWithDefaultOptions(runtimeAddress, ret)).reinterpret(arena, null);\n@@ -276,1 +275,1 @@\n-    public List<Tensor> runOp(String opName, List<Tensor> inputValues, int numOutputs, Map<String, Object> attributes, Arena sessionArena) {\n+    public List<Tensor> runOp(Arena arena, String opName, List<Tensor> inputValues, int numOutputs, Map<String, Object> attributes) {\n@@ -286,2 +285,2 @@\n-        return createSession(protoModel, sessionArena)\n-                .run(inputValues);\n+        return createSession(arena, protoModel)\n+                .run(arena, inputValues);\n@@ -290,1 +289,1 @@\n-    public List<Tensor> run(Block block, List<Tensor> inputValues, Arena sessionArena) {\n+    public List<Tensor> run(Arena arena, Block block, List<Tensor> inputValues) {\n@@ -292,2 +291,2 @@\n-        return createSession(protoModel, sessionArena)\n-                .run(inputValues);\n+        return createSession(arena, protoModel)\n+                .run(arena, inputValues);\n@@ -296,2 +295,2 @@\n-    public Session createSession(String modelPath, Arena sessionArena) {\n-        return createSession(modelPath, createSessionOptions(sessionArena), sessionArena);\n+    public Session createSession(Arena arena, String modelPath) {\n+        return createSession(arena, modelPath, createSessionOptions(arena));\n@@ -300,2 +299,2 @@\n-    public Session createSession(String modelPath, SessionOptions options, Arena sessionArena) {\n-        return new Session(retAddr(OrtApi.CreateSession(runtimeAddress, envAddress, sessionArena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)), sessionArena);\n+    public Session createSession(Arena arena, String modelPath, SessionOptions options) {\n+        return new Session(arena, retAddr(OrtApi.CreateSession(runtimeAddress, envAddress, arena.allocateFrom(modelPath), options.sessionOptionsAddress, ret)));\n@@ -304,2 +303,2 @@\n-    public Session createSession(byte[] model, Arena sessionArena) {\n-        return createSession(model, createSessionOptions(sessionArena), sessionArena);\n+    public Session createSession(Arena arena, byte[] model) {\n+        return createSession(arena, model, createSessionOptions(arena));\n@@ -308,2 +307,2 @@\n-    private Session createSession(byte[] model, SessionOptions options, Arena sessionArena) {\n-        return new Session(retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, sessionArena.allocateFrom(ValueLayout.JAVA_BYTE, model), model.length, options.sessionOptionsAddress, ret)), sessionArena);\n+    private Session createSession(Arena arena, byte[] model, SessionOptions options) {\n+        return new Session(arena, retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, arena.allocateFrom(ValueLayout.JAVA_BYTE, model), model.length, options.sessionOptionsAddress, ret)));\n@@ -315,1 +314,0 @@\n-        private final Arena sessionArena;\n@@ -317,3 +315,2 @@\n-        private Session(MemorySegment sessionAddress, Arena sessionArena) {\n-            this.sessionArena = sessionArena;\n-            this.sessionAddress = sessionAddress.reinterpret(sessionArena,\n+        private Session(Arena arena, MemorySegment sessionAddress) {\n+            this.sessionAddress = sessionAddress.reinterpret(arena,\n@@ -340,1 +337,1 @@\n-        public List<Tensor> run(List<Tensor> inputValues) {\n+        public List<Tensor> run(Arena arena, List<Tensor> inputValues) {\n@@ -344,2 +341,2 @@\n-            var inputNames = sessionArena.allocate(C_POINTER, inputLen);\n-            var inputs = sessionArena.allocate(C_POINTER, inputLen);\n+            var inputNames = arena.allocate(C_POINTER, inputLen);\n+            var inputs = arena.allocate(C_POINTER, inputLen);\n@@ -348,1 +345,1 @@\n-                inputNames.setAtIndex(C_POINTER, index, sessionArena.allocateFrom(getInputName(i)));\n+                inputNames.setAtIndex(C_POINTER, index, arena.allocateFrom(getInputName(i)));\n@@ -351,2 +348,2 @@\n-            var outputNames = sessionArena.allocate(C_POINTER, outputLen);\n-            var outputs = sessionArena.allocate(C_POINTER, outputLen);\n+            var outputNames = arena.allocate(C_POINTER, outputLen);\n+            var outputs = arena.allocate(C_POINTER, outputLen);\n@@ -354,1 +351,1 @@\n-                outputNames.setAtIndex(C_POINTER, i, sessionArena.allocateFrom(getOutputName(i)));\n+                outputNames.setAtIndex(C_POINTER, i, arena.allocateFrom(getOutputName(i)));\n@@ -360,2 +357,4 @@\n-                retArr[i] = new Tensor(outputs.getAtIndex(C_POINTER, i)\n-                        .reinterpret(sessionArena, value -> OrtApi.ReleaseValue(runtimeAddress, value)));\n+                var tensorAddr = outputs.getAtIndex(C_POINTER, i)\n+                        .reinterpret(arena, value -> OrtApi.ReleaseValue(runtimeAddress, value));\n+                retArr[i] = new Tensor(tensorData(tensorAddr).reinterpret(arena, null),\n+                                       tensorAddr);\n@@ -367,1 +366,1 @@\n-    public MemorySegment createTensor(MemorySegment flatData, Tensor.ElementType elementType, long[] shape) {\n+    public MemorySegment createTensor(MemorySegment flatData, Tensor.ElementType elementType, MemorySegment shape) {\n@@ -369,2 +368,1 @@\n-        var shapeAddr = shape.length == 0 ? MemorySegment.NULL : arena.allocateFrom(C_LONG_LONG, shape);\n-        return retAddr(OrtApi.CreateTensorWithDataAsOrtValue(runtimeAddress, allocatorInfo, flatData, flatData.byteSize(), shapeAddr, shape.length, elementType.id, ret));\n+        return retAddr(OrtApi.CreateTensorWithDataAsOrtValue(runtimeAddress, allocatorInfo, flatData, flatData.byteSize(), shape, shape.byteSize() \/ 8, elementType.id, ret));\n@@ -379,5 +377,7 @@\n-        var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n-        long dims = retLong(OrtApi.GetDimensionsCount(runtimeAddress, infoAddr, ret));\n-        var shape = arena.allocate(C_LONG_LONG, dims);\n-        checkStatus(OrtApi.GetDimensions(runtimeAddress, infoAddr, shape, dims));\n-        return shape.toArray(C_LONG_LONG);\n+        try (var arena = Arena.ofConfined()) {\n+            var infoAddr = retAddr(OrtApi.GetTensorTypeAndShape(runtimeAddress, tensorAddr, ret));\n+            long dims = retLong(OrtApi.GetDimensionsCount(runtimeAddress, infoAddr, ret));\n+            var shape = arena.allocate(C_LONG_LONG, dims);\n+            checkStatus(OrtApi.GetDimensions(runtimeAddress, infoAddr, shape, dims));\n+            return shape.toArray(C_LONG_LONG);\n+        }\n@@ -394,1 +394,1 @@\n-    public SessionOptions createSessionOptions(Arena sessionArena) {\n+    public SessionOptions createSessionOptions(Arena arena) {\n@@ -396,1 +396,1 @@\n-                .reinterpret(sessionArena, opts -> OrtApi.ReleaseSessionOptions(runtimeAddress, opts)));\n+                .reinterpret(arena, opts -> OrtApi.ReleaseSessionOptions(runtimeAddress, opts)));\n@@ -415,2 +415,1 @@\n-        return ret.get(C_POINTER, 0)\n-                .reinterpret(arena, null);\n+        return ret.get(C_POINTER, 0);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":47,"deletions":48,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static oracle.code.onnx.foreign.onnxruntime_c_api_h.C_LONG_LONG;\n+\n@@ -69,2 +71,5 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_BYTE, b ? (byte)1 : 0);\n-        return new Tensor(data, ElementType.BOOL, SCALAR_SHAPE);\n+        return ofScalar(Arena.ofAuto(), b);\n+    }\n+\n+    public static Tensor<Boolean> ofScalar(Arena arena, boolean b) {\n+        return new Tensor(arena, arena.allocateFrom(ValueLayout.JAVA_BYTE, b ? (byte)1 : 0), ElementType.BOOL, SCALAR_SHAPE);\n@@ -77,0 +82,4 @@\n+    public static Tensor<Byte> ofScalar(Arena arena, byte b) {\n+        return ofShape(arena, SCALAR_SHAPE, b);\n+    }\n+\n@@ -81,0 +90,4 @@\n+    public static Tensor<Long> ofScalar(Arena arena, long l) {\n+        return ofShape(arena, SCALAR_SHAPE, l);\n+    }\n+\n@@ -85,0 +98,4 @@\n+    public static Tensor<Float> ofScalar(Arena arena, float f) {\n+        return ofShape(arena, SCALAR_SHAPE, f);\n+    }\n+\n@@ -90,0 +107,4 @@\n+    public static Tensor<Byte> ofFlat(Arena arena, byte... values) {\n+        return ofShape(arena, new long[]{values.length}, values);\n+    }\n+\n@@ -94,0 +115,4 @@\n+    public static Tensor<Long> ofFlat(Arena arena, long... values) {\n+        return ofShape(arena, new long[]{values.length}, values);\n+    }\n+\n@@ -98,0 +123,4 @@\n+    public static Tensor<Float> ofFlat(Arena arena, float... values) {\n+        return ofShape(arena, new long[]{values.length}, values);\n+    }\n+\n@@ -99,2 +128,5 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_BYTE, values);\n-        return new Tensor(data, ElementType.UINT8, shape);\n+        return ofShape(Arena.ofAuto(), shape, values);\n+    }\n+\n+    public static Tensor<Byte> ofShape(Arena arena, long[] shape, byte... values) {\n+        return new Tensor(arena, arena.allocateFrom(ValueLayout.JAVA_BYTE, values), ElementType.UINT8, shape);\n@@ -104,2 +136,5 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_LONG, values);\n-        return new Tensor(data, ElementType.INT64, shape);\n+        return ofShape(Arena.ofAuto(), shape, values);\n+    }\n+\n+    public static Tensor<Long> ofShape(Arena arena, long[] shape, long... values) {\n+        return new Tensor(arena, arena.allocateFrom(ValueLayout.JAVA_LONG, values), ElementType.INT64, shape);\n@@ -109,2 +144,5 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_FLOAT, values);\n-        return new Tensor(data, ElementType.FLOAT, shape);\n+        return ofShape(Arena.ofAuto(), shape, values);\n+    }\n+\n+    public static Tensor<Float> ofShape(Arena arena, long[] shape, float... values) {\n+        return new Tensor(arena, arena.allocateFrom(ValueLayout.JAVA_FLOAT, values), ElementType.FLOAT, shape);\n@@ -117,6 +155,2 @@\n-    public Tensor(MemorySegment dataAddr, ElementType type, long... shape) {\n-        this(dataAddr, OnnxRuntime.getInstance().createTensor(dataAddr, type, shape));\n-    }\n-\n-    public Tensor(MemorySegment tensorAddr) {\n-        this(OnnxRuntime.getInstance().tensorData(tensorAddr), tensorAddr);\n+    public Tensor(Arena arena, MemorySegment dataAddr, ElementType type, long[] shape) {\n+        this(dataAddr, OnnxRuntime.getInstance().createTensor(dataAddr, type, shape.length == 0 ? MemorySegment.NULL : arena.allocateFrom(C_LONG_LONG, shape)));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-            return new Tensor(file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length(), ARENA), Tensor.ElementType.FLOAT, shape);\n+            return new Tensor(ARENA, file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length(), ARENA), Tensor.ElementType.FLOAT, shape);\n@@ -393,1 +393,1 @@\n-            Tensor<Byte> inputImage = new Tensor(imagesIn, Tensor.ElementType.UINT8, new long[]{imagesF.length() - IMAGES_HEADER_SIZE});\n+            Tensor<Byte> inputImage = new Tensor(ARENA, imagesIn, Tensor.ElementType.UINT8, new long[]{imagesF.length() - IMAGES_HEADER_SIZE});\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -19,1 +19,1 @@\n-            var absOp = ort.createSession(build(\n+            var absOp = ort.createSession(arena, build(\n@@ -22,1 +22,1 @@\n-                    List.of(\"y\")), arena);\n+                    List.of(\"y\")));\n@@ -24,4 +24,4 @@\n-             var addOp = ort.createSession(build(\n-                List.of(tensorInfo(\"a\", FLOAT.id), tensorInfo(\"b\", FLOAT.id)),\n-                List.of(node(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n-                List.of(\"y\")), arena);\n+             var addOp = ort.createSession(arena, build(\n+                     List.of(tensorInfo(\"a\", FLOAT.id), tensorInfo(\"b\", FLOAT.id)),\n+                     List.of(node(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n+                     List.of(\"y\")));\n@@ -39,1 +39,1 @@\n-            var absResult = absOp.run(List.of(inputTensor));\n+            var absResult = absOp.run(arena, List.of(inputTensor));\n@@ -47,1 +47,1 @@\n-            var addResult = addOp.run(List.of(inputTensor, absOutputTensor));\n+            var addResult = addOp.run(arena, List.of(inputTensor, absOutputTensor));\n@@ -63,17 +63,17 @@\n-        var ifOp = ort.createSession(build(\n-                List.of(tensorInfo(\"cond\", BOOL.id), tensorInfo(\"a\", INT64.id), tensorInfo(\"b\", INT64.id)),\n-                List.of(node(\"If\", List.of(\"cond\"), List.of(\"y\"), Map.of(\n-                        \"then_branch\", graph(\n-                                List.of(),\n-                                List.of(node(\"Identity\", List.of(\"a\"), List.of(\"y\"), Map.of())),\n-                                List.of(\"y\")),\n-                        \"else_branch\", graph(\n-                                List.of(),\n-                                List.of(node(\"Identity\", List.of(\"b\"), List.of(\"y\"), Map.of())),\n-                                List.of(\"y\"))))),\n-                List.of(\"y\")), arena);\n-\n-            var a = Tensor.ofScalar(1l);\n-            var b = Tensor.ofScalar(2l);\n-            SimpleTest.assertEquals(a, ifOp.run(List.of(Tensor.ofScalar(true), a, b)).getFirst());\n-            SimpleTest.assertEquals(b, ifOp.run(List.of(Tensor.ofScalar(false), a, b)).getFirst());\n+            var ifOp = ort.createSession(arena, build(\n+                    List.of(tensorInfo(\"cond\", BOOL.id), tensorInfo(\"a\", INT64.id), tensorInfo(\"b\", INT64.id)),\n+                    List.of(node(\"If\", List.of(\"cond\"), List.of(\"y\"), Map.of(\n+                            \"then_branch\", graph(\n+                                    List.of(),\n+                                    List.of(node(\"Identity\", List.of(\"a\"), List.of(\"y\"), Map.of())),\n+                                    List.of(\"y\")),\n+                            \"else_branch\", graph(\n+                                    List.of(),\n+                                    List.of(node(\"Identity\", List.of(\"b\"), List.of(\"y\"), Map.of())),\n+                                    List.of(\"y\"))))),\n+                    List.of(\"y\")));\n+\n+            var a = Tensor.ofScalar(arena, 1l);\n+            var b = Tensor.ofScalar(arena, 2l);\n+            SimpleTest.assertEquals(a, ifOp.run(arena, List.of(Tensor.ofScalar(arena, true), a, b)).getFirst());\n+            SimpleTest.assertEquals(b, ifOp.run(arena, List.of(Tensor.ofScalar(arena, false), a, b)).getFirst());\n@@ -87,1 +87,1 @@\n-            var forOp = ort.createSession(build(\n+            var forOp = ort.createSession(arena, build(\n@@ -95,1 +95,1 @@\n-                    List.of(\"a_out\")), arena);\n+                    List.of(\"a_out\")));\n@@ -97,1 +97,2 @@\n-            SimpleTest.assertEquals(Tensor.ofScalar(65536l), forOp.run(List.of(Tensor.ofScalar(15l), Tensor.ofScalar(true), Tensor.ofScalar(2l))).getFirst());\n+            SimpleTest.assertEquals(Tensor.ofScalar(arena, 65536l),\n+                    forOp.run(arena, List.of(Tensor.ofScalar(arena, 15l), Tensor.ofScalar(arena, true), Tensor.ofScalar(arena, 2l))).getFirst());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.image.BufferedImage;\n@@ -113,1 +110,1 @@\n-            var predictionTensor = OnnxRuntime.execute(MethodHandles.lookup(), arena,\n+            var predictionTensor = OnnxRuntime.execute(arena, MethodHandles.lookup(),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/mnist\/MNISTDemo.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}