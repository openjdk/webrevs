{"files":[{"patch":"@@ -98,1 +98,0 @@\n-    java.datatransfer \\\n@@ -101,4 +100,0 @@\n-    java.logging \\\n-    java.management.rmi \\\n-    java.naming \\\n-    java.net.http \\\n@@ -108,9 +103,1 @@\n-    java.scripting \\\n-    java.se \\\n-    java.security.sasl \\\n-    java.sql \\\n-    java.sql.rowset \\\n-    java.transaction.xa \\\n-    java.xml \\\n-    java.xml.crypto \\\n-    jdk.charsets \\\n+    jdk.attach \\\n@@ -121,3 +108,2 @@\n-    jdk.dynalink \\\n-    jdk.httpserver \\\n-    jdk.incubator.vector \\\n+    jdk.crypto.mscapi \\\n+    jdk.hotspot.agent \\\n@@ -126,0 +112,1 @@\n+    jdk.jdi \\\n@@ -127,2 +114,1 @@\n-    jdk.jsobject \\\n-    jdk.localedata \\\n+    jdk.jpackage \\\n@@ -131,4 +117,0 @@\n-    jdk.management.jfr \\\n-    jdk.naming.dns \\\n-    jdk.naming.rmi \\\n-    jdk.nio.mapmode \\\n@@ -138,4 +120,0 @@\n-    jdk.security.jgss \\\n-    jdk.unsupported \\\n-    jdk.xml.dom \\\n-    jdk.zipfs \\\n","filename":"make\/conf\/module-loader-map.conf","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-                new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType()).addMethod(clb);\n+                new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType()).addMethod(clb, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.misc.CDS;\n+import jdk.internal.util.ClassFileDumper;\n+import sun.invoke.util.VerifyAccess;\n+import sun.security.action.GetBooleanAction;\n@@ -37,3 +41,2 @@\n-import java.lang.classfile.attribute.ExceptionsAttribute;\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -41,0 +44,1 @@\n+import java.lang.constant.DynamicConstantDesc;\n@@ -53,11 +57,4 @@\n-import jdk.internal.constant.ConstantUtils;\n-import jdk.internal.constant.MethodTypeDescImpl;\n-import jdk.internal.constant.ReferenceClassDescImpl;\n-import jdk.internal.misc.CDS;\n-import jdk.internal.util.ClassFileDumper;\n-import sun.invoke.util.VerifyAccess;\n-import sun.invoke.util.Wrapper;\n-import sun.security.action.GetBooleanAction;\n-\n-import java.lang.classfile.constantpool.MethodHandleEntry;\n-import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -66,0 +63,2 @@\n+import static java.lang.invoke.MethodHandleNatives.Constants.NESTMATE_CLASS;\n+import static java.lang.invoke.MethodHandleNatives.Constants.STRONG_LOADER_LINK;\n@@ -69,0 +68,4 @@\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n+import sun.invoke.util.Wrapper;\n@@ -82,6 +85,0 @@\n-    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(flags);\n-        }\n-    };\n@@ -134,1 +131,2 @@\n-    private final ClassDesc lambdaClassDesc;         \/\/ Type descriptor for the generated class \"X$$Lambda$1\"\n+    private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+    private final ClassEntry lambdaClassEntry;       \/\/ Class entry for the generated class \"X$$Lambda$1\"\n@@ -171,3 +169,0 @@\n-     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n-     *                   method handle that is used to retrieve the string representation of the\n-     *                   quotable lambda's associated intermediate representation.\n@@ -198,2 +193,1 @@\n-        constructorTypeDesc = methodDesc(constructorType);\n-        lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n+        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n@@ -224,0 +218,1 @@\n+        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -232,1 +227,1 @@\n-        return name.replace('.', '\/') + \"$$Lambda\";\n+        return name.replace('.', '\/').concat(\"$$Lambda\");\n@@ -262,1 +257,1 @@\n-                    Object inst = mh.asType(methodType(Object.class)).invokeExact();\n+                    Object inst = mh.invokeBasic();\n@@ -344,1 +339,1 @@\n-        final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+        final byte[] classBytes = ClassFile.of().build(lambdaClassEntry, pool, new Consumer<ClassBuilder>() {\n@@ -351,1 +346,1 @@\n-                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -366,1 +361,1 @@\n-                clb.withMethod(interfaceMethodName,\n+                clb.withMethodBody(interfaceMethodName,\n@@ -374,1 +369,1 @@\n-                        clb.withMethod(interfaceMethodName,\n+                        clb.withMethodBody(interfaceMethodName,\n@@ -404,1 +399,1 @@\n-            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, Set.of(NESTMATE, STRONG), lambdaProxyClassFileDumper)\n+            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, lambdaProxyClassFileDumper, NESTMATE_CLASS | STRONG_LOADER_LINK)\n@@ -419,1 +414,1 @@\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -422,1 +417,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -426,1 +421,1 @@\n-                cob.new_(lambdaClassDesc)\n+                cob.new_(lambdaClassEntry)\n@@ -428,2 +423,2 @@\n-                   .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n-                   .putstatic(lambdaClassDesc, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)\n+                   .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                   .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)))\n@@ -432,1 +427,1 @@\n-        }));\n+        });\n@@ -440,2 +435,2 @@\n-        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new Consumer<>() {\n@@ -451,1 +446,1 @@\n-                            cob.putfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -458,1 +453,1 @@\n-                }));\n+                });\n@@ -486,1 +481,1 @@\n-               .getfield(lambdaClassDesc, argNames[capturedArity + i], argDescs[capturedArity + i]);\n+               .getfield(lambdaClassEntry.asSymbol(), argNames[capturedArity + i], argDescs[capturedArity + i]);\n@@ -494,1 +489,1 @@\n-           .putfield(lambdaClassDesc, quotedInstanceFieldName, CD_Quoted);\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CD_Quoted);\n@@ -521,2 +516,2 @@\n-        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new Consumer<>() {\n@@ -542,1 +537,1 @@\n-                               .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -550,1 +545,1 @@\n-                }));\n+                });\n@@ -561,1 +556,1 @@\n-                   .getfield(lambdaClassDesc, quotedInstanceFieldName, CD_Quoted)\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CD_Quoted)\n@@ -600,2 +595,2 @@\n-    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n-        return new MethodBody(new Consumer<CodeBuilder>() {\n+    Consumer<CodeBuilder> forwardingMethod(MethodType methodType) {\n+        return new Consumer<>() {\n@@ -615,1 +610,1 @@\n-                       .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -638,1 +633,1 @@\n-        });\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":49,"deletions":54,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -106,0 +106,2 @@\n+    \/\/ Hash code of this object\n+    private int                 hash;\n@@ -183,15 +185,0 @@\n-    \/**\n-     * Make a copy of a leaf method.\n-     *\/\n-    Method leafCopy() {\n-        if (this.root == null)\n-            throw new IllegalArgumentException(\"Can only leafCopy a non-root Method\");\n-\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n-                exceptionTypes, modifiers, slot, signature,\n-                annotations, parameterAnnotations, annotationDefault);\n-        res.root = root;\n-        res.methodAccessor = methodAccessor;\n-        return res;\n-    }\n-\n@@ -451,1 +438,7 @@\n-        return getDeclaringClass().getName().hashCode() ^ getName().hashCode();\n+        int hc = hash;\n+\n+        if (hc == 0) {\n+            hc = hash = getDeclaringClass().getName().hashCode() ^ getName()\n+                .hashCode();\n+        }\n+        return hc;\n@@ -832,1 +825,1 @@\n-     * @jls 9.6.2 Defaults for Annotation Type Elements\n+     * @jls 9.6.2 Defaults for Annotation Interface Elements\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+\n@@ -50,1 +52,1 @@\n-            if (coe instanceof BranchInstruction bi && bi.opcode().isUnconditionalBranch()) {\n+            if (coe instanceof BranchInstruction bi && BytecodeHelpers.isUnconditionalBranch(bi.opcode())) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        return ClassFile.of().transform(generatedModel, LocalsCompactor.INSTANCE);\n+        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n@@ -512,1 +512,1 @@\n-            case JavaType _ -> TypeKind.ReferenceType;\n+            case JavaType _ -> TypeKind.REFERENCE;\n@@ -668,4 +668,4 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ineg();\n-                            case LongType -> cob.lneg();\n-                            case FloatType -> cob.fneg();\n-                            case DoubleType -> cob.dneg();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.ineg();\n+                            case LONG -> cob.lneg();\n+                            case FLOAT -> cob.fneg();\n+                            case DOUBLE -> cob.dneg();\n@@ -680,1 +680,1 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> {\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> {\n@@ -684,1 +684,1 @@\n-                            case LongType -> {\n+                            case LONG -> {\n@@ -700,4 +700,4 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iadd();\n-                            case LongType -> cob.ladd();\n-                            case FloatType -> cob.fadd();\n-                            case DoubleType -> cob.dadd();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.iadd();\n+                            case LONG -> cob.ladd();\n+                            case FLOAT -> cob.fadd();\n+                            case DOUBLE -> cob.dadd();\n@@ -711,4 +711,4 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.isub();\n-                            case LongType -> cob.lsub();\n-                            case FloatType -> cob.fsub();\n-                            case DoubleType -> cob.dsub();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.isub();\n+                            case LONG -> cob.lsub();\n+                            case FLOAT -> cob.fsub();\n+                            case DOUBLE -> cob.dsub();\n@@ -722,4 +722,4 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.imul();\n-                            case LongType -> cob.lmul();\n-                            case FloatType -> cob.fmul();\n-                            case DoubleType -> cob.dmul();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.imul();\n+                            case LONG -> cob.lmul();\n+                            case FLOAT -> cob.fmul();\n+                            case DOUBLE -> cob.dmul();\n@@ -733,4 +733,4 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.idiv();\n-                            case LongType -> cob.ldiv();\n-                            case FloatType -> cob.fdiv();\n-                            case DoubleType -> cob.ddiv();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.idiv();\n+                            case LONG -> cob.ldiv();\n+                            case FLOAT -> cob.fdiv();\n+                            case DOUBLE -> cob.ddiv();\n@@ -744,4 +744,4 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.irem();\n-                            case LongType -> cob.lrem();\n-                            case FloatType -> cob.frem();\n-                            case DoubleType -> cob.drem();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.irem();\n+                            case LONG -> cob.lrem();\n+                            case FLOAT -> cob.frem();\n+                            case DOUBLE -> cob.drem();\n@@ -755,2 +755,2 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iand();\n-                            case LongType -> cob.land();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.iand();\n+                            case LONG -> cob.land();\n@@ -764,2 +764,2 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ior();\n-                            case LongType -> cob.lor();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.ior();\n+                            case LONG -> cob.lor();\n@@ -773,2 +773,2 @@\n-                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ixor();\n-                            case LongType -> cob.lxor();\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.ixor();\n+                            case LONG -> cob.lxor();\n@@ -783,2 +783,2 @@\n-                            case ByteType, CharType, IntType, ShortType -> cob.ishl();\n-                            case LongType -> cob.lshl();\n+                            case BYTE, CHAR, INT, SHORT -> cob.ishl();\n+                            case LONG -> cob.lshl();\n@@ -793,2 +793,2 @@\n-                            case IntType, ByteType, ShortType, CharType -> cob.ishr();\n-                            case LongType -> cob.lshr();\n+                            case INT, BYTE, SHORT, CHAR -> cob.ishr();\n+                            case LONG -> cob.lshr();\n@@ -803,2 +803,2 @@\n-                            case IntType, ByteType, ShortType, CharType -> cob.iushr();\n-                            case LongType -> cob.lushr();\n+                            case INT, BYTE, SHORT, CHAR -> cob.iushr();\n+                            case LONG -> cob.lushr();\n@@ -1022,1 +1022,1 @@\n-                    if (returnType != TypeKind.VoidType) {\n+                    if (returnType != TypeKind.VOID) {\n@@ -1090,1 +1090,1 @@\n-            cob.conversion(toTypeKind(right), TypeKind.IntType);\n+            cob.conversion(toTypeKind(right), TypeKind.INT);\n@@ -1169,1 +1169,1 @@\n-                case IntType, BooleanType, ByteType, ShortType, CharType ->\n+                case INT, BOOLEAN, BYTE, SHORT, CHAR ->\n@@ -1180,1 +1180,1 @@\n-                case ReferenceType ->\n+                case REFERENCE ->\n@@ -1193,1 +1193,1 @@\n-            case IntType, BooleanType, ByteType, ShortType, CharType ->\n+            case INT, BOOLEAN, BYTE, SHORT, CHAR ->\n@@ -1204,1 +1204,1 @@\n-            case ReferenceType ->\n+            case REFERENCE ->\n@@ -1211,1 +1211,1 @@\n-            case FloatType -> {\n+            case FLOAT -> {\n@@ -1215,1 +1215,1 @@\n-            case LongType -> {\n+            case LONG -> {\n@@ -1219,1 +1219,1 @@\n-            case DoubleType -> {\n+            case DOUBLE -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":49,"deletions":49,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+\n@@ -236,6 +238,6 @@\n-                case ITEM_INTEGER -> params.add(JavaType.INT);\n-                case ITEM_FLOAT -> params.add(JavaType.FLOAT);\n-                case ITEM_DOUBLE -> params.add(JavaType.DOUBLE);\n-                case ITEM_LONG -> params.add(JavaType.LONG);\n-                case ITEM_NULL -> params.add(JavaType.J_L_OBJECT);\n-                case ITEM_UNINITIALIZED_THIS ->\n+                case INTEGER -> params.add(JavaType.INT);\n+                case FLOAT -> params.add(JavaType.FLOAT);\n+                case DOUBLE -> params.add(JavaType.DOUBLE);\n+                case LONG -> params.add(JavaType.LONG);\n+                case NULL -> params.add(JavaType.J_L_OBJECT);\n+                case UNINITIALIZED_THIS ->\n@@ -383,1 +385,1 @@\n-                case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                case BranchInstruction inst when BytecodeHelpers.isUnconditionalBranch(inst.opcode()) -> {\n@@ -399,6 +401,6 @@\n-                        case IF_ICMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ICMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ICMPGE -> unifyOperands(CoreOp::lt, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ICMPLE -> unifyOperands(CoreOp::gt, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ICMPGT -> unifyOperands(CoreOp::le, stack.pop(), operand, TypeKind.IntType);\n-                        case IF_ICMPLT -> unifyOperands(CoreOp::ge, stack.pop(), operand, TypeKind.IntType);\n+                        case IF_ICMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPGE -> unifyOperands(CoreOp::lt, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPLE -> unifyOperands(CoreOp::gt, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPGT -> unifyOperands(CoreOp::le, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPLT -> unifyOperands(CoreOp::ge, stack.pop(), operand, TypeKind.INT);\n@@ -422,1 +424,1 @@\n-                case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                case ReturnInstruction inst when inst.typeKind() == TypeKind.VOID -> {\n@@ -448,8 +450,8 @@\n-                        case ByteType -> JavaType.BYTE;\n-                        case ShortType -> JavaType.SHORT;\n-                        case IntType -> JavaType.INT;\n-                        case FloatType -> JavaType.FLOAT;\n-                        case LongType -> JavaType.LONG;\n-                        case DoubleType -> JavaType.DOUBLE;\n-                        case CharType -> JavaType.CHAR;\n-                        case BooleanType -> JavaType.BOOLEAN;\n+                        case BYTE -> JavaType.BYTE;\n+                        case SHORT -> JavaType.SHORT;\n+                        case INT -> JavaType.INT;\n+                        case FLOAT -> JavaType.FLOAT;\n+                        case LONG -> JavaType.LONG;\n+                        case DOUBLE -> JavaType.DOUBLE;\n+                        case CHAR -> JavaType.CHAR;\n+                        case BOOLEAN -> JavaType.BOOLEAN;\n@@ -686,8 +688,8 @@\n-                                case BooleanType -> JavaType.BOOLEAN_ARRAY;\n-                                case ByteType -> JavaType.BYTE_ARRAY;\n-                                case CharType -> JavaType.CHAR_ARRAY;\n-                                case DoubleType -> JavaType.DOUBLE_ARRAY;\n-                                case FloatType -> JavaType.FLOAT_ARRAY;\n-                                case IntType -> JavaType.INT_ARRAY;\n-                                case LongType -> JavaType.LONG_ARRAY;\n-                                case ShortType -> JavaType.SHORT_ARRAY;\n+                                case BOOLEAN -> JavaType.BOOLEAN_ARRAY;\n+                                case BYTE -> JavaType.BYTE_ARRAY;\n+                                case CHAR -> JavaType.CHAR_ARRAY;\n+                                case DOUBLE -> JavaType.DOUBLE_ARRAY;\n+                                case FLOAT -> JavaType.FLOAT_ARRAY;\n+                                case INT -> JavaType.INT_ARRAY;\n+                                case LONG -> JavaType.LONG_ARRAY;\n+                                case SHORT -> JavaType.SHORT_ARRAY;\n@@ -878,9 +880,9 @@\n-            case BooleanType -> false;\n-            case ByteType -> (byte)0;\n-            case CharType -> (char)0;\n-            case DoubleType -> 0d;\n-            case FloatType -> 0f;\n-            case IntType -> 0;\n-            case LongType -> 0l;\n-            case ReferenceType -> null;\n-            case ShortType -> (short)0;\n+            case BOOLEAN -> false;\n+            case BYTE -> (byte)0;\n+            case CHAR -> (char)0;\n+            case DOUBLE -> 0d;\n+            case FLOAT -> 0f;\n+            case INT -> 0;\n+            case LONG -> 0l;\n+            case REFERENCE -> null;\n+            case SHORT -> (short)0;\n@@ -1004,1 +1006,1 @@\n-        if (tk != TypeKind.IntType || valueType(v1).equals(valueType(v2))) return operator.apply(v1, v2);\n+        if (tk != TypeKind.INT || valueType(v1).equals(valueType(v2))) return operator.apply(v1, v2);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":42,"deletions":40,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -315,2 +315,2 @@\n-            if (vti != ITEM_TOP) {\n-                if (vti == ITEM_LONG || vti == ITEM_DOUBLE) {\n+            if (vti != TOP) {\n+                if (vti == LONG || vti == DOUBLE) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsCompactor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.NULL;\n@@ -478,1 +479,1 @@\n-            i += vti == ITEM_DOUBLE || vti == ITEM_LONG ? 2 : 1;\n+            i += vti == DOUBLE || vti == LONG ? 2 : 1;\n@@ -526,6 +527,6 @@\n-            case ITEM_INTEGER -> CD_int;\n-            case ITEM_FLOAT -> CD_float;\n-            case ITEM_DOUBLE -> CD_double;\n-            case ITEM_LONG -> CD_long;\n-            case ITEM_UNINITIALIZED_THIS -> thisClass;\n-            case ITEM_NULL -> NULL_TYPE;\n+            case INTEGER -> CD_int;\n+            case FLOAT -> CD_float;\n+            case DOUBLE -> CD_double;\n+            case LONG -> CD_long;\n+            case UNINITIALIZED_THIS -> thisClass;\n+            case NULL -> NULL_TYPE;\n@@ -537,1 +538,1 @@\n-            case ITEM_TOP -> null;\n+            case TOP -> null;\n@@ -701,1 +702,1 @@\n-                pop(1).push(ClassDesc.ofDescriptor(i.toType().descriptor()));\n+                pop(1).push(i.toType().upperBound());\n@@ -746,1 +747,1 @@\n-                pop(1).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()).arrayType());\n+                pop(1).push(i.typeKind().upperBound().arrayType());\n@@ -753,1 +754,1 @@\n-                }).push(ClassDesc.ofDescriptor(i.typeKind().descriptor()));\n+                }).push(i.typeKind().upperBound());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+        jdk.management,\n@@ -267,1 +268,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-     *         where the provided ModuleSymbol is any\n+     *         where the provided ModuleElement is any\n@@ -64,1 +64,1 @@\n-     *         {@link #getAllModuleElements() all modules} for observable\n+     *         {@linkplain #getAllModuleElements() all modules} for observable\n@@ -147,1 +147,1 @@\n-     *         where the provided ModuleSymbol is any\n+     *         where the provided ModuleElement is any\n@@ -151,1 +151,1 @@\n-     *         {@link #getAllModuleElements() all modules} for observable\n+     *         {@linkplain #getAllModuleElements() all modules} for observable\n@@ -621,1 +621,1 @@\n-     * declared directly.  For a class the result also includes its\n+     * declared directly.  For a class, the result also includes its\n@@ -882,4 +882,4 @@\n-     * enclosing the accessor has kind {@link ElementKind#RECORD RECORD} if that is\n-     * the case, then all the record components on the accessor's enclosing element\n-     * are retrieved by invoking {@link ElementFilter#recordComponentsIn(Iterable)}.\n-     * If the accessor of at least one of the record components retrieved happen to\n+     * enclosing the accessor has kind {@link ElementKind#RECORD RECORD}, if that is\n+     * the case, then all the record components of the accessor's enclosing element\n+     * are isolated by invoking {@link ElementFilter#recordComponentsIn(Iterable)}.\n+     * If the accessor of at least one of the record components retrieved happens to\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import static com.sun.tools.javac.main.Option.DOE;\n+\n@@ -102,0 +104,1 @@\n+    public final boolean dumpStacktraceOnError;\n@@ -123,0 +126,2 @@\n+        Options options = Options.instance(context);\n+        dumpStacktraceOnError = options.isSet(\"dev\") || options.isSet(DOE);\n@@ -713,1 +718,1 @@\n-    public static class FunctionDescriptorLookupError extends RuntimeException {\n+    public static class FunctionDescriptorLookupError extends CompilerInternalException {\n@@ -718,1 +723,2 @@\n-        FunctionDescriptorLookupError() {\n+        FunctionDescriptorLookupError(boolean dumpStackTraceOnError) {\n+            super(dumpStackTraceOnError);\n@@ -730,6 +736,0 @@\n-\n-        @Override\n-        public Throwable fillInStackTrace() {\n-            \/\/ This is an internal exception; the stack trace is irrelevant.\n-            return this;\n-        }\n@@ -888,1 +888,1 @@\n-            return new FunctionDescriptorLookupError().setMessage(diag);\n+            return new FunctionDescriptorLookupError(Types.this.dumpStacktraceOnError).setMessage(diag);\n@@ -5186,1 +5186,1 @@\n-    public abstract static class SignatureGenerator {\n+    public abstract class SignatureGenerator {\n@@ -5188,1 +5188,1 @@\n-        public static class InvalidSignatureException extends RuntimeException {\n+        public class InvalidSignatureException extends CompilerInternalException {\n@@ -5193,1 +5193,2 @@\n-            InvalidSignatureException(Type type) {\n+            InvalidSignatureException(Type type, boolean dumpStackTraceOnError) {\n+                super(dumpStackTraceOnError);\n@@ -5200,6 +5201,0 @@\n-\n-            @Override\n-            public Throwable fillInStackTrace() {\n-                \/\/ This is an internal exception; the stack trace is irrelevant.\n-                return this;\n-            }\n@@ -5208,2 +5203,0 @@\n-        private final Types types;\n-\n@@ -5215,5 +5208,1 @@\n-        protected SignatureGenerator(Types types) {\n-            this.types = types;\n-        }\n-\n-            throw new InvalidSignatureException(t);\n+            throw new InvalidSignatureException(t, Types.this.dumpStacktraceOnError);\n@@ -5336,1 +5325,1 @@\n-                        c.name == types.names.empty; \/\/ or anonymous\n+                        c.name == Types.this.names.empty; \/\/ or anonymous\n@@ -5338,1 +5327,1 @@\n-                        ? types.erasure(outer)\n+                        ? Types.this.erasure(outer)\n@@ -5360,1 +5349,1 @@\n-                List<Type> bounds = types.getBounds(tvar);\n+                List<Type> bounds = Types.this.getBounds(tvar);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":28,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+        initBlockType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);\n@@ -650,0 +651,1 @@\n+    final MethodType initBlockType;\n@@ -1443,1 +1445,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, initBlockType,\n@@ -3647,14 +3649,0 @@\n-        \/* Map to hold 'fake' clinit methods. If a lambda is used to initialize a\n-         * static field and that lambda has type annotations, these annotations will\n-         * also be stored at these fake clinit methods.\n-         *\n-         * LambdaToMethod also use fake clinit methods so they can be reused.\n-         * Also as LTM is a phase subsequent to attribution, the methods from\n-         * clinits can be safely removed by LTM to save memory.\n-         *\/\n-        private Map<ClassSymbol, MethodSymbol> clinits = new HashMap<>();\n-\n-        public MethodSymbol removeClinit(ClassSymbol sym) {\n-            return clinits.remove(sym);\n-        }\n-\n@@ -3665,5 +3653,2 @@\n-         * is not a method, for example if the lambda is used to initialize\n-         * a field, then if the field is:\n-         *\n-         * - an instance field, we use the first constructor.\n-         * - a static field, we create a fake clinit method.\n+         * is not a method (e.g. if the lambda occurs in a field initializer), then\n+         * a synthetic method symbol owner is created.\n@@ -3675,1 +3660,3 @@\n-                \/\/field initializer\n+                \/\/ If the lambda is nested in a field initializer, we need to create a fake init method.\n+                \/\/ Uniqueness of this symbol is not important (as e.g. annotations will be added on the\n+                \/\/ init symbol's owner).\n@@ -3677,26 +3664,5 @@\n-                Symbol newScopeOwner = env.info.scope.owner;\n-                \/* if the field isn't static, then we can get the first constructor\n-                 * and use it as the owner of the environment. This is what\n-                 * LTM code is doing to look for type annotations so we are fine.\n-                 *\/\n-                if ((owner.flags() & STATIC) == 0) {\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n-                        newScopeOwner = s;\n-                        break;\n-                    }\n-                } else {\n-                    \/* if the field is static then we need to create a fake clinit\n-                     * method, this method can later be reused by LTM.\n-                     *\/\n-                    MethodSymbol clinit = clinits.get(enclClass);\n-                    if (clinit == null) {\n-                        Type clinitType = new MethodType(List.nil(),\n-                                syms.voidType, List.nil(), syms.methodClass);\n-                        clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,\n-                                names.clinit, clinitType, enclClass);\n-                        clinit.params = List.nil();\n-                        clinits.put(enclClass, clinit);\n-                    }\n-                    newScopeOwner = clinit;\n-                }\n-                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));\n+                Name initName = owner.isStatic() ? names.clinit : names.init;\n+                MethodSymbol initSym = new MethodSymbol(BLOCK | (owner.isStatic() ? STATIC : 0) | SYNTHETIC | PRIVATE,\n+                        initName, initBlockType, enclClass);\n+                initSym.params = List.nil();\n+                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(initSym)));\n@@ -4059,0 +4025,1 @@\n+            fExpr.owner = env.info.scope.owner;\n@@ -4769,3 +4736,0 @@\n-            if (pt.isErroneous()) {\n-                return types.createErrorType(site);\n-            }\n@@ -4880,0 +4844,4 @@\n+            if (pt.isErroneous()) {\n+                owntype = types.createErrorType(owntype);\n+            }\n+\n@@ -5203,0 +5171,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n@@ -5363,8 +5339,1 @@\n-        Type underlyingType =\n-                attribTree(tree.underlyingType, env, new ResultInfo(KindSelector.TYP_PCK, Type.noType));\n-        if (underlyingType.hasTag(PACKAGE)) {\n-            \/\/ Type annotations are not admissible on packages, but we handle packages here to\n-            \/\/ report better diagnostics later in validateAnnotatedType.\n-            result = tree.type = underlyingType;\n-            return;\n-        }\n+        Type underlyingType = attribType(tree.underlyingType, env);\n@@ -5380,1 +5349,12 @@\n-            Env<AttrContext> errEnv = env.dup(env.tree, env.info.dup());\n+            WriteableScope newScope = env.info.scope;\n+\n+            if (env.tree instanceof JCClassDecl) {\n+                Symbol fakeOwner =\n+                    new MethodSymbol(BLOCK, names.empty, null,\n+                        env.info.scope.owner);\n+                newScope = newScope.dupUnshared(fakeOwner);\n+            }\n+\n+            Env<AttrContext> errEnv =\n+                    env.dup(env.tree,\n+                            env.info.dup(newScope));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":39,"deletions":59,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -28,10 +28,1 @@\n-import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n-import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;\n-import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n-import com.sun.tools.javac.resources.CompilerProperties.Errors;\n-import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n-import com.sun.tools.javac.tree.*;\n-import com.sun.tools.javac.tree.JCTree.*;\n-import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n-import com.sun.tools.javac.tree.TreeMaker;\n-import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.code.Flags;\n@@ -42,0 +33,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n@@ -43,1 +35,0 @@\n-import com.sun.tools.javac.code.Symbol.TypeSymbol;\n@@ -48,3 +39,5 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n-import com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.*;\n-import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;\n+import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n+import com.sun.tools.javac.main.Option;\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -53,2 +46,29 @@\n-import com.sun.tools.javac.jvm.*;\n-import com.sun.tools.javac.util.*;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCAnnotation;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCBreak;\n+import com.sun.tools.javac.tree.JCTree.JCCase;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCStatement;\n+import com.sun.tools.javac.tree.JCTree.JCSwitch;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.DiagnosticSource;\n+import com.sun.tools.javac.util.InvalidUtfException;\n+import com.sun.tools.javac.util.JCDiagnostic;\n@@ -56,1 +76,6 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n@@ -58,1 +83,2 @@\n-import java.util.EnumMap;\n+import javax.lang.model.element.ElementKind;\n+import java.lang.invoke.LambdaMetafactory;\n@@ -61,2 +87,0 @@\n-import java.util.LinkedHashMap;\n-import java.util.Optional;\n@@ -68,10 +92,17 @@\n-import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;\n-import static com.sun.tools.javac.code.Flags.*;\n-import static com.sun.tools.javac.code.Kinds.Kind.*;\n-import static com.sun.tools.javac.code.TypeTag.*;\n-import static com.sun.tools.javac.tree.JCTree.Tag.*;\n-\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.type.TypeKind;\n-\n-import com.sun.tools.javac.main.Option;\n+import static com.sun.tools.javac.code.Flags.ABSTRACT;\n+import static com.sun.tools.javac.code.Flags.BLOCK;\n+import static com.sun.tools.javac.code.Flags.DEFAULT;\n+import static com.sun.tools.javac.code.Flags.FINAL;\n+import static com.sun.tools.javac.code.Flags.INTERFACE;\n+import static com.sun.tools.javac.code.Flags.LAMBDA_METHOD;\n+import static com.sun.tools.javac.code.Flags.LOCAL_CAPTURE_FIELD;\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.PRIVATE;\n+import static com.sun.tools.javac.code.Flags.STATIC;\n+import static com.sun.tools.javac.code.Flags.STRICTFP;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Kinds.Kind.MTH;\n+import static com.sun.tools.javac.code.Kinds.Kind.TYP;\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.VOID;\n@@ -89,8 +120,8 @@\n-    private Attr attr;\n-    private JCDiagnostic.Factory diags;\n-    private Log log;\n-    private Lower lower;\n-    private Names names;\n-    private Symtab syms;\n-    private Resolve rs;\n-    private Operators operators;\n+    private final Attr attr;\n+    private final JCDiagnostic.Factory diags;\n+    private final Log log;\n+    private final Lower lower;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Resolve rs;\n+    private final Operators operators;\n@@ -98,2 +129,2 @@\n-    private Types types;\n-    private TransTypes transTypes;\n+    private final Types types;\n+    private final TransTypes transTypes;\n@@ -102,9 +133,0 @@\n-    \/** the analyzer scanner *\/\n-    private LambdaAnalyzerPreprocessor analyzer;\n-\n-    \/** map from lambda trees to translation contexts *\/\n-    private Map<JCTree, TranslationContext<?>> contextMap;\n-\n-    \/** current translation context (visitor argument) *\/\n-    private TranslationContext<?> context;\n-\n@@ -114,0 +136,6 @@\n+    \/** translation context of the current lambda expression *\/\n+    private LambdaTranslationContext lambdaContext;\n+\n+    \/** the variable whose initializer is pending *\/\n+    private VarSymbol pendingVar;\n+\n@@ -129,4 +157,1 @@\n-    \/** lambda proxy is a dynamic nestmate *\/\n-    private final boolean nestmateLambdas;\n-\n-    public static final int FLAG_SERIALIZABLE = 1 << 0;\n+    public static final int FLAG_SERIALIZABLE = LambdaMetafactory.FLAG_SERIALIZABLE;\n@@ -136,1 +161,1 @@\n-    public static final int FLAG_MARKERS = 1 << 1;\n+    public static final int FLAG_MARKERS = LambdaMetafactory.FLAG_MARKERS;\n@@ -139,1 +164,1 @@\n-    public static final int FLAG_BRIDGES = 1 << 2;\n+    public static final int FLAG_BRIDGES = LambdaMetafactory.FLAG_BRIDGES;\n@@ -166,1 +191,0 @@\n-        analyzer = new LambdaAnalyzerPreprocessor();\n@@ -172,2 +196,2 @@\n-            options.isUnset(Option.G_CUSTOM) ||\n-            options.isSet(Option.G_CUSTOM, \"lines\");\n+                options.isUnset(Option.G_CUSTOM) ||\n+                        options.isSet(Option.G_CUSTOM, \"lines\");\n@@ -175,3 +199,3 @@\n-            options.isUnset(Option.G_CUSTOM)\n-            ? options.isSet(Option.G)\n-            : options.isSet(Option.G_CUSTOM, \"vars\");\n+                options.isUnset(Option.G_CUSTOM)\n+                        ? options.isSet(Option.G)\n+                        : options.isSet(Option.G_CUSTOM, \"vars\");\n@@ -181,1 +205,0 @@\n-        nestmateLambdas = Target.instance(context).runtimeUseNestAccess();\n@@ -196,1 +219,0 @@\n-\n@@ -219,1 +241,1 @@\n-        private ListBuffer<JCTree> appendedMethodList;\n+        private ListBuffer<JCTree> appendedMethodList = new ListBuffer<>();\n@@ -221,1 +243,1 @@\n-        private Map<DedupedLambda, DedupedLambda> dedupedLambdas;\n+        private final Map<DedupedLambda, DedupedLambda> dedupedLambdas = new HashMap<>();\n@@ -223,1 +245,1 @@\n-        private Map<Object, DynamicMethodSymbol> dynMethSyms = new HashMap<>();\n+        private final Map<Object, DynamicMethodSymbol> dynMethSyms = new HashMap<>();\n@@ -228,1 +250,1 @@\n-        private final Map<String, ListBuffer<JCStatement>> deserializeCases;\n+        private final Map<String, ListBuffer<JCStatement>> deserializeCases = new HashMap<>();\n@@ -230,1 +252,1 @@\n-       \/**\n+        \/**\n@@ -242,0 +264,2 @@\n+        private final Map<String, Integer> syntheticNames = new HashMap<>();\n+\n@@ -244,3 +268,0 @@\n-            appendedMethodList = new ListBuffer<>();\n-            dedupedLambdas = new HashMap<>();\n-            deserializeCases = new HashMap<>();\n@@ -257,23 +278,8 @@\n-    }\n-\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"translate methods\">\n-    @Override\n-    public <T extends JCTree> T translate(T tree) {\n-        TranslationContext<?> newContext = contextMap.get(tree);\n-        return translate(tree, newContext != null ? newContext : context);\n-    }\n-    <T extends JCTree> T translate(T tree, TranslationContext<?> newContext) {\n-        TranslationContext<?> prevContext = context;\n-        try {\n-            context = newContext;\n-            return super.translate(tree);\n-        }\n-        finally {\n-            context = prevContext;\n-        }\n-    }\n-\n-    <T extends JCTree> List<T> translate(List<T> trees, TranslationContext<?> newContext) {\n-        ListBuffer<T> buf = new ListBuffer<>();\n-        for (T tree : trees) {\n-            buf.append(translate(tree, newContext));\n+        int syntheticNameIndex(StringBuilder buf, int start) {\n+            String temp = buf.toString();\n+            Integer count = syntheticNames.get(temp);\n+            if (count == null) {\n+                count = start;\n+            }\n+            syntheticNames.put(temp, count + 1);\n+            return count;\n@@ -282,1 +288,0 @@\n-        return buf.toList();\n@@ -285,0 +290,1 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"visitor methods\">\n@@ -288,2 +294,0 @@\n-        this.context = null;\n-        this.contextMap = new HashMap<>();\n@@ -292,2 +296,0 @@\n-    \/\/ <\/editor-fold>\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"visitor methods\">\n@@ -299,1 +301,0 @@\n-     * @param tree\n@@ -303,4 +304,3 @@\n-        if (tree.sym.owner.kind == PCK) {\n-            \/\/analyze class\n-            tree = analyzer.analyzeAndPreprocessClass(tree);\n-        }\n+        DiagnosticSource prevSource = log.currentSource();\n+        LambdaTranslationContext prevLambdaContext = lambdaContext;\n+        VarSymbol prevPendingVar = pendingVar;\n@@ -310,0 +310,3 @@\n+            log.useSource(tree.sym.sourcefile);\n+            lambdaContext = null;\n+            pendingVar = null;\n@@ -311,0 +314,3 @@\n+            if (prevLambdaContext != null) {\n+                tree.sym.owner = prevLambdaContext.translatedSym;\n+            }\n@@ -315,1 +321,1 @@\n-                    kInfo.addMethod(makeDeserializeMethod(tree.sym));\n+                    kInfo.addMethod(makeDeserializeMethod());\n@@ -329,0 +335,3 @@\n+            log.useSource(prevSource.getFile());\n+            lambdaContext = prevLambdaContext;\n+            pendingVar = prevPendingVar;\n@@ -336,1 +345,0 @@\n-     * @param tree\n@@ -340,1 +348,1 @@\n-        LambdaTranslationContext localContext = (LambdaTranslationContext)context;\n+        LambdaTranslationContext localContext = new LambdaTranslationContext(tree);\n@@ -351,1 +359,1 @@\n-            Symbol owner = localContext.owner;\n+            Symbol owner = tree.owner;\n@@ -357,4 +365,4 @@\n-\n-            boolean init;\n-            if ((init = (owner.name == names.init)) || owner.name == names.clinit) {\n-                owner = owner.owner;\n+            final long ownerFlags = owner.flags();\n+            if ((ownerFlags & Flags.BLOCK) != 0) {\n+                ClassSymbol cs = (ClassSymbol) owner.owner;\n+                boolean isStaticInit = (ownerFlags & Flags.STATIC) != 0;\n@@ -362,2 +370,2 @@\n-                        init ? owner::getInitTypeAttributes : owner::getClassInitTypeAttributes,\n-                        init ? owner::setInitTypeAttributes : owner::setClassInitTypeAttributes,\n+                        isStaticInit ? cs::getClassInitTypeAttributes : cs::getInitTypeAttributes,\n+                        isStaticInit ? cs::setClassInitTypeAttributes : cs::setInitTypeAttributes,\n@@ -366,2 +374,2 @@\n-            if (localContext.self != null && localContext.self.getKind() == ElementKind.FIELD) {\n-                owner = localContext.self;\n+\n+            if (pendingVar != null && pendingVar.getKind() == ElementKind.FIELD) {\n@@ -369,2 +377,2 @@\n-                        owner::getRawTypeAttributes,\n-                        owner::setTypeAttributes,\n+                        pendingVar::getRawTypeAttributes,\n+                        pendingVar::setTypeAttributes,\n@@ -382,2 +390,2 @@\n-                    List.nil() :\n-                    make.Types(lambdaType.getThrownTypes()),\n+                        List.nil() :\n+                        make.Types(lambdaType.getThrownTypes()),\n@@ -389,22 +397,0 @@\n-        \/\/translate lambda body\n-        \/\/As the lambda body is translated, all references to lambda locals,\n-        \/\/captured variables, enclosing members are adjusted accordingly\n-        \/\/to refer to the static method parameters (rather than i.e. accessing\n-        \/\/captured members directly).\n-        lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));\n-\n-        boolean dedupe = false;\n-        if (deduplicateLambdas && !debugLinesOrVars && !localContext.isSerializable()) {\n-            DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);\n-            DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);\n-            if (existing != null) {\n-                sym = existing.symbol;\n-                dedupe = true;\n-                if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));\n-            }\n-        }\n-        if (!dedupe) {\n-            \/\/Add the method to the list of methods to be added to this class.\n-            kInfo.addMethod(lambdaDecl);\n-        }\n-\n@@ -424,3 +410,1 @@\n-        if (localContext.methodReferenceReceiver != null) {\n-            syntheticInits.append(localContext.methodReferenceReceiver);\n-        } else if (!sym.isStatic()) {\n+        if (!sym.isStatic()) {\n@@ -429,1 +413,1 @@\n-                    localContext.owner.enclClass()));\n+                    tree.owner.enclClass()));\n@@ -433,9 +417,2 @@\n-        for (Symbol fv : localContext.getSymbolMap(CAPTURED_VAR).keySet()) {\n-            if (fv != localContext.self) {\n-                JCExpression captured_local = make.Ident(fv).setType(fv.type);\n-                syntheticInits.append(captured_local);\n-            }\n-        }\n-        \/\/ add captured outer this instances (used only when `this' capture itself is illegal)\n-        for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {\n-            JCExpression captured_local = make.QualThis(fv.type);\n+        for (Symbol fv : localContext.capturedVars) {\n+            JCExpression captured_local = make.Ident(fv).setType(fv.type);\n@@ -445,1 +422,2 @@\n-        if (context.isQuotable()) {\n+        \/\/add quotable captures\n+        if (isQuotable(tree)) {\n@@ -452,1 +430,29 @@\n-        List<JCExpression> indy_args = translate(syntheticInits.toList(), localContext.prev);\n+        List<JCExpression> indy_args = translate(syntheticInits.toList());\n+\n+        LambdaTranslationContext prevLambdaContext = lambdaContext;\n+        try {\n+            lambdaContext = localContext;\n+            \/\/translate lambda body\n+            \/\/As the lambda body is translated, all references to lambda locals,\n+            \/\/captured variables, enclosing members are adjusted accordingly\n+            \/\/to refer to the static method parameters (rather than i.e. accessing\n+            \/\/captured members directly).\n+            lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));\n+        } finally {\n+            lambdaContext = prevLambdaContext;\n+        }\n+\n+        boolean dedupe = false;\n+        if (deduplicateLambdas && !debugLinesOrVars && !isSerializable(tree)) {\n+            DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);\n+            DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);\n+            if (existing != null) {\n+                sym = existing.symbol;\n+                dedupe = true;\n+                if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));\n+            }\n+        }\n+        if (!dedupe) {\n+            \/\/Add the method to the list of methods to be added to this class.\n+            kInfo.addMethod(lambdaDecl);\n+        }\n@@ -455,1 +461,1 @@\n-        result = makeMetafactoryIndyCall(context, sym.asHandle(), indy_args);\n+        result = makeMetafactoryIndyCall(tree, sym.asHandle(), localContext.translatedSym, indy_args);\n@@ -459,19 +465,14 @@\n-        \/\/ Reassign type annotations from the source that should really belong to the lambda\n-        private void apportionTypeAnnotations(JCLambda tree,\n-                                              Supplier<List<Attribute.TypeCompound>> source,\n-                                              Consumer<List<Attribute.TypeCompound>> owner,\n-                                              Consumer<List<Attribute.TypeCompound>> lambda) {\n-\n-            ListBuffer<Attribute.TypeCompound> ownerTypeAnnos = new ListBuffer<>();\n-            ListBuffer<Attribute.TypeCompound> lambdaTypeAnnos = new ListBuffer<>();\n-\n-            for (Attribute.TypeCompound tc : source.get()) {\n-                if (tc.position.onLambda == tree) {\n-                    lambdaTypeAnnos.append(tc);\n-                } else {\n-                    ownerTypeAnnos.append(tc);\n-                }\n-            }\n-            if (lambdaTypeAnnos.nonEmpty()) {\n-                owner.accept(ownerTypeAnnos.toList());\n-                lambda.accept(lambdaTypeAnnos.toList());\n+    \/\/ Reassign type annotations from the source that should really belong to the lambda\n+    private void apportionTypeAnnotations(JCLambda tree,\n+                                          Supplier<List<Attribute.TypeCompound>> source,\n+                                          Consumer<List<Attribute.TypeCompound>> owner,\n+                                          Consumer<List<Attribute.TypeCompound>> lambda) {\n+\n+        ListBuffer<Attribute.TypeCompound> ownerTypeAnnos = new ListBuffer<>();\n+        ListBuffer<Attribute.TypeCompound> lambdaTypeAnnos = new ListBuffer<>();\n+\n+        for (Attribute.TypeCompound tc : source.get()) {\n+            if (tc.position.onLambda == tree) {\n+                lambdaTypeAnnos.append(tc);\n+            } else {\n+                ownerTypeAnnos.append(tc);\n@@ -480,0 +481,5 @@\n+        if (lambdaTypeAnnos.nonEmpty()) {\n+            owner.accept(ownerTypeAnnos.toList());\n+            lambda.accept(lambdaTypeAnnos.toList());\n+        }\n+    }\n@@ -492,1 +498,0 @@\n-     * @param tree\n@@ -496,2 +501,0 @@\n-        ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;\n-\n@@ -503,30 +506,19 @@\n-        JCExpression init;\n-        switch(tree.kind) {\n-\n-            case IMPLICIT_INNER:    \/** Inner :: new *\/\n-            case SUPER:             \/** super :: instMethod *\/\n-                init = makeThis(\n-                    localContext.owner.enclClass().asType(),\n-                    localContext.owner.enclClass());\n-                break;\n-\n-            case BOUND:             \/** Expr :: instMethod *\/\n-                init = transTypes.coerce(attrEnv, tree.getQualifierExpression(),\n-                    types.erasure(tree.sym.owner.type));\n-                init = attr.makeNullCheck(init);\n-                break;\n-\n-            case UNBOUND:           \/** Type :: instMethod *\/\n-            case STATIC:            \/** Type :: staticMethod *\/\n-            case TOPLEVEL:          \/** Top level :: new *\/\n-            case ARRAY_CTOR:        \/** ArrayType :: new *\/\n-                init = null;\n-                break;\n-\n-            default:\n-                throw new InternalError(\"Should not have an invalid kind\");\n-        }\n-\n-        List<JCExpression> indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);\n-\n-        if (context.isQuotable()) {\n+        JCExpression init = switch (tree.kind) {\n+            case IMPLICIT_INNER,    \/* Inner :: new *\/\n+                 SUPER ->           \/* super :: instMethod *\/\n+                    makeThis(tree.owner.enclClass().asType(), tree.owner.enclClass());\n+            case BOUND ->           \/* Expr :: instMethod *\/\n+                    attr.makeNullCheck(transTypes.coerce(attrEnv, tree.getQualifierExpression(),\n+                            types.erasure(tree.sym.owner.type)));\n+            case UNBOUND,           \/* Type :: instMethod *\/\n+                 STATIC,            \/* Type :: staticMethod *\/\n+                 TOPLEVEL,          \/* Top level :: new *\/\n+                 ARRAY_CTOR ->      \/* ArrayType :: new *\/\n+                    null;\n+        };\n+\n+        List<JCExpression> indy_args = (init == null) ?\n+                List.nil() : translate(List.of(init));\n+\n+        \/\/ add quotable captures\n+        if (isQuotable(tree)) {\n@@ -538,2 +530,1 @@\n-\n-        result = makeMetafactoryIndyCall(localContext, refSym.asHandle(), indy_args);\n+        result = makeMetafactoryIndyCall(tree, refSym.asHandle(), refSym, indy_args);\n@@ -545,1 +536,0 @@\n-     * @param tree\n@@ -549,1 +539,1 @@\n-        if (context == null || !analyzer.lambdaIdentSymbolFilter(tree.sym)) {\n+        if (lambdaContext == null) {\n@@ -555,2 +545,0 @@\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n@@ -571,48 +559,0 @@\n-    \/**\n-     * Translate qualified `this' references within a lambda to the mapped identifier\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitSelect(JCFieldAccess tree) {\n-        if (context == null || !analyzer.lambdaFieldAccessFilter(tree)) {\n-            super.visitSelect(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                JCTree ltree = lambdaContext.translate(tree);\n-                if (ltree != null) {\n-                    result = ltree;\n-                } else {\n-                    super.visitSelect(tree);\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Translate instance creation expressions with implicit enclosing instances\n-     * @param tree\n-     *\/\n-    @Override\n-    public void visitNewClass(JCNewClass tree) {\n-        if (context == null || !analyzer.lambdaNewClassFilter(context, tree)) {\n-            super.visitNewClass(tree);\n-        } else {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;\n-                tree = lambdaContext.translate(tree);\n-                super.visitNewClass(tree);\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-    }\n-\n@@ -621,7 +561,12 @@\n-        LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;\n-        if (context != null && lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {\n-            tree.init = translate(tree.init);\n-            tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);\n-            result = tree;\n-        } else {\n-            super.visitVarDef(tree);\n+        VarSymbol prevPendingVar = pendingVar;\n+        try {\n+            pendingVar = tree.sym;\n+            if (lambdaContext != null) {\n+                tree.sym = lambdaContext.addLocal(tree.sym);\n+                tree.init = translate(tree.init);\n+                result = tree;\n+            } else {\n+                super.visitVarDef(tree);\n+            }\n+        } finally {\n+            pendingVar = prevPendingVar;\n@@ -695,1 +640,1 @@\n-                    VarSymbol loc = makeSyntheticVar(0, names.fromString(\"$loc\"), tree.expr.type, lambdaMethodDecl.sym);\n+                    VarSymbol loc = new VarSymbol(SYNTHETIC, names.fromString(\"$loc\"), tree.expr.type, lambdaMethodDecl.sym);\n@@ -714,1 +659,1 @@\n-    private JCMethodDecl makeDeserializeMethod(Symbol kSym) {\n+    private JCMethodDecl makeDeserializeMethod() {\n@@ -730,2 +675,2 @@\n-                    syms.illegalArgumentExceptionType,\n-                    List.of(make.Literal(\"Invalid lambda deserialization\"))))));\n+                        syms.illegalArgumentExceptionType,\n+                        List.of(make.Literal(\"Invalid lambda deserialization\"))))));\n@@ -733,7 +678,7 @@\n-                        names.deserializeLambda,\n-                        make.QualIdent(kInfo.deserMethodSym.getReturnType().tsym),\n-                        List.nil(),\n-                        List.of(make.VarDef(kInfo.deserParamSym, null)),\n-                        List.nil(),\n-                        body,\n-                        null);\n+                names.deserializeLambda,\n+                make.QualIdent(kInfo.deserMethodSym.getReturnType().tsym),\n+                List.nil(),\n+                List.of(make.VarDef(kInfo.deserParamSym, null)),\n+                List.nil(),\n+                body,\n+                null);\n@@ -743,1 +688,1 @@\n-        return deser;\n+        return lower.translateMethod(attrEnv, deser, make);\n@@ -753,1 +698,1 @@\n-            null, make.QualIdent(ctype.tsym), args, null);\n+                null, make.QualIdent(ctype.tsym), args, null);\n@@ -766,1 +711,1 @@\n-     }\n+    }\n@@ -797,6 +742,6 @@\n-                    kindTest,\n-                    \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n-                    \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n-                    \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n-                    \"getImplClass\", implClass),\n-                    \"getImplMethodSignature\", implMethodSignature),\n+                                                        kindTest,\n+                                                        \"getFunctionalInterfaceClass\", functionalInterfaceClass),\n+                                                \"getFunctionalInterfaceMethodName\", functionalInterfaceMethodName),\n+                                        \"getFunctionalInterfaceMethodSignature\", functionalInterfaceMethodSignature),\n+                                \"getImplClass\", implClass),\n+                        \"getImplMethodSignature\", implMethodSignature),\n@@ -804,4 +749,4 @@\n-                    pos,\n-                    syms.lambdaMetafactory,\n-                    names.altMetafactory,\n-                    staticArgs, indyType, serArgs.toList(), samSym.name)),\n+                        pos,\n+                        syms.lambdaMetafactory,\n+                        names.altMetafactory,\n+                        staticArgs, indyType, serArgs.toList(), samSym.name)),\n@@ -828,2 +773,2 @@\n-        JCBinary testExpr = make.Binary(JCTree.Tag.EQ, arg1, arg2);\n-        testExpr.operator = operators.resolveBinary(testExpr, JCTree.Tag.EQ, argType, argType);\n+        JCBinary testExpr = make.Binary(Tag.EQ, arg1, arg2);\n+        testExpr.operator = operators.resolveBinary(testExpr, Tag.EQ, argType, argType);\n@@ -842,2 +787,2 @@\n-        JCBinary compound = make.Binary(JCTree.Tag.AND, prev, eqtest);\n-        compound.operator = operators.resolveBinary(compound, JCTree.Tag.AND, syms.booleanType, syms.booleanType);\n+        JCBinary compound = make.Binary(Tag.AND, prev, eqtest);\n+        compound.operator = operators.resolveBinary(compound, Tag.AND, syms.booleanType, syms.booleanType);\n@@ -856,3 +801,3 @@\n-                    List.nil(),\n-                    make.Select(make.Ident(kInfo.deserParamSym).setType(syms.serializedLambdaType), getsym).setType(getmt),\n-                    args).setType(type);\n+                List.nil(),\n+                make.Select(make.Ident(kInfo.deserParamSym).setType(syms.serializedLambdaType), getsym).setType(getmt),\n+                args).setType(type);\n@@ -868,247 +813,0 @@\n-    \/**\n-     * Create new synthetic variable with given flags, name, type, owner\n-     *\/\n-    private VarSymbol makeSyntheticVar(long flags, Name name, Type type, Symbol owner) {\n-        return new VarSymbol(flags | SYNTHETIC, name, type, owner);\n-    }\n-\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-       Assert.check(meth.kind == MTH);\n-       List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-       if (varargsElement != null) {\n-           Assert.check((meth.flags() & VARARGS) != 0);\n-       }\n-       return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n-    \/\/ <\/editor-fold>\n-\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ReferenceTranslationContext localContext;\n-        private final Symbol owner;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree, ReferenceTranslationContext localContext, Symbol owner) {\n-            this.tree = tree;\n-            this.localContext = localContext;\n-            this.owner = owner;\n-        }\n-\n-        JCLambda lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.codeReflectionInfo = tree.codeReflectionInfo;\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                return slam;\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = localContext.bridgedRefSig();\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = addParameter(\"rec$\", tree.getQualifierExpression().type, false);\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        JCExpression getReceiverExpression() {\n-            return receiverExpression;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                                                                : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                        makeReceiver(rcvr) :\n-                        tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                    convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(localContext.tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n@@ -1118,3 +816,3 @@\n-                        type.getReturnType(),\n-                        type.getThrownTypes(),\n-                        syms.methodClass);\n+                type.getReturnType(),\n+                type.getThrownTypes(),\n+                syms.methodClass);\n@@ -1126,3 +824,3 @@\n-    private JCExpression makeMetafactoryIndyCall(TranslationContext<?> context,\n-            MethodHandleSymbol refSym, List<JCExpression> indy_args) {\n-        JCFunctionalExpression tree = context.tree;\n+    private JCExpression makeMetafactoryIndyCall(JCFunctionalExpression tree,\n+                                                 MethodHandleSymbol refSym, MethodSymbol nonDedupedRefSym,\n+                                                 List<JCExpression> indy_args) {\n@@ -1148,1 +846,9 @@\n-        Name metafactoryName = context.needsAltMetafactory() ?\n+        List<Symbol> bridges = bridges(tree);\n+        boolean isSerializable = isSerializable(tree);\n+        boolean isQuotable = isQuotable(tree);\n+        boolean needsAltMetafactory = tree.target.isIntersection() ||\n+                isSerializable || isQuotable || bridges.length() > 1;\n+\n+        dumpStats(tree, needsAltMetafactory, nonDedupedRefSym);\n+\n+        Name metafactoryName = needsAltMetafactory ?\n@@ -1151,1 +857,1 @@\n-        if (context.needsAltMetafactory()) {\n+        if (needsAltMetafactory) {\n@@ -1159,3 +865,3 @@\n-                    t.tsym != syms.quotableType.tsym &&\n-                    t.tsym != tree.type.tsym &&\n-                    t.tsym != syms.objectType.tsym) {\n+                        t.tsym != syms.quotableType.tsym &&\n+                        t.tsym != tree.type.tsym &&\n+                        t.tsym != syms.objectType.tsym) {\n@@ -1165,2 +871,2 @@\n-            int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;\n-            flags |= context.isQuotable() ? FLAG_QUOTABLE : 0;\n+            int flags = isSerializable ? FLAG_SERIALIZABLE : 0;\n+            flags |= isQuotable ? FLAG_QUOTABLE : 0;\n@@ -1168,1 +874,1 @@\n-            boolean hasBridges = context.bridges.nonEmpty();\n+            boolean hasBridges = bridges.nonEmpty();\n@@ -1181,2 +887,2 @@\n-                staticArgs = staticArgs.append(LoadableConstant.Int(context.bridges.length() - 1));\n-                for (Symbol s : context.bridges) {\n+                staticArgs = staticArgs.append(LoadableConstant.Int(bridges.length() - 1));\n+                for (Symbol s : bridges) {\n@@ -1189,1 +895,1 @@\n-            if (context.isQuotable()) {\n+            if (isQuotable) {\n@@ -1193,1 +899,1 @@\n-            if (context.isSerializable()) {\n+            if (isSerializable) {\n@@ -1219,2 +925,2 @@\n-                syms.stringType,\n-                syms.methodTypeType).appendList(staticArgs.map(types::constantType));\n+                    syms.stringType,\n+                    syms.methodTypeType).appendList(staticArgs.map(types::constantType));\n@@ -1227,4 +933,4 @@\n-                                            syms.noSymbol,\n-                                            bsm.asHandle(),\n-                                            indyType,\n-                                            staticArgs.toArray(new LoadableConstant[staticArgs.length()]));\n+                            syms.noSymbol,\n+                            bsm.asHandle(),\n+                            indyType,\n+                            staticArgs.toArray(new LoadableConstant[staticArgs.length()]));\n@@ -1245,50 +951,5 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Lambda\/reference analyzer\">\n-    \/**\n-     * This visitor collects information about translation of a lambda expression.\n-     * More specifically, it keeps track of the enclosing contexts and captured locals\n-     * accessed by the lambda being translated (as well as other useful info).\n-     * It also translates away problems for LambdaToMethod.\n-     *\/\n-    class LambdaAnalyzerPreprocessor extends TreeTranslator {\n-\n-        \/** the frame stack - used to reconstruct translation info about enclosing scopes *\/\n-        private List<Frame> frameStack;\n-\n-        \/**\n-         * keep the count of lambda expression (used to generate unambiguous\n-         * names)\n-         *\/\n-        private int lambdaCount = 0;\n-\n-        \/**\n-         * List of types undergoing construction, i.e., in an early construction context.\n-         *\/\n-        private List<ClassSymbol> typesUnderConstruction;\n-\n-        \/**\n-         * keep the count of lambda expression defined in given context (used to\n-         * generate unambiguous names for serializable lambdas)\n-         *\/\n-        private class SyntheticMethodNameCounter {\n-            private Map<String, Integer> map = new HashMap<>();\n-            int getIndex(StringBuilder buf) {\n-                String temp = buf.toString();\n-                Integer count = map.get(temp);\n-                if (count == null) {\n-                    count = 0;\n-                }\n-                ++count;\n-                map.put(temp, count);\n-                return count;\n-            }\n-        }\n-        private SyntheticMethodNameCounter syntheticMethodNameCounts =\n-                new SyntheticMethodNameCounter();\n-\n-        private Map<Symbol, JCClassDecl> localClassDefs;\n-\n-        \/**\n-         * maps for fake clinit symbols to be used as owners of lambda occurring in\n-         * a static var init context\n-         *\/\n-        private Map<ClassSymbol, Symbol> clinits = new HashMap<>();\n+    List<Symbol> bridges(JCFunctionalExpression tree) {\n+        ClassSymbol csym =\n+                types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);\n+        return types.functionalInterfaceBridges(csym);\n+    }\n@@ -1296,5 +957,4 @@\n-        private JCClassDecl analyzeAndPreprocessClass(JCClassDecl tree) {\n-            frameStack = List.nil();\n-            typesUnderConstruction = List.nil();\n-            localClassDefs = new HashMap<>();\n-            return translate(tree);\n+    \/** does this functional expression require serialization support? *\/\n+    boolean isSerializable(JCFunctionalExpression tree) {\n+        if (forceSerializable) {\n+            return true;\n@@ -1302,0 +962,2 @@\n+        return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n+    }\n@@ -1303,18 +965,3 @@\n-        @Override\n-        public void visitApply(JCMethodInvocation tree) {\n-            super.visitApply(tree);\n-            if (TreeInfo.isConstructorCall(tree)) {\n-                Assert.check(typesUnderConstruction.head == currentClass());\n-                typesUnderConstruction = typesUnderConstruction.tail;   \/\/ end of early construction context\n-            }\n-        }\n-            \/\/ where\n-            private ClassSymbol currentClass() {\n-                for (Frame frame : frameStack) {\n-                    if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                        JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                        return cdef.sym;\n-                    }\n-                }\n-                return null;\n-            }\n+    boolean isQuotable(JCFunctionalExpression tree) {\n+        return tree.codeReflectionInfo != null;\n+    }\n@@ -1322,11 +969,7 @@\n-        @Override\n-        public void visitBlock(JCBlock tree) {\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                if (frameStack.nonEmpty() && frameStack.head.tree.hasTag(CLASSDEF)) {\n-                    frameStack = frameStack.prepend(new Frame(tree));\n-                }\n-                super.visitBlock(tree);\n-            }\n-            finally {\n-                frameStack = prevStack;\n+    void dumpStats(JCFunctionalExpression tree, boolean needsAltMetafactory, Symbol sym) {\n+        if (dumpLambdaToMethodStats) {\n+            if (tree instanceof JCLambda lambda) {\n+                log.note(tree, diags.noteKey(lambda.wasMethodReference ? \"mref.stat.1\" : \"lambda.stat\",\n+                        needsAltMetafactory, sym));\n+            } else if (tree instanceof JCMemberReference) {\n+                log.note(tree, Notes.MrefStat(needsAltMetafactory, null));\n@@ -1335,0 +978,1 @@\n+    }\n@@ -1336,45 +980,6 @@\n-        @Override\n-        public void visitClassDef(JCClassDecl tree) {\n-            List<Frame> prevStack = frameStack;\n-            int prevLambdaCount = lambdaCount;\n-            SyntheticMethodNameCounter prevSyntheticMethodNameCounts =\n-                    syntheticMethodNameCounts;\n-            Map<ClassSymbol, Symbol> prevClinits = clinits;\n-            DiagnosticSource prevSource = log.currentSource();\n-            try {\n-                log.useSource(tree.sym.sourcefile);\n-                lambdaCount = 0;\n-                syntheticMethodNameCounts = new SyntheticMethodNameCounter();\n-                prevClinits = new HashMap<>();\n-                if (tree.sym.owner.kind == MTH) {\n-                    localClassDefs.put(tree.sym, tree);\n-                }\n-                if (directlyEnclosingLambda() != null) {\n-                    tree.sym.owner = owner();\n-                    if (tree.sym.hasOuterInstance()) {\n-                        \/\/if a class is defined within a lambda, the lambda must capture\n-                        \/\/its enclosing instance (if any)\n-                        TranslationContext<?> localContext = context();\n-                        final TypeSymbol outerInstanceSymbol = tree.sym.type.getEnclosingType().tsym;\n-                        while (localContext != null && !localContext.owner.isStatic()) {\n-                            if (localContext.tree.hasTag(LAMBDA)) {\n-                                JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                                if (block == null) break;\n-                                ((LambdaTranslationContext)localContext)\n-                                        .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                            }\n-                            localContext = localContext.prev;\n-                        }\n-                    }\n-                }\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                super.visitClassDef(tree);\n-            }\n-            finally {\n-                log.useSource(prevSource.getFile());\n-                frameStack = prevStack;\n-                lambdaCount = prevLambdaCount;\n-                syntheticMethodNameCounts = prevSyntheticMethodNameCounts;\n-                clinits = prevClinits;\n-            }\n-        }\n+    \/**\n+     * This class retains all the useful information about a lambda expression,\n+     * and acts as a translation map that is used by the main translation routines\n+     * in order to adjust references to captured locals\/members, etc.\n+     *\/\n+    class LambdaTranslationContext {\n@@ -1382,38 +987,2 @@\n-        @Override\n-        public void visitIdent(JCIdent tree) {\n-            if (context() != null && lambdaIdentSymbolFilter(tree.sym)) {\n-                if (tree.sym.kind == VAR &&\n-                        tree.sym.owner.kind == MTH &&\n-                        tree.type.constValue() == null) {\n-                    TranslationContext<?> localContext = context();\n-                    while (localContext != null) {\n-                        if (localContext.tree.getTag() == LAMBDA) {\n-                            JCTree block = capturedDecl(localContext.depth, tree.sym);\n-                            if (block == null) break;\n-                            ((LambdaTranslationContext)localContext)\n-                                    .addSymbol(tree.sym, CAPTURED_VAR);\n-                        }\n-                        localContext = localContext.prev;\n-                    }\n-                } else if (tree.sym.owner.kind == TYP) {\n-                    TranslationContext<?> localContext = context();\n-                    while (localContext != null  && !localContext.owner.isStatic()) {\n-                        if (localContext.tree.hasTag(LAMBDA)) {\n-                            JCTree block = capturedDecl(localContext.depth, tree.sym);\n-                            if (block == null) break;\n-                            switch (block.getTag()) {\n-                                case CLASSDEF:\n-                                    JCClassDecl cdecl = (JCClassDecl)block;\n-                                    ((LambdaTranslationContext)localContext)\n-                                            .addSymbol(cdecl.sym, CAPTURED_THIS);\n-                                    break;\n-                                default:\n-                                    Assert.error(\"bad block kind\");\n-                            }\n-                        }\n-                        localContext = localContext.prev;\n-                    }\n-                }\n-            }\n-            super.visitIdent(tree);\n-        }\n+        \/** the underlying (untranslated) tree *\/\n+        final JCFunctionalExpression tree;\n@@ -1421,4 +990,2 @@\n-        @Override\n-        public void visitLambda(JCLambda tree) {\n-            analyzeLambda(tree, \"lambda.stat\");\n-        }\n+        \/** a translation map from source symbols to translated symbols *\/\n+        final Map<VarSymbol, VarSymbol> lambdaProxies = new HashMap<>();\n@@ -1426,8 +993,2 @@\n-        private void analyzeLambda(JCLambda tree, JCExpression methodReferenceReceiver) {\n-            \/\/ Translation of the receiver expression must occur first\n-            JCExpression rcvr = translate(methodReferenceReceiver);\n-            LambdaTranslationContext context = analyzeLambda(tree, \"mref.stat.1\");\n-            if (rcvr != null) {\n-                context.methodReferenceReceiver = rcvr;\n-            }\n-        }\n+        \/** the list of symbols captured by this lambda expression *\/\n+        final List<VarSymbol> capturedVars;\n@@ -1435,21 +996,2 @@\n-        private LambdaTranslationContext analyzeLambda(JCLambda tree, String statKey) {\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                LambdaTranslationContext context = new LambdaTranslationContext(tree);\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                for (JCVariableDecl param : tree.params) {\n-                    context.addSymbol(param.sym, PARAM);\n-                    frameStack.head.addLocal(param.sym);\n-                }\n-                contextMap.put(tree, context);\n-                super.visitLambda(tree);\n-                context.complete();\n-                if (dumpLambdaToMethodStats) {\n-                    log.note(tree, diags.noteKey(statKey, context.needsAltMetafactory(), context.translatedSym));\n-                }\n-                return context;\n-            }\n-            finally {\n-                frameStack = prevStack;\n-            }\n-        }\n+        \/** the synthetic symbol for the method hoisting the translated lambda *\/\n+        final MethodSymbol translatedSym;\n@@ -1457,14 +999,2 @@\n-        @Override\n-        public void visitMethodDef(JCMethodDecl tree) {\n-            List<ClassSymbol> prevTypesUnderConstruction = typesUnderConstruction;\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                if (TreeInfo.isConstructor(tree))       \/\/ start early construction context (Object() notwithstanding)\n-                    typesUnderConstruction = typesUnderConstruction.prepend(currentClass());\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                super.visitMethodDef(tree);\n-            } finally {\n-                frameStack = prevStack;\n-                typesUnderConstruction = prevTypesUnderConstruction;\n-            }\n-        }\n+        \/** the list of parameter declarations of the translated lambda method *\/\n+        final List<JCVariableDecl> syntheticParams;\n@@ -1472,62 +1002,10 @@\n-        @Override\n-        public void visitNewClass(JCNewClass tree) {\n-            TypeSymbol def = tree.type.tsym;\n-            boolean inReferencedClass = currentlyInClass(def);\n-            boolean isLocal = def.isDirectlyOrIndirectlyLocal();\n-            if ((inReferencedClass && isLocal || lambdaNewClassFilter(context(), tree))) {\n-                TranslationContext<?> localContext = context();\n-                final TypeSymbol outerInstanceSymbol = tree.type.getEnclosingType().tsym;\n-                while (localContext != null  && !localContext.owner.isStatic()) {\n-                    if (localContext.tree.hasTag(LAMBDA)) {\n-                        if (outerInstanceSymbol != null) {\n-                            JCTree block = capturedDecl(localContext.depth, outerInstanceSymbol);\n-                            if (block == null) break;\n-                        }\n-                        ((LambdaTranslationContext)localContext)\n-                                .addSymbol(outerInstanceSymbol, CAPTURED_THIS);\n-                    }\n-                    localContext = localContext.prev;\n-                }\n-            }\n-            super.visitNewClass(tree);\n-            if (context() != null && !inReferencedClass && isLocal) {\n-                LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context();\n-                captureLocalClassDefs(def, lambdaContext);\n-            }\n-        }\n-        \/\/where\n-            void captureLocalClassDefs(Symbol csym, final LambdaTranslationContext lambdaContext) {\n-                JCClassDecl localCDef = localClassDefs.get(csym);\n-                if (localCDef != null && lambdaContext.freeVarProcessedLocalClasses.add(csym)) {\n-                    BasicFreeVarCollector fvc = lower.new BasicFreeVarCollector() {\n-                        @Override\n-                        void addFreeVars(ClassSymbol c) {\n-                            captureLocalClassDefs(c, lambdaContext);\n-                        }\n-                        @Override\n-                        void visitSymbol(Symbol sym) {\n-                            if (sym.kind == VAR &&\n-                                    sym.owner.kind == MTH &&\n-                                    ((VarSymbol)sym).getConstValue() == null) {\n-                                TranslationContext<?> localContext = context();\n-                                while (localContext != null) {\n-                                    if (localContext.tree.getTag() == LAMBDA) {\n-                                        JCTree block = capturedDecl(localContext.depth, sym);\n-                                        if (block == null) break;\n-                                        ((LambdaTranslationContext)localContext).addSymbol(sym, CAPTURED_VAR);\n-                                    }\n-                                    localContext = localContext.prev;\n-                                }\n-                            }\n-                        }\n-                    };\n-                    fvc.scan(localCDef);\n-                }\n-        }\n-        \/\/where\n-        boolean currentlyInClass(Symbol csym) {\n-            for (Frame frame : frameStack) {\n-                if (frame.tree.hasTag(JCTree.Tag.CLASSDEF)) {\n-                    JCClassDecl cdef = (JCClassDecl) frame.tree;\n-                    if (cdef.sym == csym) {\n-                        return true;\n+        LambdaTranslationContext(JCLambda tree) {\n+            this.tree = tree;\n+            \/\/ This symbol will be filled-in in complete\n+            Symbol owner = tree.owner;\n+            if (owner.kind == MTH) {\n+                final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);\n+                this.translatedSym = new MethodSymbol(0, null, null, owner.enclClass()) {\n+                    @Override\n+                    public MethodSymbol originalEnclosingMethod() {\n+                        return originalOwner;\n@@ -1535,3 +1013,50 @@\n-                }\n-            }\n-            return false;\n+                };\n+            } else {\n+                this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());\n+            }\n+            ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+            ListBuffer<VarSymbol> parameterSymbols = new ListBuffer<>();\n+            LambdaCaptureScanner captureScanner = new LambdaCaptureScanner(tree);\n+            capturedVars = captureScanner.analyzeCaptures();\n+            for (VarSymbol captured : capturedVars) {\n+                VarSymbol trans = addSymbol(captured, LambdaSymbolKind.CAPTURED_VAR);\n+                params.append(make.VarDef(trans, null));\n+                parameterSymbols.add(trans);\n+            }\n+            for (JCVariableDecl param : tree.params) {\n+                VarSymbol trans = addSymbol(param.sym, LambdaSymbolKind.PARAM);\n+                params.append(make.VarDef(trans, null));\n+                parameterSymbols.add(trans);\n+            }\n+            syntheticParams = params.toList();\n+            completeLambdaMethodSymbol(owner, captureScanner.capturesThis);\n+            translatedSym.params = parameterSymbols.toList();\n+        }\n+\n+        void completeLambdaMethodSymbol(Symbol owner, boolean thisReferenced) {\n+            boolean inInterface = owner.enclClass().isInterface();\n+\n+            \/\/ Compute and set the lambda name\n+            Name name = isSerializable(tree)\n+                    ? serializedLambdaName(owner)\n+                    : lambdaName(owner);\n+\n+            \/\/prepend synthetic args to translated lambda method signature\n+            Type type = types.createMethodTypeWithParameters(\n+                    generatedLambdaSig(),\n+                    TreeInfo.types(syntheticParams));\n+\n+            \/\/ If instance access isn't needed, make it static.\n+            \/\/ Interface instance methods must be default methods.\n+            \/\/ Lambda methods are private synthetic.\n+            \/\/ Inherit ACC_STRICT from the enclosing method, or, for clinit,\n+            \/\/ from the class.\n+            long flags = SYNTHETIC | LAMBDA_METHOD |\n+                    owner.flags_field & STRICTFP |\n+                    owner.owner.flags_field & STRICTFP |\n+                    PRIVATE |\n+                    (thisReferenced? (inInterface? DEFAULT : 0) : STATIC);\n+\n+            translatedSym.type = type;\n+            translatedSym.name = name;\n+            translatedSym.flags_field = flags;\n@@ -1541,8 +1066,2 @@\n-         * Method references to local class constructors, may, if the local\n-         * class references local variables, have implicit constructor\n-         * parameters added in Lower; As a result, the invokedynamic bootstrap\n-         * information added in the LambdaToMethod pass will have the wrong\n-         * signature. Hooks between Lower and LambdaToMethod have been added to\n-         * handle normal \"new\" in this case. This visitor converts potentially\n-         * affected method references into a lambda containing a normal\n-         * expression.\n+         * For a serializable lambda, generate a disambiguating string\n+         * which maximizes stability across deserialization.\n@@ -1550,1 +1069,1 @@\n-         * @param tree\n+         * @return String to differentiate synthetic lambda method names\n@@ -1552,12 +1071,32 @@\n-        @Override\n-        public void visitReference(JCMemberReference tree) {\n-            ReferenceTranslationContext rcontext = new ReferenceTranslationContext(tree);\n-            contextMap.put(tree, rcontext);\n-            if (rcontext.needsConversionToLambda()) {\n-                 \/\/ Convert to a lambda, and process as such\n-                MemberReferenceToLambda conv = new MemberReferenceToLambda(tree, rcontext, owner());\n-                analyzeLambda(conv.lambda(), conv.getReceiverExpression());\n-            } else {\n-                super.visitReference(tree);\n-                if (dumpLambdaToMethodStats) {\n-                    log.note(tree, Notes.MrefStat(rcontext.needsAltMetafactory(), null));\n+        private String serializedLambdaDisambiguation(Symbol owner) {\n+            StringBuilder buf = new StringBuilder();\n+            \/\/ Append the enclosing method signature to differentiate\n+            \/\/ overloaded enclosing methods.  For lambdas enclosed in\n+            \/\/ lambdas, the generated lambda method will not have type yet,\n+            \/\/ but the enclosing method's name will have been generated\n+            \/\/ with this same method, so it will be unique and never be\n+            \/\/ overloaded.\n+            Assert.check(\n+                    owner.type != null ||\n+                            lambdaContext != null);\n+            if (owner.type != null) {\n+                buf.append(typeSig(owner.type, true));\n+                buf.append(\":\");\n+            }\n+\n+            \/\/ Add target type info\n+            buf.append(types.findDescriptorSymbol(tree.type.tsym).owner.flatName());\n+            buf.append(\" \");\n+\n+            \/\/ Add variable assigned to\n+            if (pendingVar != null) {\n+                buf.append(pendingVar.flatName());\n+                buf.append(\"=\");\n+            }\n+            \/\/add captured locals info: type, name, order\n+            for (Symbol fv : capturedVars) {\n+                if (fv != owner) {\n+                    buf.append(typeSig(fv.type, true));\n+                    buf.append(\" \");\n+                    buf.append(fv.flatName());\n+                    buf.append(\",\");\n@@ -1566,51 +1105,1 @@\n-        }\n-        @Override\n-        public void visitSelect(JCFieldAccess tree) {\n-            if (context() != null && tree.sym.kind == VAR &&\n-                        (tree.sym.name == names._this ||\n-                         tree.sym.name == names._super)) {\n-                \/\/ A select of this or super means, if we are in a lambda,\n-                \/\/ we much have an instance context\n-                TranslationContext<?> localContext = context();\n-                while (localContext != null  && !localContext.owner.isStatic()) {\n-                    if (localContext.tree.hasTag(LAMBDA)) {\n-                        JCClassDecl clazz = (JCClassDecl)capturedDecl(localContext.depth, tree.sym);\n-                        if (clazz == null) break;\n-                        ((LambdaTranslationContext)localContext).addSymbol(clazz.sym, CAPTURED_THIS);\n-                    }\n-                    localContext = localContext.prev;\n-                }\n-            }\n-            super.visitSelect(tree);\n-        }\n-\n-        @Override\n-        public void visitVarDef(JCVariableDecl tree) {\n-            TranslationContext<?> context = context();\n-            if (context != null && context instanceof LambdaTranslationContext lambdaContext) {\n-                for (Frame frame : frameStack) {\n-                    if (frame.tree.hasTag(VARDEF)) {\n-                        \/\/skip variable frames inside a lambda:\n-                        continue;\n-                    } else if (frame.tree.hasTag(LAMBDA)) {\n-                        lambdaContext.addSymbol(tree.sym, LOCAL_VAR);\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                \/\/ Check for type variables (including as type arguments).\n-                \/\/ If they occur within class nested in a lambda, mark for erasure\n-                Type type = tree.sym.asType();\n-            }\n-\n-            List<Frame> prevStack = frameStack;\n-            try {\n-                if (tree.sym.owner.kind == MTH) {\n-                    frameStack.head.addLocal(tree.sym);\n-                }\n-                frameStack = frameStack.prepend(new Frame(tree));\n-                super.visitVarDef(tree);\n-            }\n-            finally {\n-                frameStack = prevStack;\n-            }\n+            return buf.toString();\n@@ -1621,2 +1110,3 @@\n-         * Return a valid owner given the current declaration stack\n-         * (required to skip synthetic lambda symbols)\n+         * For a non-serializable lambda, generate a simple method.\n+         *\n+         * @return Name to use for the synthetic lambda method name\n@@ -1624,115 +1114,7 @@\n-        private Symbol owner() {\n-            return owner(false);\n-        }\n-\n-        @SuppressWarnings(\"fallthrough\")\n-        private Symbol owner(boolean skipLambda) {\n-            List<Frame> frameStack2 = frameStack;\n-            while (frameStack2.nonEmpty()) {\n-                switch (frameStack2.head.tree.getTag()) {\n-                    case VARDEF:\n-                        if (((JCVariableDecl)frameStack2.head.tree).sym.isDirectlyOrIndirectlyLocal()) {\n-                            frameStack2 = frameStack2.tail;\n-                            break;\n-                        }\n-                        JCClassDecl cdecl = (JCClassDecl)frameStack2.tail.head.tree;\n-                        return initSym(cdecl.sym,\n-                                ((JCVariableDecl)frameStack2.head.tree).sym.flags() & STATIC);\n-                    case BLOCK:\n-                        JCClassDecl cdecl2 = (JCClassDecl)frameStack2.tail.head.tree;\n-                        return initSym(cdecl2.sym,\n-                                ((JCBlock)frameStack2.head.tree).flags & STATIC);\n-                    case CLASSDEF:\n-                        return ((JCClassDecl)frameStack2.head.tree).sym;\n-                    case METHODDEF:\n-                        return ((JCMethodDecl)frameStack2.head.tree).sym;\n-                    case LAMBDA:\n-                        if (!skipLambda)\n-                            return ((LambdaTranslationContext)contextMap\n-                                    .get(frameStack2.head.tree)).translatedSym;\n-                    default:\n-                        frameStack2 = frameStack2.tail;\n-                }\n-            }\n-            Assert.error();\n-            return null;\n-        }\n-\n-        private Symbol initSym(ClassSymbol csym, long flags) {\n-            boolean isStatic = (flags & STATIC) != 0;\n-            if (isStatic) {\n-                \/* static clinits are generated in Gen, so we need to use a fake\n-                 * one. Attr creates a fake clinit method while attributing\n-                 * lambda expressions used as initializers of static fields, so\n-                 * let's use that one.\n-                 *\/\n-                MethodSymbol clinit = attr.removeClinit(csym);\n-                if (clinit != null) {\n-                    clinits.put(csym, clinit);\n-                    return clinit;\n-                }\n-\n-                \/* if no clinit is found at Attr, then let's try at clinits.\n-                 *\/\n-                clinit = (MethodSymbol)clinits.get(csym);\n-                if (clinit == null) {\n-                    \/* no luck, let's create a new one\n-                     *\/\n-                    clinit = makePrivateSyntheticMethod(STATIC,\n-                            names.clinit,\n-                            new MethodType(List.nil(), syms.voidType,\n-                                List.nil(), syms.methodClass),\n-                            csym);\n-                    clinits.put(csym, clinit);\n-                }\n-                return clinit;\n-            } else {\n-                \/\/get the first constructor and treat it as the instance init sym\n-                for (Symbol s : csym.members_field.getSymbolsByName(names.init)) {\n-                    return s;\n-                }\n-            }\n-            Assert.error(\"init not found\");\n-            return null;\n-        }\n-\n-        private JCTree directlyEnclosingLambda() {\n-            if (frameStack.isEmpty()) {\n-                return null;\n-            }\n-            List<Frame> frameStack2 = frameStack;\n-            while (frameStack2.nonEmpty()) {\n-                switch (frameStack2.head.tree.getTag()) {\n-                    case CLASSDEF:\n-                    case METHODDEF:\n-                        return null;\n-                    case LAMBDA:\n-                        return frameStack2.head.tree;\n-                    default:\n-                        frameStack2 = frameStack2.tail;\n-                }\n-            }\n-            Assert.error();\n-            return null;\n-        }\n-\n-        private boolean inClassWithinLambda() {\n-            if (frameStack.isEmpty()) {\n-                return false;\n-            }\n-            List<Frame> frameStack2 = frameStack;\n-            boolean classFound = false;\n-            while (frameStack2.nonEmpty()) {\n-                switch (frameStack2.head.tree.getTag()) {\n-                    case LAMBDA:\n-                        return classFound;\n-                    case CLASSDEF:\n-                        classFound = true;\n-                        frameStack2 = frameStack2.tail;\n-                        break;\n-                    default:\n-                        frameStack2 = frameStack2.tail;\n-                }\n-            }\n-            \/\/ No lambda\n-            return false;\n+        private Name lambdaName(Symbol owner) {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(names.lambda);\n+            buf.append(syntheticMethodNameComponent(owner));\n+            buf.append(\"$\");\n+            buf.append(kInfo.syntheticNameIndex(buf, 0));\n+            return names.fromString(buf.toString());\n@@ -1742,3 +1124,2 @@\n-         * Return the declaration corresponding to a symbol in the enclosing\n-         * scope; the depth parameter is used to filter out symbols defined\n-         * in nested scopes (which do not need to undergo capture).\n+         * @return Method name in a form that can be folded into a\n+         * component of a synthetic method name\n@@ -1746,38 +1127,9 @@\n-        private JCTree capturedDecl(int depth, Symbol sym) {\n-            int currentDepth = frameStack.size() - 1;\n-            for (Frame block : frameStack) {\n-                switch (block.tree.getTag()) {\n-                    case CLASSDEF:\n-                        ClassSymbol clazz = ((JCClassDecl)block.tree).sym;\n-                        if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {\n-                            return currentDepth > depth ? null : block.tree;\n-                        }\n-                        break;\n-                    case VARDEF:\n-                        if ((((JCVariableDecl)block.tree).sym == sym &&\n-                                sym.owner.kind == MTH) || \/\/only locals are captured\n-                            (block.locals != null && block.locals.contains(sym))) {\n-                            return currentDepth > depth ? null : block.tree;\n-                        }\n-                        break;\n-                    case BLOCK:\n-                    case METHODDEF:\n-                    case LAMBDA:\n-                        if (block.locals != null && block.locals.contains(sym)) {\n-                            return currentDepth > depth ? null : block.tree;\n-                        }\n-                        break;\n-                    default:\n-                        Assert.error(\"bad decl kind \" + block.tree.getTag());\n-                }\n-                currentDepth--;\n-            }\n-            return null;\n-        }\n-\n-        private TranslationContext<?> context() {\n-            for (Frame frame : frameStack) {\n-                TranslationContext<?> context = contextMap.get(frame.tree);\n-                if (context != null) {\n-                    return context;\n-                }\n+        String syntheticMethodNameComponent(Symbol owner) {\n+            long ownerFlags = owner.flags();\n+            if ((ownerFlags & BLOCK) != 0) {\n+                return (ownerFlags & STATIC) != 0 ?\n+                        \"static\" : \"new\";\n+            } else if (owner.isConstructor()) {\n+                return \"new\";\n+            } else {\n+                return owner.name.toString();\n@@ -1785,1 +1137,0 @@\n-            return null;\n@@ -1789,13 +1140,4 @@\n-         *  This is used to filter out those identifiers that needs to be adjusted\n-         *  when translating away lambda expressions\n-         *\/\n-        private boolean lambdaIdentSymbolFilter(Symbol sym) {\n-            return (sym.kind == VAR || sym.kind == MTH)\n-                    && !sym.isStatic()\n-                    && sym.name != names.init;\n-        }\n-\n-        \/**\n-         *  This is used to filter out those select nodes that need to be adjusted\n-         *  when translating away lambda expressions - at the moment, this is the\n-         *  set of nodes that select `this' (qualified this)\n+         * For a serializable lambda, generate a method name which maximizes\n+         * name stability across deserialization.\n+         *\n+         * @return Name to use for the synthetic lambda method name\n@@ -1803,6 +1145,17 @@\n-        private boolean lambdaFieldAccessFilter(JCFieldAccess fAccess) {\n-            return (context instanceof LambdaTranslationContext lambdaContext)\n-                    && !fAccess.sym.isStatic()\n-                    && fAccess.name == names._this\n-                    && (fAccess.sym.owner.kind == TYP)\n-                    && !lambdaContext.translatedSymbols.get(CAPTURED_OUTER_THIS).isEmpty();\n+        private Name serializedLambdaName(Symbol owner) {\n+            StringBuilder buf = new StringBuilder();\n+            buf.append(names.lambda);\n+            \/\/ Append the name of the method enclosing the lambda.\n+            buf.append(syntheticMethodNameComponent(owner));\n+            buf.append('$');\n+            \/\/ Append a hash of the disambiguating string : enclosing method\n+            \/\/ signature, etc.\n+            String disam = serializedLambdaDisambiguation(owner);\n+            buf.append(Integer.toHexString(disam.hashCode()));\n+            buf.append('$');\n+            \/\/ The above appended name components may not be unique, append\n+            \/\/ a count based on the above name components.\n+            buf.append(kInfo.syntheticNameIndex(buf, 1));\n+            String result = buf.toString();\n+            \/\/System.err.printf(\"serializedLambdaName: %s -- %s\\n\", result, disam);\n+            return names.fromString(result);\n@@ -1812,2 +1165,2 @@\n-         * This is used to filter out those new class expressions that need to\n-         * be qualified with an enclosing tree\n+         * Translate a symbol of a given kind into something suitable for the\n+         * synthetic lambda body\n@@ -1815,10 +1168,20 @@\n-        private boolean lambdaNewClassFilter(TranslationContext<?> context, JCNewClass tree) {\n-            if (context != null\n-                    && tree.encl == null\n-                    && tree.def == null\n-                    && !tree.type.getEnclosingType().hasTag(NONE)) {\n-                Type encl = tree.type.getEnclosingType();\n-                Type current = context.owner.enclClass().type;\n-                while (!current.hasTag(NONE)) {\n-                    if (current.tsym.isSubClass(encl.tsym, types)) {\n-                        return true;\n+        VarSymbol translate(final VarSymbol sym, LambdaSymbolKind skind) {\n+            VarSymbol ret;\n+            boolean propagateAnnos = true;\n+            switch (skind) {\n+                case CAPTURED_VAR:\n+                    Name name = (sym.flags() & LOCAL_CAPTURE_FIELD) != 0 ?\n+                            sym.baseSymbol().name : sym.name;\n+                    ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym);\n+                    propagateAnnos = false;\n+                    break;\n+                case LOCAL_VAR:\n+                    ret = new VarSymbol(sym.flags() & FINAL, sym.name, sym.type, translatedSym);\n+                    ret.pos = sym.pos;\n+                    \/\/ If sym.data == ElementKind.EXCEPTION_PARAMETER,\n+                    \/\/ set ret.data = ElementKind.EXCEPTION_PARAMETER too.\n+                    \/\/ Because method com.sun.tools.javac.jvm.Code.fillExceptionParameterPositions and\n+                    \/\/ com.sun.tools.javac.jvm.Code.fillLocalVarPosition would use it.\n+                    \/\/ See JDK-8257740 for more information.\n+                    if (sym.isExceptionParameter()) {\n+                        ret.setData(ElementKind.EXCEPTION_PARAMETER);\n@@ -1826,14 +1189,8 @@\n-                    current = current.getEnclosingType();\n-                }\n-                return false;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        private class Frame {\n-            final JCTree tree;\n-            List<Symbol> locals;\n-\n-            public Frame(JCTree tree) {\n-                this.tree = tree;\n+                    break;\n+                case PARAM:\n+                    ret = new VarSymbol((sym.flags() & FINAL) | PARAMETER, sym.name, types.erasure(sym.type), translatedSym);\n+                    ret.pos = sym.pos;\n+                    break;\n+                default:\n+                    Assert.error(skind.name());\n+                    throw new AssertionError();\n@@ -1841,6 +1198,3 @@\n-\n-            void addLocal(Symbol sym) {\n-                if (locals == null) {\n-                    locals = List.nil();\n-                }\n-                locals = locals.prepend(sym);\n+            if (ret != sym && propagateAnnos) {\n+                ret.setDeclarationAttributes(sym.getRawAttributes());\n+                ret.setTypeAttributes(sym.getRawTypeAttributes());\n@@ -1848,0 +1202,1 @@\n+            return ret;\n@@ -1850,46 +1205,3 @@\n-        \/**\n-         * This class is used to store important information regarding translation of\n-         * lambda expression\/method references (see subclasses).\n-         *\/\n-        abstract class TranslationContext<T extends JCFunctionalExpression> {\n-\n-            \/** the underlying (untranslated) tree *\/\n-            final T tree;\n-\n-            \/** points to the adjusted enclosing scope in which this lambda\/mref expression occurs *\/\n-            final Symbol owner;\n-\n-            \/** the depth of this lambda expression in the frame stack *\/\n-            final int depth;\n-\n-            \/** the enclosing translation context (set for nested lambdas\/mref) *\/\n-            final TranslationContext<?> prev;\n-\n-            \/** list of methods to be bridged by the meta-factory *\/\n-            final List<Symbol> bridges;\n-\n-            TranslationContext(T tree) {\n-                this.tree = tree;\n-                this.owner = owner(true);\n-                this.depth = frameStack.size() - 1;\n-                this.prev = context();\n-                ClassSymbol csym =\n-                        types.makeFunctionalInterfaceClass(attrEnv, names.empty, tree.target, ABSTRACT | INTERFACE);\n-                this.bridges = types.functionalInterfaceBridges(csym);\n-            }\n-\n-            \/** does this functional expression need to be created using alternate metafactory? *\/\n-            boolean needsAltMetafactory() {\n-                return tree.target.isIntersection() ||\n-                        isSerializable() ||\n-                        isQuotable() ||\n-                        bridges.length() > 1;\n-            }\n-\n-            \/** does this functional expression require serialization support? *\/\n-            boolean isSerializable() {\n-                if (forceSerializable) {\n-                    return true;\n-                }\n-                return types.asSuper(tree.target, syms.serializableType.tsym) != null;\n-            }\n+        VarSymbol addLocal(VarSymbol sym) {\n+            return addSymbol(sym, LambdaSymbolKind.LOCAL_VAR);\n+        }\n@@ -1897,3 +1209,3 @@\n-            boolean isQuotable() {\n-                return tree.codeReflectionInfo != null;\n-            }\n+        private VarSymbol addSymbol(VarSymbol sym, LambdaSymbolKind skind) {\n+            return lambdaProxies.computeIfAbsent(sym, s -> translate(s, skind));\n+        }\n@@ -1901,7 +1213,6 @@\n-            \/**\n-             * @return Name of the enclosing method to be folded into synthetic\n-             * method name\n-             *\/\n-            String enclosingMethodName() {\n-                return syntheticMethodNameComponent(owner.name);\n-            }\n+        JCTree translate(JCIdent lambdaIdent) {\n+            Symbol tSym = lambdaProxies.get(lambdaIdent.sym);\n+            return tSym != null ?\n+                    make.Ident(tSym).setType(lambdaIdent.type) :\n+                    null;\n+        }\n@@ -1909,16 +1220,2 @@\n-            \/**\n-             * @return Method name in a form that can be folded into a\n-             * component of a synthetic method name\n-             *\/\n-            String syntheticMethodNameComponent(Name name) {\n-                if (name == null) {\n-                    return \"null\";\n-                }\n-                String methodName = name.toString();\n-                if (methodName.equals(\"<clinit>\")) {\n-                    methodName = \"static\";\n-                } else if (methodName.equals(\"<init>\")) {\n-                    methodName = \"new\";\n-                }\n-                return methodName;\n-            }\n+        Type generatedLambdaSig() {\n+            return types.erasure(tree.getDescriptorType(types));\n@@ -1928,4 +1225,2 @@\n-         * This class retains all the useful information about a lambda expression;\n-         * the contents of this class are filled by the LambdaAnalyzer visitor,\n-         * and the used by the main translation routines in order to adjust references\n-         * to captured locals\/members, etc.\n+         * Compute the set of local variables captured by this lambda expression.\n+         * Also determines whether this lambda expression captures the enclosing 'this'.\n@@ -1933,56 +1228,3 @@\n-        class LambdaTranslationContext extends TranslationContext<JCLambda> {\n-\n-            \/** variable in the enclosing context to which this lambda is assigned *\/\n-            final Symbol self;\n-\n-            \/** variable in the enclosing context to which this lambda is assigned *\/\n-            final Symbol assignedTo;\n-\n-            Map<LambdaSymbolKind, Map<Symbol, Symbol>> translatedSymbols;\n-\n-            \/** the synthetic symbol for the method hoisting the translated lambda *\/\n-            MethodSymbol translatedSym;\n-\n-            List<JCVariableDecl> syntheticParams;\n-\n-            \/**\n-             * to prevent recursion, track local classes processed\n-             *\/\n-            final Set<Symbol> freeVarProcessedLocalClasses;\n-\n-            \/**\n-             * For method references converted to lambdas.  The method\n-             * reference receiver expression. Must be treated like a captured\n-             * variable.\n-             *\/\n-            JCExpression methodReferenceReceiver;\n-\n-            LambdaTranslationContext(JCLambda tree) {\n-                super(tree);\n-                Frame frame = frameStack.head;\n-                switch (frame.tree.getTag()) {\n-                    case VARDEF:\n-                        assignedTo = self = ((JCVariableDecl) frame.tree).sym;\n-                        break;\n-                    case ASSIGN:\n-                        self = null;\n-                        assignedTo = TreeInfo.symbol(((JCAssign) frame.tree).getVariable());\n-                        break;\n-                    default:\n-                        assignedTo = self = null;\n-                        break;\n-                 }\n-\n-                \/\/ This symbol will be filled-in in complete\n-                if (owner.kind == MTH) {\n-                    final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);\n-                    this.translatedSym = new MethodSymbol(SYNTHETIC | PRIVATE, null, null, owner.enclClass()) {\n-                        @Override\n-                        public MethodSymbol originalEnclosingMethod() {\n-                            return originalOwner;\n-                        }\n-                    };\n-                } else {\n-                    this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());\n-                }\n-                translatedSymbols = new EnumMap<>(LambdaSymbolKind.class);\n+        class LambdaCaptureScanner extends CaptureScanner {\n+            boolean capturesThis;\n+            Set<ClassSymbol> seenClasses = new HashSet<>();\n@@ -1990,166 +1232,2 @@\n-                translatedSymbols.put(PARAM, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<Symbol, Symbol>());\n-                translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap<Symbol, Symbol>());\n-\n-                freeVarProcessedLocalClasses = new HashSet<>();\n-            }\n-\n-             \/**\n-             * For a serializable lambda, generate a disambiguating string\n-             * which maximizes stability across deserialization.\n-             *\n-             * @return String to differentiate synthetic lambda method names\n-             *\/\n-            private String serializedLambdaDisambiguation() {\n-                StringBuilder buf = new StringBuilder();\n-                \/\/ Append the enclosing method signature to differentiate\n-                \/\/ overloaded enclosing methods.  For lambdas enclosed in\n-                \/\/ lambdas, the generated lambda method will not have type yet,\n-                \/\/ but the enclosing method's name will have been generated\n-                \/\/ with this same method, so it will be unique and never be\n-                \/\/ overloaded.\n-                Assert.check(\n-                        owner.type != null ||\n-                        directlyEnclosingLambda() != null);\n-                if (owner.type != null) {\n-                    buf.append(typeSig(owner.type, true));\n-                    buf.append(\":\");\n-                }\n-\n-                \/\/ Add target type info\n-                buf.append(types.findDescriptorSymbol(tree.type.tsym).owner.flatName());\n-                buf.append(\" \");\n-\n-                \/\/ Add variable assigned to\n-                if (assignedTo != null) {\n-                    buf.append(assignedTo.flatName());\n-                    buf.append(\"=\");\n-                }\n-                \/\/add captured locals info: type, name, order\n-                for (Symbol fv : getSymbolMap(CAPTURED_VAR).keySet()) {\n-                    if (fv != self) {\n-                        buf.append(typeSig(fv.type, true));\n-                        buf.append(\" \");\n-                        buf.append(fv.flatName());\n-                        buf.append(\",\");\n-                    }\n-                }\n-\n-                return buf.toString();\n-            }\n-\n-            \/**\n-             * For a non-serializable lambda, generate a simple method.\n-             *\n-             * @return Name to use for the synthetic lambda method name\n-             *\/\n-            private Name lambdaName() {\n-                return names.lambda.append(names.fromString(enclosingMethodName() + \"$\" + lambdaCount++));\n-            }\n-\n-            \/**\n-             * For a serializable lambda, generate a method name which maximizes\n-             * name stability across deserialization.\n-             *\n-             * @return Name to use for the synthetic lambda method name\n-             *\/\n-            private Name serializedLambdaName() {\n-                StringBuilder buf = new StringBuilder();\n-                buf.append(names.lambda);\n-                \/\/ Append the name of the method enclosing the lambda.\n-                buf.append(enclosingMethodName());\n-                buf.append('$');\n-                \/\/ Append a hash of the disambiguating string : enclosing method\n-                \/\/ signature, etc.\n-                String disam = serializedLambdaDisambiguation();\n-                buf.append(Integer.toHexString(disam.hashCode()));\n-                buf.append('$');\n-                \/\/ The above appended name components may not be unique, append\n-                \/\/ a count based on the above name components.\n-                buf.append(syntheticMethodNameCounts.getIndex(buf));\n-                String result = buf.toString();\n-                \/\/System.err.printf(\"serializedLambdaName: %s -- %s\\n\", result, disam);\n-                return names.fromString(result);\n-            }\n-\n-            \/**\n-             * Translate a symbol of a given kind into something suitable for the\n-             * synthetic lambda body\n-             *\/\n-            Symbol translate(final Symbol sym, LambdaSymbolKind skind) {\n-                Symbol ret;\n-                switch (skind) {\n-                    case CAPTURED_THIS:\n-                        ret = sym;  \/\/ self represented\n-                        break;\n-                    case CAPTURED_VAR:\n-                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original captured symbol\n-                                return sym;\n-                            }\n-                        };\n-                        break;\n-                    case CAPTURED_OUTER_THIS:\n-                        Name name = names.fromString(sym.flatName().toString().replace('.', '$') + names.dollarThis);\n-                        ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original captured symbol\n-                                return sym;\n-                            }\n-                        };\n-                        break;\n-                    case LOCAL_VAR:\n-                        ret = new VarSymbol(sym.flags() & FINAL, sym.name, sym.type, translatedSym) {\n-                            @Override\n-                            public Symbol baseSymbol() {\n-                                \/\/keep mapping with original symbol\n-                                return sym;\n-                            }\n-                        };\n-                        ((VarSymbol) ret).pos = ((VarSymbol) sym).pos;\n-                        \/\/ If sym.data == ElementKind.EXCEPTION_PARAMETER,\n-                        \/\/ set ret.data = ElementKind.EXCEPTION_PARAMETER too.\n-                        \/\/ Because method com.sun.tools.javac.jvm.Code.fillExceptionParameterPositions and\n-                        \/\/ com.sun.tools.javac.jvm.Code.fillLocalVarPosition would use it.\n-                        \/\/ See JDK-8257740 for more information.\n-                        if (((VarSymbol) sym).isExceptionParameter()) {\n-                            ((VarSymbol) ret).setData(ElementKind.EXCEPTION_PARAMETER);\n-                        }\n-                        break;\n-                    case PARAM:\n-                        ret = new VarSymbol((sym.flags() & FINAL) | PARAMETER, sym.name, types.erasure(sym.type), translatedSym);\n-                        ((VarSymbol) ret).pos = ((VarSymbol) sym).pos;\n-                        \/\/ Set ret.data. Same as case LOCAL_VAR above.\n-                        if (((VarSymbol) sym).isExceptionParameter()) {\n-                            ((VarSymbol) ret).setData(ElementKind.EXCEPTION_PARAMETER);\n-                        }\n-                        break;\n-                    default:\n-                        Assert.error(skind.name());\n-                        throw new AssertionError();\n-                }\n-                if (ret != sym && skind.propagateAnnotations()) {\n-                    ret.setDeclarationAttributes(sym.getRawAttributes());\n-                    ret.setTypeAttributes(sym.getRawTypeAttributes());\n-                }\n-                return ret;\n-            }\n-\n-            void addSymbol(Symbol sym, LambdaSymbolKind skind) {\n-                if (skind == CAPTURED_THIS && sym != null && sym.kind == TYP && !typesUnderConstruction.isEmpty()) {\n-                    ClassSymbol currentClass = currentClass();\n-                    if (currentClass != null && typesUnderConstruction.contains(currentClass)) {\n-                        \/\/ reference must be to enclosing outer instance, mutate capture kind.\n-                        Assert.check(sym != currentClass); \/\/ should have been caught right in Attr\n-                        skind = CAPTURED_OUTER_THIS;\n-                    }\n-                }\n-                Map<Symbol, Symbol> transMap = getSymbolMap(skind);\n-                if (!transMap.containsKey(sym)) {\n-                    transMap.put(sym, translate(sym, skind));\n-                }\n+            LambdaCaptureScanner(JCLambda ownerTree) {\n+                super(ownerTree);\n@@ -2158,4 +1236,4 @@\n-            Map<Symbol, Symbol> getSymbolMap(LambdaSymbolKind skind) {\n-                Map<Symbol, Symbol> m = translatedSymbols.get(skind);\n-                Assert.checkNonNull(m);\n-                return m;\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                seenClasses.add(tree.sym);\n+                super.visitClassDef(tree);\n@@ -2164,25 +1242,12 @@\n-            JCTree translate(JCIdent lambdaIdent) {\n-                for (LambdaSymbolKind kind : LambdaSymbolKind.values()) {\n-                    Map<Symbol, Symbol> m = getSymbolMap(kind);\n-                    switch(kind) {\n-                        default:\n-                            if (m.containsKey(lambdaIdent.sym)) {\n-                                Symbol tSym = m.get(lambdaIdent.sym);\n-                                JCTree t = make.Ident(tSym).setType(lambdaIdent.type);\n-                                return t;\n-                            }\n-                            break;\n-                        case CAPTURED_OUTER_THIS:\n-                            Optional<Symbol> proxy = m.keySet().stream()\n-                                    .filter(out -> lambdaIdent.sym.isMemberOf(out.type.tsym, types))\n-                                    .reduce((a, b) -> a.isEnclosedBy((ClassSymbol)b) ? a : b);\n-                            if (proxy.isPresent()) {\n-                                \/\/ Transform outer instance variable references anchoring them to the captured synthetic.\n-                                Symbol tSym = m.get(proxy.get());\n-                                JCExpression t = make.Ident(tSym).setType(lambdaIdent.sym.owner.type);\n-                                t = make.Select(t, lambdaIdent.name);\n-                                t.setType(lambdaIdent.type);\n-                                TreeInfo.setSymbol(t, lambdaIdent.sym);\n-                                return t;\n-                            }\n-                            break;\n+            @Override\n+            public void visitIdent(JCIdent tree) {\n+                if (!tree.sym.isStatic() &&\n+                        tree.sym.owner.kind == TYP &&\n+                        (tree.sym.kind == VAR || tree.sym.kind == MTH) &&\n+                        !seenClasses.contains(tree.sym.owner)) {\n+                    if ((tree.sym.flags() & LOCAL_CAPTURE_FIELD) != 0) {\n+                        \/\/ a local, captured by Lower - re-capture!\n+                        addFreeVar((VarSymbol) tree.sym);\n+                    } else {\n+                        \/\/ a reference to an enclosing field or method, we need to capture 'this'\n+                        capturesThis = true;\n@@ -2190,0 +1255,3 @@\n+                } else {\n+                    \/\/ might be a local capture\n+                    super.visitIdent(tree);\n@@ -2191,30 +1259,0 @@\n-                return null;\n-            }\n-\n-            \/* Translate away qualified this expressions, anchoring them to synthetic parameters that\n-               capture the qualified this handle. `fieldAccess' is guaranteed to one such.\n-            *\/\n-            public JCTree translate(JCFieldAccess fieldAccess) {\n-                Assert.check(fieldAccess.name == names._this);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                if (m.containsKey(fieldAccess.sym.owner)) {\n-                    Symbol tSym = m.get(fieldAccess.sym.owner);\n-                    JCExpression t = make.Ident(tSym).setType(fieldAccess.sym.owner.type);\n-                    return t;\n-                }\n-                return null;\n-            }\n-\n-            \/* Translate away naked new instance creation expressions with implicit enclosing instances,\n-               anchoring them to synthetic parameters that stand proxy for the qualified outer this handle.\n-            *\/\n-            public JCNewClass translate(JCNewClass newClass) {\n-                Assert.check(newClass.clazz.type.tsym.hasOuterInstance() && newClass.encl == null);\n-                Map<Symbol, Symbol> m = translatedSymbols.get(LambdaSymbolKind.CAPTURED_OUTER_THIS);\n-                final Type enclosingType = newClass.clazz.type.getEnclosingType();\n-                if (m.containsKey(enclosingType.tsym)) {\n-                      Symbol tSym = m.get(enclosingType.tsym);\n-                      JCExpression encl = make.Ident(tSym).setType(enclosingType);\n-                      newClass.encl = encl;\n-                }\n-                return newClass;\n@@ -2223,44 +1261,7 @@\n-            \/**\n-             * The translatedSym is not complete\/accurate until the analysis is\n-             * finished.  Once the analysis is finished, the translatedSym is\n-             * \"completed\" -- updated with type information, access modifiers,\n-             * and full parameter list.\n-             *\/\n-            void complete() {\n-                if (syntheticParams != null) {\n-                    return;\n-                }\n-                boolean inInterface = translatedSym.owner.isInterface();\n-                boolean thisReferenced = !getSymbolMap(CAPTURED_THIS).isEmpty();\n-\n-                \/\/ If instance access isn't needed, make it static.\n-                \/\/ Interface instance methods must be default methods.\n-                \/\/ Lambda methods are private synthetic.\n-                \/\/ Inherit ACC_STRICT from the enclosing method, or, for clinit,\n-                \/\/ from the class.\n-                translatedSym.flags_field = SYNTHETIC | LAMBDA_METHOD |\n-                        owner.flags_field & STRICTFP |\n-                        owner.owner.flags_field & STRICTFP |\n-                        PRIVATE |\n-                        (thisReferenced? (inInterface? DEFAULT : 0) : STATIC);\n-\n-                \/\/compute synthetic params\n-                ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-                ListBuffer<VarSymbol> parameterSymbols = new ListBuffer<>();\n-\n-                \/\/ The signature of the method is augmented with the following\n-                \/\/ synthetic parameters:\n-                \/\/\n-                \/\/ 1) reference to enclosing contexts captured by the lambda expression\n-                \/\/ 2) enclosing locals captured by the lambda expression\n-                for (Symbol thisSym : getSymbolMap(CAPTURED_VAR).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n-                }\n-                for (Symbol thisSym : getSymbolMap(CAPTURED_OUTER_THIS).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n-                }\n-                for (Symbol thisSym : getSymbolMap(PARAM).values()) {\n-                    params.append(make.VarDef((VarSymbol) thisSym, null));\n-                    parameterSymbols.append((VarSymbol) thisSym);\n+            @Override\n+            public void visitSelect(JCFieldAccess tree) {\n+                if (tree.sym.kind == VAR &&\n+                        (tree.sym.name == names._this ||\n+                                tree.sym.name == names._super) &&\n+                        !seenClasses.contains(tree.sym.type.tsym)) {\n+                    capturesThis = true;\n@@ -2268,13 +1269,1 @@\n-                syntheticParams = params.toList();\n-\n-                translatedSym.params = parameterSymbols.toList();\n-\n-                \/\/ Compute and set the lambda name\n-                translatedSym.name = isSerializable()\n-                        ? serializedLambdaName()\n-                        : lambdaName();\n-\n-                \/\/prepend synthetic args to translated lambda method signature\n-                translatedSym.type = types.createMethodTypeWithParameters(\n-                        generatedLambdaSig(),\n-                        TreeInfo.types(syntheticParams));\n+                super.visitSelect(tree);\n@@ -2283,2 +1272,3 @@\n-            Type generatedLambdaSig() {\n-                return types.erasure(tree.getDescriptorType(types));\n+            @Override\n+            public void visitAnnotation(JCAnnotation tree) {\n+                \/\/ do nothing (annotation values look like captured instance fields)\n@@ -2288,5 +1278,3 @@\n-        \/**\n-         * This class retains all the useful information about a method reference;\n-         * the contents of this class are filled by the LambdaAnalyzer visitor,\n-         * and the used by the main translation routines in order to adjust method\n-         * references (i.e. in case a bridge is needed)\n+        \/*\n+         * These keys provide mappings for various translated lambda symbols\n+         * and the prevailing order must be maintained.\n@@ -2294,116 +1282,4 @@\n-        final class ReferenceTranslationContext extends TranslationContext<JCMemberReference> {\n-\n-            final boolean isSuper;\n-\n-            ReferenceTranslationContext(JCMemberReference tree) {\n-                super(tree);\n-                this.isSuper = tree.hasKind(ReferenceKind.SUPER);\n-            }\n-\n-            boolean needsVarArgsConversion() {\n-                return tree.varargsElement != null;\n-            }\n-\n-            \/**\n-             * @return Is this an array operation like clone()\n-             *\/\n-            boolean isArrayOp() {\n-                return tree.sym.owner == syms.arrayClass;\n-            }\n-\n-            boolean receiverAccessible() {\n-                \/\/hack needed to workaround 292 bug (7087658)\n-                \/\/when 292 issue is fixed we should remove this and change the backend\n-                \/\/code to always generate a method handle to an accessible method\n-                return tree.ownerAccessible;\n-            }\n-\n-            \/**\n-             * This method should be called only when target release <= 14\n-             * where LambdaMetaFactory does not spin nestmate classes.\n-             *\n-             * This method should be removed when --release 14 is not supported.\n-             *\/\n-            boolean isPrivateInOtherClass() {\n-                assert !nestmateLambdas;\n-                return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                        !types.isSameType(\n-                              types.erasure(tree.sym.enclClass().asType()),\n-                              types.erasure(owner.enclClass().asType()));\n-            }\n-\n-            \/**\n-             * Erasure destroys the implementation parameter subtype\n-             * relationship for intersection types.\n-             * Have similar problems for union types too.\n-             *\/\n-            boolean interfaceParameterIsIntersectionOrUnionType() {\n-                List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-                for (; tl.nonEmpty(); tl = tl.tail) {\n-                    Type pt = tl.head;\n-                    if (isIntersectionOrUnionType(pt))\n-                        return true;\n-                }\n-                return false;\n-            }\n-\n-            boolean isIntersectionOrUnionType(Type t) {\n-                switch (t.getKind()) {\n-                    case INTERSECTION:\n-                    case UNION:\n-                        return true;\n-                    case TYPEVAR:\n-                        TypeVar tv = (TypeVar) t;\n-                        return isIntersectionOrUnionType(tv.getUpperBound());\n-                }\n-                return false;\n-            }\n-\n-            \/**\n-             * Does this reference need to be converted to a lambda\n-             * (i.e. var args need to be expanded or \"super\" is used)\n-             *\/\n-            final boolean needsConversionToLambda() {\n-                return interfaceParameterIsIntersectionOrUnionType() ||\n-                        isSuper ||\n-                        needsVarArgsConversion() ||\n-                        isArrayOp() ||\n-                        (!nestmateLambdas && isPrivateInOtherClass()) ||\n-                        isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, owner) ||\n-                        !receiverAccessible() ||\n-                        (tree.getMode() == ReferenceMode.NEW &&\n-                          tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                          (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-            }\n-\n-            Type generatedRefSig() {\n-                return types.erasure(tree.sym.type);\n-            }\n-\n-            Type bridgedRefSig() {\n-                return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n-            }\n-        }\n-    }\n-    \/\/ <\/editor-fold>\n-\n-    \/*\n-     * These keys provide mappings for various translated lambda symbols\n-     * and the prevailing order must be maintained.\n-     *\/\n-    enum LambdaSymbolKind {\n-        PARAM,          \/\/ original to translated lambda parameters\n-        LOCAL_VAR,      \/\/ original to translated lambda locals\n-        CAPTURED_VAR,   \/\/ variables in enclosing scope to translated synthetic parameters\n-        CAPTURED_THIS,  \/\/ class symbols to translated synthetic parameters (for captured member access)\n-        CAPTURED_OUTER_THIS; \/\/ used when `this' capture is illegal, but outer this capture is legit (JDK-8129740)\n-\n-        boolean propagateAnnotations() {\n-            switch (this) {\n-                case CAPTURED_VAR:\n-                case CAPTURED_THIS:\n-                case CAPTURED_OUTER_THIS:\n-                    return false;\n-                default:\n-                    return true;\n-           }\n+        enum LambdaSymbolKind {\n+            PARAM,          \/\/ original to translated lambda parameters\n+            LOCAL_VAR,      \/\/ original to translated lambda locals\n+            CAPTURED_VAR;   \/\/ variables in enclosing scope to translated synthetic parameters\n@@ -2447,6 +1323,0 @@\n-    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                          Symbol currentClass) {\n-        return ((targetReference.flags() & PROTECTED) != 0 &&\n-                targetReference.packge() != currentClass.packge());\n-    }\n-\n@@ -2465,1 +1335,1 @@\n-         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation()}.\n+         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation(Symbol)}}.\n@@ -2470,1 +1340,1 @@\n-            super(types);\n+            types.super();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":549,"deletions":1679,"binary":false,"changes":2228,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.comp.Lower.FreeVarCollector;\n@@ -95,0 +96,1 @@\n+import java.util.stream.Collectors;\n@@ -2394,7 +2396,3 @@\n-                class FreeVarScanner extends Lower.BasicFreeVarCollector {\n-                    List<Symbol> freevars = new ArrayList<>();\n-                    Symbol owner;\n-\n-                    FreeVarScanner(Symbol owner) {\n-                        lower.super();\n-                        this.owner = owner;\n+                class FreeVarScanner extends Lower.FreeVarCollector {\n+                    FreeVarScanner() {\n+                        lower.super(tree);\n@@ -2405,9 +2403,2 @@\n-                        freevars.addAll(localCaptures.getOrDefault(c, List.of()));\n-                    }\n-\n-                    @Override\n-                    public void visitSymbol(Symbol sym) {\n-                        if (sym.kind == VAR && sym.owner == owner &&\n-                                ((VarSymbol)sym).getConstValue() == null) {\n-                            freevars.add(sym);\n-                        }\n+                        localCaptures.getOrDefault(c, List.of())\n+                                .forEach(s -> addFreeVar((VarSymbol)s));\n@@ -2416,3 +2407,2 @@\n-                FreeVarScanner fvs = new FreeVarScanner(tree.sym.owner);\n-                fvs.scan(tree);\n-                localCaptures.put(tree.sym, fvs.freevars);\n+                FreeVarScanner fvs = new FreeVarScanner();\n+                localCaptures.put(tree.sym, List.copyOf(fvs.analyzeCaptures()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -33,0 +34,2 @@\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.jvm.Target;\n@@ -49,0 +52,2 @@\n+import javax.lang.model.type.TypeKind;\n+\n@@ -78,0 +83,1 @@\n+    private final Target target;\n@@ -92,0 +98,1 @@\n+        target = Target.instance(context);\n@@ -542,0 +549,264 @@\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            Type t = types.skipTypeVars(tree.expr.type, false);\n+            Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n+            if (tree.kind == ReferenceKind.UNBOUND) {\n+                tree.expr = make.Type(receiverTarget);\n+            } else {\n+                tree.expr = translate(tree.expr, receiverTarget);\n+            }\n+            if (!tree.type.isIntersection()) {\n+                tree.type = erasure(tree.type);\n+            } else {\n+                tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n+            }\n+            result = tree;\n+        }\n+    }\n+    \/\/ where\n+    boolean needsVarArgsConversion(JCMemberReference tree) {\n+        return tree.varargsElement != null;\n+    }\n+\n+    \/**\n+     * @return Is this an array operation like clone()\n+     *\/\n+    boolean isArrayOp(JCMemberReference tree) {\n+        return tree.sym.owner == syms.arrayClass;\n+    }\n+\n+    boolean receiverAccessible(JCMemberReference tree) {\n+        \/\/hack needed to workaround 292 bug (7087658)\n+        \/\/when 292 issue is fixed we should remove this and change the backend\n+        \/\/code to always generate a method handle to an accessible method\n+        return tree.ownerAccessible;\n+    }\n+\n+    \/**\n+     * Erasure destroys the implementation parameter subtype\n+     * relationship for intersection types.\n+     * Have similar problems for union types too.\n+     *\/\n+    boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+        List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+        for (; tl.nonEmpty(); tl = tl.tail) {\n+            Type pt = tl.head;\n+            if (isIntersectionOrUnionType(pt))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean isIntersectionOrUnionType(Type t) {\n+        return switch (t.getKind()) {\n+            case INTERSECTION, UNION -> true;\n+            case TYPEVAR -> {\n+                TypeVar tv = (TypeVar) t;\n+                yield isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                          Symbol currentClass) {\n+        return ((targetReference.flags() & PROTECTED) != 0 &&\n+                targetReference.packge() != currentClass.packge());\n+    }\n+\n+    \/**\n+     * This method should be called only when target release <= 14\n+     * where LambdaMetaFactory does not spin nestmate classes.\n+     *\n+     * This method should be removed when --release 14 is not supported.\n+     *\/\n+    boolean isPrivateInOtherClass(JCMemberReference tree) {\n+        return (tree.sym.flags() & PRIVATE) != 0 &&\n+                !types.isSameType(\n+                        types.erasure(tree.sym.enclClass().asType()),\n+                        types.erasure(env.enclClass.sym.asType()));\n+    }\n+\n+    \/**\n+     * Does this reference need to be converted to a lambda\n+     * (i.e. var args need to be expanded or \"super\" is used)\n+     *\/\n+    boolean needsConversionToLambda(JCMemberReference tree) {\n+        return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                tree.hasKind(ReferenceKind.SUPER) ||\n+                needsVarArgsConversion(tree) ||\n+                isArrayOp(tree) ||\n+                (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, env.enclClass.sym) ||\n+                !receiverAccessible(tree) ||\n+                (tree.getMode() == ReferenceMode.NEW &&\n+                        tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                        (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+    }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, env.enclClass.sym);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.owner = tree.owner;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, receiverExpression), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = descPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ Use the descriptor parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            make.Ident(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            args.toList()).setType(tree.referentType.getReturnType());\n+\n+            TreeInfo.setVarargsElement(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                TreeInfo.setVarargsElement(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n@@ -863,18 +1134,0 @@\n-    public void visitReference(JCMemberReference tree) {\n-        Type t = types.skipTypeVars(tree.expr.type, false);\n-        Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n-        if (tree.kind == ReferenceKind.UNBOUND) {\n-            tree.expr = make.Type(receiverTarget);\n-        } else {\n-            tree.expr = translate(tree.expr, receiverTarget);\n-        }\n-        if (!tree.type.isIntersection()) {\n-            tree.type = erasure(tree.type);\n-        } else {\n-            tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n-        }\n-        if (tree.varargsElement != null)\n-            tree.varargsElement = erasure(tree.varargsElement);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":271,"deletions":18,"binary":false,"changes":289,"status":"modified"},{"patch":"@@ -1625,8 +1625,0 @@\n-            if (scanner.hasLambdas) {\n-                if (shouldStop(CompileState.UNLAMBDA))\n-                    return;\n-\n-                env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-                compileStates.put(env, CompileState.UNLAMBDA);\n-            }\n-\n@@ -1654,0 +1646,10 @@\n+            if (scanner.hasLambdas) {\n+                if (shouldStop(CompileState.UNLAMBDA))\n+                    return;\n+\n+                for (JCTree def : cdefs) {\n+                    LambdaToMethod.instance(context).translateTopLevelClass(env, def, localMake);\n+                }\n+                compileStates.put(env, CompileState.UNLAMBDA);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1627,0 +1627,6 @@\n+compiler.err.statement.not.expected=\\\n+    statements not expected outside of methods and initializers\n+\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n@@ -2356,0 +2362,5 @@\n+# 0: list of annotation, 1: symbol, 2: name, 3: message segment\n+compiler.err.cant.attach.type.annotations=\\\n+    Cannot attach type annotations {0} to {1}.{2}:\\n\\\n+    {3}\n+\n@@ -2547,2 +2558,11 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=\\\n-    bad RuntimeInvisibleParameterAnnotations attribute: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch=\\\n+    the length of parameters in RuntimeVisibleParameterAnnotations attribute and \\\n+    RuntimeInvisibleParameterAnnotations attribute in: {0} \\\n+    do not match, ignoring both attributes\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations=\\\n+    the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations attributes \\\n+    in: {0} \\\n+    cannot be mapped to the method''s parameters\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -814,0 +814,2 @@\n+        \/** The owner of this functional expression. *\/\n+        public Symbol owner;\n@@ -2029,0 +2031,1 @@\n+        public boolean wasMethodReference;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -360,0 +360,1 @@\n+            result = tree;\n@@ -365,0 +366,1 @@\n+            result = tree;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+    jdk\/management \\\n@@ -290,0 +291,1 @@\n+    jdk\/management\/VirtualThreadSchedulerMXBean \\\n@@ -624,1 +626,0 @@\n-    com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java \\\n@@ -627,2 +628,0 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java \\\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java \\\n@@ -657,0 +656,1 @@\n+    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java \\\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,6 +71,6 @@\n-        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements java.util.List<TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements java.util.List<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements java.util.List<TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements java.util.List<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n","filename":"test\/langtools\/jdk\/jshell\/ComputeFQNsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+compiler.err.cant.attach.type.annotations               # bad class file\n@@ -57,1 +58,2 @@\n-compiler.misc.bad.runtime.invisible.param.annotations   # bad class file\n+compiler.warn.runtime.invisible.parameter.annotations   # bad class file\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch   # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}