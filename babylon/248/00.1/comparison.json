{"files":[{"patch":"@@ -78,0 +78,1 @@\n+    jdk.code.tools \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.util.logging.PlatformLogger;\n@@ -76,1 +77,0 @@\n-        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -91,6 +91,0 @@\n-        HolderClassBuilder addLinkerType(String methodType) {\n-            validateMethodType(methodType);\n-            linkerTypes.add(methodType);\n-            return this;\n-        }\n-\n@@ -122,1 +116,0 @@\n-\n@@ -125,1 +118,0 @@\n-\n@@ -140,17 +132,1 @@\n-            \/\/ The linker type to ask for is retrieved by removing the first\n-            \/\/ and the last argument, which needs to be of Object.class\n-            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n-            index = 0;\n-            for (String linkerType : linkerTypes) {\n-                MethodType mt = asMethodType(linkerType);\n-                final int lastParam = mt.parameterCount() - 1;\n-                if (!checkLinkerTypeParams(mt)) {\n-                    throw new RuntimeException(\n-                            \"Linker type parameter must start and end with Object: \" + linkerType);\n-                }\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n-                index++;\n-            }\n-\n-            \/\/ argument, which needs to be of Object.class\n+            \/\/ and the last argument, which needs to be of Object.class\n@@ -162,0 +138,1 @@\n+                final int lastParam = mt.parameterCount() - 1;\n@@ -164,1 +141,1 @@\n-                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n@@ -166,1 +143,2 @@\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n@@ -185,1 +163,0 @@\n-\n@@ -195,1 +172,1 @@\n-                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n+                            invokerMethodTypes, callSiteMethodTypes));\n@@ -203,1 +180,0 @@\n-\n@@ -209,1 +185,0 @@\n-\n@@ -231,6 +206,0 @@\n-            return (mt.parameterCount() >= 2 &&\n-                    mt.parameterType(0) == Object.class &&\n-                    mt.parameterType(1) == Object.class);\n-        }\n-\n-        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -350,4 +319,8 @@\n-                                } else if (parts[2].endsWith(\"nvoker\")) {\n-                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n-                                    builder.addInvokerType(methodType);\n-                                    builder.addLinkerType(methodType);\n+                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n+                                    \/\/ Work around JDK-8327499\n+                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n+                                        builder.addInvokerType(methodType);\n+                                    } else {\n+                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n+                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n+                                    }\n@@ -491,2 +464,2 @@\n-     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n-     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n@@ -495,2 +468,1 @@\n-            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes) {\n+            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n@@ -501,2 +473,2 @@\n-\n-        int[] invokerTypes = {\n+        int[] types = {\n+            MethodTypeForm.LF_EX_LINKER,\n@@ -504,1 +476,2 @@\n-            MethodTypeForm.LF_GEN_INVOKER,\n+            MethodTypeForm.LF_GEN_LINKER,\n+            MethodTypeForm.LF_GEN_INVOKER\n@@ -507,1 +480,1 @@\n-        for (MethodType methodType : invokerMethodTypes) {\n+        for (int i = 0; i < invokerMethodTypes.length; i++) {\n@@ -509,3 +482,3 @@\n-            if (dedupSet.add(methodType)) {\n-                for (int type : invokerTypes) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n+            if (dedupSet.add(invokerMethodTypes[i])) {\n+                for (int type : types) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n@@ -519,18 +492,0 @@\n-        int[] linkerTypes = {\n-                MethodTypeForm.LF_EX_LINKER,\n-                MethodTypeForm.LF_GEN_LINKER,\n-        };\n-\n-        dedupSet = new HashSet<>();\n-        for (MethodType methodType : linkerMethodTypes) {\n-            \/\/ generate methods representing linkers of the specified type\n-            if (dedupSet.add(methodType)) {\n-                for (int type : linkerTypes) {\n-                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n-                            \/*customized*\/false, type);\n-                    forms.add(linkerForm);\n-                    names.add(linkerForm.kind.defaultLambdaName);\n-                }\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":26,"deletions":71,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -44,0 +46,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -45,0 +48,4 @@\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp.FuncOp;\n+import java.lang.reflect.code.parser.OpParser;\n@@ -77,0 +84,8 @@\n+    \/\/ Static builders to avoid lambdas\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n+\n@@ -82,0 +97,6 @@\n+    private static final ClassDesc CD_Quoted = Quoted.class.describeConstable().get();\n+    private static final MethodTypeDesc MTD_Quoted = MethodTypeDescImpl.ofValidated(CD_Quoted);\n+    private static final String NAME_METHOD_QUOTED = \"quoted\";\n+    private static final MethodHandle HANDLE_MAKE_QUOTED;\n+    private static final String quotedInstanceFieldName = \"quoted\";\n+\n@@ -91,0 +112,8 @@\n+\n+        try {\n+            HANDLE_MAKE_QUOTED = MethodHandles.lookup().findStatic(\n+                    InnerClassLambdaMetafactory.class, \"makeQuoted\",\n+                    MethodType.methodType(Quoted.class, String.class, Object[].class));\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n@@ -154,1 +183,2 @@\n-                                       MethodType[] altMethods)\n+                                       MethodType[] altMethods,\n+                                       MethodHandle reflectiveField)\n@@ -158,1 +188,1 @@\n-              isSerializable, altInterfaces, altMethods);\n+              isSerializable, altInterfaces, altMethods, reflectiveField);\n@@ -319,0 +349,5 @@\n+                \/\/ if quotable, generate the field that will hold the value of quoted\n+                if (quotableOpField != null) {\n+                    clb.withField(quotedInstanceFieldName, CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n+                }\n+\n@@ -345,0 +380,4 @@\n+\n+                if (quotableOpField != null) {\n+                    generateQuotableMethod(clb);\n+                }\n@@ -352,1 +391,8 @@\n-            var classdata = useImplMethodHandle? implementation : null;\n+            List<?> classdata;\n+            if (useImplMethodHandle || quotableOpField != null) {\n+                classdata = quotableOpField == null ?\n+                        List.of(implementation) :\n+                        List.of(implementation, quotableOpField, HANDLE_MAKE_QUOTED);\n+            } else {\n+                classdata = null;\n+            }\n@@ -402,0 +448,3 @@\n+                        if (quotableOpField != null) {\n+                            generateQuotedFieldInitializer(cob);\n+                        }\n@@ -407,0 +456,36 @@\n+    private void generateQuotedFieldInitializer(CodeBuilder cob) {\n+        ConstantPoolBuilder cp = cob.constantPool();\n+        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        cob.aload(0)\n+           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+        \/\/ load op string from field\n+           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+        MethodType mtype = quotableOpFieldInfo.getMethodType();\n+        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+            mtype = mtype.insertParameterTypes(0, implClass);\n+        }\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n+\n+        \/\/ load captured args in array\n+\n+        cob.loadConstant(quotableOpType.parameterCount())\n+           .anewarray(CD_Object);\n+        int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n+        \/\/ initialize quoted captures\n+        for (int i = 0; i < reflectiveCaptureCount(); i++) {\n+            cob.dup()\n+               .loadConstant(i)\n+               .aload(0)\n+               .getfield(lambdaClassEntry.asSymbol(), argNames[capturedArity + i], argDescs[capturedArity + i]);\n+            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[capturedArity + i]));\n+            cob.aastore();\n+        }\n+\n+        \/\/ now create a Quoted from String and captured args Object[]\n+\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(HANDLE_MAKE_QUOTED.type()))\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CD_Quoted);\n+    }\n+\n@@ -463,0 +548,14 @@\n+    \/**\n+     * Generate a writeReplace method that supports serialization\n+     *\/\n+    private void generateQuotableMethod(ClassBuilder clb) {\n+        clb.withMethod(NAME_METHOD_QUOTED, MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                cob.aload(0)\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CD_Quoted)\n+                   .areturn();\n+            }\n+        }));\n+    }\n+\n@@ -506,1 +605,1 @@\n-                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA_AT), List.of(cp.intEntry(0))),\n@@ -509,1 +608,1 @@\n-                for (int i = 0; i < argNames.length; i++) {\n+                for (int i = 0; i < argNames.length - reflectiveCaptureCount(); i++) {\n@@ -539,1 +638,1 @@\n-        int captureArity = factoryType.parameterCount();\n+        int captureArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -547,0 +646,5 @@\n+    private static Quoted makeQuoted(String opText, Object[] args) {\n+        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n+        return (Quoted)Interpreter.invoke(Lookup.IMPL_LOOKUP, op, args);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":110,"deletions":6,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.parser.OpParser;\n@@ -49,0 +52,2 @@\n+import java.util.List;\n+import java.util.Optional;\n@@ -51,0 +56,3 @@\n+import static java.lang.reflect.code.op.CoreOp.*;\n+import java.lang.reflect.code.type.MethodRef;\n+\n@@ -100,0 +108,1 @@\n+    private volatile Optional<FuncOp>     codeModel;\n@@ -235,0 +244,58 @@\n+    \/**\n+     * Returns the code model of the method body, if present.\n+     * @return the code model of the method body.\n+     * @since 99\n+     *\/\n+    \/\/ @@@ Make caller sensitive with the same access control as invoke\n+    \/\/ and throwing IllegalAccessException\n+\/\/    @CallerSensitive\n+    public Optional<FuncOp> getCodeModel() {\n+        Optional<FuncOp> localRef = codeModel;\n+        if (localRef == null) {\n+            synchronized (this) {\n+                localRef = codeModel;\n+                if (localRef == null) {\n+                    Optional<FuncOp> op = createCodeModel();\n+                    codeModel = localRef = op;\n+                }\n+            }\n+        }\n+        return localRef;\n+    }\n+\n+    private Optional<FuncOp> createCodeModel() {\n+        Class<?> dc = getDeclaringClass();\n+        char[] sig = MethodRef.method(this).toString().toCharArray();\n+        for (int i = 0; i < sig.length; i++) {\n+            switch (sig[i]) {\n+                case '.', ';', '[', '\/': sig[i] = '$';\n+            }\n+        }\n+        String fieldName = new String(sig) + \"$\" + \"op\";\n+        Field f;\n+        try {\n+            f = dc.getDeclaredField(fieldName);\n+        } catch (NoSuchFieldException e) {\n+            return Optional.empty();\n+        }\n+\n+        String modelText;\n+        try {\n+            \/\/ @@@ Use method handle with full power mode\n+            f.setAccessible(true);\n+            modelText = (String) f.get(null);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        FuncOp op;\n+        try {\n+            List<Op> ops = OpParser.fromString(ExtendedOp.FACTORY, modelText);\n+            op = (FuncOp) ops.get(0);\n+        } catch (RuntimeException e) {\n+            \/\/ @@@ Error or Exception?\n+            throw e;\n+        }\n+        return Optional.of(op);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * BranchCompactor is a CodeTransform skipping redundant branches to immediate targets.\n+ *\/\n+public final class BranchCompactor implements CodeTransform {\n+\n+    private BranchInstruction branch;\n+    private final List<PseudoInstruction> buffer = new ArrayList<>();\n+\n+    public BranchCompactor() {\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        if (branch == null) {\n+            if (coe instanceof BranchInstruction bi && BytecodeHelpers.isUnconditionalBranch(bi.opcode())) {\n+                \/\/unconditional branch is stored\n+                branch = bi;\n+            } else {\n+                \/\/all other elements are passed\n+                cob.with(coe);\n+            }\n+        } else {\n+            switch (coe) {\n+                case LabelTarget lt when branch.target() == lt.label() -> {\n+                    \/\/skip branch to immediate target\n+                    branch = null;\n+                    \/\/flush the buffer\n+                    atEnd(cob);\n+                    \/\/pass the target\n+                    cob.with(lt);\n+                }\n+                case PseudoInstruction pi -> {\n+                    \/\/buffer pseudo instructions\n+                    buffer.add(pi);\n+                }\n+                default -> {\n+                    \/\/any other instruction flushes the branch and buffer\n+                    atEnd(cob);\n+                    \/\/replay the code element\n+                    accept(cob, coe);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        if (branch != null) {\n+            \/\/flush the branch\n+            cob.with(branch);\n+            branch = null;\n+        }\n+        \/\/flush the buffer\n+        buffer.forEach(cob::with);\n+        buffer.clear();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,1350 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.Constable;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicCallSiteDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.StringConcatFactory;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.CoreOp.*;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Transformer of code models to bytecode.\n+ *\/\n+public final class BytecodeGenerator {\n+\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_METAFACTORY = ofCallsiteBootstrap(\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"metafactory\",\n+            CD_CallSite, CD_MethodType, CD_MethodHandle, CD_MethodType);\n+\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_ALT_METAFACTORY = ofCallsiteBootstrap(\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"altMetafactory\",\n+            CD_CallSite, CD_Object.arrayType());\n+\n+    private static final DirectMethodHandleDesc DMHD_STRING_CONCAT = ofCallsiteBootstrap(\n+            StringConcatFactory.class.describeConstable().orElseThrow(),\n+            \"makeConcat\",\n+            CD_CallSite);\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of hidden class and exposed\n+     * for invocation via a method handle.\n+     *\n+     * @param l the lookup\n+     * @param iop the invokable operation to transform to bytecode\n+     * @return the invoking method handle\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    public static <O extends Op & Op.Invokable> MethodHandle generate(MethodHandles.Lookup l, O iop) {\n+        String name = iop instanceof FuncOp fop ? fop.funcName() : \"m\";\n+        byte[] classBytes = generateClassData(l, name, iop);\n+\n+        MethodHandles.Lookup hcl;\n+        try {\n+            hcl = l.defineHiddenClass(classBytes, true, MethodHandles.Lookup.ClassOption.NESTMATE);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            FunctionType ft = iop.invokableType();\n+            MethodType mt = MethodRef.toNominalDescriptor(ft).resolveConstantDesc(hcl);\n+            return hcl.findStatic(hcl.lookupClass(), name, mt);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Transforms the function operation to bytecode encapsulated in a method of a class file.\n+     * <p>\n+     * The name of the method is the function operation's {@link FuncOp#funcName() function name}.\n+     *\n+     * @param lookup the lookup\n+     * @param fop the function operation to transform to bytecode\n+     * @return the class file bytes\n+     *\/\n+    public static byte[] generateClassData(MethodHandles.Lookup lookup, FuncOp fop) {\n+        ClassModel generatedModel = ClassFile.of().parse(generateClassData(lookup, fop.funcName(), fop));\n+        \/\/ Compact locals of the generated bytecode\n+        return ClassFile.of().transformClass(generatedModel, LocalsCompactor.INSTANCE);\n+    }\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n+     *\n+     * @param lookup the lookup\n+     * @param name the name to use for the method of the class file\n+     * @param iop the invokable operation to transform to bytecode\n+     * @return the class file bytes\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                                                         String name,\n+                                                                         O iop) {\n+        if (!iop.capturedValues().isEmpty()) {\n+            throw new UnsupportedOperationException(\"Operation captures values\");\n+        }\n+\n+        String packageName = lookup.lookupClass().getPackageName();\n+        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n+                ? name\n+                : packageName + \".\" + name);\n+        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+            List<LambdaOp> lambdaSink = new ArrayList<>();\n+            BitSet quotable = new BitSet();\n+            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n+            for (int i = 0; i < lambdaSink.size(); i++) {\n+                LambdaOp lop = lambdaSink.get(i);\n+                if (quotable.get(i)) {\n+                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n+                            .withFlags(ClassFile.ACC_STATIC)\n+                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                }\n+                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n+            }\n+        });\n+        return classBytes;\n+    }\n+\n+    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup,\n+                                                                     ClassDesc className,\n+                                                                     String methodName,\n+                                                                     O iop,\n+                                                                     ClassBuilder clb,\n+                                                                     List<LambdaOp> lambdaSink,\n+                                                                     BitSet quotable) {\n+\n+        List<Value> capturedValues = iop instanceof LambdaOp lop ? lop.capturedValues() : List.of();\n+        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(\n+                iop.invokableType()).insertParameterTypes(0, capturedValues.stream()\n+                        .map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        clb.withMethodBody(methodName, mtd, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                    new BytecodeGenerator(lookup, className, capturedValues, TypeKind.from(mtd.returnType()), new Liveness(iop),\n+                                          iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n+    }\n+\n+    private record Slot(int slot, TypeKind typeKind) {}\n+    private record ExceptionRegionWithBlocks(ExceptionRegionEnter ere, BitSet blocks) {}\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final ClassDesc className;\n+    private final List<Value> capturedValues;\n+    private final TypeKind returnType;\n+    private final List<Block> blocks;\n+    private final CodeBuilder cob;\n+    private final Label[] blockLabels;\n+    private final List<ExceptionRegionWithBlocks> allExceptionRegions;\n+    private final BitSet[] blocksRegionStack;\n+    private final BitSet blocksToVisit, catchingBlocks;\n+    private final Map<Value, Slot> slots;\n+    private final Map<Block.Parameter, Value> singlePredecessorsValues;\n+    private final List<LambdaOp> lambdaSink;\n+    private final BitSet quotable;\n+    private final Map<Op, Boolean> deferCache;\n+    private Value oprOnStack;\n+\n+    private BytecodeGenerator(MethodHandles.Lookup lookup,\n+                              ClassDesc className,\n+                              List<Value> capturedValues,\n+                              TypeKind returnType,\n+                              Liveness liveness,\n+                              List<Block> blocks,\n+                              CodeBuilder cob,\n+                              List<LambdaOp> lambdaSink,\n+                              BitSet quotable) {\n+        this.lookup = lookup;\n+        this.className = className;\n+        this.capturedValues = capturedValues;\n+        this.returnType = returnType;\n+        this.blocks = blocks;\n+        this.cob = cob;\n+        this.blockLabels = new Label[blocks.size()];\n+        this.allExceptionRegions = new ArrayList<>();\n+        this.blocksRegionStack = new BitSet[blocks.size()];\n+        this.blocksToVisit = new BitSet(blocks.size());\n+        this.catchingBlocks = new BitSet();\n+        this.slots = new HashMap<>();\n+        this.singlePredecessorsValues = new HashMap<>();\n+        this.lambdaSink = lambdaSink;\n+        this.quotable = quotable;\n+        this.deferCache = new HashMap<>();\n+    }\n+\n+    private void setExceptionRegionStack(Block.Reference target, BitSet activeRegionStack) {\n+        setExceptionRegionStack(target.targetBlock().index(), activeRegionStack);\n+    }\n+\n+    private void setExceptionRegionStack(int blockIndex, BitSet activeRegionStack) {\n+        if (blocksRegionStack[blockIndex] == null) {\n+            blocksToVisit.set(blockIndex);\n+            blocksRegionStack[blockIndex] = activeRegionStack;\n+            activeRegionStack.stream().forEach(r -> allExceptionRegions.get(r).blocks.set(blockIndex));\n+        }\n+    }\n+\n+    private Label getLabel(Block.Reference target) {\n+        return getLabel(target.targetBlock().index());\n+    }\n+\n+    private Label getLabel(int blockIndex) {\n+        if (blockIndex == blockLabels.length) {\n+            return cob.endLabel();\n+        }\n+        Label l = blockLabels[blockIndex];\n+        if (l == null) {\n+            blockLabels[blockIndex] = l = cob.newLabel();\n+        }\n+        return l;\n+    }\n+\n+    private Slot allocateSlot(Value v) {\n+        return slots.computeIfAbsent(v, _ -> {\n+            TypeKind tk = toTypeKind(v.type());\n+            return new Slot(cob.allocateLocal(tk), tk);\n+        });\n+    }\n+\n+    private void storeIfUsed(Value v) {\n+        if (!v.uses().isEmpty()) {\n+            Slot slot = allocateSlot(v);\n+            cob.storeLocal(slot.typeKind(), slot.slot());\n+        } else {\n+            \/\/ Only pop results from stack if the value has no further use (no valid slot)\n+            switch (toTypeKind(v.type()).slotSize()) {\n+                case 1 -> cob.pop();\n+                case 2 -> cob.pop2();\n+            }\n+        }\n+    }\n+\n+    private void load(Value v) {\n+        v = singlePredecessorsValues.getOrDefault(v, v);\n+        if (v instanceof Op.Result or &&\n+                or.op() instanceof ConstantOp constantOp &&\n+                !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n+            cob.loadConstant(switch (constantOp.value()) {\n+                case null -> null;\n+                case Boolean b -> {\n+                    yield b ? 1 : 0;\n+                }\n+                case Byte b -> (int)b;\n+                case Character ch -> (int)ch;\n+                case Short s -> (int)s;\n+                case Constable c -> c.describeConstable().orElseThrow();\n+                default -> throw new IllegalArgumentException(\"Unexpected constant value: \" + constantOp.value());\n+            });\n+        } else {\n+            Slot slot = slots.get(v);\n+            if (slot == null) {\n+                if (v instanceof Op.Result or) {\n+                    \/\/ Handling of deferred variables\n+                    switch (or.op()) {\n+                        case VarOp vop ->\n+                            load(vop.initOperand());\n+                        case VarAccessOp.VarLoadOp vlop ->\n+                            load(vlop.varOperand());\n+                        default ->\n+                            throw new IllegalStateException(\"Missing slot for: \" + or.op());\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"Missing slot for: \" + v);\n+                }\n+            } else {\n+                cob.loadLocal(slot.typeKind(), slot.slot());\n+            }\n+        }\n+    }\n+\n+    private void processFirstOperand(Op op) {\n+        processOperand(op.operands().getFirst());\n+    }\n+\n+    private void processOperand(Value operand) {\n+        if (oprOnStack == null) {\n+            load(operand);\n+        } else {\n+            assert oprOnStack == operand;\n+            oprOnStack = null;\n+        }\n+    }\n+\n+    private void processOperands(Op op) {\n+        processOperands(op.operands());\n+    }\n+\n+    private void processOperands(List<Value> operands) {\n+        if (oprOnStack == null) {\n+            operands.forEach(this::load);\n+        } else {\n+            assert !operands.isEmpty() && oprOnStack == operands.getFirst();\n+            oprOnStack = null;\n+            for (int i = 1; i < operands.size(); i++) {\n+                load(operands.get(i));\n+            }\n+        }\n+    }\n+\n+    \/\/ Some of the operations can be deferred\n+    private boolean canDefer(Op op) {\n+        Boolean can = deferCache.get(op);\n+        if (can == null) {\n+            can = switch (op) {\n+                case ConstantOp cop -> canDefer(cop);\n+                case VarOp vop -> canDefer(vop);\n+                case VarAccessOp.VarLoadOp vlop -> canDefer(vlop);\n+                default -> false;\n+            };\n+            deferCache.put(op, can);\n+        }\n+        return can;\n+    }\n+\n+    \/\/ Constant can be deferred, except for loading of a class constant, which  may throw an exception\n+    private static boolean canDefer(ConstantOp op) {\n+        return !op.resultType().equals(JavaType.J_L_CLASS);\n+    }\n+\n+    \/\/ Single-use var or var with a single-use entry block parameter operand can be deferred\n+    private static boolean canDefer(VarOp op) {\n+        return !moreThanOneUse(op.result())\n+            || op.operands().getFirst() instanceof Block.Parameter bp && bp.declaringBlock().isEntryBlock() && !moreThanOneUse(bp)\n+            || op.initOperand() instanceof Op.Result or && or.op() instanceof ConstantOp cop && canDefer(cop) && isDefinitelyAssigned(op);\n+\n+    }\n+\n+    \/\/ Detection if VarOp is definitelly assigned (all its VarLoadOps are dominated by VarStoreOp)\n+    \/\/ VarOp can be deferred in such case\n+    private static boolean isDefinitelyAssigned(VarOp op) {\n+        Set<Op.Result> allUses = op.result().uses();\n+        Set<Op.Result> stores = allUses.stream().filter(r -> r.op() instanceof VarAccessOp.VarStoreOp).collect(Collectors.toSet());\n+        \/\/ All VarLoadOps must be dominated by a VarStoreOp\n+        for (Op.Result load : allUses) {\n+            if (load.op() instanceof VarAccessOp.VarLoadOp && !isDominatedBy(load, stores)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ @@@ Test for dominant set\n+    private static boolean isDominatedBy(Op.Result n, Set<Op.Result> doms) {\n+        for (Op.Result dom : doms) {\n+            if (n.isDominatedBy(dom)) {\n+                return true;\n+            }\n+        }\n+\n+        Set<Block> stopBlocks = new HashSet<>();\n+        for (Op.Result dom : doms) {\n+            stopBlocks.add(dom.declaringBlock());\n+        }\n+\n+        Deque<Block> toProcess = new ArrayDeque<>();\n+        toProcess.add(n.declaringBlock());\n+        stopBlocks.add(n.declaringBlock());\n+        while (!toProcess.isEmpty()) {\n+            for (Block b : toProcess.pop().predecessors()) {\n+                if (b.isEntryBlock()) {\n+                    return false;\n+                }\n+                if (stopBlocks.add(b)) {\n+                    toProcess.add(b);\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/\/ Var load can be deferred when not used as immediate operand\n+    private boolean canDefer(VarAccessOp.VarLoadOp op) {\n+        return !isNextUse(op.result());\n+    }\n+\n+    \/\/ This method narrows the first operand inconveniences of some operations\n+    private static boolean isFirstOperand(Op nextOp, Value opr) {\n+        List<Value> values;\n+        return switch (nextOp) {\n+            \/\/ When there is no next operation\n+            case null -> false;\n+            \/\/ New object cannot use first operand from stack, new array fall through to the default\n+            case NewOp op when !(op.constructorType().returnType() instanceof ArrayType) ->\n+                false;\n+            \/\/ For lambda the effective operands are captured values\n+            case LambdaOp op ->\n+                !(values = op.capturedValues()).isEmpty() && values.getFirst() == opr;\n+            \/\/ Conditional branch may delegate to its binary test operation\n+            case ConditionalBranchOp op when getConditionForCondBrOp(op) instanceof BinaryTestOp bto ->\n+                isFirstOperand(bto, opr);\n+            \/\/ Var store effective first operand is not the first one\n+            case VarAccessOp.VarStoreOp op ->\n+                op.operands().get(1) == opr;\n+            \/\/ Unconditional branch first target block argument\n+            case BranchOp op ->\n+                !(values = op.branch().arguments()).isEmpty() && values.getFirst() == opr;\n+            \/\/ regular check of the first operand\n+            default ->\n+                !(values = nextOp.operands()).isEmpty() && values.getFirst() == opr;\n+        };\n+    }\n+\n+    \/\/ Determines if the operation result is immediatelly used by the next operation and so can stay on stack\n+    private boolean isNextUse(Value opr) {\n+        Op nextOp = switch (opr) {\n+            case Block.Parameter p -> p.declaringBlock().firstOp();\n+            case Op.Result r -> r.declaringBlock().nextOp(r.op());\n+        };\n+        \/\/ Pass over deferred operations\n+        while (canDefer(nextOp)) {\n+            nextOp = nextOp.parentBlock().nextOp(nextOp);\n+        }\n+        return isFirstOperand(nextOp, opr);\n+    }\n+\n+    private static boolean isConditionForCondBrOp(BinaryTestOp op) {\n+        \/\/ Result of op has one use as the operand of a CondBrOp op,\n+        \/\/ and both ops are in the same block\n+\n+        Set<Op.Result> uses = op.result().uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+        Op.Result use = uses.iterator().next();\n+\n+        if (use.declaringBlock() != op.parentBlock()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : use.op().successors()) {\n+            if (s.arguments().contains(op.result())) {\n+                return false;\n+            }\n+        }\n+\n+        return use.op() instanceof ConditionalBranchOp;\n+    }\n+\n+    static ClassDesc toClassDesc(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toClassDesc(vt.valueType());\n+            case JavaType jt -> jt.toNominalDescriptor();\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n+    static TypeKind toTypeKind(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toTypeKind(vt.valueType());\n+            case PrimitiveType pt -> TypeKind.from(pt.toNominalDescriptor());\n+            case JavaType _ -> TypeKind.REFERENCE;\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n+    private void generate() {\n+        \/\/ Compute exception region membership\n+        setExceptionRegionStack(0, new BitSet());\n+        int blockIndex;\n+        while ((blockIndex = blocksToVisit.nextSetBit(0)) >= 0) {\n+            blocksToVisit.clear(blockIndex);\n+            BitSet activeRegionStack = blocksRegionStack[blockIndex];\n+            Block b = blocks.get(blockIndex);\n+            Op top = b.terminatingOp();\n+            switch (top) {\n+                case BranchOp bop ->\n+                    setExceptionRegionStack(bop.branch(), activeRegionStack);\n+                case ConditionalBranchOp cop -> {\n+                    setExceptionRegionStack(cop.falseBranch(), activeRegionStack);\n+                    setExceptionRegionStack(cop.trueBranch(), activeRegionStack);\n+                }\n+                case ExceptionRegionEnter er -> {\n+                    for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n+                        catchingBlocks.set(catchBlock.targetBlock().index());\n+                        setExceptionRegionStack(catchBlock, activeRegionStack);\n+                    }\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.set(allExceptionRegions.size());\n+                    ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n+                    allExceptionRegions.add(newNode);\n+                    setExceptionRegionStack(er.start(), activeRegionStack);\n+                }\n+                case ExceptionRegionExit er -> {\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.clear(activeRegionStack.length() - 1);\n+                    setExceptionRegionStack(er.end(), activeRegionStack);\n+                }\n+                default -> {\n+                }\n+            }\n+        }\n+\n+        \/\/ Declare the exception regions\n+        for (ExceptionRegionWithBlocks erNode : allExceptionRegions.reversed()) {\n+            int start  = erNode.blocks.nextSetBit(0);\n+            while (start >= 0) {\n+                int end = erNode.blocks.nextClearBit(start);\n+                \/\/ Avoid declaration of empty exception regions\n+                if (!(blocks.get(start).firstOp() instanceof ExceptionRegionExit erEx) || erEx.end().targetBlock().index() != end) {\n+                    Label startLabel = getLabel(start);\n+                    Label endLabel = getLabel(end);\n+                    for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                        List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                        if (!params.isEmpty()) {\n+                            JavaType jt = (JavaType) params.get(0).type();\n+                            cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n+                        } else {\n+                            cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                        }\n+                    }\n+                }\n+                start = erNode.blocks.nextSetBit(end);\n+            }\n+        }\n+\n+        \/\/ Process blocks in topological order\n+        \/\/ A jump instruction assumes the false successor block is\n+        \/\/ immediately after, in sequence, to the predecessor\n+        \/\/ since the jump instructions branch on a true condition\n+        \/\/ Conditions are inverted when lowered to bytecode\n+        for (Block b : blocks) {\n+            \/\/ Ignore any non-entry blocks that have no predecessors\n+            if (!b.isEntryBlock() && b.predecessors().isEmpty()) {\n+                continue;\n+            }\n+\n+            Label blockLabel = getLabel(b.index());\n+            cob.labelBinding(blockLabel);\n+\n+            \/\/ If b is the entry block then all its parameters conservatively require slots\n+            \/\/ Some unused parameters might be declared before others that are used\n+            if (b.isEntryBlock()) {\n+                List<Block.Parameter> parameters = b.parameters();\n+                int i = 0;\n+                \/\/ Captured values prepend parameters in lambda impl methods\n+                for (Value cv : capturedValues) {\n+                    slots.put(cv, new Slot(cob.parameterSlot(i++), toTypeKind(cv.type())));\n+                }\n+                for (Block.Parameter bp : parameters) {\n+                    slots.put(bp, new Slot(cob.parameterSlot(i++), toTypeKind(bp.type())));\n+                }\n+            }\n+\n+            oprOnStack = null;\n+\n+            \/\/ If b is a catch block then the exception argument will be represented on the stack\n+            if (catchingBlocks.get(b.index())) {\n+                \/\/ Retain block argument for exception table generation\n+                push(b.parameters().getFirst());\n+            }\n+\n+            List<Op> ops = b.ops();\n+            for (int i = 0; i < ops.size() - 1; i++) {\n+                final Op o = ops.get(i);\n+                final TypeElement oprType = o.resultType();\n+                final TypeKind rvt = toTypeKind(oprType);\n+                switch (o) {\n+                    case ConstantOp op -> {\n+                        if (!canDefer(op)) {\n+                            \/\/ Constant can be deferred, except for a class constant, which  may throw an exception\n+                            Object v = op.value();\n+                            if (v == null) {\n+                                cob.aconst_null();\n+                            } else {\n+                                cob.ldc(((JavaType)v).toNominalDescriptor());\n+                            }\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarOp op -> {\n+                        \/\/     %1 : Var<int> = var %0 @\"i\";\n+                        if (canDefer(op)) {\n+                            Slot s = slots.get(op.operands().getFirst());\n+                            if (s != null) {\n+                                \/\/ Var with a single-use entry block parameter can reuse its slot\n+                                slots.put(op.result(), s);\n+                            }\n+                        } else {\n+                            processFirstOperand(op);\n+                            storeIfUsed(op.result());\n+                        }\n+                    }\n+                    case VarAccessOp.VarLoadOp op -> {\n+                        if (canDefer(op)) {\n+                            \/\/ Var load can be deferred when not used as immediate operand\n+                            slots.computeIfAbsent(op.result(), r -> slots.get(op.operands().getFirst()));\n+                        } else {\n+                            load(op.operands().getFirst());\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarAccessOp.VarStoreOp op -> {\n+                        processOperand(op.operands().get(1));\n+                        Slot slot = allocateSlot(op.operands().getFirst());\n+                        cob.storeLocal(slot.typeKind(), slot.slot());\n+                    }\n+                    case ConvOp op -> {\n+                        Value first = op.operands().getFirst();\n+                        processOperand(first);\n+                        cob.conversion(toTypeKind(first.type()), rvt);\n+                        push(op.result());\n+                    }\n+                    case NegOp op -> {\n+                        processFirstOperand(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::neg(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.ineg();\n+                            case LONG -> cob.lneg();\n+                            case FLOAT -> cob.fneg();\n+                            case DOUBLE -> cob.dneg();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ComplOp op -> {\n+                        \/\/ Lower to x ^ -1\n+                        processFirstOperand(op);\n+                        switch (rvt) {\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> {\n+                                cob.iconst_m1();\n+                                cob.ixor();\n+                            }\n+                            case LONG -> {\n+                                cob.ldc(-1L);\n+                                cob.lxor();\n+                            }\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case NotOp op -> {\n+                        processFirstOperand(op);\n+                        cob.ifThenElse(CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                        push(op.result());\n+                    }\n+                    case AddOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::add(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.iadd();\n+                            case LONG -> cob.ladd();\n+                            case FLOAT -> cob.fadd();\n+                            case DOUBLE -> cob.dadd();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case SubOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::sub(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.isub();\n+                            case LONG -> cob.lsub();\n+                            case FLOAT -> cob.fsub();\n+                            case DOUBLE -> cob.dsub();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case MulOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::mul(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.imul();\n+                            case LONG -> cob.lmul();\n+                            case FLOAT -> cob.fmul();\n+                            case DOUBLE -> cob.dmul();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case DivOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::div(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.idiv();\n+                            case LONG -> cob.ldiv();\n+                            case FLOAT -> cob.fdiv();\n+                            case DOUBLE -> cob.ddiv();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ModOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::rem(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.irem();\n+                            case LONG -> cob.lrem();\n+                            case FLOAT -> cob.frem();\n+                            case DOUBLE -> cob.drem();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case AndOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::and(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.iand();\n+                            case LONG -> cob.land();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case OrOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::or(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.ior();\n+                            case LONG -> cob.lor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case XorOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::xor(TypeKind)\n+                            case INT, BOOLEAN, BYTE, SHORT, CHAR -> cob.ixor();\n+                            case LONG -> cob.lxor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case LshlOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shl(TypeKind)\n+                            case BYTE, CHAR, INT, SHORT -> cob.ishl();\n+                            case LONG -> cob.lshl();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case AshrOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shr(TypeKind)\n+                            case INT, BYTE, SHORT, CHAR -> cob.ishr();\n+                            case LONG -> cob.lshr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case LshrOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::ushr(TypeKind)\n+                            case INT, BYTE, SHORT, CHAR -> cob.iushr();\n+                            case LONG -> cob.lushr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ArrayAccessOp.ArrayLoadOp op -> {\n+                        processOperands(op);\n+                        cob.arrayLoad(rvt);\n+                        push(op.result());\n+                    }\n+                    case ArrayAccessOp.ArrayStoreOp op -> {\n+                        processOperands(op);\n+                        cob.arrayStore(toTypeKind(((ArrayType)op.operands().getFirst().type()).componentType()));\n+                        push(op.result());\n+                    }\n+                    case ArrayLengthOp op -> {\n+                        processFirstOperand(op);\n+                        cob.arraylength();\n+                        push(op.result());\n+                    }\n+                    case BinaryTestOp op -> {\n+                        if (!isConditionForCondBrOp(op)) {\n+                            cob.ifThenElse(prepareConditionalBranch(op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                            push(op.result());\n+                        }\n+                        \/\/ Processing is deferred to the CondBrOp, do not process the op result\n+                    }\n+                    case NewOp op -> {\n+                        switch (op.constructorType().returnType()) {\n+                            case ArrayType at -> {\n+                                processOperands(op);\n+                                if (at.dimensions() == 1) {\n+                                    ClassDesc ctd = at.componentType().toNominalDescriptor();\n+                                    if (ctd.isPrimitive()) {\n+                                        cob.newarray(TypeKind.from(ctd));\n+                                    } else {\n+                                        cob.anewarray(ctd);\n+                                    }\n+                                } else {\n+                                    cob.multianewarray(at.toNominalDescriptor(), op.operands().size());\n+                                }\n+                            }\n+                            case JavaType jt -> {\n+                                cob.new_(jt.toNominalDescriptor())\n+                                    .dup();\n+                                processOperands(op);\n+                                cob.invokespecial(\n+                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n+                                        ConstantDescs.INIT_NAME,\n+                                        MethodRef.toNominalDescriptor(op.constructorType())\n+                                                 .changeReturnType(ConstantDescs.CD_void));\n+                            }\n+                            default ->\n+                                throw new IllegalArgumentException(\"Invalid return type: \"\n+                                                                    + op.constructorType().returnType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case InvokeOp op -> {\n+                        \/\/ @@@ var args\n+                        processOperands(op);\n+                        \/\/ Resolve referenced class to determine if interface\n+                        MethodRef md = op.invokeDescriptor();\n+                        JavaType refType = (JavaType)md.refType();\n+                        Class<?> refClass;\n+                        try {\n+                             refClass = (Class<?>)refType.erasure().resolve(lookup);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                        \/\/ Determine invoke opcode\n+                        final boolean isInterface = refClass.isInterface();\n+                        if (op.isVarArgs()) {\n+                            throw new UnsupportedOperationException(\"invoke varargs unsupported: \" + op.invokeDescriptor());\n+                        }\n+                        Opcode invokeOpcode = switch (op.invokeKind()) {\n+                            case STATIC ->\n+                                    Opcode.INVOKESTATIC;\n+                            case INSTANCE ->\n+                                    isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL;\n+                            case SUPER ->\n+                                    \/\/ @@@ We cannot generate an invokespecial as it will result in a verify error,\n+                                    \/\/     since the owner is not assignable to generated hidden class\n+                                    \/\/ @@@ Construct method handle via lookup.findSpecial\n+                                    \/\/     using the lookup's class as the specialCaller and\n+                                    \/\/     add that method handle to the to be defined hidden class's constant data\n+                                    \/\/     Use and ldc+constant dynamic to access the class data,\n+                                    \/\/     extract the method handle and then invoke it\n+                                    throw new UnsupportedOperationException(\"invoke super unsupported: \" + op.invokeDescriptor());\n+                        };\n+                        MethodTypeDesc mDesc = MethodRef.toNominalDescriptor(md.type());\n+                        cob.invoke(\n+                                invokeOpcode,\n+                                refType.toNominalDescriptor(),\n+                                md.name(),\n+                                mDesc,\n+                                isInterface);\n+                        ClassDesc ret = toClassDesc(op.resultType());\n+                        if (ret.isClassOrInterface() && !ret.equals(mDesc.returnType())) {\n+                            \/\/ Explicit cast if method return type differs\n+                            cob.checkcast(ret);\n+                        }\n+                        push(op.result());\n+                    }\n+                    case FieldAccessOp.FieldLoadOp op -> {\n+                        processOperands(op);\n+                        FieldRef fd = op.fieldDescriptor();\n+                        if (op.operands().isEmpty()) {\n+                            cob.getstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        } else {\n+                            cob.getfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case FieldAccessOp.FieldStoreOp op -> {\n+                        processOperands(op);\n+                        FieldRef fd = op.fieldDescriptor();\n+                        if (op.operands().size() == 1) {\n+                            cob.putstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        } else {\n+                            cob.putfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        }\n+                    }\n+                    case InstanceOfOp op -> {\n+                        processFirstOperand(op);\n+                        cob.instanceOf(((JavaType) op.type()).toNominalDescriptor());\n+                        push(op.result());\n+                    }\n+                    case CastOp op -> {\n+                        processFirstOperand(op);\n+                        cob.checkcast(((JavaType) op.type()).toNominalDescriptor());\n+                        push(op.result());\n+                    }\n+                    case LambdaOp op -> {\n+                        JavaType intfType = (JavaType)op.functionalInterface();\n+                        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                        try {\n+                            Class<?> intfClass = (Class<?>)intfType.erasure().resolve(lookup);\n+                            processOperands(op.capturedValues());\n+                            ClassDesc[] captureTypes = op.capturedValues().stream()\n+                                    .map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n+                            int lambdaIndex = lambdaSink.size();\n+                            if (Quotable.class.isAssignableFrom(intfClass)) {\n+                                \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                for (Value cv : op.capturedValues()) {\n+                                    load(cv);\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_ALT_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        \/\/ @@@ double the descriptor parameters\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(),\n+                                                          Stream.concat(Stream.of(captureTypes),\n+                                                                        Stream.of(captureTypes)).toList()),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                                  className,\n+                                                                  \"lambda$\" + lambdaIndex,\n+                                                                  mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        LambdaMetafactory.FLAG_QUOTABLE,\n+                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER,\n+                                                                 className,\n+                                                                 \"lambda$\" + lambdaIndex + \"$op\",\n+                                                                 CD_String)));\n+                                quotable.set(lambdaSink.size());\n+                            } else {\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                                  className,\n+                                                                  \"lambda$\" + lambdaIndex,\n+                                                                  mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd));\n+                            }\n+                            lambdaSink.add(op);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ConcatOp op -> {\n+                        processOperands(op);\n+                        cob.invokedynamic(DynamicCallSiteDesc.of(DMHD_STRING_CONCAT, MethodTypeDesc.of(CD_String,\n+                                toClassDesc(op.operands().get(0).type()),\n+                                toClassDesc(op.operands().get(1).type()))));\n+                        push(op.result());\n+                    }\n+                    case MonitorOp.MonitorEnterOp op -> {\n+                        processFirstOperand(op);\n+                        cob.monitorenter();\n+                    }\n+                    case MonitorOp.MonitorExitOp op -> {\n+                        processFirstOperand(op);\n+                        cob.monitorexit();\n+                    }\n+                    default ->\n+                        throw new UnsupportedOperationException(\"Unsupported operation: \" + ops.get(i));\n+                }\n+            }\n+            Op top = b.terminatingOp();\n+            switch (top) {\n+                case ReturnOp op -> {\n+                    if (returnType != TypeKind.VOID) {\n+                        processFirstOperand(op);\n+                        \/\/ @@@ box, unbox, cast here ?\n+                    }\n+                    cob.return_(returnType);\n+                }\n+                case ThrowOp op -> {\n+                    processFirstOperand(op);\n+                    cob.athrow();\n+                }\n+                case BranchOp op -> {\n+                    assignBlockArguments(op.branch());\n+                    cob.goto_(getLabel(op.branch()));\n+                }\n+                case ConditionalBranchOp op -> {\n+                    if (getConditionForCondBrOp(op) instanceof BinaryTestOp btop) {\n+                        \/\/ Processing of the BinaryTestOp was deferred, so it can be merged with CondBrOp\n+                        conditionalBranch(prepareConditionalBranch(btop), op.trueBranch(), op.falseBranch());\n+                    } else {\n+                        processFirstOperand(op);\n+                        conditionalBranch(Opcode.IFEQ, op.trueBranch(), op.falseBranch());\n+                    }\n+                }\n+                case ExceptionRegionEnter op -> {\n+                    assignBlockArguments(op.start());\n+                }\n+                case ExceptionRegionExit op -> {\n+                    assignBlockArguments(op.end());\n+                    cob.goto_(getLabel(op.end()));\n+                }\n+                default ->\n+                    throw new UnsupportedOperationException(\"Terminating operation not supported: \" + top);\n+            }\n+        }\n+    }\n+\n+    \/\/ Checks if the Op.Result is used more than once in operands and block arguments\n+    private static boolean moreThanOneUse(Value val) {\n+        return val.uses().stream().flatMap(u ->\n+                Stream.concat(\n+                        u.op().operands().stream(),\n+                        u.op().successors().stream()\n+                                .flatMap(r -> r.arguments().stream())))\n+                .filter(val::equals).limit(2).count() > 1;\n+    }\n+\n+    private void push(Value res) {\n+        assert oprOnStack == null;\n+        if (res.type().equals(JavaType.VOID)) return;\n+        if (isNextUse(res)) {\n+            if (moreThanOneUse(res)) {\n+                switch (toTypeKind(res.type()).slotSize()) {\n+                    case 1 -> cob.dup();\n+                    case 2 -> cob.dup2();\n+                }\n+                storeIfUsed(res);\n+            }\n+            oprOnStack = res;\n+        } else {\n+            storeIfUsed(res);\n+            oprOnStack = null;\n+        }\n+    }\n+\n+    \/\/ the rhs of any shift instruction must be int or smaller -> convert longs\n+    private void adjustRightTypeToInt(Op op) {\n+        TypeElement right = op.operands().getLast().type();\n+        if (right.equals(JavaType.LONG)) {\n+            cob.conversion(toTypeKind(right), TypeKind.INT);\n+        }\n+    }\n+\n+    private static Op getConditionForCondBrOp(ConditionalBranchOp op) {\n+        Value p = op.predicate();\n+        if (p.uses().size() != 1) {\n+            return null;\n+        }\n+\n+        if (p.declaringBlock() != op.parentBlock()) {\n+            return null;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : op.successors()) {\n+            if (s.arguments().contains(p)) {\n+                return null;\n+            }\n+        }\n+\n+        if (p instanceof Op.Result or) {\n+            return or.op();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private String funcIntfMethodName(Class<?> intfc) {\n+        String uniqueName = null;\n+        for (Method m : intfc.getMethods()) {\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (Modifier.isAbstract(m.getModifiers())\n+                    && (m.getReturnType() != String.class\n+                        || m.getParameterCount() != 0\n+                        || !methodName.equals(\"toString\"))\n+                    && (m.getReturnType() != int.class\n+                        || m.getParameterCount() != 0\n+                        || !methodName.equals(\"hashCode\"))\n+                    && (m.getReturnType() != boolean.class\n+                        || m.getParameterCount() != 1\n+                        || m.getParameterTypes()[0] != Object.class\n+                        || !methodName.equals(\"equals\"))) {\n+                if (uniqueName == null) {\n+                    uniqueName = methodName;\n+                } else if (!uniqueName.equals(methodName)) {\n+                    \/\/ too many abstract methods\n+                    throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.getName());\n+                }\n+            }\n+        }\n+        if (uniqueName == null) {\n+            throw new IllegalArgumentException(\"No method in: \" + intfc.getName());\n+        }\n+        return uniqueName;\n+    }\n+\n+    private void conditionalBranch(Opcode reverseOpcode, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        if (!needToAssignBlockArguments(falseBlock)) {\n+            cob.branch(reverseOpcode, getLabel(falseBlock));\n+        } else {\n+            cob.ifThen(reverseOpcode,\n+                bb -> {\n+                    assignBlockArguments(falseBlock);\n+                    bb.goto_(getLabel(falseBlock));\n+                });\n+        }\n+        assignBlockArguments(trueBlock);\n+        cob.goto_(getLabel(trueBlock));\n+    }\n+\n+    private Opcode prepareConditionalBranch(BinaryTestOp op) {\n+        Value firstOperand = op.operands().get(0);\n+        TypeKind typeKind = toTypeKind(firstOperand.type());\n+        Value secondOperand = op.operands().get(1);\n+        processOperand(firstOperand);\n+        if (isZeroIntOrNullConstant(secondOperand)) {\n+            return switch (typeKind) {\n+                case INT, BOOLEAN, BYTE, SHORT, CHAR ->\n+                    switch (op) {\n+                        case EqOp _ -> Opcode.IFNE;\n+                        case NeqOp _ -> Opcode.IFEQ;\n+                        case GtOp _ -> Opcode.IFLE;\n+                        case GeOp _ -> Opcode.IFLT;\n+                        case LtOp _ -> Opcode.IFGE;\n+                        case LeOp _ -> Opcode.IFGT;\n+                        default ->\n+                            throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                    };\n+                case REFERENCE ->\n+                    switch (op) {\n+                        case EqOp _ -> Opcode.IFNONNULL;\n+                        case NeqOp _ -> Opcode.IFNULL;\n+                        default ->\n+                            throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                    };\n+                default ->\n+                    throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+            };\n+        }\n+        processOperand(secondOperand);\n+        return switch (typeKind) {\n+            case INT, BOOLEAN, BYTE, SHORT, CHAR ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ICMPNE;\n+                    case NeqOp _ -> Opcode.IF_ICMPEQ;\n+                    case GtOp _ -> Opcode.IF_ICMPLE;\n+                    case GeOp _ -> Opcode.IF_ICMPLT;\n+                    case LtOp _ -> Opcode.IF_ICMPGE;\n+                    case LeOp _ -> Opcode.IF_ICMPGT;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                };\n+            case REFERENCE ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ACMPNE;\n+                    case NeqOp _ -> Opcode.IF_ACMPEQ;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                };\n+            case FLOAT -> {\n+                cob.fcmpg(); \/\/ FCMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            case LONG -> {\n+                cob.lcmp();\n+                yield reverseIfOpcode(op);\n+            }\n+            case DOUBLE -> {\n+                cob.dcmpg(); \/\/CMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            default ->\n+                throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+        };\n+    }\n+\n+    private boolean isZeroIntOrNullConstant(Value v) {\n+        return v instanceof Op.Result or\n+                && or.op() instanceof ConstantOp cop\n+                && switch (cop.value()) {\n+                    case null -> true;\n+                    case Integer i -> i == 0;\n+                    case Boolean b -> !b;\n+                    case Byte b -> b == 0;\n+                    case Short s -> s == 0;\n+                    case Character ch -> ch == 0;\n+                    default -> false;\n+                };\n+    }\n+\n+    private static Opcode reverseIfOpcode(BinaryTestOp op) {\n+        return switch (op) {\n+            case EqOp _ -> Opcode.IFNE;\n+            case NeqOp _ -> Opcode.IFEQ;\n+            case GtOp _ -> Opcode.IFLE;\n+            case GeOp _ -> Opcode.IFLT;\n+            case LtOp _ -> Opcode.IFGE;\n+            case LeOp _ -> Opcode.IFGT;\n+            default ->\n+                throw new UnsupportedOperationException(op.opName());\n+        };\n+    }\n+\n+    private boolean needToAssignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+        boolean need = false;\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(sargs.get(i))) {\n+                need = true;\n+                allocateSlot(barg);\n+            }\n+        }\n+        return need;\n+    }\n+\n+    private void assignBlockArguments(Block.Reference ref) {\n+        Block target = ref.targetBlock();\n+        List<Value> sargs = ref.arguments();\n+        if (catchingBlocks.get(target.index())) {\n+            \/\/ Jumping to an exception handler, exception parameter is expected on stack\n+            Value value = sargs.getFirst();\n+            if (oprOnStack == value) {\n+                oprOnStack = null;\n+            } else {\n+                load(value);\n+            }\n+        } else if (target.predecessors().size() > 1) {\n+            List<Block.Parameter> bargs = target.parameters();\n+            \/\/ First push successor arguments on the stack, then pop and assign\n+            \/\/ so as not to overwrite slots that are reused slots at different argument positions\n+            for (int i = 0; i < bargs.size(); i++) {\n+                Block.Parameter barg = bargs.get(i);\n+                Value value = sargs.get(i);\n+                if (!barg.uses().isEmpty() && !barg.equals(value)) {\n+                    if (oprOnStack == value) {\n+                        oprOnStack = null;\n+                    } else {\n+                        load(value);\n+                    }\n+                    storeIfUsed(barg);\n+                }\n+            }\n+        } else {\n+            \/\/ Single-predecessor block can just map parameter slots\n+            List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+            for (int i = 0; i < bargs.size(); i++) {\n+                Value value = sargs.get(i);\n+                if (oprOnStack == value) {\n+                    storeIfUsed(oprOnStack);\n+                    oprOnStack = null;\n+                }\n+                \/\/ Map slot of the block argument to slot of the value\n+                singlePredecessorsValues.put(bargs.get(i), singlePredecessorsValues.getOrDefault(value, value));\n+            }\n+        }\n+    }\n+\n+    static FuncOp quote(LambdaOp lop) {\n+        List<Value> captures = lop.capturedValues();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = captures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOp.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the captured values\n+            \/\/ for the copied lambda\n+            List<Value> outputCaptures = new ArrayList<>();\n+            for (int i = 0; i < captures.size(); i++) {\n+                Value c = captures.get(i);\n+                Block.Parameter p = b.parameters().get(i);\n+                if (c.type() instanceof VarType _) {\n+                    Value var = b.op(CoreOp.var(String.valueOf(i), p));\n+                    outputCaptures.add(var);\n+                } else {\n+                    outputCaptures.add(p);\n+                }\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOp.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the entry block of the lambda's ancestor body to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block, the block mapping\n+                \/\/ ensures the use of captured values are reachable when building\n+                qb.context().mapBlock(lop.ancestorBody().entryBlock(), qb);\n+                \/\/ Map the lambda's captured values\n+                qb.context().mapValues(captures, outputCaptures);\n+                \/\/ Return the lambda to be copied in the quoted operation\n+                return lop;\n+            }));\n+            b.op(CoreOp._return(q));\n+        });\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":1350,"deletions":0,"binary":false,"changes":1350,"status":"added"},{"patch":"@@ -0,0 +1,1021 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n+\n+public final class BytecodeLift {\n+\n+    private record ExceptionRegion(Label startLabel, Label endLabel, Label handlerLabel) {}\n+    private record ExceptionRegionEntry(Op.Result enter, Block.Builder startBlock, ExceptionRegion region) {}\n+\n+    private static final ClassDesc CD_LambdaMetafactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/LambdaMetafactory;\");\n+    private static final ClassDesc CD_StringConcatFactory = ClassDesc.ofDescriptor(\"Ljava\/lang\/invoke\/StringConcatFactory;\");\n+    private static final JavaType MHS_LOOKUP = JavaType.type(ConstantDescs.CD_MethodHandles_Lookup);\n+    private static final JavaType MH = JavaType.type(ConstantDescs.CD_MethodHandle);\n+    private static final JavaType MT = JavaType.type(ConstantDescs.CD_MethodType);\n+    private static final JavaType CLASS_ARRAY = JavaType.array(JavaType.J_L_CLASS);\n+    private static final MethodRef LCMP = MethodRef.method(JavaType.J_L_LONG, \"compare\", JavaType.INT, JavaType.LONG, JavaType.LONG);\n+    private static final MethodRef FCMP = MethodRef.method(JavaType.J_L_FLOAT, \"compare\", JavaType.INT, JavaType.FLOAT, JavaType.FLOAT);\n+    private static final MethodRef DCMP = MethodRef.method(JavaType.J_L_DOUBLE, \"compare\", JavaType.INT, JavaType.DOUBLE, JavaType.DOUBLE);\n+    private static final MethodRef LOOKUP = MethodRef.method(JavaType.type(ConstantDescs.CD_MethodHandles), \"lookup\", MHS_LOOKUP);\n+    private static final MethodRef FIND_STATIC = MethodRef.method(MHS_LOOKUP, \"findStatic\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, MT);\n+    private static final MethodRef FIND_VIRTUAL = MethodRef.method(MHS_LOOKUP, \"findVirtual\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, MT);\n+    private static final MethodRef FIND_CONSTRUCTOR = MethodRef.method(MHS_LOOKUP, \"findConstructor\", MH, JavaType.J_L_CLASS, MT);\n+    private static final MethodRef FIND_GETTER = MethodRef.method(MHS_LOOKUP, \"findGetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef FIND_STATIC_GETTER = MethodRef.method(MHS_LOOKUP, \"findStaticGetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef FIND_SETTER = MethodRef.method(MHS_LOOKUP, \"findSetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef FIND_STATIC_SETTER = MethodRef.method(MHS_LOOKUP, \"findStaticSetter\", MH, JavaType.J_L_CLASS, JavaType.J_L_STRING, JavaType.J_L_CLASS);\n+    private static final MethodRef METHOD_TYPE_0 = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS);\n+    private static final MethodRef METHOD_TYPE_1 = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS, JavaType.J_L_CLASS);\n+    private static final MethodRef METHOD_TYPE_L = MethodRef.method(MT, \"methodType\", MT, JavaType.J_L_CLASS, CLASS_ARRAY);\n+\n+    private final Block.Builder entryBlock;\n+    private final ClassModel classModel;\n+    private final CodeAttribute codeAttribtue;\n+    private final List<ExceptionRegion> exceptionRegions;\n+    private final Map<Label, Block.Builder> blockMap;\n+    private final LocalsToVarMapper localsToVarMapper;\n+    private final List<CodeElement> elements;\n+    private final Map<LocalsToVarMapper.Variable, Value> varToValueMap;\n+    private final Deque<Value> stack;\n+    private final Map<Object, Op.Result> constantCache;\n+    private final ArrayDeque<ExceptionRegionEntry> exceptionRegionStack;\n+    private final List<Value> initLocalValues;\n+    private final ArrayDeque<ClassDesc> newStack;\n+    private Block.Builder currentBlock;\n+\n+    private BytecodeLift(Block.Builder entryBlock, ClassModel classModel, CodeModel codeModel, Value... capturedValues) {\n+        this.entryBlock = entryBlock;\n+        this.currentBlock = entryBlock;\n+        this.classModel = classModel;\n+        this.codeAttribtue = (CodeAttribute)codeModel;\n+        var smta = codeModel.findAttribute(Attributes.stackMapTable());\n+        this.exceptionRegions = extractExceptionRegions(codeAttribtue);\n+        this.elements = codeModel.elementList();\n+        this.varToValueMap = new HashMap<>();\n+        this.stack = new ArrayDeque<>();\n+        List<ClassDesc> initLocalTypes = new ArrayList<>();\n+        this.initLocalValues = new ArrayList<>();\n+        Stream.concat(Arrays.stream(capturedValues), entryBlock.parameters().stream()).forEachOrdered(val -> {\n+            ClassDesc locType = BytecodeGenerator.toClassDesc(val.type());\n+            initLocalTypes.add(locType);\n+            initLocalValues.add(val);\n+            if (TypeKind.from(locType).slotSize() == 2) {\n+                initLocalTypes.add(null);\n+                initLocalValues.add(null);\n+            }\n+        });\n+        this.localsToVarMapper = new LocalsToVarMapper(classModel.thisClass().asSymbol(), initLocalTypes, codeModel.exceptionHandlers(), smta, elements);\n+        this.blockMap = smta.map(sma ->\n+                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        smfi -> entryBlock.block(toBlockParams(smfi.stack()))))).orElseGet(Map::of);\n+        this.constantCache = new HashMap<>();\n+        this.exceptionRegionStack = new ArrayDeque<>();\n+        this.newStack = new ArrayDeque<>();\n+    }\n+\n+    private static List<ExceptionRegion> extractExceptionRegions(CodeAttribute codeAttribute) {\n+        record JumpTarget(int targetBci, Label target, List<Integer> sourceBcis) {}\n+        BitSet targetBcis = new BitSet(codeAttribute.codeLength());\n+        var jumpMap = new HashMap<Integer, JumpTarget>() {\n+            void add(Label target, int sourceBci) {\n+                computeIfAbsent(codeAttribute.labelToBci(target), targetBci -> {\n+                    targetBcis.set(targetBci);\n+                    return new JumpTarget(targetBci, target, new ArrayList<>());\n+                }).sourceBcis.add(sourceBci);\n+            }\n+        };\n+\n+        int bci = 0;\n+        \/\/ First collect jump map\n+        for (CodeElement ce : codeAttribute) {\n+            switch (ce) {\n+                case BranchInstruction bi -> {\n+                    jumpMap.add(bi.target(), bci);\n+                }\n+                case TableSwitchInstruction tsi -> {\n+                    jumpMap.add(tsi.defaultTarget(), bci);\n+                    for (var c : tsi.cases()) {\n+                        jumpMap.add(c.target(), bci);\n+                    }\n+                }\n+                case LookupSwitchInstruction lsi -> {\n+                    jumpMap.add(lsi.defaultTarget(), bci);\n+                    for (var c : lsi.cases()) {\n+                        jumpMap.add(c.target(), bci);\n+                    }\n+                }\n+                default -> {}\n+            }\n+            if (ce instanceof Instruction i) {\n+                bci += i.sizeInBytes();\n+            }\n+        }\n+\n+        \/\/ Filter and split exception regions\n+        List<ExceptionRegion> regions = codeAttribute.exceptionHandlers().stream()\n+                .filter(ec -> ec.tryStart() != ec.tryEnd() && ec.tryStart() != ec.handler())\n+                .map(ec -> new ExceptionRegion(ec.tryStart(), ec.tryEnd(), ec.handler())).distinct().toList();\n+\n+        \/\/ Exception handlers also represent jump targets\n+        \/\/ @@@ not listed all source bcis\n+        for (ExceptionRegion er : regions) {\n+            jumpMap.add(er.handlerLabel, codeAttribute.labelToBci(er.startLabel));\n+        }\n+\n+        boolean split;\n+        do {\n+            split = false;\n+            var newRegions = new ArrayList<ExceptionRegion>();\n+            for (var reg : regions) {\n+                final int startBci = codeAttribute.labelToBci(reg.startLabel());\n+                final int endBci = codeAttribute.labelToBci(reg.endLabel());\n+                final int handlerBci = codeAttribute.labelToBci(reg.handlerLabel());\n+                \/\/ Filter out exception handlers overlapping with try blocks\n+                if (handlerBci >= endBci || handlerBci < startBci) {\n+                    Label startLabel = reg.startLabel();\n+                    int breakIndex = startBci;\n+                    \/\/ Detect additional exception region entries\n+                    while ((breakIndex = targetBcis.nextSetBit(breakIndex + 1)) >= 0 &&  breakIndex < endBci) {\n+                        JumpTarget jt = jumpMap.get(breakIndex);\n+                        \/\/ Split the exception region by each external entry (jump from outside of the region)\n+                        if (jt.sourceBcis.stream().anyMatch(sourceBci -> sourceBci < startBci || sourceBci > endBci)) {\n+                            Label breakLabel = jt.target();\n+                            newRegions.add(new ExceptionRegion(startLabel, breakLabel, reg.handlerLabel()));\n+                            startLabel = breakLabel;\n+                            split = true;\n+                        }\n+                    }\n+                    newRegions.add(new ExceptionRegion(startLabel, reg.endLabel(), reg.handlerLabel()));\n+                }\n+            }\n+            regions = newRegions;\n+        } while (split); \/\/ Each new split may change branch status to an external entry and imply more splits\n+        return regions;\n+    }\n+\n+    private List<TypeElement> toBlockParams(List<StackMapFrameInfo.VerificationTypeInfo> vtis) {\n+        ArrayList<TypeElement> params = new ArrayList<>(vtis.size());\n+        for (int i = vtis.size() - 1; i >= 0; i--) {\n+            var vti = vtis.get(i);\n+            switch (vti) {\n+                case INTEGER -> params.add(JavaType.INT);\n+                case FLOAT -> params.add(JavaType.FLOAT);\n+                case DOUBLE -> params.add(JavaType.DOUBLE);\n+                case LONG -> params.add(JavaType.LONG);\n+                case NULL -> params.add(JavaType.J_L_OBJECT);\n+                case UNINITIALIZED_THIS ->\n+                    params.add(JavaType.type(classModel.thisClass().asSymbol()));\n+                case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                    params.add(JavaType.type(ovti.classSymbol()));\n+\n+                    \/\/ Unitialized entry (a new object before its constructor is called)\n+                    \/\/ must be skipped from block parameters because they do not exist in code reflection model\n+                case StackMapFrameInfo.UninitializedVerificationTypeInfo _ -> {}\n+                default ->\n+                    throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+            }\n+        }\n+        return params;\n+    }\n+\n+    private Op.Result op(Op op) {\n+        return currentBlock.op(op);\n+    }\n+\n+    \/\/ Lift to core dialect\n+    public static CoreOp.FuncOp lift(byte[] classdata, String methodName) {\n+        return lift(classdata, methodName, null);\n+    }\n+\n+    public static CoreOp.FuncOp lift(byte[] classdata, String methodName, MethodTypeDesc methodType) {\n+        return lift(ClassFile.of(\n+                ClassFile.DebugElementsOption.DROP_DEBUG,\n+                ClassFile.LineNumbersOption.DROP_LINE_NUMBERS).parse(classdata).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName) && (methodType == null || mm.methodTypeSymbol().equals(methodType)))\n+                        .findFirst().orElseThrow(() -> new IllegalArgumentException(\"Unknown method: \" + methodName)));\n+    }\n+\n+    public static CoreOp.FuncOp lift(MethodModel methodModel) {\n+        ClassModel classModel = methodModel.parent().orElseThrow();\n+        MethodTypeDesc mDesc = methodModel.methodTypeSymbol();\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            mDesc = mDesc.insertParameterTypes(0, classModel.thisClass().asSymbol());\n+        }\n+        return NormalizeBlocksTransformer.transform(\n+                CoreOp.func(methodModel.methodName().stringValue(),\n+                            MethodRef.ofNominalDescriptor(mDesc)).body(entryBlock ->\n+                                    new BytecodeLift(entryBlock,\n+                                                     classModel,\n+                                                     methodModel.code().orElseThrow()).liftBody()));\n+    }\n+\n+    private Block.Builder newBlock(List<Block.Parameter> otherBlockParams) {\n+        return entryBlock.block(otherBlockParams.stream().map(Block.Parameter::type).toList());\n+    }\n+\n+    private void moveTo(Block.Builder next) {\n+        currentBlock = next;\n+        constantCache.clear();\n+        \/\/ Stack is reconstructed from block parameters\n+        stack.clear();\n+        if (currentBlock != null) {\n+            currentBlock.parameters().forEach(stack::add);\n+        }\n+    }\n+\n+    private void endOfFlow() {\n+        currentBlock = null;\n+        constantCache.clear();\n+        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+        stack.clear();\n+    }\n+\n+    private Block.Builder findTargetBlock(Label targetLabel) {\n+        Block.Builder targetBlock = blockMap.get(targetLabel);\n+        int targetBci = codeAttribtue.labelToBci(targetLabel);\n+        for (ExceptionRegionEntry ee : exceptionRegionStack.reversed()) {\n+            if (ee.region.startLabel == targetLabel) {\n+                \/\/ Avoid region re-entry\n+                targetBlock = ee.startBlock;\n+            } else if (targetBci < codeAttribtue.labelToBci(ee.region.startLabel) || targetBci >= codeAttribtue.labelToBci(ee.region.endLabel)) {\n+                \/\/ Leaving the exception region, need to insert ExceptionRegionExit\n+                Block.Builder next = newBlock(targetBlock.parameters());\n+                next.op(CoreOp.exceptionRegionExit(ee.enter(), targetBlock.successor(next.parameters())));\n+                targetBlock = next;\n+            }\n+        }\n+        return targetBlock;\n+    }\n+\n+    private void liftBody() {\n+        \/\/ Declare initial variables\n+        for (int i = 0; i < localsToVarMapper.slotsToInit(); i++) {\n+            LocalsToVarMapper.Variable v = localsToVarMapper.initSlotVar(i);\n+            if (v != null) {\n+                if (v.hasSingleAssignment()) {\n+                    varToValueMap.put(v, initLocalValues.get(i)); \/\/ Single value var initialized with entry block parameter\n+                } else {\n+                    varToValueMap.put(v, op(CoreOp.var(\"slot#\" + i, \/\/ New var with slot# name\n+                                                       JavaType.type(v.type()), \/\/ Type calculated by LocalsToVarMapper\n+                                                       i < initLocalValues.size()\n+                                                               ? initLocalValues.get(i) \/\/ Initialized with entry block parameter\n+                                                               : liftDefaultValue(v.type())))); \/\/ Initialized with default\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < elements.size(); i++) {\n+            switch (elements.get(i)) {\n+                case ExceptionCatch _ -> {\n+                    \/\/ Exception blocks are inserted by label target (below)\n+                }\n+                case LabelTarget lt -> {\n+                    \/\/ Insert relevant tryEnd blocks\n+                    while (!exceptionRegionStack.isEmpty() && lt.label() == exceptionRegionStack.peek().region.endLabel) {\n+                        \/\/ Create exit block with parameters constructed from the stack\n+                        ExceptionRegionEntry er = exceptionRegionStack.pop();\n+                        if (currentBlock != null) {\n+                            Block.Builder next = entryBlock.block();\n+                            op(CoreOp.exceptionRegionExit(er.enter(), next.successor()));\n+                            currentBlock = next;\n+                        }\n+                    }\n+                    Block.Builder next = blockMap.get(lt.label());\n+\n+                    \/\/ Start of a new block if defined by stack maps\n+                    if (next != null) {\n+                        if (currentBlock != null) {\n+                            \/\/ Implicit goto next block, add explicitly\n+                            \/\/ Use stack content as next block arguments\n+                            op(CoreOp.branch(successor(next)));\n+                        }\n+                        moveTo(next);\n+                    }\n+\n+                    \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n+                    for (ExceptionRegion reg : exceptionRegions.reversed()) {\n+                        if (lt.label() == reg.startLabel()) {\n+                            \/\/ Create start block\n+                            next = entryBlock.block();\n+                            Op ere = CoreOp.exceptionRegionEnter(next.successor(), findTargetBlock(reg.handlerLabel()).successor());\n+                            op(ere);\n+                            \/\/ Push ExceptionRegionEntry on stack\n+                            exceptionRegionStack.push(new ExceptionRegionEntry(ere.result(), next, reg));\n+                            currentBlock = next;\n+                        }\n+                    }\n+                }\n+                case BranchInstruction inst when BytecodeHelpers.isUnconditionalBranch(inst.opcode()) -> {\n+                    op(CoreOp.branch(successor(findTargetBlock(inst.target()))));\n+                    endOfFlow();\n+                }\n+                case BranchInstruction inst -> {\n+                    \/\/ Conditional branch\n+                    Value operand = stack.pop();\n+                    Op cop = switch (inst.opcode()) {\n+                        case IFNE -> CoreOp.eq(operand, zero(operand));\n+                        case IFEQ -> CoreOp.neq(operand, zero(operand));\n+                        case IFGE -> CoreOp.lt(operand, zero(operand));\n+                        case IFLE -> CoreOp.gt(operand, zero(operand));\n+                        case IFGT -> CoreOp.le(operand, zero(operand));\n+                        case IFLT -> CoreOp.ge(operand, zero(operand));\n+                        case IFNULL -> CoreOp.neq(operand, liftConstant(null));\n+                        case IFNONNULL -> CoreOp.eq(operand, liftConstant(null));\n+                        case IF_ICMPNE -> unifyOperands(CoreOp::eq, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPEQ -> unifyOperands(CoreOp::neq, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPGE -> unifyOperands(CoreOp::lt, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPLE -> unifyOperands(CoreOp::gt, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPGT -> unifyOperands(CoreOp::le, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ICMPLT -> unifyOperands(CoreOp::ge, stack.pop(), operand, TypeKind.INT);\n+                        case IF_ACMPEQ -> CoreOp.neq(stack.pop(), operand);\n+                        case IF_ACMPNE -> CoreOp.eq(stack.pop(), operand);\n+                        default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                    };\n+                    Block.Builder branch = findTargetBlock(inst.target());\n+                    Block.Builder next = newBlock(branch.parameters());\n+                    op(CoreOp.conditionalBranch(op(cop),\n+                            successor(next),\n+                            successor(branch)));\n+                    moveTo(next);\n+                }\n+                case LookupSwitchInstruction si -> {\n+                    liftSwitch(si.defaultTarget(), si.cases());\n+                }\n+                case TableSwitchInstruction si -> {\n+                    liftSwitch(si.defaultTarget(), si.cases());\n+                }\n+                case ReturnInstruction inst when inst.typeKind() == TypeKind.VOID -> {\n+                    op(CoreOp._return());\n+                    endOfFlow();\n+                }\n+                case ReturnInstruction _ -> {\n+                    op(CoreOp._return(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case ThrowInstruction _ -> {\n+                    op(CoreOp._throw(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case LoadInstruction inst -> {\n+                    stack.push(load(i));\n+                }\n+                case StoreInstruction inst -> {\n+                    store(i, inst.slot(), stack.pop());\n+                }\n+                case IncrementInstruction inst -> {\n+                    store(i, inst.slot(), op(CoreOp.add(load(-i - 1), liftConstant(inst.constant()))));\n+                }\n+                case ConstantInstruction inst -> {\n+                    stack.push(liftConstant(inst.constantValue()));\n+                }\n+                case ConvertInstruction inst -> {\n+                    stack.push(op(CoreOp.conv(switch (inst.toType()) {\n+                        case BYTE -> JavaType.BYTE;\n+                        case SHORT -> JavaType.SHORT;\n+                        case INT -> JavaType.INT;\n+                        case FLOAT -> JavaType.FLOAT;\n+                        case LONG -> JavaType.LONG;\n+                        case DOUBLE -> JavaType.DOUBLE;\n+                        case CHAR -> JavaType.CHAR;\n+                        case BOOLEAN -> JavaType.BOOLEAN;\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported conversion target: \" + inst.toType());\n+                    }, stack.pop())));\n+                }\n+                case OperatorInstruction inst -> {\n+                    TypeKind tk = inst.typeKind();\n+                    Value operand = stack.pop();\n+                    stack.push(op(switch (inst.opcode()) {\n+                        case IADD, LADD, FADD, DADD ->\n+                                unifyOperands(CoreOp::add, stack.pop(), operand, tk);\n+                        case ISUB, LSUB, FSUB, DSUB ->\n+                                unifyOperands(CoreOp::sub, stack.pop(), operand, tk);\n+                        case IMUL, LMUL, FMUL, DMUL ->\n+                                unifyOperands(CoreOp::mul, stack.pop(), operand, tk);\n+                        case IDIV, LDIV, FDIV, DDIV ->\n+                                unifyOperands(CoreOp::div, stack.pop(), operand, tk);\n+                        case IREM, LREM, FREM, DREM ->\n+                                unifyOperands(CoreOp::mod, stack.pop(), operand, tk);\n+                        case INEG, LNEG, FNEG, DNEG ->\n+                                CoreOp.neg(operand);\n+                        case ARRAYLENGTH ->\n+                                CoreOp.arrayLength(operand);\n+                        case IAND, LAND ->\n+                                unifyOperands(CoreOp::and, stack.pop(), operand, tk);\n+                        case IOR, LOR ->\n+                                unifyOperands(CoreOp::or, stack.pop(), operand, tk);\n+                        case IXOR, LXOR ->\n+                                unifyOperands(CoreOp::xor, stack.pop(), operand, tk);\n+                        case ISHL, LSHL ->\n+                                CoreOp.lshl(stack.pop(), toInt(operand));\n+                        case ISHR, LSHR ->\n+                                CoreOp.ashr(stack.pop(), toInt(operand));\n+                        case IUSHR, LUSHR ->\n+                                CoreOp.lshr(stack.pop(), toInt(operand));\n+                        case LCMP ->\n+                                CoreOp.invoke(LCMP, stack.pop(), operand);\n+                        case FCMPL, FCMPG ->\n+                                CoreOp.invoke(FCMP, stack.pop(), operand);\n+                        case DCMPL, DCMPG ->\n+                                CoreOp.invoke(DCMP, stack.pop(), operand);\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                    }));\n+                }\n+                case FieldInstruction inst -> {\n+                        FieldRef fd = FieldRef.field(\n+                                JavaType.type(inst.owner().asSymbol()),\n+                                inst.name().stringValue(),\n+                                JavaType.type(inst.typeSymbol()));\n+                        switch (inst.opcode()) {\n+                            case GETFIELD ->\n+                                stack.push(op(CoreOp.fieldLoad(fd, stack.pop())));\n+                            case GETSTATIC ->\n+                                stack.push(op(CoreOp.fieldLoad(fd)));\n+                            case PUTFIELD -> {\n+                                Value value = stack.pop();\n+                                op(CoreOp.fieldStore(fd, stack.pop(), value));\n+                            }\n+                            case PUTSTATIC ->\n+                                op(CoreOp.fieldStore(fd, stack.pop()));\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n+                        }\n+                }\n+                case ArrayStoreInstruction _ -> {\n+                    Value value = stack.pop();\n+                    Value index = stack.pop();\n+                    op(CoreOp.arrayStoreOp(stack.pop(), index, value));\n+                }\n+                case ArrayLoadInstruction _ -> {\n+                    Value index = stack.pop();\n+                    stack.push(op(CoreOp.arrayLoadOp(stack.pop(), index)));\n+                }\n+                case InvokeInstruction inst -> {\n+                    FunctionType mType = MethodRef.ofNominalDescriptor(inst.typeSymbol());\n+                    List<Value> operands = new ArrayList<>();\n+                    for (var _ : mType.parameterTypes()) {\n+                        operands.add(stack.pop());\n+                    }\n+                    MethodRef mDesc = MethodRef.method(\n+                            JavaType.type(inst.owner().asSymbol()),\n+                            inst.name().stringValue(),\n+                            mType);\n+                    Op.Result result = switch (inst.opcode()) {\n+                        case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                            operands.add(stack.pop());\n+                            yield op(CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.INSTANCE, false,\n+                                    mDesc.type().returnType(), mDesc, operands.reversed()));\n+                        }\n+                        case INVOKESTATIC ->\n+                                op(CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.STATIC, false,\n+                                        mDesc.type().returnType(), mDesc, operands.reversed()));\n+                        case INVOKESPECIAL -> {\n+                            if (inst.owner().asSymbol().equals(newStack.peek()) && inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                newStack.pop();\n+                                yield op(CoreOp._new(\n+                                        FunctionType.functionType(\n+                                                mDesc.refType(),\n+                                                mType.parameterTypes()),\n+                                        operands.reversed()));\n+                            } else {\n+                                operands.add(stack.pop());\n+                                yield op(CoreOp.invoke(CoreOp.InvokeOp.InvokeKind.SUPER, false,\n+                                        mDesc.type().returnType(), mDesc, operands.reversed()));\n+                            }\n+                        }\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                    };\n+                    if (!result.type().equals(JavaType.VOID)) {\n+                        stack.push(result);\n+                    }\n+                }\n+                case InvokeDynamicInstruction inst when inst.bootstrapMethod().kind() == DirectMethodHandleDesc.Kind.STATIC -> {\n+                    DirectMethodHandleDesc bsm = inst.bootstrapMethod();\n+                    ClassDesc bsmOwner = bsm.owner();\n+                    if (bsmOwner.equals(CD_LambdaMetafactory)\n+                        && inst.bootstrapArgs().get(0) instanceof MethodTypeDesc mtd\n+                        && inst.bootstrapArgs().get(1) instanceof DirectMethodHandleDesc dmhd) {\n+\n+                        var capturedValues = new Value[dmhd.invocationType().parameterCount() - mtd.parameterCount()];\n+                        for (int ci = capturedValues.length - 1; ci >= 0; ci--) {\n+                            capturedValues[ci] = stack.pop();\n+                        }\n+                        for (int ci = capturedValues.length; ci < inst.typeSymbol().parameterCount(); ci++) {\n+                            stack.pop();\n+                        }\n+                        MethodTypeDesc mt = dmhd.invocationType();\n+                        if (capturedValues.length > 0) {\n+                            mt = mt.dropParameterTypes(0, capturedValues.length);\n+                        }\n+                        FunctionType lambdaFunc = FunctionType.functionType(JavaType.type(mt.returnType()),\n+                                                                            mt.parameterList().stream().map(JavaType::type).toList());\n+                        CoreOp.LambdaOp.Builder lambda = CoreOp.lambda(currentBlock.parentBody(),\n+                                                                       lambdaFunc,\n+                                                                       JavaType.type(inst.typeSymbol().returnType()));\n+                        if (dmhd.methodName().startsWith(\"lambda$\") && dmhd.owner().equals(classModel.thisClass().asSymbol())) {\n+                            \/\/ inline lambda impl method\n+                            MethodModel implMethod = classModel.methods().stream().filter(m -> m.methodName().equalsString(dmhd.methodName())).findFirst().orElseThrow();\n+                            stack.push(op(lambda.body(\n+                                    eb -> new BytecodeLift(eb,\n+                                                           classModel,\n+                                                           implMethod.code().orElseThrow(),\n+                                                           capturedValues).liftBody())));\n+                        } else {\n+                            \/\/ lambda call to a MH\n+                            stack.push(op(lambda.body(eb -> {\n+                                Op.Result ret = eb.op(CoreOp.invoke(\n+                                        MethodRef.method(JavaType.type(dmhd.owner()),\n+                                                         dmhd.methodName(),\n+                                                         lambdaFunc.returnType(),\n+                                                         lambdaFunc.parameterTypes()),\n+                                        Stream.concat(Arrays.stream(capturedValues), eb.parameters().stream()).toArray(Value[]::new)));\n+                                eb.op(ret.type().equals(JavaType.VOID) ? CoreOp._return() : CoreOp._return(ret));\n+                            })));\n+                        }\n+                    } else if (bsmOwner.equals(CD_StringConcatFactory)) {\n+                        int argsCount = inst.typeSymbol().parameterCount();\n+                        Deque<Value> args = new ArrayDeque<>(argsCount);\n+                        for (int ai = 0; ai < argsCount; ai++) {\n+                            args.push(stack.pop());\n+                        }\n+                        Value res = null;\n+                        if (bsm.methodName().equals(\"makeConcat\")) {\n+                            for (Value argVal : args) {\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        } else {\n+                            assert bsm.methodName().equals(\"makeConcatWithConstants\");\n+                            var bsmArgs = inst.bootstrapArgs();\n+                            String recipe = (String)(bsmArgs.getFirst());\n+                            int bsmArg = 1;\n+                            for (int ri = 0; ri < recipe.length(); ri++) {\n+                                Value argVal = switch (recipe.charAt(ri)) {\n+                                    case '\\u0001' -> args.pop();\n+                                    case '\\u0002' -> liftConstant(bsmArgs.get(bsmArg++));\n+                                    default -> {\n+                                        char c;\n+                                        int start = ri;\n+                                        while (ri < recipe.length() && (c = recipe.charAt(ri)) != '\\u0001' && c != '\\u0002') ri++;\n+                                        yield liftConstant(recipe.substring(start, ri--));\n+                                    }\n+                                };\n+                                res = res == null ? argVal : op(CoreOp.concat(res, argVal));\n+                            }\n+                        }\n+                        if (res != null) stack.push(res);\n+                    } else {\n+                        MethodTypeDesc mtd = inst.typeSymbol();\n+\n+                        \/\/bootstrap\n+                        MethodTypeDesc bsmDesc = bsm.invocationType();\n+                        MethodRef bsmRef = MethodRef.method(JavaType.type(bsmOwner),\n+                                                            bsm.methodName(),\n+                                                            JavaType.type(bsmDesc.returnType()),\n+                                                            bsmDesc.parameterList().stream().map(JavaType::type).toArray(TypeElement[]::new));\n+\n+                        Value[] bootstrapArgs = liftBootstrapArgs(bsmDesc, inst.name().toString(), mtd, inst.bootstrapArgs());\n+                        Value methodHandle = op(CoreOp.invoke(MethodRef.method(CallSite.class, \"dynamicInvoker\", MethodHandle.class),\n+                                                    op(CoreOp.invoke(JavaType.type(ConstantDescs.CD_CallSite), bsmRef, bootstrapArgs))));\n+\n+                        \/\/invocation\n+                        List<Value> operands = new ArrayList<>();\n+                        for (int c = 0; c < mtd.parameterCount(); c++) {\n+                            operands.add(stack.pop());\n+                        }\n+                        operands.add(methodHandle);\n+                        MethodRef mDesc = MethodRef.method(JavaType.type(ConstantDescs.CD_MethodHandle),\n+                                                           \"invokeExact\",\n+                                                           MethodRef.ofNominalDescriptor(mtd));\n+                        Op.Result result = op(CoreOp.invoke(mDesc, operands.reversed()));\n+                        if (!result.type().equals(JavaType.VOID)) {\n+                            stack.push(result);\n+                        }\n+                    }\n+                }\n+                case NewObjectInstruction inst -> {\n+                    \/\/ Skip over this and the dup to process the invoke special\n+                    if (i + 2 < elements.size() - 1\n+                            && elements.get(i + 1) instanceof StackInstruction dup\n+                            && dup.opcode() == Opcode.DUP) {\n+                        i++;\n+                        newStack.push(inst.className().asSymbol());\n+                    } else {\n+                        throw new UnsupportedOperationException(\"New must be followed by dup\");\n+                    }\n+                }\n+                case NewPrimitiveArrayInstruction inst -> {\n+                    stack.push(op(CoreOp.newArray(\n+                            switch (inst.typeKind()) {\n+                                case BOOLEAN -> JavaType.BOOLEAN_ARRAY;\n+                                case BYTE -> JavaType.BYTE_ARRAY;\n+                                case CHAR -> JavaType.CHAR_ARRAY;\n+                                case DOUBLE -> JavaType.DOUBLE_ARRAY;\n+                                case FLOAT -> JavaType.FLOAT_ARRAY;\n+                                case INT -> JavaType.INT_ARRAY;\n+                                case LONG -> JavaType.LONG_ARRAY;\n+                                case SHORT -> JavaType.SHORT_ARRAY;\n+                                default ->\n+                                        throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                            },\n+                            stack.pop())));\n+                }\n+                case NewReferenceArrayInstruction inst -> {\n+                    stack.push(op(CoreOp.newArray(\n+                            JavaType.type(inst.componentType().asSymbol().arrayType()),\n+                            stack.pop())));\n+                }\n+                case NewMultiArrayInstruction inst -> {\n+                    stack.push(op(CoreOp._new(\n+                            FunctionType.functionType(\n+                                    JavaType.type(inst.arrayType().asSymbol()),\n+                                    Collections.nCopies(inst.dimensions(), JavaType.INT)),\n+                            IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n+                }\n+                case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n+                    stack.push(op(CoreOp.cast(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                }\n+                case TypeCheckInstruction inst -> {\n+                    stack.push(op(CoreOp.instanceOf(JavaType.type(inst.type().asSymbol()), stack.pop())));\n+                }\n+                case StackInstruction inst -> {\n+                    switch (inst.opcode()) {\n+                        case POP -> {\n+                            stack.pop();\n+                        }\n+                        case POP2 -> {\n+                            if (isCategory1(stack.pop())) {\n+                                stack.pop();\n+                            }\n+                        }\n+                        case DUP -> {\n+                            stack.push(stack.peek());\n+                        }\n+                        case DUP_X1 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            stack.push(value1);\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP_X2 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value2)) {\n+                                var value3 = stack.pop();\n+                                stack.push(value1);\n+                                stack.push(value3);\n+                            } else {\n+                                stack.push(value1);\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP2 -> {\n+                            var value1 = stack.peek();\n+                            if (isCategory1(value1)) {\n+                                stack.pop();\n+                                var value2 = stack.peek();\n+                                stack.push(value1);\n+                                stack.push(value2);\n+                            }\n+                            stack.push(value1);\n+                        }\n+                        case DUP2_X1 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value1)) {\n+                                var value3 = stack.pop();\n+                                stack.push(value2);\n+                                stack.push(value1);\n+                                stack.push(value3);\n+                            } else {\n+                                stack.push(value1);\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case DUP2_X2 -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            if (isCategory1(value1)) {\n+                                var value3 = stack.pop();\n+                                if (isCategory1(value3)) {\n+                                    var value4 = stack.pop();\n+                                    stack.push(value2);\n+                                    stack.push(value1);\n+                                    stack.push(value4);\n+                                } else {\n+                                    stack.push(value2);\n+                                    stack.push(value1);\n+                                }\n+                                stack.push(value3);\n+                            } else {\n+                                if (isCategory1(value2)) {\n+                                    var value3 = stack.pop();\n+                                    stack.push(value1);\n+                                    stack.push(value3);\n+                                } else {\n+                                    stack.push(value1);\n+                                }\n+                            }\n+                            stack.push(value2);\n+                            stack.push(value1);\n+                        }\n+                        case SWAP -> {\n+                            var value1 = stack.pop();\n+                            var value2 = stack.pop();\n+                            stack.push(value1);\n+                            stack.push(value2);\n+                        }\n+                        default ->\n+                            throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                    }\n+                }\n+                case MonitorInstruction inst -> {\n+                    var monitor = stack.pop();\n+                    switch (inst.opcode()) {\n+                        case MONITORENTER -> op(CoreOp.monitorEnter(monitor));\n+                        case MONITOREXIT -> op(CoreOp.monitorExit(monitor));\n+                        default ->\n+                                throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                    }\n+                }\n+                case NopInstruction _ -> {}\n+                case PseudoInstruction _ -> {}\n+                case Instruction inst ->\n+                    throw new UnsupportedOperationException(\"Unsupported instruction: \" + inst.opcode().name());\n+                default ->\n+                    throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n+            }\n+        }\n+        assert newStack.isEmpty();\n+    }\n+\n+    private Value load(int i) {\n+        LocalsToVarMapper.Variable var = localsToVarMapper.instructionVar(i);\n+        if (var.hasSingleAssignment()) {\n+            Value value = varToValueMap.get(var);\n+            assert value != null: \"Uninitialized single-value variable\";\n+            return value;\n+        } else {\n+            Value value = varToValueMap.get(var);\n+            assert value instanceof Op.Result r && r.op() instanceof CoreOp.VarOp: \"Invalid variable reference\";\n+            return op(CoreOp.varLoad(value));\n+        }\n+    }\n+\n+    private void store(int i, int slot, Value value) {\n+        LocalsToVarMapper.Variable var = localsToVarMapper.instructionVar(i);\n+        if (var.hasSingleAssignment()) {\n+            Value expectedNull = varToValueMap.put(var, value);\n+            assert expectedNull == null: \"Multiple assignements to a single-value variable\";\n+        } else {\n+            varToValueMap.compute(var, (_, varOpResult) -> {\n+                if (varOpResult == null) {\n+                    return op(CoreOp.var(\"slot#\" + slot,  \/\/ Initial variable declaration with slot# name\n+                                         JavaType.type(var.type()), \/\/ Type calculated by LocalsToVarMapper\n+                                         value));\n+                } else {\n+                    assert varOpResult instanceof Op.Result r && r.op() instanceof CoreOp.VarOp: \"Invalid variable reference\";\n+                    op(CoreOp.varStore(varOpResult, value)); \/\/ Store into an existig variable\n+                    return varOpResult;\n+                }\n+            });\n+        }\n+    }\n+\n+    private Op.Result lookup() {\n+        return constantCache.computeIfAbsent(LOOKUP, _ -> op(CoreOp.invoke(LOOKUP)));\n+    }\n+\n+    private Op.Result liftConstantsIntoArray(TypeElement arrayType, Object... constants) {\n+        Op.Result array = op(CoreOp.newArray(arrayType, liftConstant(constants.length)));\n+        for (int i = 0; i < constants.length; i++) {\n+            op(CoreOp.arrayStoreOp(array, liftConstant(i), liftConstant(constants[i])));\n+        }\n+        return array;\n+    }\n+\n+    private Op.Result liftDefaultValue(ClassDesc type) {\n+        return liftConstant(switch (TypeKind.from(type)) {\n+            case BOOLEAN -> false;\n+            case BYTE -> (byte)0;\n+            case CHAR -> (char)0;\n+            case DOUBLE -> 0d;\n+            case FLOAT -> 0f;\n+            case INT -> 0;\n+            case LONG -> 0l;\n+            case REFERENCE -> null;\n+            case SHORT -> (short)0;\n+            default -> throw new IllegalStateException(\"Invalid type \" + type.displayName());\n+        });\n+    }\n+\n+    private Op.Result liftConstant(Object c) {\n+        Op.Result res = constantCache.get(c);\n+        if (res == null) {\n+            res = switch (c) {\n+                case null -> op(CoreOp.constant(JavaType.J_L_OBJECT, null));\n+                case ClassDesc cd -> op(CoreOp.constant(JavaType.J_L_CLASS, JavaType.type(cd)));\n+                case Double d -> op(CoreOp.constant(JavaType.DOUBLE, d));\n+                case Float f -> op(CoreOp.constant(JavaType.FLOAT, f));\n+                case Integer ii -> op(CoreOp.constant(JavaType.INT, ii));\n+                case Long l -> op(CoreOp.constant(JavaType.LONG, l));\n+                case String s -> op(CoreOp.constant(JavaType.J_L_STRING, s));\n+                case DirectMethodHandleDesc dmh -> {\n+                    Op.Result lookup = lookup();\n+                    Op.Result owner = liftConstant(dmh.owner());\n+                    Op.Result name = liftConstant(dmh.methodName());\n+                    MethodTypeDesc invDesc = dmh.invocationType();\n+                    yield op(switch (dmh.kind()) {\n+                        case STATIC, INTERFACE_STATIC  ->\n+                            CoreOp.invoke(FIND_STATIC, lookup, owner, name, liftConstant(invDesc));\n+                        case VIRTUAL, INTERFACE_VIRTUAL ->\n+                            CoreOp.invoke(FIND_VIRTUAL, lookup, owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)));\n+                        case SPECIAL, INTERFACE_SPECIAL ->\n+                            \/\/CoreOp.invoke(MethodRef.method(e), \"findSpecial\", owner, name, liftConstant(invDesc.dropParameterTypes(0, 1)), lookup.lookupClass());\n+                            throw new UnsupportedOperationException(dmh.toString());\n+                        case CONSTRUCTOR       ->\n+                            CoreOp.invoke(FIND_CONSTRUCTOR, lookup, owner, liftConstant(invDesc.changeReturnType(ConstantDescs.CD_Void)));\n+                        case GETTER            ->\n+                            CoreOp.invoke(FIND_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                        case STATIC_GETTER     ->\n+                            CoreOp.invoke(FIND_STATIC_GETTER, lookup, owner, name, liftConstant(invDesc.returnType()));\n+                        case SETTER            ->\n+                            CoreOp.invoke(FIND_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(1)));\n+                        case STATIC_SETTER     ->\n+                            CoreOp.invoke(FIND_STATIC_SETTER, lookup, owner, name, liftConstant(invDesc.parameterType(0)));\n+                    });\n+                }\n+                case MethodTypeDesc mt -> op(switch (mt.parameterCount()) {\n+                    case 0 -> CoreOp.invoke(METHOD_TYPE_0, liftConstant(mt.returnType()));\n+                    case 1 -> CoreOp.invoke(METHOD_TYPE_1, liftConstant(mt.returnType()), liftConstant(mt.parameterType(0)));\n+                    default -> CoreOp.invoke(METHOD_TYPE_L, liftConstant(mt.returnType()), liftConstantsIntoArray(CLASS_ARRAY, (Object[])mt.parameterArray()));\n+                });\n+                case DynamicConstantDesc<?> v when v.bootstrapMethod().owner().equals(ConstantDescs.CD_ConstantBootstraps)\n+                                             && v.bootstrapMethod().methodName().equals(\"nullConstant\")\n+                        -> liftConstant(null);\n+                case DynamicConstantDesc<?> dcd -> {\n+                    DirectMethodHandleDesc bsm = dcd.bootstrapMethod();\n+                    MethodTypeDesc bsmDesc = bsm.invocationType();\n+                    Value[] bootstrapArgs = liftBootstrapArgs(bsmDesc, dcd.constantName(), dcd.constantType(), dcd.bootstrapArgsList());\n+                    MethodRef bsmRef = MethodRef.method(JavaType.type(bsm.owner()),\n+                                                        bsm.methodName(),\n+                                                        JavaType.type(bsmDesc.returnType()),\n+                                                        bsmDesc.parameterList().stream().map(JavaType::type).toArray(TypeElement[]::new));\n+                    yield op(CoreOp.invoke(bsmRef, bootstrapArgs));\n+                }\n+                case Boolean b -> op(CoreOp.constant(JavaType.BOOLEAN, b));\n+                case Byte b -> op(CoreOp.constant(JavaType.BYTE, b));\n+                case Short s -> op(CoreOp.constant(JavaType.SHORT, s));\n+                case Character ch -> op(CoreOp.constant(JavaType.CHAR, ch));\n+                default -> throw new UnsupportedOperationException(c.getClass().toString());\n+            };\n+            constantCache.put(c, res);\n+        }\n+        return res;\n+    }\n+\n+    private Value[] liftBootstrapArgs(MethodTypeDesc bsmDesc, String name, ConstantDesc desc, List<ConstantDesc> bsmArgs) {\n+        Value[] bootstrapArgs = new Value[bsmDesc.parameterCount()];\n+        bootstrapArgs[0] = lookup();\n+        bootstrapArgs[1] = liftConstant(name);\n+        bootstrapArgs[2] = liftConstant(desc);\n+        ClassDesc lastArgType = bsmDesc.parameterType(bsmDesc.parameterCount() - 1);\n+        if (lastArgType.isArray()) {\n+            for (int ai = 0; ai < bootstrapArgs.length - 4; ai++) {\n+                bootstrapArgs[ai + 3] = liftConstant(bsmArgs.get(ai));\n+            }\n+            \/\/ Vararg tail of the bootstrap method parameters\n+            bootstrapArgs[bootstrapArgs.length - 1] =\n+                    liftConstantsIntoArray(JavaType.type(lastArgType),\n+                                           bsmArgs.subList(bootstrapArgs.length - 4, bsmArgs.size()).toArray());\n+        } else {\n+            for (int ai = 0; ai < bootstrapArgs.length - 3; ai++) {\n+                bootstrapArgs[ai + 3] = liftConstant(bsmArgs.get(ai));\n+            }\n+        }\n+        return bootstrapArgs;\n+    }\n+\n+    private void liftSwitch(Label defaultTarget, List<SwitchCase> cases) {\n+        Value v = toInt(stack.pop());\n+        SwitchCase last = cases.getLast();\n+        Block.Builder def = findTargetBlock(defaultTarget);\n+        for (SwitchCase sc : cases) {\n+            Block.Builder next = sc == last ? def : newBlock(def.parameters());\n+            op(CoreOp.conditionalBranch(\n+                    op(CoreOp.eq(v, liftConstant(sc.caseValue()))),\n+                    successor(findTargetBlock(sc.target())),\n+                    successor(next)));\n+            moveTo(next);\n+        }\n+        endOfFlow();\n+    }\n+\n+    Block.Reference successor(Block.Builder next) {\n+        return next.successor(stack.stream().limit(next.parameters().size()).toList());\n+    }\n+\n+    private static TypeElement valueType(Value v) {\n+        var t = v.type();\n+        while (t instanceof VarType vt) t = vt.valueType();\n+        return t;\n+    }\n+\n+    private Op unifyOperands(BiFunction<Value, Value, Op> operator, Value v1, Value v2, TypeKind tk) {\n+        if (tk != TypeKind.INT || valueType(v1).equals(valueType(v2))) return operator.apply(v1, v2);\n+        return operator.apply(toInt(v1), toInt(v2));\n+    }\n+\n+    private Value toInt(Value v) {\n+        return valueType(v).equals(PrimitiveType.INT) ? v : op(CoreOp.conv(PrimitiveType.INT, v));\n+    }\n+\n+    private Value zero(Value otherOperand) {\n+        return liftDefaultValue(BytecodeGenerator.toClassDesc(otherOperand.type()));\n+    }\n+\n+    private static boolean isCategory1(Value v) {\n+        return BytecodeGenerator.toTypeKind(v.type()).slotSize() == 1;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":1021,"deletions":0,"binary":false,"changes":1021,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.ExceptionCatch;\n+import java.lang.classfile.instruction.IncrementInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.classfile.instruction.LoadInstruction;\n+import java.lang.classfile.instruction.LookupSwitchInstruction;\n+import java.lang.classfile.instruction.TableSwitchInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import static java.lang.constant.ConstantDescs.CD_double;\n+import static java.lang.constant.ConstantDescs.CD_long;\n+\n+\/**\n+ * LocalsCompactor transforms class to reduce allocation of local slots in the Code attribute (max_locals).\n+ * It collects slot maps, compacts them and transforms the Code attribute accordingly.\n+ * <p>\n+ * Example of maps before compaction (max_locals = 13):\n+ * <pre>\n+ *  slots:  0   1   2   3   4   5   6   7   8   9   10  11  12  13\n+ *  ---------------------------------------------------------------\n+ *  bci 0:  *   *\n+ *      8:      *   *   *\n+ *     10:      *   *   *\n+ *     15:      *   *   *   *   *\n+ *     17:      *   *   *   *   *\n+ *     18:      *           *   *\n+ *     25:      *                   *   *\n+ *     27:      *                   *   *\n+ *     32:      *                   *   *   *   *\n+ *     34:      *                   *   *   *   *\n+ *     36:      *                           *   *\n+ *     43:      *                                   *   *\n+ *     45:      *                                   *   *\n+ *     50:                                          *   *   *   *\n+ *     52:                                          *   *   *   *\n+ *     54:                                                  *   *\n+ * <\/pre>\n+ * Compact form of the same maps (max_locals = 5):\n+ * <pre>\n+ *  slots:   0   1   2   3   4   5\n+ *         +12 +13  +6  +7  +8  +9\n+ *                 +10 +11\n+ *  -------------------------------\n+ *  bci 0:  *   *\n+ *      8:      *   *   *\n+ *     10:      *   *   *\n+ *     15:      *   *   *   *   *\n+ *     17:      *   *   *   *   *\n+ *     18:      *           *   *\n+ *     25:      *   *   *\n+ *     27:      *   *   *\n+ *     32:      *   *   *   *   *\n+ *     34:      *   *   *   *   *\n+ *     36:      *           *   *\n+ *     43:      *   *   *\n+ *     45:      *   *   *\n+ *     50:  *   *   *   *\n+ *     52:  *   *   *   *\n+ *     54:  *   *\n+ * <\/pre>\n+ *\/\n+public final class LocalsCompactor {\n+\n+    static class ExceptionTableCompactor implements CodeTransform {\n+        ExceptionCatch last = null;\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            if (coe instanceof ExceptionCatch ec) {\n+                if (ec.tryStart() != ec.tryEnd()) {\n+                    if (last != null) {\n+                        if (last.handler() == ec.handler() && last.catchType().equals(ec.catchType())) {\n+                            if (last.tryStart() == ec.tryEnd()) {\n+                                last = ExceptionCatch.of(last.handler(), ec.tryStart(), last.tryEnd(), last.catchType());\n+                                return;\n+                            } else if (last.tryEnd() == ec.tryStart()) {\n+                                last = ExceptionCatch.of(last.handler(), last.tryStart(), ec.tryEnd(), last.catchType());\n+                                return;\n+                            }\n+                        }\n+                        cob.with(last);\n+                    }\n+                    last = ec;\n+                }\n+            } else {\n+                cob.with(coe);\n+            }\n+        }\n+\n+        @Override\n+        public void atEnd(CodeBuilder cob) {\n+            if (last != null) {\n+                cob.with(last);\n+                last = null;\n+            }\n+        }\n+    }\n+\n+    public static final ClassTransform INSTANCE = (clb,cle) -> {\n+        if (cle instanceof MethodModel mm) {\n+            clb.transformMethod(mm, (mb, me) -> {\n+                if (me instanceof CodeModel com) {\n+                    int[] slotMap = new LocalsCompactor(com, countParamSlots(mm)).slotMap;\n+                    \/\/ @@@ ExceptionTableCompactor can be chained on ClassTransform level when the recent Class-File API is merged into code-reflection\n+                    mb.transformCode(com, new ExceptionTableCompactor().andThen((cob, coe) -> {\n+                        switch (coe) {\n+                            case LoadInstruction li ->\n+                                cob.loadLocal(li.typeKind(), slotMap[li.slot()]);\n+                            case StoreInstruction si ->\n+                                cob.storeLocal(si.typeKind(), slotMap[si.slot()]);\n+                            case IncrementInstruction ii ->\n+                                cob.iinc(slotMap[ii.slot()], ii.constant());\n+                            default ->\n+                                cob.with(coe);\n+                        }\n+                    }));\n+                } else {\n+                    mb.with(me);\n+                }\n+            });\n+        } else {\n+            clb.with(cle);\n+        }\n+    };\n+\n+    private static int countParamSlots(MethodModel mm) {\n+        int slots = mm.flags().has(AccessFlag.STATIC) ? 0 : 1;\n+        for (ClassDesc p : mm.methodTypeSymbol().parameterList()) {\n+            slots += p == CD_long || p == CD_double ? 2 : 1;\n+        }\n+        return slots;\n+    }\n+\n+    static final class Slot {\n+        final BitSet map = new BitSet(); \/\/ Liveness map of the slot\n+        int flags; \/\/ 0 - single slot, 1 - first of double slots, 2 - second of double slots, 3 - mixed\n+    }\n+\n+    private final List<Slot> maps; \/\/ Intermediate slots liveness maps\n+    private final Map<Label, List<StackMapFrameInfo.VerificationTypeInfo>> frames;\n+    private final int[] slotMap; \/\/ Output mapping of the slots\n+\n+    private LocalsCompactor(CodeModel com, int fixedSlots) {\n+        frames = com.findAttribute(Attributes.stackMapTable()).map(\n+                smta -> smta.entries().stream().collect(\n+                        Collectors.toMap(StackMapFrameInfo::target, StackMapFrameInfo::locals)))\n+                .orElse(Map.of());\n+        var exceptionHandlers = com.exceptionHandlers();\n+        maps = new ArrayList<>();\n+        int pc = 0;\n+        \/\/ Initialization of fixed slots\n+        for (int slot = 0; slot < fixedSlots; slot++) {\n+            getMap(slot).map.set(0);\n+        }\n+        \/\/ Filling the slots liveness maps\n+        for (var e : com) {\n+            switch(e) {\n+                case LabelTarget lt -> {\n+                    for (var eh : exceptionHandlers) {\n+                        if (eh.tryStart() == lt.label()) {\n+                            mergeFrom(pc, eh.handler());\n+                        }\n+                    }\n+                }\n+                case LoadInstruction li ->\n+                    load(pc, li.slot(), li.typeKind());\n+                case StoreInstruction si ->\n+                    store(pc, si.slot(), si.typeKind());\n+                case IncrementInstruction ii ->\n+                    loadSingle(pc, ii.slot());\n+                case BranchInstruction bi ->\n+                    mergeFrom(pc, bi.target());\n+                case LookupSwitchInstruction si -> {\n+                    mergeFrom(pc, si.defaultTarget());\n+                    for (var sc : si.cases()) {\n+                        mergeFrom(pc, sc.target());\n+                    }\n+                }\n+                case TableSwitchInstruction si -> {\n+                    mergeFrom(pc, si.defaultTarget());\n+                    for (var sc : si.cases()) {\n+                        mergeFrom(pc, sc.target());\n+                    }\n+                }\n+                default -> pc--;\n+            }\n+            pc++;\n+        }\n+        \/\/ Initialization of slots mapping\n+        slotMap = new int[maps.size()];\n+        for (int slot = 0; slot < slotMap.length; slot++) {\n+            slotMap[slot] = slot;\n+        }\n+        \/\/ Iterative compaction of slots\n+        for (int targetSlot = 0; targetSlot < maps.size() - 1; targetSlot++) {\n+            for (int sourceSlot = Math.max(targetSlot + 1, fixedSlots); sourceSlot < maps.size(); sourceSlot++) {\n+                Slot source = maps.get(sourceSlot);\n+                \/\/ Re-mapping single slot\n+                if (source.flags == 0) {\n+                    Slot target = maps.get(targetSlot);\n+                    if (!target.map.intersects(source.map)) {\n+                        \/\/ Single re-mapping, merge of the liveness maps and shift of the following slots by 1 left\n+                        target.map.or(source.map);\n+                        maps.remove(sourceSlot);\n+                        for (int slot = 0; slot < slotMap.length; slot++) {\n+                            if (slotMap[slot] == sourceSlot) {\n+                                slotMap[slot] = targetSlot;\n+                            } else if (slotMap[slot] > sourceSlot) {\n+                                slotMap[slot]--;\n+                            }\n+                        }\n+                    }\n+                } else if (source.flags == 1 && sourceSlot > targetSlot + 1) {\n+                    Slot source2 = maps.get(sourceSlot + 1);\n+                    \/\/ Re-mapping distinct double slot\n+                    if (source2.flags == 2) {\n+                        Slot target = maps.get(targetSlot);\n+                        Slot target2 = maps.get(targetSlot + 1);\n+                        if (!target.map.intersects(source.map) && !target2.map.intersects(source2.map)) {\n+                            \/\/ Double re-mapping, merge of the liveness maps and shift of the following slots by 2 left\n+                            target.map.or(source.map);\n+                            target2.map.or(source2.map);\n+                            maps.remove(sourceSlot + 1);\n+                            maps.remove(sourceSlot);\n+                            for (int slot = 0; slot < slotMap.length; slot++) {\n+                                if (slotMap[slot] == sourceSlot) {\n+                                    slotMap[slot] = targetSlot;\n+                                } else if (slotMap[slot] == sourceSlot + 1) {\n+                                    slotMap[slot] = targetSlot + 1;\n+                                } else if (slotMap[slot] > sourceSlot + 1) {\n+                                    slotMap[slot] -= 2;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private Slot getMap(int slot) {\n+        while (slot >= maps.size()) {\n+            maps.add(new Slot());\n+        }\n+        return maps.get(slot);\n+    }\n+\n+    private Slot loadSingle(int pc, int slot) {\n+        Slot s =  getMap(slot);\n+        int start = s.map.nextSetBit(0) + 1;\n+        s.map.set(start, pc + 1);\n+        return s;\n+    }\n+\n+    private void load(int pc, int slot, TypeKind tk) {\n+        load(pc, slot, tk.slotSize() == 2);\n+    }\n+\n+    private void load(int pc, int slot, boolean dual) {\n+        if (dual) {\n+            loadSingle(pc, slot).flags |= 1;\n+            loadSingle(pc, slot + 1).flags |= 2;\n+        } else {\n+            loadSingle(pc, slot);\n+        }\n+    }\n+\n+    private void mergeFrom(int pc, Label target) {\n+        int slot = 0;\n+        for (var vti : frames.get(target)) {\n+            if (vti != TOP) {\n+                if (vti == LONG || vti == DOUBLE) {\n+                    load(pc, slot++, true);\n+                } else {\n+                    loadSingle(pc, slot);\n+                }\n+            }\n+            slot++;\n+        }\n+    }\n+\n+    private Slot storeSingle(int pc, int slot) {\n+        Slot s = getMap(slot);\n+        s.map.set(pc);\n+        return s;\n+    }\n+\n+    private void store(int pc, int slot, TypeKind tk) {\n+        if (tk.slotSize() == 2) {\n+            storeSingle(pc, slot).flags |= 1;\n+            storeSingle(pc, slot + 1).flags |= 2;\n+        } else {\n+            storeSingle(pc, slot);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsCompactor.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -0,0 +1,882 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapFrameInfo.*;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.NULL;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * LocalsToVarMapper scans bytecode for slot operations, forms oriented flow graphs of the slot operation segments,\n+ * analyzes the graphs and maps the segments to distinct variables, calculates each variable type and identifies\n+ * single-assigned variables and variables requiring initialization in the entry block.\n+ *\/\n+final class LocalsToVarMapper {\n+\n+    \/**\n+     * Variable identity object result of the LocalsToVarMapper analysis.\n+     *\/\n+    public static final class Variable {\n+        private ClassDesc type;\n+        private boolean single;\n+\n+        \/**\n+         * {@return Variable type}\n+         *\/\n+        ClassDesc type() {\n+            return type;\n+        }\n+\n+        \/**\n+         * {@return whether the variable has only single assignement}\n+         *\/\n+        boolean hasSingleAssignment() {\n+            return single;\n+        }\n+    }\n+\n+    \/**\n+     * Segment of bytecode related to one local slot, it represents a node in the segment graph.\n+     *\/\n+    private static final class Segment {\n+\n+        \/**\n+         * Categorization of the segment graph nodes.\n+         *\/\n+        enum Kind {\n+\n+            \/**\n+             * Segment storing a value into the local slot.\n+             *\/\n+            STORE,\n+\n+            \/**\n+             * Segment requesting to load value from the local slot.\n+             *\/\n+            LOAD,\n+\n+            \/**\n+             * Segment forming a frame of connection to other segments.\n+             * This kind of segment is later either resolved as LOAD or it identifies false connection.\n+             *\/\n+            FRAME;\n+        }\n+\n+        \/**\n+         * Link between segments.\n+         *\/\n+        record Link(Segment segment, Link other) {}\n+\n+        \/**\n+         * Kind of segment.\n+         * The value is not final, {@link Kind.FRAME} segments may be later resolved to {@link Kind.LOAD}.\n+         *\/\n+        Kind kind;\n+\n+        \/**\n+         * Segment type.\n+         * The value is not final, int type may be later changed to {@code boolean}, {@code byte}, {@code short} or {@code char}.\n+         *\/\n+        ClassDesc type;\n+\n+        \/**\n+         * Variable this segment belongs to.\n+         * The value is calculated later in the process.\n+         *\/\n+        Variable var;\n+\n+\n+        \/**\n+         * Incoming segments in the flow graph.\n+         *\/\n+        Link from;\n+\n+        \/**\n+         * Outgoing segments in the flow graph.\n+         *\/\n+        Link to;\n+\n+        \/**\n+         * Links this segment to an outgoing segment.\n+         * @param toSegment outgoing segment\n+         *\/\n+        void link(Segment toSegment) {\n+            if (this != toSegment) {\n+                toSegment.from = new Link(this, toSegment.from);\n+                this.to = new Link(toSegment, this.to);\n+            }\n+        }\n+\n+        \/**\n+         * {@return Iterable over incomming segments.}\n+         *\/\n+        Iterable<Segment> fromSegments() {\n+            return () -> new LinkIterator(from);\n+        }\n+\n+        \/**\n+         * {@return Iterable over outgoing segments.}\n+         *\/\n+        Iterable<Segment> toSegments() {\n+            return () -> new LinkIterator(to);\n+        }\n+\n+        private static final class LinkIterator implements Iterator<Segment> {\n+            Link l;\n+            public LinkIterator(Link l) {\n+                this.l = l;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return l != null;\n+            }\n+\n+            @Override\n+            public Segment next() {\n+                if (l == null) throw new NoSuchElementException();\n+                Segment s = l.segment();\n+                l = l.other();\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Stack map frame\n+     *\/\n+    private record Frame(List<ClassDesc> stack, List<Segment> locals) {}\n+\n+    \/**\n+     * Specific instance of CD_Object identifying null initialized objects.\n+     *\/\n+    private static final ClassDesc NULL_TYPE = ClassDesc.ofDescriptor(CD_Object.descriptorString());\n+\n+    \/**\n+     * Map from instruction index to a segment.\n+     *\/\n+    private final Map<Integer, Segment> insMap;\n+\n+    \/**\n+     * Set of all involved segments.\n+     *\/\n+    private final LinkedHashSet<Segment> allSegments;\n+\n+    \/**\n+     * This class descriptor.\n+     *\/\n+    private final ClassDesc thisClass;\n+\n+    \/**\n+     * All exception handlers.\n+     *\/\n+    private final List<ExceptionCatch> exceptionHandlers;\n+\n+    \/**\n+     * Actual exception handlers stack.\n+     *\/\n+    private final Set<ExceptionCatch> handlersStack;\n+\n+    \/**\n+     * Actual stack.\n+     *\/\n+    private final List<ClassDesc> stack;\n+\n+    \/**\n+     * Actual locals.\n+     *\/\n+    private final List<Segment> locals;\n+\n+    \/**\n+     * Stack map.\n+     *\/\n+    private final Map<Label, Frame> stackMap;\n+\n+    \/**\n+     * Map of new object types (to resolve unitialized verification types in the stack map).\n+     *\/\n+    private final Map<Label, ClassDesc> newMap;\n+\n+    \/**\n+     * Dirty flag indicates modified stack map frame (sub-int adjustments), so the scanning process must restart\n+     *\/\n+    private boolean frameDirty;\n+\n+    \/**\n+     * Initial set of slots. Static part comes from method arguments.\n+     * Later phase of the analysis adds synthetic slots (declarations of multiple-assigned variables)\n+     * with mandatory initialization in the entry block.\n+     *\/\n+    private final List<Segment> initSlots;\n+\n+    \/**\n+     * Constructor and executor of the LocalsToVarMapper.\n+     * @param thisClass This class descriptor.\n+     * @param initFrameLocals Entry frame locals, expanded form of the method receiver and arguments. Second positions of double slots are null.\n+     * @param exceptionHandlers Exception handlers.\n+     * @param stackMapTableAttribute Stack map table attribute.\n+     * @param codeElements Code elements list. Indexes of this list are keys to the {@link #instructionVar(int) } method.\n+     *\/\n+    public LocalsToVarMapper(ClassDesc thisClass,\n+                     List<ClassDesc> initFrameLocals,\n+                     List<ExceptionCatch> exceptionHandlers,\n+                     Optional<StackMapTableAttribute> stackMapTableAttribute,\n+                     List<CodeElement> codeElements) {\n+        this.insMap = new HashMap<>();\n+        this.thisClass = thisClass;\n+        this.exceptionHandlers = exceptionHandlers;\n+        this.handlersStack = new LinkedHashSet<>();\n+        this.stack = new ArrayList<>();\n+        this.locals = new ArrayList<>();\n+        this.allSegments = new LinkedHashSet<>();\n+        this.newMap = computeNewMap(codeElements);\n+        this.initSlots = new ArrayList<>();\n+        this.stackMap = stackMapTableAttribute.map(a -> a.entries().stream().collect(Collectors.toMap(\n+                StackMapFrameInfo::target,\n+                this::toFrame))).orElse(Map.of());\n+        for (ClassDesc cd : initFrameLocals) {\n+            initSlots.add(cd == null ? null : newSegment(cd, Segment.Kind.STORE));\n+        }\n+        int initSize = allSegments.size();\n+\n+        \/\/ Main loop of the scan phase\n+        do {\n+            \/\/ Reset of the exception handler stack\n+            handlersStack.clear();\n+            \/\/ Slot states reset if running additional rounds (changed stack map frames)\n+            if (allSegments.size() > initSize) {\n+                while (allSegments.size() > initSize) allSegments.removeLast();\n+                allSegments.forEach(sl -> {\n+                    sl.from = null;\n+                    sl.to = null;\n+                    sl.var = null;\n+                });\n+            }\n+            \/\/ Initial frame store\n+            for (int i = 0; i < initFrameLocals.size(); i++) {\n+                storeLocal(i, initSlots.get(i), locals);\n+            }\n+            this.frameDirty = false;\n+            \/\/ Iteration over all code elements\n+            for (int i = 0; i < codeElements.size(); i++) {\n+                var ce = codeElements.get(i);\n+                scan(i, ce);\n+            }\n+            endOfFlow();\n+        } while (this.frameDirty);\n+\n+        \/\/ Segment graph analysis phase\n+        \/\/ First resolve FRAME segments to LOAD segments if directly followed by a LOAD segment\n+        \/\/ Remaining FRAME segments do not form connection with segments of the same variable and will be ignored.\n+        boolean changed = true;\n+        while (changed) {\n+            changed = false;\n+            for (Segment segment : allSegments) {\n+                if (segment.kind == Segment.Kind.FRAME) {\n+                    for (Segment to : segment.toSegments()) {\n+                        if (to.kind == Segment.Kind.LOAD) {\n+                            changed = true;\n+                            segment.kind = Segment.Kind.LOAD;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Assign variable to segments, calculate var type\n+        Set<Segment> stores = new LinkedHashSet<>(); \/\/ Helper set to collect all STORE segments of a variable\n+        ArrayDeque<Segment> q = new ArrayDeque<>(); \/\/ Working queue\n+        Set<Segment> visited = new LinkedHashSet<>(); \/\/ Helper set to traverse segment graph to filter initial stores\n+        for (Segment segment : allSegments) {\n+            \/\/ Only STORE and LOAD segments without assigned var are computed\n+            if (segment.var == null && segment.kind != Segment.Kind.FRAME) {\n+                Variable var = new Variable(); \/\/ New variable\n+                q.add(segment);\n+                var.type = segment.type; \/\/ Initial variable type\n+                while (!q.isEmpty()) {\n+                    Segment se = q.pop();\n+                    if (se.var == null) {\n+                        se.var = var; \/\/ Assign variable to the segment\n+                        for (Segment to : se.toSegments()) {\n+                            \/\/ All following LOAD segments belong to the same variable\n+                            if (to.kind == Segment.Kind.LOAD) {\n+                                if (var.type == NULL_TYPE) {\n+                                    var.type = to.type; \/\/ Initially null type re-assignemnt\n+                                }\n+                                if (to.var == null) {\n+                                    q.add(to);\n+                                }\n+                            }\n+                        }\n+                        if (se.kind == Segment.Kind.LOAD) {\n+                            \/\/ Segments preceeding LOAD segment also belong to the same variable\n+                            for (Segment from : se.fromSegments()) {\n+                                if (from.kind != Segment.Kind.FRAME) { \/\/ FRAME segments are ignored\n+                                    if (var.type == NULL_TYPE) {\n+                                        var.type = from.type; \/\/ Initially null type re-assignemnt\n+                                    }\n+                                    if (from.var == null) {\n+                                        q.add(from);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                    if (se.var == var && se.kind == Segment.Kind.STORE) {\n+                        stores.add(se); \/\/ Collection of all STORE segments of the variable\n+                    }\n+                }\n+\n+                \/\/ Single-assigned variable has only one STORE segment\n+                var.single = stores.size() < 2;\n+\n+                \/\/ Identification of initial STORE segments\n+                for (var it = stores.iterator(); it.hasNext();) {\n+                    visited.clear();\n+                    Segment s = it.next();\n+                    if (s.from != null && varDominatesOverSegmentPredecessors(s, var, visited)) {\n+                        \/\/ A store preceeding dominantly with segments of the same variable is not initial\n+                        it.remove();\n+                    }\n+                }\n+\n+                \/\/ Remaining stores are all initial.\n+                if (stores.size() > 1) {\n+                    \/\/ A synthetic default-initialized dominant segment must be inserted to the variable, if there is more than one initial store segment.\n+                    \/\/ It is not necessary to link it with other variable segments, the analysys ends here.\n+                    Segment initialSegment = new Segment();\n+                    initialSegment.var = var;\n+                    initSlots.add(initialSegment);\n+                    if (var.type == CD_long || var.type == CD_double) {\n+                        initSlots.add(null); \/\/ Do not forget to alocate second slot for double slots.\n+                    }\n+                }\n+                stores.clear();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@return Number of slots to initialize at entry block (method receiver + arguments + synthetic variable initialization segments).}\n+     *\/\n+    public int slotsToInit() {\n+        return initSlots.size();\n+    }\n+\n+    \/**\n+     * {@return Variable related to the given initial slot or null}\n+     * @param initSlot initial slot index\n+     *\/\n+    public Variable initSlotVar(int initSlot) {\n+        Segment s = initSlots.get(initSlot);\n+        return s == null ? null : s.var;\n+    }\n+\n+    \/**\n+     * Method returns relevant {@link Variable} for instructions operating with local slots,\n+     * such as {@link LoadInstruction}, {@link StoreInstruction} and {@link IncrementInstruction}.\n+     * For all other elements it returns {@code null}.\n+     *\n+     * Instructions are identified by index into the {@code codeElements} list used in the {@link LocalsToVarMapper} initializer.\n+     *\n+     * {@link IncrementInstruction} relates to two potentially distinct variables, one variable to load the value from\n+     * and one variable to store the incremented value into (see: {@link BytecodeLift#liftBody() }).\n+     *\n+     * @param codeElementIndex code element index\n+     * @return Variable related to the given code element index or null\n+     *\/\n+    public Variable instructionVar(int codeElementIndex) {\n+        return insMap.get(codeElementIndex).var;\n+    }\n+\n+    \/**\n+     * Tests if variable dominates over the segment predecessors.\n+     * All incoming paths to the segment must lead from segments of the given variable and not of any other variable.\n+     * The paths may pass through {@code FRAME} segments, which do not belong to any variable and their dominance must be computed.\n+     * Implementation relies on loops-avoiding breadth-first negative search.\n+     *\/\n+    private static boolean varDominatesOverSegmentPredecessors(Segment segment, Variable var, Set<Segment> visited) {\n+        if (visited.add(segment)) {\n+            for (Segment pred : segment.fromSegments()) {\n+                \/\/ Breadth-first\n+                if (pred.kind != Segment.Kind.FRAME && pred.var != var) {\n+                    return false;\n+                }\n+            }\n+            for (Segment pred : segment.fromSegments()) {\n+                \/\/ Preceeding FRAME segment implies there is no directly preceeding variable and the dominance test must go deeper\n+                if (pred.kind == Segment.Kind.FRAME && !varDominatesOverSegmentPredecessors(pred, var, visited)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Cconverts {@link StackMapFrameInfo} to {@code Frame}, where locals are expanded form ({@code null}-filled second slots for double-slots)\n+     * of {@code FRAME} segments.\n+     * @param smfi StackMapFrameInfo\n+     * @return Frame\n+     *\/\n+    private Frame toFrame(StackMapFrameInfo smfi) {\n+        List<ClassDesc> fstack = new ArrayList<>(smfi.stack().size());\n+        List<Segment> flocals = new ArrayList<>(smfi.locals().size() * 2);\n+        for (var vti : smfi.stack()) {\n+            fstack.add(vtiToStackType(vti));\n+        }\n+        int i = 0;\n+        for (var vti : smfi.locals()) {\n+            storeLocal(i, vtiToStackType(vti), flocals, Segment.Kind.FRAME);\n+            i += vti == DOUBLE || vti == LONG ? 2 : 1;\n+        }\n+        return new Frame(fstack, flocals);\n+    }\n+\n+    \/**\n+     * {@return map of labels immediately preceding {@link NewObjectInstruction} to the object types}\n+     * The map is important to resolve unitialized verification types in the stack map.\n+     * @param codeElements List of code elements to scan\n+     *\/\n+    private static Map<Label, ClassDesc> computeNewMap(List<CodeElement> codeElements) {\n+        Map<Label, ClassDesc> newMap = new HashMap<>();\n+        Label lastLabel = null;\n+        for (int i = 0; i < codeElements.size(); i++) {\n+            switch (codeElements.get(i)) {\n+                case LabelTarget lt -> lastLabel = lt.label();\n+                case NewObjectInstruction newI -> {\n+                    if (lastLabel != null) {\n+                        newMap.put(lastLabel, newI.className().asSymbol());\n+                    }\n+                }\n+                case Instruction _ -> lastLabel = null; \/\/invalidate label\n+                default -> {} \/\/skip\n+            }\n+        }\n+        return newMap;\n+    }\n+\n+    \/**\n+     * {@return new segment and registers it in {@code allSegments} list}\n+     * @param type class descriptor of segment type\n+     * @param kind one of the segment kinds: {@code STORE}, {@code LOAD} or {@code FRAME}\n+     *\/\n+    private Segment newSegment(ClassDesc type, Segment.Kind kind) {\n+        Segment s = new Segment();\n+        s.kind = kind;\n+        s.type = type;\n+        allSegments.add(s);\n+        return s;\n+    }\n+\n+    \/**\n+     * {@return resolved class descriptor of the stack map frame verification type, custom {@code NULL_TYPE} for {@code ITEM_NULL}\n+     * or {@code null} for {@code ITEM_TOP}}\n+     * @param vti stack map frame verification type\n+     *\/\n+    private ClassDesc vtiToStackType(StackMapFrameInfo.VerificationTypeInfo vti) {\n+        return switch (vti) {\n+            case INTEGER -> CD_int;\n+            case FLOAT -> CD_float;\n+            case DOUBLE -> CD_double;\n+            case LONG -> CD_long;\n+            case UNINITIALIZED_THIS -> thisClass;\n+            case NULL -> NULL_TYPE;\n+            case ObjectVerificationTypeInfo ovti -> ovti.classSymbol();\n+            case UninitializedVerificationTypeInfo uvti ->\n+                newMap.computeIfAbsent(uvti.newTarget(), l -> {\n+                    throw new IllegalArgumentException(\"Unitialized type does not point to a new instruction\");\n+                });\n+            case TOP -> null;\n+        };\n+    }\n+\n+    \/**\n+     * Pushes the class descriptor on {@link #stack}, except for {@code void}.\n+     * @param type class descriptor\n+     *\/\n+    private void push(ClassDesc type) {\n+        if (!ConstantDescs.CD_void.equals(type)) stack.add(type);\n+    }\n+\n+    \/**\n+     * Pushes the class descriptors on the {@link #stack} at the relative position, except for {@code void}.\n+     * @param pos position relative to the stack tip\n+     * @param types class descriptors\n+     *\/\n+    private void pushAt(int pos, ClassDesc... types) {\n+        for (var t : types)\n+            if (!ConstantDescs.CD_void.equals(t))\n+                stack.add(stack.size() + pos, t);\n+    }\n+\n+    \/**\n+     * {@return if class descriptor on the {@link #stack} at the relative position is {@code long} or {@code double}}\n+     * @param pos position relative to the stack tip\n+     *\/\n+    private boolean doubleAt(int pos) {\n+        var t  = stack.get(stack.size() + pos);\n+        return t.equals(CD_long) || t.equals(CD_double);\n+    }\n+\n+    \/**\n+     * {@return class descriptor poped from the {@link #stack}}\n+     *\/\n+    private ClassDesc pop() {\n+        return stack.removeLast();\n+    }\n+\n+    \/**\n+     * {@return class descriptor from the relative position of the {@link #stack}}\n+     * @param pos position relative to the stack tip\n+     *\/\n+    private ClassDesc get(int pos) {\n+        return stack.get(stack.size() + pos);\n+    }\n+\n+    \/**\n+     * {@return class descriptor from the tip of the {@link #stack}}\n+     *\/\n+    private ClassDesc top() {\n+        return stack.getLast();\n+    }\n+\n+    \/**\n+     * {@return two class descriptors from the tip of the {@link #stack}}\n+     *\/\n+    private ClassDesc[] top2() {\n+        return new ClassDesc[] {stack.get(stack.size() - 2), stack.getLast()};\n+    }\n+\n+    \/**\n+     * Pops given number of class descriptors from the {@link #stack}.\n+     * @param i number of class descriptors to pop\n+     * @return this LocalsToVarMapper\n+     *\/\n+    private LocalsToVarMapper pop(int i) {\n+        while (i-- > 0) pop();\n+        return this;\n+    }\n+\n+    \/**\n+     * Stores class descriptor as a new {@code STORE} {@link Segment} to the {@link #locals}.\n+     * The new segment is linked with the previous segment on the same slot position (if any).\n+     * @param slot locals slot number\n+     * @param type new segment class descriptor\n+     *\/\n+    private void storeLocal(int slot, ClassDesc type) {\n+        storeLocal(slot, type, locals, Segment.Kind.STORE);\n+    }\n+\n+    \/**\n+     * Stores class descriptor as a new {@link Segment} of given kind to the given list .\n+     * The new segment is linked with the previous segment on the same slot position (if any).\n+     * @param slot locals slot number\n+     * @param type new segment class descriptor\n+     * @param where target list of segments\n+     * @param kind new segment kind\n+     *\/\n+    private void storeLocal(int slot, ClassDesc type, List<Segment> where, Segment.Kind kind) {\n+        storeLocal(slot, type == null ? null : newSegment(type, kind), where);\n+    }\n+\n+    \/**\n+     * Stores the {@link Segment} to the given list.\n+     * The new segment is linked with the previous segment on the same slot position (if any).\n+     * @param slot locals slot number\n+     * @param segment the segment to store\n+     * @param where target list of segments\n+     *\/\n+    private void storeLocal(int slot, Segment segment, List<Segment> where) {\n+        if (segment != null) {\n+            for (int i = where.size(); i <= slot; i++) where.add(null);\n+            Segment prev = where.set(slot, segment);\n+            if (prev != null) {\n+                prev.link(segment);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Links existing {@link Segment} of the {@link #locals} with a new {@code LOAD} {@link Segment} with inherited type.\n+     * @param slot slot number to load\n+     * @return type of the local\n+     *\/\n+    private ClassDesc loadLocal(int slot) {\n+        Segment segment = locals.get(slot);\n+        Segment newSegment = newSegment(segment.type, Segment.Kind.LOAD);\n+        segment.link(newSegment);\n+        return segment.type;\n+    }\n+\n+    \/**\n+     * Main code element scanning method of the scan loop.\n+     * @param elementIndex element index\n+     * @param el code element\n+     *\/\n+    private void scan(int elementIndex, CodeElement el) {\n+        switch (el) {\n+            case ArrayLoadInstruction _ ->\n+                pop(1).push(pop().componentType());\n+            case ArrayStoreInstruction _ ->\n+                pop(3);\n+            case BranchInstruction i -> {\n+                switch (i.opcode()) {\n+                    case IFEQ, IFGE, IFGT, IFLE, IFLT, IFNE, IFNONNULL, IFNULL -> {\n+                        pop();\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case IF_ACMPEQ, IF_ACMPNE, IF_ICMPEQ, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE, IF_ICMPLT, IF_ICMPNE -> {\n+                        pop(2);\n+                        mergeToTargetFrame(i.target());\n+                    }\n+                    case GOTO, GOTO_W -> {\n+                        mergeToTargetFrame(i.target());\n+                        endOfFlow();\n+                    }\n+                }\n+            }\n+            case ConstantInstruction i ->\n+                push(switch (i.constantValue()) {\n+                    case null -> NULL_TYPE;\n+                    case ClassDesc _ -> CD_Class;\n+                    case Double _ -> CD_double;\n+                    case Float _ -> CD_float;\n+                    case Integer _ -> CD_int;\n+                    case Long _ -> CD_long;\n+                    case String _ -> CD_String;\n+                    case DynamicConstantDesc<?> cd when cd.equals(NULL) -> NULL_TYPE;\n+                    case DynamicConstantDesc<?> cd -> cd.constantType();\n+                    case DirectMethodHandleDesc _ -> CD_MethodHandle;\n+                    case MethodTypeDesc _ -> CD_MethodType;\n+                });\n+            case ConvertInstruction i ->\n+                pop(1).push(i.toType().upperBound());\n+            case FieldInstruction i -> {\n+                switch (i.opcode()) {\n+                    case GETSTATIC ->\n+                        push(i.typeSymbol());\n+                    case GETFIELD ->\n+                        pop(1).push(i.typeSymbol());\n+                    case PUTSTATIC ->\n+                        pop(1);\n+                    case PUTFIELD ->\n+                        pop(2);\n+                }\n+            }\n+            case IncrementInstruction i -> { \/\/ Increment instruction maps to two segments\n+                loadLocal(i.slot());\n+                insMap.put(-elementIndex - 1, locals.get(i.slot())); \/\/ source segment is mapped with -elementIndex - 1 key\n+                storeLocal(i.slot(), CD_int);\n+                insMap.put(elementIndex, locals.get(i.slot())); \/\/ target segment is mapped with elementIndex key\n+                for (var ec : handlersStack) {\n+                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                }\n+            }\n+            case InvokeDynamicInstruction i ->\n+                pop(i.typeSymbol().parameterCount()).push(i.typeSymbol().returnType());\n+            case InvokeInstruction i ->\n+                pop(i.typeSymbol().parameterCount() + (i.opcode() == Opcode.INVOKESTATIC ? 0 : 1))\n+                        .push(i.typeSymbol().returnType());\n+            case LoadInstruction i -> {\n+                push(loadLocal(i.slot())); \/\/ Load instruction segment is mapped with elementIndex key\n+                insMap.put(elementIndex, locals.get(i.slot()));\n+            }\n+            case StoreInstruction i -> {\n+                storeLocal(i.slot(), pop());\n+                insMap.put(elementIndex, locals.get(i.slot()));  \/\/ Store instruction segment is mapped with elementIndex key\n+                for (var ec : handlersStack) {\n+                    mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                }\n+            }\n+            case MonitorInstruction _ ->\n+                pop(1);\n+            case NewMultiArrayInstruction i ->\n+                pop(i.dimensions()).push(i.arrayType().asSymbol());\n+            case NewObjectInstruction i ->\n+                push(i.className().asSymbol());\n+            case NewPrimitiveArrayInstruction i ->\n+                pop(1).push(i.typeKind().upperBound().arrayType());\n+            case NewReferenceArrayInstruction i ->\n+                pop(1).push(i.componentType().asSymbol().arrayType());\n+            case OperatorInstruction i ->\n+                pop(switch (i.opcode()) {\n+                    case ARRAYLENGTH, INEG, LNEG, FNEG, DNEG -> 1;\n+                    default -> 2;\n+                }).push(i.typeKind().upperBound());\n+            case StackInstruction i -> {\n+                switch (i.opcode()) {\n+                    case POP -> pop(1);\n+                    case POP2 -> pop(doubleAt(-1) ? 1 : 2);\n+                    case DUP -> push(top());\n+                    case DUP2 -> {\n+                        if (doubleAt(-1)) {\n+                            push(top());\n+                        } else {\n+                            pushAt(-2, top2());\n+                        }\n+                    }\n+                    case DUP_X1 -> pushAt(-2, top());\n+                    case DUP_X2 -> pushAt(doubleAt(-2) ? -2 : -3, top());\n+                    case DUP2_X1 -> {\n+                        if (doubleAt(-1)) {\n+                            pushAt(-2, top());\n+                        } else {\n+                            pushAt(-3, top2());\n+                        }\n+                    }\n+                    case DUP2_X2 -> {\n+                        if (doubleAt(-1)) {\n+                            pushAt(doubleAt(-2) ? -2 : -3, top());\n+                        } else {\n+                            pushAt(doubleAt(-3) ? -3 : -4, top2());\n+                        }\n+                    }\n+                    case SWAP -> pushAt(-1, pop());\n+                }\n+            }\n+            case TypeCheckInstruction i ->\n+                pop(1).push(i.opcode() == Opcode.CHECKCAST ? i.type().asSymbol() : ConstantDescs.CD_int);\n+            case LabelTarget lt -> {\n+                var frame = stackMap.get(lt.label());\n+                if (frame != null) { \/\/ Here we reached a stack map frame, so we merge actual stack and locals into the frame\n+                    if (!stack.isEmpty() || !locals.isEmpty()) {\n+                        mergeToTargetFrame(lt.label());\n+                        endOfFlow();\n+                    }\n+                    \/\/ Stack and locals are then taken from the frame\n+                    stack.addAll(frame.stack());\n+                    locals.addAll(frame.locals());\n+                }\n+                for (ExceptionCatch ec : exceptionHandlers) {\n+                    if (lt.label() == ec.tryStart()) { \/\/ Entering a try block\n+                        handlersStack.add(ec);\n+                        mergeLocalsToTargetFrame(stackMap.get(ec.handler()));\n+                    }\n+                    if (lt.label() == ec.tryEnd()) { \/\/ Leaving a try block\n+                        handlersStack.remove(ec);\n+                    }\n+                }\n+            }\n+            case ReturnInstruction _ , ThrowInstruction _ -> {\n+                endOfFlow();\n+            }\n+            case TableSwitchInstruction tsi -> {\n+                pop();\n+                mergeToTargetFrame(tsi.defaultTarget());\n+                for (var c : tsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            case LookupSwitchInstruction lsi -> {\n+                pop();\n+                mergeToTargetFrame(lsi.defaultTarget());\n+                for (var c : lsi.cases()) {\n+                    mergeToTargetFrame(c.target());\n+                }\n+                endOfFlow();\n+            }\n+            default -> {}\n+        }\n+    }\n+\n+    private void endOfFlow() {\n+        stack.clear();\n+        locals.clear();\n+    }\n+\n+    \/**\n+     * Merge of the actual {@link #stack} and {@link #locals} to the target stack map frame\n+     * @param target label of the target stack map frame\n+     *\/\n+    private void mergeToTargetFrame(Label target) {\n+        Frame targetFrame = stackMap.get(target);\n+        \/\/ Merge stack\n+        assert stack.size() == targetFrame.stack.size();\n+        for (int i = 0; i < targetFrame.stack.size(); i++) {\n+            ClassDesc se = stack.get(i);\n+            ClassDesc fe = targetFrame.stack.get(i);\n+            if (!se.equals(fe)) {\n+                if (se.isPrimitive() && CD_int.equals(fe)) {\n+                    targetFrame.stack.set(i, se); \/\/ Override int target frame type with more specific int sub-type\n+                    this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n+                } else {\n+                    stack.set(i, fe); \/\/ Override stack type with target frame type\n+                }\n+            }\n+        }\n+        mergeLocalsToTargetFrame(targetFrame);\n+    }\n+\n+\n+    \/**\n+     * Merge of the actual {@link #locals} to the target stack map frame\n+     * @param targetFrame target stack map frame\n+     *\/\n+    private void mergeLocalsToTargetFrame(Frame targetFrame) {\n+        \/\/ Merge locals\n+        int lSize = Math.min(locals.size(), targetFrame.locals.size());\n+        for (int i = 0; i < lSize; i++) {\n+            Segment le = locals.get(i);\n+            Segment fe = targetFrame.locals.get(i);\n+            if (le != null && fe != null) {\n+                le.link(fe); \/\/ Link target frame var with its source\n+                if (!le.type.equals(fe.type)) {\n+                    if (le.type.isPrimitive() && CD_int.equals(fe.type) ) {\n+                        fe.type = le.type; \/\/ Override int target frame type with more specific int sub-type\n+                        this.frameDirty = true; \/\/ This triggers scan loop to run again, as the stack map frame has been adjusted\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/LocalsToVarMapper.java","additions":882,"deletions":0,"binary":false,"changes":882,"status":"added"},{"patch":"@@ -93,0 +93,8 @@\n+    exports java.lang.reflect.code;\n+    exports java.lang.reflect.code.analysis;\n+    exports java.lang.reflect.code.bytecode;\n+    exports java.lang.reflect.code.interpreter;\n+    exports java.lang.reflect.code.op;\n+    exports java.lang.reflect.code.parser;\n+    exports java.lang.reflect.code.type;\n+    exports java.lang.reflect.code.writer;\n@@ -378,0 +386,1 @@\n+    exports java.lang.reflect.code.type.impl;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -1044,0 +1045,16 @@\n+\n+    \/**\n+     * Returns the code model of provided executable element (if any).\n+     * <p>\n+     * If the executable element has a code model then it will be an instance of\n+     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n+     * Note: due to circular dependencies we cannot refer to the type explicitly.\n+     *\n+     * @implSpec The default implementation unconditionally returns an empty optional.\n+     * @param e the executable element.\n+     * @return the code model of the provided executable element (if any).\n+     * @since 99\n+     *\/\n+    default Optional<Object> getBody(ExecutableElement e) {\n+        return Optional.empty();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -212,0 +222,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -215,0 +267,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -253,5 +307,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -312,0 +373,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -315,0 +377,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -329,1 +392,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -338,1 +401,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -356,1 +419,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -360,1 +423,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -370,1 +433,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -393,2 +456,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -422,1 +485,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5325,0 +5401,6 @@\n+\n+    \/\/ code reflection\n+\n+    public boolean isQuoted(Type type) {\n+        return type.tsym == syms.quotedType.tsym;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":96,"deletions":14,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -64,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -446,0 +452,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3139,0 +3158,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3282,0 +3309,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -419,0 +422,7 @@\n+        \/\/add quotable captures\n+        if (isQuotable(tree)) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                syntheticInits.append(capturedArg);\n+            }\n+        }\n+\n@@ -513,0 +523,7 @@\n+        \/\/ add quotable captures\n+        if (isQuotable(tree)) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                indy_args = indy_args.append(capturedArg);\n+            }\n+        }\n+\n@@ -831,0 +848,1 @@\n+        boolean isQuotable = isQuotable(tree);\n@@ -832,1 +850,1 @@\n-                isSerializable || bridges.length() > 1;\n+                isSerializable || isQuotable || bridges.length() > 1;\n@@ -847,0 +865,1 @@\n+                        t.tsym != syms.quotableType.tsym &&\n@@ -853,0 +872,1 @@\n+            flags |= isQuotable ? FLAG_QUOTABLE : 0;\n@@ -875,0 +895,4 @@\n+            if (isQuotable) {\n+                VarSymbol reflectField = (VarSymbol)tree.codeReflectionInfo.quotedField();\n+                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+            }\n@@ -941,0 +965,4 @@\n+    boolean isQuotable(JCFunctionalExpression tree) {\n+        return tree.codeReflectionInfo != null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,2837 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.DeferredAttr.FilterScanner;\n+import com.sun.tools.javac.comp.Lower.FreeVarCollector;\n+import com.sun.tools.javac.jvm.ByteCodes;\n+import com.sun.tools.javac.jvm.Gen;\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCArrayAccess;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression.CodeReflectionInfo;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewArray;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.JCAssert;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n+import jdk.internal.java.lang.reflect.code.*;\n+import jdk.internal.java.lang.reflect.code.op.CoreOp;\n+import jdk.internal.java.lang.reflect.code.op.ExtendedOp;\n+import jdk.internal.java.lang.reflect.code.type.*;\n+import jdk.internal.java.lang.reflect.code.type.WildcardType.BoundKind;\n+\n+import javax.lang.model.element.Modifier;\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.METHOD;\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static com.sun.tools.javac.main.Option.G_CUSTOM;\n+\n+\/**\n+ * This a tree translator that adds the code model to all method declaration marked\n+ * with the {@code CodeReflection} annotation. The model is expressed using the code\n+ * reflection API (see jdk.internal.java.lang.reflect.code).\n+ *\/\n+public class ReflectMethods extends TreeTranslator {\n+    protected static final Context.Key<ReflectMethods> reflectMethodsKey = new Context.Key<>();\n+\n+    public static ReflectMethods instance(Context context) {\n+        ReflectMethods instance = context.get(reflectMethodsKey);\n+        if (instance == null)\n+            instance = new ReflectMethods(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Gen gen;\n+    private final Log log;\n+    private final Lower lower;\n+    private final boolean dumpIR;\n+    private final boolean lineDebugInfo;\n+\n+    \/\/ @@@ Separate out mutable state\n+    private TreeMaker make;\n+    private ListBuffer<JCTree> classOps;\n+    \/\/ Also used by BodyScanner\n+    private Symbol.ClassSymbol currentClassSym;\n+    private int lambdaCount;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ReflectMethods(Context context) {\n+        context.put(reflectMethodsKey, this);\n+        Options options = Options.instance(context);\n+        dumpIR = options.isSet(\"dumpIR\");\n+        lineDebugInfo =\n+                options.isUnset(G_CUSTOM) ||\n+                        options.isSet(G_CUSTOM, \"lines\");\n+        names = Names.instance(context);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        gen = Gen.instance(context);\n+        log = Log.instance(context);\n+        lower = Lower.instance(context);\n+    }\n+\n+    \/\/ Cannot compute within constructor due to circular dependencies on bootstrap compilation\n+    \/\/ syms.objectType == null\n+    private Map<JavaType, Type> primitiveAndBoxTypeMap;\n+    Map<JavaType, Type> primitiveAndBoxTypeMap() {\n+        Map<JavaType, Type> m = primitiveAndBoxTypeMap;\n+        if (m == null) {\n+            m = primitiveAndBoxTypeMap = Map.ofEntries(\n+                    Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                    Map.entry(JavaType.BYTE, syms.byteType),\n+                    Map.entry(JavaType.SHORT, syms.shortType),\n+                    Map.entry(JavaType.CHAR, syms.charType),\n+                    Map.entry(JavaType.INT, syms.intType),\n+                    Map.entry(JavaType.LONG, syms.longType),\n+                    Map.entry(JavaType.FLOAT, syms.floatType),\n+                    Map.entry(JavaType.DOUBLE, syms.doubleType),\n+                    Map.entry(JavaType.J_L_OBJECT, syms.objectType),\n+                    Map.entry(JavaType.J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n+                    Map.entry(JavaType.J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n+                    Map.entry(JavaType.J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n+                    Map.entry(JavaType.J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n+                    Map.entry(JavaType.J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n+                    Map.entry(JavaType.J_L_LONG, types.boxedTypeOrType(syms.longType)),\n+                    Map.entry(JavaType.J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n+                    Map.entry(JavaType.J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n+            );\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (tree.sym.attribute(syms.codeReflectionType.tsym) != null) {\n+            \/\/ if the method is annotated, scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanMethod();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                classOps.add(opFieldDecl(methodName(bodyScanner.symbolToErasedMethodRef(tree.sym)), tree.getModifiers().flags, funcOp));\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the method body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n+            }\n+        }\n+        super.visitMethodDef(tree);\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ListBuffer<JCTree> prevClassOps = classOps;\n+        Symbol.ClassSymbol prevClassSym = currentClassSym;\n+        int prevLambdaCount = lambdaCount;\n+        try {\n+            lambdaCount = 0;\n+            currentClassSym = tree.sym;\n+            classOps = new ListBuffer<>();\n+            super.visitClassDef(tree);\n+            tree.defs = tree.defs.prependList(classOps.toList());\n+        } finally {\n+            lambdaCount = prevLambdaCount;\n+            classOps = prevClassOps;\n+            currentClassSym = prevClassSym;\n+            result = tree;\n+        }\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree, kind);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, null);\n+\n+                switch (kind) {\n+                    case QUOTED_STRUCTURAL -> {\n+                        JCIdent opFieldId = make.Ident(opField.sym);\n+                        ListBuffer<JCExpression> interpreterArgs = new ListBuffer<>();\n+                        JCMethodInvocation parsedOp = make.App(make.Ident(syms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n+                        interpreterArgs.append(parsedOp);\n+                        \/\/ append captured vars\n+                        interpreterArgs.appendList(capturedArgs.toList());\n+\n+                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(syms.opInterpreterInvoke), interpreterArgs.toList());\n+                        interpreterInvoke.varargsElement = syms.objectType;\n+                        super.visitLambda(tree);\n+                        result = interpreterInvoke;\n+                    }\n+                    case QUOTABLE -> {\n+                        \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                        tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                        super.visitLambda(tree);\n+                    }\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitLambda(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        Assert.check(kind != FunctionalExpressionKind.QUOTED_STRUCTURAL,\n+                \"structural quoting not supported for method references\");\n+        MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+        JCVariableDecl recvDecl = memberReferenceToLambda.receiverVar();\n+        JCLambda lambdaTree = memberReferenceToLambda.lambda();\n+\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(lambdaTree, kind);\n+            try {\n+                CoreOp.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, recvDecl);\n+                tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                super.visitReference(tree);\n+                if (recvDecl != null) {\n+                    result = copyReferenceWithReceiverVar(tree, recvDecl);\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+\n+    ListBuffer<JCExpression> quotedCapturedArgs(DiagnosticPosition pos, BodyScanner bodyScanner, JCVariableDecl recvDecl) {\n+        ListBuffer<JCExpression> capturedArgs = new ListBuffer<>();\n+        for (Symbol capturedSym : bodyScanner.stack.localToOp.keySet()) {\n+            if (capturedSym.kind == Kind.TYP) {\n+                \/\/ captured this\n+                capturedArgs.add(make.at(pos).This(capturedSym.type));\n+            } else if (recvDecl != null && capturedSym == recvDecl.sym) {\n+                \/\/ captured method reference receiver\n+                capturedArgs.add(make.at(pos).Ident(recvDecl.sym));\n+            } else if (capturedSym.kind == Kind.VAR) {\n+                \/\/ captured var\n+                VarSymbol var = (VarSymbol)capturedSym;\n+                if (var.getConstValue() == null) {\n+                    capturedArgs.add(make.at(pos).Ident(capturedSym));\n+                } else {\n+                    capturedArgs.add(make.at(pos).Literal(var.getConstValue()));\n+                }\n+            } else {\n+                throw new AssertionError(\"Unexpected captured symbol: \" + capturedSym);\n+            }\n+        }\n+        return capturedArgs;\n+    }\n+\n+    \/*\n+     * Creates a let expression of the kind:\n+     * let $recv in $recv::memberRef\n+     *\n+     * This is required to make sure that LambdaToMethod doesn't end up emitting the\n+     * code for capturing the bound method reference receiver twice.\n+     *\/\n+    JCExpression copyReferenceWithReceiverVar(JCMemberReference ref, JCVariableDecl recvDecl) {\n+        JCMemberReference newRef = make.at(ref).Reference(ref.mode, ref.name, make.Ident(recvDecl.sym), ref.typeargs);\n+        newRef.type = ref.type;\n+        newRef.target = ref.target;\n+        newRef.refPolyKind = ref.refPolyKind;\n+        newRef.referentType = ref.referentType;\n+        newRef.kind = ref.kind;\n+        newRef.varargsElement = ref.varargsElement;\n+        newRef.ownerAccessible = ref.ownerAccessible;\n+        newRef.sym = ref.sym;\n+        newRef.codeReflectionInfo = ref.codeReflectionInfo;\n+        return make.at(ref).LetExpr(recvDecl, newRef).setType(newRef.type);\n+    }\n+\n+    Name lambdaName() {\n+        return names.fromString(\"lambda\").append('$', names.fromString(String.valueOf(lambdaCount++)));\n+    }\n+\n+    Name methodName(MethodRef method) {\n+        char[] sigCh = method.toString().toCharArray();\n+        for (int i = 0; i < sigCh.length; i++) {\n+            switch (sigCh[i]) {\n+                case '.', ';', '[', '\/' -> sigCh[i] = '$';\n+            }\n+        }\n+        return names.fromChars(sigCh, 0, sigCh.length);\n+    }\n+\n+    private JCVariableDecl opFieldDecl(Name prefix, long flags, CoreOp.FuncOp op) {\n+        VarSymbol opFieldSym = new VarSymbol(flags | Flags.STATIC | Flags.FINAL | Flags.SYNTHETIC,\n+                prefix.append('$', names.fromString(\"op\")),\n+                syms.stringType,\n+                currentClassSym);\n+\n+        currentClassSym.members().enter(opFieldSym);\n+        JCLiteral opText = make.Literal(op.toText());\n+        JCVariableDecl opFieldTree = make.VarDef(opFieldSym, opText);\n+        return opFieldTree;\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        \/\/ note that this method does NOT support recursion.\n+        this.make = make;\n+        JCTree res = translate(cdef);\n+        return res;\n+    }\n+\n+    public CoreOp.FuncOp getMethodBody(Symbol.ClassSymbol classSym, JCMethodDecl methodDecl, JCBlock attributedBody, TreeMaker make) {\n+        \/\/ if the method is annotated, scan it\n+        \/\/ Called from JavacElements::getBody\n+        try {\n+            this.make = make;\n+            currentClassSym = classSym;\n+            BodyScanner bodyScanner = new BodyScanner(methodDecl, attributedBody);\n+            return bodyScanner.scanMethod();\n+        } finally {\n+            currentClassSym = null;\n+            this.make = null;\n+        }\n+    }\n+\n+    static class BodyStack {\n+        final BodyStack parent;\n+\n+        \/\/ Tree associated with body\n+        final JCTree tree;\n+\n+        \/\/ Body to add blocks\n+        final Body.Builder body;\n+        \/\/ Current block to add operations\n+        Block.Builder block;\n+\n+        \/\/ Map of symbols (method arguments and local variables) to varOp values\n+        final Map<Symbol, Value> localToOp;\n+\n+        \/\/ Label\n+        Map.Entry<String, Op.Result> label;\n+\n+        BodyStack(BodyStack parent, JCTree tree, FunctionType bodyType) {\n+            this.parent = parent;\n+\n+            this.tree = tree;\n+\n+            this.body = Body.Builder.of(parent != null ? parent.body : null, bodyType);\n+            this.block = body.entryBlock();\n+\n+            this.localToOp = new LinkedHashMap<>(); \/\/ order is important for captured values\n+        }\n+\n+        public void setLabel(String labelName, Op.Result labelValue) {\n+            if (label != null) {\n+                throw new IllegalStateException(\"Label already defined: \" + labelName);\n+            }\n+            label = Map.entry(labelName, labelValue);\n+        }\n+    }\n+\n+    class BodyScanner extends FilterScanner {\n+        private final JCTree body;\n+        private final Name name;\n+        private final BodyStack top;\n+        private BodyStack stack;\n+        private Op lastOp;\n+        private Value result;\n+        private Type pt = Type.noType;\n+        private boolean isQuoted;\n+        private Type bodyTarget;\n+        private JCTree currentNode;\n+        private Map<Symbol, List<Symbol>> localCaptures = new HashMap<>();\n+\n+        \/\/ unsupported tree nodes\n+        private static final EnumSet<JCTree.Tag> UNSUPPORTED_TAGS = EnumSet.of(\n+                \/\/ the nodes below are not as relevant, either because they have already\n+                \/\/ been handled by an earlier compiler pass, or because they are typically\n+                \/\/ not handled directly, but in the context of some enclosing statement.\n+\n+                \/\/ modifiers (these are already turned into symbols by Attr and should not be dealt with directly)\n+                Tag.ANNOTATION, Tag.TYPE_ANNOTATION, Tag.MODIFIERS,\n+                \/\/ toplevel (likely outside the scope for code models)\n+                Tag.TOPLEVEL, Tag.PACKAGEDEF, Tag.IMPORT, Tag.METHODDEF,\n+                \/\/ modules (likely outside the scope for code models)\n+                Tag.MODULEDEF, Tag.EXPORTS, Tag.OPENS, Tag.PROVIDES, Tag.REQUIRES, Tag.USES,\n+                \/\/ classes, ignore local class definitions (allows access to but does not model the definition)\n+                \/\/ Tag.CLASSDEF,\n+                \/\/ switch labels (these are handled by the enclosing construct, SWITCH or SWITCH_EXPRESSION)\n+                Tag.CASE, Tag.DEFAULTCASELABEL, Tag.CONSTANTCASELABEL, Tag.PATTERNCASELABEL,\n+                \/\/ patterns (these are handled by the enclosing construct, like IF, SWITCH_EXPRESSION, TYPETEST)\n+                Tag.ANYPATTERN, Tag.BINDINGPATTERN, Tag.RECORDPATTERN,\n+                \/\/ catch (already handled as part of TRY)\n+                Tag.CATCH,\n+                \/\/ types (these are used to parse types and should not be dealt with directly)\n+                Tag.TYPEAPPLY, Tag.TYPEUNION, Tag.TYPEINTERSECTION, Tag.TYPEPARAMETER, Tag.WILDCARD,\n+                Tag.TYPEBOUNDKIND, Tag.ANNOTATED_TYPE,\n+                \/\/ internal (these are synthetic nodes generated by javac)\n+                Tag.NO_TAG, Tag.ERRONEOUS, Tag.NULLCHK, Tag.LETEXPR);\n+\n+        private static final Set<JCTree.Tag> SUPPORTED_TAGS = EnumSet.complementOf(UNSUPPORTED_TAGS);\n+\n+        BodyScanner(JCMethodDecl tree) {\n+            this(tree, tree.body);\n+        }\n+\n+        BodyScanner(JCMethodDecl tree, JCBlock body) {\n+            super(SUPPORTED_TAGS);\n+\n+            this.currentNode = tree;\n+            this.body = body;\n+            this.name = tree.name;\n+            this.isQuoted = false;\n+\n+            List<TypeElement> parameters = new ArrayList<>();\n+            int blockArgOffset = 0;\n+            \/\/ Instance methods model \"this\" as an additional argument occurring\n+            \/\/ before all other arguments.\n+            \/\/ @@@ Inner classes.\n+            \/\/ We need to capture all \"this\", in nested order, as arguments.\n+            if (!tree.getModifiers().getFlags().contains(Modifier.STATIC)) {\n+                parameters.add(typeToTypeElement(tree.sym.owner.type));\n+                blockArgOffset++;\n+            }\n+            tree.sym.type.getParameterTypes().stream().map(this::typeToTypeElement).forEach(parameters::add);\n+\n+            FunctionType bodyType = FunctionType.functionType(\n+                    typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, bodyType);\n+\n+            \/\/ @@@ this as local variable? (it can never be stored to)\n+            for (int i = 0 ; i < tree.params.size() ; i++) {\n+                Op.Result paramOp = append(CoreOp.var(\n+                        tree.params.get(i).name.toString(),\n+                        top.block.parameters().get(blockArgOffset + i)));\n+                top.localToOp.put(tree.params.get(i).sym, paramOp);\n+            }\n+\n+            bodyTarget = tree.sym.type.getReturnType();\n+        }\n+\n+        BodyScanner(JCLambda tree, FunctionalExpressionKind kind) {\n+            super(SUPPORTED_TAGS);\n+            assert kind != FunctionalExpressionKind.NOT_QUOTED;\n+\n+            this.currentNode = tree;\n+            this.body = tree;\n+            this.name = names.fromString(\"quotedLambda\");\n+            this.isQuoted = true;\n+\n+            com.sun.tools.javac.util.List<Type> nil = com.sun.tools.javac.util.List.nil();\n+            MethodType mtype = new MethodType(nil, syms.quotedType, nil, syms.methodClass);\n+            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+                    mtype.getParameterTypes().map(this::typeToTypeElement));\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+\n+            bodyTarget = tree.target.getReturnType();\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            JCTree prev = currentNode;\n+            currentNode = tree;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                currentNode = prev;\n+            }\n+        }\n+\n+        void pushBody(JCTree tree, FunctionType bodyType) {\n+            stack = new BodyStack(stack, tree, bodyType);\n+            lastOp = null; \/\/ reset\n+        }\n+\n+        void popBody() {\n+            stack = stack.parent;\n+        }\n+\n+        Value varOpValue(Symbol sym) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                Value v = s.localToOp.get(sym);\n+                if (v != null) {\n+                    return v;\n+                }\n+                s = s.parent;\n+            }\n+            if (isQuoted) {\n+                return capturedOpValue(sym);\n+            } else {\n+                throw new NoSuchElementException(sym.toString());\n+            }\n+        }\n+\n+        Value capturedOpValue(Symbol sym) {\n+            var capturedVar = top.localToOp.get(sym);\n+            if (capturedVar == null) {\n+                var capturedArg = top.block.parameter(typeToTypeElement(sym.type));\n+                capturedVar = top.block.op(CoreOp.var(sym.name.toString(), capturedArg));\n+                top.localToOp.put(sym, capturedVar);\n+            }\n+            return capturedVar;\n+        }\n+\n+        Value thisValue() { \/\/ @@@: outer this?\n+            if (isQuoted) {\n+                \/\/ capture this - add captured class symbol to the stack top local mappings\n+                var capturedThis = top.localToOp.get(currentClassSym);\n+                if (capturedThis == null) {\n+                    capturedThis = top.block.parameter(typeToTypeElement(currentClassSym.type));\n+                    top.localToOp.put(currentClassSym, capturedThis);\n+                }\n+                return capturedThis;\n+            } else {\n+                return top.block.parameters().get(0);\n+            }\n+        }\n+\n+        Value getLabel(String labelName) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                if (s.label != null && s.label.getKey().equals(labelName)) {\n+                    return s.label.getValue();\n+                }\n+                s = s.parent;\n+            }\n+            throw new NoSuchElementException(labelName);\n+        }\n+\n+        private Op.Result append(Op op) {\n+            return append(op, generateLocation(currentNode, false), stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l) {\n+            return append(op, l, stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l, BodyStack stack) {\n+            lastOp = op;\n+            op.setLocation(l);\n+            return stack.block.apply(op);\n+        }\n+\n+        Location generateLocation(JCTree node, boolean includeSourceReference) {\n+            if (!lineDebugInfo) {\n+                return Location.NO_LOCATION;\n+            }\n+\n+            int pos = node.getStartPosition();\n+            int line = log.currentSource().getLineNumber(pos);\n+            int col = log.currentSource().getColumnNumber(pos, false);\n+            String path;\n+            if (includeSourceReference) {\n+                path = log.currentSource().getFile().toUri().toString();\n+            } else {\n+                path = null;\n+            }\n+            return new Location(path, line, col);\n+        }\n+\n+        private <O extends Op & Op.Terminating> void appendTerminating(Supplier<O> sop) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                append(sop.get());\n+            }\n+        }\n+\n+        public Value toValue(JCExpression expression, Type targetType) {\n+            result = null; \/\/ reset\n+            Type prevPt = pt;\n+            try {\n+                pt = targetType;\n+                scan(expression);\n+                return result != null ?\n+                        coerce(result, expression.type, targetType) :\n+                        null;\n+            } finally {\n+                pt = prevPt;\n+            }\n+        }\n+\n+        public Value toValue(JCExpression expression) {\n+            return toValue(expression, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree.JCStatement statement) {\n+            result = null; \/\/ reset\n+            scan(statement);\n+            return result;\n+        }\n+\n+        Value coerce(Value sourceValue, Type sourceType, Type targetType) {\n+            if (sourceType.isReference() && targetType.isReference() &&\n+                    !types.isSubtype(types.erasure(sourceType), types.erasure(targetType))) {\n+                return append(CoreOp.cast(typeToTypeElement(targetType), sourceValue));\n+            } else {\n+                return convert(sourceValue, targetType);\n+            }\n+        }\n+\n+        Value boxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.boxedTypeOrType(source));\n+        }\n+\n+        Value unboxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.unboxedTypeOrType(source));\n+        }\n+\n+        Value convert(Value exprVal, Type target) {\n+            Type source = typeElementToType(exprVal.type());\n+            boolean sourcePrimitive = source.isPrimitive();\n+            boolean targetPrimitive = target.isPrimitive();\n+            if (target.hasTag(NONE)) {\n+                return exprVal;\n+            } else if (sourcePrimitive == targetPrimitive) {\n+                if (!sourcePrimitive || types.isSameType(source, target)) {\n+                    return exprVal;\n+                } else {\n+                    \/\/ implicit primitive conversion\n+                    return append(CoreOp.conv(typeToTypeElement(target), exprVal));\n+                }\n+            } else if (sourcePrimitive) {\n+                \/\/ we need to box\n+                Type unboxedTarget = types.unboxedType(target);\n+                if (!unboxedTarget.hasTag(NONE)) {\n+                    \/\/ non-Object target\n+                    if (!types.isConvertible(source, unboxedTarget)) {\n+                        exprVal = convert(exprVal, unboxedTarget);\n+                    }\n+                    return box(exprVal, target);\n+                } else {\n+                    \/\/ Object target\n+                    return box(exprVal, types.boxedClass(source).type);\n+                }\n+            } else {\n+                \/\/ we need to unbox\n+                return unbox(exprVal, source, target, types.unboxedType(source));\n+            }\n+        }\n+\n+        Value box(Value valueExpr, Type box) {\n+            \/\/ Boxing is a static method e.g., java.lang.Integer::valueOf(int)java.lang.Integer\n+            MethodRef boxMethod = MethodRef.method(typeToTypeElement(box), names.valueOf.toString(),\n+                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+            return append(CoreOp.invoke(boxMethod, valueExpr));\n+        }\n+\n+        Value unbox(Value valueExpr, Type box, Type primitive, Type unboxedType) {\n+            if (unboxedType.hasTag(NONE)) {\n+                \/\/ Object target, first downcast to correct wrapper type\n+                unboxedType = primitive;\n+                box = types.boxedClass(unboxedType).type;\n+                valueExpr = append(CoreOp.cast(typeToTypeElement(box), valueExpr));\n+            }\n+            \/\/ Unboxing is a virtual method e.g., java.lang.Integer::intValue()int\n+            MethodRef unboxMethod = MethodRef.method(typeToTypeElement(box),\n+                    unboxedType.tsym.name.append(names.Value).toString(),\n+                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+            return append(CoreOp.invoke(unboxMethod, valueExpr));\n+        }\n+\n+        @Override\n+        void skip(JCTree tree) {\n+            \/\/ this method is called for unsupported AST nodes (see 'SUPPORTED_TAGS')\n+            throw unsupported(tree);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            Value initOp;\n+            if (tree.init != null) {\n+                initOp = toValue(tree.init, tree.type);\n+            } else {\n+                initOp = append(defaultValue(tree.type));\n+            }\n+            result = append(CoreOp.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n+            stack.localToOp.put(tree.sym, result);\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            \/\/ Consume top node that applies to write access\n+            JCTree lhs = TreeInfo.skipParens(tree.lhs);\n+            Type target = tree.lhs.type;\n+            switch (lhs.getTag()) {\n+                case IDENT: {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+                            append(CoreOp.varStore(varOp, result));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fd = symbolToFieldRef(sym, symbolSiteType(sym));\n+                            if (sym.isStatic()) {\n+                                append(CoreOp.fieldStore(fd, result));\n+                            } else {\n+                                append(CoreOp.fieldStore(fd, thisValue(), result));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(tree);\n+                        }\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+                    if (sym.isStatic()) {\n+                        append(CoreOp.fieldStore(fr, result));\n+                    } else {\n+                        append(CoreOp.fieldStore(fr, receiver, result));\n+                    }\n+                    break;\n+                }\n+                case INDEXED: {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    append(CoreOp.arrayStoreOp(array, index, result));\n+                    break;\n+                }\n+                default:\n+                    throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssignop(JCTree.JCAssignOp tree) {\n+            \/\/ Capture applying rhs and operation\n+            Function<Value, Value> scanRhs = (lhs) -> {\n+                Type unboxedType = types.unboxedTypeOrType(tree.type);\n+                Value rhs;\n+                if (tree.operator.opcode == ByteCodes.string_add && tree.rhs.type.isPrimitive()) {\n+                    rhs = toValue(tree.rhs);\n+                } else {\n+                    rhs = toValue(tree.rhs, unboxedType);\n+                }\n+                lhs = unboxIfNeeded(lhs);\n+\n+                Value assignOpResult = switch (tree.getTag()) {\n+\n+                    \/\/ Arithmetic operations\n+                    case PLUS_ASG -> {\n+                        if (tree.operator.opcode == ByteCodes.string_add) {\n+                            yield append(CoreOp.concat(lhs, rhs));\n+                        } else {\n+                            yield append(CoreOp.add(lhs, rhs));\n+                        }\n+                    }\n+                    case MINUS_ASG -> append(CoreOp.sub(lhs, rhs));\n+                    case MUL_ASG -> append(CoreOp.mul(lhs, rhs));\n+                    case DIV_ASG -> append(CoreOp.div(lhs, rhs));\n+                    case MOD_ASG -> append(CoreOp.mod(lhs, rhs));\n+\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR_ASG -> append(CoreOp.or(lhs, rhs));\n+                    case BITAND_ASG -> append(CoreOp.and(lhs, rhs));\n+                    case BITXOR_ASG -> append(CoreOp.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL_ASG -> append(CoreOp.lshl(lhs, rhs));\n+                    case SR_ASG -> append(CoreOp.ashr(lhs, rhs));\n+                    case USR_ASG -> append(CoreOp.lshr(lhs, rhs));\n+\n+\n+                    default -> throw unsupported(tree);\n+                };\n+                return result = convert(assignOpResult, tree.type);\n+            };\n+\n+            applyCompoundAssign(tree.lhs, scanRhs);\n+        }\n+\n+        void applyCompoundAssign(JCTree.JCExpression lhs, Function<Value, Value> scanRhs) {\n+            \/\/ Consume top node that applies to access\n+            lhs = TreeInfo.skipParens(lhs);\n+            switch (lhs.getTag()) {\n+                case IDENT -> {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+\n+                            Op.Result lhsOpValue = append(CoreOp.varLoad(varOp));\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            append(CoreOp.varStore(varOp, r));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+\n+                            Op.Result lhsOpValue;\n+                            TypeElement resultType = typeToTypeElement(sym.type);\n+                            if (sym.isStatic()) {\n+                                lhsOpValue = append(CoreOp.fieldLoad(resultType, fr));\n+                            } else {\n+                                lhsOpValue = append(CoreOp.fieldLoad(resultType, fr, thisValue()));\n+                            }\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            if (sym.isStatic()) {\n+                                append(CoreOp.fieldStore(fr, r));\n+                            } else {\n+                                append(CoreOp.fieldStore(fr, thisValue(), r));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(lhs);\n+                        }\n+                    }\n+                }\n+                case SELECT -> {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+\n+                    Op.Result lhsOpValue;\n+                    TypeElement resultType = typeToTypeElement(sym.type);\n+                    if (sym.isStatic()) {\n+                        lhsOpValue = append(CoreOp.fieldLoad(resultType, fr));\n+                    } else {\n+                        lhsOpValue = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                    }\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    if (sym.isStatic()) {\n+                        append(CoreOp.fieldStore(fr, r));\n+                    } else {\n+                        append(CoreOp.fieldStore(fr, receiver, r));\n+                    }\n+                }\n+                case INDEXED -> {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    Op.Result lhsOpValue = append(CoreOp.arrayLoadOp(array, index));\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    append(CoreOp.arrayStoreOp(array, index, r));\n+                }\n+                default -> throw unsupported(lhs);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            \/\/ Visited only for read access\n+\n+            Symbol sym = tree.sym;\n+            switch (sym.getKind()) {\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER ->\n+                    result = loadVar(sym);\n+                case FIELD, ENUM_CONSTANT -> {\n+                    if (sym.name.equals(names._this) || sym.name.equals(names._super)) {\n+                        result = thisValue();\n+                    } else {\n+                        FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+                        TypeElement resultType = typeToTypeElement(sym.type);\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOp.fieldLoad(resultType, fr));\n+                        } else {\n+                            result = append(CoreOp.fieldLoad(resultType, fr, thisValue()));\n+                        }\n+                    }\n+                }\n+                case INTERFACE, CLASS, ENUM -> {\n+                    result = null;\n+                }\n+                default -> {\n+                    \/\/ @@@ Cannot reach here?\n+                    throw unsupported(tree);\n+                }\n+            }\n+        }\n+\n+        private Value loadVar(Symbol sym) {\n+            Value varOp = varOpValue(sym);\n+            return varOp.type() instanceof VarType ?\n+                    append(CoreOp.varLoad(varOp)) : \/\/ regular var\n+                    varOp;                          \/\/ captured value\n+        }\n+\n+        @Override\n+        public void visitTypeIdent(JCTree.JCPrimitiveTypeTree tree) {\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitTypeArray(JCTree.JCArrayTypeTree tree) {\n+            result = null; \/\/ MyType[].class is handled in visitSelect just as MyType.class\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Type qualifierTarget = qualifierTarget(tree);\n+            \/\/ @@@: might cause redundant load if accessed symbol is static but the qualifier is not a type\n+            Value receiver = toValue(tree.selected);\n+\n+            if (tree.name.equals(names._class)) {\n+                result = append(CoreOp.constant(JavaType.J_L_CLASS, typeToTypeElement(tree.selected.type)));\n+            } else if (types.isArray(tree.selected.type)) {\n+                if (tree.sym.equals(syms.lengthVar)) {\n+                    result = append(CoreOp.arrayLength(receiver));\n+                } else {\n+                    \/\/ Should not reach here\n+                    throw unsupported(tree);\n+                }\n+            } else {\n+                Symbol sym = tree.sym;\n+                switch (sym.getKind()) {\n+                    case FIELD, ENUM_CONSTANT -> {\n+                        if (sym.name.equals(names._this) || sym.name.equals(names._super)) {\n+                            result = thisValue();\n+                        } else {\n+                            FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n+                                    tree.selected.type : qualifierTarget);\n+                            TypeElement resultType = typeToTypeElement(types.memberType(tree.selected.type, sym));\n+                            if (sym.isStatic()) {\n+                                result = append(CoreOp.fieldLoad(resultType, fr));\n+                            } else {\n+                                result = append(CoreOp.fieldLoad(resultType, fr, receiver));\n+                            }\n+                        }\n+                    }\n+                    case INTERFACE, CLASS, ENUM -> {\n+                        result = null;\n+                    }\n+                    default -> {\n+                        \/\/ @@@ Cannot reach here?\n+                        throw unsupported(tree);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitIndexed(JCArrayAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Value array = toValue(tree.indexed);\n+\n+            Value index = toValue(tree.index, typeElementToType(JavaType.INT));\n+\n+            result = append(CoreOp.arrayLoadOp(array, index));\n+        }\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            \/\/ @@@ Symbol.externalType, for use with inner classes\n+\n+            \/\/ @@@ this.xyz(...) calls in a constructor\n+\n+            JCTree meth = TreeInfo.skipParens(tree.meth);\n+            switch (meth.getTag()) {\n+                case IDENT: {\n+                    JCIdent access = (JCIdent) meth;\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    CoreOp.InvokeOp.InvokeKind ik;\n+                    if (!sym.isStatic()) {\n+                        ik = CoreOp.InvokeOp.InvokeKind.INSTANCE;\n+                        args.add(thisValue());\n+                    } else {\n+                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, symbolSiteType(sym));\n+                    Value res = append(CoreOp.invoke(ik, tree.varargsElement != null,\n+                            typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess access = (JCFieldAccess) meth;\n+\n+                    Type qualifierTarget = qualifierTarget(access);\n+                    Value receiver = toValue(access.selected, qualifierTarget);\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    CoreOp.InvokeOp.InvokeKind ik;\n+                    if (!sym.isStatic()) {\n+                        args.add(receiver);\n+                        \/\/ @@@ expr.super(...) for inner class super constructor calls\n+                        ik = switch (access.selected) {\n+                            case JCIdent i when i.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n+                            case JCFieldAccess fa when fa.sym.name.equals(names._super) -> CoreOp.InvokeOp.InvokeKind.SUPER;\n+                            default -> CoreOp.InvokeOp.InvokeKind.INSTANCE;\n+                        };\n+                    } else {\n+                        ik = CoreOp.InvokeOp.InvokeKind.STATIC;\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n+                            access.selected.type : qualifierTarget);\n+                    JavaType returnType = typeToTypeElement(meth.type.getReturnType());\n+                    CoreOp.InvokeOp iop = CoreOp.invoke(ik, tree.varargsElement != null,\n+                            returnType, mr, args);\n+                    Value res = append(iop);\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                default:\n+                    unsupported(meth);\n+            }\n+        }\n+\n+        List<Value> scanMethodArguments(List<JCExpression> args, Type methodType, Type varargsElement) {\n+            ListBuffer<Value> argValues = new ListBuffer<>();\n+            com.sun.tools.javac.util.List<Type> targetTypes = methodType.getParameterTypes();\n+            if (varargsElement != null) {\n+                targetTypes = targetTypes.reverse().tail;\n+                for (int i = 0 ; i < args.size() - (methodType.getParameterTypes().size() - 1) ; i++) {\n+                    targetTypes = targetTypes.prepend(varargsElement);\n+                }\n+                targetTypes = targetTypes.reverse();\n+            }\n+\n+            for (JCTree.JCExpression arg : args) {\n+                argValues.add(toValue(arg, targetTypes.head));\n+                targetTypes = targetTypes.tail;\n+            }\n+            return argValues.toList();\n+        }\n+\n+        @Override\n+        public void visitReference(JCTree.JCMemberReference tree) {\n+            MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+            JCVariableDecl recv = memberReferenceToLambda.receiverVar();\n+            if (recv != null) {\n+                scan(recv);\n+            }\n+            scan(memberReferenceToLambda.lambda());\n+        }\n+\n+        Type qualifierTarget(JCFieldAccess tree) {\n+            Type selectedType = types.skipTypeVars(tree.selected.type, true);\n+            return selectedType.isCompound() ?\n+                    tree.sym.owner.type :\n+                    Type.noType;\n+        }\n+\n+        @Override\n+        public void visitTypeCast(JCTree.JCTypeCast tree) {\n+            Value v = toValue(tree.expr);\n+\n+            Type expressionType = tree.expr.type;\n+            Type type = tree.type;\n+            if (expressionType.isPrimitive() && type.isPrimitive()) {\n+                if (expressionType.equals(type)) {\n+                    \/\/ Redundant cast\n+                    result = v;\n+                } else {\n+                    result = append(CoreOp.conv(typeToTypeElement(type), v));\n+                }\n+            } else if (expressionType.isPrimitive() || type.isPrimitive()) {\n+                result = convert(v, tree.type);\n+            } else if (!expressionType.hasTag(BOT) &&\n+                    types.isAssignable(expressionType, type)) {\n+                \/\/ Redundant cast\n+                result = v;\n+            } else {\n+                \/\/ Reference cast\n+                JavaType jt = typeToTypeElement(types.erasure(type));\n+                result = append(CoreOp.cast(typeToTypeElement(type), jt, v));\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeTest(JCTree.JCInstanceOf tree) {\n+            Value target = toValue(tree.expr);\n+\n+            if (tree.pattern.getTag() != Tag.IDENT) {\n+                result = scanPattern(tree.getPattern(), target);\n+            } else {\n+                result = append(CoreOp.instanceOf(typeToTypeElement(tree.pattern.type), target));\n+            }\n+        }\n+\n+        Value scanPattern(JCTree.JCPattern pattern, Value target) {\n+            \/\/ Type of pattern\n+            JavaType patternType;\n+            if (pattern instanceof JCTree.JCBindingPattern p) {\n+                patternType = ExtendedOp.Pattern.bindingType(typeToTypeElement(p.type));\n+            } else if (pattern instanceof JCTree.JCRecordPattern p) {\n+                patternType = ExtendedOp.Pattern.recordType(typeToTypeElement(p.record.type));\n+            } else {\n+                throw unsupported(pattern);\n+            }\n+\n+            \/\/ Push pattern body\n+            pushBody(pattern, FunctionType.functionType(patternType));\n+\n+            \/\/ @@@ Assumes just pattern nodes, likely will change when method patterns are supported\n+            \/\/     that have expressions for any arguments (which perhaps in turn may have pattern expressions)\n+            List<JCVariableDecl> variables = new ArrayList<>();\n+            class PatternScanner extends FilterScanner {\n+\n+                private Value result;\n+\n+                public PatternScanner() {\n+                    super(Set.of(Tag.BINDINGPATTERN, Tag.RECORDPATTERN, Tag.ANYPATTERN));\n+                }\n+\n+                @Override\n+                public void visitBindingPattern(JCTree.JCBindingPattern binding) {\n+                    JCVariableDecl var = binding.var;\n+                    variables.add(var);\n+                    boolean unnamedPatternVariable = var.name.isEmpty();\n+                    String bindingName = unnamedPatternVariable ? null : var.name.toString();\n+                    result = append(ExtendedOp.typePattern(typeToTypeElement(var.type), bindingName));\n+                }\n+\n+                @Override\n+                public void visitRecordPattern(JCTree.JCRecordPattern record) {\n+                    \/\/ @@@ Is always Identifier to record?\n+                    \/\/ scan(record.deconstructor);\n+\n+                    List<Value> nestedValues = new ArrayList<>();\n+                    for (JCTree.JCPattern jcPattern : record.nested) {\n+                        \/\/ @@@ when we support ANYPATTERN, we must add result of toValue only if it's non-null\n+                        \/\/ because passing null to recordPattern methods will cause an error\n+                        nestedValues.add(toValue(jcPattern));\n+                    }\n+\n+                    result = append(ExtendedOp.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n+                }\n+\n+                @Override\n+                public void visitAnyPattern(JCTree.JCAnyPattern anyPattern) {\n+                    result = append(ExtendedOp.matchAllPattern());\n+                }\n+\n+                Value toValue(JCTree tree) {\n+                    result = null;\n+                    scan(tree);\n+                    return result;\n+                }\n+            }\n+            \/\/ Scan pattern\n+            Value patternValue = new PatternScanner().toValue(pattern);\n+            append(CoreOp._yield(patternValue));\n+            Body.Builder patternBody = stack.body;\n+\n+            \/\/ Pop body\n+            popBody();\n+\n+            \/\/ Find nearest ancestor body stack element associated with a statement tree\n+            \/\/ @@@ Strengthen check of tree?\n+            BodyStack _variablesStack = stack;\n+            while (!(_variablesStack.tree instanceof JCTree.JCStatement)) {\n+                _variablesStack = _variablesStack.parent;\n+            }\n+            BodyStack variablesStack = _variablesStack;\n+\n+            \/\/ Create pattern var ops for pattern variables using the\n+            \/\/ builder associated with the nearest statement tree\n+            for (JCVariableDecl jcVar : variables) {\n+                Value init = variablesStack.block.op(defaultValue(jcVar.type));\n+                Op.Result op = variablesStack.block.op(CoreOp.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n+                variablesStack.localToOp.put(jcVar.sym, op);\n+            }\n+\n+            \/\/ Create pattern descriptor\n+            List<JavaType> patternDescParams = variables.stream().map(var -> typeToTypeElement(var.type)).toList();\n+            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+\n+            \/\/ Create the match body, assigning pattern values to pattern variables\n+            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), matchFuncType);\n+            Block.Builder matchBuilder = matchBody.entryBlock();\n+            for (int i = 0; i < variables.size(); i++) {\n+                Value v = matchBuilder.parameters().get(i);\n+                Value var = variablesStack.localToOp.get(variables.get(i).sym);\n+                matchBuilder.op(CoreOp.varStore(var, v));\n+            }\n+            matchBuilder.op(CoreOp._yield());\n+\n+            \/\/ Create the match operation\n+            return append(ExtendedOp.match(target, patternBody, matchBody));\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCTree.JCNewClass tree) {\n+            if (tree.def != null) {\n+                scan(tree.def);\n+            }\n+\n+            \/\/ @@@ Support local classes in pre-construction contexts\n+            if (tree.type.tsym.isDirectlyOrIndirectlyLocal() && (tree.type.tsym.flags() & NOOUTERTHIS) != 0) {\n+                throw unsupported(tree);\n+            }\n+\n+            List<TypeElement> argtypes = new ArrayList<>();\n+            Type type = tree.type;\n+            Type outer = type.getEnclosingType();\n+            List<Value> args = new ArrayList<>();\n+            if (!outer.hasTag(TypeTag.NONE)) {\n+                \/\/ Obtain outer value for inner class, and add as first argument\n+                JCTree.JCExpression encl = tree.encl;\n+                Value outerInstance;\n+                if (encl == null) {\n+                    outerInstance = thisValue();\n+                } else {\n+                    outerInstance = toValue(tree.encl);\n+                }\n+                args.add(outerInstance);\n+                argtypes.add(outerInstance.type());\n+            }\n+            if (tree.type.tsym.isDirectlyOrIndirectlyLocal()) {\n+                for (Symbol c : localCaptures.get(tree.type.tsym)) {\n+                    args.add(loadVar(c));\n+                    argtypes.add(symbolToErasedDesc(c));\n+                }\n+            }\n+\n+            \/\/ Create erased method type reference for constructor, where\n+            \/\/ the return type declares the class to instantiate\n+            \/\/ @@@ require symbol site type?\n+            MethodRef methodRef = symbolToErasedMethodRef(tree.constructor);\n+            argtypes.addAll(methodRef.type().parameterTypes());\n+            FunctionType constructorType = FunctionType.functionType(\n+                    symbolToErasedDesc(tree.constructor.owner),\n+                    argtypes);\n+\n+            args.addAll(scanMethodArguments(tree.args, tree.constructorType, tree.varargsElement));\n+\n+            result = append(CoreOp._new(typeToTypeElement(type), constructorType, args));\n+        }\n+\n+        @Override\n+        public void visitNewArray(JCTree.JCNewArray tree) {\n+            if (tree.elems != null) {\n+                int length = tree.elems.size();\n+                Op.Result a = append(CoreOp.newArray(\n+                        typeToTypeElement(tree.type),\n+                        append(CoreOp.constant(JavaType.INT, length))));\n+                int i = 0;\n+                for (JCExpression elem : tree.elems) {\n+                    Value element = toValue(elem, types.elemtype(tree.type));\n+                    append(CoreOp.arrayStoreOp(\n+                            a,\n+                            append(CoreOp.constant(JavaType.INT, i)),\n+                            element));\n+                    i++;\n+                }\n+\n+                result = a;\n+            } else {\n+                List<Value> indexes = new ArrayList<>();\n+                for (JCTree.JCExpression dim : tree.dims) {\n+                    indexes.add(toValue(dim));\n+                }\n+\n+                JavaType arrayType = typeToTypeElement(tree.type);\n+                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                        indexes.stream().map(Value::type).toList());\n+                result = append(CoreOp._new(arrayType, constructorType, indexes));\n+            }\n+        }\n+\n+        @Override\n+        public void visitLambda(JCTree.JCLambda tree) {\n+            FunctionalExpressionKind kind = functionalKind(tree);\n+            final FunctionType lambdaType = switch (kind) {\n+                case QUOTED_STRUCTURAL -> typeToFunctionType(tree.target);\n+                default -> typeToFunctionType(types.findDescriptorType(tree.target));\n+            };\n+\n+            \/\/ Push quoted body\n+            \/\/ We can either be explicitly quoted or a structural quoted expression\n+            \/\/ within some larger reflected code\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                pushBody(tree.body, FunctionType.VOID);\n+            }\n+\n+            \/\/ Push lambda body\n+            pushBody(tree.body, lambdaType);\n+\n+            \/\/ Map lambda parameters to varOp values\n+            for (int i = 0; i < tree.params.size(); i++) {\n+                JCVariableDecl p = tree.params.get(i);\n+                Op.Result paramOp = append(CoreOp.var(\n+                        p.name.toString(),\n+                        stack.block.parameters().get(i)));\n+                stack.localToOp.put(p.sym, paramOp);\n+            }\n+\n+            \/\/ Scan the lambda body\n+            if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION) {\n+                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n+                if (!tree.body.type.hasTag(TypeTag.VOID)) {\n+                    append(CoreOp._return(exprVal));\n+                } else {\n+                    appendTerminating(CoreOp::_return);\n+                }\n+            } else {\n+                Type prevBodyTarget = bodyTarget;\n+                try {\n+                    bodyTarget = tree.getDescriptorType(types).getReturnType();\n+                    toValue(((JCTree.JCStatement) tree.body));\n+                    \/\/ @@@ Check if unreachable\n+                    appendTerminating(CoreOp::_return);\n+                } finally {\n+                    bodyTarget = prevBodyTarget;\n+                }\n+            }\n+\n+            Op lambdaOp = switch (kind) {\n+                case QUOTED_STRUCTURAL -> {\n+                    yield CoreOp.closure(stack.body);\n+                }\n+                case QUOTABLE, NOT_QUOTED -> {\n+                    \/\/ Get the functional interface type\n+                    JavaType fiType = typeToTypeElement(tree.target);\n+                    \/\/ build functional lambda\n+                    yield CoreOp.lambda(fiType, stack.body);\n+                }\n+            };\n+\n+            \/\/ Pop lambda body\n+            popBody();\n+\n+            Value lambdaResult;\n+            if (isQuoted) {\n+                lambdaResult = append(lambdaOp, generateLocation(tree, true));\n+            } else {\n+                lambdaResult = append(lambdaOp);\n+            }\n+\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                append(CoreOp._yield(lambdaResult));\n+                CoreOp.QuotedOp quotedOp = CoreOp.quoted(stack.body);\n+\n+                \/\/ Pop quoted body\n+                popBody();\n+\n+                lambdaResult = append(quotedOp);\n+            }\n+\n+            result = lambdaResult;\n+        }\n+\n+        @Override\n+        public void visitIf(JCTree.JCIf tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            while (tree != null) {\n+                JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+                \/\/ Push if condition\n+                pushBody(cond,\n+                        FunctionType.functionType(JavaType.BOOLEAN));\n+                Value last = toValue(cond);\n+                last = convert(last, typeElementToType(JavaType.BOOLEAN));\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(last));\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if condition\n+                popBody();\n+\n+                \/\/ Push if body\n+                pushBody(tree.thenpart, FunctionType.VOID);\n+\n+                scan(tree.thenpart);\n+                appendTerminating(CoreOp::_yield);\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if body\n+                popBody();\n+\n+                JCTree.JCStatement elsepart = tree.elsepart;\n+                if (elsepart == null) {\n+                    tree = null;\n+                } else if (elsepart.getTag() == Tag.IF) {\n+                    tree = (JCTree.JCIf) elsepart;\n+                } else {\n+                    \/\/ Push else body\n+                    pushBody(elsepart, FunctionType.VOID);\n+\n+                    scan(elsepart);\n+                    appendTerminating(CoreOp::_yield);\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop else body\n+                    popBody();\n+\n+                    tree = null;\n+                }\n+            }\n+\n+            append(ExtendedOp._if(bodies));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSwitchExpression(JCTree.JCSwitchExpression tree) {\n+\n+            Value target = toValue(tree.selector);\n+\n+            Type switchType = adaptBottom(tree.type);\n+            FunctionType caseBodyType = FunctionType.functionType(typeToTypeElement(switchType));\n+\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, tree.selector, target, tree.cases, caseBodyType,\n+                    !tree.hasUnconditionalPattern);\n+\n+            result = append(ExtendedOp.switchExpression(caseBodyType.returnType(), target, bodies));\n+        }\n+\n+        @Override\n+        public void visitSwitch(JCTree.JCSwitch tree) {\n+\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType actionType = FunctionType.VOID;\n+\n+            List<Body.Builder> bodies = visitSwitchStatAndExpr(tree, tree.selector, target, tree.cases, actionType,\n+                    tree.patternSwitch && !tree.hasUnconditionalPattern);\n+\n+            result = append(ExtendedOp.switchStatement(target, bodies));\n+        }\n+\n+        private List<Body.Builder> visitSwitchStatAndExpr(JCTree tree, JCExpression selector, Value target,\n+                                                          List<JCTree.JCCase> cases, FunctionType caseBodyType,\n+                                                          boolean isDefaultCaseNeeded) {\n+\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            Body.Builder defaultLabel = null;\n+            Body.Builder defaultBody = null;\n+\n+            for (JCTree.JCCase c : cases) {\n+\n+                Body.Builder caseLabel = visitCaseLabel(tree, selector, target, c);\n+                Body.Builder caseBody = visitCaseBody(tree, c, caseBodyType);\n+\n+                if (c.labels.head instanceof JCTree.JCDefaultCaseLabel) {\n+                    defaultLabel = caseLabel;\n+                    defaultBody = caseBody;\n+                } else {\n+                    bodies.add(caseLabel);\n+                    bodies.add(caseBody);\n+                }\n+            }\n+\n+            if (defaultLabel != null) {\n+                bodies.add(defaultLabel);\n+                bodies.add(defaultBody);\n+            } else if (isDefaultCaseNeeded) {\n+                \/\/ label\n+                pushBody(tree, FunctionType.functionType(JavaType.BOOLEAN));\n+                append(CoreOp._yield(append(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                bodies.add(stack.body);\n+                popBody();\n+\n+                \/\/ body\n+                pushBody(tree, caseBodyType);\n+                append(CoreOp._throw(\n+                        append(CoreOp._new(FunctionType.functionType(JavaType.type(MatchException.class))))\n+                ));\n+                bodies.add(stack.body);\n+                popBody();\n+            }\n+\n+            return bodies;\n+        }\n+\n+        private Body.Builder visitCaseLabel(JCTree tree, JCExpression selector, Value target, JCTree.JCCase c) {\n+\n+            Body.Builder body;\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                if (c.labels.size() > 1) {\n+                    throw unsupported(c);\n+                }\n+\n+                pushBody(pcl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.guard != null) {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                    pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                    Value patVal = scanPattern(pcl.pat, localTarget);\n+                    append(CoreOp._yield(patVal));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                    append(CoreOp._yield(toValue(c.guard)));\n+                    clBodies.add(stack.body);\n+                    popBody();\n+\n+                    localResult = append(ExtendedOp.conditionalAnd(clBodies));\n+                } else {\n+                    localResult = scanPattern(pcl.pat, localTarget);\n+                }\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n+\n+                \/\/ Pop label\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                pushBody(headCl, caseLabelType);\n+\n+                Value localTarget = stack.block.parameters().get(0);\n+                final Value localResult;\n+                if (c.labels.size() == 1) {\n+                    Value expr = toValue(ccl.expr);\n+                    \/\/ per java spec, constant type is compatible with the type of the selector expression\n+                    \/\/ so, we convert constant to the type of the selector expression\n+                    expr = convert(expr, selector.type);\n+                    if (selector.type.isPrimitive()) {\n+                        localResult = append(CoreOp.eq(localTarget, expr));\n+                    } else {\n+                        localResult = append(CoreOp.invoke(\n+                                MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                localTarget, expr));\n+                    }\n+                } else {\n+                    List<Body.Builder> clBodies = new ArrayList<>();\n+                    for (JCTree.JCCaseLabel cl : c.labels) {\n+                        ccl = (JCTree.JCConstantCaseLabel) cl;\n+                        pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                        Value expr = toValue(ccl.expr);\n+                        expr = convert(expr, selector.type);\n+                        final Value labelResult;\n+                        if (selector.type.isPrimitive()) {\n+                            labelResult = append(CoreOp.eq(localTarget, expr));\n+                        } else {\n+                            labelResult = append(CoreOp.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+\n+                        append(CoreOp._yield(labelResult));\n+                        clBodies.add(stack.body);\n+\n+                        \/\/ Pop label\n+                        popBody();\n+                    }\n+\n+                    localResult = append(ExtendedOp.conditionalOr(clBodies));\n+                }\n+\n+                append(CoreOp._yield(localResult));\n+                body = stack.body;\n+\n+                \/\/ Pop labels\n+                popBody();\n+            } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                \/\/ @@@ Do we need to model the default label body?\n+                pushBody(headCl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                append(CoreOp._yield(append(CoreOp.constant(JavaType.BOOLEAN, true))));\n+                body = stack.body;\n+\n+                \/\/ Pop label\n+                popBody();\n+            } else {\n+                throw unsupported(tree);\n+            }\n+\n+            return body;\n+        }\n+\n+        private Body.Builder visitCaseBody(JCTree tree, JCTree.JCCase c, FunctionType caseBodyType) {\n+\n+            Body.Builder body = null;\n+            Type yieldType = tree.type != null ? adaptBottom(tree.type) : null;\n+\n+            JCTree.JCCaseLabel headCl = c.labels.head;\n+            switch (c.caseKind) {\n+                case RULE -> {\n+                    pushBody(c.body, caseBodyType);\n+\n+                    if (c.body instanceof JCTree.JCExpression e) {\n+                        Value bodyVal = toValue(e, yieldType);\n+                        append(CoreOp._yield(bodyVal));\n+                    } else if (c.body instanceof JCTree.JCStatement s){ \/\/ this includes Block\n+                        \/\/ Otherwise there is a yield statement\n+                        Type prevBodyTarget = bodyTarget;\n+                        try {\n+                            bodyTarget = yieldType;\n+                            Value bodyVal = toValue(s);\n+                            appendTerminating(CoreOp::_yield);\n+                        } finally {\n+                            bodyTarget = prevBodyTarget;\n+                        }\n+                    }\n+                    body = stack.body;\n+\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+                case STATEMENT -> {\n+                    \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                    \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                    pushBody(c, caseBodyType);\n+\n+                    scan(c.stats);\n+\n+                    appendTerminating(c.completesNormally ?\n+                            headCl instanceof JCTree.JCDefaultCaseLabel ? CoreOp::_yield : ExtendedOp::switchFallthroughOp\n+                            : CoreOp::unreachable);\n+\n+                    body = stack.body;\n+\n+                    \/\/ Pop block\n+                    popBody();\n+                }\n+            }\n+            return body;\n+        }\n+\n+        @Override\n+        public void visitYield(JCTree.JCYield tree) {\n+            Value retVal = toValue(tree.value, bodyTarget);\n+            if (retVal == null) {\n+                result = append(ExtendedOp.java_yield());\n+            } else {\n+                result = append(ExtendedOp.java_yield(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            last = convert(last, typeElementToType(JavaType.BOOLEAN));\n+            append(CoreOp._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            append(ExtendedOp._while(condition, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            last = convert(last, typeElementToType(JavaType.BOOLEAN));\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOp._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            append(ExtendedOp.doWhile(body, condition));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+            \/\/ Push expression\n+            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            Value last = toValue(tree.expr);\n+            \/\/ Yield the Iterable result of the expression\n+            append(CoreOp._yield(last));\n+            Body.Builder expression = stack.body;\n+\n+            \/\/ Pop expression\n+            popBody();\n+\n+            JCVariableDecl var = tree.getVariable();\n+            JavaType eType = typeToTypeElement(var.type);\n+            VarType varEType = VarType.varType(typeToTypeElement(var.type));\n+\n+            \/\/ Push init\n+            \/\/ @@@ When lhs assignment is a pattern we embed the pattern match into the init body and\n+            \/\/ return the bound variables\n+            pushBody(var, FunctionType.functionType(varEType, eType));\n+            Op.Result varEResult = append(CoreOp.var(var.name.toString(), stack.block.parameters().get(0)));\n+            append(CoreOp._yield(varEResult));\n+            Body.Builder init = stack.body;\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            stack.localToOp.put(var.sym, stack.block.parameters().get(0));\n+\n+            scan(tree.body);\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+            \/\/ Pop body\n+            popBody();\n+\n+            append(ExtendedOp.enhancedFor(expression, init, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForLoop(JCTree.JCForLoop tree) {\n+            class VarDefScanner extends FilterScanner {\n+                final List<JCVariableDecl> decls;\n+\n+                public VarDefScanner() {\n+                    super(Set.of(Tag.VARDEF));\n+                    this.decls = new ArrayList<>();\n+                }\n+\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    decls.add(tree);\n+                }\n+\n+                void mapVarsToBlockArguments() {\n+                    for (int i = 0; i < decls.size(); i++) {\n+                        stack.localToOp.put(decls.get(i).sym, stack.block.parameters().get(i));\n+                    }\n+                }\n+\n+                List<VarType> varTypes() {\n+                    return decls.stream()\n+                            .map(t -> VarType.varType(typeToTypeElement(t.type)))\n+                            .toList();\n+                }\n+\n+                List<Value> varValues() {\n+                    return decls.stream()\n+                            .map(t -> stack.localToOp.get(t.sym))\n+                            .toList();\n+                }\n+            }\n+\n+            \/\/ Scan local variable declarations\n+            VarDefScanner vds = new VarDefScanner();\n+            vds.scan(tree.init);\n+            List<VarType> varTypes = vds.varTypes();\n+\n+            \/\/ Push init\n+            if (varTypes.size() > 1) {\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                scan(tree.init);\n+\n+                \/\/ Capture all local variable declarations in tuple\n+                append(CoreOp._yield(append(CoreOp.tuple(vds.varValues()))));\n+            } else if (varTypes.size() == 1) {\n+                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                scan(tree.init);\n+\n+                append(CoreOp._yield(vds.varValues().get(0)));\n+            } else {\n+                pushBody(null, FunctionType.VOID);\n+                scan(tree.init);\n+\n+                append(CoreOp._yield());\n+            }\n+            Body.Builder init = stack.body;\n+\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push cond\n+            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            if (tree.cond != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                Value last = toValue(tree.cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(last));\n+            } else {\n+                append(CoreOp._yield(append(CoreOp.constant(JavaType.BOOLEAN, true))));\n+            }\n+            Body.Builder cond = stack.body;\n+\n+            \/\/ Pop cond\n+            popBody();\n+\n+            \/\/ Push update\n+            \/\/ @@@ tree.step is a List<JCStatement>\n+            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (!tree.step.isEmpty()) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.step);\n+            }\n+            append(CoreOp._yield());\n+            Body.Builder update = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (tree.body != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.body);\n+            }\n+            appendTerminating(ExtendedOp::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            append(ExtendedOp._for(init, cond, update, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitConditional(JCTree.JCConditional tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOp._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            JCTree.JCExpression truepart = TreeInfo.skipParens(tree.truepart);\n+\n+            Type condType = adaptBottom(tree.type);\n+\n+            \/\/ Push true body\n+            pushBody(truepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value trueVal = toValue(truepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOp._yield(trueVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop true body\n+            popBody();\n+\n+            JCTree.JCExpression falsepart = TreeInfo.skipParens(tree.falsepart);\n+\n+            \/\/ Push false body\n+            pushBody(falsepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value falseVal = toValue(falsepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOp._yield(falseVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop false body\n+            popBody();\n+\n+            result = append(ExtendedOp.conditionalExpression(typeToTypeElement(condType), bodies));\n+        }\n+\n+        private Type condType(JCExpression tree, Type type) {\n+            if (type.hasTag(BOT)) {\n+                return adaptBottom(tree.type);\n+            } else {\n+                return type;\n+            }\n+        }\n+\n+        private Type adaptBottom(Type type) {\n+            return type.hasTag(BOT) ?\n+                    (pt.hasTag(NONE) ? syms.objectType : pt) :\n+                    type;\n+        }\n+\n+        @Override\n+        public void visitAssert(JCAssert tree) {\n+            \/\/ assert <cond:body1> [detail:body2]\n+\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOp._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            if (tree.detail != null) {\n+                JCTree.JCExpression detail = TreeInfo.skipParens(tree.detail);\n+\n+                pushBody(detail,\n+                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                Value detailVal = toValue(detail);\n+\n+                append(CoreOp._yield(detailVal));\n+                bodies.add(stack.body);\n+\n+                \/\/Pop detail\n+                popBody();\n+            }\n+\n+            result = append(CoreOp._assert(bodies));\n+\n+        }\n+\n+        @Override\n+        public void visitBlock(JCTree.JCBlock tree) {\n+            if (stack.tree == tree) {\n+                \/\/ Block is associated with the visit of a parent structure\n+                scan(tree.stats);\n+            } else {\n+                \/\/ Otherwise, independent block structure\n+                \/\/ Push block\n+                pushBody(tree, FunctionType.VOID);\n+                scan(tree.stats);\n+                appendTerminating(CoreOp::_yield);\n+                Body.Builder body = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+\n+                append(ExtendedOp.block(body));\n+            }\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSynchronized(JCTree.JCSynchronized tree) {\n+            \/\/ Push expr\n+            pushBody(tree.lock, FunctionType.functionType(typeToTypeElement(tree.lock.type)));\n+            Value last = toValue(tree.lock);\n+            append(CoreOp._yield(last));\n+            Body.Builder expr = stack.body;\n+\n+            \/\/ Pop expr\n+            popBody();\n+\n+            \/\/ Push body block\n+            pushBody(tree.body, FunctionType.VOID);\n+            \/\/ Scan body block statements\n+            scan(tree.body.stats);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder blockBody = stack.body;\n+\n+            \/\/ Pop body block\n+            popBody();\n+\n+            append(ExtendedOp.synchronized_(expr, blockBody));\n+        }\n+\n+        @Override\n+        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n+            \/\/ Push block\n+            pushBody(tree, FunctionType.VOID);\n+            \/\/ Create constant for label\n+            String labelName = tree.label.toString();\n+            Op.Result label = append(CoreOp.constant(JavaType.J_L_STRING, labelName));\n+            \/\/ Set label on body stack\n+            stack.setLabel(labelName, label);\n+            scan(tree.body);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            result = append(ExtendedOp.labeled(body));\n+        }\n+\n+        @Override\n+        public void visitTry(JCTree.JCTry tree) {\n+            List<JCVariableDecl> rVariableDecls = new ArrayList<>();\n+            List<TypeElement> rTypes = new ArrayList<>();\n+            Body.Builder resources;\n+            if (!tree.resources.isEmpty()) {\n+                \/\/ Resources body returns a tuple that contains the resource variables\/values\n+                \/\/ in order of declaration\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCVariableDecl vdecl) {\n+                        rVariableDecls.add(vdecl);\n+                        rTypes.add(VarType.varType(typeToTypeElement(vdecl.type)));\n+                    } else {\n+                        rTypes.add(typeToTypeElement(resource.type));\n+                    }\n+                }\n+\n+                \/\/ Push resources body\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+\n+                List<Value> rValues = new ArrayList<>();\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCTree.JCExpression e) {\n+                        rValues.add(toValue(e));\n+                    } else if (resource instanceof JCTree.JCStatement s) {\n+                        rValues.add(toValue(s));\n+                    }\n+                }\n+\n+                append(CoreOp._yield(append(CoreOp.tuple(rValues))));\n+                resources = stack.body;\n+\n+                \/\/ Pop resources body\n+                popBody();\n+            } else {\n+                resources = null;\n+            }\n+\n+            \/\/ Push body\n+            \/\/ Try body accepts the resource variables (in order of declaration).\n+            List<VarType> rVarTypes = rTypes.stream().<VarType>mapMulti((t, c) -> {\n+                if (t instanceof VarType vt) {\n+                    c.accept(vt);\n+                }\n+            }).toList();\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            for (int i = 0; i < rVariableDecls.size(); i++) {\n+                stack.localToOp.put(rVariableDecls.get(i).sym, stack.block.parameters().get(i));\n+            }\n+            scan(tree.body);\n+            appendTerminating(CoreOp::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            List<Body.Builder> catchers = new ArrayList<>();\n+            for (JCTree.JCCatch catcher : tree.catchers) {\n+                \/\/ Push body\n+                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                Op.Result exVariable = append(CoreOp.var(\n+                        catcher.param.name.toString(),\n+                        stack.block.parameters().get(0)));\n+                stack.localToOp.put(catcher.param.sym, exVariable);\n+                scan(catcher.body);\n+                appendTerminating(CoreOp::_yield);\n+                catchers.add(stack.body);\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+\n+            Body.Builder finalizer;\n+            if (tree.finalizer != null) {\n+                \/\/ Push body\n+                pushBody(tree.finalizer, FunctionType.VOID);\n+                scan(tree.finalizer);\n+                appendTerminating(CoreOp::_yield);\n+                finalizer = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+            else {\n+                finalizer = null;\n+            }\n+\n+            result = append(ExtendedOp._try(resources, body, catchers, finalizer));\n+        }\n+\n+        @Override\n+        public void visitUnary(JCTree.JCUnary tree) {\n+            Tag tag = tree.getTag();\n+            switch (tag) {\n+                case POSTINC, POSTDEC, PREINC, PREDEC -> {\n+                    \/\/ Capture applying rhs and operation\n+                    Function<Value, Value> scanRhs = (lhs) -> {\n+                        Value one = append(numericOneValue(tree.type));\n+                        Value unboxedLhs = unboxIfNeeded(lhs);\n+\n+                        Value unboxedLhsPlusOne = switch (tree.getTag()) {\n+                            \/\/ Arithmetic operations\n+                            case POSTINC, PREINC -> append(CoreOp.add(unboxedLhs, one));\n+                            case POSTDEC, PREDEC -> append(CoreOp.sub(unboxedLhs, one));\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        Value lhsPlusOne = convert(unboxedLhsPlusOne, tree.type);\n+\n+                        \/\/ Assign expression result\n+                        result =  switch (tree.getTag()) {\n+                            case POSTINC, POSTDEC -> lhs;\n+                            case PREINC, PREDEC -> lhsPlusOne;\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        return lhsPlusOne;\n+                    };\n+\n+                    applyCompoundAssign(tree.arg, scanRhs);\n+                }\n+                case NEG -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.neg(rhs));\n+                }\n+                case NOT -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.not(rhs));\n+                }\n+                case COMPL -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOp.compl(rhs));\n+                }\n+                case POS -> {\n+                    \/\/ Result is value of the operand\n+                    result = toValue(tree.arg, tree.type);\n+                }\n+                default -> throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitBinary(JCBinary tree) {\n+            Tag tag = tree.getTag();\n+            if (tag == Tag.AND || tag == Tag.OR) {\n+                \/\/ Logical operations\n+                \/\/ @@@ Flatten nested sequences\n+\n+                \/\/ Push lhs\n+                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value lhs = toValue(tree.lhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(lhs));\n+                Body.Builder bodyLhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                \/\/ Push rhs\n+                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value rhs = toValue(tree.rhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOp._yield(rhs));\n+                Body.Builder bodyRhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                List<Body.Builder> bodies = List.of(bodyLhs, bodyRhs);\n+                result = append(tag == Tag.AND\n+                        ? ExtendedOp.conditionalAnd(bodies)\n+                        : ExtendedOp.conditionalOr(bodies));\n+            } else if (tag == Tag.PLUS && tree.operator.opcode == ByteCodes.string_add) {\n+                \/\/Ignore the operator and query both subexpressions for their type with concats\n+                Type lhsType = tree.lhs.type;\n+                Type rhsType = tree.rhs.type;\n+\n+                Value lhs = toValue(tree.lhs, lhsType);\n+                Value rhs = toValue(tree.rhs, rhsType);\n+\n+                result = append(CoreOp.concat(lhs, rhs));\n+            }\n+            else {\n+                Type opType = tree.operator.type.getParameterTypes().getFirst();\n+                \/\/ @@@ potentially handle shift input conversion like other binary ops\n+                boolean isShift = tag == Tag.SL || tag == Tag.SR || tag == Tag.USR;\n+                Value lhs = toValue(tree.lhs, opType);\n+                Value rhs = toValue(tree.rhs, isShift ? tree.operator.type.getParameterTypes().getLast() : opType);\n+\n+                result = switch (tag) {\n+                    \/\/ Arithmetic operations\n+                    case PLUS -> append(CoreOp.add(lhs, rhs));\n+                    case MINUS -> append(CoreOp.sub(lhs, rhs));\n+                    case MUL -> append(CoreOp.mul(lhs, rhs));\n+                    case DIV -> append(CoreOp.div(lhs, rhs));\n+                    case MOD -> append(CoreOp.mod(lhs, rhs));\n+\n+                    \/\/ Test operations\n+                    case EQ -> append(CoreOp.eq(lhs, rhs));\n+                    case NE -> append(CoreOp.neq(lhs, rhs));\n+                    \/\/\n+                    case LT -> append(CoreOp.lt(lhs, rhs));\n+                    case LE -> append(CoreOp.le(lhs, rhs));\n+                    case GT -> append(CoreOp.gt(lhs, rhs));\n+                    case GE -> append(CoreOp.ge(lhs, rhs));\n+\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR -> append(CoreOp.or(lhs, rhs));\n+                    case BITAND -> append(CoreOp.and(lhs, rhs));\n+                    case BITXOR -> append(CoreOp.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL -> append(CoreOp.lshl(lhs, rhs));\n+                    case SR -> append(CoreOp.ashr(lhs, rhs));\n+                    case USR -> append(CoreOp.lshr(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void visitLiteral(JCLiteral tree) {\n+            Object value = switch (tree.type.getTag()) {\n+                case BOOLEAN -> tree.value instanceof Integer i && i == 1;\n+                case CHAR -> (char) (int) tree.value;\n+                default -> tree.value;\n+            };\n+            Type constantType = adaptBottom(tree.type);\n+            result = append(CoreOp.constant(typeToTypeElement(constantType), value));\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            Value retVal = toValue(tree.expr, bodyTarget);\n+            if (retVal == null) {\n+                result = append(CoreOp._return());\n+            } else {\n+                result = append(CoreOp._return(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitThrow(JCTree.JCThrow tree) {\n+            Value throwVal = toValue(tree.expr);\n+            result = append(CoreOp._throw(throwVal));\n+        }\n+\n+        @Override\n+        public void visitBreak(JCTree.JCBreak tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOp._break(label));\n+        }\n+\n+        @Override\n+        public void visitContinue(JCTree.JCContinue tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOp._continue(label));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            if (tree.sym.isDirectlyOrIndirectlyLocal()) {\n+                \/\/ we need to keep track of captured locals using same strategy as Lower\n+                class FreeVarScanner extends Lower.FreeVarCollector {\n+                    FreeVarScanner() {\n+                        lower.super(tree);\n+                    }\n+\n+                    @Override\n+                    void addFreeVars(ClassSymbol c) {\n+                        localCaptures.getOrDefault(c, List.of())\n+                                .forEach(s -> addFreeVar((VarSymbol)s));\n+                    }\n+                }\n+                FreeVarScanner fvs = new FreeVarScanner();\n+                localCaptures.put(tree.sym, List.copyOf(fvs.analyzeCaptures()));\n+            }\n+        }\n+\n+        UnsupportedASTException unsupported(JCTree tree) {\n+            return new UnsupportedASTException(tree);\n+        }\n+\n+        CoreOp.FuncOp scanMethod() {\n+            scan(body);\n+            \/\/ @@@ Check if unreachable\n+            appendTerminating(CoreOp::_return);\n+            CoreOp.FuncOp func = CoreOp.func(name.toString(), stack.body);\n+            func.setLocation(generateLocation(currentNode, true));\n+            return func;\n+        }\n+\n+        CoreOp.FuncOp scanLambda() {\n+            scan(body);\n+            append(CoreOp._return(result));\n+            return CoreOp.func(name.toString(), stack.body);\n+        }\n+\n+        JavaType symbolToErasedDesc(Symbol s) {\n+            return typeToTypeElement(s.erasure(types));\n+        }\n+\n+        JavaType typeToTypeElement(Type t) {\n+            t = normalizeType(t);\n+            return switch (t.getTag()) {\n+                case VOID -> JavaType.VOID;\n+                case CHAR -> JavaType.CHAR;\n+                case BOOLEAN -> JavaType.BOOLEAN;\n+                case BYTE -> JavaType.BYTE;\n+                case SHORT -> JavaType.SHORT;\n+                case INT -> JavaType.INT;\n+                case FLOAT -> JavaType.FLOAT;\n+                case LONG -> JavaType.LONG;\n+                case DOUBLE -> JavaType.DOUBLE;\n+                case ARRAY -> {\n+                    Type et = ((ArrayType)t).elemtype;\n+                    yield JavaType.array(typeToTypeElement(et));\n+                }\n+                case WILDCARD -> {\n+                    Type.WildcardType wt = (Type.WildcardType)t;\n+                    yield wt.isUnbound() ?\n+                            JavaType.wildcard() :\n+                            JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n+                }\n+                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound())) :\n+                        JavaType.typeVarRef(t.tsym.name.toString(),\n+                                (jdk.internal.java.lang.reflect.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound()));\n+                case CLASS -> {\n+                    Assert.check(!t.isIntersection() && !t.isUnion());\n+                    JavaType typ;\n+                    if (t.getEnclosingType() != Type.noType) {\n+                        Name innerName = t.tsym.flatName().subName(t.getEnclosingType().tsym.flatName().length() + 1);\n+                        typ = JavaType.qualified(typeToTypeElement(t.getEnclosingType()), innerName.toString());\n+                    } else {\n+                        typ = JavaType.type(ClassDesc.of(t.tsym.flatName().toString()));\n+                    }\n+\n+                    List<JavaType> typeArguments;\n+                    if (t.getTypeArguments().nonEmpty()) {\n+                        typeArguments = new ArrayList<>();\n+                        for (Type ta : t.getTypeArguments()) {\n+                            typeArguments.add(typeToTypeElement(ta));\n+                        }\n+                    } else {\n+                        typeArguments = List.of();\n+                    }\n+\n+                    \/\/ Use flat name to ensure demarcation of nested classes\n+                    yield JavaType.parameterized(typ, typeArguments);\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n+                }\n+            };\n+        }\n+\n+        Type symbolSiteType(Symbol s) {\n+            boolean isMember = s.owner == syms.predefClass ||\n+                    s.isMemberOf(currentClassSym, types);\n+            return isMember ? currentClassSym.type : s.owner.type;\n+        }\n+\n+        FieldRef symbolToFieldRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        FieldRef symbolToErasedFieldRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return FieldRef.field(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedMethodRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return MethodRef.method(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType.getReturnType()),\n+                    erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        FunctionType symbolToFunctionType(Symbol s) {\n+            return typeToFunctionType(s.type);\n+        }\n+\n+        FunctionType typeToFunctionType(Type t) {\n+            return FunctionType.functionType(\n+                    typeToTypeElement(t.getReturnType()),\n+                    t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n+            TypeElement recordType = typeToTypeElement(s.type);\n+            List<RecordTypeRef.ComponentRef> components = s.getRecordComponents().stream()\n+                    .map(rc -> new RecordTypeRef.ComponentRef(typeToTypeElement(rc.type), rc.name.toString()))\n+                    .toList();\n+            return RecordTypeRef.recordType(recordType, components);\n+        }\n+\n+        Op defaultValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE -> CoreOp.constant(typeToTypeElement(t), (byte)0);\n+                case CHAR -> CoreOp.constant(typeToTypeElement(t), (char)0);\n+                case BOOLEAN -> CoreOp.constant(typeToTypeElement(t), false);\n+                case SHORT -> CoreOp.constant(typeToTypeElement(t), (short)0);\n+                case INT -> CoreOp.constant(typeToTypeElement(t), 0);\n+                case FLOAT -> CoreOp.constant(typeToTypeElement(t), 0f);\n+                case LONG -> CoreOp.constant(typeToTypeElement(t), 0L);\n+                case DOUBLE -> CoreOp.constant(typeToTypeElement(t), 0d);\n+                default -> CoreOp.constant(typeToTypeElement(t), null);\n+            };\n+        }\n+\n+        Op numericOneValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE -> CoreOp.constant(typeToTypeElement(t), (byte)1);\n+                case CHAR -> CoreOp.constant(typeToTypeElement(t), (char)1);\n+                case SHORT -> CoreOp.constant(typeToTypeElement(t), (short)1);\n+                case INT -> CoreOp.constant(typeToTypeElement(t), 1);\n+                case FLOAT -> CoreOp.constant(typeToTypeElement(t), 1f);\n+                case LONG -> CoreOp.constant(typeToTypeElement(t), 1L);\n+                case DOUBLE -> CoreOp.constant(typeToTypeElement(t), 1d);\n+                case CLASS -> numericOneValue(types.unboxedType(t));\n+                default -> throw new UnsupportedOperationException(t.toString());\n+            };\n+        }\n+\n+        Type normalizeType(Type t) {\n+            Assert.check(!t.hasTag(METHOD));\n+            return types.upward(t, false, types.captures(t));\n+        }\n+\n+        Type typeElementToType(TypeElement desc) {\n+            return primitiveAndBoxTypeMap().getOrDefault(desc, Type.noType);\n+        }\n+\n+        public boolean checkDenotableInTypeDesc(Type t) {\n+            return denotableChecker.visit(t, null);\n+        }\n+        \/\/ where\n+\n+        \/**\n+         * A type visitor that descends into the given type looking for types that are non-denotable\n+         * in code model types. Examples of such types are: type-variables (regular or captured),\n+         * wildcard type argument, intersection types, union types. The visit methods return false\n+         * as soon as a non-denotable type is encountered and true otherwise. (see {@link Check#checkDenotable(Type)}.\n+         *\/\n+        private static final Types.SimpleVisitor<Boolean, Void> denotableChecker = new Types.SimpleVisitor<>() {\n+            @Override\n+            public Boolean visitType(Type t, Void s) {\n+                return true;\n+            }\n+            @Override\n+            public Boolean visitClassType(ClassType t, Void s) {\n+                if (t.isUnion() || t.isIntersection()) {\n+                    \/\/ union and intersections cannot be denoted in code model types\n+                    return false;\n+                }\n+                \/\/ @@@ What about enclosing types?\n+                for (Type targ : t.getTypeArguments()) {\n+                    \/\/ propagate into type arguments\n+                    if (!visit(targ, s)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Void s) {\n+                \/\/ type variables cannot be denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Void s) {\n+                \/\/ wildcards cannot de denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Void s) {\n+                \/\/ propagate into element type\n+                return visit(t.elemtype, s);\n+            }\n+        };\n+\n+    }\n+\n+    \/**\n+     * An exception thrown when an unsupported AST node is found when building a method IR.\n+     *\/\n+    static class UnsupportedASTException extends RuntimeException {\n+\n+        private static final long serialVersionUID = 0;\n+        transient final JCTree tree;\n+\n+        public UnsupportedASTException(JCTree tree) {\n+            this.tree = tree;\n+        }\n+    }\n+\n+    enum FunctionalExpressionKind {\n+        QUOTED_STRUCTURAL(true), \/\/ this is transitional\n+        QUOTABLE(true),\n+        NOT_QUOTED(false);\n+\n+        final boolean isQuoted;\n+\n+        FunctionalExpressionKind(boolean isQuoted) {\n+            this.isQuoted = isQuoted;\n+        }\n+    }\n+\n+    FunctionalExpressionKind functionalKind(JCFunctionalExpression functionalExpression) {\n+        if (functionalExpression.target.hasTag(TypeTag.METHOD)) {\n+            return FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+        } else if (types.asSuper(functionalExpression.target, syms.quotableType.tsym) != null) {\n+            return FunctionalExpressionKind.QUOTABLE;\n+        } else {\n+            return FunctionalExpressionKind.NOT_QUOTED;\n+        }\n+    }\n+\n+    \/*\n+     * Converts a method reference which cannot be used directly into a lambda.\n+     * This code has been derived from LambdaToMethod::MemberReferenceToLambda. The main\n+     * difference is that, while that code concerns with translation strategy, boxing\n+     * conversion and type erasure, this version does not and, as such, can remain\n+     * at a higher level. Note that this code needs to create a synthetic variable\n+     * declaration in case of a bounded method reference whose receiver expression\n+     * is other than 'this'\/'super' (this is done to prevent the receiver expression\n+     * from being computed twice).\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final Symbol owner;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private JCVariableDecl receiverVar = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree, Symbol currentClass) {\n+            this.tree = tree;\n+            this.owner = new MethodSymbol(0, names.lambda, tree.target, currentClass);\n+            if (tree.kind == ReferenceKind.BOUND && !isThisOrSuper(tree.getQualifierExpression())) {\n+                \/\/ true bound method reference, hoist receiver expression out\n+                Type recvType = types.asSuper(tree.getQualifierExpression().type, tree.sym.owner);\n+                VarSymbol vsym = makeSyntheticVar(\"rec$\", recvType);\n+                receiverVar = make.VarDef(vsym, tree.getQualifierExpression());\n+            }\n+        }\n+\n+        JCVariableDecl receiverVar() {\n+            return receiverVar;\n+        }\n+\n+        JCLambda lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                return slam;\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            com.sun.tools.javac.util.List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+            VarSymbol receiverParam = null;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    if (receiverVar != null) {\n+                        receiverParam = receiverVar.sym;\n+                    }\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    receiverParam = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+            }\n+            for (int i = 0; descPTypes.nonEmpty(); ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                descPTypes = descPTypes.tail;\n+            }\n+\n+            return receiverParam;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol receiverParam) {\n+            JCExpression qualifier = receiverParam != null ?\n+                    make.at(tree.pos).Ident(receiverParam) :\n+                    tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCMethodInvocation apply = make.Apply(com.sun.tools.javac.util.List.nil(), select, args.toList()).\n+                    setType(tree.referentType.getReturnType());\n+\n+            apply.varargsElement = tree.varargsElement;\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            Type expectedType = tree.referentType.getReturnType().hasTag(TypeTag.VOID) ?\n+                    tree.expr.type : tree.referentType.getReturnType();\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(expectedType)),\n+                        com.sun.tools.javac.util.List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCExpression newType = make.Type(types.erasure(expectedType));\n+                if (expectedType.tsym.type.getTypeArguments().nonEmpty()) {\n+                    newType = make.TypeApply(newType, com.sun.tools.javac.util.List.nil());\n+                }\n+                JCNewClass newClass = make.NewClass(null,\n+                        com.sun.tools.javac.util.List.nil(),\n+                        newType,\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.referentType;\n+                newClass.type = expectedType;\n+                newClass.varargsElement = tree.varargsElement;\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol makeSyntheticVar(String name, Type type) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), type, owner);\n+            vsym.pos = tree.pos;\n+            return vsym;\n+        }\n+\n+        private VarSymbol addParameter(String name, Type type, boolean genArg) {\n+            VarSymbol vsym = makeSyntheticVar(name, type);\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+\n+        boolean isThisOrSuper(JCExpression expression) {\n+            return TreeInfo.isThisQualifier(expression) || TreeInfo.isSuperQualifier(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":2837,"deletions":0,"binary":false,"changes":2837,"status":"added"},{"patch":"@@ -685,0 +685,1 @@\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1609,0 +1609,4 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                env.tree = ReflectMethods.instance(context).translateTopLevelClass(env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1407,0 +1407,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4131,0 +4139,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.code.Type.MethodType;\n@@ -801,1 +802,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -810,0 +812,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public CodeReflectionInfo codeReflectionInfo;\n@@ -814,1 +818,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -816,0 +827,2 @@\n+\n+        public record CodeReflectionInfo(Symbol quotedField, List<JCExpression> capturedArgs) { }\n@@ -2007,1 +2020,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2594,1 +2607,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -668,0 +668,3 @@\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,6 +71,6 @@\n-        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements java.util.List<TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n-        assertInferredFQNs(\"class X implements java.util.List<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X extends java.util.ArrayList<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements java.util.List<TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n+        assertInferredFQNs(\"class X implements java.util.List<TypeMirror, TypeElement\", \"TypeElement\".length(), false, \"java.lang.reflect.code.TypeElement\", \"javax.lang.model.element.TypeElement\");\n","filename":"test\/langtools\/jdk\/jshell\/ComputeFQNsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -215,0 +215,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}