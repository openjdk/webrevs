{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.classfile.Opcode;\n@@ -36,0 +37,4 @@\n+\/**\n+ * BranchCompactor is a CodeTransform working as a state machine.\n+ * It identifies and compacts redundant sequences of branches in a single pass.\n+ *\/\n@@ -38,2 +43,3 @@\n-    private BranchInstruction firstBranch;\n-    private final List<PseudoInstruction> pseudoBuffer = new ArrayList<>();\n+    private BranchInstruction firstBranch, secondBranch;\n+    private final List<PseudoInstruction> pseudoBuffer1 = new ArrayList<>(),\n+                                          pseudoBuffer2 = new ArrayList<>();\n@@ -41,0 +47,1 @@\n+    \/\/BranchCompactor is in INIT_STATE until a branch instruction appears\n@@ -46,1 +53,1 @@\n-                activeState = LOOKING_FOR_TARGET;\n+                activeState = LOOKING_FOR_SHORT_JUMP;\n@@ -48,0 +55,1 @@\n+                \/\/all other instructions and pseudo instrutions are passed\n@@ -53,1 +61,4 @@\n-    private final CodeTransform LOOKING_FOR_TARGET = new CodeTransform() {\n+    \/\/In this state we are looking for immediate target of the firstBranch\n+    \/\/or also for a second (unconditional) branch when the firstBranch is conditional\n+    \/\/all pseudo instructions are buffered as they do not represent a real bytecode\n+    private final CodeTransform LOOKING_FOR_SHORT_JUMP = new CodeTransform() {\n@@ -59,2 +70,5 @@\n-                        pseudoBuffer.forEach(cob::with);\n-                        pseudoBuffer.clear();\n+                        \/\/here we have immediate target, so the first branch is skipped\n+                        \/\/all pseudo instructions are passed (including the actual target)\n+                        \/\/and BranchCompactor returns to INIT_STATE\n+                        pseudoBuffer1.forEach(cob::with);\n+                        pseudoBuffer1.clear();\n@@ -64,1 +78,2 @@\n-                        pseudoBuffer.add(lt);\n+                        \/\/here we buffer the label as a pseudo instructions\n+                        pseudoBuffer1.add(lt);\n@@ -68,1 +83,2 @@\n-                    pseudoBuffer.add(pi);\n+                    \/\/here we buffer pseudo instructions\n+                    pseudoBuffer1.add(pi);\n@@ -71,2 +87,12 @@\n-                    atEnd(cob);\n-                    firstBranch = bi;\n+                    if (!firstBranch.opcode().isUnconditionalBranch() && bi.opcode().isUnconditionalBranch()) {\n+                        \/\/second (unconditional) branch appears and the firstBranch is conditional\n+                        \/\/so the BranchCompactor moves to LOOKING_FOR_DOUBLE_JUMP state\n+                        secondBranch = bi;\n+                        activeState = LOOKING_FOR_DOUBLE_JUMP;\n+                    } else {\n+                        \/\/branches do not meet criteria to look for double jumps\n+                        \/\/so we flush the firstBranch and all buffered pseudo instructions\n+                        \/\/and continue in this state with a new firstBranch\n+                        atEnd(cob);\n+                        firstBranch = bi;\n+                    }\n@@ -75,0 +101,2 @@\n+                    \/\/any other instruction flushes the firstBranch and pseudo instructions\n+                    \/\/and returns BranchCompactor to INIT_STATE\n@@ -83,0 +111,1 @@\n+            \/\/here we flush the firstBranch and pseudo instructions\n@@ -84,2 +113,65 @@\n-            pseudoBuffer.forEach(cob::with);\n-            pseudoBuffer.clear();\n+            pseudoBuffer1.forEach(cob::with);\n+            pseudoBuffer1.clear();\n+        }\n+    };\n+\n+    \/\/This state assumes we have a sequence of one conditional and one unconditional branch\n+    \/\/and we are trying to merge them with reversed condition\n+    private final CodeTransform LOOKING_FOR_DOUBLE_JUMP = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case LabelTarget lt -> {\n+                    if (secondBranch.target() == lt.label()) {\n+                        \/\/second branch has been identified as short-circuit\n+                        \/\/so we move to LOOKING_FOR_SHORT_JUMP state\n+                        \/\/and replay all pseudo instructions from the second buffer\n+                        \/\/as there might be another short target\n+                        activeState = LOOKING_FOR_SHORT_JUMP;\n+                        pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n+                        pseudoBuffer2.clear();\n+                        activeState.accept(cob, lt);\n+                    } else if (firstBranch.target() == lt.label()) {\n+                        \/\/double branch has been detected\n+                        \/\/we replace firstBranch instruction with reverted condition and secondBranch target\n+                        \/\/move to LOOKING_FOR_SHORT_JUMP state and replay pseudoBuffer2\n+                        firstBranch = BranchInstruction.of(reverseBranchOpcode(firstBranch.opcode()), secondBranch.target());\n+                        activeState = LOOKING_FOR_SHORT_JUMP;\n+                        pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n+                        pseudoBuffer2.clear();\n+                        activeState.accept(cob, lt);\n+                    } else {\n+                        \/\/here we buffer the label as a pseudo instruction following the secondBranch\n+                        pseudoBuffer2.add(lt);\n+                    }\n+                }\n+                case PseudoInstruction pi -> {\n+                    \/\/here we buffer pseudo instructions following the secondBranch\n+                    pseudoBuffer2.add(pi);\n+                }\n+                case BranchInstruction bi -> {\n+                    \/\/third branch has been detected, so we flush the firstBranch and its pseudo instructions\n+                    \/\/move to LOOKING_FOR_SHORT_JUMP state, shift secondBranch to the firstBranch\n+                    \/\/replay the seconBranch pseudo instructions and this actual branch\n+                    LOOKING_FOR_SHORT_JUMP.atEnd(cob);\n+                    activeState = LOOKING_FOR_SHORT_JUMP;\n+                    firstBranch = secondBranch;\n+                    pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n+                    pseudoBuffer2.clear();\n+                    activeState.accept(cob, bi);\n+                }\n+                default -> {\n+                    \/\/any other instruction flushes all the branches and buffered pseudo instructions\n+                    atEnd(cob);\n+                    activeState = INIT_STATE;\n+                    cob.with(coe);\n+                }\n+            }\n+        }\n+        @Override\n+        public void atEnd(CodeBuilder cob) {\n+            \/\/here we flush everything\n+            LOOKING_FOR_SHORT_JUMP.atEnd(cob);\n+            cob.accept(secondBranch);\n+            pseudoBuffer2.forEach(cob::with);\n+            pseudoBuffer2.clear();\n@@ -100,0 +192,22 @@\n+\n+    static Opcode reverseBranchOpcode(Opcode op) {\n+        return switch (op) {\n+            case IFEQ -> Opcode.IFNE;\n+            case IFNE -> Opcode.IFEQ;\n+            case IFLT -> Opcode.IFGE;\n+            case IFGE -> Opcode.IFLT;\n+            case IFGT -> Opcode.IFLE;\n+            case IFLE -> Opcode.IFGT;\n+            case IF_ICMPEQ -> Opcode.IF_ICMPNE;\n+            case IF_ICMPNE -> Opcode.IF_ICMPEQ;\n+            case IF_ICMPLT -> Opcode.IF_ICMPGE;\n+            case IF_ICMPGE -> Opcode.IF_ICMPLT;\n+            case IF_ICMPGT -> Opcode.IF_ICMPLE;\n+            case IF_ICMPLE -> Opcode.IF_ICMPGT;\n+            case IF_ACMPEQ -> Opcode.IF_ACMPNE;\n+            case IF_ACMPNE -> Opcode.IF_ACMPEQ;\n+            case IFNULL -> Opcode.IFNONNULL;\n+            case IFNONNULL -> Opcode.IFNULL;\n+            default -> throw new IllegalArgumentException(\"Unknown branch instruction: \" + op);\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":126,"deletions":12,"binary":false,"changes":138,"status":"modified"}]}