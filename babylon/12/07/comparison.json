{"files":[{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * BranchCompactor is a CodeTransform skipping redundant branches to immediate targets.\n+ *\/\n+public final class BranchCompactor implements CodeTransform {\n+\n+    public BranchCompactor() {\n+    }\n+\n+    private BranchInstruction branch;\n+    private final List<PseudoInstruction> buffer = new ArrayList<>();\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        if (branch == null) {\n+            if (coe instanceof BranchInstruction bi && bi.opcode().isUnconditionalBranch()) {\n+                \/\/unconditional branch is stored\n+                branch = bi;\n+            } else {\n+                \/\/all other instructions and pseudo instructions are passed\n+                cob.with(coe);\n+            }\n+        } else switch (coe) {\n+            case LabelTarget lt -> {\n+                if (branch.target() == lt.label()) {\n+                    \/\/skip branch to immediate target\n+                    branch = null;\n+                    \/\/flush buffer\n+                    buffer.forEach(cob::with);\n+                    buffer.clear();\n+                    cob.with(coe);\n+                } else {\n+                    \/\/buffer other targets\n+                    buffer.add(lt);\n+                }\n+            }\n+            case PseudoInstruction pi -> {\n+                \/\/buffer pseudo instructions\n+                buffer.add(pi);\n+            }\n+            default -> {\n+                \/\/any other instruction flushes the branch and buffer\n+                atEnd(cob);\n+                \/\/the code element is replayed\n+                accept(cob, coe);\n+            }\n+        }\n+    }\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        \/\/flush the branch\n+        cob.with(branch);\n+        branch = null;\n+        \/\/flush the buffer\n+        buffer.forEach(cob::with);\n+        buffer.clear();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -38,3 +38,0 @@\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.Instruction;\n@@ -46,2 +43,0 @@\n-import java.lang.classfile.instruction.BranchInstruction;\n-import java.lang.classfile.instruction.LabelTarget;\n@@ -60,1 +55,0 @@\n-import java.lang.reflect.code.Block.Reference;\n@@ -69,1 +63,0 @@\n-import java.util.Collections;\n@@ -119,16 +112,0 @@\n-    private static class DebugTransform implements CodeTransform {\n-        private int bci = 0;\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            cob.accept(coe);\n-            switch (coe) {\n-                case LabelTarget lt -> System.out.println(bci + \": \" + lt + \" (\" + lt.label().hashCode() + \")\");\n-                case BranchInstruction bi -> System.out.println(bci + \": \" + bi + \" (\" + bi.target().hashCode() + \")\");\n-                default -> System.out.println(bci + \": \" + coe);\n-            }\n-            if (coe instanceof Instruction ins) bci += ins.sizeInBytes();\n-        }\n-\n-    }\n-\n@@ -146,1 +123,1 @@\n-                        cb -> cb.transforming(new DebugTransform(), cob -> {\n+                        cb -> cb.transforming(new BranchCompactor(), cob -> {\n@@ -170,1 +147,0 @@\n-        final Map<Block, ExceptionRegionNode> coveredBlocks;\n@@ -180,1 +156,0 @@\n-            this.coveredBlocks = new HashMap<>();\n@@ -210,1 +185,0 @@\n-\n@@ -215,4 +189,0 @@\n-        int getOrAssignSlot(Value v) {\n-            return getOrAssignSlot(v, false);\n-        }\n-\n@@ -348,9 +318,0 @@\n-    record ExceptionRegionNode(CoreOps.ExceptionRegionEnter ere, int size, ExceptionRegionNode next) {\n-    }\n-\n-    static final ExceptionRegionNode NIL = new ExceptionRegionNode(null, 0, null);\n-\n-    private static void computeExceptionRegionMembership(Body r, ConversionContext c) {\n-        Set<Block> visited = new HashSet<>();\n-        Deque<Block> stack = new ArrayDeque<>();\n-        stack.push(r.entryBlock());\n@@ -358,4 +319,19 @@\n-        \/\/ Set of catching blocks\n-        Set<Block> catchingBlocks = c.catchingBlocks;\n-        \/\/ Map of block to stack of covered exception regions\n-        Map<Block, ExceptionRegionNode> coveredBlocks = c.coveredBlocks;\n+    private static void computeExceptionRegionMembership(Body body, CodeBuilder cob, ConversionContext c) {\n+        final List<Block> blocks = body.blocks();\n+        record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {\n+        }\n+        \/\/ List of all regions\n+        final List<ExceptionRegionWithBlocks> allRegions = new ArrayList<>();\n+        class BlockWithActiveExceptionRegions {\n+            final Block block;\n+            final BitSet activeRegionStack;\n+            BlockWithActiveExceptionRegions(Block block, BitSet activeRegionStack) {\n+                this.block = block;\n+                this.activeRegionStack = activeRegionStack;\n+                int index = blocks.indexOf(block);\n+                activeRegionStack.stream().forEach(r -> allRegions.get(r).blocks.set(index));\n+            }\n+        }\n+        final Set<Block> visited = new HashSet<>();\n+        final Deque<BlockWithActiveExceptionRegions> stack = new ArrayDeque<>();\n+        stack.push(new BlockWithActiveExceptionRegions(body.entryBlock(), new BitSet()));\n@@ -364,1 +340,2 @@\n-            Block b = stack.pop();\n+            BlockWithActiveExceptionRegions bm = stack.pop();\n+            Block b = bm.block;\n@@ -368,1 +345,0 @@\n-\n@@ -370,1 +346,0 @@\n-            ExceptionRegionNode bRegions = coveredBlocks.get(b);\n@@ -372,5 +347,1 @@\n-                if (bRegions != null) {\n-                    coveredBlocks.put(bop.branch().targetBlock(), bRegions);\n-                }\n-\n-                stack.push(bop.branch().targetBlock());\n+                stack.push(new BlockWithActiveExceptionRegions(bop.branch().targetBlock(), bm.activeRegionStack));\n@@ -378,7 +349,2 @@\n-                if (bRegions != null) {\n-                    coveredBlocks.put(cop.falseBranch().targetBlock(), bRegions);\n-                    coveredBlocks.put(cop.trueBranch().targetBlock(), bRegions);\n-                }\n-\n-                stack.push(cop.falseBranch().targetBlock());\n-                stack.push(cop.trueBranch().targetBlock());\n+                stack.push(new BlockWithActiveExceptionRegions(cop.falseBranch().targetBlock(), bm.activeRegionStack));\n+                stack.push(new BlockWithActiveExceptionRegions(cop.trueBranch().targetBlock(), bm.activeRegionStack));\n@@ -386,16 +352,3 @@\n-                ArrayList<Block.Reference> catchBlocks = new ArrayList<>(er.catchBlocks());\n-                Collections.reverse(catchBlocks);\n-                for (Block.Reference catchBlock : catchBlocks) {\n-                    catchingBlocks.add(catchBlock.targetBlock());\n-                    if (bRegions != null) {\n-                        coveredBlocks.put(catchBlock.targetBlock(), bRegions);\n-                    }\n-\n-                    stack.push(catchBlock.targetBlock());\n-                }\n-\n-                ExceptionRegionNode n;\n-                if (bRegions != null) {\n-                    n = new ExceptionRegionNode(er, bRegions.size + 1, bRegions);\n-                } else {\n-                    n = new ExceptionRegionNode(er, 1, NIL);\n+                for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n+                    c.catchingBlocks.add(catchBlock.targetBlock());\n+                    stack.push(new BlockWithActiveExceptionRegions(catchBlock.targetBlock(), bm.activeRegionStack));\n@@ -403,3 +356,5 @@\n-                coveredBlocks.put(er.start().targetBlock(), n);\n-\n-                stack.push(er.start().targetBlock());\n+                BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                activeRegionStack.set(allRegions.size());\n+                ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n+                allRegions.add(newNode);\n+                stack.push(new BlockWithActiveExceptionRegions(er.start().targetBlock(), activeRegionStack));\n@@ -407,7 +362,3 @@\n-                assert bRegions != null;\n-\n-                if (bRegions.size() > 1) {\n-                    coveredBlocks.put(er.end().targetBlock(), bRegions.next());\n-                }\n-\n-                stack.push(er.end().targetBlock());\n+                BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                activeRegionStack.clear(activeRegionStack.length() - 1);\n+                stack.push(new BlockWithActiveExceptionRegions(er.end().targetBlock(), activeRegionStack));\n@@ -416,9 +367,18 @@\n-    }\n-\n-    private static void branch(CodeBuilder cob, ConversionContext c, List<Block> blocks, Block source, Block target) {\n-        int bi = blocks.indexOf(source);\n-        int si = blocks.indexOf(target);\n-        \/\/ If successor occurs immediately after this block,\n-        \/\/ then no need for goto instruction\n-        if (bi != si - 1) {\n-            cob.goto_(c.getLabel(target));\n+        \/\/ Declare the exception regions\n+        for (ExceptionRegionWithBlocks erNode : allRegions.reversed()) {\n+            int start  = erNode.blocks.nextSetBit(0);\n+            while (start >= 0) {\n+                int end = erNode.blocks.nextClearBit(start);\n+                Label startLabel = c.getLabel(blocks.get(start));\n+                Label endLabel = c.getLabel(blocks.get(end));\n+                for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                    Block cb = cbr.targetBlock();\n+                    if (!cb.parameters().isEmpty()) {\n+                        ClassDesc type = cb.parameters().get(0).type().toNominalDescriptor();\n+                        cob.exceptionCatch(startLabel, endLabel, c.getLabel(cb), type);\n+                    } else {\n+                        cob.exceptionCatchAll(startLabel, endLabel, c.getLabel(cb));\n+                    }\n+                }\n+                start = erNode.blocks.nextSetBit(end);\n+            }\n@@ -429,1 +389,1 @@\n-        computeExceptionRegionMembership(body, c);\n+        computeExceptionRegionMembership(body, cob, c);\n@@ -455,2 +415,0 @@\n-\/\/                clb.parameter(ex.type());\n-\n@@ -741,1 +699,1 @@\n-                    branch(cob, c, blocks, b, op.branch().targetBlock());\n+                    cob.goto_(c.getLabel(op.branch().targetBlock()));\n@@ -750,1 +708,1 @@\n-                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n@@ -754,1 +712,1 @@\n-                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n@@ -761,1 +719,1 @@\n-                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n@@ -765,1 +723,1 @@\n-                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n@@ -777,13 +735,1 @@\n-                    ExceptionRegionEnter enterOp = op.regionStart();\n-                    Label start = c.getLabel(enterOp.start().targetBlock());\n-                    Label end = cob.newBoundLabel();\n-                    for (Reference cbr : enterOp.catchBlocks()) {\n-                        Block cb = cbr.targetBlock();\n-                        if (!cb.parameters().isEmpty()) {\n-                            ClassDesc type = cb.parameters().get(0).type().toNominalDescriptor();\n-                            cob.exceptionCatch(start, end, c.getLabel(cb), type);\n-                        } else {\n-                            cob.exceptionCatchAll(start, end, c.getLabel(cb));\n-                        }\n-                    }\n-                    branch(cob, c, blocks, b, op.end().targetBlock());\n+                    cob.goto_(c.getLabel(op.end().targetBlock()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":61,"deletions":115,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.components.ClassPrinter;\n+import static java.lang.classfile.Opcode.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.code.bytecode.BranchCompactor;\n+import java.util.List;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestBranchCompactor\n+ *\/\n+public class TestBranchCompactor {\n+\n+    @Test\n+    public void testBranchCompactor() {\n+        var cc = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        var clm = cc.parse(cc.build(ClassDesc.of(\"c\"), clb -> clb.withMethodBody(\"m\", ConstantDescs.MTD_void, 0,\n+                cb -> cb.transforming(new BranchCompactor(), cob -> {\n+                    var l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .lineNumber(1)\n+                       .labelBinding(l)\n+                       .nop();\n+\n+                    l = cob.newLabel();\n+                    cob.goto_w(l) \/\/compact\n+                       .lineNumber(2)\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .labelBinding(l);\n+\n+                    cob.iconst_0();\n+                    l = cob.newLabel();\n+                    cob.ifeq(l) \/\/do not compact\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/do not compact\n+                       .nop()\n+                       .labelBinding(l)\n+                       .return_();\n+                }))));\n+        var code = clm.methods().get(0).code().get();\n+        ClassPrinter.toYaml(code, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        Assert.assertEquals(\n+                code.elementList().stream().mapMulti((e, ec) -> {if (e instanceof Instruction i) ec.accept(i.opcode());}).toList(),\n+                List.of(NOP, ICONST_0, IFEQ, GOTO, NOP, RETURN));\n+        Assert.assertEquals(code.findAttribute(Attributes.LINE_NUMBER_TABLE).get().lineNumbers().size(), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNew.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -131,2 +130,1 @@\n-    @Test(enabled = false)\n-    \/\/finalizer in exception handler is invalid (missing exception.region.exit)\n+    @Test\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -87,2 +86,1 @@\n-    @Test(enabled = false)\n-    \/\/finalizer in exception handler is invalid (missing exception.region.exit)\n+    @Test\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}