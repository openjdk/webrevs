{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.classfile.Opcode;\n@@ -38,2 +37,1 @@\n- * BranchCompactor is a CodeTransform working as a state machine.\n- * It identifies and compacts redundant sequences of branches in a single pass.\n+ * BranchCompactor is a CodeTransform skipping redundant branches to immediate targets.\n@@ -46,3 +44,2 @@\n-    private BranchInstruction firstBranch, secondBranch;\n-    private final List<PseudoInstruction> pseudoBuffer1 = new ArrayList<>(),\n-                                          pseudoBuffer2 = new ArrayList<>();\n+    private BranchInstruction branch;\n+    private final List<PseudoInstruction> buffer = new ArrayList<>();\n@@ -50,7 +47,6 @@\n-    \/\/BranchCompactor is in INIT_STATE until a branch instruction appears\n-    private final CodeTransform INIT_STATE = new CodeTransform() {\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            if (coe instanceof BranchInstruction bi) {\n-                firstBranch = bi;\n-                activeState = LOOKING_FOR_SHORT_JUMP;\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        if (branch == null) {\n+            if (coe instanceof BranchInstruction bi && bi.opcode().isUnconditionalBranch()) {\n+                \/\/unconditional branch is stored\n+                branch = bi;\n@@ -61,47 +57,8 @@\n-        }\n-    };\n-\n-    \/\/In this state we are looking for immediate target of the firstBranch\n-    \/\/or also for a second (unconditional) branch when the firstBranch is conditional\n-    \/\/all pseudo instructions are buffered as they do not represent a real bytecode\n-    private final CodeTransform LOOKING_FOR_SHORT_JUMP = new CodeTransform() {\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            switch (coe) {\n-                case LabelTarget lt -> {\n-                    if (firstBranch.target() == lt.label()) {\n-                        \/\/here we have immediate target, so the first branch is skipped\n-                        \/\/all pseudo instructions are passed (including the actual target)\n-                        \/\/and BranchCompactor returns to INIT_STATE\n-                        pseudoBuffer1.forEach(cob::with);\n-                        pseudoBuffer1.clear();\n-                        activeState = INIT_STATE;\n-                        cob.with(coe);\n-                    } else {\n-                        \/\/here we buffer the label as a pseudo instructions\n-                        pseudoBuffer1.add(lt);\n-                    }\n-                }\n-                case PseudoInstruction pi -> {\n-                    \/\/here we buffer pseudo instructions\n-                    pseudoBuffer1.add(pi);\n-                }\n-                case BranchInstruction bi -> {\n-                    if (!firstBranch.opcode().isUnconditionalBranch() && bi.opcode().isUnconditionalBranch()) {\n-                        \/\/second (unconditional) branch appears and the firstBranch is conditional\n-                        \/\/so the BranchCompactor moves to LOOKING_FOR_DOUBLE_JUMP state\n-                        secondBranch = bi;\n-                        activeState = LOOKING_FOR_DOUBLE_JUMP;\n-                    } else {\n-                        \/\/branches do not meet criteria to look for double jumps\n-                        \/\/so we flush the firstBranch and all buffered pseudo instructions\n-                        \/\/and continue in this state with a new firstBranch\n-                        atEnd(cob);\n-                        firstBranch = bi;\n-                    }\n-                }\n-                default -> {\n-                    \/\/any other instruction flushes the firstBranch and pseudo instructions\n-                    \/\/and returns BranchCompactor to INIT_STATE\n-                    atEnd(cob);\n-                    activeState = INIT_STATE;\n+        } else switch (coe) {\n+            case LabelTarget lt -> {\n+                if (branch.target() == lt.label()) {\n+                    \/\/skip branch to immediate target\n+                    branch = null;\n+                    \/\/flush buffer\n+                    buffer.forEach(cob::with);\n+                    buffer.clear();\n@@ -109,0 +66,3 @@\n+                } else {\n+                    \/\/buffer other targets\n+                    buffer.add(lt);\n@@ -111,61 +71,9 @@\n-        }\n-        @Override\n-        public void atEnd(CodeBuilder cob) {\n-            \/\/here we flush the firstBranch and pseudo instructions\n-            cob.accept(firstBranch);\n-            pseudoBuffer1.forEach(cob::with);\n-            pseudoBuffer1.clear();\n-        }\n-    };\n-\n-    \/\/This state assumes we have a sequence of one conditional and one unconditional branch\n-    \/\/and we are trying to merge them with reversed condition\n-    private final CodeTransform LOOKING_FOR_DOUBLE_JUMP = new CodeTransform() {\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            switch (coe) {\n-                case LabelTarget lt -> {\n-                    if (secondBranch.target() == lt.label()) {\n-                        \/\/second branch has been identified as short-circuit\n-                        \/\/so we move to LOOKING_FOR_SHORT_JUMP state\n-                        \/\/and replay all pseudo instructions from the second buffer\n-                        \/\/as there might be another short target\n-                        activeState = LOOKING_FOR_SHORT_JUMP;\n-                        pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n-                        pseudoBuffer2.clear();\n-                        activeState.accept(cob, lt);\n-                    } else if (firstBranch.target() == lt.label()) {\n-                        \/\/double branch has been detected\n-                        \/\/we replace firstBranch instruction with reverted condition and secondBranch target\n-                        \/\/move to LOOKING_FOR_SHORT_JUMP state and replay pseudoBuffer2\n-                        firstBranch = BranchInstruction.of(reverseBranchOpcode(firstBranch.opcode()), secondBranch.target());\n-                        activeState = LOOKING_FOR_SHORT_JUMP;\n-                        pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n-                        pseudoBuffer2.clear();\n-                        activeState.accept(cob, lt);\n-                    } else {\n-                        \/\/here we buffer the label as a pseudo instruction following the secondBranch\n-                        pseudoBuffer2.add(lt);\n-                    }\n-                }\n-                case PseudoInstruction pi -> {\n-                    \/\/here we buffer pseudo instructions following the secondBranch\n-                    pseudoBuffer2.add(pi);\n-                }\n-                case BranchInstruction bi -> {\n-                    \/\/third branch has been detected, so we flush the firstBranch and its pseudo instructions\n-                    \/\/move to LOOKING_FOR_SHORT_JUMP state, shift secondBranch to the firstBranch\n-                    \/\/replay the secondBranch pseudo instructions and this actual branch\n-                    LOOKING_FOR_SHORT_JUMP.atEnd(cob);\n-                    activeState = LOOKING_FOR_SHORT_JUMP;\n-                    firstBranch = secondBranch;\n-                    pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n-                    pseudoBuffer2.clear();\n-                    activeState.accept(cob, bi);\n-                }\n-                default -> {\n-                    \/\/any other instruction flushes all the branches and buffered pseudo instructions\n-                    atEnd(cob);\n-                    activeState = INIT_STATE;\n-                    cob.with(coe);\n-                }\n+            case PseudoInstruction pi -> {\n+                \/\/buffer pseudo instructions\n+                buffer.add(pi);\n+            }\n+            default -> {\n+                \/\/any other instruction flushes the branch and buffer\n+                atEnd(cob);\n+                \/\/the code element is replayed\n+                accept(cob, coe);\n@@ -174,15 +82,0 @@\n-        @Override\n-        public void atEnd(CodeBuilder cob) {\n-            \/\/here we flush everything\n-            LOOKING_FOR_SHORT_JUMP.atEnd(cob);\n-            cob.accept(secondBranch);\n-            pseudoBuffer2.forEach(cob::with);\n-            pseudoBuffer2.clear();\n-        }\n-    };\n-\n-    private CodeTransform activeState = INIT_STATE;\n-\n-    @Override\n-    public void accept(CodeBuilder cob, CodeElement coe) {\n-        activeState.accept(cob, coe);\n@@ -190,1 +83,0 @@\n-\n@@ -193,23 +85,6 @@\n-        activeState.atEnd(cob);\n-    }\n-\n-    static Opcode reverseBranchOpcode(Opcode op) {\n-        return switch (op) {\n-            case IFEQ -> Opcode.IFNE;\n-            case IFNE -> Opcode.IFEQ;\n-            case IFLT -> Opcode.IFGE;\n-            case IFGE -> Opcode.IFLT;\n-            case IFGT -> Opcode.IFLE;\n-            case IFLE -> Opcode.IFGT;\n-            case IF_ICMPEQ -> Opcode.IF_ICMPNE;\n-            case IF_ICMPNE -> Opcode.IF_ICMPEQ;\n-            case IF_ICMPLT -> Opcode.IF_ICMPGE;\n-            case IF_ICMPGE -> Opcode.IF_ICMPLT;\n-            case IF_ICMPGT -> Opcode.IF_ICMPLE;\n-            case IF_ICMPLE -> Opcode.IF_ICMPGT;\n-            case IF_ACMPEQ -> Opcode.IF_ACMPNE;\n-            case IF_ACMPNE -> Opcode.IF_ACMPEQ;\n-            case IFNULL -> Opcode.IFNONNULL;\n-            case IFNONNULL -> Opcode.IFNULL;\n-            default -> throw new IllegalArgumentException(\"Unknown branch instruction: \" + op);\n-        };\n+        \/\/flush the branch\n+        cob.with(branch);\n+        branch = null;\n+        \/\/flush the buffer\n+        buffer.forEach(cob::with);\n+        buffer.clear();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":35,"deletions":160,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.classfile.Attributes;\n@@ -25,0 +26,1 @@\n+import java.lang.classfile.Instruction;\n@@ -26,0 +28,1 @@\n+import static java.lang.classfile.Opcode.*;\n@@ -29,0 +32,1 @@\n+import java.util.List;\n@@ -41,1 +45,1 @@\n-        var cc = ClassFile.of();\n+        var cc = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n@@ -44,6 +48,15 @@\n-                    var l1 = cob.newLabel();\n-                    cob.goto_(l1);\n-                    cob.labelBinding(l1);\n-                    l1 = cob.newLabel();\n-                    cob.goto_(l1);\n-                    cob.labelBinding(l1);\n+                    var l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .lineNumber(1)\n+                       .labelBinding(l)\n+                       .nop();\n+\n+                    l = cob.newLabel();\n+                    cob.goto_w(l) \/\/compact\n+                       .lineNumber(2)\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .labelBinding(l);\n+\n@@ -51,23 +64,3 @@\n-                    cob.ifThenElse(tb -> {\n-                        var l2 = tb.newLabel();\n-                        tb.goto_(l2);\n-                        tb.labelBinding(l2);\n-                        l2 = tb.newLabel();\n-                        tb.goto_(l2);\n-                        tb.labelBinding(l2);\n-                    }, eb -> {\n-                        var l2 = eb.newLabel();\n-                        eb.goto_(l2);\n-                        eb.labelBinding(l2);\n-                        l2 = eb.newLabel();\n-                        eb.goto_(l2);\n-                        eb.labelBinding(l2);\n-                    });\n-                    l1 = cob.newLabel();\n-                    cob.goto_(l1);\n-                    cob.labelBinding(l1);\n-                    l1 = cob.newLabel();\n-                    cob.goto_(l1);\n-                    cob.labelBinding(l1);\n-                    cob.return_();\n-                }))));\n+                    l = cob.newLabel();\n+                    cob.ifeq(l) \/\/do not compact\n+                       .labelBinding(l);\n@@ -75,3 +68,12 @@\n-        ClassPrinter.toYaml(clm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n-        \/\/only iconst_0 and return_ should remain\n-        Assert.assertEquals(clm.methods().get(0).code().get().elementList().size(), 2);\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/do not compact\n+                       .nop()\n+                       .labelBinding(l)\n+                       .return_();\n+                }))));\n+        var code = clm.methods().get(0).code().get();\n+        ClassPrinter.toYaml(code, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        Assert.assertEquals(\n+                code.elementList().stream().mapMulti((e, ec) -> {if (e instanceof Instruction i) ec.accept(i.opcode());}).toList(),\n+                List.of(NOP, ICONST_0, IFEQ, GOTO, NOP, RETURN));\n+        Assert.assertEquals(code.findAttribute(Attributes.LINE_NUMBER_TABLE).get().lineNumbers().size(), 2);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":35,"deletions":33,"binary":false,"changes":68,"status":"modified"}]}