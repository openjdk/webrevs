{"files":[{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+final class BranchCompactor implements CodeTransform {\n+\n+    private BranchInstruction firstBranch;\n+    private final List<PseudoInstruction> pseudoBuffer = new ArrayList<>();\n+\n+    private final CodeTransform INIT_STATE = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            if (coe instanceof BranchInstruction bi) {\n+                firstBranch = bi;\n+                activeState = LOOKING_FOR_TARGET;\n+            } else {\n+                cob.with(coe);\n+            }\n+        }\n+    };\n+\n+    private final CodeTransform LOOKING_FOR_TARGET = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case LabelTarget lt -> {\n+                    if (firstBranch.target() == lt.label()) {\n+                        pseudoBuffer.forEach(cob::with);\n+                        pseudoBuffer.clear();\n+                        activeState = INIT_STATE;\n+                        cob.with(coe);\n+                    } else {\n+                        pseudoBuffer.add(lt);\n+                    }\n+                }\n+                case PseudoInstruction pi -> {\n+                    pseudoBuffer.add(pi);\n+                }\n+                case BranchInstruction bi -> {\n+                    atEnd(cob);\n+                    firstBranch = bi;\n+                }\n+                default -> {\n+                    atEnd(cob);\n+                    activeState = INIT_STATE;\n+                    cob.with(coe);\n+                }\n+            }\n+        }\n+        @Override\n+        public void atEnd(CodeBuilder cob) {\n+            cob.accept(firstBranch);\n+            pseudoBuffer.forEach(cob::with);\n+            pseudoBuffer.clear();\n+        }\n+    };\n+\n+    private CodeTransform activeState = INIT_STATE;\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        activeState.accept(cob, coe);\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        activeState.atEnd(cob);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -123,1 +123,1 @@\n-                        cob -> {\n+                        cb -> cb.transforming(new BranchCompactor(), cob -> {\n@@ -126,1 +126,1 @@\n-                        }));\n+                        })));\n@@ -388,10 +388,0 @@\n-    private static void branch(CodeBuilder cob, ConversionContext c, List<Block> blocks, Block source, Block target) {\n-        int bi = blocks.indexOf(source);\n-        int si = blocks.indexOf(target);\n-        \/\/ If successor occurs immediately after this block,\n-        \/\/ then no need for goto instruction\n-        if (bi != si - 1) {\n-            cob.goto_(c.getLabel(target));\n-        }\n-    }\n-\n@@ -709,1 +699,1 @@\n-                    branch(cob, c, blocks, b, op.branch().targetBlock());\n+                    cob.goto_(c.getLabel(op.branch().targetBlock()));\n@@ -718,1 +708,1 @@\n-                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n@@ -722,1 +712,1 @@\n-                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n@@ -729,1 +719,1 @@\n-                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n@@ -733,1 +723,1 @@\n-                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n@@ -745,1 +735,1 @@\n-                    branch(cob, c, blocks, b, op.end().targetBlock());\n+                    cob.goto_(c.getLabel(op.end().targetBlock()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNew.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}