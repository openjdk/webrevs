{"files":[{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * BranchCompactor is a CodeTransform working as a state machine.\n+ * It identifies and compacts redundant sequences of branches in a single pass.\n+ *\/\n+final class BranchCompactor implements CodeTransform {\n+\n+    private BranchInstruction firstBranch, secondBranch;\n+    private final List<PseudoInstruction> pseudoBuffer1 = new ArrayList<>(),\n+                                          pseudoBuffer2 = new ArrayList<>();\n+\n+    \/\/BranchCompactor is in INIT_STATE until a branch instruction appears\n+    private final CodeTransform INIT_STATE = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            if (coe instanceof BranchInstruction bi) {\n+                firstBranch = bi;\n+                activeState = LOOKING_FOR_SHORT_JUMP;\n+            } else {\n+                \/\/all other instructions and pseudo instrutions are passed\n+                cob.with(coe);\n+            }\n+        }\n+    };\n+\n+    \/\/In this state we are looking for immediate target of the firstBranch\n+    \/\/or also for a second (unconditional) branch when the firstBranch is conditional\n+    \/\/all pseudo instructions are buffered as they do not represent a real bytecode\n+    private final CodeTransform LOOKING_FOR_SHORT_JUMP = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case LabelTarget lt -> {\n+                    if (firstBranch.target() == lt.label()) {\n+                        \/\/here we have immediate target, so the first branch is skipped\n+                        \/\/all pseudo instructions are passed (including the actual target)\n+                        \/\/and BranchCompactor returns to INIT_STATE\n+                        pseudoBuffer1.forEach(cob::with);\n+                        pseudoBuffer1.clear();\n+                        activeState = INIT_STATE;\n+                        cob.with(coe);\n+                    } else {\n+                        \/\/here we buffer the label as a pseudo instructions\n+                        pseudoBuffer1.add(lt);\n+                    }\n+                }\n+                case PseudoInstruction pi -> {\n+                    \/\/here we buffer pseudo instructions\n+                    pseudoBuffer1.add(pi);\n+                }\n+                case BranchInstruction bi -> {\n+                    if (!firstBranch.opcode().isUnconditionalBranch() && bi.opcode().isUnconditionalBranch()) {\n+                        \/\/second (unconditional) branch appears and the firstBranch is conditional\n+                        \/\/so the BranchCompactor moves to LOOKING_FOR_DOUBLE_JUMP state\n+                        secondBranch = bi;\n+                        activeState = LOOKING_FOR_DOUBLE_JUMP;\n+                    } else {\n+                        \/\/branches do not meet criteria to look for double jumps\n+                        \/\/so we flush the firstBranch and all buffered pseudo instructions\n+                        \/\/and continue in this state with a new firstBranch\n+                        atEnd(cob);\n+                        firstBranch = bi;\n+                    }\n+                }\n+                default -> {\n+                    \/\/any other instruction flushes the firstBranch and pseudo instructions\n+                    \/\/and returns BranchCompactor to INIT_STATE\n+                    atEnd(cob);\n+                    activeState = INIT_STATE;\n+                    cob.with(coe);\n+                }\n+            }\n+        }\n+        @Override\n+        public void atEnd(CodeBuilder cob) {\n+            \/\/here we flush the firstBranch and pseudo instructions\n+            cob.accept(firstBranch);\n+            pseudoBuffer1.forEach(cob::with);\n+            pseudoBuffer1.clear();\n+        }\n+    };\n+\n+    \/\/This state assumes we have a sequence of one conditional and one unconditional branch\n+    \/\/and we are trying to merge them with reversed condition\n+    private final CodeTransform LOOKING_FOR_DOUBLE_JUMP = new CodeTransform() {\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            switch (coe) {\n+                case LabelTarget lt -> {\n+                    if (secondBranch.target() == lt.label()) {\n+                        \/\/second branch has been identified as short-circuit\n+                        \/\/so we move to LOOKING_FOR_SHORT_JUMP state\n+                        \/\/and replay all pseudo instructions from the second buffer\n+                        \/\/as there might be another short target\n+                        activeState = LOOKING_FOR_SHORT_JUMP;\n+                        pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n+                        pseudoBuffer2.clear();\n+                        activeState.accept(cob, lt);\n+                    } else if (firstBranch.target() == lt.label()) {\n+                        \/\/double branch has been detected\n+                        \/\/we replace firstBranch instruction with reverted condition and secondBranch target\n+                        \/\/move to LOOKING_FOR_SHORT_JUMP state and replay pseudoBuffer2\n+                        firstBranch = BranchInstruction.of(reverseBranchOpcode(firstBranch.opcode()), secondBranch.target());\n+                        activeState = LOOKING_FOR_SHORT_JUMP;\n+                        pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n+                        pseudoBuffer2.clear();\n+                        activeState.accept(cob, lt);\n+                    } else {\n+                        \/\/here we buffer the label as a pseudo instruction following the secondBranch\n+                        pseudoBuffer2.add(lt);\n+                    }\n+                }\n+                case PseudoInstruction pi -> {\n+                    \/\/here we buffer pseudo instructions following the secondBranch\n+                    pseudoBuffer2.add(pi);\n+                }\n+                case BranchInstruction bi -> {\n+                    \/\/third branch has been detected, so we flush the firstBranch and its pseudo instructions\n+                    \/\/move to LOOKING_FOR_SHORT_JUMP state, shift secondBranch to the firstBranch\n+                    \/\/replay the seconBranch pseudo instructions and this actual branch\n+                    LOOKING_FOR_SHORT_JUMP.atEnd(cob);\n+                    activeState = LOOKING_FOR_SHORT_JUMP;\n+                    firstBranch = secondBranch;\n+                    pseudoBuffer2.forEach(pi -> activeState.accept(cob, pi));\n+                    pseudoBuffer2.clear();\n+                    activeState.accept(cob, bi);\n+                }\n+                default -> {\n+                    \/\/any other instruction flushes all the branches and buffered pseudo instructions\n+                    atEnd(cob);\n+                    activeState = INIT_STATE;\n+                    cob.with(coe);\n+                }\n+            }\n+        }\n+        @Override\n+        public void atEnd(CodeBuilder cob) {\n+            \/\/here we flush everything\n+            LOOKING_FOR_SHORT_JUMP.atEnd(cob);\n+            cob.accept(secondBranch);\n+            pseudoBuffer2.forEach(cob::with);\n+            pseudoBuffer2.clear();\n+        }\n+    };\n+\n+    private CodeTransform activeState = INIT_STATE;\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        activeState.accept(cob, coe);\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        activeState.atEnd(cob);\n+    }\n+\n+    static Opcode reverseBranchOpcode(Opcode op) {\n+        return switch (op) {\n+            case IFEQ -> Opcode.IFNE;\n+            case IFNE -> Opcode.IFEQ;\n+            case IFLT -> Opcode.IFGE;\n+            case IFGE -> Opcode.IFLT;\n+            case IFGT -> Opcode.IFLE;\n+            case IFLE -> Opcode.IFGT;\n+            case IF_ICMPEQ -> Opcode.IF_ICMPNE;\n+            case IF_ICMPNE -> Opcode.IF_ICMPEQ;\n+            case IF_ICMPLT -> Opcode.IF_ICMPGE;\n+            case IF_ICMPGE -> Opcode.IF_ICMPLT;\n+            case IF_ICMPGT -> Opcode.IF_ICMPLE;\n+            case IF_ICMPLE -> Opcode.IF_ICMPGT;\n+            case IF_ACMPEQ -> Opcode.IF_ACMPNE;\n+            case IF_ACMPNE -> Opcode.IF_ACMPEQ;\n+            case IFNULL -> Opcode.IFNONNULL;\n+            case IFNONNULL -> Opcode.IFNULL;\n+            default -> throw new IllegalArgumentException(\"Unknown branch instruction: \" + op);\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -38,3 +38,0 @@\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.Instruction;\n@@ -46,2 +43,0 @@\n-import java.lang.classfile.instruction.BranchInstruction;\n-import java.lang.classfile.instruction.LabelTarget;\n@@ -60,1 +55,0 @@\n-import java.lang.reflect.code.Block.Reference;\n@@ -69,1 +63,0 @@\n-import java.util.Collections;\n@@ -119,16 +112,0 @@\n-    private static class DebugTransform implements CodeTransform {\n-        private int bci = 0;\n-\n-        @Override\n-        public void accept(CodeBuilder cob, CodeElement coe) {\n-            cob.accept(coe);\n-            switch (coe) {\n-                case LabelTarget lt -> System.out.println(bci + \": \" + lt + \" (\" + lt.label().hashCode() + \")\");\n-                case BranchInstruction bi -> System.out.println(bci + \": \" + bi + \" (\" + bi.target().hashCode() + \")\");\n-                default -> System.out.println(bci + \": \" + coe);\n-            }\n-            if (coe instanceof Instruction ins) bci += ins.sizeInBytes();\n-        }\n-\n-    }\n-\n@@ -146,1 +123,1 @@\n-                        cb -> cb.transforming(new DebugTransform(), cob -> {\n+                        cb -> cb.transforming(new BranchCompactor(), cob -> {\n@@ -170,1 +147,0 @@\n-        final Map<Block, ExceptionRegionNode> coveredBlocks;\n@@ -180,1 +156,0 @@\n-            this.coveredBlocks = new HashMap<>();\n@@ -210,1 +185,0 @@\n-\n@@ -215,4 +189,0 @@\n-        int getOrAssignSlot(Value v) {\n-            return getOrAssignSlot(v, false);\n-        }\n-\n@@ -348,9 +318,0 @@\n-    record ExceptionRegionNode(CoreOps.ExceptionRegionEnter ere, int size, ExceptionRegionNode next) {\n-    }\n-\n-    static final ExceptionRegionNode NIL = new ExceptionRegionNode(null, 0, null);\n-\n-    private static void computeExceptionRegionMembership(Body r, ConversionContext c) {\n-        Set<Block> visited = new HashSet<>();\n-        Deque<Block> stack = new ArrayDeque<>();\n-        stack.push(r.entryBlock());\n@@ -358,4 +319,19 @@\n-        \/\/ Set of catching blocks\n-        Set<Block> catchingBlocks = c.catchingBlocks;\n-        \/\/ Map of block to stack of covered exception regions\n-        Map<Block, ExceptionRegionNode> coveredBlocks = c.coveredBlocks;\n+    private static void computeExceptionRegionMembership(Body body, CodeBuilder cob, ConversionContext c) {\n+        final List<Block> blocks = body.blocks();\n+        record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {\n+        }\n+        \/\/ List of all regions\n+        final List<ExceptionRegionWithBlocks> allRegions = new ArrayList<>();\n+        class BlockWithActiveExceptionRegions {\n+            final Block block;\n+            final BitSet activeRegionStack;\n+            BlockWithActiveExceptionRegions(Block block, BitSet activeRegionStack) {\n+                this.block = block;\n+                this.activeRegionStack = activeRegionStack;\n+                int index = blocks.indexOf(block);\n+                activeRegionStack.stream().forEach(r -> allRegions.get(r).blocks.set(index));\n+            }\n+        }\n+        final Set<Block> visited = new HashSet<>();\n+        final Deque<BlockWithActiveExceptionRegions> stack = new ArrayDeque<>();\n+        stack.push(new BlockWithActiveExceptionRegions(body.entryBlock(), new BitSet()));\n@@ -364,1 +340,2 @@\n-            Block b = stack.pop();\n+            BlockWithActiveExceptionRegions bm = stack.pop();\n+            Block b = bm.block;\n@@ -368,1 +345,0 @@\n-\n@@ -370,1 +346,0 @@\n-            ExceptionRegionNode bRegions = coveredBlocks.get(b);\n@@ -372,5 +347,1 @@\n-                if (bRegions != null) {\n-                    coveredBlocks.put(bop.branch().targetBlock(), bRegions);\n-                }\n-\n-                stack.push(bop.branch().targetBlock());\n+                stack.push(new BlockWithActiveExceptionRegions(bop.branch().targetBlock(), bm.activeRegionStack));\n@@ -378,7 +349,2 @@\n-                if (bRegions != null) {\n-                    coveredBlocks.put(cop.falseBranch().targetBlock(), bRegions);\n-                    coveredBlocks.put(cop.trueBranch().targetBlock(), bRegions);\n-                }\n-\n-                stack.push(cop.falseBranch().targetBlock());\n-                stack.push(cop.trueBranch().targetBlock());\n+                stack.push(new BlockWithActiveExceptionRegions(cop.falseBranch().targetBlock(), bm.activeRegionStack));\n+                stack.push(new BlockWithActiveExceptionRegions(cop.trueBranch().targetBlock(), bm.activeRegionStack));\n@@ -386,16 +352,3 @@\n-                ArrayList<Block.Reference> catchBlocks = new ArrayList<>(er.catchBlocks());\n-                Collections.reverse(catchBlocks);\n-                for (Block.Reference catchBlock : catchBlocks) {\n-                    catchingBlocks.add(catchBlock.targetBlock());\n-                    if (bRegions != null) {\n-                        coveredBlocks.put(catchBlock.targetBlock(), bRegions);\n-                    }\n-\n-                    stack.push(catchBlock.targetBlock());\n-                }\n-\n-                ExceptionRegionNode n;\n-                if (bRegions != null) {\n-                    n = new ExceptionRegionNode(er, bRegions.size + 1, bRegions);\n-                } else {\n-                    n = new ExceptionRegionNode(er, 1, NIL);\n+                for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n+                    c.catchingBlocks.add(catchBlock.targetBlock());\n+                    stack.push(new BlockWithActiveExceptionRegions(catchBlock.targetBlock(), bm.activeRegionStack));\n@@ -403,3 +356,5 @@\n-                coveredBlocks.put(er.start().targetBlock(), n);\n-\n-                stack.push(er.start().targetBlock());\n+                BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                activeRegionStack.set(allRegions.size());\n+                ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n+                allRegions.add(newNode);\n+                stack.push(new BlockWithActiveExceptionRegions(er.start().targetBlock(), activeRegionStack));\n@@ -407,7 +362,3 @@\n-                assert bRegions != null;\n-\n-                if (bRegions.size() > 1) {\n-                    coveredBlocks.put(er.end().targetBlock(), bRegions.next());\n-                }\n-\n-                stack.push(er.end().targetBlock());\n+                BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                activeRegionStack.clear(activeRegionStack.length() - 1);\n+                stack.push(new BlockWithActiveExceptionRegions(er.end().targetBlock(), activeRegionStack));\n@@ -416,9 +367,18 @@\n-    }\n-\n-    private static void branch(CodeBuilder cob, ConversionContext c, List<Block> blocks, Block source, Block target) {\n-        int bi = blocks.indexOf(source);\n-        int si = blocks.indexOf(target);\n-        \/\/ If successor occurs immediately after this block,\n-        \/\/ then no need for goto instruction\n-        if (bi != si - 1) {\n-            cob.goto_(c.getLabel(target));\n+        \/\/ Declare the exception regions\n+        for (ExceptionRegionWithBlocks erNode : allRegions.reversed()) {\n+            int start  = erNode.blocks.nextSetBit(0);\n+            while (start >= 0) {\n+                int end = erNode.blocks.nextClearBit(start);\n+                Label startLabel = c.getLabel(blocks.get(start));\n+                Label endLabel = c.getLabel(blocks.get(end));\n+                for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                    Block cb = cbr.targetBlock();\n+                    if (!cb.parameters().isEmpty()) {\n+                        ClassDesc type = cb.parameters().get(0).type().toNominalDescriptor();\n+                        cob.exceptionCatch(startLabel, endLabel, c.getLabel(cb), type);\n+                    } else {\n+                        cob.exceptionCatchAll(startLabel, endLabel, c.getLabel(cb));\n+                    }\n+                }\n+                start = erNode.blocks.nextSetBit(end);\n+            }\n@@ -429,1 +389,1 @@\n-        computeExceptionRegionMembership(body, c);\n+        computeExceptionRegionMembership(body, cob, c);\n@@ -455,2 +415,0 @@\n-\/\/                clb.parameter(ex.type());\n-\n@@ -741,1 +699,1 @@\n-                    branch(cob, c, blocks, b, op.branch().targetBlock());\n+                    cob.goto_(c.getLabel(op.branch().targetBlock()));\n@@ -750,1 +708,1 @@\n-                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n@@ -754,1 +712,1 @@\n-                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n@@ -761,1 +719,1 @@\n-                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                    trueBuilder.goto_(c.getLabel(op.trueBranch().targetBlock()));\n@@ -765,1 +723,1 @@\n-                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                    falseBuilder.goto_(c.getLabel(op.falseBranch().targetBlock()));\n@@ -777,13 +735,1 @@\n-                    ExceptionRegionEnter enterOp = op.regionStart();\n-                    Label start = c.getLabel(enterOp.start().targetBlock());\n-                    Label end = cob.newBoundLabel();\n-                    for (Reference cbr : enterOp.catchBlocks()) {\n-                        Block cb = cbr.targetBlock();\n-                        if (!cb.parameters().isEmpty()) {\n-                            ClassDesc type = cb.parameters().get(0).type().toNominalDescriptor();\n-                            cob.exceptionCatch(start, end, c.getLabel(cb), type);\n-                        } else {\n-                            cob.exceptionCatchAll(start, end, c.getLabel(cb));\n-                        }\n-                    }\n-                    branch(cob, c, blocks, b, op.end().targetBlock());\n+                    cob.goto_(c.getLabel(op.end().targetBlock()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":61,"deletions":115,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNew.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -131,2 +130,1 @@\n-    @Test(enabled = false)\n-    \/\/finalizer in exception handler is invalid (missing exception.region.exit)\n+    @Test\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -87,2 +86,1 @@\n-    @Test(enabled = false)\n-    \/\/finalizer in exception handler is invalid (missing exception.region.exit)\n+    @Test\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}