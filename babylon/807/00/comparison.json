{"files":[{"patch":"@@ -108,3 +108,1 @@\n-        try {\n-            Class<?> aClass = Class.forName(klass.getName());\n-            Method[] declaredMethods = aClass.getDeclaredMethods();\n+            Method[] declaredMethods = klass.getDeclaredMethods();\n@@ -162,4 +160,0 @@\n-\n-        } catch (ClassNotFoundException e) {\n-            IO.println(\"Error during materialization of DeviceType: \" + e.getMessage());\n-        }\n","filename":"hat\/core\/src\/main\/java\/hat\/device\/DeviceSchema.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -33,0 +34,1 @@\n+import optkl.OpTkl;\n@@ -34,0 +36,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -45,1 +48,1 @@\n-    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp, int param) {\n+    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, int param) {\n@@ -48,1 +51,1 @@\n-            return getVectorTypeInfoWithCodeReflection(varLoadOp.resultType());\n+            return getVectorTypeInfoWithCodeReflection(lookup,varLoadOp.resultType());\n@@ -53,2 +56,2 @@\n-    public static VectorMetaData getVectorTypeInfo(JavaOp.InvokeOp invokeOp) {\n-        return getVectorTypeInfoWithCodeReflection(invokeOp.resultType());\n+    public static VectorMetaData getVectorTypeInfo(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp) {\n+        return getVectorTypeInfoWithCodeReflection(lookup,invokeOp.resultType());\n@@ -80,9 +83,3 @@\n-    public static VectorMetaData getVectorTypeInfoWithCodeReflection(TypeElement typeElement) {\n-        Class<?> aClass;\n-        try {\n-            aClass = Class.forName(typeElement.toString());\n-        } catch (ClassNotFoundException e) {\n-            \/\/ TODO: Add control for exceptions in HAT (HATExceptions Handler)\n-            throw new RuntimeException(e);\n-        }\n-        CoreOp.FuncOp codeModelType = buildCodeModelFor(aClass, \"type\");\n+    public static VectorMetaData getVectorTypeInfoWithCodeReflection(MethodHandles.Lookup lookup,TypeElement typeElement) {\n+        Class<?> clazz = (Class<?>)OpTkl.classTypeToTypeOrThrow(lookup, (ClassType) typeElement);\n+        CoreOp.FuncOp codeModelType = buildCodeModelFor(clazz, \"type\");\n@@ -101,1 +98,1 @@\n-        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(aClass, \"width\");\n+        CoreOp.FuncOp codeModelWidth = buildCodeModelFor(clazz, \"width\");\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPhaseUtils.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.types._V;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import optkl.OpTkl;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-\n-import static optkl.Invoke.invokeOpHelper;\n-import static optkl.OpTkl.isAssignable;\n-\n-\/**\n- * This class needs refactoring\n- *\n- * It seems to be a reimplementation of Optkl isAssignable\n- *\/\n-public class RefactorMe {\n-    private static void inspectNewLevel(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n-        if (interfaceClass != null && interfaceSet.add(interfaceClass)) {\n-            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n-            Arrays.stream(interfaceClass.getInterfaces())\n-                    .forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n-        }\n-    }\n-\n-\n-    public static Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n-        Set<Class<?>> interfaceSet = new HashSet<>();\n-        while (klass != null) {\n-            Arrays.stream(klass.getInterfaces())\n-                    .forEach(interfaceClass -> RefactorMe.inspectNewLevel(interfaceClass, interfaceSet));\n-            klass = klass.getSuperclass();\n-        }\n-        return interfaceSet;\n-    }\n-\n-\n-    public  static boolean  isVectorOperation(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n-        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            Set<Class<?>> interfaces = Set.of();\n-            try {\n-                Class<?> aClass = Class.forName(typeElement.toString());\n-                interfaces = inspectAllInterfaces(aClass);\n-            } catch (ClassNotFoundException _) {\n-            }\n-            return interfaces.contains(_V.class) && invokeOpHelper(lookup, invokeOp).named( namePredicate);\n-        }\n-        return false;\n-    }\n-    public static boolean isAMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-        return namePredicate.test(invokeOp.invokeDescriptor().name());\n-    }\n-    public  static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n-        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            Set<Class<?>> interfaces = Set.of();\n-            try {\n-                Class<?> aClass = Class.forName(typeElement.toString());\n-                interfaces = inspectAllInterfaces(aClass);\n-            } catch (ClassNotFoundException _) {\n-            }\n-            return interfaces.contains(_V.class) && isAMethod(invokeOp, namePredicate);\n-        }\n-        return false;\n-    }\n-    public static boolean isInvokeDescriptorSubtypeOf(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Class<?> klass) {\n-\n-        var wouldReturn = (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt, klass));\n-\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        var butReturns = interfaces.contains(klass);\n-        if (butReturns != wouldReturn) {\n-            \/\/ System.out.print(\"isInvokeDescriptorSubtypeOf\");\n-        }\n-        return butReturns;\n-\n-    }\n-\n-    public static boolean isInvokeDescriptorSubtypeOfAnyMatch(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Class<?>... klasses) {\n-\n-        boolean wouldReturn = (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt, klasses));\n-        boolean butReturns = false;\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        for (Class<?> klass : klasses) {\n-            if (interfaces.contains(klass)) {\n-                butReturns = true;\n-            }\n-        }\n-        if (butReturns != wouldReturn) {\n-            \/\/   System.out.print(\"isInvokeDescriptorSubtypeOfAnyMatch\");\n-        }\n-        return butReturns;\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RefactorMe.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -100,1 +100,1 @@\n-                            var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(varOp.resultType().valueType());\n+                            var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),varOp.resultType().valueType());\n@@ -145,1 +145,1 @@\n-                                var  hatVectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(arrayLoadOp.resultType());\n+                                var  hatVectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),arrayLoadOp.resultType());\n@@ -183,1 +183,1 @@\n-                                var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(classType);\n+                                var vectorMetaData = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),classType);\n@@ -308,1 +308,1 @@\n-        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(resultType);\n+        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(lookup(),resultType);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.optools.RefactorMe;\n@@ -36,0 +35,1 @@\n+import jdk.incubator.code.TypeElement;\n@@ -39,0 +39,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -43,0 +44,1 @@\n+import java.util.Arrays;\n@@ -52,0 +54,1 @@\n+import static optkl.OpTkl.isAssignable;\n@@ -187,8 +190,0 @@\n-\n-        private boolean meetConditionsForMemoryLoadOp(Invoke invoke) {\n-            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invoke.op(), DeviceType.class)\n-                    && !invoke.returnsVoid()\n-                    && !invoke.returnsPrimitive()\n-                    && !reservedMethods.contains(invoke.name());\n-        }\n-\n@@ -202,2 +197,5 @@\n-                        if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n-                            if (meetConditionsForMemoryLoadOp(invoke)) {\n+                        if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                             && invoke.refIs(DeviceType.class)\n+                                    && !invoke.returnsVoid()\n+                                    && !invoke.returnsPrimitive()\n+                                    && !reservedMethods.contains(invoke.name())) {\n@@ -213,1 +211,1 @@\n-                            }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.Invoke;\n@@ -52,2 +52,1 @@\n-import static hat.optools.RefactorMe.isAMethod;\n-import static optkl.OpTkl.isAssignable;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -153,6 +152,3 @@\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n-           return (invokeOp.resultType() instanceof JavaType jt\n-                   && isAssignable(lookup(), jt, _V.class)\n-                   && isAMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n-           );\n-    }\n+   \/\/ private boolean isVectorOperation(Invoke invoke) {\n+     \/\/      return ;\n+   \/\/ }\n@@ -174,1 +170,1 @@\n-        VectorMetaData metaData = getVectorTypeInfo(invokeOp);\n+        VectorMetaData metaData = getVectorTypeInfo(lookup(),invokeOp);\n@@ -220,1 +216,1 @@\n-        VectorMetaData vectorMetaData = getVectorTypeInfo(invokeOp);\n+        VectorMetaData vectorMetaData = getVectorTypeInfo(lookup(),invokeOp);\n@@ -260,2 +256,3 @@\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (isVectorOperation(invokeOp)) {\n+                                if (invokeOpHelper(lookup(),result.op()) instanceof Invoke invoke) {\n+                                    if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)){\n+                                          \/\/  isVectorOperation(invokeOpHelper(lookup(),invokeOp))) {\n@@ -264,2 +261,2 @@\n-                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                                        vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                                        vectorMetaData.put(invoke.op(), vectorTypeInfo);\n@@ -267,1 +264,1 @@\n-                                        consumer.accept(invokeOp);\n+                                        consumer.accept(invoke.op());\n@@ -306,4 +303,4 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            consumer.accept(invokeOp);\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke\n+                         &&invoke.returns(_V.class) && invoke.named(vectorOperation.methodName) ) {\n+                            consumer.accept(invoke.op());\n+                            Set<Op.Result> uses = invoke.op().result().uses();\n@@ -313,2 +310,2 @@\n-                                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                                    vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                    VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                                    vectorMetaData.put(invoke.op(), vectorTypeInfo);\n@@ -319,1 +316,1 @@\n-                    }\n+\n@@ -350,6 +347,6 @@\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (isVectorOperation(invokeOp)) {\n-                                        BinaryOpEnum binaryOpType = BinaryOpEnum.of(invokeOp);\n-                                        binaryOperation.put(invokeOp, binaryOpType);\n-                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                                        vectorMetaData.put(invokeOp, vectorTypeInfo);\n+                                if (invokeOpHelper(lookup(),result.op()) instanceof Invoke invoke ) {\n+                                    if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                                        BinaryOpEnum binaryOpType = BinaryOpEnum.of(invoke.op());\n+                                        binaryOperation.put(invoke.op(), binaryOpType);\n+                                        VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                                        vectorMetaData.put(invoke.op(), vectorTypeInfo);\n@@ -357,1 +354,1 @@\n-                                        consumer.accept(invokeOp);\n+                                        consumer.accept(invoke.op());\n@@ -393,6 +390,6 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            consumer.accept(invokeOp);\n-                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(invokeOp);\n-                            vectorMetaData.put(invokeOp, vectorTypeInfo);\n-                            Set<Op.Result> uses = invokeOp.result().uses();\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n+                        if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                            consumer.accept(invoke.op());\n+                            VectorMetaData vectorTypeInfo = getVectorTypeInfo(lookup(),invoke.op());\n+                            vectorMetaData.put(invoke.op(), vectorTypeInfo);\n+                            Set<Op.Result> uses = invoke.op().result().uses();\n@@ -431,3 +428,3 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                    if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n+                        if (invoke.returns(_V.class) && invoke.named(vectorOperation.methodName)) {\n+                            List<Value> inputOperandsInvoke = invoke.op().operands();\n@@ -436,2 +433,2 @@\n-                                    BinaryOpEnum binaryOpType = BinaryOpEnum.of(invokeOp);\n-                                    binaryOperation.put(invokeOp, binaryOpType);\n+                                    BinaryOpEnum binaryOpType = BinaryOpEnum.of(invoke.op());\n+                                    binaryOperation.put(invoke.op(), binaryOpType);\n@@ -439,1 +436,1 @@\n-                                    consumer.accept(invokeOp);\n+                                    consumer.accept(invoke.op());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":39,"deletions":42,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.optools.RefactorMe;\n+import hat.types._V;\n@@ -39,0 +39,1 @@\n+import optkl.Invoke;\n@@ -45,0 +46,4 @@\n+\n+import static optkl.Invoke.invokeOpHelper;\n+import static optkl.OpTkl.asResultOrNull;\n+import static optkl.OpTkl.isAssignable;\n@@ -90,4 +95,7 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp\n-                        && (invokeOp.operands().size() >= 3) &&\n-                            (RefactorMe.isVectorOperation(invokeOp, invokeOp.operands().get(1), n->n.equals(vectorOperation)))) {\n-                            consumer.accept(invokeOp);\n+                    if (invokeOpHelper(lookup(),codeElement)instanceof Invoke invoke\n+                            && (invoke.op().operands().size() >2)\n+                            && invoke.named(vectorOperation)\n+                            && asResultOrNull(invoke.op().operands().get(1)) instanceof Op.Result result\n+                            && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                            && isAssignable(lookup(),varLoadOp.resultType(), _V.class)){\n+                            consumer.accept(invoke.op());\n@@ -108,1 +116,1 @@\n-                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(invokeOp, 1);\n+                HATPhaseUtils.VectorMetaData vectorMetaData  = HATPhaseUtils.getVectorTypeInfo(lookup(),invokeOp, 1);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,3 +53,3 @@\n-        try {\n-            boolean isit1=  OpTkl.isAssignable(lookup(),javaType,clazz);\n-            var basicType = javaType.toBasicType();\n+       \/\/ try {\n+            return  OpTkl.isAssignable(lookup(),javaType,clazz);\n+          \/*  var basicType = javaType.toBasicType();\n@@ -62,1 +62,1 @@\n-            return  isit2;\n+            return  isit1;*\/\n@@ -64,4 +64,4 @@\n-        } catch (ReflectiveOperationException e) {\n-            System.out.println(\"Hmm\");\n-            throw new RuntimeException(e);\n-        }\n+        \/\/} catch (ReflectiveOperationException e) {\n+          \/\/  System.out.println(\"Hmm\");\n+            \/\/throw new RuntimeException(e);\n+       \/\/ }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}