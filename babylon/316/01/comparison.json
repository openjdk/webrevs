{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -40,1 +41,2 @@\n-                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList());\n+                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList(),\n+                    attributes);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.math.BigInteger;\n@@ -9,1 +10,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -11,0 +11,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -197,5 +198,3 @@\n-        long expanded = Long.expand(number, 0x7f7f7f7f7f7f7f7fl);\n-        int bytesSize = Math.max(1, 8 - Long.numberOfLeadingZeros(expanded) \/ 8);\n-        for (int i = 1; i < bytesSize; i++) {\n-            buf.write(0x80 | (int)expanded & 0x7f);\n-            expanded >>= 8;\n+        for (int i = 64 - Long.numberOfLeadingZeros(number); i > 7; i -= 7) {\n+            buf.write(0x80 | (int)number & 0x7f);\n+            number >>= 7;\n@@ -203,1 +202,1 @@\n-        buf.write((int)expanded & 0x7f);\n+        buf.write((int)number & 0x7f);\n@@ -267,2 +266,1 @@\n-    \/\/ order of building defines order inside protobufs\n-    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<ElementType> inputElementTypes) {\n+    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<ElementType> inputElementTypes, List<Object> attributes) {\n@@ -272,4 +270,0 @@\n-                        .node(new NodeProto()\n-                            .forEach(schema.inputs(), (n, i) -> n.input(i.name()))\n-                            .forEach(schema.outputs(), (n, o) -> n.output(o.name()))\n-                            .op_type(schema.name()))\n@@ -279,1 +273,1 @@\n-                                        \/\/ inputValues matching schema inputs by OnnxParameter::ordinal\n+                                        \/\/ inputValues match schema inputs by OnnxParameter::ordinal\n@@ -281,0 +275,15 @@\n+                        .node(new NodeProto()\n+                            .forEach(schema.inputs(), (n, i) -> n.input(i.name()))\n+                            .forEach(schema.outputs(), (n, o) -> n.output(o.name()))\n+                            .op_type(schema.name())\n+                            .forEach(schema.attributes(), (n, a) -> {\n+                                \/\/ attributes match schema by OnnxAttribute::ordinal\n+                                var attrValue = attributes.get(a.ordinal());\n+                                if (a.isOptional()) {\n+                                    if (attrValue instanceof java.util.Optional o && o.isPresent()) {\n+                                        n.attribute(buildAttribute(a.name(), o.get()));\n+                                    }\n+                                } else {\n+                                    n.attribute(buildAttribute(a.name(), attrValue));\n+                                }\n+                            }))\n@@ -288,52 +297,4 @@\n-    private static int toElementType(TypeElement type) {\n-        if (type == OnnxType.TENSOR_FLOAT32) {\n-            return 1;\n-        } else if(type == OnnxType.TENSOR_UINT8) {\n-            return 2;\n-        } else if(type == OnnxType.TENSOR_INT8) {\n-            return 3;\n-        } else if(type == OnnxType.TENSOR_UINT16) {\n-            return 4;\n-        } else if(type == OnnxType.TENSOR_INT16) {\n-            return 5;\n-        } else if(type == OnnxType.TENSOR_INT32) {\n-            return 6;\n-        } else if(type == OnnxType.TENSOR_INT64) {\n-            return 7;\n-        } else if(type == OnnxType.TENSOR_STRING) {\n-            return 8;\n-        } else if(type == OnnxType.TENSOR_BOOL) {\n-            return 9;\n-        } else if(type == OnnxType.TENSOR_FLOAT16) {\n-            return 10;\n-        } else if(type == OnnxType.TENSOR_FLOAT64) {\n-            return 11;\n-        } else if(type == OnnxType.TENSOR_UINT32) {\n-            return 12;\n-        } else if(type == OnnxType.TENSOR_UINT64) {\n-            return 13;\n-        } else if(type == OnnxType.TENSOR_COMPLEX64) {\n-            return 14;\n-        } else if(type == OnnxType.TENSOR_COMPLEX128) {\n-            return 15;\n-        } else if(type == OnnxType.TENSOR_BFLOAT16) {\n-            return 16;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FN) {\n-            return 17;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FNUZ) {\n-            return 18;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2) {\n-            return 19;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2FNUZ) {\n-            return 20;\n-        } else if(type == OnnxType.TENSOR_UINT4) {\n-            return 21;\n-        } else if(type == OnnxType.TENSOR_INT4) {\n-            return 22;\n-        } else if(type == OnnxType.TENSOR_FLOAT4E2M1) {\n-            return 23;\n-        } else {\n-            throw new RuntimeException(type.toString());\n-        }\n-    }\n-\n+    \/\/ @@@ unchecked constraints:\n+    \/\/         tensor FuncOp parameters and single tensor return type\n+    \/\/         OnnxOps (with tensor operands and single tensor return value) and ReturnOp (returning single tensor)\n+    \/\/         entry block only\n@@ -343,1 +304,4 @@\n-                return computeIfAbsent(v, _ -> \"#\" + size());\n+                return computeIfAbsent(v, _ -> {\n+                    System.out.println(model.funcName() + \" \" + v + \" #\" + size());\n+                    return \"#\" + size();\n+                });\n@@ -350,0 +314,4 @@\n+                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto()\n+                                .name(indexer.getName(p))\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n@@ -351,5 +319,12 @@\n-                            if (op instanceof OnnxOp) {\n-                                g.node(new NodeProto()\n-                                        .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n-                                        .output(indexer.getName(op.result()))\n-                                        .op_type(op.opName()));\n+                            switch (op) {\n+                                case OnnxOp onnxOp ->\n+                                    g.node(new NodeProto()\n+                                            .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n+                                            .output(indexer.getName(op.result()))\n+                                            .op_type(op.opName())\n+                                            .forEach(onnxOp.onnxAttributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue()))));\n+                                case CoreOp.ReturnOp _ -> {\n+                                     \/\/ skip\n+                                }\n+                                default ->\n+                                    throw new UnsupportedOperationException(op.toText());\n@@ -358,4 +333,0 @@\n-                        .forEach(model.parameters(), (g, p) -> g.input(new ValueInfoProto()\n-                                .name(indexer.getName(p))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(toElementType(p.type()))))))\n@@ -365,1 +336,1 @@\n-                                        .tensor_type(new Tensor().elem_type(toElementType(model.body().yieldType()))))))\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)model.body().yieldType()).eType().id())))))\n@@ -370,0 +341,24 @@\n+\n+    static Attribute buildAttribute(String name, Object value) {\n+        var attr = new Attribute().name(name);\n+        switch (value) {\n+            case Float f -> {\n+                attr.type(2).f(f);\n+            }\n+            case Long l -> {\n+                attr.type(3).i(l);\n+            }\n+            case float[] floats -> {\n+                attr.type(6);\n+                for (float f : floats) attr.floats(f);\n+            }\n+            case long[] longs -> {\n+                attr.type(7);\n+                for (long l : longs) attr.ints(l);\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException(value.getClass().toString()); \/\/ @@@ ToDo\n+            }\n+        }\n+        return attr;\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":72,"deletions":77,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -12,1 +12,0 @@\n-import java.nio.LongBuffer;\n@@ -19,3 +18,1 @@\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n+import java.util.Optional;\n@@ -30,1 +27,1 @@\n-    private static final int LOG_LEVEL = 0; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n+    private static final int LOG_LEVEL = 3; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n@@ -176,2 +173,2 @@\n-    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues) {\n-        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues));\n+    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues, List<Object> attributes) {\n+        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues), attributes);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+        int ordinal();\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+        public abstract int id();\n@@ -483,0 +484,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 10;\n+        }\n@@ -496,0 +502,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 1;\n+        }\n@@ -509,0 +520,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 11;\n+        }\n@@ -521,0 +537,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 16;\n+        }\n@@ -533,0 +554,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 17;\n+        }\n@@ -545,0 +571,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 19;\n+        }\n@@ -557,0 +588,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 18;\n+        }\n@@ -569,0 +605,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 20;\n+        }\n@@ -581,0 +622,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 23;\n+        }\n@@ -593,0 +639,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 22;\n+        }\n@@ -605,0 +656,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 3;\n+        }\n@@ -617,0 +673,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 5;\n+        }\n@@ -629,0 +690,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 6;\n+        }\n@@ -641,0 +707,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 7;\n+        }\n@@ -653,0 +724,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 21;\n+        }\n@@ -665,0 +741,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 2;\n+        }\n@@ -677,0 +758,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 4;\n+        }\n@@ -689,0 +775,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 12;\n+        }\n@@ -701,0 +792,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 13;\n+        }\n@@ -713,0 +809,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 14;\n+        }\n@@ -725,0 +826,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 15;\n+        }\n@@ -737,0 +843,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 9;\n+        }\n@@ -749,0 +860,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 8;\n+        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-import java.nio.FloatBuffer;\n-import java.nio.LongBuffer;\n@@ -18,2 +16,2 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(FLOAT, FLOAT)));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(FLOAT, FLOAT)))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(FLOAT, FLOAT), List.of()));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(FLOAT, FLOAT), List.of()))) {\n@@ -37,1 +35,1 @@\n-            assertTensorEquals(absExpectedTensor, absOutputTensor);\n+            SimpleTest.assertEquals(absExpectedTensor, absOutputTensor);\n@@ -47,33 +45,1 @@\n-            assertTensorEquals(addExpectedTensor, addOutputTensor);\n-        }\n-    }\n-\n-    static void assertTensorEquals(OnnxRuntime.OrtTensor expectedTensor, OnnxRuntime.OrtTensor actualTensor) {\n-        var expectedType = expectedTensor.getTensorTypeAndShape();\n-        var expectedShape = expectedType.getShape();\n-\n-        var actualType = actualTensor.getTensorTypeAndShape();\n-        var actualShape = actualType.getShape();\n-\n-        assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n-        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n-            assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n-        }\n-\n-        assertEquals(expectedType.getTensorElementType(), actualType.getTensorElementType());\n-        assertEquals(expectedType.getTensorShapeElementCount(), actualType.getTensorShapeElementCount());\n-\n-        assertEqualData(expectedTensor.asByteBuffer().asFloatBuffer(), actualTensor.asByteBuffer().asFloatBuffer());\n-    }\n-\n-    static void assertEqualData(FloatBuffer expectedData, FloatBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n-        }\n-    }\n-\n-    static void assertEqualData(LongBuffer expectedData, LongBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i));\n+            SimpleTest.assertEquals(addExpectedTensor, addOutputTensor);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":4,"deletions":38,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -4,1 +4,4 @@\n-import java.util.List;\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.util.Arrays;\n@@ -6,0 +9,1 @@\n+import java.util.stream.Stream;\n@@ -10,0 +14,2 @@\n+import oracle.code.onnx.ir.OnnxOp;\n+import org.junit.jupiter.api.Assertions;\n@@ -12,2 +18,0 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-\n@@ -16,2 +20,0 @@\n-    \/\/ Java code model -> ONNX code model -> ONNX runtime instance -> execute via ORT\n-    \/\/ Run directly, each operation reflectively executes via ORT\n@@ -29,2 +31,27 @@\n-                new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"add\", Tensor.class, Tensor.class),\n-                        List.of(a.rtTensor, b.rtTensor)).getFirst()));\n+                runModel(\"add\", a, b));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstant() {\n+        return OnnxOperators.Constant(new float[]{-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testFconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE);\n+        assertEquals(expected, fconstant());\n+        assertEquals(expected, runModel(\"fconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstant() {\n+        return OnnxOperators.Constant(new long[]{-1, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testLconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1l, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE);\n+        assertEquals(expected, lconstant());\n+        assertEquals(expected, runModel(\"lconstant\"));\n@@ -42,3 +69,9 @@\n-        assertEquals(shape, reshapeAndShape(data, shape));\n-        assertEquals(shape, new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"reshapeAndShape\", Tensor.class, Tensor.class),\n-                        List.of(data.rtTensor, shape.rtTensor)).getFirst()));\n+        assertEquals(\n+                reshapeAndShape(data, shape),\n+                runModel(\"reshapeAndShape\", data, shape));\n+    }\n+\n+    private static Tensor runModel(String name, Tensor... params) throws NoSuchMethodException {\n+        return new Tensor(OnnxRuntime.getInstance().runFunc(\n+                getOnnxModel(name),\n+                Stream.of(params).map(t -> t.rtTensor).toList()).getFirst());\n@@ -47,1 +80,1 @@\n-    private static CoreOp.FuncOp getOnnxModel(String name, Class... params) throws NoSuchMethodException {\n+    private static CoreOp.FuncOp getOnnxModel(String name) throws NoSuchMethodException {\n@@ -49,1 +82,1 @@\n-                Op.ofMethod(SimpleTest.class.getDeclaredMethod(name, params)).get());\n+                Op.ofMethod(Stream.of(SimpleTest.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get()).get());\n@@ -52,4 +85,11 @@\n-    static void assertEquals(Tensor actual, Tensor expected) {\n-        var expectedTS = expected.rtTensor.getTensorTypeAndShape();\n-        var actualTS = actual.rtTensor.getTensorTypeAndShape();\n-        assertSame(expectedTS.getTensorElementType(), actualTS.getTensorElementType());\n+    static void assertEquals(Tensor expected, Tensor actual) {\n+        assertEquals(expected.rtTensor, actual.rtTensor);\n+    }\n+\n+    static void assertEquals(OnnxRuntime.OrtTensor expected, OnnxRuntime.OrtTensor actual) {\n+\n+        var expectedType = expected.getTensorTypeAndShape();\n+        var expectedShape = expectedType.getShape();\n+\n+        var actualType = actual.getTensorTypeAndShape();\n+        var actualShape = actualType.getShape();\n@@ -57,1 +97,1 @@\n-        \/\/ @@@ assert equal shapes\n+        Assertions.assertSame(expectedType.getTensorElementType(), actualType.getTensorElementType());\n@@ -59,1 +99,8 @@\n-        switch (actualTS.getTensorElementType()) {\n+        Assertions.assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n+        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n+            Assertions.assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n+        }\n+\n+        switch (actualType.getTensorElementType()) {\n+            case UINT8, INT8, UINT16, INT16, INT32, INT64, STRING, BOOL, UINT32, UINT64, UINT4, INT4 ->\n+                assertEquals(expected.asByteBuffer(), actual.asByteBuffer());\n@@ -61,3 +108,3 @@\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asFloatBuffer(), actual.rtTensor.asByteBuffer().asFloatBuffer());\n-            case INT64 ->\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asLongBuffer(), actual.rtTensor.asByteBuffer().asLongBuffer());\n+                assertEquals(expected.asByteBuffer().asFloatBuffer(), actual.asByteBuffer().asFloatBuffer());\n+            case DOUBLE ->\n+                assertEquals(expected.asByteBuffer().asDoubleBuffer(), actual.asByteBuffer().asDoubleBuffer());\n@@ -65,1 +112,22 @@\n-                throw new UnsupportedOperationException(); \/\/ @@@ ToDo\n+                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType.getTensorElementType());\n+        }\n+    }\n+\n+    static void assertEquals(ByteBuffer expectedData, ByteBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i));\n+        }\n+    }\n+\n+    static void assertEquals(FloatBuffer expectedData, FloatBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n+        }\n+    }\n+\n+    static void assertEquals(DoubleBuffer expectedData, DoubleBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":90,"deletions":22,"binary":false,"changes":112,"status":"modified"}]}