{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -40,1 +41,6 @@\n-                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList());\n+                    inputs.stream().map(o -> Optional.ofNullable(switch (o) {\n+                        case Tensor t -> t.rtTensor;\n+                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.rtTensor;\n+                        default -> null;\n+                    })).toList(),\n+                    attributes);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.math.BigInteger;\n@@ -9,1 +10,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -11,0 +11,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -197,5 +198,3 @@\n-        long expanded = Long.expand(number, 0x7f7f7f7f7f7f7f7fl);\n-        int bytesSize = Math.max(1, 8 - Long.numberOfLeadingZeros(expanded) \/ 8);\n-        for (int i = 1; i < bytesSize; i++) {\n-            buf.write(0x80 | (int)expanded & 0x7f);\n-            expanded >>= 8;\n+        for (int i = 64 - Long.numberOfLeadingZeros(number); i > 7; i -= 7) {\n+            buf.write(0x80 | (int)number & 0x7f);\n+            number >>= 7;\n@@ -203,1 +202,1 @@\n-        buf.write((int)expanded & 0x7f);\n+        buf.write((int)number & 0x7f);\n@@ -264,1 +263,1 @@\n-    static final int OPSET_VERSION = 14;\n+    static final int OPSET_VERSION = 21;\n@@ -267,2 +266,1 @@\n-    \/\/ order of building defines order inside protobufs\n-    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<ElementType> inputElementTypes) {\n+    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<java.util.Optional<ElementType>> inputElementTypes, List<Object> attributes) {\n@@ -272,0 +270,9 @@\n+                        .forEach(schema.inputs(), (g, i) -> {\n+                            if (inputElementTypes.get(i.ordinal()).isPresent()) {\n+                                g.input(new ValueInfoProto()\n+                                    .name(i.name())\n+                                    .type(new TypeProto()\n+                                            \/\/ inputValues match schema inputs by OnnxParameter::ordinal\n+                                            .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).get().id))));\n+                            }\n+                        })\n@@ -275,6 +282,12 @@\n-                            .op_type(schema.name()))\n-                        .forEach(schema.inputs(), (g, i) -> g.input(new ValueInfoProto()\n-                                .name(i.name())\n-                                .type(new TypeProto()\n-                                        \/\/ inputValues matching schema inputs by OnnxParameter::ordinal\n-                                        .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).id)))))\n+                            .op_type(schema.name())\n+                            .forEach(schema.attributes(), (n, a) -> {\n+                                \/\/ attributes match schema by OnnxAttribute::ordinal\n+                                var attrValue = attributes.get(a.ordinal());\n+                                if (a.isOptional()) {\n+                                    if (attrValue instanceof java.util.Optional o && o.isPresent()) {\n+                                        n.attribute(buildAttribute(a.name(), o.get()));\n+                                    }\n+                                } else {\n+                                    n.attribute(buildAttribute(a.name(), attrValue));\n+                                }\n+                            }))\n@@ -288,52 +301,4 @@\n-    private static int toElementType(TypeElement type) {\n-        if (type == OnnxType.TENSOR_FLOAT32) {\n-            return 1;\n-        } else if(type == OnnxType.TENSOR_UINT8) {\n-            return 2;\n-        } else if(type == OnnxType.TENSOR_INT8) {\n-            return 3;\n-        } else if(type == OnnxType.TENSOR_UINT16) {\n-            return 4;\n-        } else if(type == OnnxType.TENSOR_INT16) {\n-            return 5;\n-        } else if(type == OnnxType.TENSOR_INT32) {\n-            return 6;\n-        } else if(type == OnnxType.TENSOR_INT64) {\n-            return 7;\n-        } else if(type == OnnxType.TENSOR_STRING) {\n-            return 8;\n-        } else if(type == OnnxType.TENSOR_BOOL) {\n-            return 9;\n-        } else if(type == OnnxType.TENSOR_FLOAT16) {\n-            return 10;\n-        } else if(type == OnnxType.TENSOR_FLOAT64) {\n-            return 11;\n-        } else if(type == OnnxType.TENSOR_UINT32) {\n-            return 12;\n-        } else if(type == OnnxType.TENSOR_UINT64) {\n-            return 13;\n-        } else if(type == OnnxType.TENSOR_COMPLEX64) {\n-            return 14;\n-        } else if(type == OnnxType.TENSOR_COMPLEX128) {\n-            return 15;\n-        } else if(type == OnnxType.TENSOR_BFLOAT16) {\n-            return 16;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FN) {\n-            return 17;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FNUZ) {\n-            return 18;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2) {\n-            return 19;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2FNUZ) {\n-            return 20;\n-        } else if(type == OnnxType.TENSOR_UINT4) {\n-            return 21;\n-        } else if(type == OnnxType.TENSOR_INT4) {\n-            return 22;\n-        } else if(type == OnnxType.TENSOR_FLOAT4E2M1) {\n-            return 23;\n-        } else {\n-            throw new RuntimeException(type.toString());\n-        }\n-    }\n-\n+    \/\/ @@@ unchecked constraints:\n+    \/\/         tensor FuncOp parameters and single tensor return type\n+    \/\/         OnnxOps (with tensor operands and single tensor return value) and ReturnOp (returning single tensor)\n+    \/\/         entry block only\n@@ -350,0 +315,4 @@\n+                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto()\n+                                .name(indexer.getName(p))\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n@@ -351,5 +320,16 @@\n-                            if (op instanceof OnnxOp) {\n-                                g.node(new NodeProto()\n-                                        .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n-                                        .output(indexer.getName(op.result()))\n-                                        .op_type(op.opName()));\n+                            switch (op) {\n+                                case OnnxOp onnxOp ->\n+                                    g.node(new NodeProto()\n+                                            .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n+                                            .output(indexer.getName(op.result()))\n+                                            .op_type(op.opName())\n+                                            .forEach(onnxOp.onnxAttributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue()))));\n+                                case CoreOp.ReturnOp _ -> {\n+                                     \/\/ skip\n+                                }\n+                                case CoreOp.TupleLoadOp _ -> {\n+                                    \/\/ @@@ hack to forward to the first from the tuple\n+                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst()));\n+                                }\n+                                default ->\n+                                    throw new UnsupportedOperationException(op.toText());\n@@ -358,4 +338,0 @@\n-                        .forEach(model.parameters(), (g, p) -> g.input(new ValueInfoProto()\n-                                .name(indexer.getName(p))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(toElementType(p.type()))))))\n@@ -365,1 +341,1 @@\n-                                        .tensor_type(new Tensor().elem_type(toElementType(model.body().yieldType()))))))\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)model.body().yieldType()).eType().id())))))\n@@ -370,0 +346,24 @@\n+\n+    static Attribute buildAttribute(String name, Object value) {\n+        var attr = new Attribute().name(name);\n+        switch (value) {\n+            case Float f -> {\n+                attr.type(1).f(f);\n+            }\n+            case Long l -> {\n+                attr.type(2).i(l);\n+            }\n+            case float[] floats -> {\n+                attr.type(6);\n+                for (float f : floats) attr.floats(f);\n+            }\n+            case long[] longs -> {\n+                attr.type(7);\n+                for (long l : longs) attr.ints(l);\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException(value.getClass().toString()); \/\/ @@@ ToDo\n+            }\n+        }\n+        return attr;\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":78,"deletions":78,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -12,1 +12,0 @@\n-import java.nio.LongBuffer;\n@@ -19,3 +18,1 @@\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n+import java.util.Optional;\n@@ -30,1 +27,1 @@\n-    private static final int LOG_LEVEL = 0; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n+    private static final int LOG_LEVEL = 3; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n@@ -172,2 +169,2 @@\n-    private static List<Tensor.ElementType> toElementTypes(List<OrtTensor> values) {\n-        return values.stream().map(OrtTensor::getTensorTypeAndShape).map(OrtTensorTypeAndShapeInfo::getTensorElementType).toList();\n+    private static List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<OrtTensor>> values) {\n+        return values.stream().map(ot -> ot.map(OrtTensor::getTensorTypeAndShape).map(OrtTensorTypeAndShapeInfo::getTensorElementType)).toList();\n@@ -176,2 +173,2 @@\n-    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues) {\n-        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues));\n+    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<Optional<OrtTensor>> inputValues, List<Object> attributes) {\n+        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues), attributes);\n@@ -183,1 +180,1 @@\n-    public List<OrtTensor> runFunc(CoreOp.FuncOp model, List<OrtTensor> inputValues) {\n+    public List<OrtTensor> runFunc(CoreOp.FuncOp model, List<Optional<OrtTensor>> inputValues) {\n@@ -289,1 +286,1 @@\n-        public List<OrtTensor> run(List<OrtTensor> inputValues) {\n+        public List<OrtTensor> run(List<Optional<OrtTensor>> inputValues) {\n@@ -297,2 +294,4 @@\n-                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n-                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).valueAddress());\n+                if (inputValues.get(i).isPresent()) {\n+                    inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n+                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get().valueAddress());\n+                }\n@@ -330,1 +329,18 @@\n-        return createFlatTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), elementType);\n+        return createTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), elementType, new TensorShape(f.length() \/ elementType.size()));\n+    }\n+\n+    OrtTensor createScalar(long element) {\n+        return createScalar(arena.allocateFrom(JAVA_LONG, element), Tensor.ElementType.INT64);\n+    }\n+\n+    OrtTensor createScalar(float element) {\n+        return createScalar(arena.allocateFrom(JAVA_FLOAT, element), Tensor.ElementType.FLOAT);\n+    }\n+\n+    private OrtTensor createScalar(MemorySegment flatData, Tensor.ElementType elementType) {\n+        try {\n+            var allocatorInfo = retAddr(allocatorGetInfo.invokeExact(defaultAllocatorAddress, ret));\n+            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), MemorySegment.NULL, 0l, elementType.id, ret)));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n+        }\n@@ -334,1 +350,1 @@\n-        return createFlatTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64);\n+        return createTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64, new TensorShape(elements.length));\n@@ -338,1 +354,1 @@\n-        return createFlatTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT);\n+        return createTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT, new TensorShape(elements.length));\n@@ -341,2 +357,1 @@\n-    private OrtTensor createFlatTensor(MemorySegment flatData, Tensor.ElementType elementType) {\n-        var flatShape = new TensorShape(flatData.byteSize() \/ elementType.size());\n+    private OrtTensor createTensor(MemorySegment flatData, Tensor.ElementType elementType, TensorShape shape) {\n@@ -345,1 +360,1 @@\n-            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), flatShape.dataAddress, 1l, elementType.id, ret)));\n+            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), shape.dataAddress, shape.getDimensionsCount(), elementType.id, ret)));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":34,"deletions":19,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    public Tensor(long data) {\n+        this(OnnxRuntime.getInstance().createScalar(data));\n+    }\n+\n+    public Tensor(float data) {\n+        this(OnnxRuntime.getInstance().createScalar(data));\n+    }\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+        int ordinal();\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+        public abstract int id();\n@@ -483,0 +484,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 10;\n+        }\n@@ -496,0 +502,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 1;\n+        }\n@@ -509,0 +520,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 11;\n+        }\n@@ -521,0 +537,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 16;\n+        }\n@@ -533,0 +554,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 17;\n+        }\n@@ -545,0 +571,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 19;\n+        }\n@@ -557,0 +588,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 18;\n+        }\n@@ -569,0 +605,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 20;\n+        }\n@@ -581,0 +622,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 23;\n+        }\n@@ -593,0 +639,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 22;\n+        }\n@@ -605,0 +656,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 3;\n+        }\n@@ -617,0 +673,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 5;\n+        }\n@@ -629,0 +690,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 6;\n+        }\n@@ -641,0 +707,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 7;\n+        }\n@@ -653,0 +724,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 21;\n+        }\n@@ -665,0 +741,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 2;\n+        }\n@@ -677,0 +758,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 4;\n+        }\n@@ -689,0 +775,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 12;\n+        }\n@@ -701,0 +792,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 13;\n+        }\n@@ -713,0 +809,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 14;\n+        }\n@@ -725,0 +826,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 15;\n+        }\n@@ -737,0 +843,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 9;\n+        }\n@@ -749,0 +860,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 8;\n+        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -335,0 +335,7 @@\n+\n+\/\/ @@@ needs some muckup tensors data\n+\/\/        Tensor<Float> conv1Weights, conv1Biases, conv2Weights, conv2Biases, fc1Weights, fc1Biases, fc2Weights, fc2Biases, fc3Weights, fc3Biases, inputImage;\n+\/\/        Assertions.assertEquals(\n+\/\/            cnn(conv1Weights, conv1Biases, conv2Weights, conv2Biases, fc1Weights, fc1Biases, fc2Weights, fc2Biases, fc3Weights, fc3Biases, inputImage),\n+\/\/            OnnxRuntime.getInstance().runFunc(onnxModel, Stream.of(conv1Weights, conv1Biases, conv2Weights, conv2Biases, fc1Weights, fc1Biases, fc2Weights, fc2Biases, fc3Weights, fc3Biases, inputImage)\n+\/\/                    .map(t -> Optional.of(t.rtTensor)).toList()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-import java.nio.FloatBuffer;\n-import java.nio.LongBuffer;\n@@ -6,0 +4,2 @@\n+import java.util.Optional;\n+import oracle.code.onnx.Tensor.ElementType;\n@@ -15,0 +15,2 @@\n+    static final Optional<ElementType> OF_FLOAT = Optional.of(FLOAT);\n+\n@@ -18,2 +20,2 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(FLOAT, FLOAT)));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(FLOAT, FLOAT)))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()))) {\n@@ -31,1 +33,1 @@\n-            var absResult = absOp.run(List.of(inputTensor));\n+            var absResult = absOp.run(List.of(Optional.of(inputTensor)));\n@@ -37,1 +39,1 @@\n-            assertTensorEquals(absExpectedTensor, absOutputTensor);\n+            SimpleTest.assertEquals(absExpectedTensor, absOutputTensor);\n@@ -39,1 +41,1 @@\n-            var addResult = addOp.run(List.of(inputTensor, absOutputTensor));\n+            var addResult = addOp.run(List.of(Optional.of(inputTensor), Optional.of(absOutputTensor)));\n@@ -47,33 +49,1 @@\n-            assertTensorEquals(addExpectedTensor, addOutputTensor);\n-        }\n-    }\n-\n-    static void assertTensorEquals(OnnxRuntime.OrtTensor expectedTensor, OnnxRuntime.OrtTensor actualTensor) {\n-        var expectedType = expectedTensor.getTensorTypeAndShape();\n-        var expectedShape = expectedType.getShape();\n-\n-        var actualType = actualTensor.getTensorTypeAndShape();\n-        var actualShape = actualType.getShape();\n-\n-        assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n-        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n-            assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n-        }\n-\n-        assertEquals(expectedType.getTensorElementType(), actualType.getTensorElementType());\n-        assertEquals(expectedType.getTensorShapeElementCount(), actualType.getTensorShapeElementCount());\n-\n-        assertEqualData(expectedTensor.asByteBuffer().asFloatBuffer(), actualTensor.asByteBuffer().asFloatBuffer());\n-    }\n-\n-    static void assertEqualData(FloatBuffer expectedData, FloatBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n-        }\n-    }\n-\n-    static void assertEqualData(LongBuffer expectedData, LongBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i));\n+            SimpleTest.assertEquals(addExpectedTensor, addOutputTensor);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":10,"deletions":40,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4,1 +4,4 @@\n-import java.util.List;\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.util.Arrays;\n@@ -6,0 +9,1 @@\n+import java.util.stream.Stream;\n@@ -10,0 +14,2 @@\n+import oracle.code.onnx.ir.OnnxOp;\n+import org.junit.jupiter.api.Assertions;\n@@ -12,2 +18,0 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-\n@@ -16,2 +20,0 @@\n-    \/\/ Java code model -> ONNX code model -> ONNX runtime instance -> execute via ORT\n-    \/\/ Run directly, each operation reflectively executes via ORT\n@@ -29,2 +31,53 @@\n-                new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"add\", Tensor.class, Tensor.class),\n-                        List.of(a.rtTensor, b.rtTensor)).getFirst()));\n+                runModel(\"add\", a, b));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstant() {\n+        return OnnxOperators.Constant(-1f);\n+    }\n+\n+    @Test\n+    public void testFconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1f);\n+        assertEquals(expected, fconstant());\n+        assertEquals(expected, runModel(\"fconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstants() {\n+        return OnnxOperators.Constant(new float[]{-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testFconstants() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE);\n+        assertEquals(expected, fconstants());\n+        assertEquals(expected, runModel(\"fconstants\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstant() {\n+        return OnnxOperators.Constant(-1l);\n+    }\n+\n+    @Test\n+    public void testLconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1l);\n+        assertEquals(expected, lconstant());\n+        assertEquals(expected, runModel(\"lconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstants() {\n+        return OnnxOperators.Constant(new long[]{-1, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testLconstants() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1l, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE);\n+        assertEquals(expected, lconstants());\n+        assertEquals(expected, runModel(\"lconstants\"));\n@@ -42,3 +95,9 @@\n-        assertEquals(shape, reshapeAndShape(data, shape));\n-        assertEquals(shape, new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"reshapeAndShape\", Tensor.class, Tensor.class),\n-                        List.of(data.rtTensor, shape.rtTensor)).getFirst()));\n+        assertEquals(\n+                reshapeAndShape(data, shape),\n+                runModel(\"reshapeAndShape\", data, shape));\n+    }\n+\n+    private static Tensor runModel(String name, Tensor... params) throws NoSuchMethodException {\n+        return new Tensor(OnnxRuntime.getInstance().runFunc(\n+                getOnnxModel(name),\n+                Stream.of(params).map(t -> Optional.ofNullable(t.rtTensor)).toList()).getFirst());\n@@ -47,1 +106,1 @@\n-    private static CoreOp.FuncOp getOnnxModel(String name, Class... params) throws NoSuchMethodException {\n+    private static CoreOp.FuncOp getOnnxModel(String name) throws NoSuchMethodException {\n@@ -49,1 +108,1 @@\n-                Op.ofMethod(SimpleTest.class.getDeclaredMethod(name, params)).get());\n+                Op.ofMethod(Stream.of(SimpleTest.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get()).get());\n@@ -52,4 +111,8 @@\n-    static void assertEquals(Tensor actual, Tensor expected) {\n-        var expectedTS = expected.rtTensor.getTensorTypeAndShape();\n-        var actualTS = actual.rtTensor.getTensorTypeAndShape();\n-        assertSame(expectedTS.getTensorElementType(), actualTS.getTensorElementType());\n+    static void assertEquals(Tensor expected, Tensor actual) {\n+        assertEquals(expected.rtTensor, actual.rtTensor);\n+    }\n+\n+    static void assertEquals(OnnxRuntime.OrtTensor expected, OnnxRuntime.OrtTensor actual) {\n+\n+        var expectedType = expected.getTensorTypeAndShape();\n+        var expectedShape = expectedType.getShape();\n@@ -57,1 +120,2 @@\n-        \/\/ @@@ assert equal shapes\n+        var actualType = actual.getTensorTypeAndShape();\n+        var actualShape = actualType.getShape();\n@@ -59,1 +123,10 @@\n-        switch (actualTS.getTensorElementType()) {\n+        Assertions.assertSame(expectedType.getTensorElementType(), actualType.getTensorElementType());\n+\n+        Assertions.assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n+        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n+            Assertions.assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n+        }\n+\n+        switch (actualType.getTensorElementType()) {\n+            case UINT8, INT8, UINT16, INT16, INT32, INT64, STRING, BOOL, UINT32, UINT64, UINT4, INT4 ->\n+                assertEquals(expected.asByteBuffer(), actual.asByteBuffer());\n@@ -61,3 +134,3 @@\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asFloatBuffer(), actual.rtTensor.asByteBuffer().asFloatBuffer());\n-            case INT64 ->\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asLongBuffer(), actual.rtTensor.asByteBuffer().asLongBuffer());\n+                assertEquals(expected.asByteBuffer().asFloatBuffer(), actual.asByteBuffer().asFloatBuffer());\n+            case DOUBLE ->\n+                assertEquals(expected.asByteBuffer().asDoubleBuffer(), actual.asByteBuffer().asDoubleBuffer());\n@@ -65,1 +138,22 @@\n-                throw new UnsupportedOperationException(); \/\/ @@@ ToDo\n+                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType.getTensorElementType());\n+        }\n+    }\n+\n+    static void assertEquals(ByteBuffer expectedData, ByteBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i));\n+        }\n+    }\n+\n+    static void assertEquals(FloatBuffer expectedData, FloatBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n+        }\n+    }\n+\n+    static void assertEquals(DoubleBuffer expectedData, DoubleBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":116,"deletions":22,"binary":false,"changes":138,"status":"modified"}]}