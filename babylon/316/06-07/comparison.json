{"files":[{"patch":"@@ -42,2 +42,2 @@\n-                        case Tensor t -> t.rtTensor;\n-                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.rtTensor;\n+                        case Tensor t -> t.tensorAddr;\n+                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.tensorAddr;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,3 +75,0 @@\n-                                castTypeInfoToMapTypeInfo,\n-                                castTypeInfoToSequenceTypeInfo,\n-                                castTypeInfoToTensorInfo,\n@@ -85,1 +82,0 @@\n-                                getOnnxTypeFromTypeInfo,\n@@ -95,1 +91,0 @@\n-                                sessionGetInputTypeInfo,\n@@ -98,1 +93,0 @@\n-                                sessionGetOutputTypeInfo,\n@@ -119,3 +113,0 @@\n-        castTypeInfoToMapTypeInfo      = handle(103, ADDRESS, ADDRESS);\n-        castTypeInfoToSequenceTypeInfo = handle(104, ADDRESS, ADDRESS);\n-        castTypeInfoToTensorInfo       = handle( 55, ADDRESS, ADDRESS);\n@@ -129,1 +120,0 @@\n-        getOnnxTypeFromTypeInfo        = handle( 56, ADDRESS, ADDRESS);\n@@ -139,1 +129,0 @@\n-        sessionGetInputTypeInfo        = handle( 33, ADDRESS, JAVA_INT, ADDRESS);\n@@ -142,1 +131,0 @@\n-        sessionGetOutputTypeInfo       = handle( 34, ADDRESS, JAVA_INT, ADDRESS);\n@@ -165,2 +153,2 @@\n-    public enum ONNXType {\n-        UNKNOWN, TENSOR, SEQUENCE, MAP, OPAQUE, SPARSETENSOR, OPTIONAL\n+    private List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<MemorySegment>> values) {\n+        return values.stream().map(ot -> ot.map(this::tensorElementType)).toList();\n@@ -169,5 +157,1 @@\n-    private static List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<OrtTensor>> values) {\n-        return values.stream().map(ot -> ot.map(OrtTensor::getTensorTypeAndShape).map(OrtTensorTypeAndShapeInfo::getTensorElementType)).toList();\n-    }\n-\n-    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<Optional<OrtTensor>> inputValues, List<Object> attributes) {\n+    public List<MemorySegment> runOp(OnnxOp.OnnxSchema schema, List<Optional<MemorySegment>> inputValues, List<Object> attributes) {\n@@ -180,1 +164,1 @@\n-    public List<OrtTensor> runFunc(CoreOp.FuncOp model, List<Optional<OrtTensor>> inputValues) {\n+    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<Optional<MemorySegment>> inputValues) {\n@@ -251,34 +235,0 @@\n-        public OrtTypeInfo getInputTypeInfo(int inputIndex) {\n-            try {\n-                return getTypeInfo(retAddr(sessionGetInputTypeInfo.invokeExact(sessionAddress, inputIndex, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public OrtTypeInfo getOutputTypeInfo(int outputIndex) {\n-            try {\n-                return getTypeInfo(retAddr(sessionGetOutputTypeInfo.invokeExact(sessionAddress, outputIndex, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        private OrtTypeInfo getTypeInfo(MemorySegment typeAddress) {\n-            try {\n-                var type = ONNXType.values()[retInt(getOnnxTypeFromTypeInfo.invokeExact(typeAddress, ret))];\n-                return switch (type) {\n-                    case TENSOR, SPARSETENSOR ->\n-                        new OrtTensorTypeAndShapeInfo(retAddr(castTypeInfoToTensorInfo.invokeExact(typeAddress, ret)));\n-                    case SEQUENCE ->\n-                        new SequenceTypeInfo(retAddr(castTypeInfoToSequenceTypeInfo.invokeExact(typeAddress, ret)));\n-                    case MAP ->\n-                        new MapTypeInfo(retAddr(castTypeInfoToMapTypeInfo.invokeExact(typeAddress, ret)));\n-                    default ->\n-                        throw new IllegalArgumentException(\"Invalid element type found in sequence \" + type);\n-                };\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n@@ -286,1 +236,1 @@\n-        public List<OrtTensor> run(List<Optional<OrtTensor>> inputValues) {\n+        public List<MemorySegment> run(List<Optional<MemorySegment>> inputValues) {\n@@ -296,1 +246,1 @@\n-                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get().valueAddress());\n+                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get());\n@@ -307,1 +257,1 @@\n-                var retArr = new OrtTensor[outputLen];\n+                var retArr = new MemorySegment[outputLen];\n@@ -309,1 +259,1 @@\n-                    retArr[i] = new OrtTensor(outputs.getAtIndex(ADDRESS, i));\n+                    retArr[i] = outputs.getAtIndex(ADDRESS, i);\n@@ -327,1 +277,1 @@\n-    public OrtTensor loadFlatTensorFromMemoryMappedDataFile(String file, Tensor.ElementType elementType) throws IOException {\n+    public MemorySegment loadFlatTensorFromMemoryMappedDataFile(String file, Tensor.ElementType elementType) throws IOException {\n@@ -329,1 +279,1 @@\n-        return createTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), elementType, new TensorShape(f.length() \/ elementType.size()));\n+        return createTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), elementType, new long[]{f.length() \/ elementType.size()});\n@@ -332,1 +282,1 @@\n-    OrtTensor createScalar(long element) {\n+    public MemorySegment createScalar(long element) {\n@@ -336,1 +286,1 @@\n-    OrtTensor createScalar(float element) {\n+    public MemorySegment createScalar(float element) {\n@@ -340,1 +290,1 @@\n-    private OrtTensor createScalar(MemorySegment flatData, Tensor.ElementType elementType) {\n+    private MemorySegment createScalar(MemorySegment flatData, Tensor.ElementType elementType) {\n@@ -343,1 +293,1 @@\n-            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), MemorySegment.NULL, 0l, elementType.id, ret)));\n+            return retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), MemorySegment.NULL, 0l, elementType.id, ret));\n@@ -349,2 +299,2 @@\n-    OrtTensor createFlatTensor(long... elements) {\n-        return createTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64, new TensorShape(elements.length));\n+    public MemorySegment createFlatTensor(long... elements) {\n+        return createTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64, new long[]{elements.length});\n@@ -353,2 +303,2 @@\n-    OrtTensor createFlatTensor(float... elements) {\n-        return createTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT, new TensorShape(elements.length));\n+    public MemorySegment createFlatTensor(float... elements) {\n+        return createTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT, new long[]{elements.length});\n@@ -357,1 +307,1 @@\n-    OrtTensor createTensor(MemorySegment flatData, Tensor.ElementType elementType, TensorShape shape) {\n+    public MemorySegment createTensor(MemorySegment flatData, Tensor.ElementType elementType, long[] shape) {\n@@ -360,1 +310,2 @@\n-            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), shape.dataAddress, shape.getDimensionsCount(), elementType.id, ret)));\n+            var shapeAddr = arena.allocateFrom(JAVA_LONG, shape);\n+            return retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), shapeAddr, (long)shape.length, elementType.id, ret));\n@@ -366,18 +317,6 @@\n-    public final class TensorShape {\n-\n-        private final MemorySegment dataAddress;\n-\n-        public TensorShape(long... dimensions) {\n-            this(arena.allocateFrom(JAVA_LONG, dimensions));\n-        }\n-\n-        private TensorShape(MemorySegment dataAddress) {\n-            this.dataAddress = dataAddress;\n-        }\n-\n-        public long getDimensionsCount() {\n-            return dataAddress.byteSize() \/ JAVA_LONG.byteSize();\n-        }\n-\n-        public long getDimension(long index) {\n-            return dataAddress.getAtIndex(JAVA_LONG, index);\n+    public Tensor.ElementType tensorElementType(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddr, ret)));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -387,25 +326,9 @@\n-    public sealed interface OrtValue {\n-\n-        MemorySegment valueAddress();\n-\n-    }\n-\n-    public final class OrtTensor implements OrtValue {\n-\n-        private final MemorySegment valueAddress;\n-\n-        private OrtTensor(MemorySegment valueAddress) {\n-            this.valueAddress = valueAddress;\n-        }\n-\n-        @Override\n-        public MemorySegment valueAddress() {\n-            return valueAddress;\n-        }\n-\n-        public OrtTensorTypeAndShapeInfo getTensorTypeAndShape() {\n-            try {\n-                return new OrtTensorTypeAndShapeInfo(retAddr(getTensorTypeAndShape.invokeExact(valueAddress, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+    public long[] tensorShape(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            long dims = retLong(getDimensionsCount.invokeExact(infoAddr, ret));\n+            var shape = arena.allocate(JAVA_LONG, dims);\n+            checkStatus(getDimensions.invokeExact(infoAddr, shape, dims));\n+            return shape.toArray(JAVA_LONG);\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -413,0 +336,1 @@\n+    }\n@@ -414,10 +338,10 @@\n-        public ByteBuffer asByteBuffer() {\n-            var type = getTensorTypeAndShape();\n-            long size = type.getTensorShapeElementCount() * type.getTensorElementType().size();\n-            try {\n-                return retAddr(getTensorMutableData.invokeExact(valueAddress, ret))\n-                        .reinterpret(size)\n-                        .asByteBuffer().order(ByteOrder.nativeOrder());\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+    public ByteBuffer tensorBuffer(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            long size = retLong(getTensorShapeElementCount.invokeExact(infoAddr, ret))\n+                    * Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddr, ret))).size();\n+            return retAddr(getTensorMutableData.invokeExact(tensorAddr, ret))\n+                    .reinterpret(size)\n+                    .asByteBuffer().order(ByteOrder.nativeOrder());\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -453,65 +377,0 @@\n-    public sealed interface OrtTypeInfo {\n-    }\n-\n-    public final class OrtTensorTypeAndShapeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private OrtTensorTypeAndShapeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-\n-        public long getDimensionsCount() {\n-            try {\n-                return retLong(getDimensionsCount.invokeExact(infoAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public Tensor.ElementType getTensorElementType() {\n-            try {\n-                return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddress, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public long getTensorShapeElementCount() {\n-            try {\n-                return retLong(getTensorShapeElementCount.invokeExact(infoAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public TensorShape getShape() {\n-            long dims = getDimensionsCount();\n-            var shape = arena.allocate(JAVA_LONG, dims);\n-            try {\n-                checkStatus(getDimensions.invokeExact(infoAddress, shape, dims));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-            return new TensorShape(shape);\n-        }\n-    }\n-\n-    public final class SequenceTypeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private SequenceTypeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-    }\n-\n-    public final class MapTypeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private MapTypeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":47,"deletions":188,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+\n@@ -66,1 +68,1 @@\n-    final OnnxRuntime.OrtTensor rtTensor;\n+    final MemorySegment tensorAddr;\n@@ -84,2 +86,2 @@\n-    Tensor(OnnxRuntime.OrtTensor rtTensor) {\n-        this.rtTensor = rtTensor;\n+    Tensor(MemorySegment tensorAddr) {\n+        this.tensorAddr = tensorAddr;\n@@ -88,1 +90,1 @@\n-    enum ElementType {\n+    public enum ElementType {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -339,2 +339,2 @@\n-            cnn(w.get(0), w.get(1), w.get(2), w.get(3), w.get(4), w.get(5), w.get(6), w.get(7), w.get(8), w.get(9), inputImage).rtTensor,\n-            OnnxRuntime.getInstance().runFunc(onnxModel, Stream.concat(w.stream(), Stream.of(inputImage)).map(t -> Optional.of(t.rtTensor)).toList()).getFirst());\n+            cnn(w.get(0), w.get(1), w.get(2), w.get(3), w.get(4), w.get(5), w.get(6), w.get(7), w.get(8), w.get(9), inputImage).tensorAddr,\n+            OnnxRuntime.getInstance().runFunc(onnxModel, Stream.concat(w.stream(), Stream.of(inputImage)).map(t -> Optional.of(t.tensorAddr)).toList()).getFirst());\n@@ -352,1 +352,1 @@\n-                                OnnxRuntime.getInstance().new TensorShape(init.getDimsList().stream().mapToLong(a -> a).toArray())));\n+                                init.getDimsList().stream().mapToLong(a -> a).toArray()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-            var absOutputTensor = (OnnxRuntime.OrtTensor)absResult.getFirst();\n+            var absOutputTensor = absResult.getFirst();\n@@ -45,1 +45,1 @@\n-            var addOutputTensor = (OnnxRuntime.OrtTensor)addResult.getFirst();\n+            var addOutputTensor = addResult.getFirst();\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -7,1 +8,0 @@\n-import java.util.Arrays;\n@@ -14,1 +14,0 @@\n-import oracle.code.onnx.ir.OnnxOp;\n@@ -103,1 +102,1 @@\n-                Stream.of(params).map(t -> Optional.ofNullable(t.rtTensor)).toList()).getFirst());\n+                Stream.of(params).map(t -> Optional.ofNullable(t.tensorAddr)).toList()).getFirst());\n@@ -112,1 +111,1 @@\n-        assertEquals(expected.rtTensor, actual.rtTensor);\n+        assertEquals(expected.tensorAddr, actual.tensorAddr);\n@@ -115,1 +114,1 @@\n-    static void assertEquals(OnnxRuntime.OrtTensor expected, OnnxRuntime.OrtTensor actual) {\n+    static void assertEquals(MemorySegment expectedTensorAddr, MemorySegment actualTensorAddr) {\n@@ -117,2 +116,1 @@\n-        var expectedType = expected.getTensorTypeAndShape();\n-        var expectedShape = expectedType.getShape();\n+        var rt = OnnxRuntime.getInstance();\n@@ -120,2 +118,3 @@\n-        var actualType = actual.getTensorTypeAndShape();\n-        var actualShape = actualType.getShape();\n+        var expectedType = rt.tensorElementType(expectedTensorAddr);\n+        var expectedShape = rt.tensorShape(expectedTensorAddr);\n+        var expectedBB = rt.tensorBuffer(expectedTensorAddr);\n@@ -123,1 +122,3 @@\n-        Assertions.assertSame(expectedType.getTensorElementType(), actualType.getTensorElementType());\n+        var actualType = rt.tensorElementType(actualTensorAddr);\n+        var actualShape = rt.tensorShape(actualTensorAddr);\n+        var actualBB = rt.tensorBuffer(actualTensorAddr);\n@@ -125,4 +126,3 @@\n-        Assertions.assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n-        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n-            Assertions.assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n-        }\n+        Assertions.assertSame(expectedType, actualType);\n+\n+        Assertions.assertArrayEquals(expectedShape, actualShape);\n@@ -130,1 +130,1 @@\n-        switch (actualType.getTensorElementType()) {\n+        switch (actualType) {\n@@ -132,1 +132,1 @@\n-                assertEquals(expected.asByteBuffer(), actual.asByteBuffer());\n+                assertEquals(expectedBB, actualBB);\n@@ -134,1 +134,1 @@\n-                assertEquals(expected.asByteBuffer().asFloatBuffer(), actual.asByteBuffer().asFloatBuffer());\n+                assertEquals(expectedBB.asFloatBuffer(), actualBB.asFloatBuffer());\n@@ -136,1 +136,1 @@\n-                assertEquals(expected.asByteBuffer().asDoubleBuffer(), actual.asByteBuffer().asDoubleBuffer());\n+                assertEquals(expectedBB.asDoubleBuffer(), actualBB.asDoubleBuffer());\n@@ -138,1 +138,1 @@\n-                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType.getTensorElementType());\n+                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"}]}