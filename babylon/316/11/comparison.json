{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -40,1 +41,6 @@\n-                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList());\n+                    inputs.stream().map(o -> Optional.ofNullable(switch (o) {\n+                        case Tensor t -> t.tensorAddr;\n+                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.tensorAddr;\n+                        default -> null;\n+                    })).toList(),\n+                    attributes);\n@@ -42,1 +48,1 @@\n-                return new Tensor<>(outTensors.getFirst());\n+                return new Tensor(outTensors.getFirst());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -9,1 +9,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -11,0 +10,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -197,5 +197,3 @@\n-        long expanded = Long.expand(number, 0x7f7f7f7f7f7f7f7fl);\n-        int bytesSize = Math.max(1, 8 - Long.numberOfLeadingZeros(expanded) \/ 8);\n-        for (int i = 1; i < bytesSize; i++) {\n-            buf.write(0x80 | (int)expanded & 0x7f);\n-            expanded >>= 8;\n+        for (int i = 64 - Long.numberOfLeadingZeros(number); i > 7; i -= 7) {\n+            buf.write(0x80 | (int)number & 0x7f);\n+            number >>= 7;\n@@ -203,1 +201,1 @@\n-        buf.write((int)expanded & 0x7f);\n+        buf.write((int)number & 0x7f);\n@@ -264,1 +262,1 @@\n-    static final int OPSET_VERSION = 14;\n+    static final int OPSET_VERSION = 21;\n@@ -267,2 +265,1 @@\n-    \/\/ order of building defines order inside protobufs\n-    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<ElementType> inputElementTypes) {\n+    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<java.util.Optional<ElementType>> inputElementTypes, List<Object> attributes) {\n@@ -272,0 +269,9 @@\n+                        .forEach(schema.inputs(), (g, i) -> {\n+                            if (inputElementTypes.get(i.ordinal()).isPresent()) {\n+                                g.input(new ValueInfoProto()\n+                                    .name(i.name())\n+                                    .type(new TypeProto()\n+                                            \/\/ inputValues match schema inputs by OnnxParameter::ordinal\n+                                            .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).get().id))));\n+                            }\n+                        })\n@@ -275,6 +281,12 @@\n-                            .op_type(schema.name()))\n-                        .forEach(schema.inputs(), (g, i) -> g.input(new ValueInfoProto()\n-                                .name(i.name())\n-                                .type(new TypeProto()\n-                                        \/\/ inputValues matching schema inputs by OnnxParameter::ordinal\n-                                        .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).id)))))\n+                            .op_type(schema.name())\n+                            .forEach(schema.attributes(), (n, a) -> {\n+                                \/\/ attributes match schema by OnnxAttribute::ordinal\n+                                var attrValue = attributes.get(a.ordinal());\n+                                if (a.isOptional()) {\n+                                    if (attrValue instanceof java.util.Optional o && o.isPresent()) {\n+                                        n.attribute(buildAttribute(a.name(), o.get()));\n+                                    }\n+                                } else {\n+                                    n.attribute(buildAttribute(a.name(), attrValue));\n+                                }\n+                            }))\n@@ -288,52 +300,4 @@\n-    private static int toElementType(TypeElement type) {\n-        if (type == OnnxType.TENSOR_FLOAT32) {\n-            return 1;\n-        } else if(type == OnnxType.TENSOR_UINT8) {\n-            return 2;\n-        } else if(type == OnnxType.TENSOR_INT8) {\n-            return 3;\n-        } else if(type == OnnxType.TENSOR_UINT16) {\n-            return 4;\n-        } else if(type == OnnxType.TENSOR_INT16) {\n-            return 5;\n-        } else if(type == OnnxType.TENSOR_INT32) {\n-            return 6;\n-        } else if(type == OnnxType.TENSOR_INT64) {\n-            return 7;\n-        } else if(type == OnnxType.TENSOR_STRING) {\n-            return 8;\n-        } else if(type == OnnxType.TENSOR_BOOL) {\n-            return 9;\n-        } else if(type == OnnxType.TENSOR_FLOAT16) {\n-            return 10;\n-        } else if(type == OnnxType.TENSOR_FLOAT64) {\n-            return 11;\n-        } else if(type == OnnxType.TENSOR_UINT32) {\n-            return 12;\n-        } else if(type == OnnxType.TENSOR_UINT64) {\n-            return 13;\n-        } else if(type == OnnxType.TENSOR_COMPLEX64) {\n-            return 14;\n-        } else if(type == OnnxType.TENSOR_COMPLEX128) {\n-            return 15;\n-        } else if(type == OnnxType.TENSOR_BFLOAT16) {\n-            return 16;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FN) {\n-            return 17;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FNUZ) {\n-            return 18;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2) {\n-            return 19;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2FNUZ) {\n-            return 20;\n-        } else if(type == OnnxType.TENSOR_UINT4) {\n-            return 21;\n-        } else if(type == OnnxType.TENSOR_INT4) {\n-            return 22;\n-        } else if(type == OnnxType.TENSOR_FLOAT4E2M1) {\n-            return 23;\n-        } else {\n-            throw new RuntimeException(type.toString());\n-        }\n-    }\n-\n+    \/\/ @@@ unchecked constraints:\n+    \/\/         tensor FuncOp parameters and single tensor return type\n+    \/\/         OnnxOps (with tensor operands and single tensor return value) and ReturnOp (returning single tensor)\n+    \/\/         entry block only\n@@ -350,0 +314,4 @@\n+                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto()\n+                                .name(indexer.getName(p))\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n@@ -351,5 +319,16 @@\n-                            if (op instanceof OnnxOp) {\n-                                g.node(new NodeProto()\n-                                        .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n-                                        .output(indexer.getName(op.result()))\n-                                        .op_type(op.opName()));\n+                            switch (op) {\n+                                case OnnxOp onnxOp ->\n+                                    g.node(new NodeProto()\n+                                            .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n+                                            .output(indexer.getName(op.result()))\n+                                            .op_type(op.opName())\n+                                            .forEach(onnxOp.onnxAttributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue()))));\n+                                case CoreOp.ReturnOp _ -> {\n+                                     \/\/ skip\n+                                }\n+                                case CoreOp.TupleLoadOp _ -> {\n+                                    \/\/ @@@ hack to forward to the first from the tuple\n+                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst()));\n+                                }\n+                                default ->\n+                                    throw new UnsupportedOperationException(op.toText());\n@@ -358,4 +337,0 @@\n-                        .forEach(model.parameters(), (g, p) -> g.input(new ValueInfoProto()\n-                                .name(indexer.getName(p))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(toElementType(p.type()))))))\n@@ -365,1 +340,1 @@\n-                                        .tensor_type(new Tensor().elem_type(toElementType(model.body().yieldType()))))))\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)model.body().yieldType()).eType().id())))))\n@@ -370,0 +345,24 @@\n+\n+    static Attribute buildAttribute(String name, Object value) {\n+        var attr = new Attribute().name(name);\n+        switch (value) {\n+            case Float f -> {\n+                attr.type(1).f(f);\n+            }\n+            case Long l -> {\n+                attr.type(2).i(l);\n+            }\n+            case float[] floats -> {\n+                attr.type(6);\n+                for (float f : floats) attr.floats(f);\n+            }\n+            case long[] longs -> {\n+                attr.type(7);\n+                for (long l : longs) attr.ints(l);\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException(value.getClass().toString()); \/\/ @@@ ToDo\n+            }\n+        }\n+        return attr;\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":77,"deletions":78,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -5,1 +5,0 @@\n-import java.io.RandomAccessFile;\n@@ -12,2 +11,0 @@\n-import java.nio.LongBuffer;\n-import java.nio.channels.FileChannel;\n@@ -19,3 +16,1 @@\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n+import java.util.Optional;\n@@ -30,1 +25,1 @@\n-    private static final int LOG_LEVEL = 0; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n+    private static final int LOG_LEVEL = 3; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n@@ -78,3 +73,0 @@\n-                                castTypeInfoToMapTypeInfo,\n-                                castTypeInfoToSequenceTypeInfo,\n-                                castTypeInfoToTensorInfo,\n@@ -88,1 +80,0 @@\n-                                getOnnxTypeFromTypeInfo,\n@@ -98,1 +89,0 @@\n-                                sessionGetInputTypeInfo,\n@@ -101,1 +91,0 @@\n-                                sessionGetOutputTypeInfo,\n@@ -122,3 +111,0 @@\n-        castTypeInfoToMapTypeInfo      = handle(103, ADDRESS, ADDRESS);\n-        castTypeInfoToSequenceTypeInfo = handle(104, ADDRESS, ADDRESS);\n-        castTypeInfoToTensorInfo       = handle( 55, ADDRESS, ADDRESS);\n@@ -132,1 +118,0 @@\n-        getOnnxTypeFromTypeInfo        = handle( 56, ADDRESS, ADDRESS);\n@@ -142,1 +127,0 @@\n-        sessionGetInputTypeInfo        = handle( 33, ADDRESS, JAVA_INT, ADDRESS);\n@@ -145,1 +129,0 @@\n-        sessionGetOutputTypeInfo       = handle( 34, ADDRESS, JAVA_INT, ADDRESS);\n@@ -168,2 +151,2 @@\n-    public enum ONNXType {\n-        UNKNOWN, TENSOR, SEQUENCE, MAP, OPAQUE, SPARSETENSOR, OPTIONAL\n+    private List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<MemorySegment>> values) {\n+        return values.stream().map(ot -> ot.map(this::tensorElementType)).toList();\n@@ -172,6 +155,2 @@\n-    private static List<Tensor.ElementType> toElementTypes(List<OrtTensor> values) {\n-        return values.stream().map(OrtTensor::getTensorTypeAndShape).map(OrtTensorTypeAndShapeInfo::getTensorElementType).toList();\n-    }\n-\n-    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues) {\n-        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues));\n+    public List<MemorySegment> runOp(OnnxOp.OnnxSchema schema, List<Optional<MemorySegment>> inputValues, List<Object> attributes) {\n+        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues), attributes);\n@@ -183,1 +162,1 @@\n-    public List<OrtTensor> runFunc(CoreOp.FuncOp model, List<OrtTensor> inputValues) {\n+    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<Optional<MemorySegment>> inputValues) {\n@@ -254,34 +233,0 @@\n-        public OrtTypeInfo getInputTypeInfo(int inputIndex) {\n-            try {\n-                return getTypeInfo(retAddr(sessionGetInputTypeInfo.invokeExact(sessionAddress, inputIndex, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public OrtTypeInfo getOutputTypeInfo(int outputIndex) {\n-            try {\n-                return getTypeInfo(retAddr(sessionGetOutputTypeInfo.invokeExact(sessionAddress, outputIndex, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        private OrtTypeInfo getTypeInfo(MemorySegment typeAddress) {\n-            try {\n-                var type = ONNXType.values()[retInt(getOnnxTypeFromTypeInfo.invokeExact(typeAddress, ret))];\n-                return switch (type) {\n-                    case TENSOR, SPARSETENSOR ->\n-                        new OrtTensorTypeAndShapeInfo(retAddr(castTypeInfoToTensorInfo.invokeExact(typeAddress, ret)));\n-                    case SEQUENCE ->\n-                        new SequenceTypeInfo(retAddr(castTypeInfoToSequenceTypeInfo.invokeExact(typeAddress, ret)));\n-                    case MAP ->\n-                        new MapTypeInfo(retAddr(castTypeInfoToMapTypeInfo.invokeExact(typeAddress, ret)));\n-                    default ->\n-                        throw new IllegalArgumentException(\"Invalid element type found in sequence \" + type);\n-                };\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n@@ -289,1 +234,1 @@\n-        public List<OrtTensor> run(List<OrtTensor> inputValues) {\n+        public List<MemorySegment> run(List<Optional<MemorySegment>> inputValues) {\n@@ -297,2 +242,4 @@\n-                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n-                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).valueAddress());\n+                if (inputValues.get(i).isPresent()) {\n+                    inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n+                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get());\n+                }\n@@ -308,1 +255,1 @@\n-                var retArr = new OrtTensor[outputLen];\n+                var retArr = new MemorySegment[outputLen];\n@@ -310,1 +257,1 @@\n-                    retArr[i] = new OrtTensor(outputs.getAtIndex(ADDRESS, i));\n+                    retArr[i] = outputs.getAtIndex(ADDRESS, i);\n@@ -328,15 +275,1 @@\n-    public OrtTensor loadFlatTensorFromMemoryMappedDataFile(String file, Tensor.ElementType elementType) throws IOException {\n-        var f = new RandomAccessFile(file, \"r\");\n-        return createFlatTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), elementType);\n-    }\n-\n-    OrtTensor createFlatTensor(long... elements) {\n-        return createFlatTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64);\n-    }\n-\n-    OrtTensor createFlatTensor(float... elements) {\n-        return createFlatTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT);\n-    }\n-\n-    private OrtTensor createFlatTensor(MemorySegment flatData, Tensor.ElementType elementType) {\n-        var flatShape = new TensorShape(flatData.byteSize() \/ elementType.size());\n+    public MemorySegment createTensor(MemorySegment flatData, Tensor.ElementType elementType, long[] shape) {\n@@ -345,1 +278,2 @@\n-            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), flatShape.dataAddress, 1l, elementType.id, ret)));\n+            var shapeAddr = shape.length == 0 ? MemorySegment.NULL : arena.allocateFrom(JAVA_LONG, shape);\n+            return retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), shapeAddr, (long)shape.length, elementType.id, ret));\n@@ -351,18 +285,6 @@\n-    public final class TensorShape {\n-\n-        private final MemorySegment dataAddress;\n-\n-        public TensorShape(long... dimensions) {\n-            this(arena.allocateFrom(JAVA_LONG, dimensions));\n-        }\n-\n-        private TensorShape(MemorySegment dataAddress) {\n-            this.dataAddress = dataAddress;\n-        }\n-\n-        public long getDimensionsCount() {\n-            return dataAddress.byteSize() \/ JAVA_LONG.byteSize();\n-        }\n-\n-        public long getDimension(long index) {\n-            return dataAddress.getAtIndex(JAVA_LONG, index);\n+    public Tensor.ElementType tensorElementType(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddr, ret)));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -372,25 +294,9 @@\n-    public sealed interface OrtValue {\n-\n-        MemorySegment valueAddress();\n-\n-    }\n-\n-    public final class OrtTensor implements OrtValue {\n-\n-        private final MemorySegment valueAddress;\n-\n-        private OrtTensor(MemorySegment valueAddress) {\n-            this.valueAddress = valueAddress;\n-        }\n-\n-        @Override\n-        public MemorySegment valueAddress() {\n-            return valueAddress;\n-        }\n-\n-        public OrtTensorTypeAndShapeInfo getTensorTypeAndShape() {\n-            try {\n-                return new OrtTensorTypeAndShapeInfo(retAddr(getTensorTypeAndShape.invokeExact(valueAddress, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+    public long[] tensorShape(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            long dims = retLong(getDimensionsCount.invokeExact(infoAddr, ret));\n+            var shape = arena.allocate(JAVA_LONG, dims);\n+            checkStatus(getDimensions.invokeExact(infoAddr, shape, dims));\n+            return shape.toArray(JAVA_LONG);\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -398,0 +304,1 @@\n+    }\n@@ -399,10 +306,10 @@\n-        public ByteBuffer asByteBuffer() {\n-            var type = getTensorTypeAndShape();\n-            long size = type.getTensorShapeElementCount() * type.getTensorElementType().size();\n-            try {\n-                return retAddr(getTensorMutableData.invokeExact(valueAddress, ret))\n-                        .reinterpret(size)\n-                        .asByteBuffer().order(ByteOrder.nativeOrder());\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+    public ByteBuffer tensorBuffer(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            long size = retLong(getTensorShapeElementCount.invokeExact(infoAddr, ret))\n+                    * Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddr, ret))).size();\n+            return retAddr(getTensorMutableData.invokeExact(tensorAddr, ret))\n+                    .reinterpret(size)\n+                    .asByteBuffer().order(ByteOrder.nativeOrder());\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -438,65 +345,0 @@\n-    public sealed interface OrtTypeInfo {\n-    }\n-\n-    public final class OrtTensorTypeAndShapeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private OrtTensorTypeAndShapeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-\n-        public long getDimensionsCount() {\n-            try {\n-                return retLong(getDimensionsCount.invokeExact(infoAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public Tensor.ElementType getTensorElementType() {\n-            try {\n-                return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddress, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public long getTensorShapeElementCount() {\n-            try {\n-                return retLong(getTensorShapeElementCount.invokeExact(infoAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public TensorShape getShape() {\n-            long dims = getDimensionsCount();\n-            var shape = arena.allocate(JAVA_LONG, dims);\n-            try {\n-                checkStatus(getDimensions.invokeExact(infoAddress, shape, dims));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-            return new TensorShape(shape);\n-        }\n-    }\n-\n-    public final class SequenceTypeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private SequenceTypeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-    }\n-\n-    public final class MapTypeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private MapTypeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":43,"deletions":201,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n+\n@@ -61,4 +66,0 @@\n-    \/\/ element type\n-    \/\/ dim\n-    \/\/ runtime representation\n-    \/\/ defer to ONNX runtime?\n@@ -66,1 +67,34 @@\n-    final OnnxRuntime.OrtTensor rtTensor;\n+    public static final long[] SCALAR_SHAPE = new long[0];\n+\n+    public static Tensor<Long> ofScalar(long l) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_LONG, l);\n+        return new Tensor<>(data, ElementType.INT64, SCALAR_SHAPE);\n+    }\n+\n+    public static Tensor<Float> ofScalar(float f) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_FLOAT, f);\n+        return new Tensor(data, ElementType.FLOAT, SCALAR_SHAPE);\n+    }\n+\n+    public static Tensor<Byte> ofFlat(byte... values) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_BYTE, values);\n+        return new Tensor(data, ElementType.UINT8, new long[]{values.length});\n+    }\n+\n+    public static Tensor<Long> ofFlat(long... values) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_LONG, values);\n+        return new Tensor(data, ElementType.INT64, new long[]{values.length});\n+    }\n+\n+    public static Tensor<Float> ofFlat(float... values) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_FLOAT, values);\n+        return new Tensor(data, ElementType.FLOAT, new long[]{values.length});\n+    }\n+\n+    \/\/ Mandatory reference to dataAddr to avoid its garbage colletion\n+    private final MemorySegment dataAddr;\n+    final MemorySegment tensorAddr;\n+\n+    Tensor(MemorySegment dataAddr, ElementType type, long... shape) {\n+        this(dataAddr, OnnxRuntime.getInstance().createTensor(dataAddr, type, shape));\n+    }\n@@ -68,2 +102,2 @@\n-    public Tensor(long... data) {\n-        this(OnnxRuntime.getInstance().createFlatTensor(data));\n+    Tensor(MemorySegment tensorAddr) {\n+        this(null, tensorAddr);\n@@ -72,2 +106,3 @@\n-    public Tensor(float... data) {\n-        this(OnnxRuntime.getInstance().createFlatTensor(data));\n+    Tensor(MemorySegment dataAddr, MemorySegment tensorAddr) {\n+        this.dataAddr = dataAddr;\n+        this.tensorAddr = tensorAddr;\n@@ -76,2 +111,2 @@\n-    Tensor(OnnxRuntime.OrtTensor rtTensor) {\n-        this.rtTensor = rtTensor;\n+    public ByteBuffer asByteBuffer() {\n+        return OnnxRuntime.getInstance().tensorBuffer(tensorAddr);\n@@ -80,1 +115,1 @@\n-    enum ElementType {\n+    public enum ElementType {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -224,0 +224,2 @@\n+            } else if (elementType.equals(JavaType.J_L_BYTE)) {\n+                return OnnxType.TENSOR_UINT8;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+        int ordinal();\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+        public abstract int id();\n@@ -483,0 +484,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 10;\n+        }\n@@ -496,0 +502,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 1;\n+        }\n@@ -509,0 +520,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 11;\n+        }\n@@ -521,0 +537,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 16;\n+        }\n@@ -533,0 +554,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 17;\n+        }\n@@ -545,0 +571,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 19;\n+        }\n@@ -557,0 +588,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 18;\n+        }\n@@ -569,0 +605,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 20;\n+        }\n@@ -581,0 +622,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 23;\n+        }\n@@ -593,0 +639,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 22;\n+        }\n@@ -605,0 +656,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 3;\n+        }\n@@ -617,0 +673,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 5;\n+        }\n@@ -629,0 +690,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 6;\n+        }\n@@ -641,0 +707,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 7;\n+        }\n@@ -653,0 +724,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 21;\n+        }\n@@ -665,0 +741,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 2;\n+        }\n@@ -677,0 +758,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 4;\n+        }\n@@ -689,0 +775,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 12;\n+        }\n@@ -701,0 +792,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 13;\n+        }\n@@ -713,0 +809,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 14;\n+        }\n@@ -725,0 +826,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 15;\n+        }\n@@ -737,0 +843,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 9;\n+        }\n@@ -749,0 +860,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 8;\n+        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.*;\n@@ -39,1 +40,0 @@\n-import java.io.StringWriter;\n@@ -45,3 +45,1 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectOutputStream;\n+import java.lang.foreign.MemorySegment;\n@@ -50,0 +48,2 @@\n+import java.nio.FloatBuffer;\n+import java.nio.channels.FileChannel;\n@@ -59,0 +59,1 @@\n+import static oracle.code.onnx.OnnxOperators.Cast;\n@@ -103,1 +104,4 @@\n-            Tensor<Float> inputImage) {\n+            Tensor<Byte> ubyteImage) {\n+\n+        Tensor<Float> inputImage = Cast(ubyteImage, empty(), Tensor.ElementType.FLOAT.id);\n+\n@@ -167,1 +171,1 @@\n-    CoreOp.FuncOp cnnModel() {\n+    static CoreOp.FuncOp cnnModel() {\n@@ -182,1 +186,1 @@\n-                OnnxType.TENSOR_FLOAT32 \/\/ input\n+                OnnxType.TENSOR_UINT8 \/\/ input\n@@ -197,1 +201,6 @@\n-            Block.Parameter inputImage = b.parameters().get(10);\n+            Block.Parameter ubyteImage = b.parameters().get(10);\n+\n+            var inputImage = b.op(OnnxOps.Cast(OnnxType.TENSOR_FLOAT32,\n+                    ubyteImage,\n+                    empty(),\n+                    OnnxType.TENSOR_FLOAT32.eType().id()));\n@@ -325,0 +334,51 @@\n+    static List<Tensor> loadWeights() throws IOException {\n+        try (var is = CNNTest.class.getResourceAsStream(\"lenet-torchscript.onnx\")) {\n+            return OnnxMl.ModelProto.parseFrom(is).getGraph().getInitializerList().stream()\n+                    .map(init ->  {\n+                        var bb = ByteBuffer.allocateDirect(init.getRawData().size());\n+                        init.getRawData().copyTo(bb);\n+                        return new Tensor(OnnxRuntime.getInstance().createTensor(\n+                                MemorySegment.ofBuffer(bb.rewind()),\n+                                Tensor.ElementType.fromOnnxId(init.getDataType()),\n+                                init.getDimsList().stream().mapToLong(a -> a).toArray()));\n+                    })\n+                    .toList();\n+        }\n+    }\n+\n+    static int nextBestMatch(FloatBuffer fb) {\n+        float maxW = fb.get();\n+        int maxI = 0;\n+        for (int i = 1; i < 10; i++) {\n+            float w = fb.get();\n+            if (w > maxW) {\n+                maxW = w;\n+                maxI = i;\n+            }\n+        }\n+        return maxI;\n+    }\n+\n+    private static final String GREY_SCALE = \" .'`^\\\",:;Il!i><~+_-?][}{1)(|\\\\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$\";\n+\n+    static void printImage(int imageIndex, ByteBuffer bb) {\n+        System.out.println(\"Image #\" + imageIndex + \" :\");\n+        int offset = imageIndex * 28 * 28;\n+        for (int y = 0; y < 28; y++) {\n+            for (int x = 0; x < 28; x++) {\n+                System.out.print(GREY_SCALE.charAt(GREY_SCALE.length() * (0xff & bb.get(offset + y * 28 + x)) \/ 256));\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+\/\/    static final String IMAGES_PATH = \"t10k-images-idx3-ubyte\";\n+\/\/    static final String LABELS_PATH = \"t10k-labels-idx1-ubyte\";\n+\/\/    static final int IMAGES_HEADER_SIZE = 16;\n+\/\/    static final int LABELS_HEADER_SIZE = 8;\n+\n+    static final String IMAGES_PATH = CNNTest.class.getResource(\"images-ubyte\").getPath();\n+    static final String LABELS_PATH = CNNTest.class.getResource(\"labels-ubyte\").getPath();\n+    static final int IMAGES_HEADER_SIZE = 0;\n+    static final int LABELS_HEADER_SIZE = 0;\n+\n@@ -326,1 +386,1 @@\n-    public void test() {\n+    public void test() throws Exception {\n@@ -330,1 +390,0 @@\n-\n@@ -335,0 +394,33 @@\n+\n+        try (RandomAccessFile imagesF = new RandomAccessFile(IMAGES_PATH, \"r\");\n+             RandomAccessFile labelsF = new RandomAccessFile(LABELS_PATH, \"r\")) {\n+\n+            ByteBuffer imagesIn = imagesF.getChannel().map(FileChannel.MapMode.READ_ONLY, IMAGES_HEADER_SIZE, imagesF.length() - IMAGES_HEADER_SIZE);\n+            ByteBuffer labelsIn = labelsF.getChannel().map(FileChannel.MapMode.READ_ONLY, LABELS_HEADER_SIZE, labelsF.length() - LABELS_HEADER_SIZE);\n+\n+            List<Tensor> weights = loadWeights();\n+            Tensor inputImage = new Tensor(MemorySegment.ofBuffer(imagesIn), Tensor.ElementType.UINT8, new long[]{imagesF.length()});\n+\n+            FloatBuffer result = new Tensor(OnnxRuntime.getInstance().runFunc(\n+                    onnxModel,\n+                    Stream.concat(weights.stream(), Stream.of(inputImage))\n+                            .map(t -> Optional.of(t.tensorAddr)).toList()).getFirst())\n+                    .asByteBuffer().asFloatBuffer();\n+\n+            int matched = 0, mismatched = 0;\n+            while (result.remaining() > 0) {\n+                int expected = labelsIn.get();\n+                int actual = nextBestMatch(result);\n+                if (expected == actual) {\n+                    matched++;\n+                } else {\n+                    int imageIndex = labelsIn.position() - 1;\n+                    printImage(imageIndex, imagesIn);\n+                    System.out.println(\"expected: \" + expected + \" actual: \" + actual);\n+                    System.out.println(\"-\".repeat(28));\n+                    mismatched++;\n+                }\n+            }\n+            System.out.println(\"matched: \" + matched + \" mismatched: \" + mismatched);\n+            Assertions.assertTrue(mismatched \/ matched < 0.05);\n+        }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":102,"deletions":10,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx;\n+\n+import java.awt.*;\n+import java.awt.event.*;\n+import java.awt.image.BufferedImage;\n+import java.io.*;\n+import jdk.incubator.code.CodeReflection;\n+import java.util.Optional;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.FloatBuffer;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import jdk.incubator.code.Op;\n+import oracle.code.onnx.compiler.OnnxTransformer;\n+\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static oracle.code.onnx.OnnxOperators.*;\n+import static oracle.code.onnx.Tensor.ElementType.*;\n+\n+public class DigitRecognizer {\n+\n+    private static final int PIXEL_DEPTH = 255;\n+\n+    private static float[] loadConstant(String resource) throws IOException {\n+        var bb = ByteBuffer.wrap(DigitRecognizer.class.getResourceAsStream(resource).readAllBytes());\n+        return FloatBuffer.allocate(bb.capacity() \/ 4).put(bb.asFloatBuffer()).array();\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> cnn(Tensor<Float> inputImage) throws IOException {\n+\n+        \/\/ Scaling and inverting the grayscale to 0-1\n+        var scalingFactor = Constant((float) PIXEL_DEPTH);\n+        var scaledInput = Div(Sub(scalingFactor, inputImage), scalingFactor);\n+\n+        \/\/ First conv layer\n+        var conv1Weights = Reshape(Constant(loadConstant(\"conv1-weight-float\")), Constant(new long[]{6, 1, 5, 5}), empty());\n+        var conv1Biases = Reshape(Constant(loadConstant(\"conv1-bias-float\")), Constant(new long[]{6}), empty());\n+        var conv1 = Conv(scaledInput, conv1Weights, of(conv1Biases), of(new long[4]),\n+                of(new long[]{1,1}), empty(), of(new long[]{1, 1, 1, 1}),\n+                of(1L), of(new long[]{5,5}));\n+        var relu1 = Relu(conv1);\n+\n+        \/\/ First pooling layer\n+        var pool1 = MaxPool(relu1, of(new long[4]), of(new long[]{1,1}), empty(),\n+                of(0L), empty(), of(new long[]{2, 2}), new long[]{2, 2});\n+\n+        \/\/ Second conv layer\n+        var conv2Weights = Reshape(Constant(loadConstant(\"conv2-weight-float\")), Constant(new long[]{16, 6, 5, 5}), empty());\n+        var conv2Biases = Reshape(Constant(loadConstant(\"conv2-bias-float\")), Constant(new long[]{16}), empty());\n+        var conv2 = Conv(pool1.Y(), conv2Weights, of(conv2Biases), of(new long[4]),\n+                of(new long[]{1,1}), empty(), of(new long[]{1, 1, 1, 1}),\n+                of(1L), of(new long[]{5,5}));\n+        var relu2 = Relu(conv2);\n+\n+        \/\/ Second pooling layer\n+        var pool2 = MaxPool(relu2, of(new long[4]), of(new long[]{1,1}), empty(),\n+                of(0L), empty(), of(new long[]{2, 2}), new long[]{2, 2});\n+\n+        \/\/ Flatten inputs\n+        var flatten = Flatten(pool2.Y(), of(1L));\n+\n+        \/\/ First fully connected layer\n+        var fc1Weights = Reshape(Constant(loadConstant(\"fc1-weight-float\")), Constant(new long[]{120, 256}), empty());\n+        var fc1Biases = Reshape(Constant(loadConstant(\"fc1-bias-float\")), Constant(new long[]{120}), empty());\n+        var fc1 = Gemm(flatten, fc1Weights, of(fc1Biases), of(1f), of(1L), of(1f), empty());\n+        var relu3 = Relu(fc1);\n+\n+        \/\/ Second fully connected layer\n+        var fc2Weights = Reshape(Constant(loadConstant(\"fc2-weight-float\")), Constant(new long[]{84, 120}), empty());\n+        var fc2Biases = Reshape(Constant(loadConstant(\"fc2-bias-float\")), Constant(new long[]{84}), empty());\n+        var fc2 = Gemm(relu3, fc2Weights, of(fc2Biases), of(1f), of(1L), of(1f), empty());\n+        var relu4 = Relu(fc2);\n+\n+        \/\/ Softmax layer\n+        var fc3Weights = Reshape(Constant(loadConstant(\"fc3-weight-float\")), Constant(new long[]{10, 84}), empty());\n+        var fc3Biases = Reshape(Constant(loadConstant(\"fc3-bias-float\")), Constant(new long[]{10}), empty());\n+        var fc3 = Gemm(relu4, fc3Weights, of(fc3Biases), of(1f), of(1L), of(1f), empty());\n+        var prediction = Softmax(fc3, of(1L));\n+\n+        return prediction;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var frame = new JFrame(\"Digit Recognizer\");\n+        var pane = new JPanel();\n+        var status = new JLabel(\"   Hold SHIFT key to draw with trackpad, click ENTER to run digit recognition.\");\n+        var robot = new Robot();\n+        var clean = new AtomicBoolean(true);\n+        var session = OnnxRuntime.getInstance().createSession(\n+                OnnxProtoBuilder.buildFuncModel(OnnxTransformer.transform(MethodHandles.lookup(),\n+                        Op.ofMethod(DigitRecognizer.class.getDeclaredMethod(\"cnn\", Tensor.class)).get())));\n+        var image = new BufferedImage(28, 28, BufferedImage.TYPE_BYTE_GRAY);\n+        var graphics = image.createGraphics();\n+        var imageBuffer = ByteBuffer.allocateDirect(28 * 28 * 4).order(ByteOrder.LITTLE_ENDIAN).asFloatBuffer();\n+        var sampleArray = new float[28 * 28];\n+        var inputTensors = List.of(Optional.of(new Tensor(MemorySegment.ofBuffer(imageBuffer), FLOAT, 1, 1, 28, 28).tensorAddr));\n+\n+        frame.setLayout(new BorderLayout());\n+        frame.add(pane, BorderLayout.CENTER);\n+        frame.add(status, BorderLayout.SOUTH);\n+        frame.setBackground(Color.WHITE);\n+        frame.addMouseMotionListener(new MouseAdapter() {\n+            @Override\n+            public void mouseMoved(MouseEvent e) {\n+                if ((e.getModifiersEx() & InputEvent.SHIFT_DOWN_MASK) != 0) {\n+                    if (clean.getAndSet(false)) {\n+                        pane.getGraphics().clearRect(0, 0, pane.getWidth(), pane.getHeight());\n+                    }\n+                    pane.getGraphics().fillOval(e.getX(), e.getY(), 20, 20);\n+                }\n+            }\n+        });\n+        frame.addKeyListener(new KeyAdapter(){\n+            @Override\n+            public void keyPressed(KeyEvent e) {\n+                if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n+                    graphics.drawImage(robot.createScreenCapture(new Rectangle(pane.getLocationOnScreen(), pane.getSize()))\n+                                     .getScaledInstance(28, 28, Image.SCALE_SMOOTH), 0, 0, null);\n+                    imageBuffer.put(0, image.getData().getSamples(0, 0, 28, 28, 0, sampleArray));\n+                    FloatBuffer result = OnnxRuntime.getInstance().tensorBuffer(session.run(inputTensors).getFirst()).asFloatBuffer();\n+                    int max = 0;\n+                    for (int i = 1; i < 10; i++) {\n+                        if (result.get(i) > result.get(max)) max = i;\n+                    }\n+                    var msg = new StringBuilder(\"<html>&nbsp;\");\n+                    for (int i = 0; i < 10; i++) {\n+                        if (max == i) {\n+                            msg.append(\"&nbsp;&nbsp;<b>%d:&nbsp;%.1f%%<\/b>\".formatted(i, 100 * result.get(i)));\n+                        } else {\n+                            msg.append(\"&nbsp;&nbsp;%d:&nbsp;%.1f%%\".formatted(i, result.get(i)));\n+\n+                        }\n+                    }\n+                    status.setText(msg.toString());\n+                    clean.set(true);\n+                }\n+            }\n+        });\n+        frame.setSize(600, 600);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/DigitRecognizer.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -3,2 +3,0 @@\n-import java.nio.FloatBuffer;\n-import java.nio.LongBuffer;\n@@ -6,0 +4,2 @@\n+import java.util.Optional;\n+import oracle.code.onnx.Tensor.ElementType;\n@@ -15,0 +15,2 @@\n+    static final Optional<ElementType> OF_FLOAT = Optional.of(FLOAT);\n+\n@@ -18,2 +20,2 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(FLOAT, FLOAT)));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(FLOAT, FLOAT)))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()))) {\n@@ -27,1 +29,1 @@\n-            var inputTensor = ort.createFlatTensor(-1f, 2, -3, 4, -5, 6);\n+            var inputTensor = Tensor.ofFlat(-1f, 2, -3, 4, -5, 6);\n@@ -29,1 +31,1 @@\n-            var absExpectedTensor = ort.createFlatTensor(1f, 2, 3, 4, 5, 6);\n+            var absExpectedTensor = Tensor.ofFlat(1f, 2, 3, 4, 5, 6);\n@@ -31,1 +33,1 @@\n-            var absResult = absOp.run(List.of(inputTensor));\n+            var absResult = absOp.run(List.of(Optional.of(inputTensor.tensorAddr)));\n@@ -35,1 +37,1 @@\n-            var absOutputTensor = (OnnxRuntime.OrtTensor)absResult.getFirst();\n+            var absOutputTensor = new Tensor(absResult.getFirst());\n@@ -37,1 +39,1 @@\n-            assertTensorEquals(absExpectedTensor, absOutputTensor);\n+            SimpleTest.assertEquals(absExpectedTensor, absOutputTensor);\n@@ -39,1 +41,1 @@\n-            var addResult = addOp.run(List.of(inputTensor, absOutputTensor));\n+            var addResult = addOp.run(List.of(Optional.of(inputTensor.tensorAddr), Optional.of(absOutputTensor.tensorAddr)));\n@@ -43,14 +45,1 @@\n-            var addOutputTensor = (OnnxRuntime.OrtTensor)addResult.getFirst();\n-\n-            var addExpectedTensor = ort.createFlatTensor(0f, 4, 0, 8, 0, 12);\n-\n-            assertTensorEquals(addExpectedTensor, addOutputTensor);\n-        }\n-    }\n-\n-    static void assertTensorEquals(OnnxRuntime.OrtTensor expectedTensor, OnnxRuntime.OrtTensor actualTensor) {\n-        var expectedType = expectedTensor.getTensorTypeAndShape();\n-        var expectedShape = expectedType.getShape();\n-\n-        var actualType = actualTensor.getTensorTypeAndShape();\n-        var actualShape = actualType.getShape();\n+            var addOutputTensor = new Tensor(addResult.getFirst());\n@@ -58,17 +47,1 @@\n-        assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n-        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n-            assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n-        }\n-\n-        assertEquals(expectedType.getTensorElementType(), actualType.getTensorElementType());\n-        assertEquals(expectedType.getTensorShapeElementCount(), actualType.getTensorShapeElementCount());\n-\n-        assertEqualData(expectedTensor.asByteBuffer().asFloatBuffer(), actualTensor.asByteBuffer().asFloatBuffer());\n-    }\n-\n-    static void assertEqualData(FloatBuffer expectedData, FloatBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n-        }\n-    }\n+            var addExpectedTensor = Tensor.ofFlat(0f, 4, 0, 8, 0, 12);\n@@ -76,4 +49,1 @@\n-    static void assertEqualData(LongBuffer expectedData, LongBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i));\n+            SimpleTest.assertEquals(addExpectedTensor, addOutputTensor);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":15,"deletions":45,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -4,1 +5,3 @@\n-import java.util.List;\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n@@ -6,0 +9,1 @@\n+import java.util.stream.Stream;\n@@ -10,0 +14,1 @@\n+import org.junit.jupiter.api.Assertions;\n@@ -12,2 +17,0 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-\n@@ -16,2 +19,0 @@\n-    \/\/ Java code model -> ONNX code model -> ONNX runtime instance -> execute via ORT\n-    \/\/ Run directly, each operation reflectively executes via ORT\n@@ -25,2 +26,2 @@\n-        var a = new Tensor(1f, 2, 3);\n-        var b = new Tensor(6f, 5, 4);\n+        var a = Tensor.ofFlat(1f, 2, 3);\n+        var b = Tensor.ofFlat(6f, 5, 4);\n@@ -29,2 +30,53 @@\n-                new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"add\", Tensor.class, Tensor.class),\n-                        List.of(a.rtTensor, b.rtTensor)).getFirst()));\n+                runModel(\"add\", a, b));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstant() {\n+        return OnnxOperators.Constant(-1f);\n+    }\n+\n+    @Test\n+    public void testFconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = Tensor.ofScalar(-1f);\n+        assertEquals(expected, fconstant());\n+        assertEquals(expected, runModel(\"fconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstants() {\n+        return OnnxOperators.Constant(new float[]{-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testFconstants() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = Tensor.ofFlat(-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE);\n+        assertEquals(expected, fconstants());\n+        assertEquals(expected, runModel(\"fconstants\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstant() {\n+        return OnnxOperators.Constant(-1l);\n+    }\n+\n+    @Test\n+    public void testLconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = Tensor.ofScalar(-1l);\n+        assertEquals(expected, lconstant());\n+        assertEquals(expected, runModel(\"lconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstants() {\n+        return OnnxOperators.Constant(new long[]{-1, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testLconstants() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = Tensor.ofFlat(-1l, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE);\n+        assertEquals(expected, lconstants());\n+        assertEquals(expected, runModel(\"lconstants\"));\n@@ -40,5 +92,11 @@\n-        var data = new Tensor(1f, 2, 3, 4, 5, 6, 7, 8);\n-        var shape = new Tensor(2l, 2, 2);\n-        assertEquals(shape, reshapeAndShape(data, shape));\n-        assertEquals(shape, new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"reshapeAndShape\", Tensor.class, Tensor.class),\n-                        List.of(data.rtTensor, shape.rtTensor)).getFirst()));\n+        var data = Tensor.ofFlat(1f, 2, 3, 4, 5, 6, 7, 8);\n+        var shape = Tensor.ofFlat(2l, 2, 2);\n+        assertEquals(\n+                reshapeAndShape(data, shape),\n+                runModel(\"reshapeAndShape\", data, shape));\n+    }\n+\n+    private static Tensor runModel(String name, Tensor... params) throws NoSuchMethodException {\n+        return new Tensor(OnnxRuntime.getInstance().runFunc(\n+                getOnnxModel(name),\n+                Stream.of(params).map(t -> Optional.ofNullable(t.tensorAddr)).toList()).getFirst());\n@@ -47,1 +105,1 @@\n-    private static CoreOp.FuncOp getOnnxModel(String name, Class... params) throws NoSuchMethodException {\n+    private static CoreOp.FuncOp getOnnxModel(String name) throws NoSuchMethodException {\n@@ -49,1 +107,1 @@\n-                Op.ofMethod(SimpleTest.class.getDeclaredMethod(name, params)).get());\n+                Op.ofMethod(Stream.of(SimpleTest.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get()).get());\n@@ -52,4 +110,15 @@\n-    static void assertEquals(Tensor actual, Tensor expected) {\n-        var expectedTS = expected.rtTensor.getTensorTypeAndShape();\n-        var actualTS = actual.rtTensor.getTensorTypeAndShape();\n-        assertSame(expectedTS.getTensorElementType(), actualTS.getTensorElementType());\n+    static void assertEquals(Tensor expected, Tensor actual) {\n+        assertEquals(expected.tensorAddr, actual.tensorAddr);\n+    }\n+\n+    static void assertEquals(MemorySegment expectedTensorAddr, MemorySegment actualTensorAddr) {\n+\n+        var rt = OnnxRuntime.getInstance();\n+\n+        var expectedType = rt.tensorElementType(expectedTensorAddr);\n+        var expectedShape = rt.tensorShape(expectedTensorAddr);\n+        var expectedBB = rt.tensorBuffer(expectedTensorAddr);\n+\n+        var actualType = rt.tensorElementType(actualTensorAddr);\n+        var actualShape = rt.tensorShape(actualTensorAddr);\n+        var actualBB = rt.tensorBuffer(actualTensorAddr);\n@@ -57,1 +126,1 @@\n-        \/\/ @@@ assert equal shapes\n+        Assertions.assertSame(expectedType, actualType);\n@@ -59,1 +128,5 @@\n-        switch (actualTS.getTensorElementType()) {\n+        Assertions.assertArrayEquals(expectedShape, actualShape);\n+\n+        switch (actualType) {\n+            case UINT8, INT8, UINT16, INT16, INT32, INT64, STRING, BOOL, UINT32, UINT64, UINT4, INT4 ->\n+                assertEquals(expectedBB, actualBB);\n@@ -61,3 +134,3 @@\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asFloatBuffer(), actual.rtTensor.asByteBuffer().asFloatBuffer());\n-            case INT64 ->\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asLongBuffer(), actual.rtTensor.asByteBuffer().asLongBuffer());\n+                assertEquals(expectedBB.asFloatBuffer(), actualBB.asFloatBuffer());\n+            case DOUBLE ->\n+                assertEquals(expectedBB.asDoubleBuffer(), actualBB.asDoubleBuffer());\n@@ -65,1 +138,22 @@\n-                throw new UnsupportedOperationException(); \/\/ @@@ ToDo\n+                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType);\n+        }\n+    }\n+\n+    static void assertEquals(ByteBuffer expectedData, ByteBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i));\n+        }\n+    }\n+\n+    static void assertEquals(FloatBuffer expectedData, FloatBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n+        }\n+    }\n+\n+    static void assertEquals(DoubleBuffer expectedData, DoubleBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":120,"deletions":26,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+S)==Ug#K\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv1-bias-float","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv1-weight-float","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+q=2Ar<JF,=SL)#=<H9Q=[\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv2-bias-float","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv2-weight-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc1-bias-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc1-weight-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc2-bias-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc2-weight-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc3-bias-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc3-weight-float","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/images-ubyte","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/labels-ubyte","binary":true,"status":"added"}]}