{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -40,1 +41,6 @@\n-                    inputs.stream().map(o -> ((Tensor)o).rtTensor).toList());\n+                    inputs.stream().map(o -> Optional.ofNullable(switch (o) {\n+                        case Tensor t -> t.tensorAddr;\n+                        case Optional ot when ot.isPresent() && ot.get() instanceof Tensor t -> t.tensorAddr;\n+                        default -> null;\n+                    })).toList(),\n+                    attributes);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.math.BigInteger;\n@@ -9,1 +10,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -11,0 +11,1 @@\n+import jdk.incubator.code.op.CoreOp;\n@@ -197,5 +198,3 @@\n-        long expanded = Long.expand(number, 0x7f7f7f7f7f7f7f7fl);\n-        int bytesSize = Math.max(1, 8 - Long.numberOfLeadingZeros(expanded) \/ 8);\n-        for (int i = 1; i < bytesSize; i++) {\n-            buf.write(0x80 | (int)expanded & 0x7f);\n-            expanded >>= 8;\n+        for (int i = 64 - Long.numberOfLeadingZeros(number); i > 7; i -= 7) {\n+            buf.write(0x80 | (int)number & 0x7f);\n+            number >>= 7;\n@@ -203,1 +202,1 @@\n-        buf.write((int)expanded & 0x7f);\n+        buf.write((int)number & 0x7f);\n@@ -264,1 +263,1 @@\n-    static final int OPSET_VERSION = 14;\n+    static final int OPSET_VERSION = 21;\n@@ -267,2 +266,1 @@\n-    \/\/ order of building defines order inside protobufs\n-    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<ElementType> inputElementTypes) {\n+    static ByteBuffer buildOpModel(OnnxOp.OnnxSchema schema, List<java.util.Optional<ElementType>> inputElementTypes, List<Object> attributes) {\n@@ -272,0 +270,9 @@\n+                        .forEach(schema.inputs(), (g, i) -> {\n+                            if (inputElementTypes.get(i.ordinal()).isPresent()) {\n+                                g.input(new ValueInfoProto()\n+                                    .name(i.name())\n+                                    .type(new TypeProto()\n+                                            \/\/ inputValues match schema inputs by OnnxParameter::ordinal\n+                                            .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).get().id))));\n+                            }\n+                        })\n@@ -275,6 +282,12 @@\n-                            .op_type(schema.name()))\n-                        .forEach(schema.inputs(), (g, i) -> g.input(new ValueInfoProto()\n-                                .name(i.name())\n-                                .type(new TypeProto()\n-                                        \/\/ inputValues matching schema inputs by OnnxParameter::ordinal\n-                                        .tensor_type(new Tensor().elem_type(inputElementTypes.get(i.ordinal()).id)))))\n+                            .op_type(schema.name())\n+                            .forEach(schema.attributes(), (n, a) -> {\n+                                \/\/ attributes match schema by OnnxAttribute::ordinal\n+                                var attrValue = attributes.get(a.ordinal());\n+                                if (a.isOptional()) {\n+                                    if (attrValue instanceof java.util.Optional o && o.isPresent()) {\n+                                        n.attribute(buildAttribute(a.name(), o.get()));\n+                                    }\n+                                } else {\n+                                    n.attribute(buildAttribute(a.name(), attrValue));\n+                                }\n+                            }))\n@@ -288,52 +301,4 @@\n-    private static int toElementType(TypeElement type) {\n-        if (type == OnnxType.TENSOR_FLOAT32) {\n-            return 1;\n-        } else if(type == OnnxType.TENSOR_UINT8) {\n-            return 2;\n-        } else if(type == OnnxType.TENSOR_INT8) {\n-            return 3;\n-        } else if(type == OnnxType.TENSOR_UINT16) {\n-            return 4;\n-        } else if(type == OnnxType.TENSOR_INT16) {\n-            return 5;\n-        } else if(type == OnnxType.TENSOR_INT32) {\n-            return 6;\n-        } else if(type == OnnxType.TENSOR_INT64) {\n-            return 7;\n-        } else if(type == OnnxType.TENSOR_STRING) {\n-            return 8;\n-        } else if(type == OnnxType.TENSOR_BOOL) {\n-            return 9;\n-        } else if(type == OnnxType.TENSOR_FLOAT16) {\n-            return 10;\n-        } else if(type == OnnxType.TENSOR_FLOAT64) {\n-            return 11;\n-        } else if(type == OnnxType.TENSOR_UINT32) {\n-            return 12;\n-        } else if(type == OnnxType.TENSOR_UINT64) {\n-            return 13;\n-        } else if(type == OnnxType.TENSOR_COMPLEX64) {\n-            return 14;\n-        } else if(type == OnnxType.TENSOR_COMPLEX128) {\n-            return 15;\n-        } else if(type == OnnxType.TENSOR_BFLOAT16) {\n-            return 16;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FN) {\n-            return 17;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E4M3FNUZ) {\n-            return 18;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2) {\n-            return 19;\n-        } else if(type == OnnxType.TENSOR_FLOAT8E5M2FNUZ) {\n-            return 20;\n-        } else if(type == OnnxType.TENSOR_UINT4) {\n-            return 21;\n-        } else if(type == OnnxType.TENSOR_INT4) {\n-            return 22;\n-        } else if(type == OnnxType.TENSOR_FLOAT4E2M1) {\n-            return 23;\n-        } else {\n-            throw new RuntimeException(type.toString());\n-        }\n-    }\n-\n+    \/\/ @@@ unchecked constraints:\n+    \/\/         tensor FuncOp parameters and single tensor return type\n+    \/\/         OnnxOps (with tensor operands and single tensor return value) and ReturnOp (returning single tensor)\n+    \/\/         entry block only\n@@ -350,0 +315,4 @@\n+                        .forEach(entryBlock.parameters(), (g, p) -> g.input(new ValueInfoProto()\n+                                .name(indexer.getName(p))\n+                                .type(new TypeProto()\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)p.type()).eType().id())))))\n@@ -351,5 +320,16 @@\n-                            if (op instanceof OnnxOp) {\n-                                g.node(new NodeProto()\n-                                        .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n-                                        .output(indexer.getName(op.result()))\n-                                        .op_type(op.opName()));\n+                            switch (op) {\n+                                case OnnxOp onnxOp ->\n+                                    g.node(new NodeProto()\n+                                            .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n+                                            .output(indexer.getName(op.result()))\n+                                            .op_type(op.opName())\n+                                            .forEach(onnxOp.onnxAttributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue()))));\n+                                case CoreOp.ReturnOp _ -> {\n+                                     \/\/ skip\n+                                }\n+                                case CoreOp.TupleLoadOp _ -> {\n+                                    \/\/ @@@ hack to forward to the first from the tuple\n+                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst()));\n+                                }\n+                                default ->\n+                                    throw new UnsupportedOperationException(op.toText());\n@@ -358,4 +338,0 @@\n-                        .forEach(model.parameters(), (g, p) -> g.input(new ValueInfoProto()\n-                                .name(indexer.getName(p))\n-                                .type(new TypeProto()\n-                                        .tensor_type(new Tensor().elem_type(toElementType(p.type()))))))\n@@ -365,1 +341,1 @@\n-                                        .tensor_type(new Tensor().elem_type(toElementType(model.body().yieldType()))))))\n+                                        .tensor_type(new Tensor().elem_type(((OnnxType.TensorType)model.body().yieldType()).eType().id())))))\n@@ -370,0 +346,24 @@\n+\n+    static Attribute buildAttribute(String name, Object value) {\n+        var attr = new Attribute().name(name);\n+        switch (value) {\n+            case Float f -> {\n+                attr.type(1).f(f);\n+            }\n+            case Long l -> {\n+                attr.type(2).i(l);\n+            }\n+            case float[] floats -> {\n+                attr.type(6);\n+                for (float f : floats) attr.floats(f);\n+            }\n+            case long[] longs -> {\n+                attr.type(7);\n+                for (long l : longs) attr.ints(l);\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException(value.getClass().toString()); \/\/ @@@ ToDo\n+            }\n+        }\n+        return attr;\n+    }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":78,"deletions":78,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -12,1 +12,0 @@\n-import java.nio.LongBuffer;\n@@ -19,3 +18,1 @@\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n+import java.util.Optional;\n@@ -30,1 +27,1 @@\n-    private static final int LOG_LEVEL = 0; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n+    private static final int LOG_LEVEL = 3; \/\/ 0 - verbose, 1 - info, 2 - warning, 3 - error, 4 - fatal\n@@ -78,3 +75,0 @@\n-                                castTypeInfoToMapTypeInfo,\n-                                castTypeInfoToSequenceTypeInfo,\n-                                castTypeInfoToTensorInfo,\n@@ -88,1 +82,0 @@\n-                                getOnnxTypeFromTypeInfo,\n@@ -98,1 +91,0 @@\n-                                sessionGetInputTypeInfo,\n@@ -101,1 +93,0 @@\n-                                sessionGetOutputTypeInfo,\n@@ -122,3 +113,0 @@\n-        castTypeInfoToMapTypeInfo      = handle(103, ADDRESS, ADDRESS);\n-        castTypeInfoToSequenceTypeInfo = handle(104, ADDRESS, ADDRESS);\n-        castTypeInfoToTensorInfo       = handle( 55, ADDRESS, ADDRESS);\n@@ -132,1 +120,0 @@\n-        getOnnxTypeFromTypeInfo        = handle( 56, ADDRESS, ADDRESS);\n@@ -142,1 +129,0 @@\n-        sessionGetInputTypeInfo        = handle( 33, ADDRESS, JAVA_INT, ADDRESS);\n@@ -145,1 +131,0 @@\n-        sessionGetOutputTypeInfo       = handle( 34, ADDRESS, JAVA_INT, ADDRESS);\n@@ -168,2 +153,2 @@\n-    public enum ONNXType {\n-        UNKNOWN, TENSOR, SEQUENCE, MAP, OPAQUE, SPARSETENSOR, OPTIONAL\n+    private List<Optional<Tensor.ElementType>> toElementTypes(List<Optional<MemorySegment>> values) {\n+        return values.stream().map(ot -> ot.map(this::tensorElementType)).toList();\n@@ -172,6 +157,2 @@\n-    private static List<Tensor.ElementType> toElementTypes(List<OrtTensor> values) {\n-        return values.stream().map(OrtTensor::getTensorTypeAndShape).map(OrtTensorTypeAndShapeInfo::getTensorElementType).toList();\n-    }\n-\n-    public List<OrtTensor> runOp(OnnxOp.OnnxSchema schema, List<OrtTensor> inputValues) {\n-        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues));\n+    public List<MemorySegment> runOp(OnnxOp.OnnxSchema schema, List<Optional<MemorySegment>> inputValues, List<Object> attributes) {\n+        var protoModel = OnnxProtoBuilder.buildOpModel(schema, toElementTypes(inputValues), attributes);\n@@ -183,1 +164,1 @@\n-    public List<OrtTensor> runFunc(CoreOp.FuncOp model, List<OrtTensor> inputValues) {\n+    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<Optional<MemorySegment>> inputValues) {\n@@ -254,34 +235,0 @@\n-        public OrtTypeInfo getInputTypeInfo(int inputIndex) {\n-            try {\n-                return getTypeInfo(retAddr(sessionGetInputTypeInfo.invokeExact(sessionAddress, inputIndex, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public OrtTypeInfo getOutputTypeInfo(int outputIndex) {\n-            try {\n-                return getTypeInfo(retAddr(sessionGetOutputTypeInfo.invokeExact(sessionAddress, outputIndex, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        private OrtTypeInfo getTypeInfo(MemorySegment typeAddress) {\n-            try {\n-                var type = ONNXType.values()[retInt(getOnnxTypeFromTypeInfo.invokeExact(typeAddress, ret))];\n-                return switch (type) {\n-                    case TENSOR, SPARSETENSOR ->\n-                        new OrtTensorTypeAndShapeInfo(retAddr(castTypeInfoToTensorInfo.invokeExact(typeAddress, ret)));\n-                    case SEQUENCE ->\n-                        new SequenceTypeInfo(retAddr(castTypeInfoToSequenceTypeInfo.invokeExact(typeAddress, ret)));\n-                    case MAP ->\n-                        new MapTypeInfo(retAddr(castTypeInfoToMapTypeInfo.invokeExact(typeAddress, ret)));\n-                    default ->\n-                        throw new IllegalArgumentException(\"Invalid element type found in sequence \" + type);\n-                };\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n@@ -289,1 +236,1 @@\n-        public List<OrtTensor> run(List<OrtTensor> inputValues) {\n+        public List<MemorySegment> run(List<Optional<MemorySegment>> inputValues) {\n@@ -297,2 +244,4 @@\n-                inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n-                inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).valueAddress());\n+                if (inputValues.get(i).isPresent()) {\n+                    inputNames.setAtIndex(ADDRESS, index, arena.allocateFrom(getInputName(i)));\n+                    inputs.setAtIndex(ADDRESS, index++, inputValues.get(i).get());\n+                }\n@@ -308,1 +257,1 @@\n-                var retArr = new OrtTensor[outputLen];\n+                var retArr = new MemorySegment[outputLen];\n@@ -310,1 +259,1 @@\n-                    retArr[i] = new OrtTensor(outputs.getAtIndex(ADDRESS, i));\n+                    retArr[i] = outputs.getAtIndex(ADDRESS, i);\n@@ -328,7 +277,2 @@\n-    public OrtTensor loadFlatTensorFromMemoryMappedDataFile(String file, Tensor.ElementType elementType) throws IOException {\n-        var f = new RandomAccessFile(file, \"r\");\n-        return createFlatTensor(f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena), elementType);\n-    }\n-\n-    OrtTensor createFlatTensor(long... elements) {\n-        return createFlatTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64);\n+    public MemorySegment createScalar(long element) {\n+        return createScalar(arena.allocateFrom(JAVA_LONG, element), Tensor.ElementType.INT64);\n@@ -337,2 +281,2 @@\n-    OrtTensor createFlatTensor(float... elements) {\n-        return createFlatTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT);\n+    public MemorySegment createScalar(float element) {\n+        return createScalar(arena.allocateFrom(JAVA_FLOAT, element), Tensor.ElementType.FLOAT);\n@@ -341,2 +285,1 @@\n-    private OrtTensor createFlatTensor(MemorySegment flatData, Tensor.ElementType elementType) {\n-        var flatShape = new TensorShape(flatData.byteSize() \/ elementType.size());\n+    private MemorySegment createScalar(MemorySegment flatData, Tensor.ElementType elementType) {\n@@ -345,1 +288,1 @@\n-            return new OrtTensor(retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), flatShape.dataAddress, 1l, elementType.id, ret)));\n+            return retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), MemorySegment.NULL, 0l, elementType.id, ret));\n@@ -351,19 +294,2 @@\n-    public final class TensorShape {\n-\n-        private final MemorySegment dataAddress;\n-\n-        public TensorShape(long... dimensions) {\n-            this(arena.allocateFrom(JAVA_LONG, dimensions));\n-        }\n-\n-        private TensorShape(MemorySegment dataAddress) {\n-            this.dataAddress = dataAddress;\n-        }\n-\n-        public long getDimensionsCount() {\n-            return dataAddress.byteSize() \/ JAVA_LONG.byteSize();\n-        }\n-\n-        public long getDimension(long index) {\n-            return dataAddress.getAtIndex(JAVA_LONG, index);\n-        }\n+    public MemorySegment createFlatTensor(byte... elements) {\n+        return createTensor(arena.allocateFrom(JAVA_BYTE, elements), Tensor.ElementType.UINT8, new long[]{elements.length});\n@@ -372,4 +298,2 @@\n-    public sealed interface OrtValue {\n-\n-        MemorySegment valueAddress();\n-\n+    public MemorySegment createFlatTensor(long... elements) {\n+        return createTensor(arena.allocateFrom(JAVA_LONG, elements), Tensor.ElementType.INT64, new long[]{elements.length});\n@@ -378,3 +302,3 @@\n-    public final class OrtTensor implements OrtValue {\n-\n-        private final MemorySegment valueAddress;\n+    public MemorySegment createFlatTensor(float... elements) {\n+        return createTensor(arena.allocateFrom(JAVA_FLOAT, elements), Tensor.ElementType.FLOAT, new long[]{elements.length});\n+    }\n@@ -382,2 +306,7 @@\n-        private OrtTensor(MemorySegment valueAddress) {\n-            this.valueAddress = valueAddress;\n+    public MemorySegment createTensor(MemorySegment flatData, Tensor.ElementType elementType, long[] shape) {\n+        try {\n+            var allocatorInfo = retAddr(allocatorGetInfo.invokeExact(defaultAllocatorAddress, ret));\n+            var shapeAddr = arena.allocateFrom(JAVA_LONG, shape);\n+            return retAddr(createTensorWithDataAsOrtValue.invokeExact(allocatorInfo, flatData, flatData.byteSize(), shapeAddr, (long)shape.length, elementType.id, ret));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -385,0 +314,1 @@\n+    }\n@@ -386,3 +316,6 @@\n-        @Override\n-        public MemorySegment valueAddress() {\n-            return valueAddress;\n+    public Tensor.ElementType tensorElementType(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddr, ret)));\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -390,0 +323,1 @@\n+    }\n@@ -391,6 +325,9 @@\n-        public OrtTensorTypeAndShapeInfo getTensorTypeAndShape() {\n-            try {\n-                return new OrtTensorTypeAndShapeInfo(retAddr(getTensorTypeAndShape.invokeExact(valueAddress, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+    public long[] tensorShape(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            long dims = retLong(getDimensionsCount.invokeExact(infoAddr, ret));\n+            var shape = arena.allocate(JAVA_LONG, dims);\n+            checkStatus(getDimensions.invokeExact(infoAddr, shape, dims));\n+            return shape.toArray(JAVA_LONG);\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -398,0 +335,1 @@\n+    }\n@@ -399,10 +337,10 @@\n-        public ByteBuffer asByteBuffer() {\n-            var type = getTensorTypeAndShape();\n-            long size = type.getTensorShapeElementCount() * type.getTensorElementType().size();\n-            try {\n-                return retAddr(getTensorMutableData.invokeExact(valueAddress, ret))\n-                        .reinterpret(size)\n-                        .asByteBuffer().order(ByteOrder.nativeOrder());\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n+    public ByteBuffer tensorBuffer(MemorySegment tensorAddr) {\n+        try {\n+            var infoAddr = retAddr(getTensorTypeAndShape.invokeExact(tensorAddr, ret));\n+            long size = retLong(getTensorShapeElementCount.invokeExact(infoAddr, ret))\n+                    * Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddr, ret))).size();\n+            return retAddr(getTensorMutableData.invokeExact(tensorAddr, ret))\n+                    .reinterpret(size)\n+                    .asByteBuffer().order(ByteOrder.nativeOrder());\n+        } catch (Throwable t) {\n+            throw wrap(t);\n@@ -438,65 +376,0 @@\n-    public sealed interface OrtTypeInfo {\n-    }\n-\n-    public final class OrtTensorTypeAndShapeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private OrtTensorTypeAndShapeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-\n-        public long getDimensionsCount() {\n-            try {\n-                return retLong(getDimensionsCount.invokeExact(infoAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public Tensor.ElementType getTensorElementType() {\n-            try {\n-                return Tensor.ElementType.fromOnnxId(retInt(getTensorElementType.invokeExact(infoAddress, ret)));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public long getTensorShapeElementCount() {\n-            try {\n-                return retLong(getTensorShapeElementCount.invokeExact(infoAddress, ret));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-        }\n-\n-        public TensorShape getShape() {\n-            long dims = getDimensionsCount();\n-            var shape = arena.allocate(JAVA_LONG, dims);\n-            try {\n-                checkStatus(getDimensions.invokeExact(infoAddress, shape, dims));\n-            } catch (Throwable t) {\n-                throw wrap(t);\n-            }\n-            return new TensorShape(shape);\n-        }\n-    }\n-\n-    public final class SequenceTypeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private SequenceTypeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-    }\n-\n-    public final class MapTypeInfo implements OrtTypeInfo {\n-\n-        private final MemorySegment infoAddress;\n-\n-        private MapTypeInfo(MemorySegment infoAddress) {\n-            this.infoAddress = infoAddress;\n-        }\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":62,"deletions":189,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+\n@@ -66,1 +69,13 @@\n-    final OnnxRuntime.OrtTensor rtTensor;\n+    final MemorySegment tensorAddr;\n+\n+    public Tensor(long data) {\n+        this(OnnxRuntime.getInstance().createScalar(data));\n+    }\n+\n+    public Tensor(float data) {\n+        this(OnnxRuntime.getInstance().createScalar(data));\n+    }\n+\n+    public Tensor(byte... data) {\n+        this(OnnxRuntime.getInstance().createFlatTensor(data));\n+    }\n@@ -76,2 +91,10 @@\n-    Tensor(OnnxRuntime.OrtTensor rtTensor) {\n-        this.rtTensor = rtTensor;\n+    public Tensor(MemorySegment dataAddr, ElementType elementType) {\n+        this(OnnxRuntime.getInstance().createTensor(dataAddr, elementType, new long[]{dataAddr.byteSize() \/ elementType.size()}));\n+    }\n+\n+    Tensor(MemorySegment tensorAddr) {\n+        this.tensorAddr = tensorAddr;\n+    }\n+\n+    public ByteBuffer asByteBuffer() {\n+        return OnnxRuntime.getInstance().tensorBuffer(tensorAddr);\n@@ -80,1 +103,1 @@\n-    enum ElementType {\n+    public enum ElementType {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -224,0 +224,2 @@\n+            } else if (elementType.equals(JavaType.J_L_BYTE)) {\n+                return OnnxType.TENSOR_UINT8;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+        int ordinal();\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,0 +471,1 @@\n+        public abstract int id();\n@@ -483,0 +484,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 10;\n+        }\n@@ -496,0 +502,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 1;\n+        }\n@@ -509,0 +520,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 11;\n+        }\n@@ -521,0 +537,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 16;\n+        }\n@@ -533,0 +554,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 17;\n+        }\n@@ -545,0 +571,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 19;\n+        }\n@@ -557,0 +588,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 18;\n+        }\n@@ -569,0 +605,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 20;\n+        }\n@@ -581,0 +622,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 23;\n+        }\n@@ -593,0 +639,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 22;\n+        }\n@@ -605,0 +656,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 3;\n+        }\n@@ -617,0 +673,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 5;\n+        }\n@@ -629,0 +690,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 6;\n+        }\n@@ -641,0 +707,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 7;\n+        }\n@@ -653,0 +724,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 21;\n+        }\n@@ -665,0 +741,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 2;\n+        }\n@@ -677,0 +758,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 4;\n+        }\n@@ -689,0 +775,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 12;\n+        }\n@@ -701,0 +792,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 13;\n+        }\n@@ -713,0 +809,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 14;\n+        }\n@@ -725,0 +826,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 15;\n+        }\n@@ -737,0 +843,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 9;\n+        }\n@@ -749,0 +860,5 @@\n+\n+        @Override\n+        public int id() {\n+            return 8;\n+        }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.*;\n@@ -39,1 +40,0 @@\n-import java.io.StringWriter;\n@@ -45,3 +45,1 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectOutputStream;\n+import java.lang.foreign.MemorySegment;\n@@ -50,0 +48,2 @@\n+import java.nio.FloatBuffer;\n+import java.nio.channels.FileChannel;\n@@ -59,0 +59,1 @@\n+import static oracle.code.onnx.OnnxOperators.Cast;\n@@ -103,1 +104,4 @@\n-            Tensor<Float> inputImage) {\n+            Tensor<Byte> ubyteImage) {\n+\n+        Tensor<Float> inputImage = Cast(ubyteImage, empty(), Tensor.ElementType.FLOAT.id);\n+\n@@ -182,1 +186,1 @@\n-                OnnxType.TENSOR_FLOAT32 \/\/ input\n+                OnnxType.TENSOR_UINT8 \/\/ input\n@@ -197,1 +201,6 @@\n-            Block.Parameter inputImage = b.parameters().get(10);\n+            Block.Parameter ubyteImage = b.parameters().get(10);\n+\n+            var inputImage = b.op(OnnxOps.Cast(OnnxType.TENSOR_FLOAT32,\n+                    ubyteImage,\n+                    empty(),\n+                    OnnxType.TENSOR_FLOAT32.eType().id()));\n@@ -325,0 +334,51 @@\n+    static List<Tensor> loadWeights() throws IOException {\n+        try (var is = CNNTest.class.getResourceAsStream(\"lenet-torchscript.onnx\")) {\n+            return OnnxMl.ModelProto.parseFrom(is).getGraph().getInitializerList().stream()\n+                    .map(init ->  {\n+                        var bb = ByteBuffer.allocateDirect(init.getRawData().size());\n+                        init.getRawData().copyTo(bb);\n+                        return new Tensor(OnnxRuntime.getInstance().createTensor(\n+                                MemorySegment.ofBuffer(bb.rewind()),\n+                                Tensor.ElementType.fromOnnxId(init.getDataType()),\n+                                init.getDimsList().stream().mapToLong(a -> a).toArray()));\n+                    })\n+                    .toList();\n+        }\n+    }\n+\n+    static int nextBestMatch(FloatBuffer fb) {\n+        float maxW = fb.get();\n+        int maxI = 0;\n+        for (int i = 1; i < 10; i++) {\n+            float w = fb.get();\n+            if (w > maxW) {\n+                maxW = w;\n+                maxI = i;\n+            }\n+        }\n+        return maxI;\n+    }\n+\n+    private static final String GREY_SCALE = \" .'`^\\\",:;Il!i><~+_-?][}{1)(|\\\\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$\";\n+\n+    static void printImage(int imageIndex, ByteBuffer bb) {\n+        System.out.println(\"Image #\" + imageIndex + \" :\");\n+        int offset = imageIndex * 28 * 28;\n+        for (int y = 0; y < 28; y++) {\n+            for (int x = 0; x < 28; x++) {\n+                System.out.print(GREY_SCALE.charAt(GREY_SCALE.length() * (0xff & bb.get(offset + y * 28 + x)) \/ 256));\n+            }\n+            System.out.println();\n+        }\n+    }\n+\n+\/\/    static final String IMAGES_PATH = \"t10k-images-idx3-ubyte\";\n+\/\/    static final String LABELS_PATH = \"t10k-labels-idx1-ubyte\";\n+\/\/    static final int IMAGES_HEADER_SIZE = 16;\n+\/\/    static final int LABELS_HEADER_SIZE = 8;\n+\n+    static final String IMAGES_PATH = CNNTest.class.getResource(\"images-ubyte\").getPath();\n+    static final String LABELS_PATH = CNNTest.class.getResource(\"labels-ubyte\").getPath();\n+    static final int IMAGES_HEADER_SIZE = 0;\n+    static final int LABELS_HEADER_SIZE = 0;\n+\n@@ -326,1 +386,1 @@\n-    public void test() {\n+    public void test() throws Exception {\n@@ -330,1 +390,0 @@\n-\n@@ -335,0 +394,33 @@\n+\n+        try (RandomAccessFile imagesF = new RandomAccessFile(IMAGES_PATH, \"r\");\n+             RandomAccessFile labelsF = new RandomAccessFile(LABELS_PATH, \"r\")) {\n+\n+            ByteBuffer imagesIn = imagesF.getChannel().map(FileChannel.MapMode.READ_ONLY, IMAGES_HEADER_SIZE, imagesF.length() - IMAGES_HEADER_SIZE);\n+            ByteBuffer labelsIn = labelsF.getChannel().map(FileChannel.MapMode.READ_ONLY, LABELS_HEADER_SIZE, labelsF.length() - LABELS_HEADER_SIZE);\n+\n+            List<Tensor> weights = loadWeights();\n+            Tensor inputImage = new Tensor(MemorySegment.ofBuffer(imagesIn), Tensor.ElementType.UINT8);\n+\n+            FloatBuffer result = new Tensor(OnnxRuntime.getInstance().runFunc(\n+                    onnxModel,\n+                    Stream.concat(weights.stream(), Stream.of(inputImage))\n+                            .map(t -> Optional.of(t.tensorAddr)).toList()).getFirst())\n+                    .asByteBuffer().asFloatBuffer();\n+\n+            int matched = 0, mismatched = 0;\n+            while (result.remaining() > 0) {\n+                int expected = labelsIn.get();\n+                int actual = nextBestMatch(result);\n+                if (expected == actual) {\n+                    matched++;\n+                } else {\n+                    int imageIndex = labelsIn.position() - 1;\n+                    printImage(imageIndex, imagesIn);\n+                    System.out.println(\"expected: \" + expected + \" actual: \" + actual);\n+                    System.out.println(\"-\".repeat(28));\n+                    mismatched++;\n+                }\n+            }\n+            System.out.println(\"matched: \" + matched + \" mismatched: \" + mismatched);\n+            Assertions.assertTrue(mismatched \/ matched < 0.05);\n+        }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":101,"deletions":9,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-import java.nio.FloatBuffer;\n-import java.nio.LongBuffer;\n@@ -6,0 +4,2 @@\n+import java.util.Optional;\n+import oracle.code.onnx.Tensor.ElementType;\n@@ -15,0 +15,2 @@\n+    static final Optional<ElementType> OF_FLOAT = Optional.of(FLOAT);\n+\n@@ -18,2 +20,2 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(FLOAT, FLOAT)));\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(FLOAT, FLOAT)))) {\n+        try (var absOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Abs.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()));\n+             var addOp = ort.createSession(OnnxProtoBuilder.buildOpModel(OnnxOps.Add.SCHEMA, List.of(OF_FLOAT, OF_FLOAT), List.of()))) {\n@@ -31,1 +33,1 @@\n-            var absResult = absOp.run(List.of(inputTensor));\n+            var absResult = absOp.run(List.of(Optional.of(inputTensor)));\n@@ -35,1 +37,1 @@\n-            var absOutputTensor = (OnnxRuntime.OrtTensor)absResult.getFirst();\n+            var absOutputTensor = absResult.getFirst();\n@@ -37,1 +39,1 @@\n-            assertTensorEquals(absExpectedTensor, absOutputTensor);\n+            SimpleTest.assertEquals(absExpectedTensor, absOutputTensor);\n@@ -39,1 +41,1 @@\n-            var addResult = addOp.run(List.of(inputTensor, absOutputTensor));\n+            var addResult = addOp.run(List.of(Optional.of(inputTensor), Optional.of(absOutputTensor)));\n@@ -43,1 +45,1 @@\n-            var addOutputTensor = (OnnxRuntime.OrtTensor)addResult.getFirst();\n+            var addOutputTensor = addResult.getFirst();\n@@ -47,33 +49,1 @@\n-            assertTensorEquals(addExpectedTensor, addOutputTensor);\n-        }\n-    }\n-\n-    static void assertTensorEquals(OnnxRuntime.OrtTensor expectedTensor, OnnxRuntime.OrtTensor actualTensor) {\n-        var expectedType = expectedTensor.getTensorTypeAndShape();\n-        var expectedShape = expectedType.getShape();\n-\n-        var actualType = actualTensor.getTensorTypeAndShape();\n-        var actualShape = actualType.getShape();\n-\n-        assertEquals(expectedShape.getDimensionsCount(), actualShape.getDimensionsCount());\n-        for (int i = 0; i < expectedShape.getDimensionsCount(); i++) {\n-            assertEquals(expectedShape.getDimension(i), actualShape.getDimension(i));\n-        }\n-\n-        assertEquals(expectedType.getTensorElementType(), actualType.getTensorElementType());\n-        assertEquals(expectedType.getTensorShapeElementCount(), actualType.getTensorShapeElementCount());\n-\n-        assertEqualData(expectedTensor.asByteBuffer().asFloatBuffer(), actualTensor.asByteBuffer().asFloatBuffer());\n-    }\n-\n-    static void assertEqualData(FloatBuffer expectedData, FloatBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n-        }\n-    }\n-\n-    static void assertEqualData(LongBuffer expectedData, LongBuffer actualData) {\n-        assertEquals(expectedData.capacity(), actualData.capacity());\n-        for (int i = 0; i < expectedData.capacity(); i++) {\n-            assertEquals(expectedData.get(i), actualData.get(i));\n+            SimpleTest.assertEquals(addExpectedTensor, addOutputTensor);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":12,"deletions":42,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -4,1 +5,3 @@\n-import java.util.List;\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n@@ -6,0 +9,1 @@\n+import java.util.stream.Stream;\n@@ -10,0 +14,1 @@\n+import org.junit.jupiter.api.Assertions;\n@@ -12,2 +17,0 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-\n@@ -16,2 +19,0 @@\n-    \/\/ Java code model -> ONNX code model -> ONNX runtime instance -> execute via ORT\n-    \/\/ Run directly, each operation reflectively executes via ORT\n@@ -29,2 +30,53 @@\n-                new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"add\", Tensor.class, Tensor.class),\n-                        List.of(a.rtTensor, b.rtTensor)).getFirst()));\n+                runModel(\"add\", a, b));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstant() {\n+        return OnnxOperators.Constant(-1f);\n+    }\n+\n+    @Test\n+    public void testFconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1f);\n+        assertEquals(expected, fconstant());\n+        assertEquals(expected, runModel(\"fconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Float> fconstants() {\n+        return OnnxOperators.Constant(new float[]{-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testFconstants() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1f, 0, 1, Float.MIN_VALUE, Float.MAX_VALUE);\n+        assertEquals(expected, fconstants());\n+        assertEquals(expected, runModel(\"fconstants\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstant() {\n+        return OnnxOperators.Constant(-1l);\n+    }\n+\n+    @Test\n+    public void testLconstant() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1l);\n+        assertEquals(expected, lconstant());\n+        assertEquals(expected, runModel(\"lconstant\"));\n+    }\n+\n+    @CodeReflection\n+    public static Tensor<Long> lconstants() {\n+        return OnnxOperators.Constant(new long[]{-1, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE});\n+    }\n+\n+    @Test\n+    public void testLconstants() throws Exception {\n+        \/\/ tests the numbers are encoded correctly\n+        var expected = new Tensor(-1l, 0, 1, Long.MIN_VALUE, Long.MAX_VALUE);\n+        assertEquals(expected, lconstants());\n+        assertEquals(expected, runModel(\"lconstants\"));\n@@ -42,3 +94,9 @@\n-        assertEquals(shape, reshapeAndShape(data, shape));\n-        assertEquals(shape, new Tensor(OnnxRuntime.getInstance().runFunc(getOnnxModel(\"reshapeAndShape\", Tensor.class, Tensor.class),\n-                        List.of(data.rtTensor, shape.rtTensor)).getFirst()));\n+        assertEquals(\n+                reshapeAndShape(data, shape),\n+                runModel(\"reshapeAndShape\", data, shape));\n+    }\n+\n+    private static Tensor runModel(String name, Tensor... params) throws NoSuchMethodException {\n+        return new Tensor(OnnxRuntime.getInstance().runFunc(\n+                getOnnxModel(name),\n+                Stream.of(params).map(t -> Optional.ofNullable(t.tensorAddr)).toList()).getFirst());\n@@ -47,1 +105,1 @@\n-    private static CoreOp.FuncOp getOnnxModel(String name, Class... params) throws NoSuchMethodException {\n+    private static CoreOp.FuncOp getOnnxModel(String name) throws NoSuchMethodException {\n@@ -49,1 +107,1 @@\n-                Op.ofMethod(SimpleTest.class.getDeclaredMethod(name, params)).get());\n+                Op.ofMethod(Stream.of(SimpleTest.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get()).get());\n@@ -52,4 +110,15 @@\n-    static void assertEquals(Tensor actual, Tensor expected) {\n-        var expectedTS = expected.rtTensor.getTensorTypeAndShape();\n-        var actualTS = actual.rtTensor.getTensorTypeAndShape();\n-        assertSame(expectedTS.getTensorElementType(), actualTS.getTensorElementType());\n+    static void assertEquals(Tensor expected, Tensor actual) {\n+        assertEquals(expected.tensorAddr, actual.tensorAddr);\n+    }\n+\n+    static void assertEquals(MemorySegment expectedTensorAddr, MemorySegment actualTensorAddr) {\n+\n+        var rt = OnnxRuntime.getInstance();\n+\n+        var expectedType = rt.tensorElementType(expectedTensorAddr);\n+        var expectedShape = rt.tensorShape(expectedTensorAddr);\n+        var expectedBB = rt.tensorBuffer(expectedTensorAddr);\n+\n+        var actualType = rt.tensorElementType(actualTensorAddr);\n+        var actualShape = rt.tensorShape(actualTensorAddr);\n+        var actualBB = rt.tensorBuffer(actualTensorAddr);\n@@ -57,1 +126,1 @@\n-        \/\/ @@@ assert equal shapes\n+        Assertions.assertSame(expectedType, actualType);\n@@ -59,1 +128,5 @@\n-        switch (actualTS.getTensorElementType()) {\n+        Assertions.assertArrayEquals(expectedShape, actualShape);\n+\n+        switch (actualType) {\n+            case UINT8, INT8, UINT16, INT16, INT32, INT64, STRING, BOOL, UINT32, UINT64, UINT4, INT4 ->\n+                assertEquals(expectedBB, actualBB);\n@@ -61,3 +134,3 @@\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asFloatBuffer(), actual.rtTensor.asByteBuffer().asFloatBuffer());\n-            case INT64 ->\n-                RuntimeTest.assertEqualData(expected.rtTensor.asByteBuffer().asLongBuffer(), actual.rtTensor.asByteBuffer().asLongBuffer());\n+                assertEquals(expectedBB.asFloatBuffer(), actualBB.asFloatBuffer());\n+            case DOUBLE ->\n+                assertEquals(expectedBB.asDoubleBuffer(), actualBB.asDoubleBuffer());\n@@ -65,1 +138,22 @@\n-                throw new UnsupportedOperationException(); \/\/ @@@ ToDo\n+                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType);\n+        }\n+    }\n+\n+    static void assertEquals(ByteBuffer expectedData, ByteBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i));\n+        }\n+    }\n+\n+    static void assertEquals(FloatBuffer expectedData, FloatBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n+        }\n+    }\n+\n+    static void assertEquals(DoubleBuffer expectedData, DoubleBuffer actualData) {\n+        Assertions.assertEquals(expectedData.capacity(), actualData.capacity());\n+        for (int i = 0; i < expectedData.capacity(); i++) {\n+            Assertions.assertEquals(expectedData.get(i), actualData.get(i), 1e-6f);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":116,"deletions":22,"binary":false,"changes":138,"status":"modified"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/images-ubyte","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/labels-ubyte","binary":true,"status":"added"}]}