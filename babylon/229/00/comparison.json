{"files":[{"patch":"@@ -48,0 +48,10 @@\n+        <dependency>\n+            <groupId>beehive-lab<\/groupId>\n+            <version>0.0.4<\/version>\n+            <artifactId>beehive-spirv-lib<\/artifactId>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>oneapi<\/groupId>\n+            <version>0.0.1<\/version>\n+            <artifactId>levelzero<\/artifactId>\n+        <\/dependency>\n@@ -93,2 +103,2 @@\n-                                <source>${babylon.dir}\/cr-examples\/spirv\/src\/main\/java\/<\/source>\n-                                <source>${beehive.spirv.toolkit.dir}\/lib\/src\/main\/java\/<\/source>\n+                                <!-- <source>${babylon.dir}\/cr-examples\/spirv\/src\/main\/java\/<\/source> -->\n+                                <!-- <source>${beehive.spirv.toolkit.dir}\/lib\/src\/main\/java\/<\/source> -->\n","filename":"hat\/backends\/spirv\/pom.xml","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+git clone https:\/\/github.com\/beehive-lab\/beehive-spirv-toolkit.git\n+cd beehive-spirv-toolkit\n+mvn clean install\n+cd ..\n+cp beehive-spirv-toolkit\/lib\/target\/beehive-spirv-lib-0.0.4.jar ..\/..\/..\/maven-build\/\n","filename":"hat\/backends\/spirv\/scripts\/build-beehive-spirv-toolkit.sh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+git clone https:\/\/github.com\/oneapi-src\/level-zero.git\n+cd level-zero\n+mkdir build\n+cd build\n+cmake .. -D CMAKE_BUILD_TYPE=Release\n+cmake --build . --target package\n+cmake --build . --target install\n","filename":"hat\/backends\/spirv\/scripts\/build-level-zero.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+#!\/bin\/bash\n+\n+$JEXTRACT_DIR\/bin\/jextract --output src\/gen\/java -I \/usr\/include -t oneapi.levelzero level-zero\/include\/ze_api.h\n+$JAVA_HOME\/bin\/javac -cp target\/classes -d target\/classes src\/gen\/java\/oneapi\/levelzero\/*.java\n+$JAVA_HOME\/bin\/jar cf levelzero.jar -C target\/classes\/ .\n+mvn install:install-file -Dfile=levelzero.jar -DgroupId=oneapi -DartifactId=levelzero -Dversion=0.0.1 -Dpackaging=jar\n+cp levelzero.jar ..\/..\/..\/maven-build\/\n","filename":"hat\/backends\/spirv\/scripts\/generate-level-zero-binding.sh","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-\n@@ -29,0 +28,1 @@\n+import hat.KernelContext;\n@@ -30,0 +30,4 @@\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.BoundSchema;\n+import hat.ifacemapper.SegmentMapper;\n+import hat.callgraph.KernelEntrypoint;\n@@ -31,3 +35,4 @@\n-import intel.code.spirv.SpirvModuleGenerator;\n-import intel.code.spirv.SpirvOps;\n-import intel.code.spirv.TranslateToSpirvModel;\n+import java.lang.foreign.Arena;\n+import intel.code.spirv.LevelZero;\n+\n+public class SpirvBackend extends JavaBackend {\n@@ -35,1 +40,1 @@\n-import java.lang.foreign.MemorySegment;\n+    private final LevelZero levelZero;\n@@ -37,1 +42,0 @@\n-public class SpirvBackend extends NativeBackend {\n@@ -39,2 +43,1 @@\n-        super(\"spirv_backend\");\n-        getBackend(null);\n+        levelZero = LevelZero.create(arena);\n@@ -43,0 +46,3 @@\n+    public void info() {\n+        System.out.println(\"hat.backend.SpirvBackend v.0.1.0\");\n+    }\n@@ -45,25 +51,3 @@\n-    public void computeContextHandoff(ComputeContext computeContext) {\n-        System.out.println(\"Spirv backend recieved closed closure\");\n-        System.out.println(\"Spirv backend will mutate  \" + computeContext.computeCallGraph.entrypoint + computeContext.computeCallGraph.entrypoint.method);\n-        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n-        boolean doSpirv = false;\n-        if (doSpirv) {\n-            TranslateToSpirvModel translateToSpirvModel = new TranslateToSpirvModel();\n-            computeContext.computeCallGraph.kernelCallGraphStream().forEach(kernelCallGraph -> {\n-                kernelCallGraph.kernelReachableResolvedStream().forEach(kr -> {\n-                    String methodName = kr.method.getName();\n-\n-                    SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(kr.funcOpWrapper().op());\n-                    MemorySegment spirvBinary = SpirvModuleGenerator.generateModule(methodName, spirvFunc);\n-\n-                    System.out.println(\"\\n------- Java Model -------\");\n-                    System.out.println(kr.funcOpWrapper().op().toText());\n-                    System.out.println(\"------- SPIR-V Model -------\");\n-                    System.out.println(spirvFunc.toText());\n-                    System.out.println(\"------- SPIR-V Module -------\");\n-                    System.out.println(SpirvModuleGenerator.disassembleModule(spirvBinary));\n-                });\n-\n-            });\n-\n-        }\n+    public <T extends Buffer> T allocate(SegmentMapper<T> segmentMapper, BoundSchema<T> boundSchema){\n+        return segmentMapper.allocate(levelZero.arena(), boundSchema);\n+    }\n@@ -71,3 +55,2 @@\n-        \/\/  var codeBuilder = new SpirvCodeReflectionBuilder();\n-        \/\/  Code code = createCode(computeContext, codeBuilder);\n-        \/\/ System.out.println(codeBuilder);\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n@@ -78,1 +61,1 @@\n-        System.out.println(\"implement spirv dispatch kernel\");\n+        levelZero.dispatchKernel(kernelCallGraph, ndRange, args);\n","filename":"hat\/backends\/spirv\/src\/main\/java\/hat\/backend\/SpirvBackend.java","additions":20,"deletions":37,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import intel.code.spirv.SpirvOps;\n+import intel.code.spirv.SpirvOp;\n@@ -60,1 +60,1 @@\n-            SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(javaFunc);\n+            SpirvOp.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(javaFunc);\n","filename":"hat\/backends\/spirv\/src\/main\/java\/hat\/backend\/TestIt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,456 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import oneapi.levelzero.ze_api_h;\n+import static oneapi.levelzero.ze_api_h.*;\n+import oneapi.levelzero.ze_context_desc_t;\n+import oneapi.levelzero.ze_kernel_desc_t;\n+import oneapi.levelzero.ze_command_queue_desc_t;\n+import oneapi.levelzero.ze_command_list_desc_t;\n+import oneapi.levelzero.ze_command_queue_group_properties_t;\n+import oneapi.levelzero.ze_event_pool_desc_t;\n+import oneapi.levelzero.ze_event_desc_t;\n+import oneapi.levelzero.ze_fence_desc_t;\n+import oneapi.levelzero.ze_module_desc_t;\n+import oneapi.levelzero.ze_group_count_t;\n+import oneapi.levelzero.ze_host_mem_alloc_desc_t;\n+import oneapi.levelzero.ze_device_mem_alloc_desc_t;\n+import oneapi.levelzero.ze_device_properties_t;\n+import oneapi.levelzero.ze_driver_properties_t;\n+import oneapi.levelzero.ze_driver_extension_properties_t;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Value;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.NDRange;\n+import hat.buffer.Buffer;\n+import hat.callgraph.KernelEntrypoint;\n+import hat.callgraph.KernelCallGraph;\n+import intel.code.spirv.SpirvModuleGenerator;\n+import intel.code.spirv.SpirvOp;\n+import intel.code.spirv.TranslateToSpirvModel;\n+import intel.code.spirv.UsmArena;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.AddressLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class LevelZero {\n+    static {\n+        System.loadLibrary(\"ze_loader\");\n+    }\n+\n+    public static final AddressLayout driver_handle_t = AddressLayout.ADDRESS;\n+    public static final AddressLayout context_handle_t = AddressLayout.ADDRESS;\n+    public static final AddressLayout device_handle_t = AddressLayout.ADDRESS;\n+    public static final AddressLayout command_queue_handle_t = AddressLayout.ADDRESS;\n+\n+    private final Arena lzArena;\n+    private final Arena backendArena;\n+    private final MemorySegment driverHandle;\n+    private final MemorySegment contextHandle;\n+    private final MemorySegment deviceHandle;\n+    private final MemorySegment queueHandle;\n+    private final MemorySegment eventPoolDescription;\n+\n+    public static LevelZero create(Arena javaArena) {\n+        return new LevelZero(javaArena);\n+    }\n+\n+    LevelZero(Arena javaArena) {\n+        lzArena = javaArena;\n+        \/\/ get driver\n+        check(zeInit(ZE_INIT_FLAG_GPU_ONLY()));\n+        int[] numDrivers = new int[1];\n+        MemorySegment pNumDrivers = lzArena.allocate(JAVA_INT);\n+        check(zeDriverGet(pNumDrivers, MemorySegment.NULL));\n+        MemorySegment driverCount = lzArena.allocate(Integer.BYTES);\n+        check(zeDriverGet(driverCount, MemorySegment.NULL));\n+        debug(\"driverCount = %d\", driverCount.get(JAVA_INT, 0));\n+        MemorySegment driverHandles = lzArena.allocate(driverCount.get(JAVA_INT, 0) * driver_handle_t.byteSize(), 8);\n+        check(zeDriverGet(driverCount, driverHandles));\n+        driverHandle = driverHandles.get(ADDRESS, 0);\n+\n+        \/\/ create context\n+        MemorySegment pContextDesc = lzArena.allocate(ze_context_desc_t.layout());\n+        ze_context_desc_t.stype(pContextDesc, ZE_STRUCTURE_TYPE_CONTEXT_DESC());\n+        MemorySegment pContextHandle = lzArena.allocate(context_handle_t);\n+        check(zeContextCreate(driverHandle, pContextDesc, pContextHandle));\n+        contextHandle = pContextHandle.get(ADDRESS, 0);\n+\n+        \/\/ get device\n+        MemorySegment pDeviceCount = lzArena.allocate(Integer.BYTES);\n+        check(zeDeviceGet(driverHandle, pDeviceCount, MemorySegment.NULL));\n+        int deviceCount = pDeviceCount.get(JAVA_INT, 0);\n+        assert deviceCount > 0;\n+        debug(\"deviceCount = %d\", deviceCount);\n+        MemorySegment deviceHandles = lzArena.allocate(deviceCount * device_handle_t.byteSize(), 8);\n+        check(zeDeviceGet(driverHandle, pDeviceCount, deviceHandles));\n+        for (int i = 0; i < deviceCount; i++) {\n+            debug(\"device #%d: %s\", i, deviceHandles.get(device_handle_t, i * device_handle_t.byteSize()));\n+        }\n+        assert deviceCount == 1;\n+        deviceHandle = deviceHandles.get(ADDRESS, 0);\n+        MemorySegment pDeviceProperties = lzArena.allocate(ze_device_properties_t.layout());\n+        ze_device_properties_t.stype(pDeviceProperties, ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES());\n+        check(zeDeviceGetProperties(deviceHandle, pDeviceProperties));\n+        debug(\"deviceProperties:\\n\\ttype = %d\\n\\tvendorId = %d\\n\\tmaxMemAllocSize = %d\",\n+            ze_device_properties_t.type(pDeviceProperties),\n+            ze_device_properties_t.vendorId(pDeviceProperties),\n+            ze_device_properties_t.maxMemAllocSize(pDeviceProperties));\n+\n+        \/\/ create queue\n+        MemorySegment pNumQueueGroups = lzArena.allocate(JAVA_INT, 1);\n+        check(zeDeviceGetCommandQueueGroupProperties(deviceHandle, pNumQueueGroups, MemorySegment.NULL));\n+        assert pNumQueueGroups.get(JAVA_INT, 0) == 1;\n+        MemorySegment pGroupProperties = lzArena.allocate(ze_command_queue_group_properties_t.layout(),\n+                                                          pNumQueueGroups.get(JAVA_INT, 0));\n+        check(zeDeviceGetCommandQueueGroupProperties(deviceHandle, pNumQueueGroups, pGroupProperties));\n+\n+        MemorySegment pQueueDesc = lzArena.allocate(ze_command_queue_desc_t.layout());\n+        ze_command_queue_desc_t.stype(pQueueDesc, ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC());\n+        ze_command_queue_desc_t.index(pQueueDesc, 0);\n+        ze_command_queue_desc_t.mode(pQueueDesc, ZE_COMMAND_QUEUE_MODE_SYNCHRONOUS());\n+        ze_command_queue_desc_t.ordinal(pQueueDesc, 0);\n+        MemorySegment pQueueHandle = lzArena.allocate(command_queue_handle_t);\n+        check(zeCommandQueueCreate(contextHandle, deviceHandle, pQueueDesc, pQueueHandle));\n+        queueHandle = pQueueHandle.get(ADDRESS, 0);\n+\n+        \/\/ create event pool (may not use events if use in-order queue)\n+        eventPoolDescription = lzArena.allocate(ze_event_pool_desc_t.layout().byteSize());\n+        ze_event_pool_desc_t.stype(eventPoolDescription, ZE_STRUCTURE_TYPE_EVENT_POOL_DESC());\n+        ze_event_pool_desc_t.count(eventPoolDescription, 20);\n+        ze_event_pool_desc_t.flags(eventPoolDescription, ZE_EVENT_POOL_FLAG_HOST_VISIBLE());\n+\n+        backendArena = new UsmArena(contextHandle, deviceHandle);\n+    }\n+\n+    public Arena arena() {\n+        return backendArena;\n+    }\n+\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+        KernelEntrypoint kernelEntrypoint = kernelCallGraph.entrypoint;\n+        CoreOp.FuncOp funcOp = kernelEntrypoint.funcOpWrapper().op();\n+        String kernelName = funcOp.funcName();\n+        \/\/ System.out.println(funcOp.toText());\n+        MemorySegment spirvBinary = SpirvModuleGenerator.generateModule(kernelName, kernelCallGraph);\n+        String path = \"\/tmp\/\" + kernelName + \".spv\";\n+        SpirvModuleGenerator.writeModuleToFile(spirvBinary, path);\n+        \/\/ System.out.println(\"generated module \\n\" + SpirvModuleGenerator.disassembleModule(spirvBinary));\n+        args[0] = ndRange.kid;\n+        List<Arg> kernelArgs = collectArgs(funcOp, args);\n+        int[] globalSizes = new int[] {ndRange.kid.maxX, 1, 1};\n+        int[] localSizes = new int[] {512, 1, 1};\n+        KernelGeometry geometry = new KernelGeometry(globalSizes, localSizes);\n+        MemorySegment commandListHandle = createCommandList(spirvBinary, kernelName, geometry, kernelArgs);\n+        executeCommandList(commandListHandle);\n+        check(zeCommandQueueSynchronize(queueHandle, -1L));\n+        for (int i = 1; i < kernelArgs.size(); i++) {\n+            copyArgToHost(kernelArgs.get(i), contextHandle);\n+        }\n+    }\n+\n+    private static void check(int result) {\n+        if (result != ZE_RESULT_SUCCESS()) {\n+            throw new RuntimeException(String.format(\"Call failed: 0x%x (%d)\", result, result));\n+        }\n+    }\n+\n+    public static void debug(String message, Object... args) {\n+        System.out.println(String.format(message, args));\n+    }\n+\n+    private List<Arg> collectArgs(CoreOp.FuncOp kernelMethod, Object[] values) {\n+        List<Arg> args = new ArrayList<>();\n+        List<Block.Parameter> params = kernelMethod.body().entryBlock().parameters();\n+        for (int i = 0; i < params.size(); i++) {\n+            args.add(Arg.createArg(this, \"arg\" + i, params.get(i), values[i]));\n+        }\n+        return args;\n+    }\n+\n+    void provisionArg(Arg arg) {\n+        MemorySegment deviceMemAllocDesc = lzArena.allocate(ze_device_mem_alloc_desc_t.layout());\n+        ze_device_mem_alloc_desc_t.stype(deviceMemAllocDesc, ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC());\n+        ze_device_mem_alloc_desc_t.ordinal(deviceMemAllocDesc, 0);\n+        MemorySegment hostMemAllocDesc = lzArena.allocate(ze_host_mem_alloc_desc_t.layout());\n+        ze_host_mem_alloc_desc_t.stype(hostMemAllocDesc, ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC());\n+        if (arg.value() instanceof Buffer buff) {\n+            arg.setNeedsCleanup(false);\n+            arg.setDataSegment(Buffer.getMemorySegment(buff));\n+            arg.setSize(8);\n+        }\n+        else if (arg.cls() == Short.class) {\n+            arg.setSize(2);\n+        }\n+        else if (arg.cls() == Integer.class || arg.cls() == Float.class || arg.cls() == Boolean.class) {\n+            arg.setSize(4);\n+        }\n+        else if (arg.cls() == Long.class) {\n+            arg.setSize(8);\n+        }\n+        else if (arg.cls() == KernelContext.class) {\n+            KernelContext kc = (KernelContext)arg.value();\n+            MemorySegment segment = lzArena.allocate(8, 8);\n+            segment.set(JAVA_INT, 0, kc.maxX);\n+            segment.set(JAVA_INT, 4, kc.x);\n+            arg.setDataSegment(segment);\n+            arg.setSize(8);\n+        }\n+        else if (arg.cls() == NDRange.class) {\n+            NDRange kc = (NDRange)arg.value();\n+            MemorySegment segment = lzArena.allocate(8, 8);\n+            arg.setDataSegment(segment);\n+            arg.setSize(8);\n+        }\n+        else throw new RuntimeException(\"unsupported type: \" + arg.cls());\n+    }\n+\n+    void copyArgToHost(Arg arg, MemorySegment contextHandle) {\n+        \/\/ currently using shared memory\n+    }\n+\n+    private MemorySegment createCommandList(MemorySegment spirvModule, String kernelName, KernelGeometry geometry, List<Arg> args) {\n+        Arena arena = Arena.ofShared();\n+        MemorySegment pCommandListHandle = lzArena.allocate(ze_command_list_handle_t);\n+        MemorySegment commandListDesc = lzArena.allocate(ze_command_list_desc_t.layout());\n+        ze_command_list_desc_t.stype(eventPoolDescription, ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC());\n+        ze_command_list_desc_t.commandQueueGroupOrdinal(commandListDesc, 0);\n+        check(zeCommandListCreate(contextHandle, deviceHandle, commandListDesc, pCommandListHandle));\n+        MemorySegment commandListHandle = pCommandListHandle.get(ADDRESS, 0);\n+        MemorySegment moduleHandle = createModule(kernelName);\n+        MemorySegment kernelHandle = createKernel(moduleHandle, kernelName, geometry);\n+        for (int i = 0; i < args.size(); i++) {\n+            Arg arg = args.get(i);\n+            setKernelArg(arg, i, commandListHandle, kernelHandle);\n+        }\n+        MemorySegment groupCount = lzArena.allocate(ze_group_count_t.layout());\n+        ze_group_count_t.groupCountX(groupCount, geometry.globalSizes()[0] \/ geometry.localSizes()[0]);\n+        ze_group_count_t.groupCountY(groupCount, geometry.globalSizes()[1] \/ geometry.localSizes()[1]);\n+        ze_group_count_t.groupCountZ(groupCount, geometry.globalSizes()[2] \/ geometry.localSizes()[2]);\n+        MemorySegment pKernelWaitHandles = MemorySegment.NULL;\n+        check(zeCommandListAppendLaunchKernel(commandListHandle, kernelHandle, groupCount, MemorySegment.NULL, 0, pKernelWaitHandles));\n+        check(zeCommandListClose(commandListHandle));\n+        return commandListHandle;\n+    }\n+\n+    private MemorySegment executeCommandList(MemorySegment commandListHandle) {\n+        MemorySegment fenceDesc = lzArena.allocate(ze_fence_desc_t.layout());\n+        ze_module_desc_t.stype(fenceDesc, ZE_STRUCTURE_TYPE_FENCE_DESC());\n+        ze_fence_desc_t.flags(fenceDesc, ZE_FENCE_FLAG_SIGNALED());\n+        MemorySegment pFenceHandle = lzArena.allocate(ze_fence_handle_t);\n+        check(zeFenceCreate(queueHandle, fenceDesc, pFenceHandle));\n+        MemorySegment fenceHandle = pFenceHandle.get(ADDRESS, 0);\n+        MemorySegment pCommandListHandle = lzArena.allocate(ze_command_list_handle_t);\n+        pCommandListHandle.set(ADDRESS, 0, commandListHandle);\n+        check(zeCommandQueueExecuteCommandLists(queueHandle, 1, pCommandListHandle, fenceHandle));\n+        check(zeCommandQueueSynchronize(queueHandle, -1L));\n+        return fenceHandle;\n+    }\n+\n+    private MemorySegment createKernel(MemorySegment moduleHandle, String kernelNameString, KernelGeometry geometry) {\n+        MemorySegment kernelDesc = lzArena.allocate(ze_kernel_desc_t.layout());\n+        MemorySegment kernelName = lzArena.allocateFrom(kernelNameString);\n+        ze_kernel_desc_t.stype(kernelDesc, ZE_STRUCTURE_TYPE_KERNEL_DESC());\n+        ze_kernel_desc_t.pKernelName(kernelDesc, kernelName);\n+        MemorySegment pKernelHandle = lzArena.allocate(ze_kernel_handle_t);\n+        check(zeKernelCreate(moduleHandle, kernelDesc, pKernelHandle));\n+        int[] globalSizes = geometry.globalSizes();\n+        int[] localSizes = geometry.localSizes();\n+        MemorySegment pGroupSizeX = lzArena.allocate(JAVA_INT, localSizes[0]);\n+        MemorySegment pGroupSizeY = lzArena.allocate(JAVA_INT, localSizes[1]);\n+        MemorySegment pGroupSizeZ = lzArena.allocate(JAVA_INT, localSizes[2]);\n+        MemorySegment kernelHandle = pKernelHandle.get(ADDRESS, 0);\n+        check(zeKernelSuggestGroupSize(kernelHandle, globalSizes[0], globalSizes[1], globalSizes[2], pGroupSizeX, pGroupSizeY, pGroupSizeZ));\n+        geometry.localSizes()[0] = pGroupSizeX.get(JAVA_INT, 0);\n+        geometry.localSizes()[1] = pGroupSizeY.get(JAVA_INT, 0);\n+        geometry.localSizes()[2] = pGroupSizeZ.get(JAVA_INT, 0);\n+        check(zeKernelSetGroupSize(kernelHandle, pGroupSizeX.get(JAVA_INT, 0), pGroupSizeY.get(JAVA_INT, 0), pGroupSizeZ.get(JAVA_INT, 0)));\n+        return kernelHandle;\n+    }\n+\n+    private void setKernelArg(Arg arg, int ordinal, MemorySegment commandListHandle, MemorySegment kernelHandle) {\n+        MemorySegment dataSegment = arg.dataSegment();\n+        Class<?> cls = arg.cls();\n+        if (cls == Short.class) {\n+            MemorySegment pArgValue = lzArena.allocateFrom(JAVA_SHORT, (short)arg.value());\n+            check(zeKernelSetArgumentValue(kernelHandle, ordinal, Short.BYTES, pArgValue));\n+        }\n+        else if (cls == Integer.class || cls == Boolean.class \/*|| VectorSpecies.class.isAssignableFrom(cls)*\/) {\n+            MemorySegment pArgValue = lzArena.allocateFrom(JAVA_INT, (int)arg.value());\n+            check(zeKernelSetArgumentValue(kernelHandle, ordinal, Integer.BYTES, pArgValue));\n+        }\n+        else if (cls == Long.class) {\n+            MemorySegment pArgValue = lzArena.allocateFrom(JAVA_LONG, (long)arg.value());\n+            check(zeKernelSetArgumentValue(kernelHandle, ordinal, Long.BYTES, pArgValue));\n+        }\n+        else if (cls == Float.class) {\n+            MemorySegment pArgValue = lzArena.allocateFrom(JAVA_LONG, Float.floatToIntBits((float)arg.value()));\n+            check(zeKernelSetArgumentValue(kernelHandle, ordinal, Float.BYTES, pArgValue));\n+        }\n+        else if (arg.value() instanceof Buffer) {\n+            MemorySegment pDataSegment = lzArena.allocateFrom(ADDRESS, dataSegment);\n+            check(zeKernelSetArgumentValue(kernelHandle, ordinal, ADDRESS.byteSize(), pDataSegment));\n+        }\n+        else if (arg.value() instanceof KernelContext) {\n+            MemorySegment pDataSegment = lzArena.allocateFrom(ADDRESS, dataSegment);\n+            check(zeKernelSetArgumentValue(kernelHandle, ordinal, ADDRESS.byteSize(), pDataSegment));\n+        }\n+        else throw new RuntimeException(\"unsupported type: \" + cls);\n+    }\n+\n+    private MemorySegment createModule(String moduleName, MemorySegment spirvCode) {\n+        MemorySegment pModuleHandle = lzArena.allocate(ze_module_handle_t);\n+        MemorySegment moduleDesc = lzArena.allocate(ze_module_desc_t.layout());\n+        ze_module_desc_t.stype(moduleDesc, ZE_STRUCTURE_TYPE_MODULE_DESC());\n+        ze_module_desc_t.format(moduleDesc, ZE_MODULE_FORMAT_IL_SPIRV());\n+        ze_module_desc_t.pInputModule(moduleDesc, spirvCode);\n+        ze_module_desc_t.inputSize(moduleDesc, spirvCode.byteSize());\n+        ze_module_desc_t.pBuildFlags(moduleDesc, lzArena.allocateFrom(\"\"));\n+        MemorySegment buildLogHandle = lzArena.allocate(ze_module_build_log_handle_t);\n+        check(zeModuleCreate(contextHandle, deviceHandle, moduleDesc, pModuleHandle, buildLogHandle));\n+        MemorySegment moduleHandle = pModuleHandle.get(ADDRESS, 0);\n+        return moduleHandle;\n+    }\n+\n+    private MemorySegment createModule(String moduleName)\n+    {\n+        try\n+        {\n+            MemorySegment codeBytes = MemorySegment.ofArray(Files.readAllBytes(Paths.get(\"\/tmp\/\" + moduleName + \".spv\")));\n+            MemorySegment spirvCode = lzArena.allocate(codeBytes.byteSize());\n+            MemorySegment.copy(codeBytes, 0, spirvCode, 0, spirvCode.byteSize());\n+            MemorySegment pModuleHandle = lzArena.allocate(ze_module_handle_t);\n+            MemorySegment moduleDesc = lzArena.allocate(ze_module_desc_t.layout());\n+            ze_module_desc_t.stype(moduleDesc, ZE_STRUCTURE_TYPE_MODULE_DESC());\n+            ze_module_desc_t.format(moduleDesc, ZE_MODULE_FORMAT_IL_SPIRV());\n+            ze_module_desc_t.pInputModule(moduleDesc, spirvCode);\n+            ze_module_desc_t.inputSize(moduleDesc, spirvCode.byteSize());\n+            ze_module_desc_t.pBuildFlags(moduleDesc, lzArena.allocateFrom(\"\"));\n+            MemorySegment buildLogHandle = lzArena.allocate(ze_module_build_log_handle_t);\n+            check(zeModuleCreate(contextHandle, deviceHandle, moduleDesc, pModuleHandle, buildLogHandle));\n+            MemorySegment moduleHandle = pModuleHandle.get(ADDRESS, 0);\n+            return moduleHandle;\n+        }\n+        catch (IOException ioe) {throw new RuntimeException(ioe);}\n+    }\n+\n+    private static record KernelGeometry(int[] globalSizes, int[] localSizes) {\n+        public KernelGeometry() {\n+            this(new int[3], new int[] {512, 1, 1});\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"global: %s, local: %s\", Arrays.toString(globalSizes), Arrays.toString(localSizes));\n+        }\n+    }\n+\n+    public static class Arg {\n+        private final String name;\n+        private final Value crValue;\n+        private final Object value;\n+        private final Class<?> cls;\n+        private int size;\n+        private boolean needsCleanup;\n+        private MemorySegment dataSegment;\n+\n+        public static Arg createArg(LevelZero levelZero, String name, Value crValue, Object value) {\n+            Arg arg = new Arg(name, crValue, value);\n+            levelZero.provisionArg(arg);\n+            return arg;\n+        }\n+\n+        private Arg(String name, Value crValue, Object value) {\n+            this.name = name;\n+            this.crValue = crValue;\n+            this.cls = value.getClass();\n+            this.value = value;\n+        }\n+\n+        public String name() {\n+            return name;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        public Object crValue() {\n+            return crValue;\n+        }\n+\n+        public Class<?> cls() {\n+            return cls;\n+        }\n+\n+        public void setSize(int size) {\n+            this.size = size;\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public void setDataSegment(MemorySegment segment) {\n+            dataSegment = segment;\n+        }\n+\n+        public MemorySegment dataSegment() {\n+            return dataSegment;\n+        }\n+\n+        public void setNeedsCleanup(boolean needsCleanup) {\n+            this.needsCleanup = needsCleanup;\n+        }\n+\n+        public boolean needsCleanup() {\n+            return needsCleanup;\n+        }\n+\n+        public int hashCode() {\n+            return crValue.hashCode();\n+        }\n+\n+        public boolean equals(Object other) {\n+            return other instanceof Arg arg && arg.crValue.equals(arg.crValue);\n+        }\n+\n+        public String toString() {\n+            return String.format(\"name = %s, hash = %d, cls = %s\", name, crValue.hashCode(), cls);\n+        }\n+    }\n+}\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/LevelZero.java","additions":456,"deletions":0,"binary":false,"changes":456,"status":"added"},{"patch":"","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","status":"copied"},{"patch":"@@ -0,0 +1,1144 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.math.BigInteger;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.FunctionType;\n+import hat.callgraph.CallGraph;\n+import hat.callgraph.KernelCallGraph;\n+import hat.callgraph.KernelEntrypoint;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVHeader;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVModule;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVFunction;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVBlock;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.operands.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.Disassembler;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPIRVDisassemblerOptions;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPVByteStreamReader;\n+import intel.code.spirv.SpirvOp.PhiOp;\n+\n+public class SpirvModuleGenerator {\n+    private final String moduleName;\n+    private final SPIRVModule module;\n+    private final Symbols symbols;\n+\n+    public static SpirvModuleGenerator create(String moduleName) {\n+        return new SpirvModuleGenerator(moduleName);\n+    }\n+\n+    public static MemorySegment generateModule(String moduleName, KernelCallGraph callGraph) {\n+        SpirvModuleGenerator generator = SpirvModuleGenerator.create(moduleName);\n+        for (CallGraph.MethodCall call : callGraph.calls) {\n+            if (call.targetMethodRef != null) {\n+                try {\n+                    Optional<CoreOp.FuncOp> ofo = call.targetMethodRef.codeModel(MethodHandles.lookup());\n+                    if (ofo.isPresent()) {\n+                        CoreOp.FuncOp fo = ofo.get();\n+                        SpirvOp.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(fo);\n+                    }\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+        KernelEntrypoint kernelEntrypoint = callGraph.entrypoint;\n+        CoreOp.FuncOp funcOp = kernelEntrypoint.funcOpWrapper().op();\n+        String kernelName = funcOp.funcName();\n+        SpirvOp.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(funcOp);\n+        generator.generateFunction(funcOp.funcName(), spirvFunc, true);\n+        return generator.finalizeModule();\n+    }\n+\n+    public static MemorySegment generateModule(String moduleName, CoreOp.FuncOp func) {\n+        SpirvOp.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(func);\n+        MemorySegment moduleSegment = SpirvModuleGenerator.generateModule(moduleName, spirvFunc);\n+        return moduleSegment;\n+    }\n+\n+    public static MemorySegment generateModule(String moduleName, SpirvOp.FuncOp func) {\n+        SpirvModuleGenerator generator = new SpirvModuleGenerator(moduleName);\n+        MemorySegment moduleSegment = generator.generateModuleInternal(func);\n+        return moduleSegment;\n+    }\n+\n+    public static void writeModuleToFile(MemorySegment module, String filepath)  {\n+        ByteBuffer buffer = module.asByteBuffer();\n+        File out = new File(filepath);\n+        try (FileChannel channel = new FileOutputStream(out, false).getChannel()) {\n+            channel.write(buffer);\n+            channel.close();\n+        }\n+        catch (IOException e)  {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void writeModuleToFile(SPIRVModule module, String filepath)\n+    {\n+        ByteBuffer buffer = ByteBuffer.allocate(module.getByteCount());\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        module.close().write(buffer);\n+        buffer.flip();\n+        File out = new File(filepath);\n+        try (FileChannel channel = new FileOutputStream(out, false).getChannel())\n+        {\n+            channel.write(buffer);\n+        }\n+        catch (IOException e)\n+        {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static String disassembleModule(MemorySegment module) {\n+        SPVByteStreamReader input = new SPVByteStreamReader(new ByteArrayInputStream(module.toArray(ValueLayout.JAVA_BYTE)));\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (PrintStream ps = new PrintStream(out))  {\n+            SPIRVDisassemblerOptions options = new SPIRVDisassemblerOptions(false, false, false, false, true);\n+            Disassembler dis = new Disassembler(input, ps, options);\n+            dis.run();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return new String(out.toByteArray());\n+    }\n+\n+    public MemorySegment finalizeModule() {\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(module.getByteCount());\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        module.close().write(buffer);\n+        buffer.flip();\n+        return MemorySegment.ofBuffer(buffer);\n+    }\n+\n+    private record SpirvResult(SPIRVId type, SPIRVId address, SPIRVId value) {}\n+\n+    private SpirvModuleGenerator(String moduleName) {\n+        this.moduleName = moduleName;\n+        this.module = new SPIRVModule(new SPIRVHeader(1, 2, 32, 0, 0));\n+        this.symbols = new Symbols();\n+        initModule();\n+    }\n+\n+    private MemorySegment generateModuleInternal(SpirvOp.FuncOp func) {\n+        generateFunction(moduleName, func, true);\n+        return finalizeModule();\n+    }\n+\n+    private SPIRVId generateFunction(String fnName, SpirvOp.FuncOp func, boolean isEntryPoint) {\n+        TypeElement returnType = func.invokableType().returnType();\n+        SPIRVId functionId = nextId(fnName);\n+        String signature = func.invokableType().returnType().toString();\n+        List<TypeElement> paramTypes = func.invokableType().parameterTypes();\n+        \/\/ build signature string\n+        for (int i = 0; i < paramTypes.size(); i++) {\n+            signature += \"_\" + paramTypes.get(i).toString();\n+        }\n+        \/\/ declare function type if not already present\n+        SPIRVId functionSig = getIdOrNull(signature);\n+        if (functionSig == null) {\n+            SPIRVId[] typeIdsArray = new SPIRVId[paramTypes.size()];\n+            for (int i = 0; i < paramTypes.size(); i++) {\n+                typeIdsArray[i] = spirvType(paramTypes.get(i).toString());\n+            }\n+            functionSig = nextId(fnName + \"Signature\");\n+            module.add(new SPIRVOpTypeFunction(functionSig, spirvType(returnType.toString()), new SPIRVMultipleOperands<>(typeIdsArray)));\n+            addId(signature, functionSig);\n+        }\n+        SPIRVId spirvReturnType = spirvType(returnType.toString());\n+        SPIRVFunction function = (SPIRVFunction)module.add(new SPIRVOpFunction(spirvReturnType, functionId, SPIRVFunctionControl.DontInline(), functionSig));\n+        SPIRVOpLabel entryLabel = new SPIRVOpLabel(nextId());\n+        SPIRVBlock entryBlock = (SPIRVBlock)function.add(entryLabel);\n+        SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(getId(\"globalInvocationId\"), getId(\"globalSize\"), getId(\"subgroupSize\"), getId(\"subgroupId\"));\n+        if (isEntryPoint) {\n+            module.add(new SPIRVOpEntryPoint(SPIRVExecutionModel.Kernel(), functionId, new SPIRVLiteralString(fnName), operands));\n+        }\n+        translateBody(func.body(), function, entryBlock);\n+        function.add(new SPIRVOpFunctionEnd());\n+        return functionId;\n+    }\n+\n+    private void translateBody(Body body, SPIRVFunction function, SPIRVBlock entryBlock) {\n+        int labelNumber = 0;\n+        SPIRVBlock spirvBlock = entryBlock;\n+        for (int bi = 1; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            SPIRVOpLabel blockLabel = new SPIRVOpLabel(nextId());\n+            SPIRVBlock newBlock = (SPIRVBlock)function.add(blockLabel);\n+            symbols.putBlock(block, newBlock);\n+            symbols.putLabel(block, blockLabel);\n+            for (int i = 0; i < block.parameters().size(); i++) {\n+                Value param = block.parameters().get(i);\n+                SPIRVId paramId = nextId();\n+                addResult(param, new SpirvResult(spirvType(param.type().toString()), null, paramId));\n+            }\n+        }\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            if (bi > 0) {\n+                spirvBlock = symbols.getBlock(block);\n+            }\n+            for (Op op : block.ops()) {\n+                switch (op)  {\n+                    case SpirvOp.PhiOp phop -> {\n+                        List<PhiOp.Predecessor> inPredecessors = phop.predecessors();\n+                        SPIRVPairIdRefIdRef[] outPredecessors = new SPIRVPairIdRefIdRef[inPredecessors.size()];\n+                        for (int i = 0; i < inPredecessors.size(); i++) {\n+                            PhiOp.Predecessor predecessor = inPredecessors.get(i);\n+                            SPIRVId label = symbols.getLabel(predecessor.block().targetBlock()).getResultId();\n+                            SPIRVId value = getResult(predecessor.value()).value();\n+                            outPredecessors[i] = new SPIRVPairIdRefIdRef(value, label);\n+                        }\n+                        SPIRVId result = nextId();\n+                        SPIRVId type = spirvType(phop.resultType().toString());\n+                        SPIRVOpPhi phiOp = new SPIRVOpPhi(spirvType(phop.resultType().toString()), result, new SPIRVMultipleOperands<>(outPredecessors));\n+                        spirvBlock.add(phiOp);\n+                        addResult(phop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOp.VariableOp vop -> {\n+                        String typeName = vop.varType().toString();\n+                        SPIRVId type = spirvType(typeName);\n+                        SPIRVId varType = spirvVariableType(type);\n+                        SPIRVId var = nextId(vop.varName());\n+                        spirvBlock.add(new SPIRVOpVariable(varType, var, SPIRVStorageClass.Function(), new SPIRVOptionalOperand<>()));\n+                        addResult(vop.result(), new SpirvResult(varType, var, null));\n+                    }\n+                    case SpirvOp.FunctionParameterOp fpo -> {\n+                        SPIRVId result = nextId();\n+                        SPIRVId type = spirvType(fpo.resultType().toString());\n+                        function.add(new SPIRVOpFunctionParameter(type, result));\n+                        module.add(new SPIRVOpDecorate(result, SPIRVDecoration.Alignment(new SPIRVLiteralInteger(8))));\n+                        addResult(fpo.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOp.LoadOp lo -> {\n+                        SPIRVId type = spirvType(lo.resultType().toString());\n+                        SpirvResult toLoad = getResult(lo.operands().get(0));\n+                        SPIRVId varAddr = toLoad.address();\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpLoad(type, result, varAddr, align(type.getName())));\n+                        addResult(lo.result(), new SpirvResult(type, varAddr, result));\n+                    }\n+                    case SpirvOp.StoreOp so -> {\n+                        SpirvResult var = getResult(so.operands().get(0));\n+                        SPIRVId varAddr = var.address();\n+                        SPIRVId value = getResult(so.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpStore(varAddr, value, align(var.type().getName())));\n+                    }\n+                    case SpirvOp.IAddOp _, SpirvOp.FAddOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIAdd(intType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIAdd(longType, ans, lhs, rhs));\n+                        else if (lhsType == floatType) spirvBlock.add(new SPIRVOpFAdd(floatType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOp.ISubOp _, SpirvOp.FSubOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpISub(intType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpISub(longType, ans, lhs, rhs));\n+                        else if (lhsType == floatType) spirvBlock.add(new SPIRVOpFSub(floatType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOp.IMulOp _, SpirvOp.FMulOp _, SpirvOp.IDivOp _, SpirvOp.FDivOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId rhsType = getResult(op.operands().get(1)).type();\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) {\n+                            if (op instanceof SpirvOp.IMulOp) spirvBlock.add(new SPIRVOpIMul(intType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOp.IDivOp) spirvBlock.add(new SPIRVOpSDiv(intType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == longType) {\n+                            SPIRVId rhsId = rhsType == intType ? nextId() : rhs;\n+                            if (rhsType == intType) spirvBlock.add(new SPIRVOpSConvert(longType, rhsId, rhs));\n+                            if (op instanceof SpirvOp.IMulOp) spirvBlock.add(new SPIRVOpIMul(longType, ans, lhs, rhsId));\n+                            else if (op instanceof SpirvOp.IDivOp) spirvBlock.add(new SPIRVOpSDiv(longType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == floatType) {\n+                            if (op instanceof SpirvOp.FMulOp) spirvBlock.add(new SPIRVOpFMul(floatType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOp.FDivOp) spirvBlock.add(new SPIRVOpFDiv(floatType, ans, lhs, rhs));\n+                        }\n+                        else unsupported(\"type\", lhsType);\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOp.ModOp mop -> {\n+                        SPIRVId type = getType(mop.operands().get(0).type().toString());\n+                        SPIRVId lhs = getResult(mop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(mop.operands().get(1)).value();\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpUMod(type, result, lhs, rhs));\n+                        addResult(mop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOp.IEqualOp eqop -> {\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOp.GeOp eqop -> {\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        spirvBlock.add(new SPIRVOpSGreaterThanEqual(boolType, ans, lhs, rhs));\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOp.PtrNotEqualOp neqop -> {\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId lhs = getResult(neqop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(neqop.operands().get(1)).value();\n+                        SPIRVId ans = nextId();\n+                        SPIRVId lhsLong = nextId();\n+                        SPIRVId rhsLong = nextId();\n+                        spirvBlock.add(new SPIRVOpConvertPtrToU(longType, lhsLong, lhs));\n+                        spirvBlock.add(new SPIRVOpConvertPtrToU(longType, rhsLong, rhs));\n+                        spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhsLong, rhsLong));\n+                        addResult(op.result(), new SpirvResult(boolType, null, ans));\n+                    }\n+                    case SpirvOp.CallOp call -> {\n+                        MethodRef methodRef = call.callDescriptor();\n+                        if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long)int\")))\n+                        {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 1;\n+                            SPIRVId indexX = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId temp1 = nextId();\n+                            SPIRVId temp2 = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(longType, temp1, array));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 4)));\n+                            SPIRVId elementBase = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(arrayType, elementBase, temp2));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, elementBase, indexX, new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(elementType, result, resultAddr, align(elementType.getName())));\n+                            addResult(call.result(), new SpirvResult(elementType, resultAddr, result));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array2D::array(long)int\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array2D::array(long)float\")))\n+                        {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 1;\n+                            SPIRVId indexX = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            SPIRVId temp1 = nextId();\n+                            SPIRVId temp2 = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(longType, temp1, array));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 4)));\n+                            SPIRVId elementBase = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(arrayType, elementBase, temp2));\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, elementBase, indexX, new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(elementType, result, resultAddr, align(elementType.getName())));\n+                            addResult(call.result(), new SpirvResult(elementType, resultAddr, result));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::array(long, int)void\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 2;\n+                            int valueIndex = nIndexes + 1;\n+                            SPIRVId indexX = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId temp1 = nextId();\n+                            SPIRVId temp2 = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(longType, temp1, array));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 4)));\n+                            SPIRVId elementBase = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(arrayType, elementBase, temp2));\n+                            SPIRVId dest = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, dest, elementBase, indexX, new SPIRVMultipleOperands<>()));\n+                            SPIRVId value = getResult(call.operands().get(valueIndex)).value();\n+                            spirvBlock.add(new SPIRVOpStore(dest, value, align(elementType.getName())));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array2D::array(long, int)void\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array2D::array(long, float)void\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 2;\n+                            int valueIndex = nIndexes + 1;\n+                            SPIRVId indexX = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId temp1 = nextId();\n+                            SPIRVId temp2 = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(longType, temp1, array));\n+                            spirvBlock.add(new SPIRVOpIAdd(longType, temp2, temp1, getConst(\"long\", 8)));\n+                            SPIRVId elementBase = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(arrayType, elementBase, temp2));\n+                            SPIRVId dest = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, dest, elementBase, indexX, new SPIRVMultipleOperands<>()));\n+                            SPIRVId value = getResult(call.operands().get(valueIndex)).value();\n+                            spirvBlock.add(new SPIRVOpStore(dest, value, align(elementType.getName())));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array::length()int\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array2D::width()int\"))||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array2D::width()int\"))) {\n+                            SPIRVId intType = getType(\"int\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, array, getConst(\"int\", 0), new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(intType, result, resultAddr, align(arrayType.getName())));\n+                            addResult(call.result(), new SpirvResult(intType, resultAddr, result));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"hat.buffer.S32Array2D::height()int\")) ||\n+                                 methodRef.equals(MethodRef.ofString(\"hat.buffer.F32Array2D::height()int\"))) {\n+                            SPIRVId intType = getType(\"int\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, array, getConst(\"int\", 1), new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(intType, result, resultAddr, align(arrayType.getName())));\n+                            addResult(call.result(), new SpirvResult(intType, resultAddr, result));\n+                        }\n+                        else if (methodRef.equals(MethodRef.ofString(\"java.lang.Math::sqrt(double)double\"))) {\n+                            SPIRVId floatType = getType(\"float\");\n+                            SPIRVId result = nextId();\n+                            SPIRVId operand = getResult(call.operands().get(0)).value();\n+                            spirvBlock.add(new SPIRVOpExtInst(floatType, result, getId(\"oclExtension\"), new SPIRVLiteralExtInstInteger(61, \"sqrt\"), new SPIRVMultipleOperands<>(operand)));\n+                            addResult(call.result(), new SpirvResult(floatType, null, result));\n+                        }\n+                        else {\n+                            SPIRVId fnId = getFunctionId(methodRef);\n+                            if (fnId == null) {\n+                                unsupported(\"method\", methodRef);\n+                            }\n+                            else {\n+                                FunctionType fnType = methodRef.type();\n+                                SPIRVId[] args = new SPIRVId[call.operands().size()];\n+                                for (int i = 0; i < args.length; i++) {\n+                                    SPIRVId argId = getResult(call.operands().get(i)).value();\n+                                    args[i] = argId;\n+                                }\n+                                SPIRVId returnType = spirvType(fnType.returnType().toString());\n+                                SPIRVId callResult = nextId();\n+                                spirvBlock.add(new SPIRVOpFunctionCall(returnType, callResult, fnId, new SPIRVMultipleOperands<>(args)));\n+                                addResult(call.result(), new SpirvResult(returnType, null, callResult));\n+                            }\n+                        }\n+                    }\n+                    case SpirvOp.ConstantOp cop -> {\n+                        SPIRVId type = spirvType(cop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        Object value = cop.value();\n+                        if (type == getType(\"int\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentInt(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"long\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentLong(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"float\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentFloat((float)value)));\n+                        }\n+                        else if (type == getType(\"bool\")) {\n+                            module.add(((boolean)value) ? new SPIRVOpConstantTrue(type, result) : new SPIRVOpConstantFalse(type, result));\n+                        }\n+                        else if (type == getType(\"java.lang.Object\")) {\n+                            module.add(new SPIRVOpConstantNull(type, result));\n+                        }\n+                        else if (type == getType(\"int[]\")) {\n+                            module.add(new SPIRVOpConstantNull(type, result));\n+                        }\n+                        else unsupported(\"type\", cop.resultType());\n+                        addResult(cop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOp.ConvertOp scop -> {\n+                        SPIRVId toType = spirvType(scop.resultType().toString());\n+                        SPIRVId to = nextId();\n+                        SpirvResult valueResult = getResult(scop.operands().get(0));\n+                        SPIRVId from = valueResult.value();\n+                        SPIRVId fromType = valueResult.type();\n+                        if (isIntegerType(fromType)) {\n+                            if (isIntegerType(toType)) {\n+                                spirvBlock.add(new SPIRVOpSConvert(toType, to, from));\n+                            }\n+                            else if (isFloatType(toType)) {\n+                                spirvBlock.add(new SPIRVOpConvertSToF(toType, to, from));\n+                            }\n+                            else unsupported(\"conversion type\", scop.resultType());\n+                        }\n+                        else if (isFloatType(fromType)) {\n+                            if (isIntegerType(toType)) {\n+                                spirvBlock.add(new SPIRVOpConvertFToS(toType, to, from));\n+                            }\n+                            else if (isFloatType(toType)) {\n+                                spirvBlock.add(new SPIRVOpFConvert(toType, to, from));\n+                            }\n+                            else unsupported(\"conversion type\", scop.resultType());\n+                        }\n+                        else unsupported(\"conversion type\", scop.operands().get(0));\n+                        addResult(scop.result(), new SpirvResult(toType, null, to));\n+                    }\n+                    case SpirvOp.InBoundsAccessChainOp iacop -> {\n+                        SPIRVId type = spirvType(iacop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        SPIRVId object = getResult(iacop.operands().get(0)).value();\n+                        SPIRVId index = getResult(iacop.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(type, result, object, index, new SPIRVMultipleOperands<>()));\n+                        addResult(iacop.result(), new SpirvResult(type, result, null));\n+                    }\n+                    case SpirvOp.FieldLoadOp flo -> {\n+                        if (flo.operands().size() > 0 && (flo.operands().get(0).type().equals(JavaType.ofString(\"hat.KernelContext\")))) {\n+                            SpirvResult result;\n+                            int group = -1;\n+                            int index = -1;\n+                            String fieldName = flo.fieldDescriptor().name();\n+                            switch (fieldName) {\n+                                case \"x\": group = 0; index = 0; break;\n+                                case \"y\": group = 0; index = 1; break;\n+                                case \"z\": group = 0; index = 2; break;\n+                                case \"maxX\": group = 1; index = 0; break;\n+                                case \"maxY\": group = 1; index = 1; break;\n+                                case \"maxZ\": group = 1; index = 2; break;\n+                            }\n+                            switch (group) {\n+                                case 0: result = globalId(index, spirvBlock); break;\n+                                case 1: result = globalSize(index, spirvBlock); break;\n+                                default: throw new RuntimeException(\"Unknown Index field: \" + fieldName);\n+                            }\n+                            addResult(flo.result(), result);\n+                        }\n+                        else if (flo.operands().get(0).type().equals(JavaType.ofString(\"hat.KernelContext\"))) {\n+                            String fieldName = flo.fieldDescriptor().name();\n+                            SPIRVId fieldIndex = switch (fieldName) {\n+                                case \"x\" -> getConst(\"long\", 0);\n+                                case \"maxX\" -> getConst(\"long\", 1);\n+                                default -> throw new RuntimeException(\"Unknown field: \" + fieldName);\n+                            };\n+                            SPIRVId intType = getType(\"int\");\n+                            String contextTypeName = flo.operands().get(0).type().toString();\n+                            SpirvResult kernalContext = getResult(flo.operands().get(0));\n+                            SPIRVId contextAddr = kernalContext.address();\n+                            SPIRVId contextType = spirvType(contextTypeName);\n+                            SPIRVId context = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(contextType, context, contextAddr, align(contextType.getName())));\n+                            SPIRVId fieldType = intType;\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsAccessChain(getType(\"ptrInt\"), resultAddr, context, new SPIRVMultipleOperands<>(fieldIndex)));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(intType, result, resultAddr, align(\"int\")));\n+                            addResult(flo.result(), new SpirvResult(intType, resultAddr, result));\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(ByteOrder.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else unsupported(\"field load\", ((ClassType)flo.fieldDescriptor().refType()).toClassName() + \".\" + flo.fieldDescriptor().name());\n+                    }\n+                    case SpirvOp.BranchOp bop -> {\n+                        SPIRVId label = symbols.getLabel(bop.branch().targetBlock()).getResultId();\n+                        Block.Reference target = bop.branch();\n+                        spirvBlock.add(new SPIRVOpBranch(label));\n+                    }\n+                    case SpirvOp.ConditionalBranchOp cbop -> {\n+                        SPIRVId test = getResult(cbop.operands().get(0)).value();\n+                        SPIRVId trueLabel = symbols.getLabel(cbop.trueBranch().targetBlock()).getResultId();\n+                        SPIRVId falseLabel = symbols.getLabel(cbop.falseBranch().targetBlock()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranchConditional(test, trueLabel, falseLabel, new SPIRVMultipleOperands<SPIRVLiteralInteger>()));\n+                    }\n+                    case SpirvOp.LtOp ltop -> {\n+                        SpirvResult lhs = getResult(ltop.operands().get(0));\n+                        SpirvResult rhs = getResult(ltop.operands().get(1));\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId result = nextId();\n+                        String operandType = lhs.type().getName();\n+                        SPIRVInstruction sop = switch (operandType) {\n+                            case \"float\" -> new SPIRVOpFUnordLessThan(boolType, result, lhs.value(), rhs.value());\n+                            case \"int\" -> new SPIRVOpSLessThan(boolType, result, lhs.value(), rhs.value());\n+                            case \"long\" -> new SPIRVOpSLessThan(boolType, result, lhs.value(), rhs.value());\n+                            default -> throw new RuntimeException(\"Unsupported type: \" + lhs.type().getName());\n+                        };\n+                        spirvBlock.add(sop);\n+                        addResult(ltop.result(), new SpirvResult(boolType, null, result));\n+                    }\n+                    case SpirvOp.ReturnOp rop -> {\n+                        spirvBlock.add(new SPIRVOpReturn());\n+                    }\n+                    case SpirvOp.ReturnValueOp rop -> {\n+                        SPIRVId returnValue = getResult(rop.operands().get(0)).value();\n+                        spirvBlock.add(new SPIRVOpReturnValue(returnValue));\n+                    }\n+                    default -> unsupported(\"op\", op.getClass());\n+                }\n+            }\n+        } \/\/ end bi\n+    }\n+\n+    private SPIRVId getFunctionId(MethodRef methodRef) {\n+        SPIRVId fnId = symbols.getId(methodRef.toString());\n+        if (fnId == null) {\n+            try {\n+                Optional<CoreOp.FuncOp> optJFuncOp = methodRef.codeModel(MethodHandles.lookup());\n+                if (optJFuncOp.isPresent()) {\n+                    CoreOp.FuncOp jFuncOp = optJFuncOp.get();\n+                    SpirvOp.FuncOp sFuncOp = TranslateToSpirvModel.translateFunction(jFuncOp);\n+                    fnId = generateFunction(jFuncOp.funcName(), sFuncOp, false);\n+                    symbols.putId(methodRef.toString(), fnId);\n+                }\n+            }\n+            catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return fnId;\n+    }\n+\n+    private void initModule() {\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Addresses()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Linkage()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Kernel()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int8()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int64()));\n+        module.add(new SPIRVOpMemoryModel(SPIRVAddressingModel.Physical64(), SPIRVMemoryModel.OpenCL()));\n+\n+        \/\/ OpenCL extension provides built-in variables suitable for kernel programming\n+        \/\/ Import extension and declare four variables\n+        SPIRVId oclExtension = nextId(\"oclExtension\");\n+        module.add(new SPIRVOpExtInstImport(oclExtension, new SPIRVLiteralString(\"OpenCL.std\")));\n+        symbols.putId(\"oclExtension\", oclExtension);\n+\n+        SPIRVId globalInvocationId = nextId(\"globalInvocationId\");\n+        SPIRVId globalSize = nextId(\"globalSize\");\n+        SPIRVId subgroupSize = nextId(\"subgroupSize\");\n+        SPIRVId subgroupId = nextId(\"subgroupId\");\n+\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalInvocationId())));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalInvocationId\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalSize())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupSize())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupId())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupId\"), SPIRVLinkageType.Import())));\n+\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalInvocationId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+    }\n+\n+    private SPIRVId spirvType(String inputType) {\n+        String javaType = inputType.replaceAll(\"\\\\$\", \".\");\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte\" -> getType(\"byte\");\n+            case \"short\" -> getType(\"short\");\n+            case \"int\" -> getType(\"int\");\n+            case \"long\" -> getType(\"long\");\n+            case \"float\" -> getType(\"float\");\n+            case \"double\" -> getType(\"double\");\n+            case \"byte[]\" -> getType(\"byte[]\");\n+            case \"int[]\" -> getType(\"int[]\");\n+            case \"float[]\" -> getType(\"float[]\");\n+            case \"double[]\" -> getType(\"double[]\");\n+            case \"long[]\" -> getType(\"long[]\");\n+            case \"bool\" -> getType(\"bool\");\n+            case \"boolean\" -> getType(\"bool\");\n+            case \"java.lang.Object\" -> getType(\"java.lang.Object\");\n+            case \"hat.buffer.S32Array\" -> getType(\"int[]\");\n+            case \"hat.buffer.S32Array2D\" -> getType(\"int[]\");\n+            case \"hat.buffer.F32Array2D\" -> getType(\"float[]\");\n+            case \"void\" -> getType(\"void\");\n+            case \"hat.KernelContext\" -> getType(\"ptrKernelContext\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"ptrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvElementType(String inputType) {\n+        String javaType = inputType.replaceAll(\"\\\\$\", \".\");\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte[]\" -> getType(\"byte\");\n+            case \"short[]\" -> getType(\"short\");\n+            case \"int[]\" -> getType(\"int\");\n+            case \"long[]\" -> getType(\"long\");\n+            case \"float[]\" -> getType(\"float\");\n+            case \"double[]\" -> getType(\"double\");\n+            case \"boolean[]\" -> getType(\"bool\");\n+            case \"hat.buffer.S32Array\" -> getType(\"int\");\n+            case \"hat.buffer.S32Array2D\" -> getType(\"int\");\n+            case \"hat.buffer.F32Array2D\" -> getType(\"float\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"byte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorElementType(SPIRVId type) {\n+        SPIRVId ans = switch(type.getName()) {\n+            case \"v8int\" -> getType(\"int\");\n+            case \"v16int\" -> getType(\"int\");\n+            case \"v8long\" -> getType(\"long\");\n+            case \"v8float\" -> getType(\"float\");\n+            case \"v16float\" -> getType(\"float\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", type.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVariableType(SPIRVId spirvType) {\n+        SPIRVId ans = switch(spirvType.getName()) {\n+            case \"bool\" -> getType(\"ptrBool\");\n+            case \"byte\" -> getType(\"ptrByte\");\n+            case \"short\" -> getType(\"ptrShort\");\n+            case \"int\" -> getType(\"ptrInt\");\n+            case \"long\" -> getType(\"ptrLong\");\n+            case \"float\" -> getType(\"ptrFloat\");\n+            case \"double\" -> getType(\"ptrDouble\");\n+            case \"boolean\" -> getType(\"ptrBool\");\n+            case \"byte[]\" -> getType(\"ptrByte[]\");\n+            case \"int[]\" -> getType(\"ptrInt[]\");\n+            case \"long[]\" -> getType(\"ptrLong[]\");\n+            case \"float[]\" -> getType(\"ptrFloat[]\");\n+            case \"double[]\" -> getType(\"ptrDouble[]\");\n+            case \"v8int\" -> getType(\"ptrV8int\");\n+            case \"v16int\" -> getType(\"ptrV16int\");\n+            case \"v8long\" -> getType(\"ptrV8long\");\n+            case \"v8float\" -> getType(\"ptrV8float\");\n+            case \"v16float\" -> getType(\"ptrV16float\");\n+            case \"ptrKernelContext\" -> getType(\"ptrPtrKernelContext\");\n+            case \"hat.KernelContext\" -> getType(\"ptrKernelContext\");\n+            case \"ptrByte\" -> getType(\"ptrPtrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", spirvType.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVectorType(String javaVectorType, int vectorLength) {\n+        String prefix = \"v\" + vectorLength;\n+        String elementType = spirvElementType(javaVectorType).getName();\n+        return getType(prefix + elementType);\n+    }\n+\n+    private int alignment(String inputType) {\n+        String spirvType = inputType.replaceAll(\"\\\\$\", \".\");\n+        int ans = switch(spirvType) {\n+            case \"bool\" -> 1;\n+            case \"byte\" -> 1;\n+            case \"short\" -> 2;\n+            case \"int\" -> 4;\n+            case \"long\" -> 8;\n+            case \"float\" -> 4;\n+            case \"double\" -> 8;\n+            case \"boolean\" -> 1;\n+            case \"v8int\" -> 32;\n+            case \"v16int\" -> 64;\n+            case \"v8long\" -> 64;\n+            case \"v8float\" -> 32;\n+            case \"v16float\" -> 64;\n+            case \"hat.KernelContext\" -> 32;\n+            case \"ptrKernelContext\" -> 32;\n+            case \"byte[]\" -> 8;\n+            case \"int[]\" -> 8;\n+            case \"long[]\" -> 8;\n+            case \"float[]\" -> 8;\n+            case \"double[]\" -> 8;\n+            case \"ptrBool\" -> 8;\n+            case \"ptrByte\" -> 8;\n+            case \"ptrInt\" -> 8;\n+            case \"ptrByte[]\" -> 8;\n+            case \"ptrInt[]\" -> 8;\n+            case \"ptrLong\" -> 8;\n+            case \"ptrLong[]\" -> 8;\n+            case \"ptrFloat\" -> 8;\n+            case \"ptrFloat[]\" -> 8;\n+            case \"ptrV8int\" -> 8;\n+            case \"ptrV8float\" -> 8;\n+            case \"ptrPtrKernelContext\" -> 8;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", spirvType);\n+        return ans;\n+    }\n+\n+    private Set<String> moduleTypes = new HashSet<>();\n+\n+    private SPIRVId getType(String inputName) {\n+        String name = inputName.replaceAll(\"\\\\$\", \".\");\n+        if (!moduleTypes.contains(name)) {\n+            switch (name) {\n+                case \"void\" -> module.add(new SPIRVOpTypeVoid(nextId(name)));\n+                case \"bool\" -> module.add(new SPIRVOpTypeBool(nextId(name)));\n+                case \"boolean\" -> module.add(new SPIRVOpTypeBool(nextId(name)));\n+                case \"byte\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(8), new SPIRVLiteralInteger(0)));\n+                case \"short\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(16), new SPIRVLiteralInteger(0)));\n+                case \"int\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(32), new SPIRVLiteralInteger(0)));\n+                case \"long\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(64), new SPIRVLiteralInteger(0)));\n+                case \"float\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(32)));\n+                case \"double\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(64)));\n+                case \"ptrBool\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"bool\")));\n+                case \"ptrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int\")));\n+                case \"ptrLong\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long\")));\n+                case \"ptrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float\")));\n+                case \"byte[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"short[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"short\")));\n+                case \"int[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"int\")));\n+                case \"long[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"long\")));\n+                case \"float[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"float\")));\n+                case \"double[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"double\")));\n+                case \"boolean[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"boolean\")));\n+                case \"ptrByte[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"byte[]\")));\n+                case \"ptrInt[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int[]\")));\n+                case \"ptrLong[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long[]\")));\n+                case \"ptrFloat[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float[]\")));\n+                case \"java.lang.Object\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"void\")));\n+                case \"hat.KernelContext\" -> module.add(new SPIRVOpTypeStruct(nextId(name), new SPIRVMultipleOperands<>(getType(\"int\"), getType(\"int\"))));\n+                case \"ptrKernelContext\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"hat.KernelContext\")));\n+                case \"ptrCrossGroupByte\"-> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrPtrKernelContext\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrKernelContext\")));\n+                case \"ptrPtrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrByte\")));\n+                case \"ptrPtrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrInt\")));\n+                case \"ptrPtrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrFloat\")));\n+                case \"v3long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(3)));\n+                case \"v8int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(8)));\n+                case \"v8long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(8)));\n+                case \"v16int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(16)));\n+                case \"v8float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(8)));\n+                case \"v16float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(16)));\n+                case \"ptrV3long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Input(), getType(\"v3long\")));\n+                case \"ptrV8long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8long\")));\n+                case \"ptrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8int\")));\n+                case \"ptrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16int\")));\n+                case \"ptrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8float\")));\n+                case \"ptrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16float\")));\n+                case \"ptrPtrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8int\")));\n+                case \"ptrPtrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16int\")));\n+                case \"ptrPtrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8float\")));\n+                case \"ptrPtrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16float\")));\n+                default -> unsupported(\"type\", name);\n+            }\n+            moduleTypes.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private Set<String> moduleConstants = new HashSet<>();\n+\n+    private SPIRVId getConst(String typeName, long value) {\n+        String name = typeName + \"_\" + value;\n+        if (!moduleConstants.contains(name)) {\n+            String valueStr = String.valueOf(value);\n+            switch (typeName) {\n+                case \"int\" -> module.add(new SPIRVOpConstant(getType(typeName), nextId(name), new SPIRVContextDependentInt(new BigInteger(valueStr))));\n+                case \"long\" -> module.add(new SPIRVOpConstant(getType(typeName), nextId(name), new SPIRVContextDependentLong(new BigInteger(valueStr))));\n+                case \"boolean\" -> module.add(value == 0 ? new SPIRVOpConstantFalse(getType(typeName), nextId(name)) : new SPIRVOpConstantTrue(getType(typeName), nextId(name)));\n+                default -> unsupported(\"constant\", name);\n+            };\n+            moduleConstants.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(int align) {\n+        return new SPIRVOptionalOperand<>(SPIRVMemoryAccess.Aligned(new SPIRVLiteralInteger(align)));\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(String type) {\n+        return align(alignment(type));\n+    }\n+\n+    private SPIRVMultipleOperands<SPIRVId> spirvOperands(SPIRVId value, int count) {\n+        SPIRVId[] values = new SPIRVId[count];\n+        Arrays.fill(values, value);\n+        return new SPIRVMultipleOperands<>(values);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> none() {\n+        return new SPIRVOptionalOperand<>();\n+    }\n+\n+    private SpirvResult globalSize(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId intType = getType(\"int\");\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalSizeId = getId(\"globalSize\");\n+        SPIRVId globalSizes = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalSizes, globalSizeId, align(32)));\n+        SPIRVId longSize = nextId();\n+        SPIRVId globalSize = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, longSize, globalSizes, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        spirvBlock.add(new SPIRVOpSConvert(intType, globalSize, longSize));\n+        return new SpirvResult(intType, null, globalSize);\n+    }\n+\n+    private SpirvResult globalId(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId intType = getType(\"int\");\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalInvocationId = getId(\"globalInvocationId\");\n+        SPIRVId globalIds = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalIds, globalInvocationId, align(32)));\n+        SPIRVId longIndex = nextId();\n+        SPIRVId globalIndex = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, longIndex, globalIds, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        spirvBlock.add(new SPIRVOpSConvert(intType, globalIndex, longIndex));\n+        return new SpirvResult(intType, null, globalIndex);\n+    }\n+\n+   private SpirvResult flatIndex(SPIRVId sizeX, SPIRVId sizeY, SPIRVId sizeZ, SPIRVId indexX, SPIRVId indexY, SPIRVId indexZ, SPIRVBlock spirvBlock)\n+    {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId xTerm0 = nextId();\n+        SPIRVId xTerm1 = nextId();\n+        SPIRVId yTerm = nextId();\n+        SPIRVId flat0 = nextId();\n+        SPIRVId flat1 = nextId();\n+        spirvBlock.add(new SPIRVOpIMul(longType, xTerm0, sizeY, sizeZ));\n+        spirvBlock.add(new SPIRVOpIMul(longType, xTerm1, xTerm0, indexX));\n+        spirvBlock.add(new SPIRVOpIMul(longType, yTerm, sizeZ, indexY));\n+        spirvBlock.add(new SPIRVOpIAdd(longType, flat0, xTerm1, yTerm));\n+        spirvBlock.add(new SPIRVOpIAdd(longType, flat1, flat0, indexZ));\n+        return new SpirvResult(longType, null, flat1);\n+    }\n+\n+    private SPIRVId nextId() {\n+        return module.getNextId();\n+    }\n+\n+    private SPIRVId nextId(String name) {\n+        SPIRVId ans = nextId();\n+        ans.setName(name);\n+        symbols.putId(name, ans);\n+        module.add(new SPIRVOpName(ans, new SPIRVLiteralString(name)));\n+        return ans;\n+    }\n+\n+    private static int counter = 0;\n+\n+    private String nextTempTag() {\n+        counter++;\n+        return \"temp_\" + counter + \"_\";\n+    }\n+\n+    private boolean isIntegerType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"byte\") || name.equals(\"short\") || name.equals(\"int\") || name.equals(\"long\");\n+    }\n+\n+    private boolean isFloatType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"float\") || name.equals(\"double\");\n+    }\n+\n+    private boolean isVectorSpecies(String javaType) {\n+        return javaType.equals(\"VectorSpecies\");\n+    }\n+\n+    private boolean isVectorType(String javaType) {\n+        return javaType.equals(\"IntVector\") || javaType.equals(\"FloatVector\");\n+    }\n+\n+    private void addId(String name, SPIRVId id) {\n+        symbols.putId(name, id);\n+    }\n+\n+    private SPIRVId getId(String name) {\n+        SPIRVId ans = symbols.getId(name);\n+        assert ans != null : name + \" not found\";\n+        return ans;\n+    }\n+\n+    private SPIRVId getIdOrNull(String name) {\n+        return symbols.getId(name);\n+    }\n+\n+    private static Object map(Function<Object, Boolean> test, Object... args) {\n+        int len = args.length;\n+        assert len >= 2 && len % 2 == 0;\n+        int pairs = len \/ 2;\n+        for (int i = 0; i < pairs; i++) {\n+            if (test.apply(args[i])) return args[i + pairs];\n+        }\n+        throw new RuntimeException(\"No match: \" + args[0]);\n+    }\n+\n+    private void unsupported(String message, Object value) {\n+        throw new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private void addResult(Value value, SpirvResult result) {\n+        assert symbols.getResult(value) == null : \"result already present\";\n+        symbols.putResult(value, result);\n+    }\n+\n+    private SpirvResult getResult(Value value) {\n+        return symbols.getResult(value);\n+    }\n+\n+    private static class Symbols {\n+        private final HashMap<Value, SpirvResult> results;\n+        private final HashMap<String, SPIRVId> ids;\n+        private final HashMap<Block, SPIRVBlock> blocks;\n+        private final HashMap<Block, SPIRVOpLabel> labels;\n+\n+        public Symbols() {\n+            this.results = new HashMap<>();\n+            this.ids = new HashMap<>();\n+            this.blocks = new HashMap<>();\n+            this.labels = new HashMap<>();\n+        }\n+\n+        public void putId(String name, SPIRVId id) {\n+            ids.put(name, id);\n+        }\n+\n+        public SPIRVId getId(String name) {\n+            return ids.get(name);\n+        }\n+\n+        public void putBlock(Block block, SPIRVBlock spirvBlock) {\n+            blocks.put(block, spirvBlock);\n+        }\n+\n+        public SPIRVBlock getBlock(Block block) {\n+            return blocks.get(block);\n+        }\n+\n+        public void putLabel(Block block, SPIRVOpLabel spirvLabel) {\n+            labels.put(block, spirvLabel);\n+        }\n+\n+        public SPIRVOpLabel getLabel(Block block) {\n+            return labels.get(block);\n+        }\n+\n+        public void putResult(Value value, SpirvResult result) {\n+            results.put(value, result);\n+        }\n+\n+        public SpirvResult getResult(Value value) {\n+            return results.get(value);\n+        }\n+\n+        public String toString() {\n+            return String.format(\"results %s\\n\\nids %s\\n\\nblocks %s\\nlabels %s\\n\", results.keySet(), ids.keySet(), blocks.keySet(), labels.keySet());\n+        }\n+    }\n+\n+    public static void debug(String message, Object... args) {\n+        System.out.println(String.format(message, args));\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":1144,"deletions":0,"binary":false,"changes":1144,"status":"added"},{"patch":"@@ -0,0 +1,873 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public abstract class SpirvOp extends ExternalizableOp {\n+    static final String NAME_PREFIX = \"spirv.\";\n+    private final TypeElement type;\n+    private final Map<String, Object> attributes;\n+\n+    SpirvOp(String opName) {\n+        super(opName, List.of());\n+        this.type = JavaType.VOID;\n+        this.attributes = new HashMap<>();\n+    }\n+\n+    SpirvOp(String opName, TypeElement type, List<Value> operands) {\n+        super(opName, operands);\n+        this.type = type;\n+        this.attributes = new HashMap<>();\n+    }\n+\n+    SpirvOp(String opName, TypeElement type, List<Value> operands, Map<String, Object> attributes) {\n+        super(opName, operands);\n+        this.type = type;\n+        this.attributes = new HashMap<>();\n+    }\n+\n+    SpirvOp(SpirvOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.type = that.type;\n+        this.attributes = new HashMap<>();\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        return attributes;\n+    }\n+\n+    public static final class ModuleOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"module\";\n+\n+        private final String name;\n+\n+        public ModuleOp(String moduleName) {\n+            super(OPNAME);\n+            this.name = moduleName;\n+        }\n+\n+        public ModuleOp(ModuleOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.name = that.name;\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc);\n+        }\n+    }\n+\n+    public static final class PhiOp extends SpirvOp {\n+        public static record Predecessor(Block.Reference block, Value value) {}\n+\n+        public static final String OPNAME = NAME_PREFIX + \"phi\";\n+        private final List<Predecessor> predecessors;\n+\n+\n+        public PhiOp(TypeElement resultType, List<Predecessor> predecessors) {\n+            super(OPNAME, resultType, List.of());\n+            this.predecessors = predecessors;\n+            this.attributes().put(\"predecessors\", predecessors);\n+        }\n+\n+        public PhiOp(PhiOp that, CopyContext cc) {\n+            super(that, cc);\n+            List<Predecessor> thisPredecessors = List.of();\n+            for (var predecessor : that.predecessors) {\n+                thisPredecessors.add(new Predecessor(cc.getSuccessorOrCreate(predecessor.block), predecessor.value()));\n+            }\n+            this.predecessors = thisPredecessors;\n+            this.attributes().put(\"predecessors\", predecessors);\n+        }\n+\n+        @Override\n+        public PhiOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PhiOp(this, cc);\n+        }\n+\n+        public List<Predecessor> predecessors() {\n+            return predecessors;\n+        }\n+    }\n+\n+    public static final class LoadOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"load\";\n+\n+        public LoadOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public LoadOp(LoadOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LoadOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FieldLoadOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"fieldload\";\n+        private final FieldRef fieldDesc;\n+\n+        public FieldLoadOp(TypeElement resultType, FieldRef fieldRef, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+            this.fieldDesc = fieldRef;\n+        }\n+\n+        public FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.fieldDesc = that.fieldDesc;\n+        }\n+\n+        @Override\n+        public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FieldLoadOp(this, cc);\n+        }\n+\n+        public FieldRef fieldDescriptor() {\n+            return fieldDesc;\n+        }\n+    }\n+\n+    public static final class StoreOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"store\";\n+\n+        public StoreOp(Value dest, Value value) {\n+            super(NAME, JavaType.VOID, List.of(dest, value));\n+        }\n+\n+        public StoreOp(List<Value> operands) {\n+            this(operands.get(0), operands.get(1));\n+        }\n+\n+        public StoreOp(StoreOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StoreOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StoreOp(this, cc);\n+        }\n+    }\n+\n+    public static final class CallOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"call\";\n+        private MethodRef descriptor;\n+\n+        public CallOp(MethodRef descriptor, List<Value> operands) {\n+            super(nameString(descriptor), descriptor.type().returnType(), operands);\n+            this.descriptor = descriptor;\n+        }\n+\n+        public CallOp(CallOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.descriptor = that.descriptor;\n+        }\n+\n+        @Override\n+        public CallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CallOp(this, cc);\n+        }\n+\n+        public MethodRef callDescriptor() {\n+            return descriptor;\n+        }\n+\n+        private static String nameString(MethodRef descriptor) {\n+            return OPNAME + \" @\" + descriptor.refType() + \"::\" + descriptor.name();\n+        }\n+    }\n+\n+    public static final class ArrayLengthOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"arraylength\";\n+\n+        public ArrayLengthOp(TypeElement resultType, List<Value> operands) {\n+            super(NAME, resultType, operands);\n+        }\n+\n+        public ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ConstantOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"constant\";\n+        private final Object value;\n+\n+        public ConstantOp(TypeElement resultType, Object value) {\n+                super(OPNAME, resultType, List.of());\n+                this.value = value;\n+        }\n+\n+        public ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.value = that.value;  \/\/ TODO: need to copy\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+    }\n+\n+    public static final class ConvertOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"sconvert\";\n+\n+        public ConvertOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public ConvertOp(ConvertOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConvertOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvertOp(this, cc);\n+        }\n+    }\n+\n+    public static final class BitwiseAndOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"and\";\n+\n+        public BitwiseAndOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public BitwiseAndOp(BitwiseAndOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BitwiseAndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BitwiseAndOp(this, cc);\n+        }\n+    }\n+\n+\n+    public static final class IAddOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"iadd\";\n+\n+        public IAddOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IAddOp(IAddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IAddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IAddOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FAddOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fadd\";\n+\n+        public FAddOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FAddOp(FAddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FAddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FAddOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ISubOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"isub\";\n+\n+        public ISubOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public ISubOp(ISubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ISubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ISubOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FSubOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fsub\";\n+\n+        public FSubOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FSubOp(FSubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FSubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FSubOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IMulOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"imul\";\n+\n+        public IMulOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IMulOp(IMulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IMulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IMulOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FMulOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fmul\";\n+\n+        public FMulOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FMulOp(FMulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FMulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FMulOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IDivOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"idiv\";\n+\n+        public IDivOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IDivOp(IDivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IDivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IDivOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FDivOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fdiv\";\n+\n+        public FDivOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FDivOp(FDivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FDivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FDivOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ModOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"mod\";\n+\n+        public ModOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public ModOp(ModOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ModOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModOp(this, cc);\n+        }\n+    }\n+\n+    public static final class SNegateOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"sneg\";\n+\n+        public SNegateOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public SNegateOp(SNegateOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SNegateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SNegateOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FNegateOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fneg\";\n+\n+        public FNegateOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FNegateOp(FNegateOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FNegateOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FNegateOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"iequal\";\n+\n+        public IEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IEqualOp(IEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fequal\";\n+\n+        public FEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FEqualOp(FEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class INotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"inotequal\";\n+\n+        public INotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public INotEqualOp(INotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public INotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new INotEqualOp(this, cc);\n+        }\n+    }\n+\n+\n+    public static final class FNotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fnotequal\";\n+\n+        public FNotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FNotEqualOp(FNotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FNotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FNotEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class PtrNotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"ptrnotequal\";\n+\n+        public PtrNotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public PtrNotEqualOp(PtrNotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrNotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrNotEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class LtOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"lt\";\n+\n+        public LtOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public LtOp(LtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LtOp(this, cc);\n+        }\n+    }\n+\n+    public static final class GtOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"gt\";\n+\n+        public GtOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public GtOp(GtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GtOp(this, cc);\n+        }\n+    }\n+\n+    public static final class GeOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"ge\";\n+\n+        public GeOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public GeOp(GeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GeOp(this, cc);\n+        }\n+    }\n+\n+    public static final class BranchOp extends SpirvOp implements Op.BlockTerminating {\n+        public static final String NAME = NAME_PREFIX + \"br\";\n+        private final Block.Reference successor;\n+\n+        public BranchOp(Block.Reference successor) {\n+            super(NAME, JavaType.VOID, List.of());\n+            this.successor = successor;\n+        }\n+\n+        public BranchOp(BranchOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.successor = cc.getSuccessorOrCreate(that.successor);\n+        }\n+\n+        @Override\n+        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BranchOp(this, cc);\n+        }\n+\n+        public Block.Reference branch() {\n+            return successor;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(successor);\n+        }\n+    }\n+\n+    public static final class ConditionalBranchOp extends SpirvOp implements Op.BlockTerminating {\n+        public static final String NAME = NAME_PREFIX + \"brcond\";\n+        private final Block.Reference trueBlock;\n+        private final Block.Reference falseBlock;\n+\n+        public ConditionalBranchOp(Block.Reference trueBlock, Block.Reference falseBlock, List<Value> operands) {\n+                super(NAME, JavaType.VOID, operands);\n+                this.trueBlock = trueBlock;\n+                this.falseBlock = falseBlock;\n+        }\n+\n+        public ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.trueBlock = cc.getSuccessorOrCreate(that.trueBlock);\n+            this.falseBlock = cc.getSuccessorOrCreate(that.falseBlock);\n+        }\n+\n+        @Override\n+        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConditionalBranchOp(this, cc);\n+        }\n+\n+        public Block.Reference trueBranch() {\n+            return trueBlock;\n+        }\n+\n+        public Block.Reference falseBranch() {\n+            return falseBlock;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(trueBlock, falseBlock);\n+        }\n+    }\n+\n+    public static final class VariableOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"variable\";\n+        private final String varName;\n+        private final TypeElement varType;\n+\n+        public VariableOp(String varName, TypeElement type, TypeElement varType) {\n+            super(OPNAME + \" @\" + varName, type, List.of());\n+            this.varName = varName;\n+            this.varType = varType;\n+        }\n+\n+        public VariableOp(VariableOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.varName = that.varName;\n+            this.varType = that.varType;\n+        }\n+\n+        @Override\n+        public VariableOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VariableOp(this, cc);\n+        }\n+\n+        public TypeElement varType() {\n+            return varType;\n+        }\n+\n+        public String varName() {\n+            return varName;\n+        }\n+    }\n+\n+    public static final class CompositeExtractOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"compositeExtract\";\n+\n+        public CompositeExtractOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public CompositeExtractOp(CompositeExtractOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CompositeExtractOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CompositeExtractOp(this, cc);\n+        }\n+    }\n+\n+    public static final class InBoundsAccessChainOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"inBoundsAccessChain\";\n+\n+        public InBoundsAccessChainOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public InBoundsAccessChainOp(InBoundsAccessChainOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public InBoundsAccessChainOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InBoundsAccessChainOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ReturnOp extends SpirvOp implements Op.Terminating {\n+        public static final String OPNAME = \"return\";\n+\n+        public ReturnOp(TypeElement resultType) {\n+            super(OPNAME, resultType, List.of());\n+        }\n+\n+        public ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ReturnValueOp extends SpirvOp implements Op.Terminating {\n+        public static final String OPNAME = \"return\";\n+\n+        public ReturnValueOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public ReturnValueOp(ReturnValueOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnValueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnValueOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FunctionParameterOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"function parameter\";\n+\n+        public FunctionParameterOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public FunctionParameterOp(FunctionParameterOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FunctionParameterOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FunctionParameterOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FuncOp extends SpirvOp implements Op.Invokable {\n+        public static enum Control {\n+            INLINE,\n+            DONTINLINE,\n+            PURE,\n+            CONST,\n+            NONE\n+        }\n+\n+        public static final String OPNAME = NAME_PREFIX + \"function\";\n+        private final String functionName;\n+        private final FunctionType functionType;\n+        private final Body body;\n+\n+\n+        public FuncOp(String name, FunctionType functionType, Body.Builder builder) {\n+            super(OPNAME + \"_\" + name);\n+            this.functionName = name;\n+            this.functionType = functionType;\n+            this.body = builder.build(this);\n+        }\n+\n+        public FuncOp(FuncOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.functionName = that.functionName;\n+            this.functionType = that.functionType;\n+            this.body = that.body;\n+        }\n+\n+        public FuncOp transform(OpTransformer ot) {\n+            return transform(CopyContext.create(), ot);\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, this.functionName, cc, ot);\n+        }\n+\n+        FuncOp(FuncOp that, String functionName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+            this.functionType = that.functionType;\n+            this.functionName = functionName;\n+            Body.Builder bb = that.body.transform(cc, ot);\n+            this.body = bb.build(this);\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public String functionName() {\n+            return functionName;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return functionType;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":873,"deletions":0,"binary":false,"changes":873,"status":"added"},{"patch":"","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","status":"copied"},{"patch":"","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","status":"copied"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.Set;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import intel.code.spirv.SpirvOp.PhiOp;\n+\n+public class TranslateToSpirvModel  {\n+    private Map<Block, Block.Builder> blockMap;    \/\/ Java block to spirv block builder\n+    private Map<Value, Value> valueMap;            \/\/ Java model Value to Spirv model Value\n+\n+    public static SpirvOp.FuncOp translateFunction(CoreOp.FuncOp func) {\n+        CoreOp.FuncOp lowFunc = lowerMethod(func);\n+        TranslateToSpirvModel instance = new TranslateToSpirvModel();\n+        Body.Builder bodyBuilder = instance.translateBody(lowFunc.body(), lowFunc, null);\n+        SpirvOp.FuncOp tempFunc = new SpirvOp.FuncOp(lowFunc.funcName(), lowFunc.invokableType(), bodyBuilder);\n+        SpirvOp.FuncOp spirvFunc = instance.addPhiOps(tempFunc);\n+        return spirvFunc;\n+    }\n+\n+    public TranslateToSpirvModel() {\n+        blockMap = new HashMap<>();\n+        valueMap = new HashMap<>();\n+    }\n+\n+    private PhiMap buildPhiMap(SpirvOp.FuncOp func) {\n+        PhiMap phiMap = PhiMap.create(); \/\/ Map<Block, List<List<PhiMap.Predecessor>>>>\n+        \/\/ populate map with (predecessor, parameter value) pairs for each block parameter\n+        for (Block block : func.body().blocks()) {\n+            for (Op op : block.ops()) {\n+                switch (op) {\n+                    case SpirvOp.BranchOp bop: {\n+                        Block targetBlock = bop.branch().targetBlock();\n+                        for (int i = 0; i < bop.branch().arguments().size(); i++) {\n+                            Value arg = bop.branch().arguments().get(i);\n+                            phiMap.addPredecessor(targetBlock, i, new PhiMap.Predecessor(bop.parent(), arg));\n+                        }\n+                        break;\n+                    }\n+                    case SpirvOp.ConditionalBranchOp cbop: {\n+                        Block trueBlock = cbop.trueBranch().targetBlock();\n+                        Block falseBlock = cbop.falseBranch().targetBlock();\n+                        for (int i = 0; i < cbop.trueBranch().arguments().size(); i++) {\n+                            Value arg = cbop.trueBranch().arguments().get(i);\n+                            phiMap.addPredecessor(trueBlock, i, new PhiMap.Predecessor(cbop.parent(), arg));\n+                        }\n+                        for (int i = 0; i < cbop.falseBranch().arguments().size(); i++) {\n+                            Value arg = cbop.falseBranch().arguments().get(i);\n+                            phiMap.addPredecessor(falseBlock, i, new PhiMap.Predecessor(cbop.parent(), arg));\n+                        }\n+                        break;\n+                    }\n+                    default:\n+                }\n+            }\n+        }\n+        return phiMap;\n+    }\n+\n+    private SpirvOp.FuncOp addPhiOps(SpirvOp.FuncOp func) {\n+        PhiMap phiMap = buildPhiMap(func);\n+        SpirvOp.FuncOp tfunc = func.transform((builder, op) -> {\n+            Block block = op.parent();\n+            if (phiMap.containsBlock(block)) {\n+                for (int i = 0; i < block.parameters().size(); i++) {\n+                    List<PhiMap.Predecessor> inPredecessors = phiMap.getPredecessors(block, i);\n+                    List<PhiOp.Predecessor> outPredecessors = new ArrayList<>();\n+                    Block.Parameter param = block.parameters().get(i);\n+                    for (PhiMap.Predecessor predecessor : inPredecessors) {\n+                        Block.Builder sourceBuilder = builder.context().getBlock(predecessor.block());\n+                        Block.Reference sourceRef = sourceBuilder.isEntryBlock() ? null : sourceBuilder.successor();\n+                        outPredecessors.add(new PhiOp.Predecessor(sourceRef, builder.context().getValue(predecessor.value())));\n+                    }\n+                    Op.Result phiResult = builder.op(new SpirvOp.PhiOp(param.type(), outPredecessors));\n+                    builder.context().mapValue(param, phiResult);\n+                }\n+                phiMap.removeBlock(block);\n+            }\n+            builder.op(op);\n+            return builder;\n+        });\n+        return tfunc;\n+    }\n+\n+    private Body.Builder translateBody(Body body, Op parentOp, Body.Builder ancestorBody) {\n+        Body.Builder bodyBuilder = Body.Builder.of(ancestorBody, body.bodyType());\n+        Block.Builder spirvBlock = bodyBuilder.entryBlock();\n+        blockMap.put(body.entryBlock(), spirvBlock);\n+        List<Block> blocks = body.blocks();\n+        \/\/ map Java blocks to spirv blocks\n+        for (Block b : blocks.subList(1, blocks.size()))  {\n+            Block.Builder loweredBlock = spirvBlock.block();\n+            for (TypeElement paramType : b.parameterTypes()) {\n+                loweredBlock.parameter(paramType);\n+            }\n+            spirvBlock = loweredBlock;\n+            for (int i = 0; i < b.parameters().size(); i++) {\n+                Block.Parameter param = b.parameters().get(i);\n+                valueMap.put(param, spirvBlock.parameters().get(i));\n+            }\n+            blockMap.put(b, spirvBlock);\n+        }\n+        \/\/ map entry block parameters to spirv function parameter\n+        spirvBlock = bodyBuilder.entryBlock();\n+        List<SpirvOp> paramOps = new ArrayList<>();\n+        Block entryBlock = body.entryBlock();\n+        int paramCount = entryBlock.parameters().size();\n+        for (int i = 0; i < paramCount; i++) {\n+            Block.Parameter bp = entryBlock.parameters().get(i);\n+            assert entryBlock.ops().get(i) instanceof CoreOp.VarOp;\n+            SpirvOp funcParam = new SpirvOp.FunctionParameterOp(bp.type(), List.of());\n+            spirvBlock.op(funcParam);\n+            valueMap.put(bp, funcParam.result());\n+            paramOps.add(funcParam);\n+        }\n+        \/\/ emit all SpirvOp.VariableOps as first ops in entry block\n+        for (Block block : body.blocks()) {\n+            for (Op op : block.ops()) {\n+                if (op instanceof CoreOp.VarOp jvop) {\n+                    TypeElement resultType = new PointerType(jvop.varValueType(), StorageType.CROSSWORKGROUP);\n+                    SpirvOp.VariableOp svop = new SpirvOp.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varValueType());\n+                    bodyBuilder.entryBlock().op(svop);\n+                    valueMap.put(jvop.result(), svop.result());\n+                }\n+            }\n+        }\n+        for (Block block : body.blocks()) {\n+            spirvBlock = blockMap.get(block);\n+            for (Op op : block.ops()) {\n+                switch (op) {\n+                    case CoreOp.VarOp vop -> {\n+                        Value dest = valueMap.get(vop.result());\n+                        Value value = valueMap.get(vop.operands().get(0));\n+                        \/\/ init variable here; declaration has been moved to top of function\n+                        SpirvOp.StoreOp store = new SpirvOp.StoreOp(dest, value);\n+                        spirvBlock.op(store);\n+                    }\n+                    case CoreOp.ReturnOp rop -> {\n+                        if (rop.operands().size() > 0) {\n+                            spirvBlock.op(new SpirvOp.ReturnValueOp(rop.resultType(), mapOperands(rop)));\n+                        }\n+                        else {\n+                            spirvBlock.op(new SpirvOp.ReturnOp(rop.resultType()));\n+                        }\n+                    }\n+                    case CoreOp.VarAccessOp.VarLoadOp vlo -> {\n+                        List<Value> operands = mapOperands(vlo);\n+                        Op.Result loadResult = spirvBlock.op(new SpirvOp.LoadOp(vlo.resultType(), operands));\n+                        valueMap.put(vlo.result(), loadResult);\n+                    }\n+                    case CoreOp.VarAccessOp.VarStoreOp vso -> {\n+                        Value dest = valueMap.get(vso.varOp().result());\n+                        Value value = valueMap.get(vso.operands().get(1));\n+                        spirvBlock.op(new SpirvOp.StoreOp(dest, value));\n+                    }\n+                    case CoreOp.ArrayAccessOp.ArrayLoadOp alo -> {\n+                        Value array = valueMap.get(alo.operands().get(0));\n+                        Value index = valueMap.get(alo.operands().get(1));\n+                        TypeElement arrayType = array.type();\n+                        SpirvOp.ConvertOp convert = new SpirvOp.ConvertOp(JavaType.type(long.class), List.of(index));\n+                        spirvBlock.op(new SpirvOp.LoadOp(arrayType, List.of(array)));\n+                        spirvBlock.op(convert);\n+                        SpirvOp ibac = new SpirvOp.InBoundsAccessChainOp(arrayType, List.of(array, convert.result()));\n+                        spirvBlock.op(ibac);\n+                        Op.Result loadResult = spirvBlock.op(new SpirvOp.LoadOp(alo.resultType(), List.of(ibac.result())));\n+                        valueMap.put(alo.result(), loadResult);\n+                    }\n+                    case CoreOp.ArrayAccessOp.ArrayStoreOp aso -> {\n+                        Value array = valueMap.get(aso.operands().get(0));\n+                        Value index = valueMap.get(aso.operands().get(1));\n+                        TypeElement arrayType = array.type();\n+                        SpirvOp ibac = new SpirvOp.InBoundsAccessChainOp(arrayType, List.of(array, index));\n+                        spirvBlock.op(ibac);\n+                        SpirvOp.StoreOp store = new SpirvOp.StoreOp(ibac.result(), valueMap.get(aso.operands().get(2)));\n+                        spirvBlock.op(store);\n+                    }\n+                    case CoreOp.ArrayLengthOp alo -> {\n+                        Op len = new SpirvOp.ArrayLengthOp(JavaType.INT, List.of(valueMap.get(alo.operands().get(0))));\n+                        spirvBlock.op(len);\n+                        valueMap.put(alo.result(), len.result());\n+                    }\n+                    case CoreOp.AndOp andop -> {\n+                        TypeElement type = andop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(andop);\n+                        SpirvOp saop = new SpirvOp.BitwiseAndOp(type, operands);\n+                        spirvBlock.op(saop);\n+                        valueMap.put(andop.result(), saop.result());\n+                     }\n+                    case CoreOp.AddOp aop -> {\n+                        TypeElement type = aop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(aop);\n+                        SpirvOp addOp;\n+                        if (isIntegerType(type)) addOp = new SpirvOp.IAddOp(type, operands);\n+                        else if (isFloatType(type)) addOp = new SpirvOp.FAddOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(addOp);\n+                        valueMap.put(aop.result(), addOp.result());\n+                     }\n+                    case CoreOp.SubOp sop -> {\n+                        TypeElement  type = sop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(sop);\n+                        SpirvOp subOp;\n+                        if (isIntegerType(type)) subOp = new SpirvOp.ISubOp(type, operands);\n+                        else if (isFloatType(type)) subOp = new SpirvOp.FSubOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(subOp);\n+                        valueMap.put(sop.result(), subOp.result());\n+                     }\n+                    case CoreOp.MulOp mop -> {\n+                        TypeElement type = mop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(mop);\n+                        SpirvOp mulOp;\n+                        if (isIntegerType(type)) mulOp = new SpirvOp.IMulOp(type, operands);\n+                        else if (isFloatType(type)) mulOp = new SpirvOp.FMulOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(mulOp);\n+                        valueMap.put(mop.result(), mulOp.result());\n+                    }\n+                    case CoreOp.DivOp dop -> {\n+                        TypeElement type = dop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(dop);\n+                        SpirvOp divOp;\n+                        if (isIntegerType(type)) divOp = new SpirvOp.IDivOp(type, operands);\n+                        else if (isFloatType(type)) divOp = new SpirvOp.FDivOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(divOp);\n+                        valueMap.put(dop.result(), divOp.result());\n+                    }\n+                    case CoreOp.ModOp mop -> {\n+                        TypeElement type = mop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(mop);\n+                        SpirvOp modOp = new SpirvOp.ModOp(type, operands);\n+                        spirvBlock.op(modOp);\n+                        valueMap.put(mop.result(), modOp.result());\n+                    }\n+                    case CoreOp.NegOp negop -> {\n+                        TypeElement type = negop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(negop);\n+                        SpirvOp snegop;\n+                        if (isIntegerType(type)) snegop = new SpirvOp.SNegateOp(type, operands);\n+                        else if (isFloatType(type)) snegop = new SpirvOp.FNegateOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(snegop);\n+                        valueMap.put(negop.result(), snegop.result());\n+                    }\n+                    case CoreOp.EqOp eqop -> {\n+                        TypeElement type = eqop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(eqop);\n+                        SpirvOp seqop;\n+                        if (isIntegerType(type)) seqop = new SpirvOp.IEqualOp(type, operands);\n+                        else if (isFloatType(type)) seqop = new SpirvOp.FEqualOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(seqop);\n+                        valueMap.put(eqop.result(), seqop.result());\n+                    }\n+                    case CoreOp.NeqOp neqop -> {\n+                        TypeElement type = neqop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(neqop);\n+                        SpirvOp sneqop;\n+                        if (isIntegerType(type)) sneqop = new SpirvOp.INotEqualOp(type, operands);\n+                        else if (isFloatType(type)) sneqop = new SpirvOp.FNotEqualOp(type, operands);\n+                        else if (isObjectType(type)) sneqop = new SpirvOp.PtrNotEqualOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(sneqop);\n+                        valueMap.put(neqop.result(), sneqop.result());\n+                    }\n+                    case CoreOp.LtOp ltop -> {\n+                        TypeElement type = ltop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(ltop);\n+                        SpirvOp sltop = new SpirvOp.LtOp(type, operands);\n+                        spirvBlock.op(sltop);\n+                        valueMap.put(ltop.result(), sltop.result());\n+                    }\n+                    case CoreOp.GtOp gtop -> {\n+                        TypeElement type = gtop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(gtop);\n+                        SpirvOp sgtop = new SpirvOp.LtOp(type, operands);\n+                        spirvBlock.op(sgtop);\n+                        valueMap.put(gtop.result(), sgtop.result());\n+                    }\n+                    case CoreOp.GeOp geop -> {\n+                        TypeElement type = geop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(geop);\n+                        SpirvOp sgeop = new SpirvOp.GeOp(type, operands);\n+                        spirvBlock.op(sgeop);\n+                        valueMap.put(geop.result(), sgeop.result());\n+                    }\n+                    case CoreOp.InvokeOp inv -> {\n+                        List<Value> operands = mapOperands(inv);\n+                        SpirvOp spirvCall = new SpirvOp.CallOp(inv.invokeDescriptor(), operands);\n+                        spirvBlock.op(spirvCall);\n+                        valueMap.put(inv.result(), spirvCall.result());\n+                    }\n+                    case CoreOp.ConstantOp cop -> {\n+                        SpirvOp scop = new SpirvOp.ConstantOp(cop.resultType(), cop.value());\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n+                    case CoreOp.ConvOp cop -> {\n+                        List<Value> operands = mapOperands(cop);\n+                        SpirvOp scop = new SpirvOp.ConvertOp(cop.resultType(), operands);\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n+                    case CoreOp.FieldAccessOp.FieldLoadOp flo -> {\n+                        SpirvOp load = new SpirvOp.FieldLoadOp(flo.resultType(), flo.fieldDescriptor(), mapOperands(flo));\n+                        spirvBlock.op(load);\n+                        valueMap.put(flo.result(), load.result());\n+                    }\n+                    case CoreOp.BranchOp bop -> {\n+                        Block branchBlock = bop.branch().targetBlock();\n+                        List<Value> sargs = new ArrayList<>();\n+                        for (Value arg : bop.branch().arguments()) {\n+                            sargs.add(valueMap.get(arg));\n+                        }\n+                        Block.Reference spvTargetBlock = blockMap.get(branchBlock).successor(sargs);\n+                        spirvBlock.op(new SpirvOp.BranchOp(spvTargetBlock));\n+                    }\n+                    case CoreOp.ConditionalBranchOp cbop -> {\n+                        Block trueBlock = cbop.trueBranch().targetBlock();\n+                        List<Value> targs = new ArrayList<>();\n+                        for (Value targ : cbop.trueBranch().arguments()) {\n+                            targs.add(valueMap.get(targ));\n+                        }\n+                        Block falseBlock = cbop.falseBranch().targetBlock();\n+                        List<Value> fargs = new ArrayList<>();\n+                        for (Value farg : cbop.falseBranch().arguments()) {\n+                            fargs.add(valueMap.get(farg));\n+                        }\n+                        Block.Reference spvTrueBlock = blockMap.get(trueBlock).successor(targs);\n+                        Block.Reference spvFalseBlock = blockMap.get(falseBlock).successor(fargs);\n+                        spirvBlock.op(new SpirvOp.ConditionalBranchOp(spvTrueBlock, spvFalseBlock, mapOperands(cbop)));\n+                    }\n+                    default -> throw unsupported(\"op\", op.getClass());\n+                }\n+            } \/\/ops\n+        } \/\/ blocks\n+        return bodyBuilder;\n+    }\n+\n+    private RuntimeException unsupported(String message, Object value) {\n+        return new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private static CoreOp.FuncOp lowerMethod(CoreOp.FuncOp fop) {\n+        CoreOp.FuncOp lfop = fop.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop)  {\n+                return lop.lower(block);\n+            }\n+            else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        return lfop;\n+    }\n+\n+    private List<Value> mapOperands(Op op) {\n+        List<Value> operands = new ArrayList<>();\n+        for (Value javaValue : op.operands()) {\n+            Value spirvValue = valueMap.get(javaValue);\n+            assert spirvValue != null : \"no value mapping from %s\" + javaValue;\n+            if (spirvValue == null) throw new RuntimeException(\"no value mapping from %s\" + javaValue);\n+            operands.add(spirvValue);\n+        }\n+        return operands;\n+    }\n+\n+    private boolean isIntegerType(TypeElement type) {\n+        return type.equals(JavaType.INT) || type.equals(JavaType.LONG);\n+    }\n+\n+    private boolean isFloatType(TypeElement type) {\n+        return type.equals(JavaType.FLOAT) || type.equals(JavaType.DOUBLE);\n+    }\n+\n+    private boolean isObjectType(TypeElement type) {\n+        \/\/ TODO: not correct\n+        return !isIntegerType(type) && !isFloatType(type);\n+    }\n+\n+    private static class PhiMap {\n+        public static record Predecessor(Block block, Value value) {}\n+\n+        private Map<Block, List<List<Predecessor>>> data;\n+\n+        private PhiMap() {\n+            data = new HashMap<>();\n+        }\n+\n+        public static PhiMap create() {\n+            return new PhiMap();\n+        }\n+\n+        private void addBlock(Block block) {\n+            data.putIfAbsent(block, new ArrayList<>());\n+        }\n+\n+        private void addParameter(Block block, int index) {\n+            addBlock(block);\n+            int paramCount = data.get(block).size();\n+            if (paramCount <= index) {\n+                data.get(block).add(new ArrayList<>());\n+            }\n+        }\n+\n+        public void addPredecessor(Block block, int paramIndex, Predecessor predecessor) {\n+            addBlock(block);\n+            addParameter(block, paramIndex);\n+            data.get(block).get(paramIndex).add(predecessor);\n+        }\n+\n+        public boolean containsBlock(Block block) {\n+            return data.containsKey(block);\n+        }\n+\n+        public List<Predecessor> getPredecessors(Block block, int paramIndex) {\n+            return data.get(block).get(paramIndex);\n+        }\n+\n+        public void removeBlock(Block block) {\n+            data.remove(block);\n+        }\n+\n+        public String toString() {\n+            return data.toString();\n+        }\n+    }\n+}\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import static java.lang.foreign.ValueLayout.*;\n+import oneapi.levelzero.ze_api_h;\n+import static oneapi.levelzero.ze_api_h.*;\n+import oneapi.levelzero.ze_device_mem_alloc_desc_t;\n+import oneapi.levelzero.ze_host_mem_alloc_desc_t;\n+\n+public final class UsmArena implements Arena {\n+    private final Arena lzArena;\n+    private final MemorySegment contextHandle;\n+    private final MemorySegment deviceHandle;\n+\n+    public UsmArena(MemorySegment contextHandle, MemorySegment deviceHandle) {\n+        lzArena = Arena.global();\n+        this.contextHandle = contextHandle;\n+        this.deviceHandle = deviceHandle;\n+    }\n+\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        MemorySegment pDeviceMemAllocDesc = lzArena.allocate(ze_device_mem_alloc_desc_t.layout());\n+        ze_device_mem_alloc_desc_t.stype(pDeviceMemAllocDesc, ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC());\n+        ze_device_mem_alloc_desc_t.ordinal(pDeviceMemAllocDesc, 0);\n+        MemorySegment pHostMemAllocDesc = lzArena.allocate(ze_host_mem_alloc_desc_t.layout());\n+        ze_host_mem_alloc_desc_t.stype(pHostMemAllocDesc, ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC());\n+        MemorySegment pBuffer = lzArena.allocate(ADDRESS);\n+        check(zeMemAllocShared(contextHandle, pDeviceMemAllocDesc, pHostMemAllocDesc, byteSize, byteAlignment, deviceHandle, pBuffer));\n+        long address = pBuffer.get(JAVA_LONG, 0);\n+        return MemorySegment.ofAddress(address).reinterpret(byteSize);\n+    }\n+\n+    public void close() {\n+    }\n+\n+    public MemorySegment.Scope scope() {\n+        return null;\n+    }\n+\n+    public void freeSegment(MemorySegment segment) {\n+        check(zeMemFree(contextHandle, segment));\n+    }\n+\n+    private static void check(int result) {\n+        if (result != ZE_RESULT_SUCCESS()) {\n+            throw new RuntimeException(String.format(\"Call failed: 0x%x (%d)\", result, result));\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/spirv\/src\/main\/java\/intel\/code\/spirv\/UsmArena.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-            --class-path maven-build\/hat-1.0.jar:${example_jar}:${backend_jar} \\\n+            --class-path maven-build\/hat-1.0.jar:${example_jar}:${backend_jar}:maven-build\/levelzero.jar:maven-build\/beehive-spirv-lib-0.0.4.jar \\\n@@ -48,1 +48,1 @@\n-            -Djava.library.path=maven-build\\\n+            -Djava.library.path=maven-build:\/usr\/local\/lib \\\n","filename":"hat\/hatrun.bash","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}