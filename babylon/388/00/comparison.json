{"files":[{"patch":"@@ -41,6 +41,0 @@\n-#if (\"${PTX_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n-#    set (PTX_BACKEND \"${CMAKE_SOURCE_DIR}\/ptx\")\n-#    message(\"PTX_BACKEND=${PTX_BACKEND}\")\n-#endif()\n-#add_subdirectory(ptx)\n-\n","filename":"hat\/backends\/ffi\/CMakeLists.txt","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+\n@@ -35,4 +37,6 @@\n-            ~MockKernel() {}\n-            long ndrange(void *argArray) {\n-                std::cout << \"mock ndrange() \" << std::endl;\n-                return 0;\n+            ~MockKernel() override = default;\n+            bool setArg(KernelArg *arg, Buffer *buffer) override{\n+                return false ;\n+            }\n+            bool setArg(KernelArg *arg) override{\n+                return false ;\n@@ -53,0 +57,13 @@\n+    };\n+    class MockQueue: public Backend::Queue{\n+    public:\n+        void wait()override{};\n+        void release()override{};\n+        void computeStart()override{};\n+        void computeEnd()override{};\n+        void dispatch(KernelContext *kernelContext, Backend::CompilationUnit::Kernel *kernel) override{\n+            std::cout << \"mock dispatch() \" << std::endl;\n+            size_t dims = 1;\n+            if (backend->config->trace | backend->config->traceEnqueues){\n+                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->maxX << std::endl;\n+            }\n@@ -54,2 +71,0 @@\n-        bool compilationUnitOK() {\n-            return true;\n@@ -57,0 +72,4 @@\n+        void copyToDevice(Buffer *buffer) override{}\n+        void copyFromDevice(Buffer *buffer) override{};\n+        explicit MockQueue(Backend *backend):Queue(backend){}\n+        ~MockQueue() override =default;\n@@ -58,1 +77,0 @@\n-\n@@ -61,1 +79,1 @@\n-    MockBackend(int configBits): Backend(configBits) {\n+    MockBackend(int configBits): Backend(new Config(configBits), new MockQueue(this)) {\n@@ -66,0 +84,2 @@\n+    Buffer * getOrCreateBuffer(BufferState *bufferState) override{\n+        Buffer *buffer = nullptr;\n@@ -67,0 +87,13 @@\n+        \/* if (bufferState->vendorPtr == 0L || bufferState->state == BufferState::NEW_STATE){\n+              openclBuffer = new OpenCLBuffer(this,  bufferState);\n+              if (openclConfig.trace){\n+                  std::cout << \"We allocated arg buffer \"<<std::endl;\n+              }\n+          }else{\n+              if (openclConfig.trace){\n+                  std::cout << \"Were reusing  buffer  buffer \"<<std::endl;\n+              }\n+              openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+          }*\/\n+        return buffer;\n+    }\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        ${OPENCL_BACKEND}\/cpp\/opencl_backend_config.cpp\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,15 @@\n-\n+OpenCLBackend::OpenCLBuffer * OpenCLBackend::getOrCreateBuffer(BufferState *bufferState) {\n+    OpenCLBuffer *openclBuffer = nullptr;\n+    if (bufferState->vendorPtr == 0L || bufferState->state == BufferState::NEW_STATE){\n+        openclBuffer = new OpenCLBuffer(this,  bufferState);\n+        if (config->trace){\n+           std::cout << \"We allocated arg buffer \"<<std::endl;\n+       }\n+    }else{\n+        if (config->trace){\n+            std::cout << \"Were reusing  buffer  buffer \"<<std::endl;\n+        }\n+        openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+    }\n+    return openclBuffer;\n+}\n@@ -29,1 +43,1 @@\n-    if (openclConfig.traceCalls){\n+    if (config->traceCalls){\n@@ -32,5 +46,5 @@\n-    if (openclConfig.minimizeCopies){\n-       BufferState_s * bufferState = BufferState_s::of(memorySegment,memorySegmentLength);\n-       if (bufferState->state == BufferState_s::DEVICE_OWNED){\n-          static_cast<OpenCLBackend::OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n-          if (openclConfig.traceEnqueues | openclConfig.traceCopies){\n+    if (config->minimizeCopies){\n+       BufferState * bufferState = BufferState::of(memorySegment,memorySegmentLength);\n+       if (bufferState->state == BufferState::DEVICE_OWNED){\n+           queue->copyFromDevice(static_cast<Backend::Buffer *>(bufferState->vendorPtr));\n+          if (config->traceEnqueues | config->traceCopies){\n@@ -39,2 +53,2 @@\n-          openclQueue.wait();\n-          openclQueue.release();\n+          queue->wait();\n+          queue->release();\n@@ -49,1 +63,1 @@\n-    if (openclConfig.traceCalls){\n+    if (config->traceCalls){\n@@ -56,1 +70,1 @@\n-        : Backend(configBits), openclConfig(mode), openclQueue(this) {\n+        : Backend(new Config(configBits), new OpenCLQueue(this)) {\n@@ -66,2 +80,2 @@\n-    if (openclConfig.platform >= platformc){\n-        std::cerr << \"We only have \"<<platformc<<\" platform\"<<((platformc>1)?\"s\":\"\")<<\" (platform[0]-platform[\"<<(platformc-1)<<\"] inclusive) you requested platform[\"<<openclConfig.platform<<\"]\"<< std::endl;\n+    if (config->platform >= platformc){\n+        std::cerr << \"We only have \"<<platformc<<\" platform\"<<((platformc>1)?\"s\":\"\")<<\" (platform[0]-platform[\"<<(platformc-1)<<\"] inclusive) you requested platform[\"<<config->platform<<\"]\"<< std::endl;\n@@ -78,1 +92,1 @@\n-        platform_id = platforms[openclConfig.platform];\n+        platform_id = platforms[config->platform];\n@@ -86,2 +100,2 @@\n-       if (openclConfig.device >= devicec){\n-            std::cerr << \"Platform[\"<<openclConfig.platform<<\"] only has \"<<devicec<<\" device\"<<((devicec>1)?\"s\":\"\")<<\" (device[0]-device[\"<<(devicec-1)<<\"] inclusive) and you requested device[\"<<openclConfig.device<<\"]\"<< std::endl;\n+       if (config->device >= devicec){\n+            std::cerr << \"Platform[\"<<config->platform<<\"] only has \"<<devicec<<\" device\"<<((devicec>1)?\"s\":\"\")<<\" (device[0]-device[\"<<(devicec-1)<<\"] inclusive) and you requested device[\"<<config->device<<\"]\"<< std::endl;\n@@ -107,1 +121,1 @@\n-    if ((context = clCreateContext(nullptr, 1, &device_ids[openclConfig.device], NULL, NULL, &status)) == NULL || status != CL_SUCCESS) {\n+    if ((context = clCreateContext(nullptr, 1, &device_ids[config->device], NULL, NULL, &status)) == NULL || status != CL_SUCCESS) {\n@@ -115,2 +129,2 @@\n-\n-    if ((openclQueue.command_queue = clCreateCommandQueue(context, device_ids[openclConfig.device], queue_props, &status)) == NULL ||\n+    auto openCLQueue = dynamic_cast<OpenCLQueue *>(queue);\n+    if ((openCLQueue->command_queue = clCreateCommandQueue(context, device_ids[config->device], queue_props, &status)) == NULL ||\n@@ -125,1 +139,1 @@\n-    device_id = device_ids[openclConfig.device];\n+    device_id = device_ids[config->device];\n@@ -137,1 +151,1 @@\n-  if (openclConfig.trace){\n+  if (config->trace){\n@@ -140,1 +154,1 @@\n-  openclQueue.computeStart();\n+    queue->computeStart();\n@@ -143,2 +157,2 @@\n-  openclQueue.computeEnd();\n- openclQueue.wait();\n+  queue->computeEnd();\n+    queue->wait();\n@@ -146,2 +160,3 @@\n- if (openclConfig.profile){\n-     openclQueue.showEvents(100);\n+ if (config->profile){\n+     auto openCLQueue = dynamic_cast<OpenCLQueue *>(queue);\n+     openCLQueue->showEvents(100);\n@@ -149,2 +164,2 @@\n- openclQueue.release();\n- if (openclConfig.trace){\n+    queue->release();\n+ if (config->trace){\n@@ -170,1 +185,1 @@\n-        if(openclConfig.trace){\n+        if(config->trace){\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":44,"deletions":29,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,7 +28,2 @@\n-\n-\/*\n-  OpenCLBuffer\n-  *\/\n-\n-OpenCLBackend::OpenCLBuffer::OpenCLBuffer(Backend *backend, Arg_s *arg, BufferState_s *bufferState)\n-        : Backend::Buffer(backend, arg, bufferState) {\n+OpenCLBackend::OpenCLBuffer::OpenCLBuffer(Backend *backend, BufferState *bufferState)\n+        : Backend::Buffer(backend, bufferState) {\n@@ -36,1 +31,1 @@\n-    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n+    auto * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n@@ -40,2 +35,2 @@\n-        bufferState->length,\/\/ arg->value.buffer.sizeInBytes,\n-        arg->value.buffer.memorySegment,\n+        bufferState->length,\n+        bufferState->ptr,\n@@ -48,80 +43,1 @@\n-     bufferState->vendorPtr =  static_cast<void *>(this);\n-    if (openclBackend->openclConfig.traceCopies){\n-        std::cout << \"created buffer for arg idx \"<< arg->idx << std::endl;\n-    }\n-\n-}\n-\n-bool OpenCLBackend::OpenCLBuffer::shouldCopyToDevice( Arg_s *arg){\n-\/\/std::cout << \"shouldCopyToDevice( Arg_s *arg)\" <<std::endl;\n-\/\/ std::cout <<std::hex;\n-\/\/\/\/ std::cout << \"arg==\"<<((long) arg) <<std::endl;\n-\/\/ std::cout << \"arg->idx==\"<<arg->idx <<std::endl;\n- \/\/  std::cout << \"bufferState==\"<<((long) bufferState) <<std::endl;\n-  \/\/  std::cout << \"kernel==\"<<((long) kernel) <<std::endl;\n-  \/\/    std::cout << \"kernel->name==\"<<kernel->name <<std::endl;\n-  \/\/   std::cout << \"kernel->program==\"<<((long) kernel->program) <<std::endl;\n-   \/\/   std::cout << \"kernel->program->backend==\"<<((long) kernel->program->backend) <<std::endl;\n-   \/\/   std::cout <<std::dec;\n-         OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n-\n-\n-   bool kernelReadsFromThisArg = (arg->value.buffer.access==RW_BYTE) || (arg->value.buffer.access==RO_BYTE);\n-   bool isAlwaysCopyingOrNewStateOrHostOwned =\n-        openclBackend->openclConfig.alwaysCopy\n-        ||  (bufferState->state == BufferState_s::NEW_STATE)\n-        || ((bufferState->state == BufferState_s::HOST_OWNED));\n-\n-   if (openclBackend->openclConfig.showWhy){\n-       std::cout<<\n-                   \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n-                   << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n-                   << \" | arg.RO=\"<<(arg->value.buffer.access==RO_BYTE)\n-                   << \" | kernel.needsToRead=\"<<  kernelReadsFromThisArg\n-                   << \" | Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n-                   <<\" so \"\n-                     ;\n-     }\n-     return isAlwaysCopyingOrNewStateOrHostOwned;\n-}\n-bool OpenCLBackend::OpenCLBuffer::shouldCopyFromDevice(Arg_s *arg){\n-   OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n- bool kernelWroteToThisArg = (arg->value.buffer.access==WO_BYTE) |  (arg->value.buffer.access==RW_BYTE);\n-       if (openclBackend->openclConfig.showWhy){\n-           std::cout<<\n-             \"config.alwaysCopy=\"<<openclBackend->openclConfig.alwaysCopy\n-                << \" | arg.WO=\"<<(arg->value.buffer.access==WO_BYTE)\n-                << \" | arg.RW=\"<<(arg->value.buffer.access==RW_BYTE)\n-                << \" | kernel.wroteToThisArg=\"<<  kernelWroteToThisArg\n-                << \"Buffer state = \"<< BufferState_s::stateNames[bufferState->state]\n-                <<\" so \" ;\n-       }\n-       return openclBackend->openclConfig.alwaysCopy;\n-}\n-\n-\n-void OpenCLBackend::OpenCLBuffer::copyToDevice() {\n-  \/\/  OpenCLKernel *openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n-    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n-   \/\/  std::cout << \"copyTo(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n-\n-    cl_int status = clEnqueueWriteBuffer(\n-       openclBackend->openclQueue.command_queue,\n-       clMem,\n-       CL_FALSE,\n-       0,\n-       bufferState->length, \/\/ arg->value.buffer.sizeInBytes,\n-       arg->value.buffer.memorySegment,\n-       openclBackend->openclQueue.eventc,\n-       openclBackend->openclQueue.eventListPtr(),\n-       openclBackend->openclQueue.nextEventPtr()\n-    );\n-    openclBackend->openclQueue.markAsCopyToDeviceAndInc(arg->idx);\n-\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    if(openclBackend->openclConfig.traceCopies){\n-        std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyToDevice()\" << std::endl;\n-    }\n+    bufferState->vendorPtr =  static_cast<void *>(this);\n@@ -130,25 +46,0 @@\n-void OpenCLBackend::OpenCLBuffer::copyFromDevice() {\n-\/\/    OpenCLKernel * openclKernel = dynamic_cast<OpenCLKernel *>(kernel);\n-    OpenCLBackend * openclBackend = dynamic_cast<OpenCLBackend *>(backend);\n- \/\/  std::cout << \"copyFrom(\" <<std::hex << (long) arg->value.buffer.memorySegment << \",\" << std::dec<<   bufferState->length <<\")\"<<std::endl;\n-\n-    cl_int status = clEnqueueReadBuffer(\n-       openclBackend->openclQueue.command_queue,\n-       clMem,\n-       CL_FALSE,\n-       0,\n-       bufferState->length,\/\/arg->value.buffer.sizeInBytes,\n-       arg->value.buffer.memorySegment,\n-       openclBackend->openclQueue.eventc,\n-       openclBackend->openclQueue.eventListPtr(),\n-       openclBackend->openclQueue.nextEventPtr()\n-    );\n-    openclBackend->openclQueue.markAsCopyFromDeviceAndInc(arg->idx);\n-    if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-    }\n-    if(openclBackend->openclConfig.traceCopies){\n-       std::cout << \"enqueued buffer for arg idx \" << arg->idx << \" in OpenCLBuffer::copyFromDevice()\" << std::endl;\n-    }\n-}\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_buffer.cpp","additions":6,"deletions":115,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#define opencl_backend_config_cpp\n-#include \"opencl_backend.h\"\n-\n-OpenCLBackend::OpenCLConfig::OpenCLConfig(int configBits): Backend::Config(configBits){\n-\n- }\n- OpenCLBackend::OpenCLConfig::~OpenCLConfig(){\n- }\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_config.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -69,117 +69,3 @@\n-\n-long OpenCLBackend::OpenCLProgram::OpenCLKernel::ndrange(void *argArray) {\n-\n-   \/\/ std::cout << \"ndrange(\" << range << \") \" << std::endl;\n-    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n-    OpenCLBackend *openclBackend = dynamic_cast<OpenCLBackend*>(compilationUnit->backend);\n-  \/\/\n-    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits,\n-     (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name);\n-    if (openclBackend->openclConfig.traceCalls){\n-       std::cout << \"ndrange(\\\"\" <<  (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<< \"\\\"){\"<<std::endl;\n-        std::cout << \"Kernel name '\"<< (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"<<std::endl;\n-    }\n-    if (openclBackend->openclConfig.trace){\n-       Sled::show(std::cout, argArray);\n-    }\n-    NDRange *ndrange = nullptr;\n-    for (int i = 0; i < argSled.argc(); i++) {\n-        Arg_s *arg = argSled.arg(i);\n-        switch (arg->variant) {\n-            case '&': {\n-               if (arg->idx == 0){\n-                   ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n-               }\n-               if (openclBackend->openclConfig.trace){\n-                  std::cout << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access);\n-                  switch (arg->value.buffer.access){\n-                      case RO_BYTE: std::cout << \" RO\";break;\n-                      case WO_BYTE: std::cout << \" WO\";break;\n-                      case RW_BYTE: std::cout << \" RW\"; break;\n-                  }\n-                  std::cout << std::endl;\n-               }\n-\n-               BufferState_s * bufferState = BufferState_s::of(arg);\n-               if (bufferState->ptr != arg->value.buffer.memorySegment){\n-                   std::cerr <<\"bufferState->ptr !=  arg->value.buffer.memorySegment\"<<std::endl;\n-                   std::exit(1);\n-               }\n-\n-               if ((bufferState->vendorPtr == 0L) && (bufferState->state != BufferState_s::NEW_STATE)){\n-                   std::cerr << \"Warning:  Unexpected initial state for arg \"<< i\n-                      <<\" of kernel '\"<<(dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"\n-                      << \" state=\" << bufferState->state<< \" '\"\n-                      << BufferState_s::stateNames[bufferState->state]<< \"'\"\n-                      << \" vendorPtr\" << bufferState->vendorPtr<<std::endl;\n-               }\n-               OpenCLBuffer * openclBuffer =nullptr;\n-\n-               if (bufferState->vendorPtr == 0L || bufferState->state == BufferState_s::NEW_STATE){\n-                  openclBuffer = new OpenCLBuffer(openclBackend, arg, bufferState);\n-                 if (openclBackend->openclConfig.trace){\n-                     std::cout << \"We allocated arg \"<<i<<\" buffer \"<<std::endl;\n-                  }\n-               }else{\n-                  if (openclBackend->openclConfig.trace){\n-                      std::cout << \"Were reusing  arg \"<<i<<\" buffer \"<<std::endl;\n-                  }\n-                  openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n-                }\n-                if (openclBuffer->shouldCopyToDevice(arg)){\n-                   openclBuffer->copyToDevice();\n-                }else if (openclBackend->openclConfig.traceSkippedCopies){\n-                    std::cout << \"NOT copying arg \" << arg->idx <<\" to device \"<< std::endl;\n-                }\n-\n-                cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openclBuffer->clMem);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (openclBackend->openclConfig.trace){\n-                   std::cout << \"set buffer arg \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-             case 'B':\n-             case 'S':\n-             case 'C':\n-             case 'I':\n-             case 'F':\n-             case 'J':\n-             case 'D':\n-             {\n-                cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n-                if (status != CL_SUCCESS) {\n-                    std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-                    exit(1);\n-                }\n-                if (openclBackend->openclConfig.trace){\n-                   std::cerr << \"set \" <<arg->variant << \" \" << arg->idx << std::endl;\n-                }\n-                break;\n-            }\n-            default: {\n-                std::cerr << \"unexpected variant setting args in OpenCLkernel::ndrange \" << (char) arg->variant << std::endl;\n-                exit(1);\n-            }\n-        }\n-    }\n-\n-    size_t globalSize = ndrange->maxX;\n-    if (openclBackend->openclConfig.trace){\n-       std::cout << \"ndrange = \" << ndrange->maxX << std::endl;\n-    }\n-    size_t dims = 1;\n-    cl_int status = clEnqueueNDRangeKernel(\n-            openclBackend->openclQueue.command_queue,\n-            kernel,\n-            dims,\n-            nullptr,\n-            &globalSize,\n-            nullptr,\n-            openclBackend->openclQueue.eventc,\n-            openclBackend->openclQueue.eventListPtr(),\n-            openclBackend->openclQueue.nextEventPtr());\n-    openclBackend->openclQueue.markAsNDRangeAndInc();\n+bool OpenCLBackend::OpenCLProgram::OpenCLKernel::setArg(KernelArg *arg, Buffer *buffer){\n+    auto * openCLBuffer = dynamic_cast<OpenCLBuffer *>(buffer);\n+    cl_int status = clSetKernelArg(kernel, arg->idx, sizeof(cl_mem), &openCLBuffer->clMem);\n@@ -188,1 +74,1 @@\n-        exit(1);\n+        return false;\n@@ -190,38 +76,1 @@\n-    if (openclBackend->openclConfig.trace | openclBackend->openclConfig.traceEnqueues){\n-       std::cout << \"enqueued kernel dispatch \\\"\" << (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name <<\n-       \"\\\" globalSize=\" << globalSize << std::endl;\n-    }\n-\n-\n-       for (int i = 0; i < argSled.argc(); i++) { \/\/ note i = 1... we don't need to copy back the KernelContext\n-          Arg_s *arg = argSled.arg(i);\n-          if (arg->variant == '&') {\n-             BufferState_s * bufferState = BufferState_s::of(arg );\n-             OpenCLBuffer *openclBuffer = static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n-             if (openclBuffer->shouldCopyFromDevice(arg)){\n-                openclBuffer->copyFromDevice();\n-                if (openclBackend->openclConfig.traceCopies||openclBackend->openclConfig.traceEnqueues){\n-                   std::cout << \"copying arg \" << arg->idx <<\" from device \"<< std::endl;\n-                }\n-                  bufferState->state = BufferState_s::DEVICE_OWNED;\n-             \/\/   bufferState->state = BufferState_s::HOST_OWNED;\n-             }else{\n-                 if (openclBackend->openclConfig.traceSkippedCopies){\n-                      std::cout << \"NOT copying arg \" << arg->idx <<\" from device \"<< std::endl;\n-                 }\n-                 bufferState->state = BufferState_s::DEVICE_OWNED;\n-             }\n-          }\n-       }\n-\n-\n-\n-      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits,\n-           (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name\n-      );\n-      openclBackend->openclQueue.wait();\n-      openclBackend->openclQueue.release();\n-       if (openclBackend->openclConfig.traceCalls){\n-                  std::cout << \"\\\"\" <<  (dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<< \"\\\"}\"<<std::endl;\n-       }\n-    return 0;\n+    return true;\n@@ -229,0 +78,8 @@\n+bool OpenCLBackend::OpenCLProgram::OpenCLKernel::setArg(KernelArg *arg) {\n+    cl_int status = clSetKernelArg(kernel, arg->idx, arg->size(), (void *) &arg->value);\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        return false;\n+    }\n+    return true;\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_kernel.cpp","additions":13,"deletions":156,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -52,4 +52,0 @@\n-bool OpenCLBackend::OpenCLProgram::compilationUnitOK() {\n-    return true;\n-}\n-\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_program.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n-    : Backend::Queue(backend),\n-     events(new cl_event[eventMax]){\n+    : Backend::ProfilableQueue(backend, 10000),\n+      command_queue(),\n+      events(new cl_event[eventMax]){\n@@ -155,3 +156,3 @@\n- void clCallback(void *){\n-      std::cerr<<\"start of compute\"<<std::endl;\n- }\n+\/\/ void clCallback(void *){\n+  \/\/    std::cerr<<\"start of compute\"<<std::endl;\n+\/\/ }\n@@ -160,4 +161,6 @@\n-  cl_int status = clEnqueueMarkerWithWaitList(\n-      command_queue,\n-      this->eventc, this->eventListPtr(),this->nextEventPtr()\n-      );\n+      cl_int status = clEnqueueMarkerWithWaitList(\n+          command_queue,\n+          this->eventc,\n+          this->eventListPtr(),\n+          this->nextEventPtr()\n+          );\n@@ -181,11 +184,1 @@\n-      void OpenCLBackend::OpenCLQueue::marker(int bits, int arg){\n-        cl_int status = clEnqueueMarkerWithWaitList(\n-            command_queue,\n-            this->eventc, this->eventListPtr(),this->nextEventPtr()\n-            );\n-              if (status != CL_SUCCESS){\n-                   std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n-                   std::exit(1);\n-               }\n-            inc(bits, arg);\n-        }\n+\n@@ -199,2 +192,0 @@\n-\n-\n@@ -222,8 +213,1 @@\n-  void OpenCLBackend::OpenCLQueue::inc(int bits, int arg){\n-      if (eventc+1 >= eventMax){\n-         std::cerr << \"OpenCLBackend::OpenCLQueue event list overflowed!!\" << std::endl;\n-      }else{\n-          eventInfoBits[eventc]=bits|arg|hasIntArgBits;\n-      }\n-      eventc++;\n-   }\n+\n@@ -237,9 +221,1 @@\n- void OpenCLBackend::OpenCLQueue::markAsNDRangeAndInc(){\n-     inc(NDRangeBits);\n- }\n- void OpenCLBackend::OpenCLQueue::markAsCopyToDeviceAndInc(int argn){\n-     inc(CopyToDeviceBits, argn);\n- }\n- void OpenCLBackend::OpenCLQueue::markAsCopyFromDeviceAndInc(int argn){\n-     inc(CopyFromDeviceBits, argn);\n- }\n+\n@@ -268,0 +244,1 @@\n+ }\n@@ -269,1 +246,68 @@\n- }\n\\ No newline at end of file\n+void OpenCLBackend::OpenCLQueue::dispatch(KernelContext *kernelContext, Backend::CompilationUnit::Kernel *kernel){\n+    size_t dims = 1;\n+    cl_int status = clEnqueueNDRangeKernel(\n+            command_queue,\n+            dynamic_cast<OpenCLProgram::OpenCLKernel*>(kernel)->kernel,\n+            dims,\n+            nullptr,\n+            reinterpret_cast<const size_t *>(&kernelContext->maxX),\n+            nullptr,\n+            eventc,\n+            eventListPtr(),\n+            nextEventPtr());\n+    inc(NDRangeBits);\n+   \/\/ markAsNDRangeAndInc();\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    if (backend->config->trace | backend->config->traceEnqueues){\n+        std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->maxX << std::endl;\n+    }\n+\n+}\n+\n+\n+void OpenCLBackend::OpenCLQueue::copyToDevice(Backend::Buffer *buffer) {\n+\n+    auto openclBuffer = dynamic_cast<OpenCLBuffer *>(buffer);\n+    cl_int status = clEnqueueWriteBuffer(\n+            command_queue,\n+            openclBuffer->clMem,\n+            CL_FALSE,\n+            0,\n+            buffer->bufferState->length,\n+            buffer->bufferState->ptr,\n+            eventc,\n+            eventListPtr(),\n+            nextEventPtr()\n+    );\n+\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    inc(CopyToDeviceBits);\n+  \/\/  markAsCopyToDeviceAndInc();\n+}\n+\n+void  OpenCLBackend::OpenCLQueue::copyFromDevice(Backend::Buffer *buffer) {\n+    auto openclBuffer = dynamic_cast<OpenCLBuffer *>(buffer);\n+    cl_int status = clEnqueueReadBuffer(\n+            command_queue,\n+            openclBuffer->clMem,\n+            CL_FALSE,\n+            0,\n+            buffer->bufferState->length,\n+            buffer->bufferState->ptr,\n+            eventc,\n+            eventListPtr(),\n+            nextEventPtr()\n+    );\n+    if (status != CL_SUCCESS) {\n+        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+        exit(1);\n+    }\n+    inc(CopyFromDeviceBits);\n+    \/\/markAsCopyFromDeviceAndInc();\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_queue.cpp","additions":84,"deletions":40,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-class KernelContext {\n+class KernelContextWithBufferState {\n@@ -31,1 +31,1 @@\n-    BufferState_s bufferState;\n+    BufferState bufferState;\n@@ -36,1 +36,1 @@\n-    Arg_s argv[2];\n+    KernelArg argv[2];\n@@ -40,1 +40,1 @@\n-struct S32Array1024_s {\n+struct S32Array1024WithBufferState {\n@@ -43,1 +43,1 @@\n-    BufferState_s bufferState;\n+    BufferState bufferState;\n@@ -47,3 +47,3 @@\n-            | OpenCLBackend::OpenCLConfig::Config::INFO_BIT\n-            | OpenCLBackend::OpenCLConfig::Config::TRACE_CALLS_BIT\n-            | OpenCLBackend::OpenCLConfig::Config::TRACE_COPIES_BIT\n+            | Backend::Config::INFO_BIT\n+            | Backend::Config::Config::TRACE_CALLS_BIT\n+            | Backend::Config::Config::TRACE_COPIES_BIT\n@@ -108,3 +108,3 @@\n-    auto *kernelContext = bufferOf<KernelContext>(\"kernelContext\");\n-    kernelContext->x=0;\n-    kernelContext->maxX=maxX;\n+    auto *kernelContextWithBufferState = bufferOf<KernelContextWithBufferState>(\"kernelContext\");\n+    kernelContextWithBufferState->x=0;\n+    kernelContextWithBufferState->maxX=maxX;\n@@ -112,1 +112,1 @@\n-    auto *s32Array1024 = bufferOf<S32Array1024_s>(\"s32Arrayx1024\");\n+    auto *s32Array1024WithBufferState = bufferOf<S32Array1024WithBufferState>(\"s32ArrayX1024\");\n@@ -114,1 +114,1 @@\n-    s32Array1024->length=maxX;\n+    s32Array1024WithBufferState->length=maxX;\n@@ -116,2 +116,2 @@\n-    for (int i=0; i<s32Array1024->length; i++){\n-        s32Array1024->array[i]=i;\n+    for (int i=0; i < s32Array1024WithBufferState->length; i++){\n+        s32Array1024WithBufferState->array[i]=i;\n@@ -121,2 +121,2 @@\n-            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) kernelContext, .sizeInBytes = sizeof(KernelContext), .access = RO_BYTE}}},\n-            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) s32Array1024, .sizeInBytes = sizeof(S32Array1024_s), .access = RW_BYTE}}}\n+            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) kernelContextWithBufferState, .sizeInBytes = sizeof(KernelContextWithBufferState), .access = RO_BYTE}}},\n+            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) s32Array1024WithBufferState, .sizeInBytes = sizeof(S32Array1024WithBufferState), .access = RW_BYTE}}}\n@@ -126,2 +126,2 @@\n-    for (int i=0; i<s32Array1024->length; i++){\n-        std::cout << i << \" array[\"<<i<<\"]=\"<<s32Array1024->array[i] <<std::endl;\n+    for (int i=0; i < s32Array1024WithBufferState->length; i++){\n+        std::cout << i << \" array[\" << i << \"]=\" << s32Array1024WithBufferState->array[i] << std::endl;\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/squares.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+\/\/ The following looks like it is not used (at least to CLION) but it is. ;) don't remove\n@@ -27,1 +28,0 @@\n-\n@@ -37,1 +37,0 @@\n-\n@@ -40,2 +39,0 @@\n-\n-\n@@ -57,6 +54,1 @@\n-    class OpenCLConfig : public Backend::Config{\n-    public:\n-        OpenCLConfig(int mode);\n-        virtual ~OpenCLConfig();\n-    };\n-    class OpenCLQueue : public Backend::Queue {\n+    class OpenCLBuffer : public Backend::Buffer {\n@@ -64,26 +56,3 @@\n-       cl_command_queue command_queue;\n-       cl_event *events;\n-       OpenCLQueue(Backend *backend);\n-       cl_event *eventListPtr();\n-       cl_event *nextEventPtr();\n-\n-        virtual void showEvents(int width);\n-        virtual void wait();\n-        virtual void release();\n-        virtual void computeStart();\n-        virtual void computeEnd();\n-        virtual void inc(int bits);\n-        virtual void inc(int bits, const char *arg);\n-        virtual  void inc(int bits, int arg);\n-        virtual void marker(int bits);\n-        virtual void marker(int bits, const char *arg);\n-        virtual void marker(int bits, int arg);\n-        virtual void markAsCopyToDeviceAndInc(int argn);\n-        virtual  void markAsCopyFromDeviceAndInc(int argn);\n-        virtual void markAsNDRangeAndInc();\n-        virtual void markAsStartComputeAndInc();\n-        virtual  void markAsEndComputeAndInc();\n-        virtual  void markAsEnterKernelDispatchAndInc();\n-        virtual void markAsLeaveKernelDispatchAndInc();\n-\n-       virtual ~OpenCLQueue();\n+        cl_mem clMem;\n+        OpenCLBuffer(Backend *backend, BufferState *bufferState);\n+        virtual ~OpenCLBuffer();\n@@ -91,10 +60,1 @@\n-    class OpenCLBuffer : public Backend::Buffer {\n-            public:\n-                cl_mem clMem;\n-                void copyToDevice();\n-                void copyFromDevice();\n-                bool shouldCopyToDevice(Arg_s *arg);\n-                bool shouldCopyFromDevice(Arg_s *arg);\n-                OpenCLBuffer(Backend *backend, Arg_s *arg, BufferState_s *bufferState);\n-                virtual ~OpenCLBuffer();\n-            };\n+\n@@ -105,1 +65,0 @@\n-           \/\/ const char *name;\n@@ -108,2 +67,3 @@\n-            ~OpenCLKernel();\n-            long ndrange( void *argArray);\n+            bool setArg(KernelArg *arg) override;\n+            bool setArg(KernelArg *arg, Buffer *buffer) override;\n+            ~OpenCLKernel() override;\n@@ -115,1 +75,1 @@\n-        ~OpenCLProgram();\n+        ~OpenCLProgram() override;\n@@ -119,1 +79,0 @@\n-        bool compilationUnitOK();\n@@ -121,1 +80,31 @@\n-\n+    class OpenCLQueue : public Backend::ProfilableQueue {\n+    public:\n+        cl_command_queue command_queue;\n+        cl_event *events;\n+\n+        cl_event *eventListPtr();\n+        cl_event *nextEventPtr();\n+\n+        explicit OpenCLQueue(Backend *backend);\n+\n+         void wait() override;\n+         void release() override;\n+         void computeStart() override;\n+         void computeEnd() override;\n+         void showEvents(int width) override;\n+         void inc(int bits) override;\n+         void inc(int bits, const char *arg) override;\n+         void marker(int bits) override;\n+         void marker(int bits, const char *arg) override;\n+         void markAsStartComputeAndInc() override;\n+         void markAsEndComputeAndInc() override;\n+         void markAsEnterKernelDispatchAndInc() override;\n+         void markAsLeaveKernelDispatchAndInc() override;\n+\n+         void copyToDevice(Buffer *buffer) override;\n+         void copyFromDevice(Buffer *buffer) override;\n+\n+\n+        void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override;\n+         ~OpenCLQueue() override;\n+    };\n@@ -126,6 +115,2 @@\n-    OpenCLConfig openclConfig;\n-    OpenCLQueue openclQueue;\n-    OpenCLBackend(int configBits);\n-    ~OpenCLBackend();\n-    \/\/int getMaxComputeUnits() override;\n-\n+    explicit OpenCLBackend(int configBits);\n+    ~OpenCLBackend() override;\n@@ -133,2 +118,1 @@\n-   \/\/ void dumpSled(std::ostream &out,void *argArray) override;\n-   \/\/ char *dumpSchema(std::ostream &out,int depth, char *ptr, void *data) override;\n+    OpenCLBuffer *getOrCreateBuffer(BufferState *bufferState) override;\n@@ -148,1 +132,0 @@\n-extern \"C\" long getOpenCLBackend(int configBits);\n@@ -170,1 +153,1 @@\n-      DeviceInfo(OpenCLBackend *openclBackend);\n+      explicit DeviceInfo(OpenCLBackend *openclBackend);\n@@ -179,1 +162,1 @@\n-  PlatformInfo(OpenCLBackend *openclBackend);\n+  explicit PlatformInfo(OpenCLBackend *openclBackend);\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":46,"deletions":63,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+\n@@ -52,1 +53,1 @@\n-        Arg_s *arg = argSled.arg(i);\n+        KernelArg *arg = argSled.arg(i);\n@@ -102,1 +103,0 @@\n-\n@@ -104,2 +104,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through backendHandle to backend.info()\" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through backendHandle to backend.info()\" << std::endl;\n@@ -107,1 +107,1 @@\n-    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    auto *backend = reinterpret_cast<Backend *>(backendHandle);\n@@ -111,2 +111,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through backendHandle to backend.computeStart()\" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through backendHandle to backend.computeStart()\" << std::endl;\n@@ -114,1 +114,1 @@\n-    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    auto *backend = reinterpret_cast<Backend *>(backendHandle);\n@@ -118,2 +118,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through backendHandle to backend.computeEnd()\" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through backendHandle to backend.computeEnd()\" << std::endl;\n@@ -121,1 +121,1 @@\n-    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    auto *backend = reinterpret_cast<Backend *>(backendHandle);\n@@ -125,1 +125,1 @@\n-    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    auto *backend = reinterpret_cast<Backend *>(backendHandle);\n@@ -129,3 +129,3 @@\n-    if (INFO){\n-       std::cout << \"trampolining through backendHandle to backend.compile() \"\n-           <<std::hex<<backendHandle<< std::dec <<std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through backendHandle to backend.compile() \"\n+                  << std::hex << backendHandle << std::dec << std::endl;\n@@ -133,1 +133,1 @@\n-    auto *backend = reinterpret_cast<Backend*>(backendHandle);\n+    auto *backend = reinterpret_cast<Backend *>(backendHandle);\n@@ -135,2 +135,2 @@\n-    if (INFO){\n-       std::cout << \"compilationUnitHandle = \"<<std::hex<<compilationUnitHandle<< std::dec <<std::endl;\n+    if (INFO) {\n+        std::cout << \"compilationUnitHandle = \" << std::hex << compilationUnitHandle << std::dec << std::endl;\n@@ -141,1 +141,1 @@\n-    if (INFO){\n+    if (INFO) {\n@@ -143,1 +143,1 @@\n-            <<std::hex<<compilationUnitHandle<< std::dec <<std::endl;\n+                  << std::hex << compilationUnitHandle << std::dec << std::endl;\n@@ -150,2 +150,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through kernelHandle to kernel.ndrange(...) \" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through kernelHandle to kernel.ndrange(...) \" << std::endl;\n@@ -154,1 +154,1 @@\n-    kernel->ndrange( argArray);\n+    kernel->ndrange(argArray);\n@@ -158,2 +158,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through to releaseKernel \" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through to releaseKernel \" << std::endl;\n@@ -166,2 +166,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through to releaseCompilationUnit \" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through to releaseCompilationUnit \" << std::endl;\n@@ -173,2 +173,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through to compilationUnitHandleOK \" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through to compilationUnitHandleOK \" << std::endl;\n@@ -181,2 +181,2 @@\n-    if (INFO){\n-       std::cout << \"trampolining through to getBuffer \" << std::endl;\n+    if (INFO) {\n+        std::cout << \"trampolining through to getBuffer \" << std::endl;\n@@ -190,2 +190,2 @@\n-\n-Backend::Config::Config(int configBits):\n+Backend::Config::Config(int configBits)\n+        :\n@@ -193,1 +193,1 @@\n-        minimizeCopies((configBits&MINIMIZE_COPIES_BIT)==MINIMIZE_COPIES_BIT),\n+        minimizeCopies((configBits & MINIMIZE_COPIES_BIT) == MINIMIZE_COPIES_BIT),\n@@ -195,30 +195,30 @@\n-        trace((configBits&TRACE_BIT)==TRACE_BIT),\n-        traceCopies((configBits&TRACE_COPIES_BIT)==TRACE_COPIES_BIT),\n-        traceEnqueues((configBits&TRACE_ENQUEUES_BIT)==TRACE_ENQUEUES_BIT),\n-        traceCalls((configBits&TRACE_CALLS_BIT)==TRACE_CALLS_BIT),\n-        traceSkippedCopies((configBits&TRACE_SKIPPED_COPIES_BIT)==TRACE_SKIPPED_COPIES_BIT),\n-        info((configBits&INFO_BIT)==INFO_BIT),\n-        showCode((configBits&SHOW_CODE_BIT)==SHOW_CODE_BIT),\n-        profile((configBits&PROFILE_BIT)==PROFILE_BIT),\n-        showWhy((configBits&SHOW_WHY_BIT)==SHOW_WHY_BIT),\n-        showState((configBits&SHOW_STATE_BIT)==SHOW_STATE_BIT),\n-        ptx((configBits&PTX_BIT)==PTX_BIT),\n-\n-        platform((configBits&0xf)),\n-        device((configBits&0xf0)>>4){\n-    if (info){\n-        std::cout << \"native showCode \" << showCode <<std::endl;\n-        std::cout << \"native info \" << info<<std::endl;\n-        std::cout << \"native minimizeCopies \" << minimizeCopies<<std::endl;\n-        std::cout << \"native alwaysCopy \" << alwaysCopy<<std::endl;\n-        std::cout << \"native trace \" << trace<<std::endl;\n-        std::cout << \"native traceSkippedCopies \" << traceSkippedCopies<<std::endl;\n-        std::cout << \"native traceCalls \" << traceCalls<<std::endl;\n-        std::cout << \"native traceCopies \" << traceCopies<<std::endl;\n-        std::cout << \"native traceEnqueues \" << traceEnqueues<<std::endl;\n-        std::cout << \"native profile \" << profile<<std::endl;\n-        std::cout << \"native showWhy \" << showWhy<<std::endl;\n-        std::cout << \"native showState \" << showState<<std::endl;\n-        std::cout << \"native ptx \" << ptx<<std::endl;\n-        std::cout << \"native platform \" << platform<<std::endl;\n-        std::cout << \"native device \" << device<<std::endl;\n+        trace((configBits & TRACE_BIT) == TRACE_BIT),\n+        traceCopies((configBits & TRACE_COPIES_BIT) == TRACE_COPIES_BIT),\n+        traceEnqueues((configBits & TRACE_ENQUEUES_BIT) == TRACE_ENQUEUES_BIT),\n+        traceCalls((configBits & TRACE_CALLS_BIT) == TRACE_CALLS_BIT),\n+        traceSkippedCopies((configBits & TRACE_SKIPPED_COPIES_BIT) == TRACE_SKIPPED_COPIES_BIT),\n+        info((configBits & INFO_BIT) == INFO_BIT),\n+        showCode((configBits & SHOW_CODE_BIT) == SHOW_CODE_BIT),\n+        profile((configBits & PROFILE_BIT) == PROFILE_BIT),\n+        showWhy((configBits & SHOW_WHY_BIT) == SHOW_WHY_BIT),\n+        showState((configBits & SHOW_STATE_BIT) == SHOW_STATE_BIT),\n+        ptx((configBits & PTX_BIT) == PTX_BIT),\n+\n+        platform((configBits & 0xf)),\n+        device((configBits & 0xf0) >> 4) {\n+    if (info) {\n+        std::cout << \"native showCode \" << showCode << std::endl;\n+        std::cout << \"native info \" << info << std::endl;\n+        std::cout << \"native minimizeCopies \" << minimizeCopies << std::endl;\n+        std::cout << \"native alwaysCopy \" << alwaysCopy << std::endl;\n+        std::cout << \"native trace \" << trace << std::endl;\n+        std::cout << \"native traceSkippedCopies \" << traceSkippedCopies << std::endl;\n+        std::cout << \"native traceCalls \" << traceCalls << std::endl;\n+        std::cout << \"native traceCopies \" << traceCopies << std::endl;\n+        std::cout << \"native traceEnqueues \" << traceEnqueues << std::endl;\n+        std::cout << \"native profile \" << profile << std::endl;\n+        std::cout << \"native showWhy \" << showWhy << std::endl;\n+        std::cout << \"native showState \" << showState << std::endl;\n+        std::cout << \"native ptx \" << ptx << std::endl;\n+        std::cout << \"native platform \" << platform << std::endl;\n+        std::cout << \"native device \" << device << std::endl;\n@@ -227,1 +227,2 @@\n-Backend::Config::~Config(){\n+\n+Backend::Config::~Config() {\n@@ -231,5 +232,1 @@\n-        :backend(backend),\n-         eventMax(10000),\n-         eventInfoBits(new int[eventMax]),\n-         eventInfoConstCharPtrArgs(new const char *[eventMax]),\n-         eventc(0){\n+        : backend(backend) {\n@@ -237,0 +234,1 @@\n+\n@@ -238,2 +236,1 @@\n-    delete[]eventInfoBits;\n-    delete[]eventInfoConstCharPtrArgs;\n+\n@@ -241,0 +238,1 @@\n+\n@@ -243,1 +241,1 @@\n-   \/\/ std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n+    \/\/ std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n@@ -245,0 +243,1 @@\n+\n@@ -247,1 +246,1 @@\n-   \/\/ std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n+    \/\/ std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n@@ -249,0 +248,1 @@\n+\n@@ -251,1 +251,1 @@\n-  \/\/  std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n+    \/\/  std::cout << \"in Text len=\"<<len<<\" isCopy=\"<<isCopy << std::endl;\n@@ -253,1 +253,2 @@\n-void Text::write(std::string &filename) const{\n+\n+void Text::write(std::string &filename) const {\n@@ -259,2 +260,3 @@\n-void Text::read(std::string &filename){\n-    if (isCopy && text){\n+\n+void Text::read(std::string &filename) {\n+    if (isCopy && text) {\n@@ -264,1 +266,1 @@\n-    isCopy=false;\n+    isCopy = false;\n@@ -287,2 +289,2 @@\n-Text::~Text(){\n-    if (isCopy && text){\n+Text::~Text() {\n+    if (isCopy && text) {\n@@ -299,0 +301,1 @@\n+\n@@ -301,1 +304,154 @@\n-}\n\\ No newline at end of file\n+}\n+\n+long Backend::CompilationUnit::Kernel::ndrange(void *argArray) {\n+    if (compilationUnit->backend->config->traceCalls) {\n+        std::cout << \"kernelContext(\\\"\" << name << \"\\\"){\" << std::endl;\n+    }\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n+    auto *profilableQueue = dynamic_cast<ProfilableQueue *>(compilationUnit->backend->queue);\n+    if (profilableQueue != nullptr) {\n+        profilableQueue->marker(Backend::ProfilableQueue::EnterKernelDispatchBits, name);\n+    }\n+    if (compilationUnit->backend->config->trace) {\n+        Sled::show(std::cout, argArray);\n+    }\n+    KernelContext *kernelContext = nullptr;\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        KernelArg *arg = argSled.arg(i);\n+        switch (arg->variant) {\n+            case '&': {\n+                if (arg->idx == 0) {\n+                    kernelContext = static_cast<KernelContext *>(arg->value.buffer.memorySegment);\n+                }\n+                if (compilationUnit->backend->config->trace) {\n+                    std::cout << \"arg[\" << i << \"] = \" << std::hex << (int) (arg->value.buffer.access);\n+                    switch (arg->value.buffer.access) {\n+                        case RO_BYTE:\n+                            std::cout << \" RO\";\n+                            break;\n+                        case WO_BYTE:\n+                            std::cout << \" WO\";\n+                            break;\n+                        case RW_BYTE:\n+                            std::cout << \" RW\";\n+                            break;\n+                    }\n+                    std::cout << std::endl;\n+                }\n+\n+                BufferState *bufferState = BufferState::of(arg);\n+\n+                Buffer *buffer = compilationUnit->backend->getOrCreateBuffer(bufferState);\n+\n+                bool kernelReadsFromThisArg = (arg->value.buffer.access == RW_BYTE) || (arg->value.buffer.access == RO_BYTE);\n+                bool copyToDevice =\n+                        compilationUnit->backend->config->alwaysCopy\n+                        || (bufferState->state == BufferState::NEW_STATE)\n+                        || ((bufferState->state == BufferState::HOST_OWNED)\n+                        );\n+\n+                if (compilationUnit->backend->config->showWhy) {\n+                    std::cout <<\n+                              \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n+                              << \" | arg.RW=\" << (arg->value.buffer.access == RW_BYTE)\n+                              << \" | arg.RO=\" << (arg->value.buffer.access == RO_BYTE)\n+                              << \" | kernel.needsToRead=\" << kernelReadsFromThisArg\n+                              << \" | Buffer state = \" << BufferState::stateNames[bufferState->state]\n+                              << \" so \";\n+                }\n+                if (copyToDevice) {\n+                    compilationUnit->backend->queue->copyToDevice(buffer);\n+                   \/\/ buffer->copyToDevice();\n+                    if (compilationUnit->backend->config->traceCopies) {\n+                        std::cout << \"copying arg \" << arg->idx << \" to device \" << std::endl;\n+                    }\n+                } else {\n+                    if (compilationUnit->backend->config->traceSkippedCopies) {\n+                        std::cout << \"NOT copying arg \" << arg->idx << \" to device \" << std::endl;\n+                    }\n+                }\n+                setArg(arg, buffer);\n+                if (compilationUnit->backend->config->trace) {\n+                    std::cout << \"set buffer arg \" << arg->idx << std::endl;\n+                }\n+                break;\n+            }\n+            case 'B':\n+            case 'S':\n+            case 'C':\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D': {\n+                setArg(arg);\n+                if (compilationUnit->backend->config->trace) {\n+                    std::cerr << \"set \" << arg->variant << \" \" << arg->idx << std::endl;\n+                }\n+                break;\n+            }\n+            default: {\n+                std::cerr << \"unexpected variant setting args in OpenCLkernel::kernelContext \" << (char) arg->variant << std::endl;\n+                exit(1);\n+            }\n+        }\n+    }\n+\n+    if (kernelContext == nullptr){\n+        std::cerr << \"Looks like we recieved a kernel dispatch with xero args kernel='\"<<name<<\"'\" << std::endl;\n+        exit(1);\n+    }\n+\n+    if (compilationUnit->backend->config->trace) {\n+        std::cout << \"kernelContext = \" << kernelContext->maxX << std::endl;\n+    }\n+\n+    \/\/ We 'double dispatch' back to the kernel to actually do the dispatch\n+\n+    compilationUnit->backend->queue->dispatch(kernelContext, this);\n+\n+\n+    for (int i = 0; i < argSled.argc(); i++) { \/\/ note i = 1... we never need to copy back the KernelContext\n+        KernelArg *arg = argSled.arg(i);\n+        if (arg->variant == '&') {\n+            BufferState *bufferState = BufferState::of(arg);\n+\n+            bool kernelWroteToThisArg = (arg->value.buffer.access == WO_BYTE) | (arg->value.buffer.access == RW_BYTE);\n+            if (compilationUnit->backend->config->showWhy) {\n+                std::cout <<\n+                          \"config.alwaysCopy=\" << compilationUnit->backend->config->alwaysCopy\n+                          << \" | arg.WO=\" << (arg->value.buffer.access == WO_BYTE)\n+                          << \" | arg.RW=\" << (arg->value.buffer.access == RW_BYTE)\n+                          << \" | kernel.wroteToThisArg=\" << kernelWroteToThisArg\n+                          << \"Buffer state = \" << BufferState::stateNames[bufferState->state]\n+                          << \" so \";\n+            }\n+\n+            auto *buffer = static_cast<Buffer *>(bufferState->vendorPtr);\n+            if (compilationUnit->backend->config->alwaysCopy) {\n+                compilationUnit->backend->queue->copyFromDevice(buffer);\n+               \/\/ buffer->copyFromDevice();\n+                if (compilationUnit->backend->config->traceCopies || compilationUnit->backend->config->traceEnqueues) {\n+                    std::cout << \"copying arg \" << arg->idx << \" from device \" << std::endl;\n+                }\n+            } else {\n+                if (compilationUnit->backend->config->traceSkippedCopies) {\n+                    std::cout << \"NOT copying arg \" << arg->idx << \" from device \" << std::endl;\n+                }\n+                if (kernelWroteToThisArg) {\n+                    bufferState->state = BufferState::DEVICE_OWNED;\n+                }\n+            }\n+        }\n+    }\n+    if (profilableQueue != nullptr) {\n+        profilableQueue->marker(Backend::ProfilableQueue::LeaveKernelDispatchBits, name);\n+    }\n+    compilationUnit->backend->queue->wait();\n+    compilationUnit->backend->queue->release();\n+    if (compilationUnit->backend->config->traceCalls) {\n+        std::cout << \"\\\"\" << name << \"\\\"}\" << std::endl;\n+    }\n+    return 0;\n+}\n+\n+\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":238,"deletions":82,"binary":false,"changes":320,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-   #define SNPRINTF snprintf\n+#define SNPRINTF snprintf\n@@ -45,7 +45,7 @@\n-   #include <malloc.h>\n-   #if defined (_WIN32)\n-      #include \"windows.h\"\n-      #define SNPRINTF _snprintf\n-   #else\n-      #define SNPRINTF  snprintf\n-   #endif\n+#include <malloc.h>\n+#if defined (_WIN32)\n+#include \"windows.h\"\n+#define SNPRINTF _snprintf\n+#else\n+#define SNPRINTF  snprintf\n+#endif\n@@ -69,0 +69,1 @@\n+\n@@ -76,0 +77,1 @@\n+\n@@ -77,0 +79,1 @@\n+\n@@ -78,0 +81,1 @@\n+\n@@ -79,0 +83,1 @@\n+\n@@ -80,0 +85,1 @@\n+\n@@ -83,1 +89,1 @@\n-class Log:public Text  {\n+class Log : public Text {\n@@ -86,2 +92,4 @@\n-    Log(char* text);\n-    ~Log()  = default;\n+\n+    Log(char *text);\n+\n+    ~Log() = default;\n@@ -91,4 +99,4 @@\n- #define UNKNOWN_BYTE 0\n- #define RO_BYTE (1<<1)\n- #define WO_BYTE (1<<2)\n- #define RW_BYTE (RO_BYTE|WO_BYTE)\n+#define UNKNOWN_BYTE 0\n+#define RO_BYTE (1<<1)\n+#define WO_BYTE (1<<2)\n+#define RW_BYTE (RO_BYTE|WO_BYTE)\n@@ -96,1 +104,1 @@\n- struct Buffer_s {\n+struct Buffer_s {\n@@ -100,1 +108,1 @@\n-} ;\n+};\n@@ -102,1 +110,1 @@\n- union Value_u {\n+union Value_u {\n@@ -115,1 +123,1 @@\n-} ;\n+};\n@@ -117,1 +125,1 @@\n- struct Arg_s {\n+struct KernelArg {\n@@ -123,15 +131,27 @@\n-    size_t size(){\n-       size_t sz;\n-       switch(variant){\n-          case 'I': case'F':sz= sizeof(u32_t);break;\n-          case 'S': case 'C':sz= sizeof(u16_t);break;\n-          case 'D':case 'J':return sizeof(u64_t);break;\n-          case 'B':return sizeof (u8_t);break;\n-        default:\n-           std::cerr <<\"Bad variant \" <<variant << \"arg::size\" << std::endl;\n-           exit(1);\n-\n-      }\n-\n-      return sz;\n-      }\n+\n+    size_t size() {\n+        size_t sz;\n+        switch (variant) {\n+            case 'I':\n+            case 'F':\n+                sz = sizeof(u32_t);\n+                break;\n+            case 'S':\n+            case 'C':\n+                sz = sizeof(u16_t);\n+                break;\n+            case 'D':\n+            case 'J':\n+                return sizeof(u64_t);\n+                break;\n+            case 'B':\n+                return sizeof(u8_t);\n+                break;\n+            default:\n+                std::cerr << \"Bad variant \" << variant << \"arg::size\" << std::endl;\n+                exit(1);\n+\n+        }\n+\n+        return sz;\n+    }\n@@ -140,46 +160,69 @@\n- struct BufferState_s{\n-   static const long  MAGIC =0x4a71facebffab175;\n-   static const int NO_STATE = 0;\n-   static const int NEW_STATE = 1;\n-   static const int HOST_OWNED = 2;\n-   static const int DEVICE_OWNED = 3;\n-   static const int DEVICE_VALID_HOST_HAS_COPY = 4;\n-   const static  char *stateNames[]; \/\/ See below for out of line definition\n-\n-   long magic1;\n-   void *ptr;\n-   long length;\n-   int bits;\n-   int state;\n-   void *vendorPtr;\n-   long magic2;\n-   bool ok(){\n-      return ((magic1 == MAGIC) && (magic2 == MAGIC));\n-   }\n-   void setState(int newState) {\n-      state = newState;\n-   }\n-   int getState() {\n-      return state;\n-   }\n-\n-   void dump(const char *msg){\n-     if (ok()){\n-        printf(\"{%s,ptr:%016lx,length: %016lx,  state:%08x, vendorPtr:%016lx}\\n\", msg, (long)ptr, length,  state, (long)vendorPtr);\n-     }else{\n-        printf(\"%s bad magic \\n\", msg);\n-        printf(\"(magic1:%016lx,\", magic1);\n-        printf(\"{%s, ptr:%016lx, length: %016lx,  state:%08x, vendorPtr:%016lx}\", msg, (long)ptr, length,  state, (long)vendorPtr);\n-        printf(\"magic2:%016lx)\\n\", magic2);\n-     }\n-   }\n-   static BufferState_s* of(void *ptr, size_t sizeInBytes){\n-      return (BufferState_s*) (((char*)ptr)+sizeInBytes-sizeof(BufferState_s));\n-   }\n-\n-     static BufferState_s* of(Arg_s *arg){ \/\/ access?\n-        return BufferState_s::of(\n-           arg->value.buffer.memorySegment,\n-           arg->value.buffer.sizeInBytes\n-           );\n-      }\n+struct BufferState {\n+    static const long MAGIC = 0x4a71facebffab175;\n+    static const int NO_STATE = 0;\n+    static const int NEW_STATE = 1;\n+    static const int HOST_OWNED = 2;\n+    static const int DEVICE_OWNED = 3;\n+    static const int DEVICE_VALID_HOST_HAS_COPY = 4;\n+    const static char *stateNames[]; \/\/ See below for out of line definition\n+\n+    long magic1;\n+    void *ptr;\n+    long length;\n+    int bits;\n+    int state;\n+    void *vendorPtr;\n+    long magic2;\n+\n+    bool ok() {\n+        return ((magic1 == MAGIC) && (magic2 == MAGIC));\n+    }\n+\n+    void setState(int newState) {\n+        state = newState;\n+    }\n+\n+    int getState() {\n+        return state;\n+    }\n+\n+    void dump(const char *msg) {\n+        if (ok()) {\n+            printf(\"{%s,ptr:%016lx,length: %016lx,  state:%08x, vendorPtr:%016lx}\\n\", msg, (long) ptr, length, state, (long) vendorPtr);\n+        } else {\n+            printf(\"%s bad magic \\n\", msg);\n+            printf(\"(magic1:%016lx,\", magic1);\n+            printf(\"{%s, ptr:%016lx, length: %016lx,  state:%08x, vendorPtr:%016lx}\", msg, (long) ptr, length, state, (long) vendorPtr);\n+            printf(\"magic2:%016lx)\\n\", magic2);\n+        }\n+    }\n+\n+    static BufferState *of(void *ptr, size_t sizeInBytes) {\n+        return (BufferState *) (((char *) ptr) + sizeInBytes - sizeof(BufferState));\n+    }\n+\n+    static BufferState *of(KernelArg *arg) { \/\/ access?\n+        BufferState *bufferState = BufferState::of(\n+                arg->value.buffer.memorySegment,\n+                arg->value.buffer.sizeInBytes\n+        );\n+\n+\n+        \/\/Sanity check the buffers\n+        \/\/ These sanity check finds errors passing memory segments which are not Buffers\n+\n+        if (bufferState->ptr != arg->value.buffer.memorySegment) {\n+            std::cerr << \"bufferState->ptr !=  arg->value.buffer.memorySegment\" << std::endl;\n+            std::exit(1);\n+        }\n+\n+        if ((bufferState->vendorPtr == 0L) && (bufferState->state != BufferState::NEW_STATE)) {\n+            std::cerr << \"Warning:  Unexpected initial state for buffer \"\n+                      \/\/<<\" of kernel '\"<<(dynamic_cast<Backend::CompilationUnit::Kernel*>(this))->name<<\"'\"\n+                      << \" state=\" << bufferState->state << \" '\"\n+                      << BufferState::stateNames[bufferState->state] << \"'\"\n+                      << \" vendorPtr\" << bufferState->vendorPtr << std::endl;\n+        }\n+        \/\/ End of sanity checks\n+        return bufferState;\n+    }\n@@ -188,0 +231,1 @@\n+\n@@ -189,1 +233,1 @@\n-const  char *BufferState_s::stateNames[] = {\n+const  char *BufferState::stateNames[] = {\n@@ -201,1 +245,1 @@\n-    Arg_s argv[0\/*argc*\/];\n+    KernelArg argv[0\/*argc*\/];\n@@ -212,2 +256,2 @@\n-    Arg_s *arg(int n) {\n-        Arg_s *a = (argArray->argv + n);\n+    KernelArg *arg(int n) {\n+        KernelArg *a = (argArray->argv + n);\n@@ -218,1 +262,1 @@\n-        hexdump(arg(n), sizeof(Arg_s));\n+        hexdump(arg(n), sizeof(KernelArg));\n@@ -222,1 +266,1 @@\n-        Arg_s *a = arg(n);\n+        KernelArg *a = arg(n);\n@@ -262,1 +306,1 @@\n-        Arg_s *a = arg(argc());\n+        KernelArg *a = arg(argc());\n@@ -264,1 +308,1 @@\n-   }\n+    }\n@@ -303,2 +347,0 @@\n-\n-\n@@ -313,1 +355,1 @@\n-class NDRange {\n+class KernelContext {\n@@ -321,1 +363,1 @@\n-    class Config{\n+    class Config {\n@@ -326,18 +368,18 @@\n-        const static  int START_BIT_IDX = 16;\n-        const static  int MINIMIZE_COPIES_BIT =1<<START_BIT_IDX;\n-        const static  int TRACE_BIT =1<<17;\n-        const static  int PROFILE_BIT =1<<18;\n-        const static  int SHOW_CODE_BIT = 1 << 19;\n-        const static  int SHOW_KERNEL_MODEL_BIT = 1 << 20;\n-        const static  int SHOW_COMPUTE_MODEL_BIT = 1 <<21;\n-        const static  int INFO_BIT = 1<<22;\n-        const static  int TRACE_COPIES_BIT = 1 <<23;\n-        const static  int TRACE_SKIPPED_COPIES_BIT = 1 <<24;\n-        const static  int TRACE_ENQUEUES_BIT = 1 <<25;\n-        const static  int TRACE_CALLS_BIT = 1 <<26;\n-        const static  int SHOW_WHY_BIT = 1 <<27;\n-        const static  int SHOW_STATE_BIT = 1 <<28;\n-        const static  int PTX_BIT = 1 <<29;\n-        const static  int END_BIT_IDX = 30;\n-\n-        const static  char *bitNames[]; \/\/ See below for out of line definition\n+        const static int START_BIT_IDX = 16;\n+        const static int MINIMIZE_COPIES_BIT = 1 << START_BIT_IDX;\n+        const static int TRACE_BIT = 1 << 17;\n+        const static int PROFILE_BIT = 1 << 18;\n+        const static int SHOW_CODE_BIT = 1 << 19;\n+        const static int SHOW_KERNEL_MODEL_BIT = 1 << 20;\n+        const static int SHOW_COMPUTE_MODEL_BIT = 1 << 21;\n+        const static int INFO_BIT = 1 << 22;\n+        const static int TRACE_COPIES_BIT = 1 << 23;\n+        const static int TRACE_SKIPPED_COPIES_BIT = 1 << 24;\n+        const static int TRACE_ENQUEUES_BIT = 1 << 25;\n+        const static int TRACE_CALLS_BIT = 1 << 26;\n+        const static int SHOW_WHY_BIT = 1 << 27;\n+        const static int SHOW_STATE_BIT = 1 << 28;\n+        const static int PTX_BIT = 1 << 29;\n+        const static int END_BIT_IDX = 30;\n+\n+        const static char *bitNames[]; \/\/ See below for out of line definition\n@@ -361,0 +403,1 @@\n+\n@@ -363,16 +406,0 @@\n-    class Queue {\n-    public:\n-        const static  int START_BIT_IDX =20;\n-        static const int CopyToDeviceBits= 1<<START_BIT_IDX;\n-        static const int CopyFromDeviceBits= 1<<21;\n-        static const int NDRangeBits =1<<22;\n-        static const int StartComputeBits= 1<<23;\n-        static const int EndComputeBits= 1<<24;\n-        static const int EnterKernelDispatchBits= 1<<25;\n-        static const int LeaveKernelDispatchBits= 1<<26;\n-        static const int HasConstCharPtrArgBits = 1<<27;\n-        static const int hasIntArgBits = 1<<28;\n-        const static  int END_BIT_IDX = 27;\n-        Backend *backend;\n-        size_t eventMax;\n-        size_t eventc;\n@@ -380,23 +407,0 @@\n-        int *eventInfoBits;\n-        const char **eventInfoConstCharPtrArgs;\n-        Queue(Backend *openclBackend);\n-        virtual void showEvents(int width)=0;\n-        virtual void wait()=0;\n-        virtual void release()=0;\n-        virtual void computeStart()=0;\n-        virtual void computeEnd()=0;\n-        virtual void inc(int bits)=0;\n-        virtual void inc(int bits, const char *arg)=0;\n-        virtual  void inc(int bits, int arg)=0;\n-        virtual void marker(int bits)=0;\n-        virtual void marker(int bits, const char *arg)=0;\n-        virtual void marker(int bits, int arg)=0;\n-        virtual void markAsCopyToDeviceAndInc(int argn)=0;\n-        virtual  void markAsCopyFromDeviceAndInc(int argn)=0;\n-        virtual void markAsNDRangeAndInc()=0;\n-        virtual void markAsStartComputeAndInc()=0;\n-        virtual  void markAsEndComputeAndInc()=0;\n-        virtual  void markAsEnterKernelDispatchAndInc()=0;\n-        virtual void markAsLeaveKernelDispatchAndInc()=0;\n-         virtual ~Queue();\n-    };\n@@ -406,9 +410,3 @@\n-        Arg_s *arg;\n-        BufferState_s *bufferState;\n-\n-        virtual void copyToDevice() = 0;\n-\n-        virtual void copyFromDevice() = 0;\n-\n-        Buffer(Backend *backend, Arg_s *arg, BufferState_s *bufferState)\n-                : backend(backend), arg(arg), bufferState(bufferState) {\n+        BufferState *bufferState;\n+        Buffer(Backend *backend, BufferState *bufferState)\n+                : backend(backend), bufferState(bufferState) {\n@@ -416,2 +414,1 @@\n-\n-        virtual ~Buffer() {}\n+        virtual ~Buffer() = default;\n@@ -419,0 +416,1 @@\n+\n@@ -427,1 +425,5 @@\n-            virtual long ndrange(void *argArray) = 0;\n+            virtual bool setArg(KernelArg *arg, Buffer *openCLBuffer) = 0;\n+\n+            virtual bool setArg(KernelArg *arg) = 0;\n+\n+            virtual long ndrange(void *argArray) final;\n@@ -439,1 +441,2 @@\n-  public:\n+\n+    public:\n@@ -444,0 +447,1 @@\n+\n@@ -446,2 +450,2 @@\n-        bool compilationUnitOK(){\n-           return ok;\n+        virtual bool compilationUnitOK() final {\n+            return ok;\n@@ -451,1 +455,1 @@\n-                : backend(backend), src(src),log(log),ok(ok) {\n+                : backend(backend), src(src), log(log), ok(ok) {\n@@ -455,6 +459,6 @@\n-           if (src != nullptr) {\n-              delete[] src;\n-           }\n-           if (log != nullptr) {\n-              delete[] log;\n-           }\n+            if (src != nullptr) {\n+                delete[] src;\n+            }\n+            if (log != nullptr) {\n+                delete[] log;\n+            }\n@@ -463,1 +467,0 @@\n-    int mode;\n@@ -465,1 +468,82 @@\n-    Backend(int mode): mode(mode){}\n+    class Queue {\n+    public:\n+\n+        Backend *backend;\n+\n+        Queue(Backend *backend);\n+\n+        virtual void wait() = 0;\n+\n+        virtual void release() = 0;\n+\n+        virtual void computeStart() = 0;\n+\n+        virtual void computeEnd() = 0;\n+\n+        virtual void copyToDevice(Buffer *buffer)=0;\n+\n+        virtual void copyFromDevice(Buffer *buffer)=0;\n+\n+        virtual void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) = 0;\n+\n+        virtual ~Queue();\n+    };\n+\n+    class ProfilableQueue : public Queue {\n+    public:\n+        const static int START_BIT_IDX = 20;\n+        static const int CopyToDeviceBits = 1 << START_BIT_IDX;\n+        static const int CopyFromDeviceBits = 1 << 21;\n+        static const int NDRangeBits = 1 << 22;\n+        static const int StartComputeBits = 1 << 23;\n+        static const int EndComputeBits = 1 << 24;\n+        static const int EnterKernelDispatchBits = 1 << 25;\n+        static const int LeaveKernelDispatchBits = 1 << 26;\n+        static const int HasConstCharPtrArgBits = 1 << 27;\n+        static const int hasIntArgBits = 1 << 28;\n+        const static int END_BIT_IDX = 27;\n+\n+        size_t eventMax;\n+        size_t eventc;\n+        int *eventInfoBits;\n+        const char **eventInfoConstCharPtrArgs;\n+\n+        virtual void showEvents(int width) = 0;\n+\n+        virtual void inc(int bits) = 0;\n+\n+        virtual void inc(int bits, const char *arg) = 0;\n+\n+        virtual void marker(int bits) = 0;\n+\n+        virtual void marker(int bits, const char *arg) = 0;\n+\n+\n+        virtual void markAsStartComputeAndInc() = 0;\n+\n+        virtual void markAsEndComputeAndInc() = 0;\n+\n+        virtual void markAsEnterKernelDispatchAndInc() = 0;\n+\n+        virtual void markAsLeaveKernelDispatchAndInc() = 0;\n+\n+        ProfilableQueue(Backend *backend, int eventMax)\n+                : Queue(backend),\n+                  eventMax(eventMax),\n+                  eventInfoBits(new int[eventMax]),\n+                  eventInfoConstCharPtrArgs(new const char *[eventMax]),\n+                  eventc(0) {}\n+\n+        virtual ~ProfilableQueue() override {\n+            delete[]eventInfoBits;\n+            delete[]eventInfoConstCharPtrArgs;\n+        }\n+    };\n+\n+    Config *config;\n+    Queue *queue;\n+\n+    Backend(Config *config, Queue *queue)\n+            : config(config), queue(queue) {}\n+\n+    virtual Buffer *getOrCreateBuffer(BufferState *bufferState) = 0;\n@@ -473,1 +557,1 @@\n-    virtual CompilationUnit * compile(int len, char *source) = 0;\n+    virtual CompilationUnit *compile(int len, char *source) = 0;\n@@ -475,1 +559,1 @@\n-    virtual bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength)=0;\n+    virtual bool getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength) = 0;\n@@ -500,1 +584,1 @@\n-T *bufferOf(const char*name){\n+T *bufferOf(const char *name) {\n@@ -502,4 +586,4 @@\n-    size_t lenExcludingBufferState = lenIncludingBufferState - sizeof(BufferState_s);\n-    T *buffer = (T*)new unsigned char[lenIncludingBufferState];\n-    BufferState_s *bufferState = (BufferState_s*)((char*)buffer+lenExcludingBufferState);\n-    bufferState->magic1 = bufferState->magic2 = BufferState_s::MAGIC;\n+    size_t lenExcludingBufferState = lenIncludingBufferState - sizeof(BufferState);\n+    T *buffer = (T *) new unsigned char[lenIncludingBufferState];\n+    auto *bufferState = (BufferState *) ((char *) buffer + lenExcludingBufferState);\n+    bufferState->magic1 = bufferState->magic2 = BufferState::MAGIC;\n@@ -507,2 +591,2 @@\n-    bufferState->length= sizeof(T) - sizeof(BufferState_s);\n-    bufferState->state=BufferState_s::NEW_STATE;\n+    bufferState->length = sizeof(T) - sizeof(BufferState);\n+    bufferState->state = BufferState::NEW_STATE;\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":267,"deletions":183,"binary":false,"changes":450,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -38,4 +39,5 @@\n-\n-            long ndrange(void *argArray) override {\n-                std::cout << \"spirv ndrange() \" << std::endl;\n-                return 0;\n+            bool setArg(KernelArg *arg, Buffer *buffer) override{\n+                return false ;\n+            }\n+            bool setArg(KernelArg *arg) override{\n+                return false ;\n@@ -56,0 +58,13 @@\n+    };\n+    class SpirvQueue: public Backend::Queue{\n+    public:\n+        void wait()override{};\n+        void release()override{};\n+        void computeStart()override{};\n+        void computeEnd()override{};\n+        void dispatch(KernelContext *kernelContext, Backend::CompilationUnit::Kernel *kernel) override{\n+            std::cout << \"spirv dispatch() \" << std::endl;\n+            size_t dims = 1;\n+            if (backend->config->trace | backend->config->traceEnqueues){\n+                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->maxX << std::endl;\n+            }\n@@ -57,2 +72,0 @@\n-        bool compilationUnitOK() {\n-            return true;\n@@ -60,0 +73,4 @@\n+        void copyToDevice(Buffer *buffer) override{}\n+        void copyFromDevice(Buffer *buffer) override{};\n+        explicit SpirvQueue(Backend *backend):Queue(backend){}\n+        ~SpirvQueue() override =default;\n@@ -61,1 +78,0 @@\n-\n@@ -63,1 +79,1 @@\n-    SpirvBackend(int mode): Backend(mode) {\n+    SpirvBackend(int mode): Backend(new Config(mode), new SpirvQueue(this)) {\n@@ -68,0 +84,17 @@\n+\n+    Buffer * getOrCreateBuffer(BufferState *bufferState) override{\n+        Buffer *buffer = nullptr;\n+\n+      \/* if (bufferState->vendorPtr == 0L || bufferState->state == BufferState::NEW_STATE){\n+            openclBuffer = new OpenCLBuffer(this,  bufferState);\n+            if (openclConfig.trace){\n+                std::cout << \"We allocated arg buffer \"<<std::endl;\n+            }\n+        }else{\n+            if (openclConfig.trace){\n+                std::cout << \"Were reusing  buffer  buffer \"<<std::endl;\n+            }\n+            openclBuffer=  static_cast<OpenCLBuffer*>(bufferState->vendorPtr);\n+        }*\/\n+        return buffer;\n+    }\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"}]}