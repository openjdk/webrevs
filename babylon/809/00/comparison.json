{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import optkl.Trxfmr;\n@@ -55,1 +56,0 @@\n-import static optkl.OpTkl.transform;\n@@ -440,3 +440,2 @@\n-      static  public CoreOp.FuncOp transformPTXPtrs(MethodHandles.Lookup lookup,CoreOp.FuncOp func, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n-        var here = CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n-        return transform(here, func,_->true,(block, op) -> {\n+      static  public CoreOp.FuncOp transformPTXPtrs(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp, HashMap<String, Object> argsMap, Set<String> usedMathFns) {\n+        return new Trxfmr(funcOp).transform(_->true,(block, op) -> {\n@@ -469,1 +468,1 @@\n-        });\n+        }).funcOp();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import optkl.Trxfmr;\n@@ -57,1 +58,0 @@\n-import static optkl.OpTkl.transform;\n@@ -136,1 +136,1 @@\n-            transformedFuncOp = transform(here, computeMethod.funcOp(),_->true,(bldr, op) -> {\n+            transformedFuncOp = new Trxfmr(computeMethod.funcOp()).transform(_->true,(bldr, op) -> {\n@@ -204,1 +204,1 @@\n-            });\n+            }).funcOp();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import static optkl.OpTkl.getQuotedCapturedValues;\n+import static optkl.Lambda.lambdaOpHelper;\n@@ -203,1 +203,1 @@\n-        Object[] args = getQuotedCapturedValues(lambda, quoted, method);\n+        Object[] args = lambdaOpHelper(lookup,lambda).getQuotedCapturedValues( quoted, method);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import optkl.OpTkl;\n+import optkl.Trxfmr;\n@@ -47,1 +47,0 @@\n-import static optkl.OpTkl.transform;\n@@ -73,1 +72,0 @@\n-        var here = CallSite.of(BufferTagger.class, \"inlineLoop\");\n@@ -78,2 +76,2 @@\n-            ssaFunc = OpTkl.transform(here, ssaFunc,(blockbuilder, op) -> {\n-                if (invokeOpHelper(lookup, op) instanceof Invoke invoke          \/\/ always but pattern friendly\n+            ssaFunc = ssaFunc.transform( (blockbuilder, op) -> {\n+                if (invokeOpHelper(lookup, op) instanceof Invoke invoke                         \/\/ always but pattern friendly\n@@ -105,1 +103,1 @@\n-                return blockbuilder;\n+               return blockbuilder;\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import static optkl.OpTkl.getQuotedCapturedValues;\n+import static optkl.Lambda.lambdaOpHelper;\n@@ -170,1 +170,1 @@\n-        Object[] args = getQuotedCapturedValues(kernelCallSite.lambdaOp,kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n+        Object[] args = lambdaOpHelper(lookup(),kernelCallSite.lambdaOp).getQuotedCapturedValues(kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import static optkl.OpTkl.elements;\n@@ -82,3 +81,3 @@\n-        var here = CallSite.of(OpTkl.class, \"createTransitiveInvokeModule\");\n-        elements(here, entry).forEach(codeElement -> {\n-            if (invokeOpHelper(lookup,codeElement) instanceof Invoke invoke) {\n+\n+        Invoke.stream(lookup,entry)\n+                .forEach(invoke -> {\n@@ -97,1 +96,0 @@\n-            }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-import static optkl.OpTkl.mutateBlock;\n+import static optkl.OpTkl.updateBlock;\n@@ -336,1 +336,1 @@\n-                            OpTkl.statements(mutateBlock(forOp)),\n+                            OpTkl.statements(updateBlock(forOp)),\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-            boolean finalIsLocalOrPrivateDS = isLocalOrPrivateDS;\n+            boolean finalIsLocalOrPrivateDS = isLocalOrPrivateDS;\/\/ ?\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import optkl.Trxfmr;\n@@ -46,2 +47,0 @@\n-import static optkl.OpTkl.elements;\n-import static optkl.OpTkl.isAssignable;\n@@ -52,9 +51,0 @@\n-    public boolean hasArrayView(CoreOp.FuncOp entry) {\n-        var here = CallSite.of(HATArrayViewPhase.class, \"isArrayView\");\n-        return elements(here, entry).anyMatch((element) -> (\n-                element instanceof JavaOp.InvokeOp iop &&\n-                        iop.resultType() instanceof ArrayType &&\n-                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n-                        (isAssignable(lookup(), javaType, MappableIface.class)\n-                                || isAssignable(lookup(), javaType, DeviceType.class))));\n-    }\n@@ -64,1 +54,3 @@\n-        if (hasArrayView(funcOp)) {\n+        if (Invoke.stream(lookup(), funcOp).anyMatch(invoke ->\n+                            invoke.returnsArray()\n+                        && invoke.refIs(MappableIface.class,DeviceType.class))) {\n@@ -68,1 +60,1 @@\n-            return funcOp.transform(funcOp.funcName(), (blockBuilder, op) -> {\n+            return new Trxfmr(funcOp).transform( (blockBuilder, op) -> {\n@@ -230,1 +222,1 @@\n-            });\n+            }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATArrayViewPhase.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-         return Trxfmr.of(funcOp)\n-                 .transform(\n+         return Trxfmr.of(funcOp).transform(\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import optkl.Trxfmr;\n@@ -224,4 +225,2 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!reducedFloatsType.containsKey(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+        return new Trxfmr(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -233,2 +232,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n@@ -249,6 +247,3 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                var ctx = blockBuilder.context();\n-                ctx.mapValue(invokeOp.result(), ctx.getValue(invokeOp.operands().getFirst()));\n+        return  new Trxfmr(funcOp).transform(ce->nodesInvolved.contains(ce),(blockBuilder, op) -> {\n+           if (op instanceof JavaOp.InvokeOp invokeOp) {\n+               blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.context().getValue(invokeOp.operands().getFirst()));\n@@ -259,2 +254,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n@@ -281,1 +275,1 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n+        return new Trxfmr(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n@@ -290,2 +284,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n@@ -295,1 +288,1 @@\n-        Map<Op, ReducedFloatType> reducedFloatsType = new HashMap<>();\n+        Map<JavaOp.InvokeOp, ReducedFloatType> reducedFloatsType = new HashMap<>();\n@@ -304,5 +297,3 @@\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            if (!reducedFloatsType.containsKey(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createFloatFromF16(invokeOpHelper(lookup(),invokeOp), blockBuilder, reducedFloatsType.get(invokeOp));\n+        return new Trxfmr(funcOp).transform(reducedFloatsType::containsKey,(blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp $ && invokeOpHelper(lookup(),$) instanceof Invoke invoke) {\n+                createFloatFromF16(invoke, blockBuilder, reducedFloatsType.get(invoke.op()));\n@@ -311,2 +302,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import optkl.Trxfmr;\n@@ -54,2 +55,0 @@\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.transform;\n@@ -87,2 +86,0 @@\n-        var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase\");\n-        before(here,funcOp);\n@@ -91,1 +88,0 @@\n-\n@@ -108,1 +104,1 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        return new Trxfmr(funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n@@ -122,3 +118,1 @@\n-        });\n-        after(here,funcOp );\n-        return funcOp;\n+        }).funcOp();\n@@ -192,2 +186,0 @@\n-            var here = CallSite.of(PrivateMemoryPhase.class, \"HATDialectifyMemoryPhase - memoryLoadOp\");\n-            before(here, funcOp);\n@@ -216,4 +208,2 @@\n-            funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-                if (!nodesInvolved.contains(op)) {\n-                    blockBuilder.op(op);\n-                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+            return new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+               if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -222,2 +212,1 @@\n-                    JavaOp.InvokeOp invokeOp = varTable.get(varOp);\n-                    factory(blockBuilder, varOp, invokeOp);\n+                    factory(blockBuilder, varOp, varTable.get(varOp));\n@@ -225,1 +214,0 @@\n-\n@@ -227,3 +215,1 @@\n-            });\n-            after(here, funcOp);\n-            return funcOp;\n+            }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import optkl.util.CallSite;\n@@ -38,2 +37,0 @@\n-\n-\n@@ -41,1 +38,0 @@\n-\n@@ -45,16 +41,0 @@\n-\n-    default boolean tracing(){\n-            return kernelCallGraph().config().showCompilationPhases();\n-    }\n-\n-    default void before(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model before [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \"  + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n-\n-    default void after(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (tracing()) {\n-            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() +  \"]: \" + System.lineSeparator() + funcOp.toText());\n-        }\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhase.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-        return new Trxfmr(funcOp)\n-                .transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n+        return new Trxfmr(funcOp).transform(ce->ce instanceof JavaOp.FieldAccessOp, c->{\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import optkl.util.CallSite;\n+import optkl.Trxfmr;\n@@ -53,1 +53,0 @@\n-import static optkl.OpTkl.transform;\n@@ -151,6 +150,0 @@\n-\n-   \/\/ private boolean isVectorOperation(Invoke invoke) {\n-     \/\/      return ;\n-   \/\/ }\n-\n-\n@@ -177,1 +170,1 @@\n-    private void inertVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Map<Op, VectorMetaData> vectorMetaData) {\n+    private void insertVectorVarOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, Map<Op, VectorMetaData> vectorMetaData) {\n@@ -247,1 +240,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyVectorLoad\");\n@@ -249,1 +241,0 @@\n-        before(here, funcOp);\n@@ -275,5 +266,2 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node\n+        return new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -289,1 +277,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -292,3 +280,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n@@ -298,1 +284,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyVectorOf\");\n@@ -300,1 +285,0 @@\n-        before(here, funcOp);\n@@ -321,1 +305,1 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        return new Trxfmr(funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -327,1 +311,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -330,3 +314,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n@@ -336,2 +318,1 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyVectorBinaryOps\");\n-        before(here, funcOp);\n+\n@@ -365,1 +346,1 @@\n-        funcOp = transform(here, funcOp, nodesInvolved::contains, (blockBuilder, op) -> {\n+        return new Trxfmr(funcOp).transform( nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -376,1 +357,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -379,3 +360,1 @@\n-        });\n-        after(here, funcOp);\n-        return funcOp;\n+        }).funcOp();\n@@ -385,2 +364,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyMutableOf\");\n-        before(here, funcOp);\n@@ -408,1 +385,1 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+        funcOp = new Trxfmr(funcOp).transform(_->true, (blockBuilder, op) -> {\n@@ -414,1 +391,1 @@\n-                inertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n+                insertVectorVarOp(blockBuilder, varOp, vectorMetaData);\n@@ -417,2 +394,1 @@\n-        });\n-        after(here, funcOp);\n+        }).funcOp();\n@@ -423,2 +399,0 @@\n-        var here = CallSite.of(this.getClass(), \"dialectifyBinaryWithConcatenation\");\n-        before(here, funcOp);\n@@ -451,2 +425,9 @@\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n+        if (!nodesInvolved.isEmpty()) {\n+            funcOp = new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n+                 if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    insertVectorBinaryOp(blockBuilder, invokeOp, binaryOperation);\n+                } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                    insertVectorVarLoadOp(blockBuilder, varLoadOp);\n+                }\n+                return blockBuilder;\n+            }).funcOp();\n@@ -454,11 +435,0 @@\n-        funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                insertVectorBinaryOp(blockBuilder, invokeOp, binaryOperation);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                insertVectorVarLoadOp(blockBuilder, varLoadOp);\n-            }\n-            return blockBuilder;\n-        });\n-        after(here, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorPhase.java","additions":25,"deletions":55,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import optkl.OpTkl;\n+import optkl.Trxfmr;\n@@ -97,1 +97,1 @@\n-        funcOp = OpTkl.transform( funcOp, ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n+        return new Trxfmr(funcOp).transform(ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n@@ -131,3 +131,1 @@\n-        });\n-\n-        return funcOp;\n+        }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-import optkl.OpTkl;\n-import optkl.util.CallSite;\n+import optkl.Trxfmr;\n@@ -103,1 +102,1 @@\n-           funcOp = OpTkl.transform(CallSite.of(this.getClass()), funcOp, _->true, (blockBuilder, op) -> {\n+           return new Trxfmr(funcOp).transform(nodesInvolved::contains, (blockBuilder, op) -> {\n@@ -105,3 +104,1 @@\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n@@ -125,2 +122,1 @@\n-        });\n-        return funcOp;\n+        }).funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import optkl.Trxfmr;\n@@ -42,1 +43,0 @@\n-import static optkl.OpTkl.transform;\n@@ -83,1 +83,1 @@\n-        var transformed = transform(here, funcOp,_->true,(builder, op) -> {\n+        var transformed = new Trxfmr(funcOp).transform(_->true,(builder, op) -> {\n@@ -97,1 +97,1 @@\n-        });\n+        }).funcOp();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import optkl.Trxfmr;\n@@ -46,1 +47,0 @@\n-import static optkl.OpTkl.transform;\n@@ -140,1 +140,1 @@\n-            CoreOp.FuncOp transformed = transform(here, javaFunc,_->true,(builder, op) -> {\n+            CoreOp.FuncOp transformed = new Trxfmr(javaFunc).transform(_->true,(builder, op) -> {\n@@ -155,1 +155,1 @@\n-            });\n+            }).funcOp();\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package optkl;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public interface Lambda extends OpHelper<JavaOp.LambdaOp>{\n+\n+    @Override\n+    default  String name(){\n+        return op().externalizeOpName();\n+    }\n+\n+    default boolean isPrimitive(){\n+        return op().result().type() instanceof PrimitiveType;\n+    }\n+\n+    default  <T>boolean of(Class<T> clazz){\n+        return isAssignable((JavaType) op().resultType(),clazz);\n+    }\n+\n+    static Lambda lambdaOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.LambdaOp op) implements Lambda {}\n+        return codeElement instanceof JavaOp.LambdaOp lambdaOp? new Impl(lookup,lambdaOp): null;\n+    }\n+\n+\n+    default Object[] getQuotedCapturedValues(Quoted quoted, Method method) {\n+        var block = op().body().entryBlock();\n+        var ops = block.ops();\n+        Object[] varLoadNames = ops.stream()\n+                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n+                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n+                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n+                .map(CoreOp.VarOp::varName).toArray();\n+        Map<String, Object> nameValueMap = new HashMap<>();\n+\n+        quoted.capturedValues().forEach((k, v) -> {\n+            if (k instanceof Op.Result result) {\n+                if (result.op() instanceof CoreOp.VarOp varOp) {\n+                    nameValueMap.put(varOp.varName(), v);\n+                }\n+            }\n+        });\n+        Object[] args = new Object[method.getParameterCount()];\n+        if (args.length != varLoadNames.length) {\n+            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n+        }\n+        for (int i = 1; i < args.length; i++) {\n+            args[i] = nameValueMap.get(varLoadNames[i].toString());\n+            if (args[i] instanceof CoreOp.Var<?> var) {\n+                args[i] = var.value();\n+            }\n+        }\n+        return args;\n+    }\n+}\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Lambda.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.HashSet;\n@@ -59,1 +58,1 @@\n-        return OpTkl.operandAsResult(op(),i) instanceof Op.Result result?result:null;\n+        return OpTkl.operandNAsResult(op(),i) instanceof Op.Result result?result:null;\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.code.CodeTransformer;\n@@ -31,1 +30,0 @@\n-import jdk.incubator.code.Quoted;\n@@ -37,1 +35,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -39,1 +36,0 @@\n-import optkl.util.CallSite;\n@@ -43,1 +39,0 @@\n-import java.lang.reflect.Method;\n@@ -47,1 +42,0 @@\n-import java.util.HashMap;\n@@ -49,1 +43,0 @@\n-import java.util.Map;\n@@ -51,2 +44,0 @@\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n@@ -72,1 +63,0 @@\n-\n@@ -76,34 +66,0 @@\n-\n-    static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n-        var block = lambdaOp.body().entryBlock();\n-        var ops = block.ops();\n-        Object[] varLoadNames = ops.stream()\n-                .filter(op -> op instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                .map(op -> (CoreOp.VarAccessOp.VarLoadOp) op)\n-                .map(varLoadOp -> (Op.Result) varLoadOp.operands().getFirst())\n-                .map(varLoadOp -> (CoreOp.VarOp) varLoadOp.op())\n-                .map(CoreOp.VarOp::varName).toArray();\n-        Map<String, Object> nameValueMap = new HashMap<>();\n-\n-        quoted.capturedValues().forEach((k, v) -> {\n-            if (k instanceof Op.Result result) {\n-                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                    nameValueMap.put(varOp.varName(), v);\n-                }\n-            }\n-        });\n-        Object[] args = new Object[method.getParameterCount()];\n-        if (args.length != varLoadNames.length) {\n-            throw new IllegalStateException(\"Why don't we have enough captures.!! \");\n-        }\n-        for (int i = 1; i < args.length; i++) {\n-            args[i] = nameValueMap.get(varLoadNames[i].toString());\n-            if (args[i] instanceof CoreOp.Var varbox) {\n-                args[i] = varbox.value();\n-            }\n-        }\n-        return args;\n-    }\n-\n-\n-\n@@ -150,2 +106,2 @@\n-    static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx) {\n-        return ternaryOp.bodies().get(idx).entryBlock();\n+    static Block entryBlockOfBodyN(Op op, int idx) {\n+        return op.bodies().get(idx).entryBlock();\n@@ -155,1 +111,1 @@\n-        return block(ternaryOp, 0);\n+        return entryBlockOfBodyN(ternaryOp, 0);\n@@ -159,1 +115,1 @@\n-        return block(ternaryOp, 1);\n+        return entryBlockOfBodyN(ternaryOp, 1);\n@@ -163,1 +119,1 @@\n-        return block(ternaryOp, 2);\n+        return entryBlockOfBodyN(ternaryOp, 2);\n@@ -167,1 +123,1 @@\n-    static Value operandOrNull(Op op, int idx) {\n+    static Value operandNOrNull(Op op, int idx) {\n@@ -171,8 +127,1 @@\n-    static Block block(JavaOp.ForOp forOp, int idx) {\n-        return forOp.bodies().get(idx).entryBlock();\n-    }\n-\n-    static Block mutateBlock(JavaOp.ForOp forOp) {\n-        return block(forOp, 2);\n-    }\n-\n+    static Block updateBlock(JavaOp.ForOp forOp) {return forOp.update().entryBlock();}\n@@ -182,1 +131,0 @@\n-\n@@ -186,5 +134,0 @@\n-\n-    static Block block(JavaOp.WhileOp whileOp, int idx) {\n-        return whileOp.bodies().get(idx).entryBlock();\n-    }\n-\n@@ -192,1 +135,1 @@\n-        return block(whileOp, 0);\n+        return entryBlockOfBodyN(whileOp, 0);\n@@ -195,1 +138,0 @@\n-\n@@ -205,2 +147,2 @@\n-        if (value instanceof Op.Result r) {\n-            return r;\n+        if (value instanceof Op.Result result) {\n+            return result;\n@@ -218,1 +160,1 @@\n-    static Op.Result operandAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n+    static Op.Result operandNAsResult(jdk.incubator.code.CodeElement<?, ?> codeElement, int n) {\n@@ -277,73 +219,0 @@\n-\n-    static Stream<jdk.incubator.code.CodeElement<?, ?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.elements();\n-    }\n-\n-    static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n-                                        Predicate<jdk.incubator.code.CodeElement<?, ?>> predicate,\n-                                        Function<CodeElement<?, ?>, T> mapper\n-    ) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.elements().filter(predicate).map(mapper);\n-    }\n-\n-\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<CodeElement<?,?>> predicate, CodeTransformer codeTransformer) {\n-        if (callSite!= null && callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform((blockBuilder, op) -> {\n-            if (predicate.test(op)) {\n-                var builder = codeTransformer.acceptOp(blockBuilder, op);\n-                if (builder != blockBuilder) {\n-                    throw new RuntimeException(\"Where does this builder come from \" + builder);\n-                }\n-            } else {\n-                blockBuilder.op(op);\n-            }\n-            return blockBuilder;\n-        });\n-    }\n-    static CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Predicate<CodeElement<?,?>> predicate, CodeTransformer codeTransformer) {\n-       return OpTkl.transform(null, funcOp,predicate,codeTransformer);\n-    }\n-\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform(CodeTransformer);\n-    }\n-\n-\n-    static Class<?> typeElementToClass(MethodHandles.Lookup lookup, TypeElement type) {\n-        class PrimitiveHolder {\n-            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-                    JavaType.BYTE, byte.class,\n-                    JavaType.SHORT, short.class,\n-                    JavaType.INT, int.class,\n-                    JavaType.LONG, long.class,\n-                    JavaType.FLOAT, float.class,\n-                    JavaType.DOUBLE, double.class,\n-                    JavaType.CHAR, char.class,\n-                    JavaType.BOOLEAN, boolean.class\n-            );\n-        }\n-        try {\n-            if (type instanceof PrimitiveType primitiveType) {\n-                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-            } else if (type instanceof ClassType classType) {\n-                return ((Class<?>) classType.resolve(lookup));\n-            } else {\n-                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n-            }\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(\"given type cannot be converted to class\");\n-        }\n-    }\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":11,"deletions":142,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.LinkedHashSet;\n@@ -40,1 +39,0 @@\n-import java.util.function.BiConsumer;\n@@ -45,1 +43,1 @@\n-import static optkl.OpTkl.operandOrNull;\n+import static optkl.OpTkl.operandNOrNull;\n@@ -210,1 +208,1 @@\n-            return getValue(operandOrNull(op(),idx));\n+            return getValue(operandNOrNull(op(),idx));\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}