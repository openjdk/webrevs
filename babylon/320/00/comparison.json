{"files":[{"patch":"@@ -5,0 +5,1 @@\n+import java.nio.ByteOrder;\n@@ -309,0 +310,5 @@\n+            String getName(Value v, int subIndex) {\n+                var name = getName(v);\n+                if (subIndex != 0) name += \".\" + subIndex;\n+                return name;\n+            }\n@@ -322,2 +328,2 @@\n-                                            .forEach(op.operands(), (n, p) -> n.input(indexer.getName(p)))\n-                                            .output(indexer.getName(op.result()))\n+                                            .forEach(op.operands(), (n, i) -> n.input(indexer.getName(i)))\n+                                            .forEach(onnxOp.onnxOutputs(), (n, o) -> n.output(indexer.getName(op.result(), o.ordinal())))\n@@ -329,3 +335,2 @@\n-                                case CoreOp.TupleLoadOp _ -> {\n-                                    \/\/ @@@ hack to forward to the first from the tuple\n-                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst()));\n+                                case CoreOp.TupleLoadOp tlo -> {\n+                                    indexer.put(op.result(), indexer.getName(op.operands().getFirst(), tlo.index()));\n@@ -343,0 +348,1 @@\n+        OnnxProtoPrinter.printModel(ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+package oracle.code.onnx;\n+\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.util.Arrays;\n+\n+public enum OnnxProtoPrinter {\n+    BYTE, BYTES, INT, LONG, FLOAT, DOUBLE, STRING,\n+    Attribute, ValueInfoProto, NodeProto, TrainingInfoProto, ModelProto, StringStringEntryProto, TensorAnnotation,\n+    GraphProto, TensorProto, Segment, SparseTensorProto, TensorShapeProto, Dimension, TypeProto, Tensor, Sequence,\n+    Map, Optional, SparseTensor, OperatorSetIdProto, FunctionProto;\n+\n+    static {\n+        init(Attribute,\n+                1, \"name\", STRING,\n+                2, \"f\", FLOAT,\n+                3, \"i\", LONG,\n+                4, \"s\", BYTES,\n+                5, \"t\", TensorProto,\n+                6, \"g\", GraphProto,\n+                7, \"floats\", FLOAT,\n+                8, \"ints\", LONG,\n+                9, \"strings\", BYTES,\n+               10, \"tensors\", TensorProto,\n+               11, \"graphs\", GraphProto,\n+               13, \"doc_string\", STRING,\n+               14, \"tp\", TypeProto,\n+               15, \"type_protos\", TypeProto,\n+               20, \"type\", INT,\n+               21, \"ref_attr_name\", STRING,\n+               22, \"sparse_tensor\", SparseTensorProto,\n+               23, \"sparse_tensors\", SparseTensorProto);\n+        init(ValueInfoProto,\n+                1, \"name\", STRING,\n+                2, \"type\", TypeProto,\n+                3, \"doc_string\", STRING,\n+                4, \"metadata_props\", StringStringEntryProto);\n+        init(NodeProto,\n+                1, \"input\", STRING,\n+                2, \"output\", STRING,\n+                3, \"name\", STRING,\n+                4, \"op_type\", STRING,\n+                5, \"attribute\", Attribute,\n+                6, \"doc_string\", STRING,\n+                7, \"domain\", STRING,\n+                8, \"overload\", STRING,\n+                9, \"metadata_props\", StringStringEntryProto);\n+        init(TrainingInfoProto,\n+                1, \"initialization\", GraphProto,\n+                2, \"algorithm\", GraphProto,\n+                3, \"initialization_binding\", StringStringEntryProto,\n+                4, \"update_binding\", StringStringEntryProto);\n+        init(ModelProto,\n+                1, \"ir_version\", LONG,\n+                2, \"producer_name\", STRING,\n+                3, \"producer_version\", STRING,\n+                4, \"domain\", STRING,\n+                5, \"model_version\", LONG,\n+                6, \"doc_string\", STRING,\n+                7, \"graph\", GraphProto,\n+                8, \"opset_import\", OperatorSetIdProto,\n+                14, \"metadata_props\", StringStringEntryProto,\n+                20, \"training_info\", TrainingInfoProto,\n+                25, \"functions\", FunctionProto);\n+        init(StringStringEntryProto,\n+                1, \"key\", STRING,\n+                2, \"value\", STRING);\n+        init(TensorAnnotation,\n+                1, \"tensor_name\", STRING,\n+                2, \"quant_parameter_tensor_names\", StringStringEntryProto);\n+        init(GraphProto,\n+                1, \"node\", NodeProto,\n+                2, \"name\", STRING,\n+                5, \"initializer\", TensorProto,\n+                10, \"doc_string\", STRING,\n+                11, \"input\", ValueInfoProto,\n+                12, \"output\", ValueInfoProto,\n+                13, \"value_info\", ValueInfoProto,\n+                14, \"quantization_annotation\", TensorAnnotation,\n+                15, \"sparse_initializer\", SparseTensorProto,\n+                16, \"metadata_props\", StringStringEntryProto);\n+        init(TensorProto,\n+                1, \"dims\", LONG,\n+                2, \"data_type\", INT,\n+                3, \"segment\", Segment,\n+                4, \"float_data\", FLOAT,\n+                5, \"int32_data\", INT,\n+                6, \"string_data\", BYTES,\n+                7, \"int64_data\", LONG,\n+                8, \"name\", STRING,\n+                9, \"raw_data\", BYTES,\n+                10, \"double_data\", DOUBLE,\n+                11, \"uint64_data\", LONG,\n+                12, \"doc_string\", STRING,\n+                13, \"external_data\", StringStringEntryProto,\n+                14, \"data_location\", INT,\n+                16, \"metadata_props\", StringStringEntryProto);\n+        init(Segment,\n+                1, \"begin\", LONG,\n+                2, \"end\", LONG);\n+        init(SparseTensorProto,\n+                1, \"values\", TensorProto,\n+                2, \"indices\", TensorProto,\n+                3, \"dims\", LONG);\n+        init(TensorShapeProto,\n+                1, \"dim\", Dimension);\n+        init(Dimension,\n+                1, \"dim_value\", LONG,\n+                2, \"dim_param\", STRING,\n+                3, \"denotation\", STRING);\n+        init(TypeProto,\n+                1, \"tensor_type\", Tensor,\n+                4, \"sequence_type\", Sequence,\n+                5, \"map_type\", Map,\n+                6, \"denotation\", STRING,\n+                8, \"sparse_tensor_type\", SparseTensor,\n+                9, \"optional_type\", Optional);\n+        init(Tensor,\n+                1, \"elem_type\", INT,\n+                2, \"shape\", TensorShapeProto);\n+        init(Sequence,\n+                1, \"elem_type\", TypeProto);\n+        init(Map,\n+                1, \"key_type\", INT,\n+                2, \"value_type\", TypeProto);\n+        init(Optional,\n+                1, \"elem_type\", TypeProto);\n+        init(SparseTensor,\n+                1, \"elem_type\", INT,\n+                2, \"shape\", TensorShapeProto);\n+        init(OperatorSetIdProto,\n+                1, \"domain\", STRING,\n+                2, \"version\", LONG);\n+        init(FunctionProto,\n+                1, \"name\", STRING,\n+                4, \"input\", STRING,\n+                5, \"output\", STRING,\n+                6, \"attribute\", STRING,\n+                7, \"node\", NodeProto,\n+                8, \"doc_string\", STRING,\n+                9, \"opset_import\", OperatorSetIdProto,\n+                10, \"domain\", STRING,\n+                11, \"attribute_proto\", Attribute,\n+                12, \"value_info\", ValueInfoProto,\n+                13, \"overload\", STRING,\n+                14, \"metadata_props\", StringStringEntryProto);\n+    }\n+\n+    private record Field(String name, OnnxProtoPrinter type) {}\n+\n+    private static void init(OnnxProtoPrinter proto, Object... fields) {\n+        proto.fields = new Field[(int)fields[fields.length - 3]];\n+        for (int i = 0; i < fields.length; i += 3) {\n+            proto.fields[(int)fields[i] - 1] = new Field((String)fields[i + 1], (OnnxProtoPrinter)fields[i + 2]);\n+        }\n+    }\n+\n+    private static long decodeVarint(ByteBuffer data) {\n+        int i, shift = 0;\n+        long value = 0;\n+        do {\n+            value |= ((i = data.get()) & 0x7f) << shift;\n+            shift += 7;\n+        } while ((i & 0x80) != 0);\n+        return value;\n+    }\n+\n+    private Field[] fields;\n+\n+    public void print(int indent, ByteBuffer data) {\n+        while (data.remaining() > 0) {\n+            long tag = decodeVarint(data);\n+            var f = fields[((int)tag >> 3) - 1];\n+            System.out.print(\"    \".repeat(indent) + f.type() + \" \" + f.name() + \" \");\n+            switch (f.type) {\n+                case BYTE, INT, LONG ->\n+                    System.out.println(decodeVarint(data));\n+                case FLOAT ->\n+                    System.out.println(data.getFloat());\n+                case DOUBLE ->\n+                    System.out.println(data.getDouble());\n+                case BYTES -> {\n+                    var bytes = new byte[(int)decodeVarint(data)];\n+                    data.get(bytes);\n+                    System.out.println(Arrays.toString(bytes));\n+                }\n+                case STRING -> {\n+                    var bytes = new byte[(int)decodeVarint(data)];\n+                    data.get(bytes);\n+                    System.out.println('\"' + new String(bytes) + '\"');\n+                }\n+                default -> {\n+                    var size = decodeVarint(data);\n+                    int limit = data.limit();\n+                    System.out.println();\n+                    f.type().print(indent + 1, data.limit(data.position() + (int)size));\n+                    data.limit(limit);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void printModel(ByteBuffer model) {\n+        ModelProto.print(0, model);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        for (var fName : args) {\n+            System.out.println(fName);\n+            try (var in = new RandomAccessFile(fName, \"r\")) {\n+                ModelProto.print(1, in.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, in.length()).order(ByteOrder.LITTLE_ENDIAN));\n+            }\n+        }\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoPrinter.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -69,0 +69,4 @@\n+    public static Tensor<Byte> ofScalar(byte b) {\n+        return ofShape(SCALAR_SHAPE, b);\n+    }\n+\n@@ -70,2 +74,1 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_LONG, l);\n-        return new Tensor<>(data, ElementType.INT64, SCALAR_SHAPE);\n+        return ofShape(SCALAR_SHAPE, l);\n@@ -75,2 +78,1 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_FLOAT, f);\n-        return new Tensor(data, ElementType.FLOAT, SCALAR_SHAPE);\n+        return ofShape(SCALAR_SHAPE, f);\n@@ -79,0 +81,1 @@\n+\n@@ -80,2 +83,1 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_BYTE, values);\n-        return new Tensor(data, ElementType.UINT8, new long[]{values.length});\n+        return ofShape(new long[]{values.length}, values);\n@@ -85,2 +87,1 @@\n-        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_LONG, values);\n-        return new Tensor(data, ElementType.INT64, new long[]{values.length});\n+        return ofShape(new long[]{values.length}, values);\n@@ -90,0 +91,14 @@\n+        return ofShape(new long[]{values.length}, values);\n+    }\n+\n+    public static Tensor<Byte> ofShape(long[] shape, byte... values) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_BYTE, values);\n+        return new Tensor(data, ElementType.UINT8, shape);\n+    }\n+\n+    public static Tensor<Long> ofShape(long[] shape, long... values) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_LONG, values);\n+        return new Tensor(data, ElementType.INT64, shape);\n+    }\n+\n+    public static Tensor<Float> ofShape(long[] shape, float... values) {\n@@ -91,1 +106,1 @@\n-        return new Tensor(data, ElementType.FLOAT, new long[]{values.length});\n+        return new Tensor(data, ElementType.FLOAT, shape);\n@@ -98,1 +113,1 @@\n-    Tensor(MemorySegment dataAddr, ElementType type, long... shape) {\n+    public Tensor(MemorySegment dataAddr, ElementType type, long... shape) {\n@@ -102,1 +117,1 @@\n-    Tensor(MemorySegment tensorAddr) {\n+    public Tensor(MemorySegment tensorAddr) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.Arena;\n@@ -47,1 +48,0 @@\n-import java.nio.ByteOrder;\n@@ -50,4 +50,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n@@ -55,1 +51,1 @@\n-import onnx.OnnxMl;\n+import java.util.function.Function;\n@@ -75,0 +71,13 @@\n+    private static final String IMAGES_PATH = CNNTest.class.getResource(\"images-ubyte\").getPath();\n+    private static final String LABELS_PATH = CNNTest.class.getResource(\"labels-ubyte\").getPath();\n+    private static final int IMAGES_HEADER_SIZE = 0;\n+    private static final int LABELS_HEADER_SIZE = 0;\n+\n+\/\/    static final String IMAGES_PATH = CNNTest.class.getResource(\"t10k-images-idx3-ubyte\").getPath();\n+\/\/    static final String LABELS_PATH = CNNTest.class.getResource(\"t10k-labels-idx1-ubyte\").getPath();\n+\/\/    static final int IMAGES_HEADER_SIZE = 16;\n+\/\/    static final int LABELS_HEADER_SIZE = 8;\n+\n+    private static final String GREY_SCALE = \" .'`^\\\",:;Il!i><~+_-?][}{1)(|\\\\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$\";\n+    private static final Arena ARENA = Arena.ofAuto();\n+\n@@ -78,1 +87,0 @@\n-    private static final int NUM_LABELS = 10;\n@@ -153,18 +161,0 @@\n-    @CodeReflection\n-    public Tensor<Float> loadWeight(Initializer init) {\n-        var buf = ByteBuffer.allocate(init.values().length).order(ByteOrder.nativeOrder());\n-        buf.put(init.values());\n-        buf.rewind();\n-        var floatBuf = buf.asFloatBuffer();\n-        var floatArr = new float[floatBuf.remaining()];\n-        floatBuf.get(floatArr);\n-        Tensor<Long> shape = Constant(\n-                empty(), empty(), empty(), empty(), empty(), of(init.shape()), empty(), empty()\n-        );\n-        Tensor<Float> floats = Constant(\n-                empty(), of(floatArr), empty(), empty(), empty(), empty(), empty(), empty()\n-        );\n-        var shaped = Reshape(floats, shape, empty());\n-        return shaped;\n-    }\n-\n@@ -334,12 +324,8 @@\n-    static List<Tensor> loadWeights() throws IOException {\n-        try (var is = CNNTest.class.getResourceAsStream(\"lenet-torchscript.onnx\")) {\n-            return OnnxMl.ModelProto.parseFrom(is).getGraph().getInitializerList().stream()\n-                    .map(init ->  {\n-                        var bb = ByteBuffer.allocateDirect(init.getRawData().size());\n-                        init.getRawData().copyTo(bb);\n-                        return new Tensor(OnnxRuntime.getInstance().createTensor(\n-                                MemorySegment.ofBuffer(bb.rewind()),\n-                                Tensor.ElementType.fromOnnxId(init.getDataType()),\n-                                init.getDimsList().stream().mapToLong(a -> a).toArray()));\n-                    })\n-                    .toList();\n+    static void printImage(int imageIndex, ByteBuffer bb) {\n+        System.out.println(\"Image #\" + imageIndex + \" :\");\n+        int offset = imageIndex * 28 * 28;\n+        for (int y = 0; y < 28; y++) {\n+            for (int x = 0; x < 28; x++) {\n+                System.out.print(GREY_SCALE.charAt(GREY_SCALE.length() * (0xff & bb.get(offset + y * 28 + x)) \/ 256));\n+            }\n+            System.out.println();\n@@ -349,0 +335,19 @@\n+    private static Tensor<Float> floatTensor(String resource, long... shape) throws IOException {\n+        try (var file = new RandomAccessFile(CNNTest.class.getResource(resource).getPath(), \"r\")) {\n+            return new Tensor(file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length(), ARENA), Tensor.ElementType.FLOAT, shape);\n+        }\n+    }\n+\n+    static List<Tensor> loadWeights() throws IOException {\n+        return List.of(floatTensor(\"conv1-weight-float-le\", 6, 1, 5, 5),\n+                       floatTensor(\"conv1-bias-float-le\", 6),\n+                       floatTensor(\"conv2-weight-float-le\", 16, 6, 5, 5),\n+                       floatTensor(\"conv2-bias-float-le\", 16),\n+                       floatTensor(\"fc1-weight-float-le\", 120, 256),\n+                       floatTensor(\"fc1-bias-float-le\", 120),\n+                       floatTensor(\"fc2-weight-float-le\", 84, 120),\n+                       floatTensor(\"fc2-bias-float-le\", 84),\n+                       floatTensor(\"fc3-weight-float-le\", 10, 84),\n+                       floatTensor(\"fc3-bias-float-le\", 10));\n+    }\n+\n@@ -362,23 +367,0 @@\n-    private static final String GREY_SCALE = \" .'`^\\\",:;Il!i><~+_-?][}{1)(|\\\\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$\";\n-\n-    static void printImage(int imageIndex, ByteBuffer bb) {\n-        System.out.println(\"Image #\" + imageIndex + \" :\");\n-        int offset = imageIndex * 28 * 28;\n-        for (int y = 0; y < 28; y++) {\n-            for (int x = 0; x < 28; x++) {\n-                System.out.print(GREY_SCALE.charAt(GREY_SCALE.length() * (0xff & bb.get(offset + y * 28 + x)) \/ 256));\n-            }\n-            System.out.println();\n-        }\n-    }\n-\n-\/\/    static final String IMAGES_PATH = \"t10k-images-idx3-ubyte\";\n-\/\/    static final String LABELS_PATH = \"t10k-labels-idx1-ubyte\";\n-\/\/    static final int IMAGES_HEADER_SIZE = 16;\n-\/\/    static final int LABELS_HEADER_SIZE = 8;\n-\n-    static final String IMAGES_PATH = CNNTest.class.getResource(\"images-ubyte\").getPath();\n-    static final String LABELS_PATH = CNNTest.class.getResource(\"labels-ubyte\").getPath();\n-    static final int IMAGES_HEADER_SIZE = 0;\n-    static final int LABELS_HEADER_SIZE = 0;\n-\n@@ -386,1 +368,1 @@\n-    public void test() throws Exception {\n+    public void testModels() {\n@@ -390,0 +372,1 @@\n+\n@@ -394,0 +377,9 @@\n+    }\n+\n+    @Test\n+    public void testInterpreter() throws Exception {\n+        List<Tensor> weights = loadWeights();\n+        test(inputImage -> cnn(weights.get(0), weights.get(1), weights.get(2), weights.get(3), weights.get(4),\n+                               weights.get(5), weights.get(6), weights.get(7), weights.get(8), weights.get(9),\n+                               inputImage));\n+    }\n@@ -395,0 +387,10 @@\n+    @Test\n+    public void testProtobufModel() throws Exception {\n+        List<Tensor> weights = loadWeights();\n+        test(inputImage -> new Tensor(OnnxRuntime.getInstance().runFunc(\n+                    OnnxTransformer.transform(MethodHandles.lookup(), getFuncOp(\"cnn\")),\n+                    Stream.concat(weights.stream(), Stream.of(inputImage))\n+                            .map(t -> Optional.of(t.tensorAddr)).toList()).getFirst()));\n+    }\n+\n+    private void test(Function<Tensor, Tensor> executor) throws Exception {\n@@ -401,2 +403,1 @@\n-            List<Tensor> weights = loadWeights();\n-            Tensor inputImage = new Tensor(MemorySegment.ofBuffer(imagesIn), Tensor.ElementType.UINT8, new long[]{imagesF.length()});\n+            Tensor inputImage = new Tensor(MemorySegment.ofBuffer(imagesIn), Tensor.ElementType.UINT8, new long[]{imagesF.length() - IMAGES_HEADER_SIZE});\n@@ -404,5 +405,1 @@\n-            FloatBuffer result = new Tensor(OnnxRuntime.getInstance().runFunc(\n-                    onnxModel,\n-                    Stream.concat(weights.stream(), Stream.of(inputImage))\n-                            .map(t -> Optional.of(t.tensorAddr)).toList()).getFirst())\n-                    .asByteBuffer().asFloatBuffer();\n+            FloatBuffer result = executor.apply(inputImage).asByteBuffer().asFloatBuffer();\n@@ -444,41 +441,59 @@\n-    public static void extractWeights(Path inputOnnx, Path outputSerialized) throws IOException  {\n-        try (InputStream is = Files.newInputStream(inputOnnx)) {\n-            OnnxMl.ModelProto model = OnnxMl.ModelProto.parseFrom(is);\n-            OnnxMl.GraphProto graph = model.getGraph();\n-            List<Initializer> initList = new ArrayList<>();\n-            for (var init : graph.getInitializerList()) {\n-                var name = init.getName();\n-                var type = init.getDataType();\n-                var shape = init.getDimsList().stream().mapToLong(a -> a).toArray();\n-                var valuesBuf = init.getRawData().asReadOnlyByteBuffer();\n-                var valuesArr = new byte[valuesBuf.remaining()];\n-                valuesBuf.get(valuesArr);\n-                var initializer = new Initializer(name, type, shape, valuesArr);\n-                System.out.println(initializer);\n-                initList.add(initializer);\n-            }\n-            try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(outputSerialized))) {\n-                oos.writeObject(initList);\n-            }\n-        }\n-    }\n-\n-    public record Initializer(String name, int type, long[] shape, byte[] values) implements java.io.Serializable {\n-        @Override\n-        public String toString() {\n-            return \"Initializer{\" +\n-                    \"name='\" + name + '\\'' +\n-                    \", type=\" + type +\n-                    \", shape=\" + Arrays.toString(shape) +\n-                    \", values.length=\" + values.length +\n-                    '}';\n-        }\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        Path inputPath = Path.of(args[0]);\n-\n-        Path outputPath = Path.of(args[1]);\n-\n-        extractWeights(inputPath, outputPath);\n-    }\n+\/\/    @CodeReflection\n+\/\/    public Tensor<Float> loadWeight(Initializer init) {\n+\/\/        var buf = ByteBuffer.allocate(init.values().length).order(ByteOrder.nativeOrder());\n+\/\/        buf.put(init.values());\n+\/\/        buf.rewind();\n+\/\/        var floatBuf = buf.asFloatBuffer();\n+\/\/        var floatArr = new float[floatBuf.remaining()];\n+\/\/        floatBuf.get(floatArr);\n+\/\/        Tensor<Long> shape = Constant(\n+\/\/                empty(), empty(), empty(), empty(), empty(), of(init.shape()), empty(), empty()\n+\/\/        );\n+\/\/        Tensor<Float> floats = Constant(\n+\/\/                empty(), of(floatArr), empty(), empty(), empty(), empty(), empty(), empty()\n+\/\/        );\n+\/\/        var shaped = Reshape(floats, shape, empty());\n+\/\/        return shaped;\n+\/\/    }\n+\/\/\n+\/\/    public static void extractWeights(Path inputOnnx, Path outputSerialized) throws IOException  {\n+\/\/        try (InputStream is = Files.newInputStream(inputOnnx)) {\n+\/\/            OnnxMl.ModelProto model = OnnxMl.ModelProto.parseFrom(is);\n+\/\/            OnnxMl.GraphProto graph = model.getGraph();\n+\/\/            List<Initializer> initList = new ArrayList<>();\n+\/\/            for (var init : graph.getInitializerList()) {\n+\/\/                var name = init.getName();\n+\/\/                var type = init.getDataType();\n+\/\/                var shape = init.getDimsList().stream().mapToLong(a -> a).toArray();\n+\/\/                var valuesBuf = init.getRawData().asReadOnlyByteBuffer();\n+\/\/                var valuesArr = new byte[valuesBuf.remaining()];\n+\/\/                valuesBuf.get(valuesArr);\n+\/\/                var initializer = new Initializer(name, type, shape, valuesArr);\n+\/\/                System.out.println(initializer);\n+\/\/                initList.add(initializer);\n+\/\/            }\n+\/\/            try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(outputSerialized))) {\n+\/\/                oos.writeObject(initList);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    public record Initializer(String name, int type, long[] shape, byte[] values) implements java.io.Serializable {\n+\/\/        @Override\n+\/\/        public String toString() {\n+\/\/            return \"Initializer{\" +\n+\/\/                    \"name='\" + name + '\\'' +\n+\/\/                    \", type=\" + type +\n+\/\/                    \", shape=\" + Arrays.toString(shape) +\n+\/\/                    \", values.length=\" + values.length +\n+\/\/                    '}';\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    public static void main(String[] args) throws IOException {\n+\/\/        Path inputPath = Path.of(args[0]);\n+\/\/\n+\/\/        Path outputPath = Path.of(args[1]);\n+\/\/\n+\/\/        extractWeights(inputPath, outputPath);\n+\/\/    }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":124,"deletions":109,"binary":false,"changes":233,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        var bb = ByteBuffer.wrap(MNISTDemo.class.getResourceAsStream(resource).readAllBytes());\n+        var bb = ByteBuffer.wrap(MNISTDemo.class.getResourceAsStream(resource).readAllBytes()).order(ByteOrder.LITTLE_ENDIAN);\n@@ -64,2 +64,2 @@\n-        var conv1Weights = Reshape(Constant(loadConstant(\"conv1-weight-float\")), Constant(new long[]{6, 1, 5, 5}), empty());\n-        var conv1Biases = Reshape(Constant(loadConstant(\"conv1-bias-float\")), Constant(new long[]{6}), empty());\n+        var conv1Weights = Reshape(Constant(loadConstant(\"conv1-weight-float-le\")), Constant(new long[]{6, 1, 5, 5}), empty());\n+        var conv1Biases = Reshape(Constant(loadConstant(\"conv1-bias-float-le\")), Constant(new long[]{6}), empty());\n@@ -76,2 +76,2 @@\n-        var conv2Weights = Reshape(Constant(loadConstant(\"conv2-weight-float\")), Constant(new long[]{16, 6, 5, 5}), empty());\n-        var conv2Biases = Reshape(Constant(loadConstant(\"conv2-bias-float\")), Constant(new long[]{16}), empty());\n+        var conv2Weights = Reshape(Constant(loadConstant(\"conv2-weight-float-le\")), Constant(new long[]{16, 6, 5, 5}), empty());\n+        var conv2Biases = Reshape(Constant(loadConstant(\"conv2-bias-float-le\")), Constant(new long[]{16}), empty());\n@@ -91,2 +91,2 @@\n-        var fc1Weights = Reshape(Constant(loadConstant(\"fc1-weight-float\")), Constant(new long[]{120, 256}), empty());\n-        var fc1Biases = Reshape(Constant(loadConstant(\"fc1-bias-float\")), Constant(new long[]{120}), empty());\n+        var fc1Weights = Reshape(Constant(loadConstant(\"fc1-weight-float-le\")), Constant(new long[]{120, 256}), empty());\n+        var fc1Biases = Reshape(Constant(loadConstant(\"fc1-bias-float-le\")), Constant(new long[]{120}), empty());\n@@ -97,2 +97,2 @@\n-        var fc2Weights = Reshape(Constant(loadConstant(\"fc2-weight-float\")), Constant(new long[]{84, 120}), empty());\n-        var fc2Biases = Reshape(Constant(loadConstant(\"fc2-bias-float\")), Constant(new long[]{84}), empty());\n+        var fc2Weights = Reshape(Constant(loadConstant(\"fc2-weight-float-le\")), Constant(new long[]{84, 120}), empty());\n+        var fc2Biases = Reshape(Constant(loadConstant(\"fc2-bias-float-le\")), Constant(new long[]{84}), empty());\n@@ -103,2 +103,2 @@\n-        var fc3Weights = Reshape(Constant(loadConstant(\"fc3-weight-float\")), Constant(new long[]{10, 84}), empty());\n-        var fc3Biases = Reshape(Constant(loadConstant(\"fc3-bias-float\")), Constant(new long[]{10}), empty());\n+        var fc3Weights = Reshape(Constant(loadConstant(\"fc3-weight-float-le\")), Constant(new long[]{10, 84}), empty());\n+        var fc3Biases = Reshape(Constant(loadConstant(\"fc3-bias-float-le\")), Constant(new long[]{10}), empty());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/MNISTDemo.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -99,0 +99,14 @@\n+    @CodeReflection\n+    public static Tensor<Long> indicesOfMaxPool(Tensor<Float> x) {\n+        \/\/ testing secondary output\n+        return OnnxOperators.MaxPool(x, Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),  new long[]{2}).Indices();\n+    }\n+\n+    @Test\n+    public void testIndicesOfMaxPool() throws Exception {\n+        var x = Tensor.ofShape(new long[]{2, 2, 2}, 1f, 2, 3, 4, 5, 6, 7, 8);\n+        assertEquals(\n+                indicesOfMaxPool(x),\n+                runModel(\"indicesOfMaxPool\", x));\n+    }\n+\n@@ -106,1 +120,1 @@\n-        return OnnxTransformer.transform(MethodHandles.publicLookup(),\n+        return OnnxTransformer.transform(MethodHandles.lookup(),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-�����S��)��=���=�U��g#K\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv1-bias-float","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -0,0 +1,1 @@\n+Ө��S����)��ߎ=�U�=K#g�\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv1-bias-float-le","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv1-weight-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv1-weight-float-le","binary":true,"status":"added"},{"patch":"@@ -1,1 +0,0 @@\n-�q=2Ar<J���F���,�����=��S�L)#=���<������H���9�����Q����=[��\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv2-bias-float","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -0,0 +1,1 @@\n+q�rA2=�J<�F���,���쿽S��=#)L����=���<H�������9Q�����Ž��[=\n\\ No newline at end of file\n","filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv2-bias-float-le","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv2-weight-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/conv2-weight-float-le","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc1-bias-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc1-bias-float-le","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc1-weight-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc1-weight-float-le","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc2-bias-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc2-bias-float-le","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc2-weight-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc2-weight-float-le","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc3-bias-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc3-bias-float-le","binary":true,"status":"added"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc3-weight-float","binary":true,"status":"deleted"},{"filename":"cr-examples\/onnx\/src\/test\/resources\/oracle\/code\/onnx\/fc3-weight-float-le","binary":true,"status":"added"}]}