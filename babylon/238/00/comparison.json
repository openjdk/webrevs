{"files":[{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeItem.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.util.*;\n+\n+\/**\n+ * A model transformer that normalizes blocks.\n+ * <p>\n+ * Merges redundant blocks with their predecessors, those which are unconditionally\n+ * branched to and have only one predecessor.\n+ * <p>\n+ * Removes unused block parameters.\n+ *\/\n+public final class NormalizeBlocksTransformer implements OpTransformer {\n+    final Set<Block> mergedBlocks = new HashSet<>();\n+    final Map<Block, BitSet> adjustedBlocks = new HashMap<>();\n+\n+    private NormalizeBlocksTransformer() {\n+    }\n+\n+    \/**\n+     * Transforms an operation, merging redundant blocks.\n+     *\n+     * @param op  the operation to transform\n+     * @param <O> the type of operation\n+     * @return the transformed operation\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <O extends Op> O transform(O op) {\n+        return (O) op.transform(CopyContext.create(), new NormalizeBlocksTransformer());\n+    }\n+\n+    ;\n+\n+    @Override\n+    public void apply(Block.Builder block, Block b) {\n+        \/\/ Ignore merged block\n+        if (!mergedBlocks.contains(b)) {\n+            OpTransformer.super.apply(block, b);\n+        }\n+    }\n+\n+    @Override\n+    public Block.Builder apply(Block.Builder b, Op op) {\n+        if (op instanceof CoreOp.BranchOp bop &&\n+                bop.branch().targetBlock().predecessors().size() == 1) {\n+            \/\/ Merge the successor's target block with this block, and so on\n+            \/\/ The terminal branch operation is replaced with the operations in the\n+            \/\/ successor's target block\n+            mergeBlock(b, bop);\n+            return b;\n+        } else if (op instanceof Op.BlockTerminating) {\n+            \/\/ Remove any unused block parameters and successor arguments\n+            for (Block.Reference successor : op.successors()) {\n+                Block target = successor.targetBlock();\n+                BitSet unusedParameterIndexes = adjustedBlocks.computeIfAbsent(target,\n+                        k -> adjustBlock(b, k));\n+                if (!unusedParameterIndexes.isEmpty()) {\n+                    adjustSuccessor(unusedParameterIndexes, b, successor);\n+                }\n+            }\n+        }\n+        b.op(op);\n+        return b;\n+    }\n+\n+    \/\/ Remove any unused block parameters\n+    BitSet adjustBlock(Block.Builder b, Block target) {\n+        \/\/ Determine the indexes of unused block parameters\n+        List<Block.Parameter> parameters = target.parameters();\n+        BitSet unusedParameterIndexes = parameters.stream()\n+                .filter(p -> p.uses().isEmpty())\n+                .mapToInt(Block.Parameter::index)\n+                .collect(BitSet::new, BitSet::set, BitSet::or);\n+\n+        if (!unusedParameterIndexes.isEmpty()) {\n+            \/\/ Create a new output block and remap it to the target block,\n+            \/\/ overriding any previous mapping\n+            Block.Builder adjustedBlock = b.block();\n+            b.context().mapBlock(target, adjustedBlock);\n+\n+            \/\/ Update and remap the output block parameters\n+            for (int i = 0; i < parameters.size(); i++) {\n+                if (!unusedParameterIndexes.get(i)) {\n+                    Block.Parameter parameter = parameters.get(i);\n+                    b.context().mapValue(\n+                            parameter,\n+                            adjustedBlock.parameter(parameter.type()));\n+                }\n+            }\n+        }\n+\n+        return unusedParameterIndexes;\n+    }\n+\n+    \/\/ Remove any unused successor arguments\n+    void adjustSuccessor(BitSet unusedParameterIndexes, Block.Builder b, Block.Reference successor) {\n+        \/\/ Create a new output successor and remap it\n+        List<Value> arguments = new ArrayList<>();\n+        for (int i = 0; i < successor.arguments().size(); i++) {\n+            if (!unusedParameterIndexes.get(i)) {\n+                arguments.add(b.context().getValue(successor.arguments().get(i)));\n+            }\n+        }\n+        Block.Reference adjustedSuccessor = b.context().getBlock(successor.targetBlock())\n+                .successor(arguments);\n+        b.context().mapSuccessor(successor, adjustedSuccessor);\n+    }\n+\n+    void mergeBlock(Block.Builder b, CoreOp.BranchOp bop) {\n+        Block.Reference reference = bop.branch();\n+        Block successor = reference.targetBlock();\n+        \/\/ Replace use of the successor's parameters with the reference's arguments\n+        b.context().mapValues(successor.parameters(),\n+                b.context().getValues(reference.arguments()));\n+        mergeBlock(b, successor);\n+    }\n+\n+    void mergeBlock(Block.Builder b, Block successor) {\n+        mergedBlocks.add(successor);\n+\n+        \/\/ Merge non-terminal operations\n+        for (int i = 0; i < successor.ops().size() - 1; i++) {\n+            b.op(successor.ops().get(i));\n+        }\n+\n+        \/\/ Check if subsequent successor block can be normalized\n+        apply(b, successor.terminatingOp());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/NormalizeBlocksTransformer.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-public class StringConcatTransformer implements OpTransformer {\n+public final class StringConcatTransformer implements OpTransformer {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/StringConcatTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestNormalizeBlocksTransformer\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.stream.Stream;\n+\n+public class TestNormalizeBlocksTransformer {\n+    static final String TEST1_INPUT = \"\"\"\n+            func @\"f\" (%0 : int)int -> {\n+                %1 : int = invoke @\"C::m()int\";\n+                branch ^block_1;\n+\n+              ^block_1:\n+                %2 : int = invoke %1 @\"C::m(int)int\";\n+                branch ^block_2(%2);\n+\n+              ^block_2(%3: int):\n+                %4 : int = invoke %2 %3 @\"C::m(int, int)int\";\n+                branch ^block_3(%3);\n+\n+              ^block_3(%5: int):\n+                %6 : int = invoke %4 %3 %5 @\"C::m(int, int, int)int\";\n+                branch ^block_4;\n+\n+              ^block_4:\n+                return %6;\n+            };\n+            \"\"\";\n+    static final String TEST1_EXPECTED = \"\"\"\n+            func @\"f\" (%0 : int)int -> {\n+                %1 : int = invoke @\"C::m()int\";\n+                %2 : int = invoke %1 @\"C::m(int)int\";\n+                %3 : int = invoke %2 %2 @\"C::m(int, int)int\";\n+                %4 : int = invoke %3 %2 %2 @\"C::m(int, int, int)int\";\n+                return %4;\n+            };\n+            \"\"\";\n+\n+    static final String TEST2_INPUT = \"\"\"\n+            func @\"f\" (%0 : java.lang.Object)void -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_1 ^block_3 ^block_8;\n+\n+              ^block_1:\n+                %3 : int = invoke @\"A::try_()int\";\n+                branch ^block_2;\n+\n+              ^block_2:\n+                exception.region.exit %2 ^block_6;\n+\n+              ^block_3(%4 : java.lang.RuntimeException):\n+                %5 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_4 ^block_8;\n+\n+              ^block_4:\n+                %6 : Var<java.lang.RuntimeException> = var %4 @\"e\";\n+                branch ^block_5;\n+\n+              ^block_5:\n+                exception.region.exit %5 ^block_6;\n+\n+              ^block_6:\n+                %7 : int = invoke @\"A::finally_()int\";\n+                branch ^block_7;\n+\n+              ^block_7:\n+                return;\n+\n+              ^block_8(%8 : java.lang.Throwable):\n+                %9 : int = invoke @\"A::finally_()int\";\n+                throw %8;\n+            };\n+            \"\"\";\n+    static final String TEST2_EXPECTED = \"\"\"\n+            func @\"f\" (%0 : java.lang.Object)void -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"o\";\n+                %2 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_1 ^block_2 ^block_5;\n+\n+              ^block_1:\n+                %3 : int = invoke @\"A::try_()int\";\n+                exception.region.exit %2 ^block_4;\n+\n+              ^block_2(%4 : java.lang.RuntimeException):\n+                %5 : java.lang.reflect.code.op.CoreOp$ExceptionRegion = exception.region.enter ^block_3 ^block_5;\n+\n+              ^block_3:\n+                %6 : Var<java.lang.RuntimeException> = var %4 @\"e\";\n+                exception.region.exit %5 ^block_4;\n+\n+              ^block_4:\n+                %7 : int = invoke @\"A::finally_()int\";\n+                return;\n+\n+              ^block_5(%8 : java.lang.Throwable):\n+                %9 : int = invoke @\"A::finally_()int\";\n+                throw %8;\n+            };\"\"\";\n+\n+    static final String TEST3_INPUT = \"\"\"\n+            func @\"f\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : boolean = gt %0 %1;\n+                cbranch %2 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %3 : int = constant @\"1\";\n+                branch ^block_1_1;\n+\n+              ^block_1_1:\n+                branch ^block_3(%3);\n+\n+              ^block_2:\n+                %4 : int = constant @\"-1\";\n+                branch ^block_2_1;\n+\n+              ^block_2_1:\n+                branch ^block_3(%4);\n+\n+              ^block_3(%5 : int):\n+                return %5;\n+            };\"\"\";\n+    static final String TEST3_EXPECTED = \"\"\"\n+            func @\"f\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : boolean = gt %0 %1;\n+                cbranch %2 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %3 : int = constant @\"1\";\n+                branch ^block_3(%3);\n+\n+              ^block_2:\n+                %4 : int = constant @\"-1\";\n+                branch ^block_3(%4);\n+\n+              ^block_3(%5 : int):\n+                return %5;\n+            };\n+            \"\"\";\n+\n+    static final String TEST4_INPUT = \"\"\"\n+            func @\"f\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : boolean = gt %0 %1;\n+                cbranch %2 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %3 : int = constant @\"1\";\n+                branch ^block_1_1;\n+\n+              ^block_1_1:\n+                branch ^block_3(%3, %3, %3);\n+\n+              ^block_2:\n+                %4 : int = constant @\"-1\";\n+                branch ^block_2_1;\n+\n+              ^block_2_1:\n+                branch ^block_3(%4, %4, %4);\n+\n+              ^block_3(%unused_1 : int, %5 : int, %unused_2 : int):\n+                return %5;\n+            };\"\"\";\n+    static final String TEST4_EXPECTED = \"\"\"\n+            func @\"f\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : boolean = gt %0 %1;\n+                cbranch %2 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %3 : int = constant @\"1\";\n+                branch ^block_3(%3);\n+\n+              ^block_2:\n+                %4 : int = constant @\"-1\";\n+                branch ^block_3(%4);\n+\n+              ^block_3(%5 : int):\n+                return %5;\n+            };\n+            \"\"\";\n+\n+    @DataProvider\n+    static Object[][] testModels() {\n+        return new Object[][]{\n+                parse(TEST1_INPUT, TEST1_EXPECTED),\n+                parse(TEST2_INPUT, TEST2_EXPECTED),\n+                parse(TEST3_INPUT, TEST3_EXPECTED),\n+                parse(TEST4_INPUT, TEST4_EXPECTED),\n+        };\n+    }\n+\n+    static Object[] parse(String... models) {\n+        return Stream.of(models).map(s -> OpParser.fromString(ExtendedOp.FACTORY, s).getFirst())\n+                .toArray(Object[]::new);\n+    }\n+\n+    @Test(dataProvider = \"testModels\")\n+    public void test(Op input, Op expected) {\n+        Op actual = NormalizeBlocksTransformer.transform(input);\n+        Assert.assertEquals(actual.toText(), expected.toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestNormalizeBlocksTransformer.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"}]}