{"files":[{"patch":"@@ -54,0 +54,1 @@\n+import java.lang.reflect.code.type.VarType;\n@@ -60,1 +61,0 @@\n-import java.util.Iterator;\n@@ -69,1 +69,13 @@\n-    private BytecodeGenerator() {\n+\n+    final MethodHandles.Lookup lookup;\n+    final CodeBuilder cob;\n+    final Map<Object, Label> labels;\n+    final Set<Block> catchingBlocks;\n+    final Map<Value, Slot> slots;\n+\n+    private BytecodeGenerator(MethodHandles.Lookup lookup, Liveness liveness, CodeBuilder cob) {\n+        this.lookup = lookup;\n+        this.cob = cob;\n+        this.labels = new HashMap<>();\n+        this.slots = new HashMap<>();\n+        this.catchingBlocks = new HashSet<>();\n@@ -86,1 +98,1 @@\n-            print(classBytes);\n+\/\/            print(classBytes);\n@@ -158,4 +170,2 @@\n-                        cb -> cb.transforming(new BranchCompactor(), cob -> {\n-                            ConversionContext c = new ConversionContext(lookup, liveness, cob);\n-                            generateBody(iop.body(), cob, c);\n-                        })));\n+                        cb -> cb.transforming(new BranchCompactor(), cob ->\n+                            new BytecodeGenerator(lookup, liveness, cob).generateBody(iop.body()))));\n@@ -165,58 +175,1 @@\n-    \/*\n-        Live list of slot, value, v, and value, r, after which no usage of v dominates r\n-        i.e. liveness range.\n-        Free list, once slot goes dead it is added to the free list, so it can be reused.\n-\n-        Block args need to have a fixed mapping to locals, unless the stack is used.\n-     *\/\n-\n-    static final class ConversionContext {\n-        final MethodHandles.Lookup lookup;\n-        final Liveness liveness;\n-        final CodeBuilder cb;\n-        final Map<Object, Label> labels;\n-        final Map<Block, LiveSlotSet> liveSet;\n-        Block current;\n-        final Set<Block> catchingBlocks;\n-\n-        public ConversionContext(MethodHandles.Lookup lookup, Liveness liveness, CodeBuilder cb) {\n-            this.lookup = lookup;\n-            this.liveness = liveness;\n-            this.cb = cb;\n-            this.labels = new HashMap<>();\n-            this.liveSet = new HashMap<>();\n-            this.catchingBlocks = new HashSet<>();\n-        }\n-\n-        public Label getLabel(Object b) {\n-            return labels.computeIfAbsent(b, _b -> cb.newLabel());\n-        }\n-\n-        void setCurrentBlock(Block current) {\n-            this.current = current;\n-            liveSet.computeIfAbsent(current, b -> new LiveSlotSet());\n-        }\n-\n-        LiveSlotSet liveSlotSet(Block b) {\n-            return liveSet.computeIfAbsent(b, _b -> new LiveSlotSet());\n-        }\n-\n-        LiveSlotSet liveSlotSet() {\n-            return liveSet.get(current);\n-        }\n-\n-        int getSlot(Value v) {\n-            return liveSlotSet().getSlot(v);\n-        }\n-\n-        int getOrAssignSlot(Value v, boolean assignIfUnused) {\n-            return liveSlotSet().getOrAssignSlot(v, assignIfUnused);\n-        }\n-\n-        int assignSlot(Value v) {\n-            return liveSlotSet().assignSlot(v);\n-        }\n-\n-        void freeSlot(Value v) {\n-            liveSlotSet().freeSlot(v);\n-        }\n+    private record Slot(int slot, TypeKind typeKind) {}\n@@ -224,3 +177,3 @@\n-        boolean isLastUse(Value v, Op op) {\n-            return liveness.isLastUse(v, op);\n-        }\n+    private Label getLabel(Object b) {\n+        return labels.computeIfAbsent(b, _b -> cob.newLabel());\n+    }\n@@ -228,6 +181,6 @@\n-        void freeSlotsOfOp(Op op) {\n-            for (Value v : op.operands()) {\n-                if (isLastUse(v, op)) {\n-                    freeSlot(v);\n-                }\n-            }\n+    private Slot allocateSlot(Value v) {\n+        return slots.computeIfAbsent(v, _ -> {\n+            TypeKind tk = toTypeKind(v.type());\n+            return new Slot(cob.allocateLocal(tk), tk);\n+        });\n+    }\n@@ -235,6 +188,11 @@\n-            for (Block.Reference s : op.successors()) {\n-                for (Value v : s.arguments()) {\n-                    if (isLastUse(v, op)) {\n-                        freeSlot(v);\n-                    }\n-                }\n+    private void storeIfUsed(Value v) {\n+        if (!v.uses().isEmpty()) {\n+            Slot slot = allocateSlot(v);\n+\/\/            System.out.println(\"Stored \" + hash(v) + \" in \" + slot);\n+            cob.storeInstruction(slot.typeKind(), slot.slot());\n+        } else {\n+\/\/            System.out.println(\"Popped \" + hash(v));\n+            \/\/ Only pop results from stack if the value has no further use (no valid slot)\n+            switch (toTypeKind(v.type()).slotSize()) {\n+                case 1 -> cob.pop();\n+                case 2 -> cob.pop2();\n@@ -243,0 +201,1 @@\n+    }\n@@ -244,2 +203,16 @@\n-        void transitionLiveSlotSetTo(Block successor) {\n-            liveSlotSet(successor).transitionLiveSlotSetFrom(liveSlotSet());\n+    private static String hash(Value v) {\n+        return Integer.toHexString(v.hashCode());\n+    }\n+\n+    private Slot load(Value v) {\n+        if (v instanceof Op.Result or &&\n+                or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n+\/\/            System.out.println(\"Loaded constant \" + hash(v) + \" value \" + fromValue(constantOp.value()));\n+            cob.constantInstruction(fromValue(constantOp.value()));\n+            return null;\n+        } else {\n+            Slot slot = slots.get(v);\n+\/\/            System.out.println(\"Loaded \" + hash(v) + \" from \" + slot);\n+            cob.loadInstruction(slot.typeKind(), slot.slot());\n+            return slot;\n@@ -249,4 +222,1 @@\n-    private static void processOperands(CodeBuilder cob,\n-                                        ConversionContext c,\n-                                        Op op,\n-                                        boolean isLastOpResultOnStack) {\n+    private void processOperands(Op op, boolean isLastOpResultOnStack) {\n@@ -254,9 +224,1 @@\n-            Value operand = op.operands().get(i);\n-            if (operand instanceof Op.Result or &&\n-                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n-                cob.constantInstruction(fromValue(constantOp.value()));\n-            } else {\n-                int slot = c.getSlot(operand);\n-                cob.loadInstruction(toTypeKind(operand.type()), slot);\n-            }\n+            load(op.operands().get(i));\n@@ -328,24 +290,17 @@\n-        JavaType jt = (JavaType) t;\n-        TypeElement rbt = jt.toBasicType();\n-\n-        if (rbt.equals(JavaType.INT)) {\n-            return TypeKind.IntType;\n-        } else if (rbt.equals(JavaType.LONG)) {\n-            return TypeKind.LongType;\n-        } else if (rbt.equals(JavaType.FLOAT)) {\n-            return TypeKind.FloatType;\n-        } else if (rbt.equals(JavaType.DOUBLE)) {\n-            return TypeKind.DoubleType;\n-        } else if (rbt.equals(JavaType.J_L_OBJECT)) {\n-            return TypeKind.ReferenceType;\n-        } else {\n-            throw new IllegalArgumentException(\"Bad type: \" + t);\n-        }\n-    }\n-\n-    private static void storeInstruction(CodeBuilder cob, TypeKind tk, int slot) {\n-        if (slot < 0) {\n-            \/\/ Only pop results from stack if the value has no further use (no valid slot)\n-            switch (tk.slotSize()) {\n-                case 1 -> cob.pop();\n-                case 2 -> cob.pop2();\n+        return switch (t) {\n+            case VarType vt -> toTypeKind(vt.valueType());\n+            case JavaType jt -> {\n+                TypeElement bt = jt.toBasicType();\n+                if (bt.equals(JavaType.INT)) {\n+                    yield TypeKind.IntType;\n+                } else if (bt.equals(JavaType.LONG)) {\n+                    yield TypeKind.LongType;\n+                } else if (bt.equals(JavaType.FLOAT)) {\n+                    yield TypeKind.FloatType;\n+                } else if (bt.equals(JavaType.DOUBLE)) {\n+                    yield TypeKind.DoubleType;\n+                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n+                    yield TypeKind.ReferenceType;\n+                } else {\n+                    throw new IllegalArgumentException(\"Bad type: \" + t);\n+                }\n@@ -353,3 +308,3 @@\n-        } else {\n-            cob.storeInstruction(tk, slot);\n-        }\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n@@ -358,1 +313,1 @@\n-    private static void computeExceptionRegionMembership(Body body, CodeBuilder cob, ConversionContext c) {\n+    private void computeExceptionRegionMembership(Body body) {\n@@ -383,9 +338,24 @@\n-            if (top instanceof CoreOps.BranchOp bop) {\n-                stack.push(new BlockWithActiveExceptionRegions(bop.branch().targetBlock(), bm.activeRegionStack));\n-            } else if (top instanceof CoreOps.ConditionalBranchOp cop) {\n-                stack.push(new BlockWithActiveExceptionRegions(cop.falseBranch().targetBlock(), bm.activeRegionStack));\n-                stack.push(new BlockWithActiveExceptionRegions(cop.trueBranch().targetBlock(), bm.activeRegionStack));\n-            } else if (top instanceof CoreOps.ExceptionRegionEnter er) {\n-                for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n-                    c.catchingBlocks.add(catchBlock.targetBlock());\n-                    stack.push(new BlockWithActiveExceptionRegions(catchBlock.targetBlock(), bm.activeRegionStack));\n+            switch (top) {\n+                case CoreOps.BranchOp bop ->\n+                    stack.push(new BlockWithActiveExceptionRegions(bop.branch().targetBlock(), bm.activeRegionStack));\n+                case CoreOps.ConditionalBranchOp cop -> {\n+                    stack.push(new BlockWithActiveExceptionRegions(cop.falseBranch().targetBlock(), bm.activeRegionStack));\n+                    stack.push(new BlockWithActiveExceptionRegions(cop.trueBranch().targetBlock(), bm.activeRegionStack));\n+                }\n+                case CoreOps.ExceptionRegionEnter er -> {\n+                    for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n+                        catchingBlocks.add(catchBlock.targetBlock());\n+                        stack.push(new BlockWithActiveExceptionRegions(catchBlock.targetBlock(), bm.activeRegionStack));\n+                    }\n+                    BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                    activeRegionStack.set(allRegions.size());\n+                    ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n+                    allRegions.add(newNode);\n+                    stack.push(new BlockWithActiveExceptionRegions(er.start().targetBlock(), activeRegionStack));\n+                }\n+                case CoreOps.ExceptionRegionExit er -> {\n+                    BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n+                    activeRegionStack.clear(activeRegionStack.length() - 1);\n+                    stack.push(new BlockWithActiveExceptionRegions(er.end().targetBlock(), activeRegionStack));\n+                }\n+                default -> {\n@@ -393,9 +363,0 @@\n-                BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n-                activeRegionStack.set(allRegions.size());\n-                ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n-                allRegions.add(newNode);\n-                stack.push(new BlockWithActiveExceptionRegions(er.start().targetBlock(), activeRegionStack));\n-            } else if (top instanceof CoreOps.ExceptionRegionExit er) {\n-                BitSet activeRegionStack = (BitSet)bm.activeRegionStack.clone();\n-                activeRegionStack.clear(activeRegionStack.length() - 1);\n-                stack.push(new BlockWithActiveExceptionRegions(er.end().targetBlock(), activeRegionStack));\n@@ -410,2 +371,2 @@\n-                Label startLabel = c.getLabel(blocks.get(start));\n-                Label endLabel = c.getLabel(blocks.get(end));\n+                Label startLabel = getLabel(blocks.get(start));\n+                Label endLabel = getLabel(blocks.get(end));\n@@ -417,1 +378,1 @@\n-                        cob.exceptionCatch(startLabel, endLabel, c.getLabel(cb), type);\n+                        cob.exceptionCatch(startLabel, endLabel, getLabel(cb), type);\n@@ -419,1 +380,1 @@\n-                        cob.exceptionCatchAll(startLabel, endLabel, c.getLabel(cb));\n+                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cb));\n@@ -427,2 +388,2 @@\n-    private static void generateBody(Body body, CodeBuilder cob, ConversionContext c) {\n-        computeExceptionRegionMembership(body, cob, c);\n+    private void generateBody(Body body) {\n+        computeExceptionRegionMembership(body);\n@@ -442,2 +403,1 @@\n-            c.setCurrentBlock(b);\n-            Label blockLabel = c.getLabel(b);\n+            Label blockLabel = getLabel(b);\n@@ -448,1 +408,7 @@\n-            b.parameters().forEach(p -> c.getOrAssignSlot(p, b.isEntryBlock()));\n+            if (b.isEntryBlock()) {\n+                List<Block.Parameter> parameters = b.parameters();\n+                for (int i = 0; i < parameters.size(); i++) {\n+                    Block.Parameter bp = parameters.get(i);\n+                    slots.put(bp, new Slot(cob.parameterSlot(i), toTypeKind(bp.type())));\n+                }\n+            }\n@@ -451,1 +417,1 @@\n-            if (c.catchingBlocks.contains(b)) {\n+            if (catchingBlocks.contains(b)) {\n@@ -453,8 +419,1 @@\n-                Block.Parameter ex = b.parameters().get(0);\n-                \/\/ Store in slot if used, otherwise pop\n-                if (!ex.uses().isEmpty()) {\n-                    int slot = c.getSlot(ex);\n-                    storeInstruction(cob, toTypeKind(ex.type()), slot);\n-                } else {\n-                    cob.pop();\n-                }\n+                storeIfUsed(b.parameters().get(0));\n@@ -471,0 +430,1 @@\n+\/\/                System.out.println(o.getClass().getSimpleName() + \" result: \" + hash(o.result()));\n@@ -484,1 +444,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -487,2 +447,1 @@\n-                        int slot = c.assignSlot(op.result());\n-                        storeInstruction(cob, toTypeKind(op.varType()), slot);\n+                        storeIfUsed(op.result());\n@@ -494,3 +453,4 @@\n-                        int slot = c.getSlot(op.operands().get(0));\n-                        CoreOps.VarOp vop = op.varOp();\n-                        cob.loadInstruction(toTypeKind(vop.varType()), slot);\n+                        Slot slot = load(op.operands().get(0));\n+                        if (slot != null) {\n+                            slots.putIfAbsent(op.result(), slot);\n+                        }\n@@ -500,9 +460,1 @@\n-                            Value operand = op.operands().get(1);\n-                            if (operand instanceof Op.Result or &&\n-                                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                                    !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n-                                cob.constantInstruction(fromValue(constantOp.value()));\n-                            } else {\n-                                int slot = c.getSlot(operand);\n-                                cob.loadInstruction(toTypeKind(operand.type()), slot);\n-                            }\n+                            load(op.operands().get(1));\n@@ -512,3 +464,6 @@\n-                        int slot = c.getSlot(op.operands().get(0));\n-                        CoreOps.VarOp vop = op.varOp();\n-                        storeInstruction(cob, toTypeKind(vop.varType()), slot);\n+                        storeIfUsed(op.operands().get(0));\n+                    }\n+                    case ConvOp op -> {\n+                        processOperands(op, isLastOpResultOnStack);\n+                        TypeKind tk = toTypeKind(op.operands().get(0).type());\n+                        if (tk != rvt) cob.convertInstruction(tk, rvt);\n@@ -517,1 +472,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -527,1 +482,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -531,1 +486,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -541,1 +496,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -551,1 +506,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -561,1 +516,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -571,1 +526,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -581,1 +536,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -589,1 +544,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -597,1 +552,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -605,1 +560,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -609,1 +564,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -614,1 +569,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -619,2 +574,2 @@\n-                            processOperands(cob, c, op, isLastOpResultOnStack);\n-                            cob.ifThenElse(prepareReverseCondition(cob, op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                            processOperands(op, isLastOpResultOnStack);\n+                            cob.ifThenElse(prepareReverseCondition(op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n@@ -632,2 +587,1 @@\n-                                    int slot = c.assignSlot(oprOnStack);\n-                                    storeInstruction(cob, rvt, slot);\n+                                    storeIfUsed(oprOnStack);\n@@ -639,1 +593,1 @@\n-                                processOperands(cob, c, op, false);\n+                                processOperands(op, false);\n@@ -647,1 +601,1 @@\n-                                processOperands(cob, c, op, isLastOpResultOnStack);\n+                                processOperands(op, isLastOpResultOnStack);\n@@ -656,1 +610,1 @@\n-                                processOperands(cob, c, op, isLastOpResultOnStack);\n+                                processOperands(op, isLastOpResultOnStack);\n@@ -662,1 +616,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -670,1 +624,1 @@\n-                            descKind = resolveToMethodHandleDesc(c.lookup, op.invokeDescriptor()).kind();\n+                            descKind = resolveToMethodHandleDesc(lookup, op.invokeDescriptor()).kind();\n@@ -702,1 +656,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -717,1 +671,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -733,1 +687,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -737,1 +691,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -743,2 +697,0 @@\n-                \/\/ Free up slots for values that are no longer live\n-                c.freeSlotsOfOp(o);\n@@ -750,2 +702,1 @@\n-                        int slot = c.assignSlot(o.result());\n-                        storeInstruction(cob, rvt, slot);\n+                        storeIfUsed(o.result());\n@@ -759,1 +710,0 @@\n-            c.freeSlotsOfOp(top);\n@@ -766,1 +716,1 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        processOperands(op, isLastOpResultOnStack);\n@@ -771,1 +721,1 @@\n-                    processOperands(cob, c, op, isLastOpResultOnStack);\n+                    processOperands(op, isLastOpResultOnStack);\n@@ -775,2 +725,2 @@\n-                    assignBlockArguments(op, op.branch(), cob, c);\n-                    cob.goto_(c.getLabel(op.branch().targetBlock()));\n+                    assignBlockArguments(op.branch());\n+                    cob.goto_(getLabel(op.branch().targetBlock()));\n@@ -781,2 +731,2 @@\n-                        processOperands(cob, c, btop, isLastOpResultOnStack);\n-                        conditionalBranch(cob, c, btop, op.trueBranch(), op.falseBranch());\n+                        processOperands(btop, isLastOpResultOnStack);\n+                        conditionalBranch(btop, op.trueBranch(), op.falseBranch());\n@@ -784,2 +734,2 @@\n-                        processOperands(cob, c, op, isLastOpResultOnStack);\n-                        conditionalBranch(cob, c, Opcode.IFEQ, op, op.trueBranch(), op.falseBranch());\n+                        processOperands(op, isLastOpResultOnStack);\n+                        conditionalBranch(Opcode.IFEQ, op, op.trueBranch(), op.falseBranch());\n@@ -789,4 +739,1 @@\n-                    assignBlockArguments(op, op.start(), cob, c);\n-                    for (Block.Reference catchBlock : op.catchBlocks()) {\n-                        c.transitionLiveSlotSetTo(catchBlock.targetBlock());\n-                    }\n+                    assignBlockArguments(op.start());\n@@ -795,2 +742,2 @@\n-                    assignBlockArguments(op, op.end(), cob, c);\n-                    cob.goto_(c.getLabel(op.end().targetBlock()));\n+                    assignBlockArguments(op.end());\n+                    cob.goto_(getLabel(op.end().targetBlock()));\n@@ -804,141 +751,0 @@\n-    static final class LiveSlotSet {\n-        final Map<Value, Integer> liveSet;\n-        final BitSet freeSlots;\n-\n-        public LiveSlotSet() {\n-            this.liveSet = new HashMap<>();\n-            this.freeSlots = new BitSet();\n-        }\n-\n-        void transitionLiveSlotSetFrom(LiveSlotSet that) {\n-            freeSlots.or(that.freeSlots);\n-\n-            \/\/ Filter dead values, those whose slots have been freed\n-            Iterator<Map.Entry<Value, Integer>> slots = that.liveSet.entrySet().iterator();\n-            while (slots.hasNext()) {\n-                var slot = slots.next();\n-                if (!freeSlots.get(slot.getValue())) {\n-                    liveSet.put(slot.getKey(), slot.getValue());\n-                }\n-            }\n-        }\n-\n-        int getSlot(Value v) {\n-            Integer slot = liveSet.get(v);\n-            if (slot == null) {\n-                throw new IllegalArgumentException(\"Value is not assigned a slot\");\n-            }\n-\n-            return slot;\n-        }\n-\n-        int assignSlot(Value v) {\n-            if (liveSet.containsKey(v)) {\n-                throw new IllegalArgumentException(\"Value is assigned a slot\");\n-            }\n-\n-            \/\/ If no uses then no slot is assigned\n-            Set<Op.Result> uses = v.uses();\n-            if (uses.isEmpty()) {\n-                \/\/ @@@\n-                return -1;\n-            }\n-\n-            \/\/ Find a free slot\n-            int slot = findSlot(slotsPerValue(v));\n-\n-            liveSet.put(v, slot);\n-            return slot;\n-        }\n-\n-        int getOrAssignSlot(Value v) {\n-            return getOrAssignSlot(v, false);\n-        }\n-\n-        int getOrAssignSlot(Value v, boolean assignIfUnused) {\n-            \/\/ If value is already active return slot\n-            Integer slotBox = liveSet.get(v);\n-            if (slotBox != null) {\n-                \/\/ Remove any free slot if present for reassignment\n-                freeSlots.clear(slotBox);\n-                if (slotsPerValue(v) == 2) {\n-                    freeSlots.clear(slotBox + 1);\n-                }\n-                return slotBox;\n-            }\n-\n-            \/\/ If no users then no slot is assigned\n-            Set<Op.Result> users = v.uses();\n-            if (!assignIfUnused && users.isEmpty()) {\n-                \/\/ @@@\n-                return -1;\n-            }\n-\n-            \/\/ Find a free slot\n-            int slot = findSlot(slotsPerValue(v));\n-\n-            liveSet.put(v, slot);\n-            return slot;\n-        }\n-\n-        private int findSlot(int nSlots) {\n-            if (freeSlots.isEmpty()) {\n-                return createNewSlot();\n-            } else if (nSlots == 1) {\n-                int slot = freeSlots.nextSetBit(0);\n-                freeSlots.clear(slot);\n-                return slot;\n-            } else {\n-                assert nSlots == 2;\n-                \/\/ Find first 2 contiguous slots\n-                int slot = 0;\n-                slot = freeSlots.nextSetBit(slot);\n-                while (slot != -1) {\n-                    int next = freeSlots.nextSetBit(slot + 1);\n-                    if (next - slot == 1) {\n-                        freeSlots.clear(slot);\n-                        freeSlots.clear(next);\n-                        return slot;\n-                    }\n-\n-                    slot = next;\n-                }\n-                return createNewSlot();\n-            }\n-        }\n-\n-        private int createNewSlot() {\n-            int slot = 0;\n-            if (!liveSet.isEmpty()) {\n-                \/\/ @@@ this is inefficient, track mox slot value\n-                Map.Entry<Value, Integer> e = liveSet.entrySet().stream().reduce((e1, e2) -> {\n-                    return e1.getValue() >= e2.getValue()\n-                            ? e1 : e2;\n-                }).get();\n-                slot = e.getValue() + slotsPerValue(e.getKey());\n-            }\n-            return slot;\n-        }\n-\n-        void freeSlot(Value v) {\n-            \/\/ Add the value's slot to the free list, if present\n-            \/\/ The value and slot are still preserved in the live set,\n-            \/\/ so slots can still be queried, but no slots should be assigned\n-            \/\/ to new values until it is safe to do so\n-\/\/@@@ BytecodeLift does not handle slot overrides correctly yet\n-\/\/            Integer slot = liveSet.get(v);\n-\/\/            if (slot != null) {\n-\/\/                freeSlots.set(slot);\n-\/\/                if (slotsPerValue(v) == 2) {\n-\/\/                    freeSlots.set(slot + 1);\n-\/\/                }\n-\/\/            }\n-        }\n-\n-        static int slotsPerValue(Value x) {\n-            return x.type().equals(JavaType.DOUBLE) || x.type().equals(JavaType.LONG)\n-                    ? 2\n-                    : 1;\n-        }\n-    }\n-\n@@ -969,3 +775,2 @@\n-    private static void conditionalBranch(CodeBuilder cob, ConversionContext c, BinaryTestOp op,\n-                                          Block.Reference trueBlock, Block.Reference falseBlock) {\n-        conditionalBranch(cob, c, prepareReverseCondition(cob, op), op, trueBlock, falseBlock);\n+    private void conditionalBranch(BinaryTestOp op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        conditionalBranch(prepareReverseCondition(op), op, trueBlock, falseBlock);\n@@ -974,4 +779,3 @@\n-    private static void conditionalBranch(CodeBuilder cob, ConversionContext c, Opcode reverseOpcode, Op op,\n-                                          Block.Reference trueBlock, Block.Reference falseBlock) {\n-        if (!needToAssignBlockArguments(falseBlock.targetBlock(), c)) {\n-            cob.branchInstruction(reverseOpcode, c.getLabel(falseBlock.targetBlock()));\n+    private void conditionalBranch(Opcode reverseOpcode, Op op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        if (!needToAssignBlockArguments(falseBlock)) {\n+            cob.branchInstruction(reverseOpcode, getLabel(falseBlock.targetBlock()));\n@@ -981,2 +785,2 @@\n-                    assignBlockArguments(op, falseBlock, bb, c);\n-                    bb.goto_(c.getLabel(falseBlock.targetBlock()));\n+                    assignBlockArguments(falseBlock);\n+                    bb.goto_(getLabel(falseBlock.targetBlock()));\n@@ -985,2 +789,2 @@\n-        assignBlockArguments(op, trueBlock, cob, c);\n-        cob.goto_(c.getLabel(trueBlock.targetBlock()));\n+        assignBlockArguments(trueBlock);\n+        cob.goto_(getLabel(trueBlock.targetBlock()));\n@@ -989,20 +793,23 @@\n-    private static Opcode prepareReverseCondition(CodeBuilder cob, BinaryTestOp op) {\n-        TypeKind vt = toTypeKind(op.operands().get(0).type());\n-        if (vt == TypeKind.IntType) {\n-            return switch (op) {\n-                case EqOp _ -> Opcode.IF_ICMPNE;\n-                case NeqOp _ -> Opcode.IF_ICMPEQ;\n-                case GtOp _ -> Opcode.IF_ICMPLE;\n-                case GeOp _ -> Opcode.IF_ICMPLT;\n-                case LtOp _ -> Opcode.IF_ICMPGE;\n-                case LeOp _ -> Opcode.IF_ICMPGT;\n-                default ->\n-                    throw new UnsupportedOperationException(op.opName());\n-            };\n-        } else {\n-            switch (vt) {\n-                case FloatType -> cob.fcmpg(); \/\/ FCMPL?\n-                case LongType -> cob.lcmp();\n-                case DoubleType -> cob.dcmpg(); \/\/CMPL?\n-                default ->\n-                    throw new UnsupportedOperationException(op.opName() + \" on \" + vt);\n+    private Opcode prepareReverseCondition(BinaryTestOp op) {\n+        return switch (toTypeKind(op.operands().get(0).type())) {\n+            case IntType ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ICMPNE;\n+                    case NeqOp _ -> Opcode.IF_ICMPEQ;\n+                    case GtOp _ -> Opcode.IF_ICMPLE;\n+                    case GeOp _ -> Opcode.IF_ICMPLT;\n+                    case LtOp _ -> Opcode.IF_ICMPGE;\n+                    case LeOp _ -> Opcode.IF_ICMPGT;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                };\n+            case ReferenceType ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ACMPNE;\n+                    case NeqOp _ -> Opcode.IF_ACMPEQ;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                };\n+            case FloatType -> {\n+                cob.fcmpg(); \/\/ FCMPL?\n+                yield reverseIfOpcode(op);\n@@ -1010,11 +817,11 @@\n-            return switch (op) {\n-                case EqOp _ -> Opcode.IFNE;\n-                case NeqOp _ -> Opcode.IFEQ;\n-                case GtOp _ -> Opcode.IFLE;\n-                case GeOp _ -> Opcode.IFLT;\n-                case LtOp _ -> Opcode.IFGE;\n-                case LeOp _ -> Opcode.IFGT;\n-                default ->\n-                    throw new UnsupportedOperationException(op.opName());\n-            };\n-        }\n+            case LongType -> {\n+                cob.lcmp();\n+                yield reverseIfOpcode(op);\n+            }\n+            case DoubleType -> {\n+                cob.dcmpg(); \/\/CMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            default ->\n+                throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+        };\n@@ -1023,6 +830,22 @@\n-    private static boolean needToAssignBlockArguments(Block b, ConversionContext c) {\n-        c.transitionLiveSlotSetTo(b);\n-        LiveSlotSet liveSlots = c.liveSlotSet(b);\n-        for (Block.Parameter barg : b.parameters()) {\n-            if (liveSlots.getOrAssignSlot(barg) >= 0) {\n-                return true;\n+    private static Opcode reverseIfOpcode(BinaryTestOp op) {\n+        return switch (op) {\n+            case EqOp _ -> Opcode.IFNE;\n+            case NeqOp _ -> Opcode.IFEQ;\n+            case GtOp _ -> Opcode.IFLE;\n+            case GeOp _ -> Opcode.IFLT;\n+            case LtOp _ -> Opcode.IFGE;\n+            case LeOp _ -> Opcode.IFGT;\n+            default ->\n+                throw new UnsupportedOperationException(op.opName());\n+        };\n+    }\n+\n+    private boolean needToAssignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+        boolean need = false;\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(sargs.get(i))) {\n+                need = true;\n+                allocateSlot(barg);\n@@ -1031,1 +854,1 @@\n-        return false;\n+        return need;\n@@ -1034,9 +857,3 @@\n-    private static void assignBlockArguments(Op op, Block.Reference s, CodeBuilder cob, ConversionContext c) {\n-        List<Value> sargs = s.arguments();\n-        List<Block.Parameter> bargs = s.targetBlock().parameters();\n-\n-        \/\/ Transition over live-out to successor block\n-        \/\/ All predecessors of successor will have the same live-out set so it does not\n-        \/\/ matter which predecessor performs this action\n-        c.transitionLiveSlotSetTo(s.targetBlock());\n-\n+    private void assignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n@@ -1045,2 +862,0 @@\n-\n-        LiveSlotSet liveSlots = c.liveSlotSet(s.targetBlock());\n@@ -1049,19 +864,4 @@\n-            int bslot = liveSlots.getOrAssignSlot(barg);\n-            if (bslot >= 0) {\n-                Value value = sargs.get(i);\n-                if (value instanceof Op.Result or &&\n-                        or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                        !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n-                    cob.constantInstruction(fromValue(constantOp.value()));\n-                    TypeKind vt = toTypeKind(barg.type());\n-                    cob.storeInstruction(vt, bslot);\n-                } else {\n-                    int sslot = c.getSlot(value);\n-\n-                    \/\/ Assignment only required if slots differ\n-                    if (sslot != bslot) {\n-                        TypeKind vt = toTypeKind(barg.type());\n-                        cob.loadInstruction(vt, sslot);\n-                        cob.storeInstruction(vt, bslot);\n-                    }\n-                }\n+            Value value = sargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(value)) {\n+                load(value);\n+                storeIfUsed(barg);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":242,"deletions":442,"binary":false,"changes":684,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Attributes;\n@@ -31,0 +32,1 @@\n+import java.lang.classfile.Instruction;\n@@ -35,1 +37,1 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n@@ -39,0 +41,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -47,1 +50,0 @@\n-import java.lang.reflect.code.op.CoreOps.ExceptionRegionEnter;\n@@ -52,1 +54,0 @@\n-import java.util.BitSet;\n@@ -58,0 +59,1 @@\n+import java.util.stream.Collectors;\n@@ -59,0 +61,4 @@\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.constant.MethodTypeDesc;\n+\n@@ -62,1 +68,73 @@\n-    private BytecodeLift() {\n+    private final Block.Builder entryBlock;\n+    private final CodeModel codeModel;\n+    private final Map<Label, Block.Builder> blockMap;\n+    private final Map<String, Op.Result> varMap;\n+    private final Deque<Value> stack;\n+    private Block.Builder currentBlock;\n+\n+    private static String varName(int slot, TypeKind tk) {\n+        return tk.typeName() + slot;\n+    }\n+\n+    private static TypeElement toTypeElement(StackMapFrameInfo.VerificationTypeInfo vti) {\n+        return switch (vti) {\n+            case ITEM_INTEGER -> JavaType.INT;\n+            case ITEM_FLOAT -> JavaType.FLOAT;\n+            case ITEM_DOUBLE -> JavaType.DOUBLE;\n+            case ITEM_LONG -> JavaType.LONG;\n+            case ITEM_NULL -> JavaType.J_L_OBJECT;\n+            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                    JavaType.ofNominalDescriptor(ovti.classSymbol());\n+            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n+                    JavaType.J_L_OBJECT;\n+            default ->\n+                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+\n+        };\n+    }\n+\n+    private TypeElement toTypeElement(ClassEntry ce) {\n+        return JavaType.ofNominalDescriptor(ce.asSymbol());\n+    }\n+\n+    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel) {\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            throw new IllegalArgumentException(\"Unsuported lift of non-static method: \" + methodModel);\n+        }\n+        this.entryBlock = entryBlock;\n+        this.currentBlock = entryBlock;\n+        this.codeModel = methodModel.code().orElseThrow();\n+        this.varMap = new HashMap<>();\n+        this.stack = new ArrayDeque<>();\n+        List<Block.Parameter> bps = entryBlock.parameters();\n+        List<ClassDesc> mps = methodModel.methodTypeSymbol().parameterList();\n+        for (int i = 0, slot = 0; i < bps.size(); i++) {\n+            TypeKind tk = TypeKind.from(mps.get(i)).asLoadable();\n+            varStore(slot, tk, bps.get(i));\n+            slot += tk.slotSize();\n+        }\n+        this.blockMap = codeModel.findAttribute(Attributes.STACK_MAP_TABLE).map(sma ->\n+                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        smfi -> entryBlock.block(smfi.stack().stream().map(BytecodeLift::toTypeElement).toList())))).orElse(Map.of());\n+    }\n+\n+    private void varStore(int slot, TypeKind tk, Value value) {\n+        varMap.compute(varName(slot, tk), (varName, var) -> {\n+            if (var == null) {\n+                return op(CoreOps.var(varName, value));\n+            } else {\n+                op(CoreOps.varStore(var, value));\n+                return var;\n+            }\n+        });\n+    }\n+\n+    private Op.Result var(int slot, TypeKind tk) {\n+        Op.Result r = varMap.get(varName(slot, tk));\n+        if (r == null) throw new IllegalArgumentException(\"Undeclared variable: \" + slot + \"-\" + tk); \/\/ @@@ these cases may need lazy var injection\n+        return r;\n+    }\n+\n+    private Op.Result op(Op op) {\n+        return currentBlock.op(op);\n@@ -67,0 +145,4 @@\n+        return lift(classdata, methodName, null);\n+    }\n+\n+    public static CoreOps.FuncOp lift(byte[] classdata, String methodName, MethodTypeDesc methodType) {\n@@ -70,1 +152,1 @@\n-                        .filter(mm -> mm.methodName().equalsString(methodName))\n+                        .filter(mm -> mm.methodName().equalsString(methodName) && (methodType == null || mm.methodTypeSymbol().equals(methodType)))\n@@ -75,1 +157,0 @@\n-        FunctionType mt = MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol());\n@@ -78,1 +159,15 @@\n-                mt).body(entryBlock -> {\n+                MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock ->\n+                        new BytecodeLift(entryBlock, methodModel).lift());\n+    }\n+\n+    private Block.Builder getBlock(Label l) {\n+        Block.Builder bb = blockMap.get(l);\n+        if (bb == null) {\n+            if (currentBlock == null) {\n+                throw new IllegalArgumentException(\"Block without an stack frame detected.\");\n+            } else {\n+                return newBlock();\n+            }\n+        }\n+        return bb;\n+    }\n@@ -80,4 +175,3 @@\n-            final CodeModel codeModel = methodModel.code().orElseThrow();\n-            final HashMap<Label, Block.Builder> blockMap = new HashMap<>();\n-            final HashMap<Label, Map<Integer, Op.Result>> localsMap = new HashMap<>();\n-            final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n+    private Block.Builder newBlock() {\n+        return entryBlock.block(stack.stream().map(Value::type).toList());\n+    }\n@@ -85,3 +179,8 @@\n-            Block.Builder currentBlock = entryBlock;\n-            final Deque<Value> stack = new ArrayDeque<>();\n-            Map<Integer, Op.Result> locals = new HashMap<>();\n+    private void moveTo(Block.Builder next) {\n+        currentBlock = next;\n+        \/\/ Stack is reconstructed from block parameters\n+        stack.clear();\n+        if (currentBlock != null) {\n+            currentBlock.parameters().forEach(stack::add);\n+        }\n+    }\n@@ -89,6 +188,5 @@\n-            int varIndex = 0;\n-            \/\/ Initialize local variables from entry block parameters\n-            for (Block.Parameter bp : entryBlock.parameters()) {\n-                \/\/ @@@ Reference type\n-                locals.put(varIndex, entryBlock.op(CoreOps.var(Integer.toString(varIndex++), bp)));\n-            }\n+    private void endOfFlow() {\n+        currentBlock = null;\n+        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+        stack.clear();\n+    }\n@@ -96,75 +194,29 @@\n-            final List<CodeElement> elements = codeModel.elementList();\n-            final BitSet visited = new BitSet();\n-            int initiallyResolved; \/\/ This is counter helping to determine if the remaining code is not accessible (\"dead\")\n-            while ((initiallyResolved = visited.cardinality()) < elements.size()) {\n-                for (int i = visited.nextClearBit(0); i < elements.size();) {\n-                    \/\/ We start from the first unvisited instruction and mark it as visited\n-                    visited.set(i);\n-                    switch (elements.get(i)) {\n-                        case ExceptionCatch ec -> {\n-                            \/\/ Exception blocks are inserted by label target (below)\n-                        }\n-                        case LabelTarget lt -> {\n-                            \/\/ Start of a new block\n-                            Block.Builder next = blockMap.get(lt.label());\n-                            if (currentBlock != null) {\n-                                \/\/ Flow has not been interrupted and we can build next block based on the actual stack and locals\n-                                if (next == null) {\n-                                    \/\/ New block parameter types are calculated from the actual stack\n-                                    next = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                    blockMap.put(lt.label(), next);\n-                                    localsMap.put(lt.label(), locals);\n-                                }\n-                                \/\/ Implicit goto next block, add explicitly\n-                                \/\/ Use stack content as next block arguments\n-                                currentBlock.op(CoreOps.branch(next.successor(List.copyOf(stack))));\n-                            }\n-                            if (next != null) {\n-                                \/\/ We know the next block so we can continue\n-                                currentBlock = next;\n-                                \/\/ Stack is reconstructed from block parameters\n-                                stack.clear();\n-                                locals = localsMap.get(lt.label());\n-                                currentBlock.parameters().forEach(stack::add);\n-                                \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n-                                for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n-                                    if (lt.label() == ec.tryStart()) {\n-                                        \/\/ Get or create handler with the exception as parameter\n-                                        Block.Builder handler = blockMap.computeIfAbsent(ec.handler(), _ ->\n-                                                entryBlock.block(List.of(JavaType.ofNominalDescriptor(\n-                                                        ec.catchType().map(ClassEntry::asSymbol).orElse(ConstantDescs.CD_Throwable)))));\n-                                        localsMap.putIfAbsent(ec.handler(), locals);\n-                                        \/\/ Create start block\n-                                        next = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                        ExceptionRegionEnter ere = CoreOps.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor());\n-                                        currentBlock.op(ere);\n-                                        \/\/ Store ERE into map for exit\n-                                        exceptionRegionsMap.put(ec, ere.result());\n-                                        currentBlock = next;\n-                                        \/\/ Stack is reconstructed from block parameters\n-                                        stack.clear();\n-                                        currentBlock.parameters().forEach(stack::add);\n-                                    }\n-                                }\n-                                \/\/ Insert relevant tryEnd blocks in normal order\n-                                for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n-                                    if (lt.label() == ec.tryEnd()) {\n-                                        \/\/ Create exit block with parameters constructed from the stack\n-                                        next = entryBlock.block(stack.stream().map(Value::type).toList());\n-                                        currentBlock.op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor()));\n-                                        currentBlock = next;\n-                                        \/\/ Stack is reconstructed from block parameters\n-                                        stack.clear();\n-                                        currentBlock.parameters().forEach(stack::add);\n-                                    }\n-                                }\n-                            } else {\n-                                \/\/ Here we do not know the next block parameters, stack and locals\n-                                \/\/ so we make it unvisited\n-                                visited.clear(i);\n-                                \/\/ interrupt the flow\n-                                currentBlock = null;\n-                                stack.clear();\n-                                \/\/ and skip to a next block\n-                                while (i < elements.size() - 1 && !(elements.get(i + 1) instanceof LabelTarget)) i++;\n-                            }\n+    private void lift() {\n+        final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n+\n+        List<CodeElement> elements = codeModel.elementList();\n+        for (int i = 0; i < elements.size(); i++) {\n+            switch (elements.get(i)) {\n+                case ExceptionCatch _ -> {\n+                    \/\/ Exception blocks are inserted by label target (below)\n+                }\n+                case LabelTarget lt -> {\n+                    \/\/ Start of a new block\n+                    Block.Builder next = getBlock(lt.label());\n+                    if (currentBlock != null) {\n+                        \/\/ Implicit goto next block, add explicitly\n+                        \/\/ Use stack content as next block arguments\n+                        op(CoreOps.branch(next.successor(List.copyOf(stack))));\n+                    }\n+                    moveTo(next);\n+                    \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n+                    for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                        if (lt.label() == ec.tryStart()) {\n+                            Block.Builder handler = getBlock(ec.handler());\n+                            \/\/ Create start block\n+                            next = newBlock();\n+                            Op ere = CoreOps.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor());\n+                            op(ere);\n+                            \/\/ Store ERE into map for exit\n+                            exceptionRegionsMap.put(ec, ere.result());\n+                            moveTo(next);\n@@ -172,8 +224,8 @@\n-                        case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n-                            \/\/ Get or create target block with parameters constructed from the stack\n-                            currentBlock.op(CoreOps.branch(blockMap.computeIfAbsent(inst.target(), _ ->\n-                                    entryBlock.block(stack.stream().map(Value::type).toList())).successor(List.copyOf(stack))));\n-                            localsMap.putIfAbsent(inst.target(), locals);\n-                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                            stack.clear();\n-                            currentBlock = null;\n+                    }\n+                    \/\/ Insert relevant tryEnd blocks in normal order\n+                    for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                        if (lt.label() == ec.tryEnd()) {\n+                            \/\/ Create exit block with parameters constructed from the stack\n+                            next = newBlock();\n+                            op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor()));\n+                            moveTo(next);\n@@ -181,20 +233,137 @@\n-                        case BranchInstruction inst -> {\n-                            \/\/ Conditional branch\n-                            Value operand = stack.pop();\n-                            Op cop = switch (inst.opcode()) {\n-                                case IFNE -> CoreOps.eq(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n-                                case IFEQ -> CoreOps.neq(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n-                                case IFGE -> CoreOps.lt(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n-                                case IFLE -> CoreOps.gt(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n-                                case IFGT -> CoreOps.le(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n-                                case IFLT -> CoreOps.ge(operand, currentBlock.op(CoreOps.constant(JavaType.INT, 0)));\n-                                case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n-                                case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n-                                case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n-                                case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n-                                case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n-                                case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n-                                default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n-                            };\n-                            if (!stack.isEmpty()) {\n-                                throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                    }\n+                }\n+                case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                    op(CoreOps.branch(getBlock(inst.target()).successor(List.copyOf(stack))));\n+                    endOfFlow();\n+                }\n+                case BranchInstruction inst -> {\n+                    \/\/ Conditional branch\n+                    Value operand = stack.pop();\n+                    Op cop = switch (inst.opcode()) {\n+                        case IFNE -> CoreOps.eq(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFEQ -> CoreOps.neq(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFGE -> CoreOps.lt(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFLE -> CoreOps.gt(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFGT -> CoreOps.le(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFLT -> CoreOps.ge(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFNULL -> CoreOps.neq(operand, op(CoreOps.constant(JavaType.J_L_OBJECT, Op.NULL_ATTRIBUTE_VALUE)));\n+                        case IFNONNULL -> CoreOps.eq(operand, op(CoreOps.constant(JavaType.J_L_OBJECT, Op.NULL_ATTRIBUTE_VALUE)));\n+                        case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n+                        case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                        case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n+                        case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n+                        case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n+                        case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n+                        case IF_ACMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                        case IF_ACMPNE -> CoreOps.eq(stack.pop(), operand);\n+                        default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                    };\n+                    if (!stack.isEmpty()) {\n+                        throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                    }\n+                    Block.Builder next = currentBlock.block();\n+                    op(CoreOps.conditionalBranch(op(cop),\n+                            next.successor(),\n+                            getBlock(inst.target()).successor()));\n+                    moveTo(next);\n+                }\n+    \/\/                case LookupSwitchInstruction si -> {\n+    \/\/                    \/\/ Default label is first successor\n+    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+    \/\/                    addSuccessors(si.cases(), blockMap, b);\n+    \/\/                }\n+    \/\/                case TableSwitchInstruction si -> {\n+    \/\/                    \/\/ Default label is first successor\n+    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+    \/\/                    addSuccessors(si.cases(), blockMap, b);\n+    \/\/                }\n+                case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                    op(CoreOps._return());\n+                    endOfFlow();\n+                }\n+                case ReturnInstruction _ -> {\n+                    op(CoreOps._return(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case ThrowInstruction _ -> {\n+                    op(CoreOps._throw(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case LoadInstruction inst -> {\n+                    stack.push(op(CoreOps.varLoad(var(inst.slot(), inst.typeKind()))));\n+                }\n+                case StoreInstruction inst -> {\n+                    varStore(inst.slot(), inst.typeKind(), stack.pop());\n+                }\n+                case IncrementInstruction inst -> {\n+                    varStore(inst.slot(), TypeKind.IntType, op(CoreOps.add(\n+                            op(CoreOps.varLoad(var(inst.slot(), TypeKind.IntType))),\n+                            op(CoreOps.constant(JavaType.INT, inst.constant())))));\n+                }\n+                case ConstantInstruction inst -> {\n+                    stack.push(op(switch (inst.constantValue()) {\n+                        case ClassDesc v -> CoreOps.constant(JavaType.J_L_CLASS, JavaType.ofNominalDescriptor(v));\n+                        case Double v -> CoreOps.constant(JavaType.DOUBLE, v);\n+                        case Float v -> CoreOps.constant(JavaType.FLOAT, v);\n+                        case Integer v -> CoreOps.constant(JavaType.INT, v);\n+                        case Long v -> CoreOps.constant(JavaType.LONG, v);\n+                        case String v -> CoreOps.constant(JavaType.J_L_STRING, v);\n+                        default ->\n+                            \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                            throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n+                    }));\n+                }\n+                case ConvertInstruction inst -> {\n+                    stack.push(op(CoreOps.conv(switch (inst.toType()) {\n+                        case ByteType -> JavaType.BYTE;\n+                        case ShortType -> JavaType.SHORT;\n+                        case IntType -> JavaType.INT;\n+                        case FloatType -> JavaType.FLOAT;\n+                        case LongType -> JavaType.LONG;\n+                        case DoubleType -> JavaType.DOUBLE;\n+                        case CharType -> JavaType.CHAR;\n+                        case BooleanType -> JavaType.BOOLEAN;\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported conversion target: \" + inst.toType());\n+                    }, stack.pop())));\n+                }\n+                case OperatorInstruction inst -> {\n+                    Value operand = stack.pop();\n+                    stack.push(op(switch (inst.opcode()) {\n+                        case IADD, LADD, FADD, DADD ->\n+                                CoreOps.add(stack.pop(), operand);\n+                        case ISUB, LSUB, FSUB, DSUB ->\n+                                CoreOps.sub(stack.pop(), operand);\n+                        case IMUL, LMUL, FMUL, DMUL ->\n+                                CoreOps.mul(stack.pop(), operand);\n+                        case IDIV, LDIV, FDIV, DDIV ->\n+                                CoreOps.div(stack.pop(), operand);\n+                        case IREM, LREM, FREM, DREM ->\n+                                CoreOps.mod(stack.pop(), operand);\n+                        case INEG, LNEG, FNEG, DNEG ->\n+                                CoreOps.neg(operand);\n+                        case ARRAYLENGTH ->\n+                                CoreOps.arrayLength(operand);\n+                        case IAND, LAND ->\n+                                CoreOps.and(stack.pop(), operand);\n+                        case IOR, LOR ->\n+                                CoreOps.or(stack.pop(), operand);\n+                        case IXOR, LXOR ->\n+                                CoreOps.xor(stack.pop(), operand);\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                    }));\n+                }\n+                case FieldInstruction inst -> {\n+                        FieldRef fd = FieldRef.field(\n+                                JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                inst.name().stringValue(),\n+                                JavaType.ofNominalDescriptor(inst.typeSymbol()));\n+                        switch (inst.opcode()) {\n+                            case GETFIELD ->\n+                                stack.push(op(CoreOps.fieldLoad(fd, stack.pop())));\n+                            case GETSTATIC ->\n+                                stack.push(op(CoreOps.fieldLoad(fd)));\n+                            case PUTFIELD -> {\n+                                Value value = stack.pop();\n+                                stack.push(op(CoreOps.fieldStore(fd, stack.pop(), value)));\n@@ -202,24 +371,4 @@\n-                            Block.Builder nextBlock = currentBlock.block();\n-                            currentBlock.op(CoreOps.conditionalBranch(currentBlock.op(cop),\n-                                    nextBlock.successor(),\n-                                    \/\/ Get or create target block\n-                                    blockMap.computeIfAbsent(inst.target(), _ ->\n-                                            entryBlock.block(stack.stream().map(Value::type).toList())).successor()));\n-                            localsMap.putIfAbsent(inst.target(), locals);\n-                            currentBlock = nextBlock;\n-                        }\n-        \/\/                case LookupSwitchInstruction si -> {\n-        \/\/                    \/\/ Default label is first successor\n-        \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-        \/\/                    addSuccessors(si.cases(), blockMap, b);\n-        \/\/                }\n-        \/\/                case TableSwitchInstruction si -> {\n-        \/\/                    \/\/ Default label is first successor\n-        \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n-        \/\/                    addSuccessors(si.cases(), blockMap, b);\n-        \/\/                }\n-                        case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n-                            currentBlock.op(CoreOps._return());\n-                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                            stack.clear();\n-                            currentBlock = null;\n+                            case PUTSTATIC ->\n+                                stack.push(op(CoreOps.fieldStore(fd, stack.pop())));\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n@@ -227,14 +376,24 @@\n-                        case ReturnInstruction _ -> {\n-                            currentBlock.op(CoreOps._return(stack.pop()));\n-                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                            stack.clear();\n-                            currentBlock = null;\n-                        }\n-                        case ThrowInstruction _ -> {\n-                            currentBlock.op(CoreOps._throw(stack.pop()));\n-                            \/\/ Flow discontinued, stack cleared to be ready for the next label target\n-                            stack.clear();\n-                            currentBlock = null;\n-                        }\n-                        case LoadInstruction inst -> {\n-                            stack.push(currentBlock.op(CoreOps.varLoad(locals.get(inst.slot()))));\n+                }\n+                case ArrayStoreInstruction _ -> {\n+                    Value value = stack.pop();\n+                    Value index = stack.pop();\n+                    op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n+                }\n+                case ArrayLoadInstruction _ -> {\n+                    Value index = stack.pop();\n+                    stack.push(op(CoreOps.arrayLoadOp(stack.pop(), index)));\n+                }\n+                case InvokeInstruction inst -> {\n+                    FunctionType mType = MethodRef.ofNominalDescriptor(inst.typeSymbol());\n+                    List<Value> operands = new ArrayList<>();\n+                    for (var _ : mType.parameterTypes()) {\n+                        operands.add(stack.pop());\n+                    }\n+                    MethodRef mDesc = MethodRef.method(\n+                            JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                            inst.name().stringValue(),\n+                            mType);\n+                    Op.Result result = switch (inst.opcode()) {\n+                        case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                            operands.add(stack.pop());\n+                            yield op(CoreOps.invoke(mDesc, operands.reversed()));\n@@ -242,5 +401,9 @@\n-                        case StoreInstruction inst -> {\n-                            Value operand = stack.pop();\n-                            Op.Result local = locals.get(inst.slot());\n-                            if (local == null) {\n-                                locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(varIndex++), operand)));\n+                        case INVOKESTATIC ->\n+                            op(CoreOps.invoke(mDesc, operands.reversed()));\n+                        case INVOKESPECIAL -> {\n+                            if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                yield op(CoreOps._new(\n+                                        FunctionType.functionType(\n+                                                mDesc.refType(),\n+                                                mType.parameterTypes()),\n+                                        operands.reversed()));\n@@ -248,83 +411,0 @@\n-                                TypeElement varType = ((CoreOps.VarOp) local.op()).varType();\n-                                if (!operand.type().equals(varType)) {\n-                                    \/\/ @@@ How to override local slots?\n-                                    locals = new HashMap<>(locals);\n-                                    locals.put(inst.slot(), currentBlock.op(CoreOps.var(Integer.toString(varIndex++), operand)));\n-                                } else {\n-                                    currentBlock.op(CoreOps.varStore(local, operand));\n-                                }\n-                            }\n-                        }\n-                        case IncrementInstruction inst -> {\n-                            Op.Result local = locals.get(inst.slot());\n-                            currentBlock.op(CoreOps.varStore(local, currentBlock.op(CoreOps.add(\n-                                    currentBlock.op(CoreOps.varLoad(local)),\n-                                    currentBlock.op(CoreOps.constant(JavaType.INT, inst.constant()))))));\n-                        }\n-                        case ConstantInstruction inst -> {\n-                            stack.push(currentBlock.op(switch (inst.constantValue()) {\n-                                case ClassDesc v -> CoreOps.constant(JavaType.J_L_CLASS, JavaType.ofNominalDescriptor(v));\n-                                case Double v -> CoreOps.constant(JavaType.DOUBLE, v);\n-                                case Float v -> CoreOps.constant(JavaType.FLOAT, v);\n-                                case Integer v -> CoreOps.constant(JavaType.INT, v);\n-                                case Long v -> CoreOps.constant(JavaType.LONG, v);\n-                                case String v -> CoreOps.constant(JavaType.J_L_STRING, v);\n-                                default ->\n-                                    \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n-                                    throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n-                            }));\n-                        }\n-                        case OperatorInstruction inst -> {\n-                            Value operand = stack.pop();\n-                            stack.push(currentBlock.op(switch (inst.opcode()) {\n-                                case IADD, LADD, FADD, DADD ->\n-                                        CoreOps.add(stack.pop(), operand);\n-                                case ISUB, LSUB, FSUB, DSUB ->\n-                                        CoreOps.sub(stack.pop(), operand);\n-                                case IMUL, LMUL, FMUL, DMUL ->\n-                                        CoreOps.mul(stack.pop(), operand);\n-                                case IDIV, LDIV, FDIV, DDIV ->\n-                                        CoreOps.div(stack.pop(), operand);\n-                                case IREM, LREM, FREM, DREM ->\n-                                        CoreOps.mod(stack.pop(), operand);\n-                                case INEG, LNEG, FNEG, DNEG ->\n-                                        CoreOps.neg(operand);\n-                                case ARRAYLENGTH ->\n-                                        CoreOps.arrayLength(operand);\n-                                default ->\n-                                    throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n-                            }));\n-                        }\n-                        case FieldInstruction inst -> {\n-                                FieldRef fd = FieldRef.field(\n-                                        JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n-                                        inst.name().stringValue(),\n-                                        JavaType.ofNominalDescriptor(inst.typeSymbol()));\n-                                switch (inst.opcode()) {\n-                                    case GETFIELD ->\n-                                        stack.push(currentBlock.op(CoreOps.fieldLoad(fd, stack.pop())));\n-                                    case GETSTATIC ->\n-                                        stack.push(currentBlock.op(CoreOps.fieldLoad(fd)));\n-                                    case PUTFIELD -> {\n-                                        Value value = stack.pop();\n-                                        stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop(), value)));\n-                                    }\n-                                    case PUTSTATIC ->\n-                                        stack.push(currentBlock.op(CoreOps.fieldStore(fd, stack.pop())));\n-                                    default ->\n-                                        throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n-                                }\n-                        }\n-                        case ArrayStoreInstruction _ -> {\n-                            Value value = stack.pop();\n-                            Value index = stack.pop();\n-                            currentBlock.op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n-                        }\n-                        case ArrayLoadInstruction _ -> {\n-                            Value index = stack.pop();\n-                            stack.push(currentBlock.op(CoreOps.arrayLoadOp(stack.pop(), index)));\n-                        }\n-                        case InvokeInstruction inst -> {\n-                            FunctionType mType = MethodRef.ofNominalDescriptor(inst.typeSymbol());\n-                            List<Value> operands = new ArrayList<>();\n-                            for (var _ : mType.parameterTypes()) {\n@@ -332,81 +412,1 @@\n-                            }\n-                            MethodRef mDesc = MethodRef.method(\n-                                    JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n-                                    inst.name().stringValue(),\n-                                    mType);\n-                            Op.Result result = switch (inst.opcode()) {\n-                                case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n-                                    operands.add(stack.pop());\n-                                    yield currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                                }\n-                                case INVOKESTATIC ->\n-                                    currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                                case INVOKESPECIAL -> {\n-                                    if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n-                                        yield currentBlock.op(CoreOps._new(\n-                                                FunctionType.functionType(\n-                                                        mType.parameterTypes().get(0),\n-                                                        mType.parameterTypes().subList(1, mType.parameterTypes().size())),\n-                                                operands.reversed()));\n-                                    } else {\n-                                        operands.add(stack.pop());\n-                                        yield currentBlock.op(CoreOps.invoke(mDesc, operands.reversed()));\n-                                    }\n-                                }\n-                                default ->\n-                                    throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n-                            };\n-                            if (!result.type().equals(JavaType.VOID)) {\n-                                stack.push(result);\n-                            }\n-                        }\n-                        case NewObjectInstruction _ -> {\n-                            \/\/ Skip over this and the dup to process the invoke special\n-                            if (i + 2 < elements.size() - 1\n-                                    && elements.get(i + 1) instanceof StackInstruction dup\n-                                    && dup.opcode() == Opcode.DUP\n-                                    && elements.get(i + 2) instanceof InvokeInstruction init\n-                                    && init.name().equalsString(ConstantDescs.INIT_NAME)) {\n-                                i++;\n-                            } else {\n-                                throw new UnsupportedOperationException(\"New must be followed by dup and invokespecial for <init>\");\n-                            }\n-                        }\n-                        case NewPrimitiveArrayInstruction inst -> {\n-                            stack.push(currentBlock.op(CoreOps.newArray(\n-                                    switch (inst.typeKind()) {\n-                                        case BooleanType -> JavaType.BOOLEAN_ARRAY;\n-                                        case ByteType -> JavaType.BYTE_ARRAY;\n-                                        case CharType -> JavaType.CHAR_ARRAY;\n-                                        case DoubleType -> JavaType.DOUBLE_ARRAY;\n-                                        case FloatType -> JavaType.FLOAT_ARRAY;\n-                                        case IntType -> JavaType.INT_ARRAY;\n-                                        case LongType -> JavaType.LONG_ARRAY;\n-                                        case ShortType -> JavaType.SHORT_ARRAY;\n-                                        default ->\n-                                                throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n-                                    },\n-                                    stack.pop())));\n-                        }\n-                        case NewReferenceArrayInstruction inst -> {\n-                            stack.push(currentBlock.op(CoreOps.newArray(\n-                                    JavaType.type(JavaType.ofNominalDescriptor(inst.componentType().asSymbol()), 1),\n-                                    stack.pop())));\n-                        }\n-                        case NewMultiArrayInstruction inst -> {\n-                            stack.push(currentBlock.op(CoreOps._new(\n-                                    FunctionType.functionType(\n-                                            JavaType.ofNominalDescriptor(inst.arrayType().asSymbol()),\n-                                            Collections.nCopies(inst.dimensions(), JavaType.INT)),\n-                                    IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n-                        }\n-                        case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n-                            stack.push(currentBlock.op(CoreOps.cast(JavaType.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n-                        }\n-                        case StackInstruction inst -> {\n-                            switch (inst.opcode()) {\n-                                case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n-                                case DUP, DUP2 -> stack.push(stack.peek());\n-                                \/\/@@@ implement all other stack ops\n-                                default ->\n-                                    throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                                yield op(CoreOps.invoke(mDesc, operands.reversed()));\n@@ -416,1 +416,4 @@\n-                            throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n+                            throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                    };\n+                    if (!result.type().equals(JavaType.VOID)) {\n+                        stack.push(result);\n@@ -418,6 +421,9 @@\n-                    if (visited.get(++i)) {\n-                        \/\/ Interrupt the flow if the following instruction has been already visited\n-                        currentBlock = null;\n-                        stack.clear();\n-                        \/\/ and continue with the next unvisited instruction\n-                        i = visited.nextClearBit(i);\n+                }\n+                case NewObjectInstruction _ -> {\n+                    \/\/ Skip over this and the dup to process the invoke special\n+                    if (i + 2 < elements.size() - 1\n+                            && elements.get(i + 1) instanceof StackInstruction dup\n+                            && dup.opcode() == Opcode.DUP) {\n+                        i++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"New must be followed by dup\");\n@@ -426,4 +432,27 @@\n-                if (visited.cardinality() == initiallyResolved) {\n-                    \/\/ If there is no progress, all remaining blocks are dead code\n-                    \/\/ we may alternatively just exit and ignore the dead code\n-                    throw new IllegalArgumentException(\"Dead code detected.\");\n+                case NewPrimitiveArrayInstruction inst -> {\n+                    stack.push(op(CoreOps.newArray(\n+                            switch (inst.typeKind()) {\n+                                case BooleanType -> JavaType.BOOLEAN_ARRAY;\n+                                case ByteType -> JavaType.BYTE_ARRAY;\n+                                case CharType -> JavaType.CHAR_ARRAY;\n+                                case DoubleType -> JavaType.DOUBLE_ARRAY;\n+                                case FloatType -> JavaType.FLOAT_ARRAY;\n+                                case IntType -> JavaType.INT_ARRAY;\n+                                case LongType -> JavaType.LONG_ARRAY;\n+                                case ShortType -> JavaType.SHORT_ARRAY;\n+                                default ->\n+                                        throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                            },\n+                            stack.pop())));\n+                }\n+                case NewReferenceArrayInstruction inst -> {\n+                    stack.push(op(CoreOps.newArray(\n+                            JavaType.ofNominalDescriptor(inst.componentType().asSymbol().arrayType()),\n+                            stack.pop())));\n+                }\n+                case NewMultiArrayInstruction inst -> {\n+                    stack.push(op(CoreOps._new(\n+                            FunctionType.functionType(\n+                                    JavaType.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                    Collections.nCopies(inst.dimensions(), JavaType.INT)),\n+                            IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n@@ -431,0 +460,16 @@\n+                case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n+                    stack.push(op(CoreOps.cast(JavaType.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                }\n+                case StackInstruction inst -> {\n+                    switch (inst.opcode()) {\n+                        case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n+                        case DUP, DUP2 -> stack.push(stack.peek());\n+                        \/\/@@@ implement all other stack ops\n+                        default ->\n+                            throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                    }\n+                }\n+                case Instruction inst ->\n+                    throw new UnsupportedOperationException(\"Unsupported instruction: \" + inst.opcode().name());\n+                default ->\n+                    throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n@@ -432,1 +477,1 @@\n-        });\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":387,"deletions":342,"binary":false,"changes":729,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.analysis.SSA;\n@@ -113,3 +112,0 @@\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,407 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestBytecode\n+ *\/\n+\n+public class TestBytecode {\n+\n+    @CodeReflection\n+    static int intNumOps(int i, int j, int k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static long longNumOps(long i, long j, long k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static float floatNumOps(float i, float j, float k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static double doubleNumOps(double i, double j, double k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int intBitOps(int i, int j, int k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static long longBitOps(long i, long j, long k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static boolean boolBitOps(boolean i, boolean j, boolean k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static String constructor(String s, int i, int j) {\n+        return new String(s.getBytes(), i, j);\n+    }\n+\n+    @CodeReflection\n+    static Class<?> classArray(int i, int j) {\n+        Class<?>[] ifaces = new Class[1 + i + j];\n+        ifaces[0] = Function.class;\n+        return ifaces[0];\n+    }\n+\n+    @CodeReflection\n+    static String[] stringArray(int i, int j) {\n+        return new String[i];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArray2(int i, int j) {\n+        return new String[i][];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArrayMulti(int i, int j) {\n+        return new String[i][j];\n+    }\n+\n+    @CodeReflection\n+    static int[][] initializedIntArray(int i, int j) {\n+        return new int[][]{{i, j}, {i + j}};\n+    }\n+\n+    @CodeReflection\n+    static int ifElseCompare(int i, int j) {\n+        if (i < 3) {\n+            i += 1;\n+        } else {\n+            j += 2;\n+        }\n+        return i + j;\n+    }\n+\n+    @CodeReflection\n+    static int ifElseEquality(int i, int j) {\n+        if (j != 0) {\n+            if (i != 0) {\n+                i += 1;\n+            } else {\n+                i += 2;\n+            }\n+        } else {\n+            if (j != 0) {\n+                i += 3;\n+            } else {\n+                i += 4;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int conditionalExpr(int i, int j) {\n+        return ((i - 1 >= 0) ? i - 1 : j - 1);\n+    }\n+\n+    @CodeReflection\n+    static int nestedConditionalExpr(int i, int j) {\n+        return (i < 2) ? (j < 3) ? i : j : i + j;\n+    }\n+\n+    @CodeReflection\n+    static int tryFinally(int i, int j) {\n+        try {\n+            i = i + j;\n+        } finally {\n+            i = i + j;\n+        }\n+        return i;\n+    }\n+\n+    public record A(String s) {}\n+\n+    @CodeReflection\n+    static A newWithArgs(int i, int j) {\n+        return new A(\"hello world\".substring(i, i + j));\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n, int j) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + j;\n+        }\n+        return sum;\n+    }\n+\n+\n+    @CodeReflection\n+    static int ifElseNested(int a, int b) {\n+        int c = a + b;\n+        int d = 10 - a + b;\n+        if (b < 3) {\n+            if (a < 3) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (a > 2) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @CodeReflection\n+    static int methodCall(int a, int b) {\n+        int i = Math.max(a, b);\n+        return Math.negateExact(i);\n+    }\n+\n+    @CodeReflection\n+    static int[] primitiveArray(int i, int j) {\n+        int[] ia = new int[i + 1];\n+        ia[0] = j;\n+        return ia;\n+    }\n+\n+    @CodeReflection\n+    static boolean not(int i, int j) {\n+        boolean b = i < j;\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static int mod(int i, int j) {\n+        return i % (j + 1);\n+    }\n+\n+    @CodeReflection\n+    static int xor(int i, int j) {\n+        return i ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int whileLoop(int i, int n) { int\n+        counter = 0;\n+        while (i < n && counter < 3) {\n+            counter++;\n+            if (counter == 4) {\n+                break;\n+            }\n+            i++;\n+        }\n+        return counter;\n+    }\n+\n+    record TestData(Method testMethod) {\n+        @Override\n+        public String toString() {\n+            String s = testMethod.getName() + Arrays.stream(testMethod.getParameterTypes()).map(Class::getSimpleName).collect(Collectors.joining(\",\", \"(\", \")\"));\n+            if (s.length() > 30) s = s.substring(0, 27) + \"...\";\n+            return s;\n+        }\n+    }\n+\n+    @DataProvider(name = \"testMethods\")\n+    public static TestData[]testMethods() {\n+        return Stream.of(TestBytecode.class.getDeclaredMethods()).filter(m -> m.isAnnotationPresent(CodeReflection.class)).map(TestData::new).toArray(TestData[]::new);\n+    }\n+\n+    private static byte[] CLASS_DATA;\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        CLASS_DATA = TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes();\n+\/\/        ClassPrinter.toYaml(ClassFile.of().parse(CLASS_DATA), ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+    }\n+\n+    private static MethodTypeDesc toMethodTypeDesc(Method m) {\n+        return MethodTypeDesc.of(m.getReturnType().describeConstable().orElseThrow(),\n+                                 Arrays.stream(m.getParameterTypes()).map(cls -> cls.describeConstable().orElseThrow()).toList());\n+    }\n+\n+\n+    private static final Map<Class<?>, Object[]> TEST_ARGS = new IdentityHashMap<>();\n+    private static Object[] values(Object... values) {\n+        return values;\n+    }\n+    private static void initTestArgs(Object[] values, Class<?>... argTypes) {\n+        for (var argType : argTypes) TEST_ARGS.put(argType, values);\n+    }\n+    static {\n+        initTestArgs(values(1, 2, 3, 4), int.class, Integer.class, byte.class, Byte.class, short.class, Short.class, char.class, Character.class);\n+        initTestArgs(values(false, true), boolean.class, Boolean.class);\n+        initTestArgs(values(\"Hello World\"), String.class);\n+        initTestArgs(values(1l, 2l, 3l, 4l), long.class, Long.class);\n+        initTestArgs(values(1f, 2f, 3f, 4f), float.class, Float.class);\n+        initTestArgs(values(1d, 2d, 3d, 4d), double.class, Double.class);\n+    }\n+\n+    interface Executor {\n+        void execute(Object[] args) throws Throwable;\n+    }\n+\n+    private static void permutateAllArgs(Class<?>[] argTypes, Executor executor) throws Throwable {\n+        final int argn = argTypes.length;\n+        Object[][] argValues = new Object[argn][];\n+        for (int i = 0; i < argn; i++) {\n+            argValues[i] = TEST_ARGS.get(argTypes[i]);\n+        }\n+        int[] argIndexes = new int[argn];\n+        Object[] args = new Object[argn];\n+        while (true) {\n+            for (int i = 0; i < argn; i++) {\n+                args[i] = argValues[i][argIndexes[i]];\n+            }\n+\/\/            System.out.println(Arrays.toString(args));\n+            executor.execute(args);\n+            int i = argn - 1;\n+            while (i >= 0 && argIndexes[i] == argValues[i].length - 1) i--;\n+            if (i < 0) return;\n+            argIndexes[i++]++;\n+            while (i < argn) argIndexes[i++] = 0;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testLift(TestData d) throws Throwable {\n+        CoreOps.FuncOp flift;\n+        try {\n+            flift = BytecodeLift.lift(CLASS_DATA, d.testMethod.getName(), toMethodTypeDesc(d.testMethod));\n+        } catch (Throwable e) {\n+            System.out.println(\"Lift failed, expected:\");\n+            d.testMethod.getCodeModel().ifPresent(f -> f.writeTo(System.out));\n+            throw e;\n+        }\n+        try {\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                Assert.assertEquals(invokeAndConvert(flift, args), d.testMethod.invoke(null, args)));\n+        } catch (Throwable e) {\n+            flift.writeTo(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    private static Object invokeAndConvert(CoreOps.FuncOp func, Object[] args) {\n+        Object ret = Interpreter.invoke(func, args);\n+        if (ret instanceof Integer i) {\n+            TypeElement rt = func.invokableType().returnType();\n+            if (rt.equals(JavaType.BOOLEAN)) {\n+                return i != 0;\n+            } else if (rt.equals(JavaType.BYTE)) {\n+                return i.byteValue();\n+            } else if (rt.equals(JavaType.CHAR)) {\n+                return (short)i.intValue();\n+            } else if (rt.equals(JavaType.SHORT)) {\n+                return i.shortValue();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testGenerate(TestData d) throws Throwable {\n+        CoreOps.FuncOp func = d.testMethod.getCodeModel().get();\n+\n+        CoreOps.FuncOp lfunc = func.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        try {\n+            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lfunc);\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                    Assert.assertEquals(mh.invokeWithArguments(args), d.testMethod.invoke(null, args)));\n+        } catch (Throwable e) {\n+            func.writeTo(System.out);\n+            lfunc.writeTo(System.out);\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":407,"deletions":0,"binary":false,"changes":407,"status":"added"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @run testng TestLiftArrayCreation\n- *\/\n-\n-public class TestLiftArrayCreation {\n-    @CodeReflection\n-    public static String[] f() {\n-        return new String[10];\n-    }\n-\n-    @Test\n-    public void testf() {\n-        CoreOps.FuncOp f = getFuncOp(\"f\");\n-        byte[] classdata = generate(f);\n-\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f\");\n-        flift.writeTo(System.out);\n-\n-        Assert.assertEquals(Interpreter.invoke(flift), f());\n-    }\n-\n-    @CodeReflection\n-    public static String[][] f2() {\n-        return new String[10][];\n-    }\n-\n-    @Test\n-    public void testf2() {\n-        CoreOps.FuncOp f = getFuncOp(\"f2\");\n-        byte[] classdata = generate(f);\n-\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f2\");\n-        flift.writeTo(System.out);\n-\n-        Assert.assertEquals(Interpreter.invoke(flift), f2());\n-    }\n-\n-    @CodeReflection\n-    public static String[][] f3() {\n-        return new String[10][5];\n-    }\n-\n-    @Test\n-    public void testf3() {\n-        CoreOps.FuncOp f = getFuncOp(\"f3\");\n-        byte[] classdata = generate(f);\n-\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f3\");\n-        flift.writeTo(System.out);\n-\n-        Assert.assertEquals(Interpreter.invoke(flift), f3());\n-    }\n-\n-    @CodeReflection\n-    public static String[][] f4() {\n-        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n-    }\n-\n-    @Test\n-    public void testf4() {\n-        CoreOps.FuncOp f = getFuncOp(\"f4\");\n-        byte[] classdata = generate(f);\n-\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f4\");\n-        flift.writeTo(System.out);\n-\n-        Assert.assertEquals(Interpreter.invoke(flift), f4());\n-    }\n-\n-    static byte[] generate(CoreOps.FuncOp f) {\n-        f.writeTo(System.out);\n-\n-        CoreOps.FuncOp lf = f.transform((block, op) -> {\n-            if (op instanceof Op.Lowerable lop) {\n-                return lop.lower(block);\n-            } else {\n-                block.op(op);\n-                return block;\n-            }\n-        });\n-        lf.writeTo(System.out);\n-\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), lf);\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestLiftArrayCreation.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftArrayCreation.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Label;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.net.URL;\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @run testng TestLiftControl\n- *\/\n-\n-public class TestLiftControl {\n-\n-    static int ifelseCompare(int a, int b, int n) {\n-        if (n < 10) {\n-            a += 1;\n-        } else {\n-            b += 2;\n-        }\n-        return a + b;\n-    }\n-\n-    @Test\n-    public void testifElseCompare() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"ifelseCompare\");\n-\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 1), ifelseCompare(0, 0, 1));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 11), ifelseCompare(0, 0, 11));\n-    }\n-\n-    \/\/ @@@ Cannot use boolean since it erases to int\n-    static int ifelseEquality(int v, int t1, int t1_1, int t2_1) {\n-        if (t1 != 0) {\n-            if (t1_1 != 0) {\n-                v += 1;\n-            } else {\n-                v += 2;\n-            }\n-        } else {\n-            if (t2_1 != 0) {\n-                v += 3;\n-            } else {\n-                v += 4;\n-            }\n-        }\n-        return v;\n-    }\n-\n-    @Test\n-    public void testIfelseEquality() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"ifelseEquality\");\n-\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 1, 0, 0), ifelseEquality(0, 1, 0, 0));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 1, 1, 0), ifelseEquality(0, 1, 1, 0));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 0, 1), ifelseEquality(0, 0, 0, 1));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 0, 0, 0), ifelseEquality(0, 0, 0, 0));\n-    }\n-\n-    static int conditionalExpression(int i, int len) {\n-        return ((i - 1 >= 0) ? i - 1 : len - 1);\n-    }\n-\n-    @Test\n-    public void testConditionalExpression() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"conditionalExpression\");\n-\n-        Assert.assertEquals((int) Interpreter.invoke(f, 5, 10), conditionalExpression(5, 10));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 10), conditionalExpression(0, 10));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 0, 50), conditionalExpression(0, 50));\n-    }\n-\n-    static int nestedConditionalExpression(int a, int b, int c, int n) {\n-        return (n < 10) ? (n < 5) ? a : b : c;\n-    }\n-\n-    @Test\n-    public void testNestedConditionalExpression() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"nestedConditionalExpression\");\n-\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 1), nestedConditionalExpression(1, 2, 3, 1));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 6), nestedConditionalExpression(1, 2, 3, 6));\n-        Assert.assertEquals((int) Interpreter.invoke(f, 1, 2, 3, 11), nestedConditionalExpression(1, 2, 3, 11));\n-    }\n-\n-    @Test\n-    public void testBackJumps() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"BackJumps\"), clb ->\n-                clb.withMethodBody(\"backJumps\", MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int), ClassFile.ACC_STATIC, cob -> {\n-                    Label l1 = cob.newLabel();\n-                    Label l2 = cob.newLabel();\n-                    Label l3 = cob.newLabel();\n-                    Label l4 = cob.newLabel();\n-                    \/\/ Code wrapped in back jumps requires multiple passes and block skipping\n-                    cob.goto_(l1)\n-                       .labelBinding(l2)\n-                       .goto_(l3)\n-                       .labelBinding(l4)\n-                       .iload(0)\n-                       .ireturn()\n-                       .labelBinding(l1)\n-                       .goto_(l2)\n-                       .labelBinding(l3)\n-                       .goto_(l4);\n-                })), \"backJumps\");\n-\n-        Assert.assertEquals((int) Interpreter.invoke(f, 42), 42);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testDeadCodeDetection() throws Throwable {\n-        Interpreter.invoke(getFuncOp(ClassFile.of().build(ClassDesc.of(\"DeadCode\"), clb ->\n-                clb.withMethodBody(\"deadCode\", ConstantDescs.MTD_void, ClassFile.ACC_STATIC, cob ->\n-                   cob.return_().nop())), \"deadCode\"));\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String method) {\n-        return getFuncOp(getClassdata(), method);\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(byte[] classdata, String method) {\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, method);\n-        flift.writeTo(System.out);\n-        CoreOps.FuncOp fliftcoreSSA = SSA.transform(flift);\n-        fliftcoreSSA.writeTo(System.out);\n-        return fliftcoreSSA;\n-    }\n-\n-    static byte[] getClassdata() {\n-        URL resource = TestLiftControl.class.getClassLoader()\n-                .getResource(TestLiftControl.class.getName().replace('.', '\/') + \".class\");\n-        try {\n-            return resource.openStream().readAllBytes();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftControl.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLiftCustomBytecode\n+ *\/\n+\n+public class TestLiftCustomBytecode {\n+\n+    @Test\n+    public void testBackJumps() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"BackJumps\"), clb ->\n+                clb.withMethodBody(\"backJumps\", MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int), ClassFile.ACC_STATIC, cob -> {\n+                    Label l1 = cob.newLabel();\n+                    Label l2 = cob.newLabel();\n+                    Label l3 = cob.newLabel();\n+                    Label l4 = cob.newLabel();\n+                    \/\/ Code wrapped in back jumps requires multiple passes and block skipping\n+                    cob.goto_(l1)\n+                       .labelBinding(l2)\n+                       .goto_(l3)\n+                       .labelBinding(l4)\n+                       .iload(0)\n+                       .ireturn()\n+                       .labelBinding(l1)\n+                       .goto_(l2)\n+                       .labelBinding(l3)\n+                       .goto_(l4);\n+                })), \"backJumps\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, 42), 42);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(byte[] classdata, String method) {\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, method);\n+        flift.writeTo(System.out);\n+        return flift;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.code.analysis.SSA;\n@@ -71,2 +70,0 @@\n-        CoreOps.FuncOp fliftcoreSSA = SSA.transform(flift);\n-        fliftcoreSSA.writeTo(System.out);\n@@ -77,1 +74,1 @@\n-                fliftcoreSSA, f);\n+                flift, f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @run testng TestLiftSimple\n- *\/\n-\n-public class TestLiftSimple {\n-\n-    @CodeReflection\n-    static int f(int i, int j) {\n-        i = i + j;\n-        return i;\n-    }\n-\n-    @Test\n-    public void testF() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"f\");\n-        byte[] classdata = generate(f);\n-\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f\");\n-        flift.writeTo(System.out);\n-\n-        Assert.assertEquals(Interpreter.invoke(flift, 1, 1), f(1, 1));\n-    }\n-\n-    @CodeReflection\n-    static int f2() {\n-        Class<?>[] ifaces = new Class[1];\n-        ifaces[0] = Function.class;\n-        return ifaces.length;\n-    }\n-\n-    @Test\n-    public void testF2() {\n-        CoreOps.FuncOp f = getFuncOp(\"f2\");\n-        byte[] classdata = generate(f);\n-\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"f2\");\n-        flift.writeTo(System.out);\n-\n-        Assert.assertEquals(Interpreter.invoke(flift), f2());\n-    }\n-\n-    static byte[] generate(CoreOps.FuncOp f) {\n-        f.writeTo(System.out);\n-\n-        CoreOps.FuncOp lf = f.transform((block, op) -> {\n-            if (op instanceof Op.Lowerable lop) {\n-                return lop.lower(block);\n-            } else {\n-                block.op(op);\n-                return block;\n-            }\n-        });\n-        lf.writeTo(System.out);\n-\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), lf);\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestLiftSimple.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftSimple.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.StringWriter;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Instruction;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.Opcode;\n-import java.lang.classfile.instruction.*;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.lang.reflect.code.op.CoreOps;\n-\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @run testng TestLiftSmallCorpus\n- *\/\n-\n-public class TestLiftSmallCorpus {\n-\n-    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-    private static final ClassFile CF = ClassFile.of(ClassFile.DebugElementsOption.DROP_DEBUG,\n-                                                     ClassFile.LineNumbersOption.DROP_LINE_NUMBERS);\n-    private static final int COLUMN_WIDTH = 150;\n-\n-    private int passed, failed, skipped;\n-\n-    @Test\n-    public void testDoubleRoundtripStability() throws Exception {\n-        passed = 0;\n-        failed = 0;\n-        skipped = 0;\n-        for (Path p : Files.walk(JRT.getPath(\"modules\/java.base\/java\"))\n-                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n-                .toList()) {\n-            testDoubleRoundtripStability(p);\n-        }\n-\n-        \/\/ @@@ There is still several failing cases\n-        Assert.assertTrue(failed < 5 && passed > 4200, STR.\"failed: \\{failed}, passed: \\{passed}, skipped: \\{skipped}\");\n-    }\n-\n-    private void testDoubleRoundtripStability(Path path) throws Exception {\n-        var clm = CF.parse(path);\n-        for (var originalModel : clm.methods()) {\n-            try {\n-                CoreOps.FuncOp firstLift = lift(originalModel);\n-                CoreOps.FuncOp firstTransform = transform(firstLift);\n-                MethodModel firstModel = lower(firstTransform);\n-                CoreOps.FuncOp secondLift = lift(firstModel);\n-                CoreOps.FuncOp secondTransform = transform(secondLift);\n-                MethodModel secondModel = lower(secondTransform);\n-\n-                \/\/ testing only methods passing through\n-                var firstNormalized = normalize(firstModel);\n-                var secondNormalized = normalize(secondModel);\n-                if (!firstNormalized.equals(secondNormalized)) {\n-                    failed++;\n-                    System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n-                    printInColumns(firstLift, secondLift);\n-                    printInColumns(firstTransform, secondTransform);\n-                    printInColumns(firstNormalized, secondNormalized);\n-                    System.out.println();\n-                } else {\n-                    passed++;\n-                }\n-            } catch (Exception e) {\n-                \/\/ We skip methods failing to lift or lower for now\n-                skipped++;\n-            }\n-        }\n-    }\n-    private static void printInColumns(CoreOps.FuncOp first, CoreOps.FuncOp second) {\n-        StringWriter fw = new StringWriter();\n-        first.writeTo(fw);\n-        StringWriter sw = new StringWriter();\n-        second.writeTo(sw);\n-        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n-    }\n-\n-    private static void printInColumns(List<String> first, List<String> second) {\n-        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n-        for (int i = 0; i < first.size() || i < second.size(); i++) {\n-            String f = i < first.size() ? first.get(i) : \"\";\n-            String s = i < second.size() ? second.get(i) : \"\";\n-            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n-        }\n-    }\n-\n-    private static CoreOps.FuncOp lift(MethodModel mm) {\n-        return BytecodeLift.lift(mm);\n-    }\n-\n-    private static CoreOps.FuncOp transform(CoreOps.FuncOp func) {\n-        return SSA.transform(func.transform((block, op) -> {\n-                    if (op instanceof Op.Lowerable lop) {\n-                        return lop.lower(block);\n-                    } else {\n-                        block.op(op);\n-                        return block;\n-                    }\n-                }));\n-    }\n-\n-    private static MethodModel lower(CoreOps.FuncOp func) {\n-        return CF.parse(BytecodeGenerator.generateClassData(\n-                MethodHandles.lookup(),\n-                func)).methods().get(0);\n-    }\n-\n-\n-    public static List<String> normalize(MethodModel mm) {\n-        record El(int index, String format, Label... targets) {\n-            public El(int index, Instruction i, Object format, Label... targets) {\n-                this(index, trim(i.opcode()) + \" \" + format, targets);\n-            }\n-            public String toString(Map<Label, Integer> targetsMap) {\n-                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n-            }\n-        }\n-\n-        Map<Label, Integer> targetsMap = new HashMap<>();\n-        List<El> elements = new ArrayList<>();\n-        Label lastLabel = null;\n-        int i = 0;\n-        for (var e : mm.code().orElseThrow()) {\n-            var er = switch (e) {\n-                case LabelTarget lt -> {\n-                    lastLabel = lt.label();\n-                    yield null;\n-                }\n-                case ExceptionCatch ec ->\n-                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n-                case BranchInstruction ins ->\n-                    new El(i++, ins, \"@%d\", ins.target());\n-                case ConstantInstruction ins ->\n-                    new El(i++, \"LDC \" + ins.constantValue());\n-                case FieldInstruction ins ->\n-                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n-                case InvokeDynamicInstruction ins ->\n-                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n-                case InvokeInstruction ins ->\n-                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n-                case LoadInstruction ins ->\n-                    new El(i++, ins, \"#\" + ins.slot());\n-                case StoreInstruction ins ->\n-                    new El(i++, ins, \"#\" + ins.slot());\n-                case IncrementInstruction ins ->\n-                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n-                case LookupSwitchInstruction ins ->\n-                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n-                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n-                case NewMultiArrayInstruction ins ->\n-                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n-                case NewObjectInstruction ins ->\n-                    new El(i++, ins, ins.className().asInternalName());\n-                case NewPrimitiveArrayInstruction ins ->\n-                    new El(i++, ins, ins.typeKind());\n-                case NewReferenceArrayInstruction ins ->\n-                    new El(i++, ins, ins.componentType().asInternalName());\n-                case TableSwitchInstruction ins ->\n-                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n-                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n-                case TypeCheckInstruction ins ->\n-                    new El(i++, ins, ins.type().asInternalName());\n-                case Instruction ins ->\n-                    new El(i++, ins, \"\");\n-                default -> null;\n-            };\n-            if (er != null) {\n-                if (lastLabel != null) {\n-                    targetsMap.put(lastLabel, elements.size());\n-                    lastLabel = null;\n-                }\n-                elements.add(er);\n-            }\n-        }\n-        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n-    }\n-\n-    private static String trim(Opcode opcode) {\n-        var name = opcode.toString();\n-        int i = name.indexOf('_');\n-        return i > 2 ? name.substring(0, i) : name;\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftSmallCorpus.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeLift;\n-import java.net.URL;\n-\n-\/*\n- * @test\n- * @run testng TestLiftTryFinally\n- *\/\n-\n-public class TestLiftTryFinally {\n-\n-    static int f(int i, int j) {\n-        try {\n-            i = i + j;\n-        } finally {\n-            i = i + j;\n-        }\n-        return i;\n-    }\n-\n-    @Test\n-    public void testF() throws Throwable {\n-        CoreOps.FuncOp flift = getFuncOp(\"f\");\n-        flift.writeTo(System.out);\n-        Assert.assertEquals(Interpreter.invoke(flift, 1, 1), f(1, 1));\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String method) {\n-        byte[] classdata = getClassdata();\n-        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, method);\n-        flift.writeTo(System.out);\n-        CoreOps.FuncOp fliftcoreSSA = SSA.transform(flift);\n-        fliftcoreSSA.writeTo(System.out);\n-        return fliftcoreSSA;\n-    }\n-\n-    static byte[] getClassdata() {\n-        URL resource = TestLiftTryFinally.class.getClassLoader()\n-                .getResource(TestLiftTryFinally.class.getName().replace('.', '\/') + \".class\");\n-        try {\n-            return resource.openStream().readAllBytes();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftTryFinally.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @run testng TestNew\n- *\/\n-\n-public class TestNew {\n-\n-    record A(String s) {}\n-\n-    static String y(String in) {\n-        return in;\n-    }\n-\n-    @CodeReflection\n-    static A newWithArguments(String in) {\n-        String s = y(in);\n-        return new A(s);\n-    }\n-\n-    @Test\n-    public void testNewWithArguments() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"newWithArguments\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((A) mh.invoke(\"S\"), newWithArguments(\"S\"));\n-    }\n-\n-\n-    static MethodHandle generate(CoreOps.FuncOp f) {\n-        f.writeTo(System.out);\n-\n-        CoreOps.FuncOp lf = f.transform((block, op) -> {\n-            if (op instanceof Op.Lowerable lop) {\n-                return lop.lower(block);\n-            } else {\n-                block.op(op);\n-                return block;\n-            }\n-        });\n-        lf.writeTo(System.out);\n-\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestNew.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNew.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.IntBinaryOperator;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestQuoted\n+ *\/\n+\n+public class TestQuoted {\n+\n+    @Test\n+    public void testQuoted() throws Throwable {\n+        Quoted q = (int i, int j) -> {\n+            i = i + j;\n+            return i;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        MethodHandle mh = generate(cop);\n+\n+        Assert.assertEquals(3, (int) mh.invoke(1, 2));\n+    }\n+\n+    static <O extends Op & Op.Invokable> MethodHandle generate(O f) {\n+        f.writeTo(System.out);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        O lf = (O) f.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestQuoted.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -1,288 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.CopyContext;\n-import java.lang.reflect.code.Quoted;\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.function.IntBinaryOperator;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @run testng TestSimple\n- *\/\n-\n-public class TestSimple {\n-\n-    @CodeReflection\n-    static int f(int i, int j) {\n-        i = i + j;\n-        return i;\n-    }\n-\n-    @Test\n-    public void testF() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"f\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals(f(1, 2), (int) mh.invoke(1, 2));\n-    }\n-\n-    @Test\n-    public void testQuoted() throws Throwable {\n-        Quoted q = (int i, int j) -> {\n-            i = i + j;\n-            return i;\n-        };\n-        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n-\n-        MethodHandle mh = generate(cop);\n-\n-        Assert.assertEquals(f(1, 2), (int) mh.invoke(1, 2));\n-    }\n-\n-    @CodeReflection\n-    static int ifelse(int a, int b, int n) {\n-        if (n < 10) {\n-            a += 1;\n-        } else {\n-            b += 2;\n-        }\n-        return a + b;\n-    }\n-\n-    @Test\n-    public void testIfelse() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"ifelse\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((int) mh.invoke(0, 0, 1), ifelse(0, 0, 1));\n-        Assert.assertEquals((int) mh.invoke(0, 0, 11), ifelse(0, 0, 11));\n-    }\n-\n-    @CodeReflection\n-    static int loop(int n) {\n-        int sum = 0;\n-        for (int i = 0; i < n; i++) {\n-            sum = sum + i;\n-        }\n-        return sum;\n-    }\n-\n-    @Test\n-    public void testLoop() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"loop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((int) mh.invoke(10), loop(10));\n-    }\n-\n-    @CodeReflection\n-    static int ifelseNested(int a, int b, int c, int d, int n) {\n-        if (n < 20) {\n-            if (n < 10) {\n-                a += 1;\n-            } else {\n-                b += 2;\n-            }\n-            c += 3;\n-        } else {\n-            if (n > 20) {\n-                a += 4;\n-            } else {\n-                b += 5;\n-            }\n-            d += 6;\n-        }\n-        return a + b + c + d;\n-    }\n-\n-    @Test\n-    public void testIfelseNested() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"ifelseNested\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        for (int i : new int[]{1, 11, 20, 21}) {\n-            Assert.assertEquals((int) mh.invoke(0, 0, 0, 0, i), ifelseNested(0, 0, 0, 0, i));\n-        }\n-    }\n-\n-    @CodeReflection\n-    static int nestedLoop(int n) {\n-        int sum = 0;\n-        for (int i = 0; i < n; i++) {\n-            for (int j = 0; j < n; j++) {\n-                sum = sum + i + j;\n-            }\n-        }\n-        return sum;\n-    }\n-\n-    @Test\n-    public void testNestedLoop() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"nestedLoop\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((int) mh.invoke(10), nestedLoop(10));\n-    }\n-\n-    @CodeReflection\n-    static int methodCallFieldAccess(int a, int b, IntBinaryOperator o) {\n-        int i = o.applyAsInt(a, b);\n-        System.out.println(i);\n-        return i;\n-    }\n-\n-    @Test\n-    public void testMethodCall() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"methodCallFieldAccess\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        int a = 1;\n-        int b = 1;\n-        IntBinaryOperator o = Integer::sum;\n-        Assert.assertEquals((int) mh.invoke(a, b, o), methodCallFieldAccess(a, b, o));\n-    }\n-\n-    @CodeReflection\n-    static Class<?>[] arrayCreationAndAccess() {\n-        Class<?>[] ca = new Class<?>[1];\n-        ca[0] = Function.class;\n-        return ca;\n-    }\n-\n-    @Test\n-    public void testArrayCreationAndAccess() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"arrayCreationAndAccess\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((Class<?>[]) mh.invoke(), arrayCreationAndAccess());\n-    }\n-\n-    @CodeReflection\n-    static int[] primitiveArrayCreationAndAccess() {\n-        int[] ia = new int[1];\n-        ia[0] = 42;\n-        return ia;\n-    }\n-\n-    @Test\n-    public void testPrimitiveArrayCreationAndAccess() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"primitiveArrayCreationAndAccess\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((int[]) mh.invoke(), primitiveArrayCreationAndAccess());\n-    }\n-\n-    @CodeReflection\n-    public static boolean not(boolean b) {\n-        return !b;\n-    }\n-\n-    @Test\n-    public void testNot() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"not\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((boolean) mh.invoke(true), not(true));\n-        Assert.assertEquals((boolean) mh.invoke(false), not(false));\n-    }\n-\n-    @CodeReflection\n-    public static int mod(int a, int b) {\n-        return a % b;\n-    }\n-\n-    @Test\n-    public void testMod() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"mod\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((int) mh.invoke(10, 3), mod(10, 3));\n-    }\n-\n-    @CodeReflection\n-    public static boolean xor(boolean a, boolean b) {\n-        return a ^ b;\n-    }\n-\n-    @Test\n-    public void testXor() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"xor\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((boolean) mh.invoke(true, false), xor(true, false));\n-    }\n-\n-    static <O extends Op & Op.Invokable> MethodHandle generate(O f) {\n-        f.writeTo(System.out);\n-\n-        @SuppressWarnings(\"unchecked\")\n-        O lf = (O) f.transform(CopyContext.create(), (block, op) -> {\n-            if (op instanceof Op.Lowerable lop) {\n-                return lop.lower(block);\n-            } else {\n-                block.op(op);\n-                return block;\n-            }\n-        });\n-        lf.writeTo(System.out);\n-\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestSimple.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":0,"deletions":288,"binary":false,"changes":288,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.analysis.SSA;\n@@ -154,3 +153,0 @@\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestSmallCorpus\n+ *\/\n+public class TestSmallCorpus {\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final ClassFile CF = ClassFile.of(ClassFile.DebugElementsOption.DROP_DEBUG,\n+                                                     ClassFile.LineNumbersOption.DROP_LINE_NUMBERS);\n+    private static final int COLUMN_WIDTH = 150;\n+\n+    private int passed, notMatching;\n+    private Map<String, Map<String, Integer>> errorStats;\n+\n+    @Test\n+    public void testDoubleRoundtripStability() throws Exception {\n+        passed = 0;\n+        notMatching = 0;\n+        errorStats = new LinkedHashMap<>();\n+        for (Path p : Files.walk(JRT.getPath(\"modules\/java.base\/java\"))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+                .toList()) {\n+            testDoubleRoundtripStability(p);\n+        }\n+\n+        for (var stats : errorStats.entrySet()) {\n+            System.out.println(STR.\"\"\"\n+\n+            \\{stats.getKey()} errors:\n+            -----------------------------------------------------\n+            \"\"\");\n+            stats.getValue().entrySet().stream().sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue())).forEach(e -> System.out.println(e.getValue() +\"x \" + e.getKey() + \"\\n\"));\n+        }\n+\n+\n+        \/\/ @@@ There is still several failing cases and a lot of errors\n+        Assert.assertTrue(notMatching < 31 && passed > 5400, STR.\"\"\"\n+\n+                    passed: \\{passed}\n+                    not matching: \\{notMatching}\n+                    \\{errorStats.entrySet().stream().map(e -> e.getKey() + \" errors: \"\n+                            + e.getValue().values().stream().collect(Collectors.summingInt(Integer::intValue))).collect(Collectors.joining(\"\\n    \"))}\n+                \"\"\");\n+    }\n+\n+    private void testDoubleRoundtripStability(Path path) throws Exception {\n+        var clm = CF.parse(path);\n+        for (var originalModel : clm.methods()) {\n+            if (originalModel.flags().has(AccessFlag.STATIC) && originalModel.code().isPresent()) try {\n+                CoreOps.FuncOp firstLift = lift(originalModel);\n+                try {\n+                    CoreOps.FuncOp firstTransform = transform(firstLift);\n+                    try {\n+                        MethodModel firstModel = lower(firstTransform);\n+                        try {\n+                            CoreOps.FuncOp secondLift = lift(firstModel);\n+                            try {\n+                                CoreOps.FuncOp secondTransform = transform(secondLift);\n+                                try {\n+                                    MethodModel secondModel = lower(secondTransform);\n+\n+                                    \/\/ testing only methods passing through\n+                                    var firstNormalized = normalize(firstModel);\n+                                    var secondNormalized = normalize(secondModel);\n+                                    if (!firstNormalized.equals(secondNormalized)) {\n+                                        notMatching++;\n+                                        System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+                                        printInColumns(firstLift, secondLift);\n+                                        printInColumns(firstTransform, secondTransform);\n+                                        printInColumns(firstNormalized, secondNormalized);\n+                                        System.out.println();\n+                                    } else {\n+                                        passed++;\n+                                    }\n+                                } catch (Exception e) {\n+                                    error(\"second lower\", e);\n+                                }\n+                            } catch (Exception e) {\n+                                error(\"second transform\", e);\n+                            }\n+                        } catch (Exception e) {\n+                            error(\"second lift\", e);\n+                        }\n+                    } catch (Exception e) {\n+                        error(\"first lower\", e);\n+                    }\n+                } catch (Exception e) {\n+                    error(\"first transform\", e);\n+                }\n+            } catch (Exception e) {\n+                error(\"first lift\", e);\n+            }\n+        }\n+    }\n+    private static void printInColumns(CoreOps.FuncOp first, CoreOps.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n+\n+    private static CoreOps.FuncOp lift(MethodModel mm) {\n+        return BytecodeLift.lift(mm);\n+    }\n+\n+    private static CoreOps.FuncOp transform(CoreOps.FuncOp func) {\n+        return SSA.transform(func.transform((block, op) -> {\n+                    if (op instanceof Op.Lowerable lop) {\n+                        return lop.lower(block);\n+                    } else {\n+                        block.op(op);\n+                        return block;\n+                    }\n+                }));\n+    }\n+\n+    private static MethodModel lower(CoreOps.FuncOp func) {\n+        return CF.parse(BytecodeGenerator.generateClassData(\n+                MethodHandles.lookup(),\n+                func)).methods().get(0);\n+    }\n+\n+\n+    public static List<String> normalize(MethodModel mm) {\n+        record El(int index, String format, Label... targets) {\n+            public El(int index, Instruction i, Object format, Label... targets) {\n+                this(index, trim(i.opcode()) + \" \" + format, targets);\n+            }\n+            public String toString(Map<Label, Integer> targetsMap) {\n+                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n+            }\n+        }\n+\n+        Map<Label, Integer> targetsMap = new HashMap<>();\n+        List<El> elements = new ArrayList<>();\n+        Label lastLabel = null;\n+        int i = 0;\n+        for (var e : mm.code().orElseThrow()) {\n+            var er = switch (e) {\n+                case LabelTarget lt -> {\n+                    lastLabel = lt.label();\n+                    yield null;\n+                }\n+                case ExceptionCatch ec ->\n+                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n+                case BranchInstruction ins ->\n+                    new El(i++, ins, \"@%d\", ins.target());\n+                case ConstantInstruction ins ->\n+                    new El(i++, \"LDC \" + ins.constantValue());\n+                case FieldInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n+                case InvokeDynamicInstruction ins ->\n+                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n+                case InvokeInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n+                case LoadInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case StoreInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case IncrementInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n+                case LookupSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case NewMultiArrayInstruction ins ->\n+                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n+                case NewObjectInstruction ins ->\n+                    new El(i++, ins, ins.className().asInternalName());\n+                case NewPrimitiveArrayInstruction ins ->\n+                    new El(i++, ins, ins.typeKind());\n+                case NewReferenceArrayInstruction ins ->\n+                    new El(i++, ins, ins.componentType().asInternalName());\n+                case TableSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case TypeCheckInstruction ins ->\n+                    new El(i++, ins, ins.type().asInternalName());\n+                case Instruction ins ->\n+                    new El(i++, ins, \"\");\n+                default -> null;\n+            };\n+            if (er != null) {\n+                if (lastLabel != null) {\n+                    targetsMap.put(lastLabel, elements.size());\n+                    lastLabel = null;\n+                }\n+                elements.add(er);\n+            }\n+        }\n+        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n+    }\n+\n+    private static String trim(Opcode opcode) {\n+        var name = opcode.toString();\n+        int i = name.indexOf('_');\n+        return i > 2 ? name.substring(0, i) : name;\n+    }\n+\n+    private void error(String category, Exception e) {\n+        StringWriter sw = new StringWriter();\n+        e.printStackTrace(new PrintWriter(sw));\n+        errorStats.computeIfAbsent(category, _ -> new HashMap<>())\n+                  .compute(sw.toString(), (_, i) -> i == null ? 1 : i + 1);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.analysis.SSA;\n@@ -272,3 +271,0 @@\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.analysis.SSA;\n@@ -208,3 +207,0 @@\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.code.analysis.SSA;\n@@ -231,3 +230,0 @@\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.analysis.SSA;\n-import java.lang.reflect.code.bytecode.BytecodeGenerator;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @run testng TestWhile\n- *\/\n-\n-public class TestWhile {\n-\n-    @CodeReflection\n-    private static int fWhile(int i, int n) { int\n-        counter = 0;\n-        while (i < n && counter < 8) {\n-            counter++;\n-            if (counter == 5) {\n-                break;\n-            }\n-            i++;\n-        }\n-        return counter;\n-    }\n-\n-    @Test\n-    public void testWhile() throws Throwable {\n-        CoreOps.FuncOp f = getFuncOp(\"fWhile\");\n-\n-        MethodHandle mh = generate(f);\n-\n-        Assert.assertEquals((int) mh.invoke(1, 2), fWhile(1, 2));\n-        Assert.assertEquals((int) mh.invoke(1, 10), fWhile(1, 10));\n-    }\n-\n-    static MethodHandle generate(CoreOps.FuncOp f) {\n-        f.writeTo(System.out);\n-\n-        CoreOps.FuncOp lf = f.transform((block, op) -> {\n-            if (op instanceof Op.Lowerable lop) {\n-                return lop.lower(block);\n-            } else {\n-                block.op(op);\n-                return block;\n-            }\n-        });\n-        lf.writeTo(System.out);\n-\n-        lf = SSA.transform(lf);\n-        lf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n-    }\n-\n-    static CoreOps.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestWhile.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n-\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestWhile.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"}]}