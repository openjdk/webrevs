{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-    jdk.jsobject \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -31,0 +32,1 @@\n+import java.lang.classfile.Annotation;\n@@ -32,0 +34,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -48,5 +51,66 @@\n-\/**\n- * Helper class to assist the GenerateJLIClassesPlugin to get access to\n- * generate classes ahead of time.\n- *\/\n-class GenerateJLIClassesHelper {\n+\/\/\/ Generates bound method handle species classes, and classes with methods that\n+\/\/\/ hold compiled lambda form bytecode ahead of time, so certain lambda forms\n+\/\/\/ no longer need to spin classes because they can find existing bytecode.\n+\/\/\/ Bytecode pre-generation reduces static initialization costs, footprint costs,\n+\/\/\/ and circular dependencies that may arise if a class is generated per\n+\/\/\/ LambdaForm by [InvokerBytecodeGenerator].\n+\/\/\/\n+\/\/\/ Since lambda forms and bound method handle species are closely tied to\n+\/\/\/ method types, which have many varieties, this generator needs *traces* to\n+\/\/\/ detect which method types are used, so generation matches the actual usage.\n+\/\/\/ See the main entrypoint [#generateHolderClasses(Stream)] for more details\n+\/\/\/ about *traces*.\n+\/\/\/\n+\/\/\/ Note this pregeneration does not cover all lambda forms that can be created.\n+\/\/\/ For example, forms created by [LambdaFormEditor] are not captured.\n+\/\/\/\n+\/\/\/ Pregenerated species classes are resolved in [ClassSpecializer.Factory#loadSpecies]\n+\/\/\/ and behave identically to on-demand generated ones.  Pregenerated lambda\n+\/\/\/ forms are resolved in [InvokerBytecodeGenerator#lookupPregenerated], which\n+\/\/\/ looks up methods for code from the following 4 possibly-generated classes:\n+\/\/\/  -  [Invokers.Holder]\n+\/\/\/  -  [DirectMethodHandle.Holder]\n+\/\/\/  -  [DelegatingMethodHandle.Holder]\n+\/\/\/  -  [LambdaForm.Holder]\n+\/\/\/\n+\/\/\/ [VarHandle] linker forms, analogous to invoker forms in [Invokers.Holder],\n+\/\/\/ have a similar pre-generation system except it is done at source generation;\n+\/\/\/ they reside in [VarHandleGuards].\n+\/\/\/\n+\/\/\/ ## Usages of this generator\n+\/\/\/ Currently, `GenerateJLIClassesHelper` is invoked when creating a modular JDK\n+\/\/\/ image or generating an AOT cache.\n+\/\/\/\n+\/\/\/ #### Modular Image\n+\/\/\/ When creating a modular JDK image,\n+\/\/\/ `jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin` passes the\n+\/\/\/ *traces* in the file `jdk\/tools\/jlink\/internal\/plugins\/default_jli_trace.txt`\n+\/\/\/ in `$JAVA_HOME\/lib\/modules` to this generator.  The *traces* are generated\n+\/\/\/ from the execution of `build.tools.classlist.HelloClasslist` in the build\n+\/\/\/ process of the JDK.\n+\/\/\/\n+\/\/\/ > To list all the Species classes in a JDK image:\n+\/\/\/ > ```\n+\/\/\/ > jimage list $JAVA_HOME\/lib\/modules | grep BoundMethodHandle.Species_\n+\/\/\/ > ```\n+\/\/\/\n+\/\/\/ > All these pregenerated classes can be examined by javap in the same image:\n+\/\/\/ > (Note to escape `$` in bash)\n+\/\/\/ > ```\n+\/\/\/ > javap -c -p -v java.lang.invoke.LambdaForm\\$Holder\n+\/\/\/ > ```\n+\/\/\/\n+\/\/\/ #### AOT Cache\n+\/\/\/ When creating an AOT cache, *traces* generated from the training run are\n+\/\/\/ captured and stored inside the AOT configuration file, and are accessed with\n+\/\/\/ the C++ `FinalImageRecipes` class.  Classes regenerated from these *traces*\n+\/\/\/ are linked in assembly phase; see `regeneratedClasses.hpp`.\n+\/\/\/\n+\/\/\/ @see #generateHolderClasses(Stream)\n+\/\/\/ @see BoundMethodHandle.Specializer\n+\/\/\/ @see DelegatingMethodHandle.Holder\n+\/\/\/ @see DirectMethodHandle.Holder\n+\/\/\/ @see Invokers.Holder\n+\/\/\/ @see LambdaForm.Holder\n+\/\/\/ @see VarHandleGuards\n+final class GenerateJLIClassesHelper {\n@@ -71,0 +135,1 @@\n+    static final Annotation AOT_SAFE_ANNOTATION = Annotation.of(AOTSafeClassInitializer.class.describeConstable().orElseThrow());\n@@ -289,7 +354,17 @@\n-    \/*\n-     * Returns a map of class name in internal form to the corresponding class bytes\n-     * per the given stream of SPECIES_RESOLVE and LF_RESOLVE trace logs.\n-     *\n-     * Used by GenerateJLIClassesPlugin to pre-generate holder classes during\n-     * jlink phase.\n-     *\/\n+    \/\/\/ Returns a map from class names in internal form to the corresponding\n+    \/\/\/ class bytes.\n+    \/\/\/\n+    \/\/\/ A few known lambda forms, such as field accessors, can be comprehensively\n+    \/\/\/ generated.  Most others lambda forms are associated with unique method\n+    \/\/\/ types; thus they are generated per the given stream of SPECIES_RESOLVE\n+    \/\/\/ and LF_RESOLVE *trace* logs, which are created according to {@link\n+    \/\/\/ MethodHandleStatics#TRACE_RESOLVE} configuration.\n+    \/\/\/\n+    \/\/\/ The names of methods in the generated classes are internal tokens\n+    \/\/\/ recognized by [InvokerBytecodeGenerator#lookupPregenerated] and are\n+    \/\/\/ subject to change.\n+    \/\/\/\n+    \/\/\/ @param traces the *traces* to determine the lambda forms and species\n+    \/\/\/        to generate\n+    \/\/\/ @see MethodHandleStatics#traceLambdaForm\n+    \/\/\/ @see MethodHandleStatics#traceSpeciesType\n@@ -520,0 +595,1 @@\n+               .with(RuntimeVisibleAnnotationsAttribute.of(AOT_SAFE_ANNOTATION))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":88,"deletions":12,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+\n@@ -250,0 +252,1 @@\n+@AOTSafeClassInitializer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-        java.desktop, \/\/ for ScopedValue\n@@ -159,7 +158,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n-        jdk.jartool, \/\/ participates in preview features\n-        jdk.jdeps, \/\/ participates in preview features\n-        jdk.jfr, \/\/ participates in preview features\n-        jdk.jlink,   \/\/ participates in preview features\n-        jdk.jshell, \/\/ participates in preview features\n-        jdk.incubator.code; \/\/ participates in preview features\n+        jdk.incubator.code;\n@@ -204,0 +197,2 @@\n+    exports jdk.internal.net.quic to\n+        java.net.http;\n@@ -274,0 +269,1 @@\n+        java.net.http,\n@@ -326,0 +322,1 @@\n+        java.security.sasl,\n@@ -410,2 +407,1 @@\n-    uses sun.util.resources.LocaleData.CommonResourceBundleProvider;\n-    uses sun.util.resources.LocaleData.SupplementaryResourceBundleProvider;\n+    uses sun.util.resources.LocaleData.LocaleDataResourceBundleProvider;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import com.sun.tools.javac.code.Source.Feature;\n@@ -52,1 +51,0 @@\n-import com.sun.tools.javac.comp.LambdaToMethod;\n@@ -2315,2 +2313,5 @@\n-     * Return the base type of t or any of its outer types that starts\n-     * with the given symbol.  If none exists, return null.\n+     *  This method returns the first type in a sequence (starting at `t`) that is\n+     *  a subclass of `sym`. The next type in the sequence is obtained by calling\n+     *  `getEnclosingType()` on the previous type in the sequence. Note, this is\n+     *  typically used to compute the implicit qualifier in a method\/field access\n+     *  expression. Example:\n@@ -2318,2 +2319,13 @@\n-     * @param t a type\n-     * @param sym a symbol\n+     *  static class Sup<F> { public F f; }\n+     *   class Outer {\n+     *    static class Sub extends Sup<String> {\n+     *        class I {\n+     *          void test() {\n+     *              String f2 = f; \/\/ Sup<String>::f\n+     *          }\n+     *        }\n+     *    }\n+     *  }\n+     *\n+     *  @param t a type\n+     *  @param sym a symbol\n@@ -2322,16 +2334,5 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                t = t.getEnclosingType();\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case ARRAY:\n-            return isSubtype(t, sym.type) ? sym.type : null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n+        Type t1 = t;\n+        while (!t1.hasTag(NONE)) {\n+            Type s = asSuper(t1, sym);\n+            if (s != null) return s;\n+            t1 = t1.getEnclosingType();\n@@ -2339,0 +2340,1 @@\n+        return null;\n@@ -2342,2 +2344,13 @@\n-     * Return the base type of t or any of its enclosing types that\n-     * starts with the given symbol.  If none exists, return null.\n+     * This method returns the first type in a sequence (starting at `t`) that is\n+     * a subclass of `sym`. The next type in the sequence is obtained by obtaining\n+     * innermost lexically enclosing class type of the previous type in the sequence.\n+     * Note, this is typically used to compute the implicit qualifier in\n+     * a type expression. Example:\n+     *\n+     * class A<T> { class B { } }\n+     *\n+     * class C extends A<String> {\n+     *   static class D {\n+     *      B b; \/\/ A<String>.B\n+     *   }\n+     * }\n@@ -2349,19 +2362,7 @@\n-        switch (t.getTag()) {\n-        case CLASS:\n-            do {\n-                Type s = asSuper(t, sym);\n-                if (s != null) return s;\n-                Type outer = t.getEnclosingType();\n-                t = (outer.hasTag(CLASS)) ? outer :\n-                    (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :\n-                    Type.noType;\n-            } while (t.hasTag(CLASS));\n-            return null;\n-        case ARRAY:\n-            return isSubtype(t, sym.type) ? sym.type : null;\n-        case TYPEVAR:\n-            return asSuper(t, sym);\n-        case ERROR:\n-            return t;\n-        default:\n-            return null;\n+        Type t1 = t;\n+        while (!t1.hasTag(NONE)) {\n+            Type s = asSuper(t1, sym);\n+            if (s != null) return s;\n+            t1 = (t1.tsym.owner.enclClass() != null)\n+                    ? t1.tsym.owner.enclClass().type\n+                    : noType;\n@@ -2369,0 +2370,1 @@\n+        return null;\n@@ -4593,1 +4595,1 @@\n-        List<Type> commonSupers = superClosure(to, erasure(from));\n+        List<Type> commonSupers = supertypeClosure(to, erasure(from));\n@@ -4651,1 +4653,1 @@\n-    private List<Type> superClosure(Type t, Type s) {\n+    private List<Type> supertypeClosure(Type t, Type s) {\n@@ -4657,1 +4659,1 @@\n-                cl = union(cl, superClosure(l.head, s));\n+                cl = union(cl, supertypeClosure(l.head, s));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":48,"deletions":46,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -88,1 +89,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n@@ -108,0 +108,1 @@\n+    final LintMapper lintMapper;\n@@ -126,1 +127,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -147,0 +147,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -166,1 +167,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -876,1 +876,0 @@\n-        deferredLintHandler.push(variable);\n@@ -892,1 +891,0 @@\n-            deferredLintHandler.pop();\n@@ -1021,1 +1019,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1208,1 +1205,1 @@\n-                    log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);\n+                    log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract(tree.sym, owner));\n@@ -1256,1 +1253,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m);\n@@ -1259,2 +1256,2 @@\n-                \/\/ Start of constructor prologue\n-                localEnv.info.ctorPrologue = isConstructor;\n+                \/\/ Start of constructor prologue (if not in java.lang.Object constructor)\n+                localEnv.info.ctorPrologue = isConstructor && owner.type != syms.objectType;\n@@ -1286,1 +1283,1 @@\n-                        tree.vartype = make.Erroneous();\n+                        tree.vartype = make.at(tree.pos()).Erroneous();\n@@ -1293,1 +1290,1 @@\n-                            tree.vartype = make.Erroneous();\n+                            tree.vartype = make.at(tree.pos()).Erroneous();\n@@ -1320,1 +1317,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1365,1 +1361,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym);\n@@ -1462,1 +1458,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);\n+            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner);\n@@ -1975,1 +1971,1 @@\n-            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+            log.warning(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2077,1 +2073,1 @@\n-                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -2803,10 +2799,3 @@\n-        Type clazztype;\n-\n-        try {\n-            env.info.isAnonymousNewClass = tree.def != null;\n-            clazztype = TreeInfo.isEnumInit(env.tree) ?\n-                attribIdentAsEnumType(env, (JCIdent)clazz) :\n-                attribType(clazz, env);\n-        } finally {\n-            env.info.isAnonymousNewClass = false;\n-        }\n+        Type clazztype = TreeInfo.isEnumInit(env.tree) ?\n+            attribIdentAsEnumType(env, (JCIdent)clazz) :\n+            attribType(clazz, env);\n@@ -2856,1 +2845,1 @@\n-            if (cdef == null && !isSpeculativeDiamondInferenceRound && \/\/ class body may be nulled out in speculative tree copy\n+            if (cdef == null && !tree.classDeclRemoved() && !isSpeculativeDiamondInferenceRound && \/\/ class body may be nulled out in speculative tree copy\n@@ -4283,2 +4272,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                              Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.UNCONDITIONAL_PATTERN_IN_INSTANCEOF.error(this.sourceName));\n@@ -4304,2 +4292,1 @@\n-                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    log.error(tree.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n@@ -4366,1 +4353,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n+        annotate.annotateLater(tree.var.mods.annotations, env, v);\n@@ -4368,1 +4355,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v);\n@@ -4606,1 +4593,1 @@\n-            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n+            log.warning(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4633,1 +4620,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4635,1 +4622,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -4712,3 +4699,13 @@\n-                    Symbol sym2 = (sym.flags() & Flags.PRIVATE) != 0 ?\n-                        rs.new AccessError(env, site, sym) :\n-                                sym;\n+                    \/\/ JLS 4.9 specifies the members are derived by inheritance.\n+                    \/\/ We skip inducing a whole class by filtering members that\n+                    \/\/ can never be inherited:\n+                    Symbol sym2;\n+                    if (sym.isPrivate()) {\n+                        \/\/ Private members\n+                        sym2 = rs.new AccessError(env, site, sym);\n+                    } else if (sym.owner.isInterface() && sym.kind == MTH && (sym.flags() & STATIC) != 0) {\n+                        \/\/ Interface static methods\n+                        sym2 = rs.new SymbolNotFoundError(ABSENT_MTH);\n+                    } else {\n+                        sym2 = sym;\n+                    }\n@@ -4813,5 +4810,2 @@\n-                    else if (ownOuter.hasTag(CLASS) && site != ownOuter) {\n-                        Type normOuter = site;\n-                        if (normOuter.hasTag(CLASS)) {\n-                            normOuter = types.asEnclosingSuper(site, ownOuter.tsym);\n-                        }\n+                    else if ((ownOuter.hasTag(CLASS) || ownOuter.hasTag(TYPEVAR)) && site != ownOuter) {\n+                        Type normOuter = types.asEnclosingSuper(site, ownOuter.tsym);\n@@ -5203,2 +5197,2 @@\n-                        if (site.hasTag(CLASS))\n-                            site = types.asOuterSuper(site, clazzOuter.tsym);\n+                        if (site.hasTag(CLASS) || site.hasTag(TYPEVAR))\n+                            site = types.asEnclosingSuper(site, clazzOuter.tsym);\n@@ -5392,2 +5386,1 @@\n-        if (!env.info.isAnonymousNewClass)\n-            annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);\n+        annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);\n@@ -5440,0 +5433,3 @@\n+\n+        \/\/ Now that this tree is attributed, we can calculate the Lint configuration everywhere within it\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n@@ -5482,1 +5478,0 @@\n-            deferredLintHandler.flush(env.tree, lint);\n@@ -5666,1 +5661,0 @@\n-                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5712,4 +5706,2 @@\n-        chk.checkModuleName(tree);\n-        chk.checkDeprecatedAnnotation(tree, msym);\n-\n-            deferredLintHandler.flush(tree, lint);\n+            chk.checkModuleName(tree);\n+            chk.checkDeprecatedAnnotation(tree, msym);\n@@ -5854,0 +5846,3 @@\n+        } else if (tree.declaredUsingVar()) {\n+            Assert.check(tree.typePos != Position.NOPOS);\n+            tree.vartype = make.at(tree.typePos).Type(type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":50,"deletions":55,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2834,1 +2834,2 @@\n-            JCExpression exactnessCheck = null;\n+            JCStatement prefixStatement;\n+            JCExpression exactnessCheck;\n@@ -2837,8 +2838,2 @@\n-            \/\/ preserving the side effects of the value\n-            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n-                    names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n-                    types.erasure(tree.expr.type),\n-                    currentMethodSym);\n-            JCStatement var = make.at(tree.pos())\n-                    .VarDef(dollar_s, instanceOfExpr);\n-\n+                \/\/ instanceOfExpr; true\n+                prefixStatement = make.Exec(instanceOfExpr);\n@@ -2847,7 +2842,5 @@\n-            }\n-            else if (tree.expr.type.isReference()) {\n-                JCExpression nullCheck =\n-                        makeBinary(NE,\n-                            make.Ident(dollar_s),\n-                            makeNull());\n-\n+            } else if (tree.expr.type.isPrimitive()) {\n+                \/\/ ExactConversionSupport.isXxxExact(instanceOfExpr)\n+                prefixStatement = null;\n+                exactnessCheck = getExactnessCheck(tree, instanceOfExpr);\n+            } else if (tree.expr.type.isReference()) {\n@@ -2855,6 +2848,3 @@\n-                    exactnessCheck = nullCheck;\n-                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n-                    exactnessCheck =\n-                        makeBinary(AND,\n-                            nullCheck,\n-                            getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n+                    \/\/ instanceOfExpr != null\n+                    prefixStatement = null;\n+                    exactnessCheck = makeBinary(NE, instanceOfExpr, makeNull());\n@@ -2862,6 +2852,26 @@\n-                    exactnessCheck =\n-                        makeBinary(AND,\n-                            nullCheck,\n-                            make.at(tree.pos())\n-                                .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n-                                .setType(syms.booleanType));\n+                    \/\/ We read the result of instanceOfExpr, so create variable\n+                    VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                            names.fromString(\"tmp\" + variableIndex++ + this.target.syntheticNameChar()),\n+                            types.erasure(tree.expr.type),\n+                            currentMethodSym);\n+                    prefixStatement = make.at(tree.pos())\n+                            .VarDef(dollar_s, instanceOfExpr);\n+\n+                    JCExpression nullCheck =\n+                            makeBinary(NE,\n+                                    make.Ident(dollar_s),\n+                                    makeNull());\n+\n+                    if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                        exactnessCheck =\n+                            makeBinary(AND,\n+                                nullCheck,\n+                                getExactnessCheck(tree, boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type))));\n+                    } else {\n+                        exactnessCheck =\n+                            makeBinary(AND,\n+                                nullCheck,\n+                                make.at(tree.pos())\n+                                    .TypeTest(make.Ident(dollar_s), make.Type(types.boxedClass(tree.pattern.type).type))\n+                                    .setType(syms.booleanType));\n+                    }\n@@ -2869,0 +2879,2 @@\n+            } else {\n+                throw Assert.error(\"Non primitive or reference type: \" + tree.expr.type);\n@@ -2870,5 +2882,1 @@\n-            else if (tree.expr.type.isPrimitive()) {\n-                exactnessCheck = getExactnessCheck(tree, make.Ident(dollar_s));\n-            }\n-\n-            result = make.LetExpr(List.of(var), exactnessCheck)\n+            result = (prefixStatement == null ? exactnessCheck : make.LetExpr(List.of(prefixStatement), exactnessCheck))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1146,3 +1146,1 @@\n-        tree.bounds = translate(tree.bounds, null);\n-        tree.type = erasure(tree.type);\n-        result = tree;\n+        result = translate(tree.bounds.head, null);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        locations.update(log, lint, FSInfo.instance(context));\n+        locations.update(log, FSInfo.instance(context));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -566,6 +566,0 @@\n-            Map<String,String> env = new HashMap<>();\n-            \/\/ ignores timestamps not stored in ZIP central directory, reducing I\/O\n-            \/\/ This key is handled by ZipFileSystem only.\n-            env.put(\"zipinfo-time\", \"false\");\n-\n-                env.put(\"multi-release\", multiReleaseValue);\n@@ -575,0 +569,1 @@\n+                Map<String, ?> env = fsInfo.readOnlyJarFSEnv(multiReleaseValue);\n@@ -582,2 +577,5 @@\n-                \/\/ or if non \"*.jar\" files are on the classpath.\n-                this.fileSystem = FileSystems.newFileSystem(archivePath, env, (ClassLoader)null);\n+                \/\/ or if non \"*.jar\" files are on the classpath. If this is not a ZIP\/JAR file then it\n+                \/\/ will ignore ZIP specific parameters in env, and may not end up being read-only.\n+                \/\/ However, Javac should never attempt to write back to archives either way.\n+                Map<String, ?> env = fsInfo.readOnlyJarFSEnv(null);\n+                this.fileSystem = FileSystems.newFileSystem(archivePath, env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -759,0 +759,5 @@\n+            \/\/make sure variables defined in the let expression are not included\n+            \/\/in the defined variables for jumps that go outside of this let\n+            \/\/expression:\n+            undefineVariablesInChain(result.falseJumps, limit);\n+            undefineVariablesInChain(result.trueJumps, limit);\n@@ -766,0 +771,7 @@\n+        \/\/where:\n+        private void undefineVariablesInChain(Chain toClear, int limit) {\n+            while (toClear != null) {\n+                toClear.state.defined.excludeFrom(limit);\n+                toClear = toClear.next;\n+            }\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.EnumSet;\n@@ -66,0 +67,1 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n@@ -267,0 +269,4 @@\n+    \/** The Lint mapper.\n+     *\/\n+    protected LintMapper lintMapper;\n+\n@@ -279,4 +285,0 @@\n-    \/** The preview language version.\n-     *\/\n-    protected Preview preview;\n-\n@@ -399,0 +401,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -420,1 +423,0 @@\n-        preview = Preview.instance(context);\n@@ -451,1 +453,2 @@\n-        werror        = options.isSet(WERROR);\n+        werrorAny     = options.isSet(WERROR) || options.isSet(WERROR_CUSTOM, Option.LINT_CUSTOM_ALL);\n+        werrorLint    = options.getLintCategoriesOf(WERROR, LintCategory::newEmptySet);\n@@ -524,1 +527,1 @@\n-    \/** Switch: treat warnings as errors\n+    \/** Switch: treat any kind of warning (lint or non-lint) as an error.\n@@ -526,1 +529,5 @@\n-    protected boolean werror;\n+    protected boolean werrorAny;\n+\n+    \/** Switch: treat lint warnings in the specified {@link LintCategory}s as errors.\n+     *\/\n+    protected EnumSet<LintCategory> werrorLint;\n@@ -591,1 +598,3 @@\n-        if (werror && log.nerrors == 0 && log.nwarnings > 0) {\n+        log.reportOutstandingWarnings();\n+        if (log.nerrors == 0 && log.nwarnings > 0 &&\n+                (werrorAny || werrorLint.clone().removeAll(log.lintWarnings))) {\n@@ -597,0 +606,7 @@\n+    \/**\n+     * Should warnings in the given lint category be treated as errors due to a {@code -Werror} flag?\n+     *\/\n+    public boolean isWerror(LintCategory lc) {\n+        return werrorAny || werrorLint.contains(lc);\n+    }\n+\n@@ -641,0 +657,1 @@\n+        lintMapper.startParsingFile(filename);\n@@ -660,0 +677,1 @@\n+        lintMapper.finishParsingFile(tree);\n@@ -1688,2 +1706,1 @@\n-                env.tree = TransPatterns.instance(context)\n-                        .translateTopLevelClass(env, env.tree, localMake);\n+                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n@@ -1918,2 +1935,2 @@\n-        chk.reportDeferredDiagnostics();\n-        preview.reportDeferredDiagnostics();\n+        log.reportOutstandingWarnings();\n+        log.reportOutstandingNotes();\n@@ -1921,1 +1938,1 @@\n-            log.mandatoryNote(null, Notes.CompressedDiags);\n+            log.note(Notes.CompressedDiags);\n@@ -1996,0 +2013,1 @@\n+        lintMapper = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,1 @@\n+        ensureEntered(\"getAllModuleElements\");\n@@ -807,0 +808,1 @@\n+            case ERR -> null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    private final Lint lint;\n@@ -210,1 +209,0 @@\n-        lint = Lint.instance(context);\n@@ -217,1 +215,1 @@\n-        werror = options.isSet(Option.WERROR);\n+        werror = compiler.isWerror(PROCESSING);\n@@ -630,1 +628,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n+                       boolean allowModules, ProcessingEnvironment env) {\n@@ -651,2 +649,1 @@\n-                        add(importStringToPattern(allowModules, annotationPattern,\n-                                                  processor, log, lint));\n+                        add(importStringToPattern(allowModules, annotationPattern, processor, log));\n@@ -654,1 +651,1 @@\n-                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -667,1 +664,1 @@\n-                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -675,2 +672,1 @@\n-                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -763,2 +759,1 @@\n-                                                           JavacProcessingEnvironment.this,\n-                                                           lint);\n+                                                           JavacProcessingEnvironment.this);\n@@ -892,1 +887,1 @@\n-        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n+        if (unmatchedAnnotations.size() > 0) {\n@@ -1653,1 +1648,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {\n@@ -1666,1 +1661,1 @@\n-                return warnAndNoMatches(s, p, log, lint);\n+                return warnAndNoMatches(s, p, log);\n@@ -1675,1 +1670,1 @@\n-            return warnAndNoMatches(s, p, log, lint);\n+            return warnAndNoMatches(s, p, log);\n@@ -1679,2 +1674,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n-        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log) {\n+        log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-    cannot reference {0} before supertype constructor has been called\n+    reference to {0} may only appear after an explicit constructor invocation\n@@ -404,1 +404,1 @@\n-    cannot assign initialized field ''{0}'' before supertype constructor has been called\n+    assignment to initialized field ''{0}'' may only appear after an explicit constructor invocation\n@@ -908,0 +908,1 @@\n+# 0: symbol, 1: symbol\n@@ -909,1 +910,1 @@\n-    method does not override or implement a method from a supertype\n+    {0} in {1} does not override or implement a method from a supertype\n@@ -911,0 +912,1 @@\n+# 0: symbol, 1: symbol\n@@ -912,1 +914,1 @@\n-    static methods cannot be annotated with @Override\n+    static method {0} in {1} cannot be annotated with @Override\n@@ -914,0 +916,1 @@\n+# 0: symbol, 1: symbol\n@@ -915,1 +918,1 @@\n-    missing method body, or declare abstract\n+    method {0} in {1} is missing a method body, or should be declared abstract\n@@ -1614,0 +1617,1 @@\n+# flags: default-enabled\n@@ -1690,0 +1694,1 @@\n+# flags: mandatory\n@@ -1937,0 +1942,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -1942,0 +1948,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -1947,0 +1954,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -1957,0 +1965,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -1968,0 +1977,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -1973,0 +1983,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -1977,0 +1988,1 @@\n+# flags: strict\n@@ -2200,0 +2212,1 @@\n+# flags: default-enabled\n@@ -2205,0 +2218,1 @@\n+# flags: default-enabled\n@@ -2230,0 +2244,1 @@\n+# flags: default-enabled\n@@ -2235,0 +2250,1 @@\n+# flags: default-enabled\n@@ -2247,0 +2263,1 @@\n+# flags: default-enabled\n@@ -2371,0 +2388,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -2376,0 +2394,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -2385,0 +2404,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -2392,0 +2412,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -2397,0 +2418,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -2795,0 +2817,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -3191,0 +3214,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -3197,0 +3221,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -3260,0 +3285,1 @@\n+# flags: source-level\n@@ -3265,0 +3291,1 @@\n+# flags: source-level\n@@ -3280,0 +3307,1 @@\n+# flags: source-level\n@@ -3285,0 +3313,1 @@\n+# flags: source-level\n@@ -3296,0 +3325,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -3301,0 +3331,1 @@\n+# flags: aggregate, mandatory, default-enabled\n@@ -3306,0 +3337,1 @@\n+# flags: mandatory\n@@ -3870,0 +3902,1 @@\n+# flags: default-enabled\n@@ -3886,0 +3919,1 @@\n+# flags: default-enabled\n@@ -4263,0 +4297,1 @@\n+# flags: aggregate, mandatory, default-enabled\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1015,0 +1015,7 @@\n+\n+        public enum DeclKind {\n+            EXPLICIT,       \/\/ \"SomeType name\"\n+            IMPLICIT,       \/\/ \"name\"\n+            VAR,            \/\/ \"var name\"\n+        }\n+\n@@ -1027,4 +1034,4 @@\n-        \/** explicit start pos *\/\n-        public int startPos = Position.NOPOS;\n-        \/** declared using `var` *\/\n-        private boolean declaredUsingVar;\n+        \/** how the variable's type was declared *\/\n+        public DeclKind declKind;\n+        \/** a source code position to use for \"vartype\" when null (can happen if declKind != EXPLICIT) *\/\n+        public int typePos;\n@@ -1037,1 +1044,1 @@\n-            this(mods, name, vartype, init, sym, false);\n+            this(mods, name, vartype, init, sym, DeclKind.EXPLICIT, Position.NOPOS);\n@@ -1045,1 +1052,2 @@\n-                                 boolean declaredUsingVar) {\n+                                 DeclKind declKind,\n+                                 int typePos) {\n@@ -1051,1 +1059,2 @@\n-            this.declaredUsingVar = declaredUsingVar;\n+            this.declKind = declKind;\n+            this.typePos = typePos;\n@@ -1057,1 +1066,1 @@\n-            this(mods, null, vartype, null, null, false);\n+            this(mods, null, vartype, null, null, DeclKind.EXPLICIT, Position.NOPOS);\n@@ -1072,1 +1081,1 @@\n-            return declaredUsingVar;\n+            return declKind == DeclKind.VAR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -626,3 +626,1 @@\n-                if (node.startPos != Position.NOPOS) {\n-                    return node.startPos;\n-                } else if (node.mods.pos != Position.NOPOS) {\n+                if (node.mods.pos != Position.NOPOS) {\n@@ -630,5 +628,1 @@\n-                } else if (node.vartype == null || node.vartype.pos == Position.NOPOS) {\n-                    \/\/if there's no type (partially typed lambda parameter)\n-                    \/\/simply return node position\n-                    return node.pos;\n-                } else {\n+                } else if (node.vartype != null) {\n@@ -636,0 +630,2 @@\n+                } else if (node.typePos != Position.NOPOS) {\n+                    return node.typePos;\n@@ -637,0 +633,1 @@\n+                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -143,1 +143,2 @@\n- * strings that can be used with {@code @SuppressWarnings}.\n+ * strings that are recognized by <em>javac<\/em> in {@code @SuppressWarnings}\n+ * annotations. Unrecognized strings are ignored.\n@@ -154,1 +155,0 @@\n- * <tr><th scope=\"row\">{@code classfile}            <td>issues related to classfile contents\n@@ -167,1 +167,0 @@\n- * <tr><th scope=\"row\">{@code incubating}           <td>use of incubating modules\n@@ -175,1 +174,0 @@\n- * <tr><th scope=\"row\">{@code path}                 <td>invalid path elements on the command line\n@@ -179,1 +177,0 @@\n- * <tr><th scope=\"row\">{@code restricted}           <td>use of restricted methods\n@@ -182,0 +179,1 @@\n+ * <tr><th scope=\"row\">{@code restricted}           <td>use of restricted methods\n@@ -189,5 +187,3 @@\n- * <tr><th scope=\"row\">{@code synchronization}      <td>synchronization attempts on instances of value-based classes;\n- *                                                      this key is a deprecated alias for {@code identity}, which has\n- *                                                      the same uses and effects. Users are encouraged to use the\n- *                                                      {@code identity} category for all future and existing uses of\n- *                                                      {@code synchronization}\n+ * <tr><th scope=\"row\">{@code synchronization}      <td>deprecated alias for {@code identity} with an identical effect.\n+ *                                                      Users are encouraged to use {@code identity} instead of\n+ *                                                      {@code synchronization} for all current and future uses.\n@@ -209,0 +205,19 @@\n+ * All of the non-{@code docllint:} strings listed above may also be used with the {@code -Xlint} command line flag.\n+ * The {@code -Xlint} flag also supports these strings not supported by {@code @SuppressWarnings}:\n+ *\n+ * <table class=\"striped\">\n+ *     <caption>Strings supported by {@code -Xlint} but not {@code SuppressWarnings}<\/caption>\n+ * <thead>\n+ * <tr><th>String<th>Warnings Related To ...\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\">{@code classfile}            <td>issues related to classfile contents\n+ * <tr><th scope=\"row\">{@code incubating}           <td>use of incubating modules\n+ * <tr><th scope=\"row\">{@code options}              <td>issues relating to use of command line options\n+ * <tr><th scope=\"row\">{@code output-file-clash}    <td>output files being overwritten due to filename clashes\n+ * <tr><th scope=\"row\">{@code path}                 <td>invalid path elements on the command line\n+ * <tr><th scope=\"row\">{@code processing}           <td>issues regarding annotation processing\n+ * <tr><th scope=\"row\">{@code restricted}           <td>use of restricted methods\n+ * <\/tbody>\n+ * <\/table>\n+ *\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -320,2 +320,1 @@\n-    jdk\/internal\/jrtfs \\\n-    sun\/tools\/jrunscript\n+    jdk\/internal\/jrtfs\n@@ -326,1 +325,0 @@\n-    -sun\/tools\/jrunscript \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}