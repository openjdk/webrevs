{"files":[{"patch":"@@ -44,0 +44,1 @@\n+    jdk.incubator.code \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import sun.util.logging.PlatformLogger;\n@@ -141,1 +142,0 @@\n-        private final TreeSet<String> linkerTypes = new TreeSet<>();\n@@ -156,6 +156,0 @@\n-        HolderClassBuilder addLinkerType(String methodType) {\n-            validateMethodType(methodType);\n-            linkerTypes.add(methodType);\n-            return this;\n-        }\n-\n@@ -187,1 +181,0 @@\n-\n@@ -190,1 +183,0 @@\n-\n@@ -205,17 +197,1 @@\n-            \/\/ The linker type to ask for is retrieved by removing the first\n-            \/\/ and the last argument, which needs to be of Object.class\n-            MethodType[] linkerMethodTypes = new MethodType[linkerTypes.size()];\n-            index = 0;\n-            for (String linkerType : linkerTypes) {\n-                MethodType mt = asMethodType(linkerType);\n-                final int lastParam = mt.parameterCount() - 1;\n-                if (!checkLinkerTypeParams(mt)) {\n-                    throw new RuntimeException(\n-                            \"Linker type parameter must start and end with Object: \" + linkerType);\n-                }\n-                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n-                linkerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n-                index++;\n-            }\n-\n-            \/\/ argument, which needs to be of Object.class\n+            \/\/ and the last argument, which needs to be of Object.class\n@@ -227,0 +203,1 @@\n+                final int lastParam = mt.parameterCount() - 1;\n@@ -229,1 +206,1 @@\n-                            \"Invoker type parameter must start with 2 Objects: \" + invokerType);\n+                            \"Invoker type parameter must start and end with Object: \" + invokerType);\n@@ -231,1 +208,2 @@\n-                invokerMethodTypes[index] = mt.dropParameterTypes(0, 2);\n+                mt = mt.dropParameterTypes(lastParam, lastParam + 1);\n+                invokerMethodTypes[index] = mt.dropParameterTypes(0, 1);\n@@ -250,1 +228,0 @@\n-\n@@ -260,1 +237,1 @@\n-                            linkerMethodTypes, invokerMethodTypes, callSiteMethodTypes));\n+                            invokerMethodTypes, callSiteMethodTypes));\n@@ -268,1 +245,0 @@\n-\n@@ -274,1 +250,0 @@\n-\n@@ -296,6 +271,0 @@\n-            return (mt.parameterCount() >= 2 &&\n-                    mt.parameterType(0) == Object.class &&\n-                    mt.parameterType(1) == Object.class);\n-        }\n-\n-        public static boolean checkLinkerTypeParams(MethodType mt) {\n@@ -425,4 +394,8 @@\n-                                } else if (parts[2].endsWith(\"nvoker\")) {\n-                                    \/\/ MH.exactInvoker exactInvoker MH.invoker invoker\n-                                    builder.addInvokerType(methodType);\n-                                    builder.addLinkerType(methodType);\n+                                    MethodType mt = HolderClassBuilder.asMethodType(methodType);\n+                                    \/\/ Work around JDK-8327499\n+                                    if (HolderClassBuilder.checkInvokerTypeParams(mt)) {\n+                                        builder.addInvokerType(methodType);\n+                                    } else {\n+                                        PlatformLogger.getLogger(\"java.lang.invoke\")\n+                                                .warning(\"Invalid LF_RESOLVE \" + parts[1] + \" \" + parts[2] + \" \" + parts[3]);\n+                                    }\n@@ -567,2 +540,2 @@\n-     * the invoker forms for the set of supplied {@code linkerMethodTypes}\n-     * {@code invokerMethodTypes}, and {@code callSiteMethodTypes}.\n+     * the invoker forms for the set of supplied {@code invokerMethodTypes}\n+     * and {@code callSiteMethodTypes}.\n@@ -571,2 +544,1 @@\n-            MethodType[] linkerMethodTypes, MethodType[] invokerMethodTypes,\n-            MethodType[] callSiteMethodTypes) {\n+            MethodType[] invokerMethodTypes, MethodType[] callSiteMethodTypes) {\n@@ -577,2 +549,2 @@\n-\n-        int[] invokerTypes = {\n+        int[] types = {\n+            MethodTypeForm.LF_EX_LINKER,\n@@ -580,1 +552,2 @@\n-            MethodTypeForm.LF_GEN_INVOKER,\n+            MethodTypeForm.LF_GEN_LINKER,\n+            MethodTypeForm.LF_GEN_INVOKER\n@@ -583,1 +556,1 @@\n-        for (MethodType methodType : invokerMethodTypes) {\n+        for (int i = 0; i < invokerMethodTypes.length; i++) {\n@@ -585,3 +558,3 @@\n-            if (dedupSet.add(methodType)) {\n-                for (int type : invokerTypes) {\n-                    LambdaForm invokerForm = Invokers.invokeHandleForm(methodType,\n+            if (dedupSet.add(invokerMethodTypes[i])) {\n+                for (int type : types) {\n+                    LambdaForm invokerForm = Invokers.invokeHandleForm(invokerMethodTypes[i],\n@@ -595,18 +568,0 @@\n-        int[] linkerTypes = {\n-                MethodTypeForm.LF_EX_LINKER,\n-                MethodTypeForm.LF_GEN_LINKER,\n-        };\n-\n-        dedupSet = new HashSet<>();\n-        for (MethodType methodType : linkerMethodTypes) {\n-            \/\/ generate methods representing linkers of the specified type\n-            if (dedupSet.add(methodType)) {\n-                for (int type : linkerTypes) {\n-                    LambdaForm linkerForm = Invokers.invokeHandleForm(methodType,\n-                            \/*customized*\/false, type);\n-                    forms.add(linkerForm);\n-                    names.add(linkerForm.kind.defaultLambdaName);\n-                }\n-            }\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":26,"deletions":71,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -273,0 +273,4 @@\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n+     * must be a {@code Quotable} object, inspectable using code reflection. *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -355,1 +359,2 @@\n-                                             EMPTY_MT_ARRAY);\n+                                             EMPTY_MT_ARRAY,\n+                                 null);\n@@ -401,0 +406,1 @@\n+     *                          MethodHandle quotableField    \/\/ IF flags has QUOTABLE set\n@@ -424,0 +430,4 @@\n+     *     <li>{@code quotableField} is a\n+     *     {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter} method handle\n+     *     that is used to retrieve the string representation of the quotable lambda's associated\n+     *     intermediate representation.<\/li>\n@@ -438,0 +448,3 @@\n+     * <p>When FLAG_QUOTABLE is set in {@code flags}, the function objects\n+     * will implement {@code Quotable}.\n+     *\n@@ -503,0 +516,2 @@\n+        \/\/ Getter that returns the op of a Quotable instance\n+        MethodHandle quotableOpGetter = null;\n@@ -523,0 +538,5 @@\n+        if ((flags & FLAG_QUOTABLE) != 0) {\n+            quotableOpGetter = extractArg(args, argIndex++, MethodHandle.class);\n+            altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+            altInterfaces[altInterfaces.length-1] = InnerClassLambdaMetafactory.CodeReflectionSupport.QUOTABLE_CLASS;\n+        }\n@@ -547,1 +567,2 @@\n-                                                  altMethods);\n+                                                  altMethods,\n+                                                  quotableOpGetter);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -157,1 +157,2 @@\n-        jdk.compiler;\n+        jdk.compiler,\n+        jdk.incubator.code;\n@@ -170,1 +171,4 @@\n-        jdk.crypto.cryptoki;\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.code;\n+    exports jdk.internal.access.code to\n+        jdk.compiler;\n@@ -308,1 +312,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.code;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -204,0 +204,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -210,0 +220,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -213,0 +265,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -251,5 +305,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -310,0 +371,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -313,0 +375,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -327,1 +390,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -336,1 +399,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -354,1 +417,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -358,1 +421,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -368,1 +431,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -391,2 +454,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -420,1 +483,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5339,0 +5415,24 @@\n+\n+    \/\/ code reflection\n+\n+    \/\/ The predicates below do not use a predefined symbol in Symtab.\n+    \/\/ This is deliberate, as we cannot initialize symbols in modules\n+    \/\/ other than java.base at startup.\n+\n+    public boolean isQuoted(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quoted) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n+\n+    public boolean isQuotable(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quotable) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":113,"deletions":13,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -51,0 +53,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -52,0 +55,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -53,0 +57,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -66,0 +71,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -447,0 +453,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3158,0 +3177,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3301,0 +3328,99 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(checkQuotedReturnExpr((JCExpression) that.getBody()));\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : checkQuotedReturnExpr(tree.expr));\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            boolean hasErroneousType = restypes.toList()\n+                    .stream().anyMatch(Type::isErroneous);\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                if (hasErroneousType) {\n+                    restype = syms.errorType;\n+                } else {\n+                    boolean hasNonVoidReturn = restypes.toList()\n+                            .stream().anyMatch(t -> t != syms.voidType);\n+                    boolean hasVoidReturn = restypes.toList()\n+                            .stream().anyMatch(t -> t == syms.voidType);\n+\n+                    if (hasVoidReturn && hasNonVoidReturn) {\n+                        \/\/ void vs. non-void mismatch\n+                        log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                        restype = syms.errorType;\n+                    } else if (hasVoidReturn) {\n+                        restype = syms.voidType;\n+                    } else {\n+                        restype = condType(resPositions.toList(), restypes.toList());\n+                    }\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (!hasErroneousType && restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n@@ -3302,0 +3428,8 @@\n+        Type checkQuotedReturnExpr(JCExpression retExpr) {\n+            if (retExpr.type.hasTag(BOT)) {\n+                log.error(retExpr, Errors.BadQuotedLambdaNullReturn);\n+            }\n+            return retExpr.type;\n+        }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-    class FreeVarCollector extends CaptureScanner {\n+    public class FreeVarCollector extends CaptureScanner {\n@@ -277,1 +277,1 @@\n-        FreeVarCollector(JCTree ownerTree) {\n+        protected FreeVarCollector(JCTree ownerTree) {\n@@ -281,1 +281,1 @@\n-        void addFreeVars(ClassSymbol c) {\n+        protected void addFreeVars(ClassSymbol c) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+                slam.codeModel = tree.codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.JavaCompiler.CodeReflectionSupport;\n@@ -194,1 +196,3 @@\n-        ClassLoader thisClassLoader = getClass().getClassLoader();\n+        ClassLoader thisClassLoader = CodeReflectionSupport.CODE_LAYER != null ?\n+                CodeReflectionSupport.CODE_LAYER.findLoader(\"jdk.incubator.code\") :\n+                getClass().getClassLoader();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.JavaCompiler.CodeReflectionSupport;\n@@ -1167,2 +1169,13 @@\n-            Configuration cf = bootLayer.configuration().resolveAndBind(ModuleFinder.of(), finder, Collections.emptySet());\n-            ModuleLayer layer = bootLayer.defineModulesWithOneLoader(cf, ClassLoader.getSystemClassLoader());\n+            ModuleLayer augmentedModuleLayer;\n+            ClassLoader parentCL;\n+            if (CodeReflectionSupport.CODE_LAYER != null) {\n+                \/\/ create a layer whose parent is Babylon's code layer\n+                augmentedModuleLayer = CodeReflectionSupport.CODE_LAYER;\n+                parentCL = CodeReflectionSupport.CODE_LAYER.findLoader(\"jdk.incubator.code\");\n+            } else {\n+                augmentedModuleLayer = bootLayer;\n+                parentCL = ClassLoader.getSystemClassLoader();\n+            }\n+            Configuration cf = augmentedModuleLayer.configuration()\n+                    .resolveAndBind(ModuleFinder.of(), finder, Collections.emptySet());\n+            ModuleLayer layer = augmentedModuleLayer.defineModulesWithOneLoader(cf, parentCL);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.module.Configuration;\n+import java.lang.reflect.Method;\n@@ -41,0 +43,1 @@\n+import java.util.Optional;\n@@ -43,0 +46,1 @@\n+import java.util.ServiceLoader;\n@@ -90,0 +94,2 @@\n+import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n+\n@@ -380,0 +386,2 @@\n+    private boolean hasCodeReflectionModule;\n+\n@@ -1062,0 +1070,9 @@\n+\n+        if (modules.modulesInitialized()) {\n+            \/\/ This has to happen precisely here. At this point, we have all we need to\n+            \/\/ determine whether jdk.incubator.module is part of the module graph\n+            \/\/ but we have yet to trigger an ENTER event. This gives the code reflection plugin\n+            \/\/ a window to check whether code reflection should be enabled for this compilation unit.\n+            hasCodeReflectionModule = modules.getObservableModule(names.jdk_incubator_code) != null;\n+        }\n+\n@@ -1675,0 +1692,7 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                Optional<CodeReflectionTransformer> reflectMethods = reflectMethods();\n+                if (reflectMethods.isPresent()) {\n+                    env.tree = reflectMethods.get().translateTopLevelClass(context, env.tree, localMake);\n+                }\n+            }\n+\n@@ -1730,0 +1754,42 @@\n+    Optional<CodeReflectionTransformer> reflectMethods() {\n+        return CodeReflectionSupport.CODE_LAYER != null ?\n+                ServiceLoader.load(CodeReflectionSupport.CODE_LAYER, CodeReflectionTransformer.class).findFirst() :\n+                Optional.empty();\n+    }\n+\n+    public static class CodeReflectionSupport {\n+        public static final ModuleLayer CODE_LAYER;\n+\n+        static {\n+            if (ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ we are in an exploded build, so just use the boot layer\n+                CODE_LAYER = ModuleLayer.boot();\n+            } else if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ the code module is installed, but not in the boot layer, create a new layer which contains it\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(java.lang.module.ModuleFinder.of(), java.lang.module.ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                CODE_LAYER = parent.defineModulesWithOneLoader(cf, scl);\n+                Module codeReflectionModule = CODE_LAYER.findModule(\"jdk.incubator.code\").get();\n+                Module jdkCompilerModule = JavaCompiler.class.getModule();\n+                \/\/ We need to add exports all jdk.compiler packages so that the plugin can use them\n+                for (String packageName : jdkCompilerModule.getPackages()) {\n+                    jdkCompilerModule.addExports(packageName, codeReflectionModule);\n+                }\n+                \/\/ We also need to add exports all java.base packages so that the plugin can use them\n+                \/\/ But we need to do so by calling a method in java.base reflectively\n+                try {\n+                    Class<?> codeModuleLayerInit = Class.forName(\"jdk.internal.access.code.CodeModuleLayerInit\");\n+                    Method initLayerMethod = codeModuleLayerInit.getDeclaredMethod(\"initCodeModuleLayer\", ModuleLayer.class);\n+                    initLayerMethod.invoke(null, CODE_LAYER);\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            } else {\n+                \/\/ if we run in bootstrap mode, there might be no jdk.incubator.code\n+                CODE_LAYER = null;\n+            }\n+        }\n+    }\n+\n@@ -1885,0 +1951,4 @@\n+    public boolean hasCodeReflectionModule() {\n+        return hasCodeReflectionModule;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -60,0 +61,1 @@\n+import com.sun.tools.javac.comp.Attr;\n@@ -69,0 +71,1 @@\n+import com.sun.tools.javac.tree.TreeMaker;\n@@ -76,1 +79,1 @@\n-import com.sun.tools.javac.comp.Attr;\n+\n@@ -78,1 +81,1 @@\n-import com.sun.tools.javac.comp.Resolve;\n+\n@@ -98,0 +101,1 @@\n+    private final JavacTrees javacTrees;\n@@ -99,1 +103,0 @@\n-    private final Resolve resolve;\n@@ -102,0 +105,1 @@\n+    private final TreeMaker make;\n@@ -121,1 +125,1 @@\n-        resolve = Resolve.instance(context);\n+        javacTrees = JavacTrees.instance(context);\n@@ -125,0 +129,1 @@\n+        make = TreeMaker.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1409,0 +1409,11 @@\n+compiler.err.bad.quoted.lambda.null.return=\\\n+    invalid ''null'' return expression in quoted lambda\n+\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4302,0 +4313,29 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+# 0: symbol\n+compiler.err.quoted.method.inner.class=\\\n+    unsupported quoted method in inner class {0}\n+\n+# 0: symbol\n+compiler.err.quoted.lambda.inner.class=\\\n+    unsupported quoted lambda in inner class {0}\n+\n+# 0: symbol\n+compiler.err.quoted.mref.inner.class=\\\n+    unsupported quoted method reference in inner class {0}\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -803,1 +803,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -814,0 +815,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public MethodSymbol codeModel;\n@@ -816,1 +819,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -2017,1 +2027,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2606,1 +2616,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-import javax.tools.JavaCompiler;\n-import javax.tools.StandardLocation;\n+import com.sun.tools.javac.comp.CodeReflectionTransformer;\n@@ -257,1 +256,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -259,1 +259,1 @@\n-        jdk.jshell;\n+        jdk.jshell, jdk.incubator.code;\n@@ -262,1 +262,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -265,1 +266,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -270,1 +272,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -273,1 +276,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.incubator.code;\n@@ -275,1 +279,2 @@\n-        jdk.javadoc;\n+        jdk.javadoc,\n+        jdk.incubator.code;\n@@ -285,1 +290,2 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n@@ -290,1 +296,4 @@\n-        jdk.internal.md;\n+        jdk.internal.md,\n+        jdk.incubator.code;\n+    exports com.sun.tools.javac.processing to\n+        jdk.incubator.code;\n@@ -297,0 +306,1 @@\n+    uses CodeReflectionTransformer;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -682,0 +682,3 @@\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}