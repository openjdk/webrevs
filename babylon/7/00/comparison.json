{"files":[{"patch":"@@ -1,263 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Quotable;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.lang.reflect.code.interpreter.Interpreter;\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-\n-import static java.lang.reflect.code.descriptor.MethodDesc.method;\n-import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n-import static java.lang.reflect.code.descriptor.TypeDesc.type;\n-import static java.lang.reflect.code.op.CoreOps.*;\n-\n-\/*\n- * @test\n- * @run testng TestLinqUsingQuotable\n- *\/\n-\n-public class TestLinqUsingQuotable {\n-\n-    \/\/ Quotable functional interfaces\n-\n-    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n-    }\n-\n-    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n-    }\n-\n-\n-    \/\/ Query interfaces\n-\n-    public interface Queryable<T> {\n-        TypeDesc elementType();\n-\n-        \/\/ Queryable<T> -> Queryable<U>\n-        FuncOp expression();\n-\n-        QueryProvider provider();\n-\n-        @SuppressWarnings(\"unchecked\")\n-        default Queryable<T> where(QuotablePredicate<T> f) {\n-            LambdaOp l = (LambdaOp) f.quoted().op();\n-            return (Queryable<T>) insertQuery(elementType(), \"where\", l);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        default <R> Queryable<R> select(QuotableFunction<T, R> f) {\n-            LambdaOp l = (LambdaOp) f.quoted().op();\n-            return (Queryable<R>) insertQuery(l.funcDescriptor().returnType(), \"select\", l);\n-        }\n-\n-        private Queryable<?> insertQuery(TypeDesc elementType, String methodName, LambdaOp lambdaOp) {\n-            QueryProvider qp = provider();\n-\n-            \/\/ Copy function expression, replacing return operation\n-            FuncOp currentQueryExpression = expression();\n-            TypeDesc queryableType = TypeDesc.type(qp.queryableType(), elementType);\n-            FuncOp nextQueryExpression = func(\"query\",\n-                    methodType(queryableType, currentQueryExpression.funcDescriptor().parameters()))\n-                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n-                        Op.Result fi = block.op(lambdaOp);\n-\n-                        MethodDesc md = method(qp.queryableType(), methodName,\n-                                methodType(qp.queryableType(), lambdaOp.functionalInterface()).erase());\n-                        Op.Result queryable = block.op(invoke(queryableType, md, query, fi));\n-\n-                        block.op(_return(queryable));\n-                    }));\n-\n-            return qp.createQuery(elementType, nextQueryExpression);\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        default QueryResult<Stream<T>> elements() {\n-            TypeDesc resultType = type(type(Stream.class), elementType());\n-            return (QueryResult<Stream<T>>) insertQueryResult(resultType, \"elements\");\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        default QueryResult<Long> count() {\n-            return (QueryResult<Long>) insertQueryResult(TypeDesc.LONG, \"count\");\n-        }\n-\n-        private QueryResult<?> insertQueryResult(TypeDesc resultType, String methodName) {\n-            QueryProvider qp = provider();\n-\n-            \/\/ Copy function expression, replacing return operation\n-            FuncOp currentQueryExpression = expression();\n-            TypeDesc queryResultType = TypeDesc.type(qp.queryResultType(), resultType);\n-            FuncOp queryResultExpression = func(\"queryResult\",\n-                    methodType(queryResultType, currentQueryExpression.funcDescriptor().parameters()))\n-                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n-                        MethodDesc md = method(qp.queryableType(), methodName, methodType(qp.queryResultType()));\n-                        Op.Result queryResult = block.op(invoke(queryResultType, md, query));\n-\n-                        block.op(_return(queryResult));\n-                    }));\n-            return qp.createQueryResult(resultType, queryResultExpression);\n-        }\n-    }\n-\n-    public interface QueryResult<T> {\n-        TypeDesc resultType();\n-\n-        \/\/ Queryable<T> -> QueryResult<T>\n-        FuncOp expression();\n-\n-        Object execute();\n-    }\n-\n-    public interface QueryProvider {\n-        TypeDesc queryableType();\n-\n-        TypeDesc queryResultType();\n-\n-        Queryable<?> createQuery(TypeDesc elementType, FuncOp queryExpression);\n-\n-        QueryResult<?> createQueryResult(TypeDesc resultType, FuncOp expression);\n-\n-        <T> Queryable<T> newQuery(Class<T> elementType);\n-    }\n-\n-\n-    \/\/ Query implementation\n-\n-    public static final class TestQueryable<T> implements Queryable<T> {\n-        final TypeDesc elementType;\n-        final TestQueryProvider provider;\n-        final FuncOp expression;\n-\n-        TestQueryable(Class<T> tableClass, TestQueryProvider qp) {\n-            this.elementType = type(tableClass);\n-            this.provider = qp;\n-\n-            TypeDesc queryableType = TypeDesc.type(qp.queryableType(), elementType);\n-            \/\/ Initial expression is an identity function\n-            var funDescriptor = methodType(queryableType, queryableType);\n-            this.expression = func(\"query\", funDescriptor)\n-                    .body(b -> b.op(_return(b.parameters().get(0))));\n-        }\n-\n-        TestQueryable(TypeDesc elementType, TestQueryProvider provider, FuncOp expression) {\n-            this.elementType = elementType;\n-            this.provider = provider;\n-            this.expression = expression;\n-        }\n-\n-        @Override\n-        public TypeDesc elementType() {\n-            return elementType;\n-        }\n-\n-        @Override\n-        public FuncOp expression() {\n-            return expression;\n-        }\n-\n-        @Override\n-        public QueryProvider provider() {\n-            return provider;\n-        }\n-    }\n-\n-    public record TestQueryResult<T>(TypeDesc resultType, FuncOp expression) implements QueryResult<T> {\n-        @Override\n-        public Object execute() {\n-            \/\/ @@@ Compile\/translate the expression and execute it\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n-\n-    public static final class TestQueryProvider implements QueryProvider {\n-        final TypeDesc queryableType;\n-        final TypeDesc queryResultType;\n-\n-        TestQueryProvider() {\n-            this.queryableType = TypeDesc.type(Queryable.class);\n-            this.queryResultType = TypeDesc.type(QueryResult.class);\n-        }\n-\n-        @Override\n-        public TypeDesc queryableType() {\n-            return queryableType;\n-        }\n-\n-        @Override\n-        public TypeDesc queryResultType() {\n-            return queryResultType;\n-        }\n-\n-        @Override\n-        public Queryable<?> createQuery(TypeDesc elementType, FuncOp expression) {\n-            return new TestQueryable<>(elementType, this, expression);\n-        }\n-\n-        @Override\n-        public QueryResult<?> createQueryResult(TypeDesc resultType, FuncOp expression) {\n-            return new TestQueryResult<>(resultType, expression);\n-        }\n-\n-        @Override\n-        public <T> Queryable<T> newQuery(Class<T> elementType) {\n-            return new TestQueryable<>(elementType, this);\n-        }\n-    }\n-\n-\n-    static class Customer {\n-        \/\/ 1st column\n-        String contactName;\n-        \/\/ 2nd column\n-        String phone;\n-        \/\/ 3rd column\n-        String city;\n-    }\n-\n-    @Test\n-    public void testSimpleQuery() {\n-        QueryProvider qp = new TestQueryProvider();\n-\n-        QueryResult<Stream<String>> qr = qp.newQuery(Customer.class)\n-                .where(c -> c.city.equals(\"London\"))\n-                .select(c -> c.contactName).elements();\n-\n-        qr.expression().writeTo(System.out);\n-\n-        @SuppressWarnings(\"unchecked\")\n-        QueryResult<Stream<String>> qr2 = (QueryResult<Stream<String>>) Interpreter.invoke(MethodHandles.lookup(),\n-                qr.expression(), qp.newQuery(Customer.class));\n-\n-        qr2.expression().writeTo(System.out);\n-\n-        Assert.assertEquals(qr.expression().toText(), qr2.expression().toText());\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuotable.java","additions":0,"deletions":263,"binary":false,"changes":263,"status":"deleted"},{"patch":"@@ -43,1 +43,1 @@\n- * @run testng TestLinq\n+ * @run testng TestLinqUsingQuoted\n@@ -46,1 +46,1 @@\n-public class TestLinq {\n+public class TestLinqUsingQuoted {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinq.java","status":"renamed"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.reflect.code.op.CoreOps;\n@@ -28,5 +27,2 @@\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-import java.util.TreeSet;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.*;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ActiveSet.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.op.CoreOps.FuncOp;\n@@ -33,1 +31,1 @@\n-\n+import java.lang.reflect.code.op.CoreOps;\n@@ -40,6 +38,0 @@\n-import static java.lang.reflect.code.op.CoreOps._return;\n-import static java.lang.reflect.code.op.CoreOps.add;\n-import static java.lang.reflect.code.op.CoreOps.invoke;\n-import static java.lang.reflect.code.op.CoreOps.constant;\n-import static java.lang.reflect.code.op.CoreOps.mul;\n-import static java.lang.reflect.code.op.CoreOps.neg;\n@@ -47,0 +39,1 @@\n+import static java.lang.reflect.code.op.CoreOps.*;\n@@ -49,1 +42,3 @@\n-    final FuncOp f;\n+    \/\/ The function to differentiate\n+    final FuncOp fcm;\n+    \/\/ The independent variable\n@@ -51,2 +46,1 @@\n-    final TypeDesc indT;\n-\n+    \/\/ The active set for the independent variable\n@@ -54,0 +48,1 @@\n+    \/\/ The map of input value to it's (output) differentiated value\n@@ -56,0 +51,2 @@\n+    \/\/ The constant value 0.0d\n+    \/\/ Declared in the (output) function's entry block\n@@ -58,5 +55,2 @@\n-    ForwardDifferentiation(FuncOp f, Block.Parameter ind) {\n-        this.f = f;\n-\n-        Block fb = f.body().entryBlock();\n-        int indI = fb.parameters().indexOf(ind);\n+    private ForwardDifferentiation(FuncOp fcm, Block.Parameter ind) {\n+        int indI = fcm.body().entryBlock().parameters().indexOf(ind);\n@@ -66,0 +60,1 @@\n+        this.fcm = fcm;\n@@ -67,1 +62,0 @@\n-        this.indT = ind.type();\n@@ -70,1 +64,2 @@\n-        this.activeSet = ActiveSet.activeSet(f, ind);\n+        this.activeSet = ActiveSet.activeSet(fcm, ind);\n+        \/\/ A mapping of input values to their (output) differentiated values\n@@ -74,2 +69,2 @@\n-    public static FuncOp diff(FuncOp f, Block.Parameter ind) {\n-        return new ForwardDifferentiation(f, ind).diff();\n+    public static FuncOp partialDiff(FuncOp fcm, Block.Parameter ind) {\n+        return new ForwardDifferentiation(fcm, ind).partialDiff();\n@@ -78,6 +73,2 @@\n-    FuncOp diff() {\n-        Block fb = f.body().entryBlock();\n-        int indI = fb.parameters().indexOf(ind);\n-        if (indI == -1) {\n-            throw new IllegalArgumentException(\"Independent argument not defined by function\");\n-        }\n+    FuncOp partialDiff() {\n+        int indI = fcm.body().entryBlock().parameters().indexOf(ind);\n@@ -86,1 +77,1 @@\n-        FuncOp cf = f.transform(\"d\" + f.funcName() + \"_darg\" + indI,\n+        FuncOp dfcm = fcm.transform(STR.\"d\\{fcm.funcName()}_darg\\{indI}\",\n@@ -89,0 +80,1 @@\n+                        \/\/ Initialize\n@@ -92,0 +84,2 @@\n+                    \/\/ If the result of the operation is in the active set,\n+                    \/\/ then differentiate it, otherwise copy it\n@@ -94,0 +88,2 @@\n+                        \/\/ Map the input result to its (output) differentiated result\n+                        \/\/ so that it can be used when differentiating subsequent operations\n@@ -101,1 +97,1 @@\n-        return cf;\n+        return dfcm;\n@@ -105,1 +101,1 @@\n-        \/\/ Define constants at start\n+        \/\/ Declare constants at start\n@@ -107,0 +103,1 @@\n+        \/\/ The differential of ind is 1\n@@ -110,1 +107,1 @@\n-        \/\/ Append differential block arguments to blocks\n+        \/\/ Append differential block parameters to blocks\n@@ -114,0 +111,1 @@\n+                    \/\/ Get the output block builder for the input (declaring) block\n@@ -115,0 +113,1 @@\n+                    \/\/ Add a new block parameter for differential parameter\n@@ -116,0 +115,1 @@\n+                    \/\/ Place in mapping\n@@ -129,0 +129,1 @@\n+        \/\/ Switch on the op, using pattern matching\n@@ -131,0 +132,1 @@\n+                \/\/ Copy input operation\n@@ -136,1 +138,0 @@\n-\n@@ -140,0 +141,1 @@\n+                \/\/ Copy input operation\n@@ -147,1 +149,0 @@\n-\n@@ -151,0 +152,1 @@\n+                \/\/ Copy input operation\n@@ -153,0 +155,1 @@\n+                \/\/ Product rule\n@@ -158,4 +161,5 @@\n-\n-                Op.Result x1 = block.op(mul(dlhs, block.context().getValue(rhs)));\n-                Op.Result x2 = block.op(mul(block.context().getValue(lhs), drhs));\n-                yield block.op(add(x1, x2));\n+                Value outputLhs = block.context().getValue(lhs);\n+                Value outputRhs = block.context().getValue(rhs);\n+                yield block.op(add(\n+                        block.op(mul(dlhs, outputRhs)),\n+                        block.op(mul(outputLhs, drhs))));\n@@ -164,0 +168,1 @@\n+                \/\/ Copy input operation\n@@ -165,0 +170,1 @@\n+                \/\/ Differential of constant is zero\n@@ -173,0 +179,1 @@\n+                \/\/ Differentiate sin(x)\n@@ -174,0 +181,1 @@\n+                    \/\/ Copy input operation\n@@ -176,0 +184,1 @@\n+                    \/\/ Chain rule\n@@ -179,2 +188,2 @@\n-\n-                    Op.Result cosx = block.op(invoke(J_L_MATH_COS, block.context().getValue(a)));\n+                    Value outputA = block.context().getValue(a);\n+                    Op.Result cosx = block.op(invoke(J_L_MATH_COS, outputA));\n@@ -187,1 +196,1 @@\n-                \/\/ Replace\n+                \/\/ Replace with return of differentiated value\n@@ -190,1 +199,0 @@\n-\n@@ -194,0 +202,1 @@\n+                \/\/ Update with differentiated block arguments\n@@ -207,2 +216,2 @@\n-            List<Value> args = cc.getValues(from.arguments());\n-            \/\/ Append the differential value arguments, if any\n+            List<Value> outputArgs = cc.getValues(from.arguments());\n+            \/\/ Append the differential arguments, if any\n@@ -211,1 +220,1 @@\n-                args.add(da);\n+                outputArgs.add(da);\n@@ -215,1 +224,1 @@\n-            Block.Reference to = cc.getBlock(from.targetBlock()).successor(args);\n+            Block.Reference to = cc.getBlock(from.targetBlock()).successor(outputArgs);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":54,"deletions":45,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @enablePreview\n@@ -63,1 +64,1 @@\n-        CoreOps.FuncOp dff_dx = ExpressionElimination.eliminate(ForwardDifferentiation.diff(f, x));\n+        CoreOps.FuncOp dff_dx = ExpressionElimination.eliminate(ForwardDifferentiation.partialDiff(f, x));\n@@ -69,1 +70,1 @@\n-        CoreOps.FuncOp dff_dy = ExpressionElimination.eliminate(ForwardDifferentiation.diff(f, y));\n+        CoreOps.FuncOp dff_dy = ExpressionElimination.eliminate(ForwardDifferentiation.partialDiff(f, y));\n@@ -113,1 +114,1 @@\n-        CoreOps.FuncOp df_dx = ForwardDifferentiation.diff(f, x);\n+        CoreOps.FuncOp df_dx = ForwardDifferentiation.partialDiff(f, x);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+\n+public abstract class QueryProvider {\n+    public abstract <T> Queryable<T> query(Class<T> elementType);\n+\n+    protected abstract Queryable<?> createQuery(TypeDesc elementDesc, CoreOps.FuncOp queryExpression);\n+\n+    protected abstract QueryResult<?> createQueryResult(TypeDesc resultDesc, CoreOps.FuncOp expression);\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryProvider.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+\n+public interface QueryResult<T> {\n+    TypeDesc DESC = TypeDesc.type(QueryResult.class);\n+\n+    \/\/ T\n+    TypeDesc resultDesc();\n+\n+    \/\/ Queryable<T> -> QueryResult<T>\n+    CoreOps.FuncOp expression();\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryResult.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.descriptor.MethodDesc.method;\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n+public interface Queryable<T> {\n+    TypeDesc DESC = TypeDesc.type(Queryable.class);\n+\n+    QueryProvider provider();\n+\n+    \/\/ T\n+    TypeDesc elementDesc();\n+\n+    \/\/ Queryable<T> -> Queryable<U>\n+    FuncOp expression();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default Queryable<T> where(QuotablePredicate<T> f) {\n+        LambdaOp l = (LambdaOp) f.quoted().op();\n+        return (Queryable<T>) insertQuery(elementDesc(), \"where\", l);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default <R> Queryable<R> select(QuotableFunction<T, R> f) {\n+        LambdaOp l = (LambdaOp) f.quoted().op();\n+        return (Queryable<R>) insertQuery(l.funcDescriptor().returnType(), \"select\", l);\n+    }\n+\n+    private Queryable<?> insertQuery(TypeDesc elementDesc, String methodName, LambdaOp lambdaOp) {\n+        \/\/ Copy function expression, replacing return operation\n+        FuncOp queryExpression = expression();\n+        TypeDesc queryableDesc = TypeDesc.type(Queryable.DESC, elementDesc);\n+        FuncOp nextQueryExpression = func(\"query\",\n+                methodType(queryableDesc, queryExpression.funcDescriptor().parameters()))\n+                .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                    Op.Result fi = block.op(lambdaOp);\n+\n+                    MethodDesc md = method(Queryable.DESC, methodName,\n+                            methodType(Queryable.DESC, lambdaOp.functionalInterface().rawType()));\n+                    Op.Result queryable = block.op(invoke(queryableDesc, md, query, fi));\n+\n+                    block.op(_return(queryable));\n+                }));\n+\n+        return provider().createQuery(elementDesc, nextQueryExpression);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default QueryResult<Stream<T>> elements() {\n+        TypeDesc resultDesc = type(type(Stream.class), elementDesc());\n+        return (QueryResult<Stream<T>>) insertQueryResult(resultDesc, \"elements\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default QueryResult<Long> count() {\n+        TypeDesc resultDesc = TypeDesc.LONG;\n+        return (QueryResult<Long>) insertQueryResult(resultDesc, \"count\");\n+    }\n+\n+    private QueryResult<?> insertQueryResult(TypeDesc resultDesc, String methodName) {\n+        \/\/ Copy function expression, replacing return operation\n+        FuncOp queryExpression = expression();\n+        TypeDesc queryResultDesc = TypeDesc.type(QueryResult.DESC, resultDesc);\n+        FuncOp queryResultExpression = func(\"queryResult\",\n+                methodType(queryResultDesc, queryExpression.funcDescriptor().parameters()))\n+                .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                    MethodDesc md = method(Queryable.DESC, methodName,\n+                            methodType(QueryResult.DESC));\n+                    Op.Result queryResult = block.op(invoke(queryResultDesc, md, query));\n+\n+                    block.op(_return(queryResult));\n+                }));\n+\n+        return provider().createQueryResult(resultDesc, queryResultExpression);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.util.function.Function;\n+\n+@FunctionalInterface\n+public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotableFunction.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.util.function.Predicate;\n+\n+@FunctionalInterface\n+public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotablePredicate.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLinq\n+ *\/\n+\n+public class TestLinq {\n+\n+    \/\/ A record modeling a table with three columns, one for each component\n+    record Customer(String contactName, String phone, String city) {\n+    }\n+\n+    @Test\n+    public void testSimpleQuery() {\n+        QueryProvider qp = new TestQueryProvider();\n+\n+        \/\/ Query all customers based in London, and return their names\n+        QueryResult<Stream<String>> qr = qp.query(Customer.class)\n+                .where(c -> c.city.equals(\"London\"))\n+                .select(c -> c.contactName)\n+                .elements();\n+\n+        System.out.println(qr.expression().toText());\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QueryResult<Stream<String>> qr2 = (QueryResult<Stream<String>>) Interpreter.invoke(MethodHandles.lookup(),\n+                qr.expression(), qp.query(Customer.class));\n+        System.out.println(qr2.expression().toText());\n+\n+        Assert.assertEquals(qr.expression().toText(), qr2.expression().toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestLinq.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.descriptor.TypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+\n+import static java.lang.reflect.code.descriptor.MethodTypeDesc.methodType;\n+import static java.lang.reflect.code.descriptor.TypeDesc.type;\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+\n+public final class TestQueryProvider extends QueryProvider {\n+    public TestQueryProvider() {\n+    }\n+\n+    @Override\n+    public <T> Queryable<T> query(Class<T> elementType) {\n+        return new TestQueryable<>(elementType, this);\n+    }\n+\n+    @Override\n+    protected Queryable<?> createQuery(TypeDesc elementDesc, CoreOps.FuncOp expression) {\n+        return new TestQueryable<>(elementDesc, this, expression);\n+    }\n+\n+    @Override\n+    protected QueryResult<?> createQueryResult(TypeDesc resultDesc, CoreOps.FuncOp expression) {\n+        return new TestQueryResult<>(resultDesc, expression);\n+    }\n+\n+    static final class TestQueryable<T> implements Queryable<T> {\n+        final TypeDesc elementDesc;\n+        final TestQueryProvider provider;\n+        final CoreOps.FuncOp expression;\n+\n+        TestQueryable(Class<T> tableClass, TestQueryProvider qp) {\n+            this.elementDesc = type(tableClass);\n+            this.provider = qp;\n+\n+            TypeDesc queryableType = TypeDesc.type(Queryable.DESC, elementDesc);\n+            \/\/ Initial expression is an identity function\n+            var funDescriptor = methodType(queryableType, queryableType);\n+            this.expression = func(\"query\", funDescriptor)\n+                    .body(b -> b.op(_return(b.parameters().get(0))));\n+        }\n+\n+        TestQueryable(TypeDesc elementDesc, TestQueryProvider provider, CoreOps.FuncOp expression) {\n+            this.elementDesc = elementDesc;\n+            this.provider = provider;\n+            this.expression = expression;\n+        }\n+\n+        @Override\n+        public QueryProvider provider() {\n+            return provider;\n+        }\n+\n+        @Override\n+        public TypeDesc elementDesc() {\n+            return elementDesc;\n+        }\n+\n+        @Override\n+        public CoreOps.FuncOp expression() {\n+            return expression;\n+        }\n+    }\n+\n+    record TestQueryResult<T>(TypeDesc resultDesc, CoreOps.FuncOp expression) implements QueryResult<T> {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}