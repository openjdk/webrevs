{"files":[{"patch":"@@ -60,1 +60,1 @@\n-        │    └── (opencl|cuda|ptx|mock|shared)\n+        │    └── (opencl|cuda|ptx|hip|mock|shared)\n","filename":"hat\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+if (\"${HIP_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n+    set (HIP_BACKEND \"${CMAKE_SOURCE_DIR}\/hip\")\n+    message(\"HIP_BACKEND=${HIP_BACKEND}\")\n+endif()\n+add_subdirectory(hip)\n+\n","filename":"hat\/backends\/CMakeLists.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+cmake_minimum_required(VERSION 3.22.1)\n+project(cuda_backend)\n+\n+set(CMAKE_CXX_STANDARD 14)\n+\n+find_package(hip)\n+if(hip_FOUND)\n+\tmessage(\"HIP\")\n+\n+\tif (\"${HIP_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n+\t\tset (HIP_BACKEND \"${CMAKE_SOURCE_DIR}\")\n+\t\tmessage(\"HIP_BACKEND=${HIP_BACKEND}\")\n+    endif()\n+\n+    if (\"${SHARED_BACKEND}EMPTY\" STREQUAL \"EMPTY\")\n+        set (SHARED_BACKEND \"${CMAKE_SOURCE_DIR}\/..\/shared\")\n+        message(\"SHARED_BACKEND=${SHARED_BACKEND}\")\n+    endif()\n+\n+    include_directories(\n+            ${HIP_INCLUDE_DIR}\n+            ${SHARED_BACKEND}\/include\n+            ${HIP_BACKEND}\/include\n+    )\n+\n+    link_directories(\n+            ${CMAKE_BINARY_DIR}\n+            ${HIP_LIBRARY_DIR}\n+    )\n+\n+    add_library(hip_backend SHARED\n+\t    ${SHARED_BACKEND}\/cpp\/shared.cpp\n+\t    ${HIP_BACKEND}\/cpp\/hip_backend.cpp\n+    )\n+\n+    target_link_libraries(hip_backend\n+\t    PRIVATE hip::host\n+    )\n+\n+    add_executable(hip_info\n+\t    ${HIP_BACKEND}\/cpp\/info.cpp\n+    )\n+\n+    target_link_libraries(hip_info\n+            hip_backend\n+            hip::host\n+    )\n+endif()\n","filename":"hat\/backends\/hip\/CMakeLists.txt","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+#include <sys\/wait.h>\n+#include <chrono>\n+#include <hip\/hip_runtime.h>\n+#include <hip\/hiprtc.h>\n+#include \"hip_backend.h\"\n+\n+#define CHECK_RET_CODE(call, ret_code)                                                             \\\n+  {                                                                                                \\\n+    if ((call) != ret_code) {                                                                      \\\n+      std::cout << \"Failed in call: \" << #call << std::endl;                                       \\\n+      std::abort();                                                                                \\\n+    }                                                                                              \\\n+  }\n+#define HIP_CHECK(call) CHECK_RET_CODE(call, hipSuccess)\n+#define HIPRTC_CHECK(call) CHECK_RET_CODE(call, HIPRTC_SUCCESS)\n+\n+uint64_t timeSinceEpochMillisec() {\n+    using namespace std::chrono;\n+    return duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();\n+}\n+\n+HIPBackend::HIPProgram::HIPKernel::HIPBuffer::HIPBuffer(Backend::Program::Kernel *kernel, Arg_s *arg)\n+        : Buffer(kernel, arg), devicePtr() {\n+    \/*\n+     *   (void *) arg->value.buffer.memorySegment,\n+     *   (size_t) arg->value.buffer.sizeInBytes);\n+     *\/\n+#ifdef VERBOSE\n+    std::cout << \"hipMalloc()\" << std::endl;\n+#endif\n+    HIP_CHECK(hipMalloc(&devicePtr, (size_t) arg->value.buffer.sizeInBytes));\n+#ifdef VERBOSE\n+    std::cout << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec <<std::endl;\n+#endif\n+    arg->value.buffer.vendorPtr = static_cast<void *>(this);\n+}\n+\n+HIPBackend::HIPProgram::HIPKernel::HIPBuffer::~HIPBuffer() {\n+\n+#ifdef VERBOSE\n+    std::cout << \"hipFree()\"\n+              << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n+              << std::endl;\n+#endif\n+    HIP_CHECK(hipFree(devicePtr));\n+    arg->value.buffer.vendorPtr = nullptr;\n+}\n+\n+void HIPBackend::HIPProgram::HIPKernel::HIPBuffer::copyToDevice() {\n+    auto hipKernel = dynamic_cast<HIPKernel*>(kernel);\n+#ifdef VERBOSE\n+    std::cout << \"copyToDevice() 0x\"   << std::hex<<arg->value.buffer.sizeInBytes<<std::dec << \" \"<< arg->value.buffer.sizeInBytes << \" \"\n+              << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n+              << std::endl;\n+#endif\n+    char *ptr = (char*)arg->value.buffer.memorySegment;\n+\n+    unsigned long ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n+    unsigned long ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n+\n+    if (ifacefacade1 != 0x1face00000facadeL && ifacefacade1 != ifacefacade2) {\n+        std::cerr<<\"End of buf marker before HtoD\"<< std::hex << ifacefacade1 << ifacefacade2<< \" buffer corrupt !\" <<std::endl\n+                <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n+        exit(-1);\n+    }\n+\n+    HIP_CHECK(hipMemcpyHtoDAsync(devicePtr, arg->value.buffer.memorySegment, arg->value.buffer.sizeInBytes, hipKernel->hipStream));\n+}\n+\n+void HIPBackend::HIPProgram::HIPKernel::HIPBuffer::copyFromDevice() {\n+    auto hipKernel = dynamic_cast<HIPKernel*>(kernel);\n+#ifdef VERBOSE\n+    std::cout << \"copyFromDevice() 0x\" << std::hex<<arg->value.buffer.sizeInBytes<<std::dec << \" \"<< arg->value.buffer.sizeInBytes << \" \"\n+              << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n+              << std::endl;\n+#endif\n+    char *ptr = (char*)arg->value.buffer.memorySegment;\n+\n+    unsigned long ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n+    unsigned long ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n+\n+    if (ifacefacade1 != 0x1face00000facadeL || ifacefacade1 != ifacefacade2) {\n+        std::cerr<<\"end of buf marker before  DtoH\"<< std::hex << ifacefacade1 << ifacefacade2<< std::dec<< \" buffer corrupt !\"<<std::endl\n+                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n+        exit(-1);\n+    }\n+    HIP_CHECK(hipMemcpyDtoHAsync(arg->value.buffer.memorySegment, devicePtr, arg->value.buffer.sizeInBytes, hipKernel->hipStream));\n+\n+    ifacefacade1 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-16);\n+    ifacefacade2 = *reinterpret_cast<unsigned long*>(ptr+arg->value.buffer.sizeInBytes-8);\n+\n+    if (ifacefacade1 != 0x1face00000facadeL || ifacefacade1 != ifacefacade2) {\n+        std::cerr<<\"end of buf marker after  DtoH\"<< std::hex << ifacefacade1 << ifacefacade2<< std::dec<< \" buffer corrupt !\"<<std::endl\n+                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n+        exit(-1);\n+    }\n+}\n+\n+HIPBackend::HIPProgram::HIPKernel::HIPKernel(Backend::Program *program, char * name, hipFunction_t kernel)\n+        : Backend::Program::Kernel(program, name), kernel(kernel),hipStream() {\n+}\n+\n+HIPBackend::HIPProgram::HIPKernel::~HIPKernel() = default;\n+\n+long HIPBackend::HIPProgram::HIPKernel::ndrange(void *argArray) {\n+#ifdef VERBOSE\n+    std::cout << \"ndrange(\" << range << \") \" << name << std::endl;\n+#endif\n+\n+    hipStreamCreate(&hipStream);\n+    ArgSled argSled(static_cast<ArgArray_s *>(argArray));\n+    void *argslist[argSled.argc()];\n+    NDRange *ndrange = nullptr;\n+#ifdef VERBOSE\n+    std::cerr << \"there are \" << argSled.argc() << \"args \" << std::endl;\n+#endif\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_s *arg = argSled.arg(i);\n+        switch (arg->variant) {\n+            case '&': {\n+                if (arg->idx == 0){\n+                    ndrange = static_cast<NDRange *>(arg->value.buffer.memorySegment);\n+                }\n+                auto hipBuffer = new HIPBuffer(this, arg);\n+                hipBuffer->copyToDevice();\n+                argslist[arg->idx] = static_cast<void *>(&hipBuffer->devicePtr);\n+                break;\n+            }\n+            case 'I':\n+            case 'F':\n+            case 'J':\n+            case 'D':\n+            case 'C':\n+            case 'S': {\n+                argslist[arg->idx] = static_cast<void *>(&arg->value);\n+                break;\n+            }\n+            default: {\n+                std::cerr << \" unhandled variant \" << (char) arg->variant << std::endl;\n+                break;\n+            }\n+        }\n+    }\n+\n+    int range = ndrange->maxX;\n+    int rangediv1024 = range \/ 1024;\n+    int rangemod1024 = range % 1024;\n+    if (rangemod1024 > 0) {\n+        rangediv1024++;\n+    }\n+\n+#ifdef VERBOSE\n+    std::cout << \"Running the kernel...\" << std::endl;\n+    std::cout << \"   Requested range   = \" << range << std::endl;\n+    std::cout << \"   Range mod 1024    = \" << rangemod1024 << std::endl;\n+    std::cout << \"   Actual range 1024 = \" << (rangediv1024 * 1024) << std::endl;\n+#endif\n+\n+    HIP_CHECK(hipModuleLaunchKernel(kernel, rangediv1024, 1, 1, 1024, 1, 1, 0, hipStream, argslist, 0));\n+\n+#ifdef VERBOSE\n+    std::cout << \"Kernel complete...\"<<hipGetErrorString(t)<<std::endl;\n+#endif\n+\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_s *arg = argSled.arg(i);\n+        if (arg->variant == '&') {\n+            static_cast<HIPBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n+\n+        }\n+    }\n+\n+    for (int i = 0; i < argSled.argc(); i++) {\n+        Arg_s *arg = argSled.arg(i);\n+        if (arg->variant == '&') {\n+            delete static_cast<HIPBuffer *>(arg->value.buffer.vendorPtr);\n+            arg->value.buffer.vendorPtr = nullptr;\n+        }\n+    }\n+    HIP_CHECK(hipStreamSynchronize(hipStream));\n+    HIP_CHECK(hipStreamDestroy(hipStream));\n+\n+    return (long) 0;\n+}\n+\n+\n+HIPBackend::HIPProgram::HIPProgram(Backend *backend, BuildInfo *buildInfo, hipModule_t module)\n+        : Backend::Program(backend, buildInfo), module(module) {\n+}\n+\n+HIPBackend::HIPProgram::~HIPProgram() = default;\n+\n+long HIPBackend::HIPProgram::getKernel(int nameLen, char *name) {\n+\n+    hipFunction_t kernel;\n+    HIP_CHECK(hipModuleGetFunction(&kernel, module, name));\n+    long kernelHandle =  reinterpret_cast<long>(new HIPKernel(this, name, kernel));\n+\n+    return kernelHandle;\n+}\n+\n+bool HIPBackend::HIPProgram::programOK() {\n+    return true;\n+}\n+\n+HIPBackend::HIPBackend(HIPBackend::HIPConfig *hipConfig, int\n+configSchemaLen, char *configSchema)\n+        : Backend((Backend::Config*) hipConfig, configSchemaLen, configSchema), device(),context()  {\n+#ifdef VERBOSE\n+    std::cout << \"HIPBackend constructor \" << ((hipConfig == nullptr) ? \"hipConfig== null\" : \"got hipConfig\")\n+              << std::endl;\n+#endif\n+    int deviceCount = 0;\n+    hipError_t err = hipInit(0);\n+    if (err == HIP_SUCCESS) {\n+        hipGetDeviceCount(&deviceCount);\n+        std::cout << \"HIPBackend device count\" << std::endl;\n+        hipDeviceGet(&device, 0);\n+        std::cout << \"HIPBackend device ok\" << std::endl;\n+        hipCtxCreate(&context, 0, device);\n+        std::cout << \"HIPBackend context created ok\" << std::endl;\n+    } else {\n+        std::cout << \"HIPBackend failed, we seem to have the runtime library but no device, no context, nada \"\n+                  << std::endl;\n+        exit(1);\n+    }\n+}\n+\n+HIPBackend::HIPBackend() : HIPBackend(nullptr, 0, nullptr) {\n+\n+}\n+\n+HIPBackend::~HIPBackend() {\n+#ifdef VERBOSE\n+    std::cout << \"freeing context\" << std::endl;\n+#endif\n+    auto status = hipCtxDestroy(context);\n+    if (HIP_SUCCESS != status) {\n+        std::cerr << \"hipCtxDestroy(() HIP error = \" << status\n+                  <<\" \" << hipGetErrorString(static_cast<hipError_t>(status))\n+                  <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n+        exit(-1);\n+    }\n+}\n+\n+int HIPBackend::getMaxComputeUnits() {\n+    std::cout << \"getMaxComputeUnits()\" << std::endl;\n+    int value = 1;\n+    return value;\n+}\n+\n+void HIPBackend::info() {\n+    char name[100];\n+    hipDeviceGetName(name, sizeof(name), device);\n+    std::cout << \"> Using device 0: \" << name << std::endl;\n+\n+    \/\/ get compute capabilities and the devicename\n+    int major = 0, minor = 0;\n+    hipDeviceGetAttribute(&major, hipDeviceAttributeComputeCapabilityMajor, device);\n+    hipDeviceGetAttribute(&minor, hipDeviceAttributeComputeCapabilityMinor, device);\n+    std::cout << \"> HIP Device has major=\" << major << \" minor=\" << minor << \" compute capability\" << std::endl;\n+\n+    int warpSize;\n+    hipDeviceGetAttribute(&warpSize, hipDeviceAttributeWarpSize, device);\n+    std::cout << \"> HIP Device has wave front size \" << warpSize << std::endl;\n+\n+    int threadsPerBlock;\n+    hipDeviceGetAttribute(&threadsPerBlock, hipDeviceAttributeMaxThreadsPerBlock, device);\n+    std::cout << \"> HIP Device has threadsPerBlock \" << threadsPerBlock << std::endl;\n+\n+    int cores;\n+    hipDeviceGetAttribute(&cores, hipDeviceAttributeMultiprocessorCount, device);\n+    std::cout << \"> HIP Cores \" << cores << std::endl;\n+\n+    size_t totalGlobalMem;\n+    hipDeviceTotalMem(&totalGlobalMem, device);\n+    std::cout << \"  Total amount of global memory:   \" << (unsigned long long) totalGlobalMem << std::endl;\n+    std::cout << \"  64-bit Memory Address:           \" <<\n+              ((totalGlobalMem > (unsigned long long) 4 * 1024 * 1024 * 1024L) ? \"YES\" : \"NO\") << std::endl;\n+\n+}\n+\n+long HIPBackend::compileProgram(int len, char *source) {\n+\n+#ifdef VERBOSE\n+    std::cout << \"inside compileProgram\" << std::endl;\n+    std::cout << \"hip \" << source << std::endl;\n+#endif\n+    hiprtcProgram prog;\n+    auto status = hiprtcCreateProgram(&prog,\n+                    source,\n+                    \"hip_kernel.hip\",\n+                    0,\n+                    nullptr,\n+                    nullptr);\n+    if (status != HIPRTC_SUCCESS){\n+        size_t logSize;\n+        hiprtcGetProgramLogSize(prog, &logSize);\n+\n+        std::cerr << \"hiprtcCreateProgram(() HIP error = \" << std::endl;\n+        if (logSize) {\n+            std::string log(logSize, '\\0');\n+            hiprtcGetProgramLog(prog, &log[0]);\n+            std::cerr <<\" \" << log\n+                      <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n+        }\n+        exit(-1);\n+    }\n+\n+    status = hiprtcCompileProgram(prog, 0, nullptr);\n+    if (status != HIPRTC_SUCCESS){\n+        size_t logSize;\n+        hiprtcGetProgramLogSize(prog, &logSize);\n+\n+        std::cerr << \"hiprtcCompileProgram(() HIP error = \" << std::endl;\n+        if (logSize) {\n+            std::string log(logSize, '\\0');\n+            hiprtcGetProgramLog(prog, &log[0]);\n+            std::cerr <<\" \" << log\n+                      <<\" \" << __FILE__ << \" line \" << __LINE__ << std::endl;\n+        }\n+        exit(-1);\n+    }\n+\n+    size_t codeSize;\n+    hiprtcGetCodeSize(prog, &codeSize);\n+#ifdef VERBOSE\n+    std::cerr << \"HIP compiled code size \" << codeSize << std::endl;\n+#endif\n+\n+    std::vector<char> kernel_binary(codeSize);\n+    hiprtcGetCode(prog, kernel_binary.data());\n+\n+    hipModule_t module;\n+    hipModuleLoadData(&module, kernel_binary.data());\n+    hiprtcDestroyProgram(&prog);\n+\n+    return reinterpret_cast<long>(new HIPProgram(this, nullptr, module));\n+}\n+\n+long getBackend(void *config, int configSchemaLen, char *configSchema) {\n+    long backendHandle = reinterpret_cast<long>(\n+            new HIPBackend(static_cast<HIPBackend::HIPConfig *>(config), configSchemaLen,\n+                            configSchema));\n+#ifdef VERBOSE\n+    std::cout << \"getBackend() -> backendHandle=\" << std::hex << backendHandle << std::dec << std::endl;\n+#endif\n+    return backendHandle;\n+}\n+\n+\n+\n","filename":"hat\/backends\/hip\/cpp\/hip_backend.cpp","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+#include \"hip_backend.h\"\n+\n+int main(int argc, char **argv) {\n+    HIPBackend hipBackend;\n+    hipBackend.info();\n+}\n+\n","filename":"hat\/backends\/hip\/cpp\/info.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+#pragma once\n+#define HIP_TYPES\n+#ifdef __APPLE__\n+\n+#define LongUnsignedNewline \"%llu\\n\"\n+#define Size_tNewline \"%lu\\n\"\n+#define LongHexNewline \"(0x%llx)\\n\"\n+#define alignedMalloc(size, alignment) memalign(alignment, size)\n+#define SNPRINTF snprintf\n+#else\n+\n+#include <malloc.h>\n+\n+#define LongHexNewline \"(0x%lx)\\n\"\n+#define LongUnsignedNewline \"%lu\\n\"\n+#define Size_tNewline \"%lu\\n\"\n+#if defined (_WIN32)\n+#include \"windows.h\"\n+#define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n+#define SNPRINTF _snprintf\n+#else\n+#define alignedMalloc(size, alignment) memalign(alignment, size)\n+#define SNPRINTF  snprintf\n+#endif\n+#endif\n+\n+#include <iostream>\n+#include <hip\/hip_runtime.h>\n+\n+#define HIP_TYPES\n+\n+#include \"shared.h\"\n+\n+#include <fstream>\n+\n+#include<vector>\n+\n+class HIPBackend : public Backend {\n+public:\n+    class HIPConfig : public Backend::Config {\n+    public:\n+        boolean gpu;\n+    };\n+\n+    class HIPProgram : public Backend::Program {\n+        class HIPKernel : public Backend::Program::Kernel {\n+            class HIPBuffer : public Backend::Program::Kernel::Buffer {\n+            public:\n+                hipDeviceptr_t devicePtr;\n+\n+                HIPBuffer(Backend::Program::Kernel *kernel, Arg_s *arg);\n+\n+                void copyToDevice();\n+\n+                void copyFromDevice();\n+\n+                virtual ~HIPBuffer();\n+            };\n+\n+        private:\n+            hipFunction_t kernel;\n+            hipStream_t hipStream;\n+        public:\n+            HIPKernel(Backend::Program *program, char* name, hipFunction_t kernel);\n+\n+            ~HIPKernel() override;\n+\n+            long ndrange( void *argArray);\n+        };\n+\n+    private:\n+        hipModule_t module;\n+\n+    public:\n+        HIPProgram(Backend *backend, BuildInfo *buildInfo, hipModule_t module);\n+\n+        ~HIPProgram();\n+\n+        long getKernel(int nameLen, char *name);\n+\n+        bool programOK();\n+    };\n+\n+private:\n+    hipDevice_t device;\n+    hipCtx_t context;\n+public:\n+\n+    HIPBackend(HIPConfig *config, int configSchemaLen, char *configSchema);\n+\n+    HIPBackend();\n+\n+    ~HIPBackend();\n+\n+    int getMaxComputeUnits();\n+\n+    void info();\n+\n+    long compileProgram(int len, char *source);\n+\n+};\n+\n","filename":"hat\/backends\/hip\/include\/hip_backend.h","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>hat-backend-hip<\/artifactId>\n+    <version>1.0<\/version>\n+    <packaging>jar<\/packaging>\n+    <!-- this required to inherit parent properties -->\n+    <parent>\n+        <groupId>oracle.code<\/groupId>\n+        <version>1.0<\/version>\n+        <artifactId>hat.backends<\/artifactId>\n+    <\/parent>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>oracle.code<\/groupId>\n+            <version>1.0<\/version>\n+            <artifactId>hat<\/artifactId>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <plugins>\n+             <plugin>\n+               <groupId>org.codehaus.mojo<\/groupId>\n+               <artifactId>exec-maven-plugin<\/artifactId>\n+               <configuration>\n+                  <skip>true<\/skip>\n+                  <!-- we want to inherit properties from parent but not the\n+                       plugin that calls cmake -->\n+               <\/configuration>\n+            <\/plugin>\n+\n+\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-antrun-plugin<\/artifactId>\n+                <version>1.8<\/version>\n+                <executions>\n+                    <execution>\n+                        <phase>install<\/phase>\n+                        <configuration>\n+                            <target>\n+                                <copy file=\"target\/hat-backend-hip-1.0.jar\" todir=\"${hat.target}\"\/>\n+                            <\/target>\n+                        <\/configuration>\n+                        <goals>\n+                            <goal>run<\/goal>\n+                        <\/goals>\n+                    <\/execution>\n+                <\/executions>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+\n+<\/project>\n","filename":"hat\/backends\/hip\/pom.xml","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+package hat.backend;\n+\n+\n+import hat.ComputeContext;\n+import hat.NDRange;\n+import hat.callgraph.KernelCallGraph;\n+\n+public class HIPBackend extends C99NativeBackend {\n+    public HIPBackend() {\n+        super(\"hip_backend\");\n+        getBackend(null);\n+        info();\n+    }\n+\n+    @Override\n+    public void computeContextHandoff(ComputeContext computeContext) {\n+        injectBufferTracking(computeContext.computeCallGraph.entrypoint);\n+\n+    }\n+\n+    @Override\n+    public void dispatchKernel(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args) {\n+        CompiledKernel compiledKernel = kernelCallGraphCompiledCodeMap.computeIfAbsent(kernelCallGraph, (_) -> {\n+            String code = createCode(kernelCallGraph, new HIPHatKernelBuilder(), args);\n+            long programHandle = compileProgram(code);\n+            if (programOK(programHandle)) {\n+                long kernelHandle = getKernel(programHandle, kernelCallGraph.entrypoint.method.getName());\n+                return new CompiledKernel(this, kernelCallGraph, code, kernelHandle, args);\n+            } else {\n+                throw new IllegalStateException(\"HIP failed to compile \");\n+            }\n+        });\n+        compiledKernel.dispatch(ndRange,args);\n+    }\n+}\n","filename":"hat\/backends\/hip\/src\/main\/java\/hat\/backend\/HIPBackend.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+package hat.backend;\n+\n+public class HIPDeviceInfo {\n+    public static void main(String[] args) {\n+        HIPBackend hipBackend = new HIPBackend();\n+        hipBackend.info();\n+    }\n+}\n","filename":"hat\/backends\/hip\/src\/main\/java\/hat\/backend\/HIPDeviceInfo.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+package hat.backend;\n+\n+import hat.backend.c99codebuilders.C99HatBuildContext;\n+import hat.backend.c99codebuilders.C99HatKernelBuilder;\n+import hat.optools.OpWrapper;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public class HIPHatKernelBuilder extends C99HatKernelBuilder<HIPHatKernelBuilder> {\n+\n+    @Override\n+    public HIPHatKernelBuilder defines() {\n+        return this\n+                .hashDefine(\"NDRANGE_HIP\")\n+                .hashDefine(\"__global\")\n+                .hashDefine(\"NULL\", \"nullptr\");\n+    }\n+\n+    @Override\n+    public HIPHatKernelBuilder pragmas() {\n+        return self();\n+    }\n+\n+    public HIPHatKernelBuilder globalId() {\n+        return identifier(\"blockIdx\").dot().identifier(\"x\")\n+                .asterisk()\n+                .identifier(\"blockDim\").dot().identifier(\"x\")\n+                .plus()\n+                .identifier(\"threadIdx\").dot().identifier(\"x\");\n+    }\n+\n+    @Override\n+    public HIPHatKernelBuilder globalSize() {\n+        return identifier(\"gridDim\").dot().identifier(\"x\")\n+                .asterisk()\n+                .identifier(\"blockDim\").dot().identifier(\"x\");\n+    }\n+\n+\n+    @Override\n+    public HIPHatKernelBuilder kernelDeclaration(String name) {\n+        return externC().space().keyword(\"__global__\").space().voidType().space().identifier(name);\n+    }\n+\n+    @Override\n+    public HIPHatKernelBuilder functionDeclaration(JavaType javaType, String name) {\n+        return externC().space().keyword(\"__device__\").space().keyword(\"inline\").space().type(javaType).space().identifier(name);\n+    }\n+\n+    @Override\n+    public HIPHatKernelBuilder globalPtrPrefix() {\n+        return self();\n+    }\n+\n+\n+    @Override\n+    public HIPHatKernelBuilder atomicInc(C99HatBuildContext buildContext, Op.Result instanceResult, String name){\n+        return identifier(\"atomicAdd\").paren(_ -> {\n+             ampersand().recurse(buildContext, OpWrapper.wrap(instanceResult.op()));\n+             rarrow().identifier(name).comma().literal(1);\n+        });\n+    }\n+}\n","filename":"hat\/backends\/hip\/src\/main\/java\/hat\/backend\/HIPHatKernelBuilder.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+hat.backend.HIPBackend\n+hat.backend.JavaSequentialBackend\n+hat.backend.JavaMultiThreadedBackend\n","filename":"hat\/backends\/hip\/src\/main\/resources\/META-INF\/services\/hat.backend.Backend","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -45,0 +46,1 @@\n+        <module>hip<\/module>\n","filename":"hat\/backends\/pom.xml","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-   echo '       backend  : opencl|cuda|spirv|ptx|mock'\n+   echo '       backend  : opencl|cuda|hip|spirv|ptx|mock'\n","filename":"hat\/hatrun.bash","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}