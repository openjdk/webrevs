{"files":[{"patch":"@@ -411,16 +411,5 @@\n-        if (CallGraph.noModuleOp) {\n-            System.out.println(\"NOT using ModuleOp for CudaBackend\");\n-            for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n-                CoreOp.FuncOp calledFunc = k.funcOp();\n-                CoreOp.FuncOp loweredFunc = OpTk.lower(calledFunc);\n-                loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n-                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n-            }\n-        } else {\n-            System.out.println(\"Using ModuleOp for CudaBackend\");\n-            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n-                CoreOp.FuncOp loweredFunc = OpTk.lower(funcOp);\n-                loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n-                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n-            });\n-        }\n+        kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n+            CoreOp.FuncOp loweredFunc = OpTk.lower(funcOp);\n+            loweredFunc = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,loweredFunc, argsMap, usedMathFns);\n+            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+        });\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,10 +60,2 @@\n-        if (CallGraph.noModuleOp) {\n-            System.out.println(\"NOT using ModuleOp for MockBackend\");\n-            kernelCallGraph.kernelReachableResolvedStream().forEach(kr -> {\n-\n-            });\n-        } else {\n-            System.out.println(\"Using ModuleOp for MockBackend\");\n-            kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n-            });\n-        }\n+        kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n+        });\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -234,14 +234,2 @@\n-        if (CallGraph.noModuleOp) {\n-            IO.println(\"NOT using ModuleOp for C99FFIBackend\");\n-            kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-                    .forEach(kernelReachableResolvedMethod -> {\n-                                HatFinalDetectionPhase finals = new HatFinalDetectionPhase();\n-                                finals.apply(kernelReachableResolvedMethod.funcOp());\n-                                \/\/ Update the build context for this method to use the right constants-map\n-                                buildContext.setFinals(finals.getFinalVars());\n-                                builder.nl().kernelMethod(buildContext, kernelReachableResolvedMethod.funcOp()).nl();\n-                    });\n-        } else {\n-            IO.println(\"Using ModuleOp for C99FFIBackend\");\n-            kernelCallGraph.moduleOp.functionTable()\n-                    .forEach((_, funcOp) -> {\n+        kernelCallGraph.moduleOp.functionTable()\n+                .forEach((_, funcOp) -> {\n@@ -249,2 +237,2 @@\n-                        HatFinalDetectionPhase finals = new HatFinalDetectionPhase();\n-                        finals.apply(funcOp);\n+                    HatFinalDetectionPhase finals = new HatFinalDetectionPhase();\n+                    finals.apply(funcOp);\n@@ -252,5 +240,4 @@\n-                        \/\/ Update the build context for this method to use the right constants-map\n-                        buildContext.setFinals(finals.getFinalVars());\n-                        builder.nl().kernelMethod(buildContext, funcOp).nl();\n-                    });\n-        }\n+                    \/\/ Update the build context for this method to use the right constants-map\n+                    buildContext.setFinals(finals.getFinalVars());\n+                    builder.nl().kernelMethod(buildContext, funcOp).nl();\n+                });\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -60,0 +60,11 @@\n+    public static String convertAccessType(int i) {\n+        switch (i) {\n+            case 0 -> {return \"NOT_BUFFER\";}\n+            case 1 -> {return \"NA\";}\n+            case 2 -> {return \"RO\";}\n+            case 4 -> {return \"WO\";}\n+            case 6 -> {return \"RW\";}\n+            default -> {return \"\";}\n+        }\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import hat.callgraph.CallGraph;\n@@ -333,1 +332,5 @@\n-                    if (CallGraph.bufferTagging) assert bufferAccessList.get(i).value == accessByte;\n+                    assert bufferAccessList.get(i).value == accessByte: \"buffer tagging mismatch: \"\n+                            + kernelCallGraph.entrypoint.getMethod().getParameters()[i].toString()\n+                            + \" in \" + kernelCallGraph.entrypoint.getMethod().getName()\n+                            + \" annotated as \" + BufferTagger.convertAccessType(accessByte)\n+                            + \" but tagged as \" + bufferAccessList.get(i).name();\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,4 +46,0 @@\n-\n-    \/\/ Todo: We should phase these out. We can also use Config.....\n-    public final static boolean noModuleOp = Boolean.getBoolean(\"noModuleOp\");\n-    public final static boolean bufferTagging = Boolean.getBoolean(\"bufferTagging\");\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,5 +217,1 @@\n-        if (CallGraph.noModuleOp) {\n-            updateDag(entrypoint);\n-        } else {\n-            closeWithModuleOp(entrypoint);\n-        }\n+        closeWithModuleOp(entrypoint);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,3 +85,1 @@\n-        System.out.println(\"-DbufferTagging=\"+CallGraph.bufferTagging);\n-        System.out.println(\"-DnoModuleOp=\"+CallGraph.noModuleOp);\n-        bufferAccessList = CallGraph.bufferTagging?BufferTagger.getAccessList(computeContext.accelerator.lookup, entrypoint.funcOp()):List.of();\n+        bufferAccessList = BufferTagger.getAccessList(computeContext.accelerator.lookup, entrypoint.funcOp());\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,3 +191,1 @@\n-                        var vmOpts = new ArrayList<String>(List.of(\n-                            \"-DbufferTagging=true\"\n-                        ));\n+                        var vmOpts = new ArrayList<String>(List.of());\n@@ -260,3 +258,1 @@\n-                        var vmOpts = new ArrayList<String>(List.of(\n-                            \"-DbufferTagging=true\"\n-                        ));\n+                        var vmOpts = new ArrayList<String>(List.of());\n","filename":"hat\/hat.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1287,2 +1287,0 @@\n-        public boolean noModuleOp;\n-        public boolean bufferTagging;\n@@ -1347,8 +1345,0 @@\n-\n-        public void noModuleOp() {\n-            this.noModuleOp = true;\n-        }\n-\n-        public void bufferTagging() {\n-            this.bufferTagging = true;\n-        }\n@@ -1386,6 +1376,0 @@\n-        if (javaBuilder.noModuleOp) {\n-            result.opts.add(\"-DnoModuleOp=true\");\n-        }\n-        if (javaBuilder.bufferTagging) {\n-            result.opts.add(\"-DbufferTagging=true\");\n-        }\n","filename":"hat\/hat\/Script.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-     boolean noModuleOp = false;\n-     boolean bufferTagging = false;\n@@ -76,2 +74,0 @@\n-                   case \"noModuleOp\" -> noModuleOp = true;\n-                   case \"bufferTagging\" -> bufferTagging = true;\n@@ -177,1 +173,0 @@\n-          if (config.noModuleOp) System.out.println(\"NOT using ModuleOp for CallGraphs\");\n@@ -185,2 +180,0 @@\n-              .when(config.noModuleOp, Script.JavaBuilder::noModuleOp)\n-              .when(config.bufferTagging, Script.JavaBuilder::bufferTagging)\n","filename":"hat\/hat\/run.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-    boolean noModuleOp = false;\n@@ -81,1 +80,0 @@\n-                    case \"noModuleOp\" -> noModuleOp = true;\n@@ -151,3 +149,0 @@\n-        if (config.noModuleOp) {\n-            System.out.println(\"NOT using ModuleOp for CallGraphs\");\n-        }\n@@ -188,1 +183,0 @@\n-                    .when(config.noModuleOp, Script.JavaBuilder::noModuleOp)\n@@ -231,1 +225,0 @@\n-                .when(config.noModuleOp, Script.JavaBuilder::noModuleOp)\n","filename":"hat\/hat\/test.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}