{"files":[{"patch":"@@ -96,0 +96,1 @@\n+                import jdk.incubator.code.extern.ExternalizedOp;\n","filename":"cr-examples\/onnx\/opgen\/src\/main\/java\/oracle\/code\/onnx\/opgen\/OpGen.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -656,1 +656,1 @@\n-        public If(ExternalizableOp.ExternalizedOp def) {\n+        public If(ExternalizedOp def) {\n@@ -799,1 +799,1 @@\n-        public Loop(ExternalizableOp.ExternalizedOp def) {\n+        public Loop(ExternalizedOp def) {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/ExplicitOnnxOps.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.Op;\n@@ -31,1 +32,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -35,1 +36,1 @@\n-public abstract class OnnxOp extends ExternalizableOp {\n+public abstract class OnnxOp extends Op {\n@@ -232,1 +233,1 @@\n-        super(def);\n+        super(def.name(), def.operands());\n@@ -334,3 +335,2 @@\n-    public Map<String, Object> attributes() {\n-        HashMap<String, Object> m = new HashMap<>(super.attributes());\n-        m.putAll(onnxAttributes);\n+    public Map<String, Object> externalize() {\n+        HashMap<String, Object> m = new HashMap<>(onnxAttributes);\n@@ -343,1 +343,1 @@\n-        return m;\n+        return Collections.unmodifiableMap(m);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOp.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.extern.ExternalizedOp;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxOps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -35,1 +36,1 @@\n-public abstract sealed class OnnxType implements ExternalizableTypeElement {\n+public abstract sealed class OnnxType implements TypeElement {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -273,1 +273,1 @@\n-                ExternalizableOp.ExternalizedOp extOp = new ExternalizableOp.ExternalizedOp(\n+                ExternalizedOp extOp = new ExternalizedOp(\n@@ -275,0 +275,1 @@\n+                        null,\n@@ -286,1 +287,1 @@\n-                extOp = new ExternalizableOp.ExternalizedOp(\n+                extOp = new ExternalizedOp(\n@@ -288,0 +289,1 @@\n+                        null,\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/proto\/OnnxModelTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -30,1 +30,1 @@\n-public abstract sealed class SpirvType implements ExternalizableTypeElement permits PointerType, StorageType {\n+public abstract sealed class SpirvType implements TypeElement permits PointerType, StorageType {\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varValueType());\n+            SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.externalize().get(\"\"), resultType, jvop.varValueType());\n@@ -102,1 +102,1 @@\n-                    SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varValueType());\n+                    SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.externalize().get(\"\"), resultType, jvop.varValueType());\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -39,1 +39,1 @@\n-    static abstract class ArithMathOp extends ExternalizableOp {\n+    static abstract class ArithMathOp extends Op {\n@@ -43,1 +43,1 @@\n-            super(def);\n+            super(def.name(), def.operands());;\n@@ -134,4 +134,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(ATTRIBUTE_CONSTANT_VALUE, value);\n-            return attrs;\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_CONSTANT_VALUE, value);\n@@ -432,4 +430,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(ATTRIBUTE_PREDICATE, Long.valueOf(ck.ordinal()));\n-            return attrs;\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_PREDICATE, Long.valueOf(ck.ordinal()));\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -9,1 +9,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n@@ -11,0 +10,1 @@\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -68,1 +68,1 @@\n-            if (value == ExternalizableOp.NULL_ATTRIBUTE_VALUE)\n+            if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE)\n@@ -562,1 +562,1 @@\n-                    Object value = op instanceof ExternalizableOp exop ? exop.attributes().values().toArray()[0] : 0;\n+                    Object value = op.externalize().isEmpty() ? 0 : op.externalize().values().toArray()[0];\n@@ -607,5 +607,6 @@\n-        Map<String, Object> attributes = op instanceof ExternalizableOp exop ? exop.attributes() : Map.of();\n-        if (dropLocation && !attributes.isEmpty() &&\n-                attributes.containsKey(ExternalizableOp.ATTRIBUTE_LOCATION)) {\n-            attributes = new HashMap<>(attributes);\n-            attributes.remove(ExternalizableOp.ATTRIBUTE_LOCATION);\n+        if (!dropLocation) {\n+            Location location = op.location();\n+            if (location != null) {\n+                write(\" \");\n+                writeAttribute(\"loc\", op.location());\n+            }\n@@ -613,0 +614,1 @@\n+        Map<String, Object> attributes = op.externalize();\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/MLIRGenerator.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -42,1 +42,1 @@\n-    public static final class ForOp extends ExternalizableOp implements Op.Loop {\n+    public static final class ForOp extends Op implements Op.Loop {\n@@ -73,1 +73,1 @@\n-            super(def);\n+            super(def.name(), def.operands());;\n@@ -112,1 +112,1 @@\n-    public static class YieldOp extends ExternalizableOp implements Op.Terminating {\n+    public static class YieldOp extends Op implements Op.Terminating {\n@@ -116,1 +116,1 @@\n-            super(def);\n+            super(def.name(), def.operands());\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    static abstract class TritonOp extends ExternalizableOp {\n+    static abstract class TritonOp extends Op {\n@@ -45,1 +45,1 @@\n-            super(def);\n+            super(def.name(), def.operands());\n@@ -223,4 +223,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(ATTRIBUTE_FUNC_NAME, funcName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_FUNC_NAME, funcName);\n@@ -293,4 +291,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(ATTRIBUTE_FUNC_NAME, funcName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_FUNC_NAME, funcName);\n@@ -376,4 +372,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(ATTRIBUTE_AXIS, axis);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_AXIS, axis);\n@@ -453,4 +447,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(ATTRIBUTE_AXIS, axis);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_AXIS, axis);\n@@ -518,5 +510,4 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(ATTRIBUTE_START, start);\n-            m.put(ATTRIBUTE_END, end);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\n+                    ATTRIBUTE_START, start,\n+                    ATTRIBUTE_END, end);\n@@ -566,4 +557,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(ATTRIBUTE_AXIS, axis);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(ATTRIBUTE_AXIS, axis);\n@@ -836,1 +825,1 @@\n-        public TypeElement constructType(ExternalizableTypeElement.ExternalizedTypeElement tree) {\n+        public TypeElement constructType(ExternalizedTypeElement tree) {\n@@ -860,1 +849,1 @@\n-                        ExternalizableTypeElement.ExternalizedTypeElement a = tree.arguments().get(i);\n+                        ExternalizedTypeElement a = tree.arguments().get(i);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":18,"deletions":29,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,5 +28,2 @@\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -41,1 +38,1 @@\n-    public static class ConsumeOp extends ExternalizableOp {\n+    public static class ConsumeOp extends Op {\n@@ -45,1 +42,1 @@\n-            super(def);\n+            super(def.name(), def.operands());\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -30,1 +30,1 @@\n-public abstract sealed class TritonType implements ExternalizableTypeElement\n+public abstract sealed class TritonType implements TypeElement\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n@@ -167,1 +166,1 @@\n-    public static class PTXPtrOp extends ExternalizableOp {\n+    public static class PTXPtrOp extends Op {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.code.op.ExternalizableOp;\n@@ -44,1 +43,1 @@\n-public abstract class SpirvOp extends ExternalizableOp {\n+public abstract class SpirvOp extends Op {\n","filename":"hat\/backends\/ffi\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n@@ -210,1 +208,1 @@\n-    public static final class PtrType implements ExternalizableTypeElement {\n+    public static final class PtrType implements TypeElement {\n@@ -272,1 +270,1 @@\n-    public static final class PtrToMember extends ExternalizableOp {\n+    public static final class PtrToMember extends Op {\n@@ -348,5 +346,4 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", simpleMemberName);\n-            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n-            return attrs;\n+        public Map<String, Object> externalize() {\n+            return Map.of(\n+                    \"\", simpleMemberName,\n+                    ATTRIBUTE_OFFSET, memberOffset);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n@@ -241,1 +239,1 @@\n-    public static final class PtrType implements ExternalizableTypeElement {\n+    public static final class PtrType implements TypeElement {\n@@ -289,1 +287,1 @@\n-    public static final class PtrToMember extends ExternalizableOp {\n+    public static final class PtrToMember extends Op {\n@@ -365,5 +363,4 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", simpleMemberName);\n-            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n-            return attrs;\n+        public Map<String, Object> externalize() {\n+            return Map.of(\n+                    \"\", simpleMemberName,\n+                    ATTRIBUTE_OFFSET, memberOffset);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -55,1 +54,0 @@\n-import java.util.HashMap;\n@@ -235,1 +233,1 @@\n-    public abstract sealed static class HatType implements ExternalizableTypeElement permits HatPtrType {\n+    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n@@ -303,1 +301,1 @@\n-    public static final class HatPtrOp<T extends MappableIface> extends ExternalizableOp {\n+    public static final class HatPtrOp<T extends MappableIface> extends Op {\n@@ -363,5 +361,4 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", simpleMemberName);\n-            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n-            return attrs;\n+        public Map<String, Object> externalize() {\n+            return Map.of(\n+                    \"\", simpleMemberName,\n+                    ATTRIBUTE_OFFSET, memberOffset);\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-        \/\/  if (value == Op.NULL_ATTRIBUTE_VALUE) {\n+        \/\/  if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE) {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/opcodebuilders\/OpCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,0 +408,12 @@\n+    \/**\n+     * Externalizes the operation's state as a map of attributes.\n+     *\n+     * <p>A null attribute value is represented by the constant\n+     * value {@link jdk.incubator.code.extern.ExternalizedOp#NULL_ATTRIBUTE_VALUE}.\n+     *\n+     * @return the operation's externalized state, as an unmodifiable map\n+     *\/\n+    public Map<String, Object> externalize() {\n+        return Map.of();\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -24,5 +24,0 @@\n-     * @implSpec\n-     * The default implementation returns an externalized type element with\n-     * an identifier that is the result of applying {@code toString} to this object, and\n-     * with no arguments.\n-     *\n@@ -31,9 +26,1 @@\n-    default ExternalizableTypeElement.ExternalizedTypeElement externalize() {\n-        \/\/ @@@ Certain externalizable type elements are composed of other type elements,\n-        \/\/ which may or may not be externalizable. OpWriter is designed to work with\n-        \/\/ non-externalizable type elements, but in such cases OpParser will fail\n-        \/\/ to parse what OpWriter produces.\n-        \/\/ @@@ Should this throw UnsupportedOperationException\n-        \/\/ @@@ Should this be a static helper method on ExternalizableTypeElement?\n-        return ExternalizableTypeElement.ExternalizedTypeElement.of(toString());\n-    }\n+    ExternalizedTypeElement externalize();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/TypeElement.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,5 +28,3 @@\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.extern.ExternalizableOp;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -36,2 +34,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n@@ -41,1 +37,1 @@\n-sealed abstract class SlotOp extends ExternalizableOp {\n+sealed abstract class SlotOp extends Op {\n@@ -71,11 +67,0 @@\n-    protected SlotOp(ExternalizedOp def) {\n-        super(def);\n-\n-        this.slot = def.extractAttributeValue(ATTRIBUTE_SLOT, true,\n-                v -> switch (v) {\n-                    case String s -> Integer.parseInt(s);\n-                    case Integer i -> i;\n-                    default -> throw new UnsupportedOperationException(\"Unsupported slot value:\" + v);\n-                });\n-    }\n-\n@@ -89,4 +74,2 @@\n-    public Map<String, Object> attributes() {\n-        HashMap<String, Object> m = new HashMap<>(super.attributes());\n-        m.put(\"\", slot);\n-        return Collections.unmodifiableMap(m);\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"\", slot);\n@@ -101,8 +84,8 @@\n-        public SlotLoadOp(ExternalizedOp opdef) {\n-            super(opdef);\n-\n-            if (opdef.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand\");\n-            }\n-\n-            this.resultType = opdef.resultType();\n+        public SlotLoadOp(ExternalizedOp def) {\n+            int slot = def.extractAttributeValue(ATTRIBUTE_SLOT, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.parseInt(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported slot value:\" + v);\n+                    });\n+            this(slot, def.resultType());\n@@ -146,6 +129,8 @@\n-        public SlotStoreOp(ExternalizedOp opdef) {\n-            super(opdef);\n-\n-            if (opdef.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Operation must have two operands\");\n-            }\n+        public SlotStoreOp(ExternalizedOp def) {\n+            int slot = def.extractAttributeValue(ATTRIBUTE_SLOT, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.parseInt(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported slot value:\" + v);\n+                    });\n+            this(slot, def.operands().getFirst());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/SlotOp.java","additions":22,"deletions":37,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n@@ -30,0 +29,2 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n+\n@@ -43,1 +44,1 @@\n-        private static final ExternalizableTypeElement.ExternalizedTypeElement UNRESOLVED_REF = new ExternalizableTypeElement.ExternalizedTypeElement(\"?REF\", List.of());\n+        private static final ExternalizedTypeElement UNRESOLVED_REF = new ExternalizedTypeElement(\"?REF\", List.of());\n@@ -46,1 +47,1 @@\n-        public ExternalizableTypeElement.ExternalizedTypeElement externalize() {\n+        public ExternalizedTypeElement externalize() {\n@@ -52,1 +53,1 @@\n-        private static final ExternalizableTypeElement.ExternalizedTypeElement UNRESOLVED_INT = new ExternalizableTypeElement.ExternalizedTypeElement(\"?INT\", List.of());\n+        private static final ExternalizedTypeElement UNRESOLVED_INT = new ExternalizedTypeElement(\"?INT\", List.of());\n@@ -55,1 +56,1 @@\n-        public ExternalizableTypeElement.ExternalizedTypeElement externalize() {\n+        public ExternalizedTypeElement externalize() {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedType.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -31,1 +30,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -45,1 +44,1 @@\n-public sealed abstract class CoreOp extends ExternalizableOp {\n+public sealed abstract class CoreOp extends Op {\n@@ -55,4 +54,0 @@\n-    protected CoreOp(ExternalizedOp def) {\n-        super(def);\n-    }\n-\n@@ -100,8 +95,1 @@\n-            return new FuncOp(def, funcName);\n-        }\n-\n-        FuncOp(ExternalizedOp def, String funcName) {\n-            super(def);\n-\n-            this.funcName = funcName;\n-            this.body = def.bodyDefinitions().get(0).build(this);\n+            return new FuncOp(funcName, def.bodyDefinitions().get(0));\n@@ -135,2 +123,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(NAME, List.of());\n@@ -148,4 +135,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", funcName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", funcName);\n@@ -201,8 +186,1 @@\n-            return new FuncCallOp(def, funcName);\n-        }\n-\n-        FuncCallOp(ExternalizedOp def, String funcName) {\n-            super(def);\n-\n-            this.funcName = funcName;\n-            this.resultType = def.resultType();\n+            return new FuncCallOp(funcName, def.resultType(), def.operands());\n@@ -231,4 +209,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", funcName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", funcName);\n@@ -265,8 +241,1 @@\n-            return new ModuleOp(def);\n-        }\n-\n-        ModuleOp(ExternalizedOp def) {\n-            super(def);\n-\n-            this.body = def.bodyDefinitions().get(0).build(this);\n-            this.table = createTable(body);\n+            return new ModuleOp(def.bodyDefinitions().get(0));\n@@ -303,3 +272,2 @@\n-        ModuleOp(List<FuncOp> functions) {\n-            super(NAME,\n-                    List.of());\n+        ModuleOp(Body.Builder bodyBuilder) {\n+            super(NAME, List.of());\n@@ -307,0 +275,5 @@\n+            this.body = bodyBuilder.build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        ModuleOp(List<FuncOp> functions) {\n@@ -309,1 +282,0 @@\n-            SequencedMap<String, FuncOp> table = new LinkedHashMap<>();\n@@ -312,1 +284,0 @@\n-                table.put(f.funcName(), f);\n@@ -315,2 +286,2 @@\n-            this.table = Collections.unmodifiableSequencedMap(table);\n-            this.body = bodyC.build(this);\n+\n+            this(bodyC);\n@@ -355,10 +326,1 @@\n-            super(def);\n-\n-            this.quotedBody = def.bodyDefinitions().get(0).build(this);\n-\n-            if (quotedBody.entryBlock().terminatingOp() instanceof YieldOp brk &&\n-                    brk.yieldValue() instanceof Result quotedOpResult) {\n-                this.quotedOp = quotedOpResult.op();\n-            } else {\n-                throw new IllegalArgumentException();\n-            }\n+            this(def.bodyDefinitions().get(0));\n@@ -380,2 +342,1 @@\n-            super(NAME,\n-                    List.of());\n+            super(NAME, List.of());\n@@ -453,3 +414,1 @@\n-            super(def);\n-\n-            this.body = def.bodyDefinitions().get(0).build(this);\n+            this(def.bodyDefinitions().get(0));\n@@ -519,1 +478,1 @@\n-            super(def);\n+            this(def.operands());\n@@ -553,2 +512,0 @@\n-            super(def);\n-\n@@ -558,0 +515,2 @@\n+\n+            this(def.operands().isEmpty() ? null : def.operands().get(0));\n@@ -569,4 +528,0 @@\n-        ReturnOp() {\n-            super(NAME, List.of());\n-        }\n-\n@@ -574,1 +529,1 @@\n-            super(NAME, List.of(operand));\n+            super(NAME, operand == null ? List.of() : List.of(operand));\n@@ -603,2 +558,0 @@\n-            super(def);\n-\n@@ -608,0 +561,2 @@\n+\n+            this();\n@@ -641,2 +596,0 @@\n-            super(def);\n-\n@@ -646,0 +599,2 @@\n+\n+            this(def.operands());\n@@ -693,2 +648,0 @@\n-            super(def);\n-\n@@ -699,1 +652,1 @@\n-            this.b = def.successors().get(0);\n+            this(def.successors().get(0));\n@@ -750,2 +703,0 @@\n-            super(def);\n-\n@@ -756,2 +707,1 @@\n-            this.t = def.successors().get(0);\n-            this.f = def.successors().get(1);\n+            this(def.operands().getFirst(), def.successors().get(0), def.successors().get(1));\n@@ -822,1 +772,1 @@\n-            return new ConstantOp(def, value);\n+            return new ConstantOp(def.resultType(), value);\n@@ -843,1 +793,1 @@\n-                return value == NULL_ATTRIBUTE_VALUE ?\n+                return value == ExternalizedOp.NULL_ATTRIBUTE_VALUE ?\n@@ -846,1 +796,1 @@\n-                return value == NULL_ATTRIBUTE_VALUE ?\n+                return value == ExternalizedOp.NULL_ATTRIBUTE_VALUE ?\n@@ -848,1 +798,1 @@\n-            } else if (value == NULL_ATTRIBUTE_VALUE) {\n+            } else if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE) {\n@@ -855,7 +805,0 @@\n-        ConstantOp(ExternalizedOp def, Object value) {\n-            super(def);\n-\n-            this.type = def.resultType();\n-            this.value = value;\n-        }\n-\n@@ -882,4 +825,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-            attrs.put(\"\", value == null ? NULL_ATTRIBUTE_VALUE : value);\n-            return attrs;\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", value == null ? ExternalizedOp.NULL_ATTRIBUTE_VALUE : value);\n@@ -947,0 +888,1 @@\n+            \/\/ @@@ Cannot use canonical constructor because type is wrapped\n@@ -951,1 +893,1 @@\n-            super(def);\n+            super(NAME, def.operands());\n@@ -974,4 +916,0 @@\n-        VarOp(String varName, Value init) {\n-            this(varName, init.type(), init);\n-        }\n-\n@@ -979,10 +917,1 @@\n-            super(NAME, List.of(init));\n-\n-            this.varName =  varName == null ? \"\" : varName;\n-            this.resultType = CoreType.varType(type);\n-        }\n-\n-        \/\/ @@@ This and the above constructor can be merged when\n-        \/\/ statements before super can be used in the jdk.compiler module\n-        VarOp(String varName, TypeElement type) {\n-            super(NAME, List.of());\n+            super(NAME, init == null ? List.of() : List.of(init));\n@@ -995,8 +924,2 @@\n-        public Map<String, Object> attributes() {\n-            if (isUnnamedVariable()) {\n-                return super.attributes();\n-            }\n-\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", varName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return isUnnamedVariable() ? Map.of() : Map.of(\"\", varName);\n@@ -1040,4 +963,0 @@\n-        VarAccessOp(ExternalizedOp opdef) {\n-            super(opdef);\n-        }\n-\n@@ -1086,2 +1005,0 @@\n-                super(opdef);\n-\n@@ -1092,0 +1009,2 @@\n+\n+                this(opdef.operands().get(0));\n@@ -1098,4 +1017,0 @@\n-            VarLoadOp(List<Value> varValue) {\n-                super(NAME, varValue);\n-            }\n-\n@@ -1127,2 +1042,0 @@\n-                super(opdef);\n-\n@@ -1133,0 +1046,2 @@\n+\n+                this(opdef.operands().get(0), opdef.operands().get(1));\n@@ -1151,2 +1066,1 @@\n-                super(NAME,\n-                        List.of(varValue, v));\n+                super(NAME, List.of(varValue, v));\n@@ -1176,1 +1090,1 @@\n-            super(def);\n+            this(def.operands());\n@@ -1218,8 +1132,1 @@\n-            return new TupleLoadOp(def, index);\n-        }\n-\n-        TupleLoadOp(ExternalizedOp def, int index) {\n-            super(def);\n-\n-            \/\/ @@@ Validate tuple type and index\n-            this.index = index;\n+            return new TupleLoadOp(def.operands().get(0), index);\n@@ -1250,4 +1157,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", index);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", index);\n@@ -1288,8 +1193,1 @@\n-            return new TupleWithOp(def, index);\n-        }\n-\n-        TupleWithOp(ExternalizedOp def, int index) {\n-            super(def);\n-\n-            \/\/ @@@ Validate tuple type and index\n-            this.index = index;\n+            return new TupleWithOp(def.operands().get(0), index, def.operands().get(1));\n@@ -1321,4 +1219,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", index);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", index);\n@@ -1335,1 +1231,1 @@\n-            Value value = operands().get(2);\n+            Value value = operands().get(1);\n@@ -1513,1 +1409,1 @@\n-        return new ReturnOp();\n+        return _return(null);\n@@ -1609,1 +1505,1 @@\n-        return new VarOp(name, type);\n+        return var(name, type, null);\n@@ -1632,1 +1528,1 @@\n-        return new VarOp(name, init);\n+        return var(name, init.type(), init);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":59,"deletions":163,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n@@ -6,0 +5,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -17,1 +17,1 @@\n-public sealed interface CoreType extends ExternalizableTypeElement\n+public sealed interface CoreType extends TypeElement\n@@ -33,1 +33,1 @@\n-            public TypeElement constructType(ExternalizableTypeElement.ExternalizedTypeElement tree) {\n+            public TypeElement constructType(ExternalizedTypeElement tree) {\n@@ -52,1 +52,1 @@\n-                        for (ExternalizableTypeElement.ExternalizedTypeElement child : tree.arguments()) {\n+                        for (ExternalizedTypeElement child : tree.arguments()) {\n@@ -71,1 +71,1 @@\n-                        for (ExternalizableTypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n+                        for (ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreType.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/FunctionType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/TupleType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/VarType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ArrayType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ClassType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -62,1 +62,1 @@\n-public sealed abstract class JavaOp extends ExternalizableOp {\n+public sealed abstract class JavaOp extends Op {\n@@ -72,4 +72,0 @@\n-    protected JavaOp(ExternalizableOp.ExternalizedOp def) {\n-        super(def);\n-    }\n-\n@@ -181,4 +177,1 @@\n-            super(def);\n-\n-            this.functionalInterface = def.resultType();\n-            this.body = def.bodyDefinitions().get(0).build(this);\n+            this(def.resultType(), def.bodyDefinitions().get(0));\n@@ -386,2 +379,0 @@\n-            super(def);\n-\n@@ -391,0 +382,2 @@\n+\n+            this(def.operands().get(0));\n@@ -426,4 +419,1 @@\n-            super(def);\n-            var bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n-            checkBodies(bodies);\n-            this.bodies = bodies;\n+            this(def.bodyDefinitions());\n@@ -434,1 +424,4 @@\n-            checkBodies(bodies);\n+\n+            if (bodies.size() != 1 && bodies.size() != 2) {\n+                throw new IllegalArgumentException(\"Assert must have one or two bodies.\");\n+            }\n@@ -439,1 +432,0 @@\n-\n@@ -444,6 +436,0 @@\n-        private void checkBodies(List<?> bodies) {\n-            if (bodies.size() != 1 && bodies.size() != 2) {\n-                throw new IllegalArgumentException(\"Assert must have one or two bodies.\");\n-            }\n-        }\n-\n@@ -470,8 +456,0 @@\n-        public MonitorOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n-            }\n-        }\n-\n@@ -503,1 +481,5 @@\n-                super(def);\n+                if (def.operands().size() != 1) {\n+                    throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+                }\n+\n+                this(def.operands().get(0));\n@@ -528,1 +510,5 @@\n-                super(def);\n+                if (def.operands().size() != 1) {\n+                    throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+                }\n+\n+                this(def.operands().get(0));\n@@ -617,12 +603,1 @@\n-            return new InvokeOp(def, ik, isVarArgs, invokeDescriptor);\n-        }\n-\n-        InvokeOp(ExternalizedOp def, InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor) {\n-            super(def);\n-\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, def.operands());\n-\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n-            this.invokeDescriptor = invokeDescriptor;\n-            this.resultType = def.resultType();\n+            return new InvokeOp(ik, isVarArgs, def.resultType(), invokeDescriptor, def.operands());\n@@ -666,2 +641,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+        public Map<String, Object> externalize() {\n+            HashMap<String, Object> m = new HashMap<>();\n@@ -738,3 +713,1 @@\n-            super(def);\n-\n-            this.resultType = def.resultType();\n+            this(def.resultType(), def.operands().get(0));\n@@ -797,11 +770,1 @@\n-            return new NewOp(def, isVarArgs, constructorDescriptor);\n-        }\n-\n-        NewOp(ExternalizedOp def, boolean isVarArgs, ConstructorRef constructorDescriptor) {\n-            super(def);\n-\n-            validateArgCount(isVarArgs, constructorDescriptor, def.operands());\n-\n-            this.isVarArgs = isVarArgs;\n-            this.constructorDescriptor = constructorDescriptor;\n-            this.resultType = def.resultType();\n+            return new NewOp(isVarArgs, def.resultType(), constructorDescriptor, def.operands());\n@@ -818,9 +781,0 @@\n-        static void validateArgCount(boolean isVarArgs, ConstructorRef constructorDescriptor, List<Value> operands) {\n-            int paramCount = constructorDescriptor.type().parameterTypes().size();\n-            int argCount = operands.size();\n-            if ((!isVarArgs && argCount != paramCount)\n-                    || argCount < paramCount - 1) {\n-                throw new IllegalArgumentException(isVarArgs + \" \" + constructorDescriptor);\n-            }\n-        }\n-\n@@ -835,0 +789,2 @@\n+            validateArgCount(isVarargs, constructorDescriptor, args);\n+\n@@ -840,0 +796,9 @@\n+        static void validateArgCount(boolean isVarArgs, ConstructorRef constructorDescriptor, List<Value> operands) {\n+            int paramCount = constructorDescriptor.type().parameterTypes().size();\n+            int argCount = operands.size();\n+            if ((!isVarArgs && argCount != paramCount)\n+                    || argCount < paramCount - 1) {\n+                throw new IllegalArgumentException(isVarArgs + \" \" + constructorDescriptor);\n+            }\n+        }\n+\n@@ -841,2 +806,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+        public Map<String, Object> externalize() {\n+            HashMap<String, Object> m = new HashMap<>();\n@@ -877,6 +842,0 @@\n-        FieldAccessOp(ExternalizedOp def, FieldRef fieldDescriptor) {\n-            super(def);\n-\n-            this.fieldDescriptor = fieldDescriptor;\n-        }\n-\n@@ -897,4 +856,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", fieldDescriptor);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", fieldDescriptor);\n@@ -929,7 +886,5 @@\n-                return new FieldLoadOp(def, fieldDescriptor);\n-            }\n-\n-            FieldLoadOp(ExternalizedOp opdef, FieldRef fieldDescriptor) {\n-                super(opdef, fieldDescriptor);\n-\n-                resultType = opdef.resultType();\n+                if (def.operands().isEmpty()) {\n+                    return new FieldLoadOp(def.resultType(), fieldDescriptor);\n+                } else {\n+                    return new FieldLoadOp(def.resultType(), fieldDescriptor, def.operands().get(0));\n+                }\n@@ -979,1 +934,1 @@\n-                if (def.operands().size() > 2) {\n+                if (def.operands().isEmpty() || def.operands().size() > 2) {\n@@ -989,5 +944,5 @@\n-                return new FieldStoreOp(def, fieldDescriptor);\n-            }\n-\n-            FieldStoreOp(ExternalizedOp opdef, FieldRef fieldDescriptor) {\n-                super(opdef, fieldDescriptor);\n+                if (def.operands().size() == 1) {\n+                    return new FieldStoreOp(fieldDescriptor, def.operands().get(0));\n+                } else {\n+                    return new FieldStoreOp(fieldDescriptor, def.operands().get(0), def.operands().get(1));\n+                }\n@@ -1007,2 +962,1 @@\n-                super(NAME,\n-                        List.of(receiver, v), descriptor);\n+                super(NAME, List.of(receiver, v), descriptor);\n@@ -1013,2 +967,1 @@\n-                super(NAME,\n-                        List.of(v), descriptor);\n+                super(NAME, List.of(v), descriptor);\n@@ -1034,1 +987,1 @@\n-            super(def);\n+            this(def.operands().get(0));\n@@ -1061,9 +1014,0 @@\n-        ArrayAccessOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 2 && def.operands().size() != 3) {\n-                throw new IllegalArgumentException(\"Operation must have 2 or 3 operands\");\n-            }\n-\n-            \/\/ @@@ validate first operand is an array\n-        }\n@@ -1101,2 +1045,5 @@\n-                super(def);\n-                this.componentType = def.resultType();\n+                if (def.operands().size() != 2) {\n+                    throw new IllegalArgumentException(\"Operation must have two operands\");\n+                }\n+\n+                this(def.operands().get(0), def.operands().get(1), def.resultType());\n@@ -1141,1 +1088,5 @@\n-                super(def);\n+                if (def.operands().size() != 3) {\n+                    throw new IllegalArgumentException(\"Operation must have two operands\");\n+                }\n+\n+                this(def.operands().get(0), def.operands().get(1), def.operands().get(2));\n@@ -1186,7 +1137,1 @@\n-            return new InstanceOfOp(def, typeDescriptor);\n-        }\n-\n-        InstanceOfOp(ExternalizedOp def, TypeElement typeDescriptor) {\n-            super(def);\n-\n-            this.typeDescriptor = typeDescriptor;\n+            return new InstanceOfOp(typeDescriptor, def.operands().get(0));\n@@ -1207,2 +1152,1 @@\n-            super(NAME,\n-                    List.of(v));\n+            super(NAME, List.of(v));\n@@ -1214,4 +1158,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", typeDescriptor);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", typeDescriptor);\n@@ -1252,8 +1194,1 @@\n-            return new CastOp(def, type);\n-        }\n-\n-        CastOp(ExternalizedOp def, TypeElement typeDescriptor) {\n-            super(def);\n-\n-            this.resultType = def.resultType();\n-            this.typeDescriptor = typeDescriptor;\n+            return new CastOp(def.resultType(), type, def.operands().get(0));\n@@ -1282,4 +1217,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", typeDescriptor);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", typeDescriptor);\n@@ -1313,7 +1246,1 @@\n-            super(def);\n-\n-            if (def.successors().size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n-            }\n-\n-            this.s = List.copyOf(def.successors());\n+            this(def.successors());\n@@ -1375,7 +1302,1 @@\n-            super(def);\n-\n-            if (def.successors().size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n-            }\n-\n-            this.s = List.copyOf(def.successors());\n+            this(def.successors());\n@@ -1438,1 +1359,0 @@\n-            super(def);\n@@ -1442,0 +1362,2 @@\n+\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1464,8 +1386,0 @@\n-        protected ArithmeticOperation(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().isEmpty()) {\n-                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n-            }\n-        }\n-\n@@ -1486,8 +1400,0 @@\n-        protected TestOperation(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().isEmpty()) {\n-                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n-            }\n-        }\n-\n@@ -1507,8 +1413,0 @@\n-        protected BinaryOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n-            }\n-        }\n-\n@@ -1533,8 +1431,0 @@\n-        protected UnaryOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n-            }\n-        }\n-\n@@ -1559,8 +1449,0 @@\n-        protected BinaryTestOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 2) {\n-                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n-            }\n-        }\n-\n@@ -1589,1 +1471,1 @@\n-            super(def);\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1613,2 +1495,2 @@\n-        public SubOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public SubOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1638,2 +1520,2 @@\n-        public MulOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public MulOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1663,2 +1545,2 @@\n-        public DivOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public DivOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1688,2 +1570,2 @@\n-        public ModOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public ModOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1714,2 +1596,2 @@\n-        public OrOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public OrOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1740,2 +1622,2 @@\n-        public AndOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public AndOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1766,2 +1648,2 @@\n-        public XorOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public XorOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1791,2 +1673,2 @@\n-        public LshlOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public LshlOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1816,2 +1698,2 @@\n-        public AshrOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public AshrOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1841,2 +1723,2 @@\n-        public LshrOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public LshrOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1866,2 +1748,2 @@\n-        public NegOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public NegOp(ExternalizedOp def) {\n+            this(def.operands().get(0));\n@@ -1891,2 +1773,2 @@\n-        public ComplOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public ComplOp(ExternalizedOp def) {\n+            this(def.operands().get(0));\n@@ -1916,2 +1798,2 @@\n-        public NotOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public NotOp(ExternalizedOp def) {\n+            this(def.operands().get(0));\n@@ -1942,2 +1824,2 @@\n-        public EqOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public EqOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1968,2 +1850,2 @@\n-        public NeqOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public NeqOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -1993,2 +1875,2 @@\n-        public GtOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public GtOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -2019,2 +1901,2 @@\n-        public GeOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public GeOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -2045,2 +1927,2 @@\n-        public LtOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public LtOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -2071,2 +1953,2 @@\n-        public LeOp(ExternalizedOp opdef) {\n-            super(opdef);\n+        public LeOp(ExternalizedOp def) {\n+            this(def.operands().get(0), def.operands().get(1));\n@@ -2094,8 +1976,0 @@\n-        JavaLabelOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() > 1) {\n-                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n-            }\n-        }\n-\n@@ -2189,1 +2063,1 @@\n-            super(def);\n+            this(def.operands().isEmpty() ? null : def.operands().get(0));\n@@ -2219,1 +2093,1 @@\n-            super(def);\n+            this(def.operands().isEmpty() ? null : def.operands().get(0));\n@@ -2271,1 +2145,5 @@\n-            super(def);\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+\n+            this(def.operands().isEmpty() ? null : def.operands().get(0));\n@@ -2283,5 +2161,0 @@\n-        JavaYieldOp() {\n-            super(NAME,\n-                    List.of());\n-        }\n-\n@@ -2289,1 +2162,1 @@\n-            super(NAME, List.of(operand));\n+            super(NAME, operand == null ? List.of() : List.of(operand));\n@@ -2352,2 +2225,0 @@\n-            super(def);\n-\n@@ -2358,1 +2229,1 @@\n-            this.body = def.bodyDefinitions().get(0).build(this);\n+            this(def.bodyDefinitions().get(0));\n@@ -2434,4 +2305,1 @@\n-            super(def);\n-\n-            this.expr = def.bodyDefinitions().get(0).build(this);\n-            this.blockBody = def.bodyDefinitions().get(1).build(this);\n+            this(def.bodyDefinitions().get(0), def.bodyDefinitions().get(1));\n@@ -2604,2 +2472,0 @@\n-            super(def);\n-\n@@ -2610,1 +2476,1 @@\n-            this.body = def.bodyDefinitions().get(0).build(this);\n+            this(def.bodyDefinitions().get(0));\n@@ -2779,2 +2645,0 @@\n-            super(def);\n-\n@@ -2785,3 +2649,1 @@\n-            \/\/ @@@ Validate\n-\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this(def.bodyDefinitions());\n@@ -2916,11 +2778,0 @@\n-        public JavaSwitchOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (def.operands().size() != 1) {\n-                throw new IllegalStateException(\"Operation must have one operand\");\n-            }\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n@@ -3075,3 +2926,1 @@\n-            super(def);\n-\n-            this.resultType = def.resultType();\n+            this(def.resultType(), def.operands().get(0), def.bodyDefinitions());\n@@ -3112,1 +2961,1 @@\n-            super(def);\n+            this(def.operands().get(0), def.bodyDefinitions());\n@@ -3144,1 +2993,1 @@\n-            super(def);\n+            this();\n@@ -3292,6 +3141,4 @@\n-            super(def);\n-\n-            this.init = def.bodyDefinitions().get(0).build(this);\n-            this.cond = def.bodyDefinitions().get(1).build(this);\n-            this.update = def.bodyDefinitions().get(2).build(this);\n-            this.body = def.bodyDefinitions().get(3).build(this);\n+            this(def.bodyDefinitions().get(0),\n+                    def.bodyDefinitions().get(1),\n+                    def.bodyDefinitions().get(2),\n+                    def.bodyDefinitions().get(3));\n@@ -3528,5 +3375,3 @@\n-            super(def);\n-\n-            this.expression = def.bodyDefinitions().get(0).build(this);\n-            this.init = def.bodyDefinitions().get(1).build(this);\n-            this.body = def.bodyDefinitions().get(2).build(this);\n+            this(def.bodyDefinitions().get(0),\n+                    def.bodyDefinitions().get(1),\n+                    def.bodyDefinitions().get(2));\n@@ -3746,4 +3591,1 @@\n-            super(def);\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this(def.bodyDefinitions());\n@@ -3892,4 +3734,1 @@\n-            super(def);\n-\n-            \/\/ @@@ Validate\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this(def.bodyDefinitions());\n@@ -3999,12 +3838,0 @@\n-        public JavaConditionalOp(ExternalizedOp def) {\n-            super(def);\n-\n-            if (!def.operands().isEmpty()) {\n-                throw new IllegalStateException(\"Operation must have no operands\");\n-            }\n-\n-            \/\/ @@@ Validate\n-\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-        }\n-\n@@ -4138,1 +3965,1 @@\n-            super(def);\n+            this(def.bodyDefinitions());\n@@ -4193,1 +4020,1 @@\n-            super(def);\n+            this(def.bodyDefinitions());\n@@ -4229,2 +4056,0 @@\n-            super(def);\n-\n@@ -4235,4 +4060,1 @@\n-            \/\/ @@@ Validate\n-\n-            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-            this.resultType = def.resultType();\n+            this(def.resultType(), def.bodyDefinitions());\n@@ -4395,4 +4217,4 @@\n-            super(def);\n-\n-            List<Body> bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n-            Body first = bodies.get(0);\n+            List<Body.Builder> bodies = def.bodyDefinitions();\n+            Body.Builder first = bodies.getFirst();\n+            Body.Builder resources;\n+            Body.Builder body;\n@@ -4400,2 +4222,2 @@\n-                this.resources = null;\n-                this.body = first;\n+                resources = null;\n+                body = first;\n@@ -4403,2 +4225,2 @@\n-                this.resources = first;\n-                this.body = bodies.get(1);\n+                resources = first;\n+                body = bodies.get(1);\n@@ -4407,1 +4229,2 @@\n-            Body last = bodies.get(bodies.size() - 1);\n+            Body.Builder last = bodies.getLast();\n+            Body.Builder finalizer;\n@@ -4409,1 +4232,1 @@\n-                this.finalizer = last;\n+                finalizer = last;\n@@ -4411,1 +4234,1 @@\n-                this.finalizer = null;\n+                finalizer = null;\n@@ -4413,1 +4236,1 @@\n-            this.catchers = bodies.subList(\n+            List<Body.Builder> catchers = bodies.subList(\n@@ -4416,0 +4239,2 @@\n+\n+            this(resources, body, catchers, finalizer);\n@@ -4838,4 +4663,0 @@\n-            PatternOp(ExternalizedOp def) {\n-                super(def);\n-            }\n-\n@@ -4863,2 +4684,4 @@\n-            public static TypePatternOp create(ExternalizedOp def) {\n-                String name = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n+            public TypePatternOp(ExternalizedOp def) {\n+                super(NAME, List.of());\n+\n+                this.bindingName = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n@@ -4870,7 +4693,1 @@\n-                return new TypePatternOp(def, name);\n-            }\n-\n-            TypePatternOp(ExternalizedOp def, String bindingName) {\n-                super(def);\n-\n-                this.bindingName = bindingName;\n+                \/\/ @@@ Cannot use canonical constructor because it wraps the given type\n@@ -4900,6 +4717,2 @@\n-            public Map<String, Object> attributes() {\n-                HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n-                if (bindingName != null) {\n-                    attrs.put(\"\", bindingName);\n-                }\n-                return attrs;\n+            public Map<String, Object> externalize() {\n+                return bindingName == null ? Map.of() : Map.of(\"\", bindingName);\n@@ -4941,7 +4754,1 @@\n-                return new RecordPatternOp(def, recordDescriptor);\n-            }\n-\n-            RecordPatternOp(ExternalizedOp def, RecordTypeRef recordDescriptor) {\n-                super(def);\n-\n-                this.recordDescriptor = recordDescriptor;\n+                return new RecordPatternOp(recordDescriptor, def.operands());\n@@ -4970,4 +4777,2 @@\n-            public Map<String, Object> attributes() {\n-                HashMap<String, Object> m = new HashMap<>(super.attributes());\n-                m.put(\"\", recordDescriptor);\n-                return Collections.unmodifiableMap(m);\n+            public Map<String, Object> externalize() {\n+                return Map.of(\"\", recordDescriptor());\n@@ -4999,1 +4804,1 @@\n-                super(def);\n+                this();\n@@ -5032,4 +4837,2 @@\n-                super(def);\n-\n-                this.pattern = def.bodyDefinitions().get(0).build(this);\n-                this.match = def.bodyDefinitions().get(1).build(this);\n+                this(def.operands().get(0),\n+                        def.bodyDefinitions().get(0), def.bodyDefinitions().get(1));\n@@ -6005,1 +5808,1 @@\n-        return new JavaYieldOp();\n+        return java_yield(null);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":170,"deletions":367,"binary":false,"changes":537,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -14,1 +14,1 @@\n-public sealed interface JavaRef extends ExternalizableTypeElement\n+public sealed interface JavaRef extends TypeElement\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaRef.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.code.TypeElement;\n@@ -36,1 +37,0 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n@@ -59,1 +59,1 @@\n-public sealed interface JavaType extends ExternalizableTypeElement\n+public sealed interface JavaType extends TypeElement\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/PrimitiveType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.TypeElement;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -139,1 +140,1 @@\n-    public sealed interface Owner extends ExternalizableTypeElement permits ClassType, MethodRef, ConstructorRef { }\n+    public sealed interface Owner extends TypeElement permits ClassType, MethodRef, ConstructorRef { }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/TypeVariableType.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/WildcardType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/ConstructorRefImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/FieldRefImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement.ExternalizedTypeElement;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/JavaTypeUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/MethodRefImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/RecordTypeRefImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.extern;\n-\n-import jdk.incubator.code.*;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Function;\n-\n-\/**\n- * An operation that supports externalization of its content and reconstruction\n- * via an instance of {@link ExternalizedOp}.\n- * <p>\n- * The specific content of an externalizable operation can be externalized to a\n- * map of {@link #attributes attributes}, and is reconstructed from the\n- * attributes component of an instance of {@link ExternalizedOp}.\n- * <p>\n- * An externalizable operation could be externalized via serialization to\n- * a textual representation. That textual representation could then be deserialized,\n- * via parsing, into an instance of {@link ExternalizedOp} from which a new\n- * externalizable operation can be reconstructed that is identical to one that\n- * was serialized.\n- *\/\n-public abstract class ExternalizableOp extends Op {\n-\n-    \/**\n-     * An operation's externalized content (a record) that can be utilized to construct an instance\n-     * of an {@link ExternalizableOp} associated with the operation's name.\n-     *\n-     * @param name            the operation name\n-     * @param operands        the list of operands\n-     * @param successors      the list of successors\n-     * @param resultType      the operation result type\n-     * @param attributes      the operation's specific content as an attributes map\n-     * @param bodyDefinitions the list of body builders for building the operation's bodies\n-     * @apiNote Deserializers of operations may utilize this record to construct operations,\n-     * thereby separating the specifics of deserializing from construction.\n-     *\/\n-    public record ExternalizedOp(String name,\n-                                 List<Value> operands,\n-                                 List<Block.Reference> successors,\n-                                 TypeElement resultType,\n-                                 Map<String, Object> attributes,\n-                                 List<Body.Builder> bodyDefinitions) {\n-\n-        public ExternalizedOp {\n-            attributes = Map.copyOf(attributes);\n-        }\n-\n-        \/**\n-         * Gets an attribute value from the attributes map, converts the value by applying it\n-         * to mapping function, and returns the result.\n-         *\n-         * <p>If the attribute is a default attribute then this method first attempts to\n-         * get the attribute whose name is the empty string, otherwise if there is no such\n-         * attribute present or the attribute is not a default attribute then this method\n-         * attempts to get the attribute with the given name.\n-         *\n-         * <p>On successfully obtaining the attribute its value is converted by applying the value\n-         * to the mapping function. A {@code null} value is represented by the value\n-         * {@link #NULL_ATTRIBUTE_VALUE}.\n-         *\n-         * <p>If no attribute is present the {@code null} value is applied to the mapping function.\n-         *\n-         * @param name      the attribute name.\n-         * @param isDefault true if the attribute is a default attribute\n-         * @param <T>       the converted attribute value type\n-         * @return the converted attribute value\n-         *\/\n-        public <T> T extractAttributeValue(String name, boolean isDefault, Function<Object, T> mapper) {\n-            Object value = null;\n-            if (isDefault && attributes.containsKey(\"\")) {\n-                value = attributes.get(\"\");\n-                assert value != null;\n-            }\n-\n-            if (value == null && attributes.containsKey(name)) {\n-                value = attributes.get(name);\n-                assert value != null;\n-            }\n-\n-            return mapper.apply(value);\n-        }\n-\n-        \/**\n-         * Externalizes an operation's content.\n-         * <p>\n-         * If the operation is an instanceof {@code ExternalizableOp} then the operation's\n-         * specific content is externalized to an attribute map, otherwise the attribute map\n-         * is empty.\n-         *\n-         * @param cc the copy context\n-         * @param op the operation\n-         * @return the operation's content.\n-         *\/\n-        public static ExternalizedOp externalizeOp(CopyContext cc, Op op) {\n-            return new ExternalizedOp(\n-                    op.opName(),\n-                    cc.getValues(op.operands()),\n-                    op.successors().stream().map(cc::getSuccessorOrCreate).toList(),\n-                    op.resultType(),\n-                    op instanceof ExternalizableOp exop ? exop.attributes() : Map.of(),\n-                    op.bodies().stream().map(b -> b.copy(cc)).toList()\n-            );\n-        }\n-    }\n-\n-    \/**\n-     * The attribute name associated with the location attribute.\n-     *\/\n-    public static final String ATTRIBUTE_LOCATION = \"loc\";\n-\n-    \/**\n-     * The attribute value that represents the external null value.\n-     *\/\n-    public static final Object NULL_ATTRIBUTE_VALUE = new Object();\n-\n-    \/**\n-     * Constructs an operation by copying given operation.\n-     *\n-     * @param that the operation to copy.\n-     * @param cc   the copy context.\n-     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n-     * values computed, in order, by mapping the operation's operands using the copy context.\n-     *\/\n-    protected ExternalizableOp(Op that, CopyContext cc) {\n-        super(that, cc);\n-    }\n-\n-    \/**\n-     * Constructs an operation with a name, operation result type, and list of operands.\n-     *\n-     * @param name     the operation name.\n-     * @param operands the list of operands, a copy of the list is performed if required.\n-     *\/\n-    protected ExternalizableOp(String name, List<? extends Value> operands) {\n-        super(name, operands);\n-    }\n-\n-    \/**\n-     * Constructs an operation from its external content.\n-     *\n-     * @param def the operation's external content.\n-     * @implSpec This implementation invokes the {@link Op#Op(String, List) constructor}\n-     * accepting the non-optional components of the operation's content, {@code name},\n-     * and {@code operands}:\n-     * <pre> {@code\n-     *  this(def.name(), def.operands());\n-     * }<\/pre>\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    protected ExternalizableOp(ExternalizedOp def) {\n-        super(def.name(), def.operands());\n-        setLocation(extractLocation(def));\n-    }\n-\n-    static Location extractLocation(ExternalizedOp def) {\n-        Object v = def.attributes().get(ATTRIBUTE_LOCATION);\n-        return switch (v) {\n-            case String s -> Location.fromString(s);\n-            case Location loc -> loc;\n-            case null -> null;\n-            default -> throw new UnsupportedOperationException(\"Unsupported location value:\" + v);\n-        };\n-    }\n-\n-    \/**\n-     * Externalizes the operation's specific content as a map of attributes.\n-     *\n-     * <p>A null attribute value is represented by the constant\n-     * value {@link #NULL_ATTRIBUTE_VALUE}.\n-     *\n-     * @return the operation's attributes, as an unmodifiable map\n-     *\/\n-    public Map<String, Object> attributes() {\n-        Location l = location();\n-        return l == null ? Map.of() : Map.of(ATTRIBUTE_LOCATION, l);\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/ExternalizableOp.java","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-package jdk.incubator.code.extern;\n-\n-import jdk.incubator.code.TypeElement;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * A type element that supports externalization of its content and reconstruction\n- * via an instance of {@link ExternalizedTypeElement}.\n- *\/\n-public interface ExternalizableTypeElement extends TypeElement {\n-\n-    \/**\n-     * A type element's externalized content in structured symbolic form.\n-     * <p>\n-     * A {@link TypeElement type element} can be constructed from an externalized type element\n-     * using a {@link TypeElementFactory}.\n-     *\n-     * @param identifier the externalized type's identifier\n-     * @param arguments  the externalized type's arguments\n-     *\/\n-    record ExternalizedTypeElement(String identifier, List<ExternalizedTypeElement> arguments) {\n-\n-        public ExternalizedTypeElement {\n-            arguments = List.copyOf(arguments);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return toString(this);\n-        }\n-\n-        static String toString(ExternalizedTypeElement t) {\n-            if (t.arguments.isEmpty()) {\n-                return t.identifier;\n-            }\n-\n-            StringBuilder s = new StringBuilder();\n-            s.append(t.identifier);\n-            if (!t.arguments.isEmpty()) {\n-                String args = t.arguments.stream()\n-                        .map(Object::toString)\n-                        .collect(Collectors.joining(\", \", \"<\", \">\"));\n-                s.append(args);\n-            }\n-\n-            return s.toString();\n-        }\n-\n-        \/\/ Factories\n-\n-        public static ExternalizedTypeElement of(String s) {\n-            return new ExternalizedTypeElement(s, List.of());\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a) {\n-            return new ExternalizedTypeElement(s, List.of(a));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2) {\n-            return new ExternalizedTypeElement(s, List.of(a1, a2));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n-                                                 ExternalizedTypeElement a3) {\n-            return new ExternalizedTypeElement(s, List.of(a1, a2, a3));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n-                                                 ExternalizedTypeElement a3, ExternalizedTypeElement a4) {\n-            return new ExternalizedTypeElement(s, List.of(a1, a2, a3, a4));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement... arguments) {\n-            return new ExternalizedTypeElement(s, List.of(arguments));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 List<ExternalizedTypeElement> arguments) {\n-            return new ExternalizedTypeElement(s, arguments);\n-        }\n-\n-        \/**\n-         * Parses a string as an externalized type element.\n-         * <p>\n-         * For any given externalized type element, {@code te}, the following\n-         * expression returns {@code true}.\n-         * {@snippet lang = java:\n-         * te.equals(ExternalizableTypeElement.ExternalizedTypeElement.ofString(te.toString()));\n-         *}\n-         * @param s the string\n-         * @return the externalized code type.\n-         *\/\n-        public static ExternalizedTypeElement ofString(String s) {\n-            return jdk.incubator.code.extern.impl.DescParser.parseExTypeElem(s);\n-        }\n-    }\n-\n-    \/**\n-     * Externalizes this type element's content.\n-     *\n-     * @return the type element's content.\n-     *\/\n-    ExternalizedTypeElement externalize();\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/ExternalizableTypeElement.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -0,0 +1,97 @@\n+package jdk.incubator.code.extern;\n+\n+import jdk.incubator.code.*;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * An operation's externalized state (a record) that can be utilized to construct an instance\n+ * of an {@link Op} associated with that state, such as the operation's name.\n+ *\n+ * @param name            the operation name\n+ * @param location        the source location associated with the operation, may be null\n+ * @param operands        the list of operands\n+ * @param successors      the list of successors\n+ * @param resultType      the operation result type\n+ * @param attributes      the operation's specific state as a map of attributes\n+ * @param bodyDefinitions the list of body builders for building the operation's bodies\n+ * @apiNote Deserializers of operations may utilize this record to construct operations,\n+ * thereby separating the specifics of deserializing from construction.\n+ *\/\n+public record ExternalizedOp(String name,\n+                             Location location,\n+                             List<Value> operands,\n+                             List<Block.Reference> successors,\n+                             TypeElement resultType,\n+                             Map<String, Object> attributes,\n+                             List<Body.Builder> bodyDefinitions) {\n+\n+    \/**\n+     * The attribute value that represents the external null value.\n+     *\/\n+    public static final Object NULL_ATTRIBUTE_VALUE = new Object();\n+\n+    public ExternalizedOp {\n+        attributes = Map.copyOf(attributes);\n+    }\n+\n+    \/**\n+     * Gets an attribute value from the attributes map, converts the value by applying it\n+     * to mapping function, and returns the result.\n+     *\n+     * <p>If the attribute is a default attribute then this method first attempts to\n+     * get the attribute whose name is the empty string, otherwise if there is no such\n+     * attribute present or the attribute is not a default attribute then this method\n+     * attempts to get the attribute with the given name.\n+     *\n+     * <p>On successfully obtaining the attribute its value is converted by applying the value\n+     * to the mapping function. A {@code null} value is represented by the value\n+     * {@link ExternalizedOp#NULL_ATTRIBUTE_VALUE}.\n+     *\n+     * <p>If no attribute is present the {@code null} value is applied to the mapping function.\n+     *\n+     * @param name      the attribute name.\n+     * @param isDefault true if the attribute is a default attribute\n+     * @param <T>       the converted attribute value type\n+     * @return the converted attribute value\n+     *\/\n+    public <T> T extractAttributeValue(String name, boolean isDefault, Function<Object, T> mapper) {\n+        Object value = null;\n+        if (isDefault && attributes.containsKey(\"\")) {\n+            value = attributes.get(\"\");\n+            assert value != null;\n+        }\n+\n+        if (value == null && attributes.containsKey(name)) {\n+            value = attributes.get(name);\n+            assert value != null;\n+        }\n+\n+        return mapper.apply(value);\n+    }\n+\n+    \/**\n+     * Externalizes an operation's content.\n+     * <p>\n+     * If the operation is an instanceof {@code ExternalizableOp} then the operation's\n+     * specific content is externalized to an attribute map, otherwise the attribute map\n+     * is empty.\n+     *\n+     * @param cc the copy context\n+     * @param op the operation\n+     * @return the operation's content.\n+     *\/\n+    public static ExternalizedOp externalizeOp(CopyContext cc, Op op) {\n+        return new ExternalizedOp(\n+                op.opName(),\n+                op.location(),\n+                cc.getValues(op.operands()),\n+                op.successors().stream().map(cc::getSuccessorOrCreate).toList(),\n+                op.resultType(),\n+                op.externalize(),\n+                op.bodies().stream().map(b -> b.copy(cc)).toList()\n+        );\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/ExternalizedOp.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+package jdk.incubator.code.extern;\n+\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A type element's externalized content in structured symbolic form.\n+ * <p>\n+ * A {@link TypeElement type element} can be constructed from an externalized type element\n+ * using a {@link TypeElementFactory}.\n+ *\n+ * @param identifier the externalized type's identifier\n+ * @param arguments  the externalized type's arguments\n+ *\/\n+public record ExternalizedTypeElement(String identifier, List<ExternalizedTypeElement> arguments) {\n+\n+    public ExternalizedTypeElement {\n+        arguments = List.copyOf(arguments);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(this);\n+    }\n+\n+    static String toString(ExternalizedTypeElement t) {\n+        if (t.arguments.isEmpty()) {\n+            return t.identifier;\n+        }\n+\n+        StringBuilder s = new StringBuilder();\n+        s.append(t.identifier);\n+        if (!t.arguments.isEmpty()) {\n+            String args = t.arguments.stream()\n+                    .map(Object::toString)\n+                    .collect(Collectors.joining(\", \", \"<\", \">\"));\n+            s.append(args);\n+        }\n+\n+        return s.toString();\n+    }\n+\n+    \/\/ Factories\n+\n+    public static ExternalizedTypeElement of(String s) {\n+        return new ExternalizedTypeElement(s, List.of());\n+    }\n+\n+    public static ExternalizedTypeElement of(String s,\n+                                             ExternalizedTypeElement a) {\n+        return new ExternalizedTypeElement(s, List.of(a));\n+    }\n+\n+    public static ExternalizedTypeElement of(String s,\n+                                             ExternalizedTypeElement a1, ExternalizedTypeElement a2) {\n+        return new ExternalizedTypeElement(s, List.of(a1, a2));\n+    }\n+\n+    public static ExternalizedTypeElement of(String s,\n+                                             ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n+                                             ExternalizedTypeElement a3) {\n+        return new ExternalizedTypeElement(s, List.of(a1, a2, a3));\n+    }\n+\n+    public static ExternalizedTypeElement of(String s,\n+                                             ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n+                                             ExternalizedTypeElement a3, ExternalizedTypeElement a4) {\n+        return new ExternalizedTypeElement(s, List.of(a1, a2, a3, a4));\n+    }\n+\n+    public static ExternalizedTypeElement of(String s,\n+                                             ExternalizedTypeElement... arguments) {\n+        return new ExternalizedTypeElement(s, List.of(arguments));\n+    }\n+\n+    public static ExternalizedTypeElement of(String s,\n+                                             List<ExternalizedTypeElement> arguments) {\n+        return new ExternalizedTypeElement(s, arguments);\n+    }\n+\n+    \/**\n+     * Parses a string as an externalized type element.\n+     * <p>\n+     * For any given externalized type element, {@code te}, the following\n+     * expression returns {@code true}.\n+     * {@snippet lang = java:\n+     * te.equals(ExternalizedTypeElement.ofString(te.toString()));\n+     * }\n+     *\n+     * @param s the string\n+     * @return the externalized code type.\n+     *\/\n+    public static ExternalizedTypeElement ofString(String s) {\n+        return jdk.incubator.code.extern.impl.DescParser.parseExTypeElem(s);\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/ExternalizedTypeElement.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    static final JavaType J_C_O_EXTERNALIZED_OP = type(ExternalizableOp.ExternalizedOp.class);\n+    static final JavaType J_C_E_EXTERNALIZED_OP = type(ExternalizedOp.class);\n@@ -59,1 +59,1 @@\n-            Op.class, ExternalizableOp.ExternalizedOp.class);\n+            Op.class, ExternalizedOp.class);\n@@ -111,0 +111,5 @@\n+    static final JavaType J_C_LOCATION = type(Location.class);\n+\n+    static final MethodRef LOCATION_FROM_STRING = MethodRef.method(J_C_LOCATION, \"fromString\",\n+            J_C_LOCATION, J_L_STRING);\n+\n@@ -112,1 +117,1 @@\n-            J_C_O_EXTERNALIZED_OP,\n+            J_C_E_EXTERNALIZED_OP,\n@@ -114,0 +119,1 @@\n+            J_C_LOCATION,\n@@ -210,0 +216,1 @@\n+                inputOp,\n@@ -211,0 +218,1 @@\n+                inputOp.location(),\n@@ -214,1 +222,1 @@\n-                inputOp instanceof ExternalizableOp exop ? exop.attributes() : Map.of(),\n+                inputOp.externalize(),\n@@ -220,1 +228,3 @@\n-    Value buildOpDefinition(String name,\n+    Value buildOpDefinition(Op inputOp,\n+                            String name,\n+                            Location location,\n@@ -228,0 +238,1 @@\n+                buildLocation(location),\n@@ -231,1 +242,1 @@\n-                buildAttributeMap(attributes),\n+                buildAttributeMap(inputOp, attributes),\n@@ -236,0 +247,9 @@\n+    Value buildLocation(Location l) {\n+        if (l == null) {\n+            return builder.op(constant(J_C_LOCATION, null));\n+        } else {\n+            return builder.op(invoke(LOCATION_FROM_STRING,\n+                    builder.op(constant(J_L_STRING, l.toString()))));\n+        }\n+    }\n+\n@@ -311,1 +331,1 @@\n-    Value buildAttributeMap(Map<String, Object> attributes) {\n+    Value buildAttributeMap(Op inputOp, Map<String, Object> attributes) {\n@@ -357,4 +377,0 @@\n-            case Location l -> {\n-                \/\/ @@@ Construct location explicitly\n-                yield builder.op(constant(J_L_STRING, l.toString()));\n-            }\n@@ -365,2 +381,2 @@\n-            case Object o when value == ExternalizableOp.NULL_ATTRIBUTE_VALUE -> {\n-                yield builder.op(fieldLoad(FieldRef.field(ExternalizableOp.class,\n+            case Object o when value == ExternalizedOp.NULL_ATTRIBUTE_VALUE -> {\n+                yield builder.op(fieldLoad(FieldRef.field(ExternalizedOp.class,\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpBuilder.java","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * {@link ExternalizableOp.ExternalizedOp external content}.\n+ * {@link ExternalizedOp external content}.\n@@ -71,1 +71,1 @@\n-     * with one parameter type of {@link ExternalizableOp.ExternalizedOp} and return type that is the concrete class type.\n+     * with one parameter type of {@link ExternalizedOp} and return type that is the concrete class type.\n@@ -73,1 +73,1 @@\n-     * {@link ExternalizableOp.ExternalizedOp}.\n+     * {@link ExternalizedOp}.\n@@ -87,1 +87,6 @@\n-                return constructOp(opClass, def);\n+                Op op = constructOp(opClass, def);\n+                \/\/ Set location if available\n+                if (op != null && def.location() != null) {\n+                    op.setLocation(def.location());\n+                }\n+                return op;\n@@ -101,1 +106,1 @@\n-    Op constructOp(ExternalizableOp.ExternalizedOp def);\n+    Op constructOp(ExternalizedOp def);\n@@ -114,1 +119,1 @@\n-    default Op constructOpOrFail(ExternalizableOp.ExternalizedOp def) {\n+    default Op constructOpOrFail(ExternalizedOp def) {\n@@ -172,1 +177,1 @@\n-            method = opClass.getMethod(\"create\", ExternalizableOp.ExternalizedOp.class);\n+            method = opClass.getMethod(\"create\", ExternalizedOp.class);\n@@ -191,1 +196,1 @@\n-            constructor = opClass.getConstructor(ExternalizableOp.ExternalizedOp.class);\n+            constructor = opClass.getConstructor(ExternalizedOp.class);\n@@ -204,1 +209,1 @@\n-    private static Op constructOp(Class<? extends Op> opClass, ExternalizableOp.ExternalizedOp opDef) {\n+    private static Op constructOp(Class<? extends Op> opClass, ExternalizedOp opDef) {\n@@ -206,1 +211,1 @@\n-            private static final ClassValue<Function<ExternalizableOp.ExternalizedOp, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n+            private static final ClassValue<Function<ExternalizedOp, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n@@ -208,1 +213,1 @@\n-                protected Function<ExternalizableOp.ExternalizedOp, Op> computeValue(Class<?> opClass) {\n+                protected Function<ExternalizedOp, Op> computeValue(Class<?> opClass) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpFactory.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement.*;\n@@ -257,1 +256,1 @@\n-        ExternalizableOp.ExternalizedOp opdef = nodeToOpDef(opNode, rtype, c, ancestorBody);\n+        ExternalizedOp opdef = nodeToOpDef(opNode, rtype, c, ancestorBody);\n@@ -261,1 +260,1 @@\n-    static ExternalizableOp.ExternalizedOp nodeToOpDef(OpNode opNode, ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n+    static ExternalizedOp nodeToOpDef(OpNode opNode, ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n@@ -268,1 +267,12 @@\n-        return new ExternalizableOp.ExternalizedOp(operationName,\n+        Location location = null;\n+        if (!opNode.attributes.isEmpty()) {\n+            Object v = opNode.attributes.remove(OpWriter.ATTRIBUTE_LOCATION);\n+            location = switch (v) {\n+                case String s -> Location.fromString(s);\n+                case Location loc -> loc;\n+                case null -> null;\n+                default -> throw new UnsupportedOperationException(\"Unsupported location value:\" + v);\n+            };\n+        }\n+        return new ExternalizedOp(operationName,\n+                location,\n@@ -477,1 +487,1 @@\n-            case NULL -> ExternalizableOp.NULL_ATTRIBUTE_VALUE;\n+            case NULL -> ExternalizedOp.NULL_ATTRIBUTE_VALUE;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpParser.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -49,0 +49,5 @@\n+    \/**\n+     * The attribute name associated with the location attribute.\n+     *\/\n+    static final String ATTRIBUTE_LOCATION = \"loc\";\n+\n@@ -74,1 +79,1 @@\n-            if (value == ExternalizableOp.NULL_ATTRIBUTE_VALUE) {\n+            if (value == ExternalizedOp.NULL_ATTRIBUTE_VALUE) {\n@@ -443,5 +448,6 @@\n-        Map<String, Object> attributes = op instanceof ExternalizableOp exop ? exop.attributes() : Map.of();\n-        if (dropLocation && !attributes.isEmpty() &&\n-                attributes.containsKey(ExternalizableOp.ATTRIBUTE_LOCATION)) {\n-            attributes = new HashMap<>(attributes);\n-            attributes.remove(ExternalizableOp.ATTRIBUTE_LOCATION);\n+        if (!dropLocation) {\n+            Location location = op.location();\n+            if (location != null) {\n+                write(\" \");\n+                writeAttribute(ATTRIBUTE_LOCATION, op.location());\n+            }\n@@ -449,0 +455,1 @@\n+        Map<String, Object> attributes = op.externalize();\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/OpWriter.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * {@link ExternalizableTypeElement.ExternalizedTypeElement external content}.\n+ * {@link ExternalizedTypeElement external content}.\n@@ -14,1 +14,1 @@\n-     * {@link ExternalizableTypeElement.ExternalizedTypeElement external content}.\n+     * {@link ExternalizedTypeElement external content}.\n@@ -22,1 +22,1 @@\n-    TypeElement constructType(ExternalizableTypeElement.ExternalizedTypeElement tree);\n+    TypeElement constructType(ExternalizedTypeElement tree);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/TypeElementFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -42,1 +42,1 @@\n-    public static ExternalizableTypeElement.ExternalizedTypeElement parseExTypeElem(String desc) {\n+    public static ExternalizedTypeElement parseExTypeElem(String desc) {\n@@ -63,1 +63,1 @@\n-    public static ExternalizableTypeElement.ExternalizedTypeElement parseExTypeElem(Lexer l) {\n+    public static ExternalizedTypeElement parseExTypeElem(Lexer l) {\n@@ -71,1 +71,1 @@\n-        List<ExternalizableTypeElement.ExternalizedTypeElement> args = new ArrayList<>();\n+        List<ExternalizedTypeElement> args = new ArrayList<>();\n@@ -81,1 +81,1 @@\n-        return new ExternalizableTypeElement.ExternalizedTypeElement(identifier.toString(), args);\n+        return new ExternalizedTypeElement(identifier.toString(), args);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/extern\/impl\/DescParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -37,1 +38,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n@@ -64,1 +64,1 @@\n-        ExternalizableOp.ExternalizedOp odef = ExternalizableOp.ExternalizedOp.externalizeOp(CopyContext.create(), f);\n+        ExternalizedOp odef = ExternalizedOp.externalizeOp(CopyContext.create(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n@@ -29,0 +28,2 @@\n+import jdk.incubator.code.extern.ExternalizedOp;\n+\n@@ -40,1 +41,1 @@\n-    public static final class AnfLetOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+    public static final class AnfLetOp extends Op implements Op.Terminating, Op.Nested {\n@@ -65,3 +66,1 @@\n-            super(def);\n-\n-            this.bindings = def.bodyDefinitions().get(0).build(this);\n+            this(def.bodyDefinitions().get(0));\n@@ -100,1 +99,1 @@\n-    public static final class AnfLetRecOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+    public static final class AnfLetRecOp extends Op implements Op.Terminating, Op.Nested {\n@@ -125,3 +124,1 @@\n-            super(def);\n-\n-            this.bindings = def.bodyDefinitions().get(0).build(this);\n+            this(def.bodyDefinitions().get(0));\n@@ -169,1 +166,1 @@\n-    public static final class AnfIfOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+    public static final class AnfIfOp extends Op implements Op.Terminating, Op.Nested {\n@@ -212,5 +209,4 @@\n-        public AnfIfOp(ExternalizableOp.ExternalizedOp def) {\n-            super(def);\n-\n-            this.then_ = def.bodyDefinitions().get(0).build(this);\n-            this.else_ = def.bodyDefinitions().get(1).build(this);\n+        public AnfIfOp(ExternalizedOp def) {\n+            this(def.operands().getFirst(),\n+                    def.bodyDefinitions().get(0),\n+                    def.bodyDefinitions().get(1));\n@@ -262,1 +258,1 @@\n-    public static final class AnfFuncOp extends ExternalizableOp implements Op.Nested {\n+    public static final class AnfFuncOp extends Op implements Op.Nested {\n@@ -298,8 +294,1 @@\n-            return new AnfFuncOp(def, funcName);\n-        }\n-\n-        AnfFuncOp(ExternalizedOp def, String funcName) {\n-            super(def);\n-\n-            this.funcName = funcName;\n-            this.body = def.bodyDefinitions().get(0).build(this);\n+            return new AnfFuncOp(funcName, def.bodyDefinitions().get(0));\n@@ -338,4 +327,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", funcName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", funcName);\n@@ -363,1 +350,1 @@\n-    public static final class AnfApply extends ExternalizableOp implements Op.Terminating {\n+    public static final class AnfApply extends Op implements Op.Terminating {\n@@ -367,1 +354,1 @@\n-            super(def);\n+            this(def.operands());\n@@ -399,1 +386,1 @@\n-    public static final class AnfApplyStub extends ExternalizableOp implements Op.Terminating {\n+    public static final class AnfApplyStub extends Op implements Op.Terminating {\n@@ -417,7 +404,1 @@\n-            return new AnfApplyStub(def,callsiteName,def.resultType());\n-        }\n-\n-        public AnfApplyStub(ExternalizedOp def, String name, TypeElement resultType) {\n-            super(def);\n-            this.resultType = resultType;\n-            this.callSiteName = name;\n+            return new AnfApplyStub(callsiteName, def.operands(), def.resultType());\n@@ -433,4 +414,2 @@\n-        public Map<String, Object> attributes() {\n-            HashMap<String, Object> m = new HashMap<>(super.attributes());\n-            m.put(\"\", callSiteName);\n-            return Collections.unmodifiableMap(m);\n+        public Map<String, Object> externalize() {\n+            return Map.of(\"\", callSiteName);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/AnfDialect.java","additions":21,"deletions":42,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import jdk.incubator.code.extern.ExternalizableTypeElement;\n@@ -27,0 +26,1 @@\n+import jdk.incubator.code.extern.ExternalizedTypeElement;\n@@ -84,1 +84,1 @@\n-        ExternalizableTypeElement.ExternalizedTypeElement emr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(mds);\n+        ExternalizedTypeElement emr = ExternalizedTypeElement.ofString(mds);\n@@ -117,1 +117,1 @@\n-        ExternalizableTypeElement.ExternalizedTypeElement ecr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(crs);\n+        ExternalizedTypeElement ecr = ExternalizedTypeElement.ofString(crs);\n@@ -156,1 +156,1 @@\n-        ExternalizableTypeElement.ExternalizedTypeElement efr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(frs);\n+        ExternalizedTypeElement efr = ExternalizedTypeElement.ofString(frs);\n@@ -196,1 +196,1 @@\n-        ExternalizableTypeElement.ExternalizedTypeElement ertr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(rtds);\n+        ExternalizedTypeElement ertr = ExternalizedTypeElement.ofString(rtds);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.code.extern.ExternalizableOp;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.code.extern.ExternalizedOp;\n@@ -42,1 +42,1 @@\n-    static class TestOp extends ExternalizableOp {\n+    static class TestOp extends Op {\n@@ -46,2 +46,1 @@\n-            super(opdef);\n-            this.attributeValue = null;\n+            this((Object) null);\n@@ -71,1 +70,1 @@\n-        public Map<String, Object> attributes() {\n+        public Map<String, Object> externalize() {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestAttributeSerialization.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}