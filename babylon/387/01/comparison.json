{"files":[{"patch":"@@ -17,1 +17,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -31,0 +30,1 @@\n+    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n@@ -119,1 +119,1 @@\n-        var meth = receiver == null ? treeMaker.Ident(methodSym) : treeMaker.Select((JCTree.JCExpression) valueToTree.get(receiver), methodSym);\n+        var meth = receiver == null ? treeMaker.Ident(methodSym) : treeMaker.Select(exprTree(receiver), methodSym);\n@@ -122,1 +122,1 @@\n-            args.add((JCTree.JCExpression) valueToTree.get(operand));\n+            args.add(exprTree(operand));\n@@ -130,3 +130,0 @@\n-        if (invokeOp.result().uses().isEmpty()) {\n-            return treeMaker.Exec(methodInvocation);\n-        }\n@@ -147,1 +144,1 @@\n-                        dims.add(((JCTree.JCExpression) valueToTree.get(newOp.operands().get(d))));\n+                        dims.add(exprTree(newOp.operands().get(d)));\n@@ -157,1 +154,1 @@\n-                    args.add((JCTree.JCExpression) valueToTree.get(operand));\n+                    args.add(exprTree(operand));\n@@ -170,12 +167,1 @@\n-                    treeMaker.Return((JCTree.JCExpression) valueToTree.get(returnOp.returnValue()));\n-            case CoreOp.VarOp varOp when varOp.initOperand() instanceof Block.Parameter p -> valueToTree.get(p);\n-            case CoreOp.VarOp varOp -> {\n-                var name = names.fromString(varOp.varName());\n-                var type = typeElementToType(varOp.varValueType());\n-                var v = new Symbol.VarSymbol(LocalVarFlags, name, type, ms);\n-                yield treeMaker.VarDef(v, (JCTree.JCExpression) valueToTree.get(varOp.initOperand()));\n-            }\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                    when varLoadOp.varOp().initOperand() instanceof Block.Parameter p2 -> valueToTree.get(p2);\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->\n-                    treeMaker.Ident((JCTree.JCVariableDecl) valueToTree.get(varLoadOp.varOperand()));\n+                    treeMaker.Return(exprTree(returnOp.returnValue()));\n@@ -202,2 +188,1 @@\n-                        treeMaker.Indexed((JCTree.JCExpression) valueToTree.get(array), (JCTree.JCExpression) valueToTree.get(index)),\n-                        (JCTree.JCExpression) valueToTree.get(val)\n+                        treeMaker.Indexed(exprTree(array), exprTree(index)), exprTree(val)\n@@ -205,1 +190,2 @@\n-                yield treeMaker.Exec(as);\n+                as.type = typeElementToType(((ArrayType) array.type()).componentType());\n+                yield as;\n@@ -210,2 +196,34 @@\n-        valueToTree.put(op.result(), tree);\n-        return tree;\n+        if (tree instanceof JCTree.JCExpression expr) {\n+            \/\/ introduce a local variable to hold the expr, to make sure an op's tree is inserted right away\n+            \/\/ for some operations this is essential, e.g. to ensure the correct order of operations\n+            Type type;\n+            if (op instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n+                \/\/ if ConstantOp value is null, tree.type will be null_type\n+                \/\/ if null_type is used to create a VarSymbol, an exception will be thrown\n+                type = typeElementToType(cop.resultType());\n+            } else {\n+                type = tree.type;\n+            }\n+            var vs = new Symbol.VarSymbol(LocalVarFlags, names.fromString(\"_$\" + localVarCount++), type, ms);\n+            var varDef = treeMaker.VarDef(vs, expr);\n+            map(op.result(), varDef);\n+            return varDef;\n+        } else {\n+            return tree;\n+        }\n+    }\n+\n+    private JCTree.JCExpression exprTree(Value v) {\n+        JCTree tree = valueToTree.get(v);\n+        if (tree instanceof JCTree.JCVariableDecl vd) {\n+            return treeMaker.Ident(vd);\n+        } else if (tree instanceof JCTree.JCExpressionStatement exprStat) {\n+            return exprStat.expr;\n+        } else if (tree instanceof JCTree.JCExpression expr) {\n+            return expr;\n+        }\n+        throw new IllegalStateException(\"Value not mapped to VariableDeclaration nor to an ExpressionStatement\");\n+    }\n+\n+    private void map(Value v, JCTree t) {\n+        valueToTree.put(v, t);\n@@ -222,3 +240,0 @@\n-        \/\/ TODO add VarOps in OpBuilder\n-        funcOp = addVarsWhenNecessary(funcOp);\n-        funcOp.writeTo(System.out);\n@@ -226,1 +241,1 @@\n-            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n+            map(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n@@ -241,43 +256,0 @@\n-    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n-        \/\/ using cc only is not possible\n-        \/\/ because at first opr --> varOpRes\n-        \/\/ at the first usage we would have to opr --> varLoad\n-        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n-\n-        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n-        AtomicInteger varCounter = new AtomicInteger();\n-\n-        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n-            var newParams = block.parameters();\n-            var oldParams = funcOp.parameters();\n-            for (int i = 0; i < newParams.size(); i++) {\n-                Op.Result var = block.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), newParams.get(i)));\n-                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n-            }\n-\n-            block.transformBody(funcOp.body(), java.util.List.of(), (Block.Builder b, Op op) -> {\n-                var cc = b.context();\n-                for (Value operand : op.operands()) {\n-                    if (valueToVar.containsKey(operand)) {\n-                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n-                        cc.mapValue(operand, varLoadRes);\n-                    }\n-                }\n-                var opr = b.op(op);\n-                var M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\", Op.Result.class, Op.class);\n-                var M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\", Block.Parameter.class, TypeElement.class);\n-                \/\/ we introduce VarOp to hold an opr that's used multiple times\n-                \/\/ or to mark that an InvokeOp must be mapped to a Statement\n-                \/\/ specifically call to Bloc.Builder#op, we want this call to map to a statement so that it get added\n-                \/\/ to the opMethod body immediately to ensure correct order of operations\n-                var isBlockOpInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_OP.equals(invokeOp.invokeDescriptor());\n-                var isBlockParamInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_PARAM.equals(invokeOp.invokeDescriptor());\n-                if (!(op instanceof CoreOp.VarOp) && (op.result().uses().size() > 1 || isBlockOpInvocation || isBlockParamInvocation)) {\n-                    var varOpRes = b.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), opr));\n-                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n-                }\n-                return b;\n-            });\n-        });\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":44,"deletions":72,"binary":false,"changes":116,"status":"modified"}]}