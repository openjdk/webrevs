{"files":[{"patch":"@@ -20,1 +20,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -34,1 +33,1 @@\n-    private final Map<Value, JCTree> valueToTree = new HashMap<>();\n+    private final Map<Value, Symbol.VarSymbol> valueToVarSym = new HashMap<>();\n@@ -37,0 +36,1 @@\n+    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n@@ -121,1 +121,1 @@\n-                treeMaker.Select((JCTree.JCExpression) valueToTree.get(receiver), methodSym);\n+                treeMaker.Select(exprTree(receiver), methodSym);\n@@ -124,1 +124,1 @@\n-            args.add((JCTree.JCExpression) valueToTree.get(operand));\n+            args.add(exprTree(operand));\n@@ -135,3 +135,0 @@\n-        if (invokeOp.result().uses().isEmpty()) {\n-            return treeMaker.Exec(methodInvocation);\n-        }\n@@ -152,1 +149,1 @@\n-                        dims.add(((JCTree.JCExpression) valueToTree.get(newOp.operands().get(d))));\n+                        dims.add(exprTree(newOp.operands().get(d)));\n@@ -162,1 +159,1 @@\n-                    args.add((JCTree.JCExpression) valueToTree.get(operand));\n+                    args.add(exprTree(operand));\n@@ -176,12 +173,1 @@\n-                    treeMaker.Return((JCTree.JCExpression) valueToTree.get(returnOp.returnValue()));\n-            case CoreOp.VarOp varOp when varOp.initOperand() instanceof Block.Parameter p -> valueToTree.get(p);\n-            case CoreOp.VarOp varOp -> {\n-                var name = names.fromString(varOp.varName());\n-                var type = typeElementToType(varOp.varValueType());\n-                var v = new Symbol.VarSymbol(LocalVarFlags, name, type, ms);\n-                yield treeMaker.VarDef(v, (JCTree.JCExpression) valueToTree.get(varOp.initOperand()));\n-            }\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                    when varLoadOp.varOp().initOperand() instanceof Block.Parameter p2 -> valueToTree.get(p2);\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->\n-                    treeMaker.Ident((JCTree.JCVariableDecl) valueToTree.get(varLoadOp.varOperand()));\n+                    treeMaker.Return(exprTree(returnOp.returnValue()));\n@@ -198,3 +184,1 @@\n-                        treeMaker.Indexed((JCTree.JCExpression) valueToTree.get(array),\n-                                (JCTree.JCExpression) valueToTree.get(index)),\n-                                (JCTree.JCExpression) valueToTree.get(val)\n+                        treeMaker.Indexed(exprTree(array), exprTree(index)), exprTree(val)\n@@ -202,2 +186,2 @@\n-                yield treeMaker.Exec(as);\n-                \/\/ body builder are created but never passed when creating the op, why ?\n+                as.type = typeElementToType(((ArrayType) array.type()).componentType());\n+                yield as;\n@@ -207,2 +191,26 @@\n-        valueToTree.put(op.result(), tree);\n-        return tree;\n+        if (tree instanceof JCTree.JCExpression expr) {\n+            \/\/ introduce a local variable to hold the expr, to make sure an op's tree is inserted right away\n+            \/\/ for some operations this is essential, e.g. to ensure the correct order of operations\n+            Type type;\n+            if (op instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n+                \/\/ if ConstantOp value is null, tree.type will be null_type\n+                \/\/ if null_type is used to create a VarSymbol, an exception will be thrown\n+                type = typeElementToType(cop.resultType());\n+            } else {\n+                type = tree.type;\n+            }\n+            var vs = new Symbol.VarSymbol(LocalVarFlags, names.fromString(\"_$\" + localVarCount++), type, ms);\n+            var varDef = treeMaker.VarDef(vs, expr);\n+            map(op.result(), vs);\n+            return varDef;\n+        } else {\n+            return tree;\n+        }\n+    }\n+\n+    private JCTree.JCExpression exprTree(Value v) {\n+        return treeMaker.Ident(valueToVarSym.get(v));\n+    }\n+\n+    private void map(Value v, Symbol.VarSymbol vs) {\n+        valueToVarSym.put(v, vs);\n@@ -219,3 +227,0 @@\n-        \/\/ TODO add VarOps in OpBuilder\n-        funcOp = addVarsWhenNecessary(funcOp);\n-        funcOp.writeTo(System.out);\n@@ -223,1 +228,1 @@\n-            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n+            map(funcOp.parameters().get(i), ms.params().get(i));\n@@ -238,43 +243,0 @@\n-    public static CoreOp.FuncOp addVarsWhenNecessary(CoreOp.FuncOp funcOp) {\n-        \/\/ using cc only is not possible\n-        \/\/ because at first opr --> varOpRes\n-        \/\/ at the first usage we would have to opr --> varLoad\n-        \/\/ meaning we would have to back up the mapping, update it, then restore it before transforming the next op\n-\n-        Map<Value, CoreOp.VarOp> valueToVar = new HashMap<>();\n-        AtomicInteger varCounter = new AtomicInteger();\n-\n-        return CoreOp.func(funcOp.funcName(), funcOp.body().bodyType()).body(block -> {\n-            var newParams = block.parameters();\n-            var oldParams = funcOp.parameters();\n-            for (int i = 0; i < newParams.size(); i++) {\n-                Op.Result var = block.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), newParams.get(i)));\n-                valueToVar.put(oldParams.get(i), ((CoreOp.VarOp) var.op()));\n-            }\n-\n-            block.transformBody(funcOp.body(), java.util.List.of(), (Block.Builder b, Op op) -> {\n-                var cc = b.context();\n-                for (Value operand : op.operands()) {\n-                    if (valueToVar.containsKey(operand)) {\n-                        var varLoadRes = b.op(CoreOp.varLoad(valueToVar.get(operand).result()));\n-                        cc.mapValue(operand, varLoadRes);\n-                    }\n-                }\n-                var opr = b.op(op);\n-                var M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\", Op.Result.class, Op.class);\n-                var M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\", Block.Parameter.class, TypeElement.class);\n-                \/\/ we introduce VarOp to hold an opr that's used multiple times\n-                \/\/ or to mark that an InvokeOp must be mapped to a Statement\n-                \/\/ specifically call to Bloc.Builder#op, we want this call to map to a statement so that it get added\n-                \/\/ to the opMethod body immediately to ensure correct order of operations\n-                var isBlockOpInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_OP.equals(invokeOp.invokeDescriptor());\n-                var isBlockParamInvocation = op instanceof CoreOp.InvokeOp invokeOp && M_BLOCK_BUILDER_PARAM.equals(invokeOp.invokeDescriptor());\n-                if (!(op instanceof CoreOp.VarOp) && (op.result().uses().size() > 1 || isBlockOpInvocation || isBlockParamInvocation)) {\n-                    var varOpRes = b.op(CoreOp.var(\"_$\" + varCounter.getAndIncrement(), opr));\n-                    valueToVar.put(op.result(), ((CoreOp.VarOp) varOpRes.op()));\n-                }\n-                return b;\n-            });\n-        });\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":37,"deletions":75,"binary":false,"changes":112,"status":"modified"}]}