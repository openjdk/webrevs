{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.classfile.Label;\n@@ -89,2 +90,2 @@\n-    private static final String quotedInstanceFieldName = \"quoted\";\n-    private static final String COMPILER_GENERATED_MODEL_FIELD_NAME = \"COMPILER_GENERATED_MODEL\";\n+    private static final String QUOTED_FIELD_NAME = \"quoted\";\n+    private static final String MODEL_FIELD_NAME = \"model\";\n@@ -336,1 +337,0 @@\n-                \/\/ if quotable, generate the field that will hold the value of quoted\n@@ -338,1 +338,5 @@\n-                    clb.withField(quotedInstanceFieldName, reflectableLambdaInfo.quotedClass(), ACC_PRIVATE + ACC_FINAL);\n+                    \/\/ the field that will hold the quoted instance\n+                    clb.withField(QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass(), ACC_PRIVATE);\n+                    \/\/ the field that will hold the model\n+                    clb.withField(MODEL_FIELD_NAME, reflectableLambdaInfo.funcOpClass(),\n+                            ACC_PRIVATE | ACC_STATIC);\n@@ -409,25 +413,0 @@\n-\n-                if (reflectableLambdaInfo != null) {\n-                    \/\/ if we visit a callsite twice, we will use the same class\n-                    \/\/ if the lambda doesn't capture values we only have one instance, model shared anyway\n-                    \/\/ if it captures values, each visit result in a creation of new instance of the class\n-                    \/\/ those instances have the same code model generated by the compiler\n-                    \/\/ they may differ in captured values\n-                    \/\/ as first step let's share the compiler generated code model\n-                    ClassDesc funcOpClassDesc = reflectableLambdaInfo.funcOpClass();\n-                    clb.withField(COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc,\n-                            ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-\n-                    ConstantPoolBuilder cp = pool;\n-                    MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n-                    NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n-                    \/\/ load quotableOpGetter\n-                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n-                    MethodType mtype = quotableOpGetterInfo.getMethodType();\n-                    if (quotableOpGetterInfo.getReferenceKind() != MethodHandleInfo.REF_invokeStatic) {\n-                        mtype = mtype.insertParameterTypes(0, implClass);\n-                    }\n-                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n-                    cob.checkcast(funcOpClassDesc);\n-                    cob.putstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME, funcOpClassDesc);\n-                }\n@@ -456,3 +435,0 @@\n-                        if (reflectableLambdaInfo != null) {\n-                            generateQuotedFieldInitializer(cob);\n-                        }\n@@ -464,33 +440,0 @@\n-    private void generateQuotedFieldInitializer(CodeBuilder cob) {\n-        ConstantPoolBuilder cp = cob.constantPool();\n-        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n-        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n-        \/\/ push the receiver on the stack for operand of put field instruction\n-        cob.aload(0)\n-                \/\/ load class data: CodeReflectionSupport.HANDLE_MAKE_QUOTED\n-                .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n-                .getstatic(lambdaClassEntry.asSymbol(), COMPILER_GENERATED_MODEL_FIELD_NAME,\n-                        reflectableLambdaInfo.funcOpClass());\n-\n-\n-        \/\/ load captured args in array\n-\n-        int capturedArity = factoryType.parameterCount();\n-        cob.loadConstant(capturedArity)\n-           .anewarray(CD_Object);\n-        \/\/ initialize quoted captures\n-        for (int i = 0; i < capturedArity; i++) {\n-            cob.dup()\n-               .loadConstant(i)\n-               .aload(0)\n-               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n-            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n-            cob.aastore();\n-        }\n-\n-        \/\/ Create a Quoted from FuncOp and captured args Object[]\n-\n-        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(reflectableLambdaInfo.extractOpHandle().type()))\n-           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, reflectableLambdaInfo.quotedClass());\n-    }\n-\n@@ -554,1 +497,1 @@\n-    * Generate method #quoted()\n+    * Generate method #__internal_quoted()\n@@ -557,1 +500,1 @@\n-        clb.withMethod(NAME_METHOD_QUOTED, MethodTypeDesc.of(reflectableLambdaInfo.quotedClass()), ACC_PRIVATE + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethod(NAME_METHOD_QUOTED, MethodTypeDesc.of(reflectableLambdaInfo.quotedClass()), ACC_PRIVATE, new MethodBody(new Consumer<CodeBuilder>() {\n@@ -561,2 +504,2 @@\n-                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, reflectableLambdaInfo.quotedClass())\n-                   .areturn();\n+                        .invokevirtual(lambdaClassEntry.asSymbol(), \"getQuoted\", MethodTypeDesc.of(reflectableLambdaInfo.quotedClass()))\n+                        .areturn();\n@@ -565,0 +508,69 @@\n+        \/\/ generate helper methods\n+        clb.withMethod(\"getQuoted\", MethodTypeDesc.of(reflectableLambdaInfo.quotedClass()),\n+                ACC_PRIVATE + ACC_SYNCHRONIZED,\n+                new MethodBody(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        Label nonNull = cob.newLabel();\n+                        cob.aload(0)\n+                                .getfield(lambdaClassEntry.asSymbol(), QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass())\n+                                .ifnonnull(nonNull)\n+                                .aload(0);\/\/ will be used by putfield to store the quoted instance\n+\n+                        \/\/ load class data: MH to Quoted.extractOp\n+                        ConstantPoolBuilder cp = cob.constantPool();\n+                        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH));\n+\n+                        cob.invokestatic(lambdaClassEntry.asSymbol(), \"getModel\", MethodTypeDesc.of(reflectableLambdaInfo.funcOpClass()));\n+\n+                        \/\/ load captured args in array\n+                        int capturedArity = factoryType.parameterCount();\n+                        cob.loadConstant(capturedArity)\n+                                .anewarray(CD_Object);\n+                        for (int i = 0; i < capturedArity; i++) {\n+                            cob.dup()\n+                                    .loadConstant(i)\n+                                    .aload(0)\n+                                    .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+                            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+                            cob.aastore();\n+                        }\n+\n+                        \/\/ Create a Quoted from FuncOp and captured args Object[]\n+                        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(reflectableLambdaInfo.extractOpHandle().type()))\n+                                .putfield(lambdaClassEntry.asSymbol(), QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass());\n+\n+                        cob.labelBinding(nonNull)\n+                                .aload(0)\n+                                .getfield(lambdaClassEntry.asSymbol(), QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass())\n+                                .areturn();\n+                    }\n+                }));\n+\n+        clb.withMethod(\"getModel\", MethodTypeDesc.of(reflectableLambdaInfo.funcOpClass()),\n+                ACC_PRIVATE + ACC_STATIC + ACC_SYNCHRONIZED,\n+                new MethodBody(new Consumer<CodeBuilder>() {\n+                    @Override\n+                    public void accept(CodeBuilder cob) {\n+                        Label nonNull = cob.newLabel();\n+                        cob.getstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, reflectableLambdaInfo.funcOpClass())\n+                                .ifnonnull(nonNull);\n+\n+                        \/\/ load class data: MH to op building method\n+                        ClassDesc funcOpClassDesc = reflectableLambdaInfo.funcOpClass();\n+                        ConstantPoolBuilder cp = pool;\n+                        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+                        MethodType mtype = quotableOpGetterInfo.getMethodType();\n+                        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get())\n+                                .checkcast(funcOpClassDesc)\n+                                .putstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, funcOpClassDesc);\n+\n+                        cob.labelBinding(nonNull)\n+                                .getstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, funcOpClassDesc)\n+                                .areturn();\n+                    }\n+                }));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":81,"deletions":69,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -501,0 +501,2 @@\n+     * @throws UnsupportedOperationException If The Java version used at compile time to generate and store the code model\n+     *                                       is not the same as the Java version used at runtime to load the code model.\n@@ -526,1 +528,5 @@\n-        } catch (InvocationTargetException | IllegalAccessException e) {\n+        } catch (ReflectiveOperationException e) {\n+            \/\/ op method may throw UOE in case java compile time version doesn't match runtime version\n+            if (e.getCause() instanceof UnsupportedOperationException uoe) {\n+                throw uoe;\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @summary test that lambda model generated by the compiler is shared across instances of the same lambda class.\n+ * This property means we only invoke the op building method once per lambda class.\n+ * @modules jdk.incubator.code\n+ * @run junit TestLambdaModelUnique\n+ *\/\n+public class TestLambdaModelUnique {\n+\n+    Runnable f() {\n+        return (@Reflect Runnable) () -> {\n+            System.out.println(\"Running...\");\n+        };\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatDoNotCaptureInSequence() {\n+        Runnable q1 = f();\n+        Runnable q2 = f();\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assertions.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatDoNotCaptureInParallel() { \/\/ parallel\n+        Runnable q1 = f();\n+        Runnable q2 = f();\n+        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n+        Assertions.assertSame(ops.getFirst(), ops.getLast());\n+    }\n+\n+    static IntUnaryOperator g(int i) {\n+        return (@Reflect IntUnaryOperator) j -> j + i;\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatCaptureInSequence() {\n+        IntUnaryOperator q1 = g(1);\n+        IntUnaryOperator q2 = g(2);\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assertions.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatCaptureInParallel() {\n+        IntUnaryOperator q1 = g(1);\n+        IntUnaryOperator q2 = g(2);\n+        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n+        Assertions.assertSame(ops.getFirst(), ops.getLast());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaModelUnique.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestMethodModelUnique\n+ *\/\n+public class TestMethodModelUnique {\n+\n+    @Reflect\n+    static void f() {\n+    }\n+    @Reflect\n+    static void g() {\n+    }\n+\n+    @Test\n+    public void testInstancesReflectSameMethodHaveSameModel() throws NoSuchMethodException {\n+        Method f = this.getClass().getDeclaredMethod(\"f\");\n+        Method f2 = this.getClass().getDeclaredMethod(\"f\");\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+        CoreOp.FuncOp fm2 = Op.ofMethod(f2).orElseThrow();\n+        Assertions.assertSame(fm, fm2);\n+    }\n+\n+    @Test\n+    public void testInstancesReflectDiffMethodsHaveDiffModels() throws NoSuchMethodException {\n+        Method f = this.getClass().getDeclaredMethod(\"f\");\n+        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n+\n+        Method g = this.getClass().getDeclaredMethod(\"g\");\n+        CoreOp.FuncOp gm = Op.ofMethod(g).orElseThrow();\n+\n+        Assertions.assertNotSame(gm, fm);\n+    }\n+\n+    @Test\n+    public void testOpOfMethodIsThreadSafe() throws NoSuchMethodException {\n+        Method f = this.getClass().getDeclaredMethod(\"f\");\n+        List<Optional<CoreOp.FuncOp>> fops = IntStream.range(1, 3).parallel().mapToObj(_ -> Op.ofMethod(f)).toList();\n+        Assertions.assertSame(fops.getFirst(), fops.getLast());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestMethodModelUnique.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import jdk.incubator.code.Reflect;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @summary For a reflectable lambda, calls to Op.ofQuotable must produce the same instance.\n+ * @modules jdk.incubator.code\n+ * @run junit TestQuotedUnique\n+ *\/\n+public class TestQuotedUnique {\n+\n+    @Test\n+    public void testInSequence() {\n+        int j = 8;\n+        IntUnaryOperator q = (@Reflect IntUnaryOperator) i -> i * 2 + j;\n+        Quoted q1 = Op.ofQuotable(q).get();\n+        Quoted q2 = Op.ofQuotable(q).get();\n+        Assertions.assertSame(q1, q2);\n+    }\n+\n+    @Test\n+    public void testInParallel() {\n+        int j = 8;\n+        IntUnaryOperator q = (@Reflect IntUnaryOperator) i -> i * 2 + j;\n+        List<Quoted> quotedObjects = IntStream.range(1, 3).parallel().mapToObj(_ -> Op.ofQuotable(q).get()).toList();\n+        Assertions.assertSame(quotedObjects.getFirst(), quotedObjects.getLast());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuotedUnique.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+import jdk.incubator.code.Op;\n@@ -28,12 +29,2 @@\n-        \/\/ in the lambda class initializer <clinit>, we invoke lambda op method\n-        \/\/ after the changes we made to $CM classfile, the lambda op method throws UOE, causing <clinit> to fails\n-        \/\/ UOE -> ExceptionInInitializerError -> InternalError\n-        InternalError ie = null;\n-        try {\n-            IntBinaryOperator l = (@Reflect IntBinaryOperator) (a, b) -> Math.max(a, b);\n-        } catch (InternalError e) {\n-            Assertions.assertInstanceOf(ExceptionInInitializerError.class, e.getCause());\n-            Assertions.assertInstanceOf(UnsupportedOperationException.class, e.getCause().getCause());\n-            ie = e;\n-        }\n-        Assertions.assertNotNull(ie, \"Reflectable lambda creation didn't fail as expected\");\n+        IntBinaryOperator l = (@Reflect IntBinaryOperator) (a, b) -> Math.max(a, b);\n+        Assertions.assertThrows(UnsupportedOperationException.class, () -> Op.ofQuotable(l));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestJavaVersionCheckerForLambdas.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.List;\n-import java.util.function.IntUnaryOperator;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit LambdaModelUniquenessTest\n- *\/\n-public class LambdaModelUniquenessTest {\n-\n-    Runnable f() {\n-        return (@Reflect Runnable) () -> {\n-            System.out.println(\"Running...\");\n-        };\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatDoNotCapture() {\n-        Runnable q1 = f();\n-        Runnable q2 = f();\n-        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n-        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n-        Assertions.assertSame(quoted1.op(), quoted2.op());\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatDoNotCapture2() {\n-        Runnable q1 = f();\n-        Runnable q2 = f();\n-        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n-        Assertions.assertSame(ops.getFirst(), ops.getLast());\n-    }\n-\n-    static IntUnaryOperator g(int i) {\n-        return (@Reflect IntUnaryOperator) j -> j + i;\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatCapture() {\n-        IntUnaryOperator q1 = g(1);\n-        IntUnaryOperator q2 = g(2);\n-        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n-        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n-        Assertions.assertSame(quoted1.op(), quoted2.op());\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatCapture2() {\n-        IntUnaryOperator q1 = g(1);\n-        IntUnaryOperator q2 = g(2);\n-        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n-        Assertions.assertSame(ops.getFirst(), ops.getLast());\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaModelUniquenessTest.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.reflect.Method;\n-\n-\/*\n- * @test\n- * @modules jdk.incubator.code\n- * @run junit MethodModelUniquenessTest\n- *\/\n-\n-public class MethodModelUniquenessTest {\n-\n-    @Reflect\n-    static void f() {\n-    }\n-    @Reflect\n-    static void g() {\n-    }\n-\n-    @Test\n-    public void testInstancesReflectSameMethodHaveSameModel() throws NoSuchMethodException {\n-        Method f = this.getClass().getDeclaredMethod(\"f\");\n-        Method f2 = this.getClass().getDeclaredMethod(\"f\");\n-        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n-        CoreOp.FuncOp fm2 = Op.ofMethod(f2).orElseThrow();\n-        Assertions.assertSame(fm, fm2);\n-    }\n-\n-    @Test\n-    public void testInstancesReflectDiffMethodsHaveDiffModels() throws NoSuchMethodException {\n-        Method f = this.getClass().getDeclaredMethod(\"f\");\n-        CoreOp.FuncOp fm = Op.ofMethod(f).orElseThrow();\n-\n-        Method g = this.getClass().getDeclaredMethod(\"g\");\n-        CoreOp.FuncOp gm = Op.ofMethod(g).orElseThrow();\n-\n-        Assertions.assertNotSame(gm, fm);\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodModelUniquenessTest.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"}]}