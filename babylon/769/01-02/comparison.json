{"files":[{"patch":"@@ -1,67 +0,0 @@\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.reflect.Method;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.IntUnaryOperator;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-\/*\n- * @test\n- * @summary test that lambda model generated by the compiler is shared across instances of the same lambda class.\n- * This property means we only invoke the op building method once per lambda class.\n- * @modules jdk.incubator.code\n- * @run junit TestLambdaModelUnique\n- *\/\n-public class TestLambdaModelUnique {\n-\n-    Runnable f() {\n-        return (@Reflect Runnable) () -> {\n-            System.out.println(\"Running...\");\n-        };\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatDoNotCaptureInSequence() {\n-        Runnable q1 = f();\n-        Runnable q2 = f();\n-        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n-        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n-        Assertions.assertSame(quoted1.op(), quoted2.op());\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatDoNotCaptureInParallel() { \/\/ parallel\n-        Runnable q1 = f();\n-        Runnable q2 = f();\n-        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n-        Assertions.assertSame(ops.getFirst(), ops.getLast());\n-    }\n-\n-    static IntUnaryOperator g(int i) {\n-        return (@Reflect IntUnaryOperator) j -> j + i;\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatCaptureInSequence() {\n-        IntUnaryOperator q1 = g(1);\n-        IntUnaryOperator q2 = g(2);\n-        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n-        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n-        Assertions.assertSame(quoted1.op(), quoted2.op());\n-    }\n-\n-    @Test\n-    public void testWithLambdaThatCaptureInParallel() {\n-        IntUnaryOperator q1 = g(1);\n-        IntUnaryOperator q2 = g(2);\n-        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n-        Assertions.assertSame(ops.getFirst(), ops.getLast());\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaModelUnique.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -15,1 +15,1 @@\n- * @run junit TestMethodModelUnique\n+ * @run junit TestOpOfMethod\n@@ -17,1 +17,1 @@\n-public class TestMethodModelUnique {\n+public class TestOpOfMethod {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpOfMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/TestMethodModelUnique.java","status":"renamed"},{"patch":"@@ -0,0 +1,79 @@\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Quoted;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.List;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @run junit TestOpOfQuotable\n+ *\/\n+public class TestOpOfQuotable {\n+\n+    Runnable f() {\n+        return (@Reflect Runnable) () -> {\n+            System.out.println(\"Running...\");\n+        };\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatDoNotCaptureInSequence() {\n+        Runnable q1 = f();\n+        Runnable q2 = f();\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assertions.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatDoNotCaptureInParallel() { \/\/ parallel\n+        Runnable q1 = f();\n+        Runnable q2 = f();\n+        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n+        Assertions.assertSame(ops.getFirst(), ops.getLast());\n+    }\n+\n+    static IntUnaryOperator g(int i) {\n+        return (@Reflect IntUnaryOperator) j -> j + i;\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatCaptureInSequence() {\n+        IntUnaryOperator q1 = g(1);\n+        IntUnaryOperator q2 = g(2);\n+        Quoted quoted1 = Op.ofQuotable(q1).orElseThrow();\n+        Quoted quoted2 = Op.ofQuotable(q2).orElseThrow();\n+        Assertions.assertSame(quoted1.op(), quoted2.op());\n+    }\n+\n+    @Test\n+    public void testWithLambdaThatCaptureInParallel() {\n+        IntUnaryOperator q1 = g(1);\n+        IntUnaryOperator q2 = g(2);\n+        List<Op> ops = Stream.of(q1, q2).parallel().map(q -> Op.ofQuotable(q).orElseThrow().op()).toList();\n+        Assertions.assertSame(ops.getFirst(), ops.getLast());\n+    }\n+\n+    @Test\n+    public void testQuotedIsSameInSequence() {\n+        int j = 8;\n+        IntUnaryOperator q = (@Reflect IntUnaryOperator) i -> i * 2 + j;\n+        Quoted q1 = Op.ofQuotable(q).get();\n+        Quoted q2 = Op.ofQuotable(q).get();\n+        Assertions.assertSame(q1, q2);\n+    }\n+\n+    @Test\n+    public void testQuotedIsSameInParallel() {\n+        int j = 8;\n+        IntUnaryOperator q = (@Reflect IntUnaryOperator) i -> i * 2 + j;\n+        List<Quoted> quotedObjects = IntStream.range(1, 3).parallel().mapToObj(_ -> Op.ofQuotable(q).get()).toList();\n+        Assertions.assertSame(quotedObjects.getFirst(), quotedObjects.getLast());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestOpOfQuotable.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Quoted;\n-import jdk.incubator.code.Reflect;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.util.List;\n-import java.util.function.IntUnaryOperator;\n-import java.util.stream.IntStream;\n-\n-\/*\n- * @test\n- * @summary For a reflectable lambda, calls to Op.ofQuotable must produce the same instance.\n- * @modules jdk.incubator.code\n- * @run junit TestQuotedUnique\n- *\/\n-public class TestQuotedUnique {\n-\n-    @Test\n-    public void testInSequence() {\n-        int j = 8;\n-        IntUnaryOperator q = (@Reflect IntUnaryOperator) i -> i * 2 + j;\n-        Quoted q1 = Op.ofQuotable(q).get();\n-        Quoted q2 = Op.ofQuotable(q).get();\n-        Assertions.assertSame(q1, q2);\n-    }\n-\n-    @Test\n-    public void testInParallel() {\n-        int j = 8;\n-        IntUnaryOperator q = (@Reflect IntUnaryOperator) i -> i * 2 + j;\n-        List<Quoted> quotedObjects = IntStream.range(1, 3).parallel().mapToObj(_ -> Op.ofQuotable(q).get()).toList();\n-        Assertions.assertSame(quotedObjects.getFirst(), quotedObjects.getLast());\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestQuotedUnique.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"}]}