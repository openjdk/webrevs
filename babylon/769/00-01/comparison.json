{"files":[{"patch":"@@ -509,0 +509,8 @@\n+        \/*\n+        synchronized Quoted getQuoted() {\n+            if (quoted == null) {\n+                quoted = Quoted.extractOp(getModel(), captures);\n+            }\n+            return quoted;\n+        }\n+        * *\/\n@@ -514,1 +522,0 @@\n-                        Label nonNull = cob.newLabel();\n@@ -517,31 +524,34 @@\n-                                .ifnonnull(nonNull)\n-                                .aload(0);\/\/ will be used by putfield to store the quoted instance\n-\n-                        \/\/ load class data: MH to Quoted.extractOp\n-                        ConstantPoolBuilder cp = cob.constantPool();\n-                        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n-                        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n-                        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH));\n-\n-                        cob.invokestatic(lambdaClassEntry.asSymbol(), \"getModel\", MethodTypeDesc.of(reflectableLambdaInfo.funcOpClass()));\n-\n-                        \/\/ load captured args in array\n-                        int capturedArity = factoryType.parameterCount();\n-                        cob.loadConstant(capturedArity)\n-                                .anewarray(CD_Object);\n-                        for (int i = 0; i < capturedArity; i++) {\n-                            cob.dup()\n-                                    .loadConstant(i)\n-                                    .aload(0)\n-                                    .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n-                            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n-                            cob.aastore();\n-                        }\n-\n-                        \/\/ Create a Quoted from FuncOp and captured args Object[]\n-                        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(reflectableLambdaInfo.extractOpHandle().type()))\n-                                .putfield(lambdaClassEntry.asSymbol(), QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass());\n-\n-                        cob.labelBinding(nonNull)\n-                                .aload(0)\n-                                .getfield(lambdaClassEntry.asSymbol(), QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass())\n+                                .astore(1)\n+                                .aload(1)\n+                                .ifThen(Opcode.IFNULL, bcb -> {\n+                                    bcb.aload(0); \/\/ will be used by putfield\n+\n+                                    \/\/ load class data: MH to Quoted.extractOp\n+                                    ConstantPoolBuilder cp = bcb.constantPool();\n+                                    MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                                    NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                                    bcb.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH));\n+\n+                                    bcb.invokestatic(lambdaClassEntry.asSymbol(), \"getModel\", MethodTypeDesc.of(reflectableLambdaInfo.funcOpClass()));\n+\n+                                    \/\/ load captured args in array\n+                                    int capturedArity = factoryType.parameterCount();\n+                                    bcb.loadConstant(capturedArity)\n+                                            .anewarray(CD_Object);\n+                                    for (int i = 0; i < capturedArity; i++) {\n+                                        bcb.dup()\n+                                                .loadConstant(i)\n+                                                .aload(0)\n+                                                .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+                                        TypeConvertingMethodAdapter.boxIfTypePrimitive(bcb, TypeKind.from(argDescs[i]));\n+                                        bcb.aastore();\n+                                    }\n+\n+                                    \/\/ invoke Quoted.extractOp\n+                                    bcb.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(reflectableLambdaInfo.extractOpHandle().type()))\n+                                            .dup_x1()\n+                                            .putfield(lambdaClassEntry.asSymbol(), QUOTED_FIELD_NAME, reflectableLambdaInfo.quotedClass())\n+                                            .astore(1);\n+\n+                                })\n+                                .aload(1)\n@@ -552,0 +562,8 @@\n+        \/*\n+        private static synchronized CoreOp.FuncOp getModel() {\n+            if(model == null) {\n+                model = ...invoke lambda op building method...\n+            }\n+            return model;\n+        }\n+        * *\/\n@@ -557,5 +575,0 @@\n-                        Label nonNull = cob.newLabel();\n-                        cob.getstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, reflectableLambdaInfo.funcOpClass())\n-                                .ifnonnull(nonNull);\n-\n-                        \/\/ load class data: MH to op building method\n@@ -563,11 +576,17 @@\n-                        ConstantPoolBuilder cp = pool;\n-                        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n-                        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n-                        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n-                        MethodType mtype = quotableOpGetterInfo.getMethodType();\n-                        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get())\n-                                .checkcast(funcOpClassDesc)\n-                                .putstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, funcOpClassDesc);\n-\n-                        cob.labelBinding(nonNull)\n-                                .getstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, funcOpClassDesc)\n+                        cob.getstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, funcOpClassDesc)\n+                                .astore(0)\n+                                .aload(0)\n+                                .ifThen(Opcode.IFNULL, bcb -> {\n+                                    \/\/ load class data: MH to op building method\n+                                    ConstantPoolBuilder cp = pool;\n+                                    MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+                                    NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+                                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+                                    MethodType mtype = quotableOpGetterInfo.getMethodType();\n+                                    cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get())\n+                                            .checkcast(funcOpClassDesc)\n+                                            .dup()\n+                                            .putstatic(lambdaClassEntry.asSymbol(), MODEL_FIELD_NAME, funcOpClassDesc)\n+                                            .astore(0);\n+                                })\n+                                .aload(0)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":67,"deletions":48,"binary":false,"changes":115,"status":"modified"}]}