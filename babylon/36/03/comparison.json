{"files":[{"patch":"@@ -331,0 +331,79 @@\n+    static <T extends Op & Op.Invokable>\n+    Object invokeBody(MethodHandles.Lookup l, Body r,\n+                  OpContext oc) {\n+        Block first = r.entryBlock();\n+\n+        Map<Value, Object> values = new HashMap<>();\n+\n+        \/\/ Note that first block cannot have any successors so the queue will have at least one entry\n+        oc.stack.push(new BlockContext(first, values));\n+        \/\/capturedValues.forEach(oc::setValue);\n+        while (true) {\n+            BlockContext bc = oc.stack.peek();\n+\n+            \/\/ Execute all but the terminating operation\n+            int nops = bc.b.ops().size();\n+            try {\n+                for (int i = 0; i < nops - 1; i++) {\n+                    Op op = bc.b.ops().get(i);\n+                    assert !(op instanceof Op.Terminating) : op.opName();\n+\n+                    Object result = exec(l, oc, op);\n+                    oc.setValue(op.result(), result);\n+                }\n+            } catch (InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                processThrowable(oc, l, t);\n+                continue;\n+            }\n+\n+            \/\/ Execute the terminating operation\n+            Op to = bc.b.terminatingOp();\n+            if (to instanceof CoreOps.ConditionalBranchOp cb) {\n+                boolean p;\n+                Object bop = oc.getValue(cb.predicate());\n+                if (bop instanceof Boolean bp) {\n+                    p = bp;\n+                } else if (bop instanceof Integer ip) {\n+                    \/\/ @@@ This is required when lifting up from bytecode, since boolean values\n+                    \/\/ are erased to int values, abd the bytecode lifting implementation is not currently\n+                    \/\/ sophisticated enough to recover the type information\n+                    p = ip != 0;\n+                } else {\n+                    throw interpreterException(\n+                            new UnsupportedOperationException(\"Unsupported type input to operation: \" + cb));\n+                }\n+                Block.Reference sb = p ? cb.trueBranch() : cb.falseBranch();\n+                oc.successor(sb);\n+            } else if (to instanceof CoreOps.BranchOp b) {\n+                Block.Reference sb = b.branch();\n+\n+                oc.successor(sb);\n+            } else if (to instanceof CoreOps.ThrowOp _throw) {\n+                Throwable t = (Throwable) oc.getValue(_throw.argument());\n+                processThrowable(oc, l, t);\n+            } else if (to instanceof CoreOps.ReturnOp ret) {\n+                Value rv = ret.returnValue();\n+                return rv == null ? null : oc.getValue(rv);\n+            } else if (to instanceof CoreOps.YieldOp yop) {\n+               Value yv = yop.yieldValue();\n+               return yv == null ? null : oc.getValue(yv);\n+            } else if (to instanceof CoreOps.ExceptionRegionEnter ers) {\n+                var er = new ExceptionRegionRecord(oc.stack.peek(), ers);\n+                oc.setValue(ers.result(), er);\n+\n+                oc.pushExceptionRegion(er);\n+\n+                oc.successor(ers.start());\n+            } else if (to instanceof CoreOps.ExceptionRegionExit ere) {\n+                oc.popExceptionRegion(ere.regionStart());\n+\n+                oc.successor(ere.end());\n+            } else {\n+                throw interpreterException(\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+            }\n+        }\n+    }\n+\n@@ -351,0 +430,2 @@\n+\n+\n@@ -521,0 +602,13 @@\n+        } else if (o instanceof CoreOps.AssertOp _assert) {\n+            Body testBody = _assert.bodies.get(0);\n+            boolean testResult = (boolean) invokeBody(l,testBody,oc);\n+            if (!testResult) {\n+                if (_assert.bodies.size() > 1) {\n+                    Body messageBody = _assert.bodies.get(1);\n+                    String message = String.valueOf(invokeBody(l, messageBody, oc));\n+                    throw new AssertionError(message);\n+                } else {\n+                    throw new AssertionError();\n+                }\n+            }\n+            return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1842,1 +1842,1 @@\n-                         FunctionType.functionType(JavaType.J_L_STRING));\n+                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -ea TestAssert\n+ *\/\n+public class TestAssert {\n+\n+    public static final String FAILURESTRING = \"failure\";\n+    public static final char FAILURECHAR = 'o';\n+\n+    public static final float FAILUREFLOAT = -1.0f;\n+    public static final double FAILUREDOUBLE = -1.0d;\n+    public static final byte FAILUREBYTE = -1;\n+    public static final short FAILURESHORT = -1;\n+    public static final int FAILUREINT = -1;\n+\n+    public static final long FAILURELONG = -1;\n+\n+    public static final String FAILUREOBJECTMSG = \"FAILURE OBJECT\";\n+\n+    public static final Object FAILUREOBJECT = new FailureObject();\n+\n+\n+    @Test\n+    public void testAssertThrows(){\n+        testThrows(\"assertThrow\");\n+    }\n+\n+    @Test\n+    public void testAssertString(){\n+        AssertionError ae = testThrows(\"assertThrowWithMessage\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(FAILURESTRING)) {\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertChar() {\n+        AssertionError ae = testThrows(\"assertChar\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILURECHAR))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertFloat() {\n+        AssertionError ae = testThrows(\"assertFloat\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREFLOAT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertDouble() {\n+        AssertionError ae = testThrows(\"assertDouble\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREDOUBLE))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertByte() {\n+        AssertionError ae = testThrows(\"assertByte\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREBYTE))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertShort() {\n+        AssertionError ae = testThrows(\"assertShort\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILURESHORT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertInt() {\n+        AssertionError ae = testThrows(\"assertInt\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREINT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertLong() {\n+        AssertionError ae = testThrows(\"assertLong\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILURELONG))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertObject() {\n+        AssertionError ae = testThrows(\"assertObject\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREOBJECT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertExpr1() {\n+        AssertionError ae = testThrows(\"assertExpr1\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREINT + FAILURELONG))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    private static AssertionError testThrows(String methodName) {\n+        try {\n+            Class<TestAssert> clazz = TestAssert.class;\n+            Method method = clazz.getDeclaredMethod(methodName);\n+            CoreOps.FuncOp f = method.getCodeModel().orElseThrow();\n+            AssertionError ae = (AssertionError) retCatch(() -> Interpreter.invoke(MethodHandles.lookup(), method.getCodeModel().orElseThrow()));\n+            Assert.assertNotNull(ae);\n+            return ae;\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Throwable retCatch(Runnable r) {\n+        try {\n+            r.run();\n+        } catch (Throwable t) {\n+            return t;\n+        }\n+        return null;\n+    }\n+\n+\n+\n+    @CodeReflection\n+    public static void assertThrow() {\n+        assert false;\n+    }\n+\n+    @CodeReflection\n+    public static void assertThrowWithMessage() {\n+        assert false : FAILURESTRING;\n+    }\n+\n+    @CodeReflection\n+    public static void assertChar() {\n+        char c = FAILURECHAR;\n+        assert false : c;\n+    }\n+\n+    @CodeReflection\n+    public static void assertFloat() {\n+        float f = FAILUREFLOAT;\n+        assert false : f;\n+    }\n+\n+    @CodeReflection\n+    public static void assertDouble() {\n+        double d = FAILUREDOUBLE;\n+        assert false : d;\n+    }\n+\n+    @CodeReflection\n+    public static void assertByte() {\n+        byte b = FAILUREBYTE;\n+        assert false : b;\n+    }\n+\n+    @CodeReflection\n+    public static void assertShort() {\n+        short s = FAILURESHORT;\n+        assert false : s;\n+    }\n+\n+    @CodeReflection\n+    public static void assertInt() {\n+        int i = FAILUREINT;\n+        assert false : i;\n+    }\n+\n+    @CodeReflection\n+    public static void assertLong() {\n+        long l = FAILURELONG;\n+        assert false : l;\n+    }\n+\n+    @CodeReflection\n+    public static void assertObject() {\n+        Object o = FAILUREOBJECT;\n+        assert false : o;\n+    }\n+\n+    @CodeReflection\n+    public static void assertExpr1() {\n+        int i = FAILUREINT;\n+        long l = FAILURELONG;\n+        assert false : i + l;\n+    }\n+\n+    static class FailureObject {\n+        @Override\n+        public String toString(){\n+           return FAILUREOBJECTMSG;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestAssert.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"}]}