{"files":[{"patch":"@@ -248,2 +248,0 @@\n-        OpContext oc = new OpContext();\n-\n@@ -251,0 +249,9 @@\n+        return invoke(l, r, capturedValues, Optional.empty(), args);\n+\n+    }\n+\n+    private static Object invoke(MethodHandles.Lookup l, Body r,\n+                  Map<Value, Object> capturedValues, Optional<OpContext> ooc,\n+                  List<Object> args) {\n+        OpContext oc = ooc.orElse(new OpContext());\n+\n@@ -311,1 +318,0 @@\n-\n@@ -313,0 +319,3 @@\n+            } else if (to instanceof CoreOps.YieldOp yop) {\n+                Value yv = yop.yieldValue();\n+                return yv == null ? null : oc.getValue(yv);\n@@ -332,76 +341,3 @@\n-    Object invokeBody(MethodHandles.Lookup l, Body r,\n-                  OpContext oc) {\n-        Block first = r.entryBlock();\n-\n-        Map<Value, Object> values = new HashMap<>();\n-\n-        \/\/ Note that first block cannot have any successors so the queue will have at least one entry\n-        oc.stack.push(new BlockContext(first, values));\n-        \/\/capturedValues.forEach(oc::setValue);\n-        while (true) {\n-            BlockContext bc = oc.stack.peek();\n-\n-            \/\/ Execute all but the terminating operation\n-            int nops = bc.b.ops().size();\n-            try {\n-                for (int i = 0; i < nops - 1; i++) {\n-                    Op op = bc.b.ops().get(i);\n-                    assert !(op instanceof Op.Terminating) : op.opName();\n-\n-                    Object result = exec(l, oc, op);\n-                    oc.setValue(op.result(), result);\n-                }\n-            } catch (InterpreterException e) {\n-                throw e;\n-            } catch (Throwable t) {\n-                processThrowable(oc, l, t);\n-                continue;\n-            }\n-\n-            \/\/ Execute the terminating operation\n-            Op to = bc.b.terminatingOp();\n-            if (to instanceof CoreOps.ConditionalBranchOp cb) {\n-                boolean p;\n-                Object bop = oc.getValue(cb.predicate());\n-                if (bop instanceof Boolean bp) {\n-                    p = bp;\n-                } else if (bop instanceof Integer ip) {\n-                    \/\/ @@@ This is required when lifting up from bytecode, since boolean values\n-                    \/\/ are erased to int values, abd the bytecode lifting implementation is not currently\n-                    \/\/ sophisticated enough to recover the type information\n-                    p = ip != 0;\n-                } else {\n-                    throw interpreterException(\n-                            new UnsupportedOperationException(\"Unsupported type input to operation: \" + cb));\n-                }\n-                Block.Reference sb = p ? cb.trueBranch() : cb.falseBranch();\n-                oc.successor(sb);\n-            } else if (to instanceof CoreOps.BranchOp b) {\n-                Block.Reference sb = b.branch();\n-\n-                oc.successor(sb);\n-            } else if (to instanceof CoreOps.ThrowOp _throw) {\n-                Throwable t = (Throwable) oc.getValue(_throw.argument());\n-                processThrowable(oc, l, t);\n-            } else if (to instanceof CoreOps.ReturnOp ret) {\n-                Value rv = ret.returnValue();\n-                return rv == null ? null : oc.getValue(rv);\n-            } else if (to instanceof CoreOps.YieldOp yop) {\n-               Value yv = yop.yieldValue();\n-               return yv == null ? null : oc.getValue(yv);\n-            } else if (to instanceof CoreOps.ExceptionRegionEnter ers) {\n-                var er = new ExceptionRegionRecord(oc.stack.peek(), ers);\n-                oc.setValue(ers.result(), er);\n-\n-                oc.pushExceptionRegion(er);\n-\n-                oc.successor(ers.start());\n-            } else if (to instanceof CoreOps.ExceptionRegionExit ere) {\n-                oc.popExceptionRegion(ere.regionStart());\n-\n-                oc.successor(ere.end());\n-            } else {\n-                throw interpreterException(\n-                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n-            }\n-        }\n+    Object interpretBody(MethodHandles.Lookup l, Body r,\n+                         OpContext oc) {\n+        return invoke(l, r, new HashMap<>(), Optional.of(oc), List.of());\n@@ -604,1 +540,1 @@\n-            boolean testResult = (boolean) invokeBody(l,testBody,oc);\n+            boolean testResult = (boolean) interpretBody(l,testBody,oc);\n@@ -608,1 +544,1 @@\n-                    String message = String.valueOf(invokeBody(l, messageBody, oc));\n+                    String message = String.valueOf(interpretBody(l, messageBody, oc));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":17,"deletions":81,"binary":false,"changes":98,"status":"modified"}]}