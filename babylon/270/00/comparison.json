{"files":[{"patch":"@@ -1,1 +1,2 @@\n-\/*\n+\/* vim: set ft=java: \n+ *\n@@ -26,2 +27,3 @@\n-import static bldr.Bldr.*;           \/\/ all the helpers are here \n-import static java.nio.file.Files.*; \/\/ so we can use isDirectory(path);\n+import static bldr.Bldr.*;\n+\n+void main(String[] args) {\n@@ -29,3 +31,5 @@\n-void main(String[] args) throws IOException, InterruptedException, URISyntaxException {\n-   var hatDir = new Root();\n-   List.of(args).forEach(arg->println(arg));\n+ var hatDir = Dir.current();\n+ var hatLibDir = assertExists(hatDir.dir(\"hat\"));\n+ var backends = assertExists(hatDir.dir(\"backends\"));\n+ var examples = assertExists(hatDir.dir(\"examples\"));\n+ var buildDir =BuildDir.of(hatDir.path(\"build\")).create();\n@@ -33,2 +37,5 @@\n-   withExpectedDirectory(hatDir.subDir(\"hat\"), hatProjectDir -> {\n-      var hatJavacOpts = new JavacBuilder().opts(\n+\n+ var hatJar = jar($->$\n+   .jar(buildDir.jarFile(\"hat-1.0.jar\"))\n+   .javac($$->$$\n+      .opts(\n@@ -39,99 +46,49 @@\n-      );\n-\n-      var hatJarResult = new Project(hatDir.buildDir(), hatProjectDir, \"1.0\").build(hatJavacOpts);\n-\n-      var hatExampleJavacConfig = new JavacBuilder().basedOn(hatJavacOpts).class_path(hatJarResult.jar);\n-\n-      withExpectedDirectory(hatDir.subDir(\"backends\"), backendsDir -> {\n-         subDirStream(backendsDir, \"opencl\", \"ptx\", \"cuda\", \"mock\")\n-             .map(backendDir -> new Project(hatDir.buildDir(), backendDir, \"1.0\"))\n-             .parallel()\n-             .forEach(project -> project.build(\"hat-backend\", hatExampleJavacConfig));\n-\n-         var cmakeBuildDir = hatDir.buildDir().resolve(\"cmake-build-debug\");\n-\n-         if (!isDirectory(cmakeBuildDir)) { \/\/ We need to rerun build -B defaultCMakeBuilder.buildDir\n-            mkdir(cmakeBuildDir);\n-            cmake($ -> $ .S(backendsDir) .B(cmakeBuildDir) .opts(\"-DHAT_TARGET=\" + hatDir.buildDir()));\n-         }\n-\n-         cmake($->$ .build(cmakeBuildDir));\n-      });\n-\n-\n-      withExpectedDirectory(hatDir.subDir(\"examples\"), examplesDir ->\n-         subDirStream(examplesDir, \"blackscholes\", \"mandel\", \"squares\", \"heal\", \"violajones\", \"life\")\n-             .map(exampleDir -> new Project(hatDir.buildDir(), exampleDir, \"1.0\"))\n-             .parallel()\n-             .forEach(project -> project.build(\"hat-example\", hatExampleJavacConfig))\n-      );\n-\n-      withOptionalDirectory(hatDir.subDir(\"hattricks\"), hattricksDir -> {\n-         subDirStream(hattricksDir, \"chess\", \"view\")\n-             .map(hattrickDir -> new Project(hatDir.buildDir(), hattrickDir, \"1.0\"))\n-             .parallel()\n-             .forEach(project -> project.build(\"hat-example\", hatExampleJavacConfig));\n-\n-\n-             withOptionalDirectory(hattricksDir.resolve(\"nbody-extracted-cl\"),nbodyExtractedCl -> {\n-                var jextractedJava = mkdir(hatDir.buildDir().resolve(\"jextracted-java\"));\n-                var extractedOpenCLCode = jextractedJava.resolve(\"opencl\");\n-                if (!isDirectory(extractedOpenCLCode)) {\n-                   mkdir(extractedOpenCLCode);\n-                   println(\"Extracting OpenCL API\");\n-                   jextract($$ -> $$\n-                      .home(hatDir.requireJExtract())\n-                      .cwd(nbodyExtractedCl)\n-                      .output(jextractedJava)\n-                      .target_package(\"opencl\")\n-                      .when(os instanceof OS.Mac,  $$$ -> $$$\n-                         .compile_flag(\"-F\" + ((OS.Mac)os).appLibFrameworks())\n-                         .library(((OS.Mac)os).frameworkLibrary(\"OpenCL\"))\n-                         .header(((OS.Mac)os).frameworkHeader(\"OpenCL\", \"opencl.h\"))\n-                      )\n-                   );\n-                }\n-                var extractedOpenGLCode = jextractedJava.resolve(\"opengl\");\n-                if (!isDirectory(extractedOpenGLCode)) {\n-                   mkdir(extractedOpenGLCode);\n-                   println(\"Extracting OpenGL API\");\n-                   jextract($$ -> $$\n-                      .home(hatDir.requireJExtract())\n-                      .cwd(nbodyExtractedCl)\n-                      .output(jextractedJava)\n-                      .target_package(\"opengl\")\n-                      .when(os instanceof OS.Mac, $$$ -> $$$\n-                          .compile_flag(\"-F\" + ((OS.Mac)os).libFrameworks())\n-                          .library(\n-                              ((OS.Mac)os).frameworkLibrary(\"GLUT\"),\n-                              ((OS.Mac)os).frameworkLibrary(\"OpenGL\")\n-                              )\n-                          .header(((OS.Mac)os).frameworkHeader(\"GLUT\",\"glut.h\"))\n-                      )\n-                      .when(os instanceof OS.Linux, $$$ -> {\n-                      })\n-                   );\n-                }\n-\n-                println(\"Building nbody-extracted-cl\");\n-                var nbodyJar =jar($ -> $\n-                   .jar(hatDir.buildDir().resolve(\"hat-example-nbody-extracted-cl-1.0.jar\"))\n-                   .path_list(nbodyExtractedCl.resolve(\"src\/main\/resources\"))\n-                   .javac($$ -> $$.basedOn(hatExampleJavacConfig)\n-                       .source_path(nbodyExtractedCl.resolve(\"src\/main\/java\"), extractedOpenCLCode, extractedOpenGLCode)\n-                   )\n-                );\n-\n-                \/*java($ -> $\n-                   .vmopts(\n-                       \"--enable-preview\",\n-                       \"--enable-native-access=ALL-UNNAMED\",\n-                       \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                       \"-XstartOnFirstThread\"\n-                    )\n-                    .class_path(nbodyJar.jar)\n-                    .main_class(\"nbody.Main\")\n-                ); *\/\n-             });\n-          });\n-      });\n+      )\n+      .class_dir(buildDir.classDir(\"hat-1.0.jar.classes\"))\n+      .source_path(hatLibDir.dir(\"src\/main\/java\"))\n+   )\n+ );\n+\n+ backends.forEachSubDirectory(\"opencl\", \"ptx\").forEach(backend -> \n+   jar($->$\n+     .jar(buildDir.jarFile(\"hat-backend-\" + backend.name() + \"-1.0.jar\"))\n+     .javac($$ -> $$\n+        .opts(\n+           \"--source\", \"24\",\n+           \"--enable-preview\",\n+           \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+           \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+        )\n+        .class_dir(buildDir.classDir(\"hat-backend-\" + backend.name() + \"-1.0.jar.classes\"))\n+        .class_path(hatJar)\n+        .source_path(backend.dir(\"src\/main\/java\"))\n+     )\n+     .dir_list(dir->dir.exists(),backend.dir(\"src\/main\/resources\"))\n+   )\n+ );\n+\n+ var cmakeBuildDir = buildDir.cMakeBuildDir(\"cmake-build-debug\");\n+\n+ if (!cmakeBuildDir.exists()) {\n+    cmake($ -> $.source_dir(backends).build_dir(cmakeBuildDir).copy_to(buildDir));\n+ }\n+\n+ cmake($->$.build(cmakeBuildDir));\n+\n+ examples.forEachSubDirectory(\"blackscholes\", \"mandel\", \"squares\", \"heal\", \"violajones\", \"life\").forEach(example -> \n+   jar($->$\n+     .jar(buildDir.jarFile(\"hat-example-\" + example.name() + \"-1.0.jar\"))\n+     .javac($$->$$\n+        .opts(\n+           \"--source\", \"24\",\n+           \"--enable-preview\",\n+           \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+           \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+        )\n+        .class_dir(buildDir.classDir(\"hat-example-\" + example.name() + \"-1.0.jar.classes\"))\n+        .class_path(hatJar)\n+        .source_path(example.dir(\"src\/main\/java\"))\n+     )\n+     .dir_list(dir->dir.exists(),example.dir(\"src\/main\/resources\"))\n+   )\n+ );\n","filename":"hat\/bld","additions":64,"deletions":107,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -0,0 +1,1278 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package bldr;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+import static java.io.IO.print;\n+import static java.io.IO.println;\n+import static java.nio.file.Files.isDirectory;\n+import static java.nio.file.Files.isRegularFile;\n+\n+public class Bldr {\n+    public interface PathHolder  {\n+        Path path();\n+        default String name(){\n+            return path().getFileName().toString();\n+        }\n+        default Matcher pathMatcher(Pattern pattern) {\n+            return pattern.matcher(path().toString());\n+        }\n+\n+        default boolean matches(Pattern pattern) {\n+            return pathMatcher(pattern).matches();\n+        }\n+\n+        default boolean matches(String pattern) {\n+            return pathMatcher(Pattern.compile(pattern)).matches();\n+        }\n+\n+    }\n+\n+    public interface TargetDirProvider extends PathHolder {\n+        Path targetDir();\n+    }\n+\n+    public interface JavaSourceDirProvider {\n+        Path javaSourceDir();\n+    }\n+\n+    public interface ResourceDirProvider {\n+        DirPathHolder resourcesDir();\n+    }\n+\n+    public interface  DirPathHolder<T extends DirPathHolder<T>> extends PathHolder {\n+         default Path path(String subdir){\n+            return path().resolve(subdir);\n+        }\n+        default Stream<Path> find() {\n+            try {\n+                return Files.walk(path());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        default Stream<Path> find(Predicate<Path> predicate) {\n+            return find().filter(predicate);\n+        }\n+\n+\n+        default Stream<Path> findFiles() {\n+            return find( Files::isRegularFile);\n+        }\n+\n+        default Stream<Path> findDirs() {\n+            return find( Files::isDirectory);\n+        }\n+\n+        default Stream<Path> findFiles(Predicate<Path> predicate) {\n+            return findFiles().filter(predicate);\n+        }\n+\n+        default Stream<SearchableTextFile> findTextFiles(String... suffixes) {\n+            return findFiles().map(SearchableTextFile::new).filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n+        }\n+\n+        default Stream<Path> findDirs( Predicate<Path> predicate) {\n+            return find( Files::isDirectory).filter(predicate);\n+        }\n+\n+\n+        default boolean exists(){\n+             return Files.exists(path()) && Files.isDirectory(path());\n+        }\n+\n+\n+    }\n+\n+    public interface FilePathHolder extends PathHolder { }\n+\n+    public interface ClassPathEntry extends PathHolder { }\n+    public record CMakeBuildDir(Path path) implements  BuildDirHolder<CMakeBuildDir> {\n+        public static CMakeBuildDir of(Path path) {\n+            return new CMakeBuildDir(path);\n+        }\n+\n+        @Override\n+        public CMakeBuildDir create() {\n+            return CMakeBuildDir.of(mkdir(path()));\n+        }\n+\n+        @Override\n+        public CMakeBuildDir remove() {\n+            return CMakeBuildDir.of(rmdir(path()));\n+        }\n+    }\n+    public interface BuildDirHolder<T extends BuildDirHolder<T>> extends DirPathHolder<T> {\n+        T create();\n+        T remove();\n+        default void clean(){\n+            remove();\n+            create();\n+        }\n+        default Path mkdir(Path path) {\n+            try {\n+                return Files.createDirectories(path);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        default Path rmdir(Path path) {\n+            try {\n+                if (Files.exists(path)) {\n+                    Files.walk(path).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+                }\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+            }\n+            return path;\n+        }\n+\n+    }\n+    public record ClassDir(Path path) implements ClassPathEntry, BuildDirHolder<ClassDir> {\n+        public static ClassDir of(Path path) {\n+            return new ClassDir(path);\n+        }\n+\n+        public static ClassDir temp(String javacclasses) {\n+            try {\n+                return of(Files.createTempDirectory(\"javacClasses\"));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public ClassDir create(){\n+            return ClassDir.of(mkdir(path()));\n+        }\n+        @Override\n+        public ClassDir remove(){\n+            return ClassDir.of(rmdir(path()));\n+        }\n+    }\n+    public record Dir(Path path) implements  DirPathHolder<Dir> {\n+        public static Dir of(Path path){\n+           return new Dir(path);\n+       }\n+        public static Dir of(String string){\n+            return of (Path.of(string));\n+        }\n+        public static Dir current(){\n+            return of(Path.of(System.getProperty(\"user.dir\")));\n+        }\n+        public Dir parent(){\n+            return of(path().getParent());\n+        }\n+\n+        public  Dir dir(String subdir){\n+            return Dir.of(path(subdir));\n+        }\n+        public Stream<Dir> forEachSubDirectory(String ... dirNames){\n+            return Stream.of(dirNames).map(dirName->path().resolve(dirName)).filter(Files::isDirectory).map(Dir::new);\n+        }\n+\n+    }\n+    public record RootDirAndSubPath(DirPathHolder<?> root, Path path) {\n+        Path relativize() {\n+            return root().path().relativize(path());\n+        }\n+    }\n+    public record BuildDir(Path path) implements ClassPathEntry, BuildDirHolder<BuildDir> {\n+        public static BuildDir of(Path path){\n+            return new BuildDir(path);\n+        }\n+\n+        public JarFile jarFile(String name) {\n+            return JarFile.of(path().resolve(name));\n+        }\n+        public CMakeBuildDir cMakeBuildDir(String name) {\n+            return CMakeBuildDir.of(path().resolve(name));\n+        }\n+        public ClassDir classDir(String name) {\n+            return ClassDir.of(path().resolve(name));\n+        }\n+\n+        @Override\n+        public BuildDir create() {\n+            return BuildDir.of(mkdir(path()));\n+        }\n+\n+        @Override\n+        public BuildDir remove() {\n+            return BuildDir.of(rmdir(path()));\n+        }\n+\n+        public BuildDir dir(String subdir){\n+            return BuildDir.of(path(subdir));\n+        }\n+\n+    }\n+\n+    public record JarFile(Path path) implements ClassPathEntry, FilePathHolder {\n+        public static JarFile of(Path path) {\n+            return new JarFile(path);\n+        }\n+    }\n+\n+    public record SourcePathEntry(Path path) implements DirPathHolder<SourcePathEntry> {\n+    }\n+\n+    public interface TextFile extends FilePathHolder{\n+\n+    }\n+\n+    public interface SourceFile extends TextFile {\n+    }\n+\n+    public static class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n+         Path path;\n+\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                try {\n+                    return Files.readString(Path.of(toUri()));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+        JavaSourceFile(Path path) {\n+            super(path.toUri(), JavaFileObject.Kind.SOURCE);\n+\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+    }\n+\n+    public record CppSourceFile(Path path) implements SourceFile {\n+    }\n+\n+    public record CppHeaderSourceFile(Path path) implements SourceFile {\n+    }\n+\n+\n+    public record ClassPath(List<ClassPathEntry> entries) {\n+    }\n+\n+    public record SourcePath(List<SourcePathEntry> entries) {\n+    }\n+\n+    public record XMLFile(Path path) implements TextFile {\n+    }\n+\n+    public interface OS {\n+        String arch();\n+\n+        String name();\n+\n+        String version();\n+\n+        static final String MacName = \"Mac OS X\";\n+        static final String LinuxName = \"Linux\";\n+\n+\n+        record Linux(String arch, String name, String version) implements OS {\n+        }\n+\n+        record Mac(String arch, String name, String version) implements OS {\n+            public Path appLibFrameworks() {\n+                return Path.of(\"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n+                        + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n+            }\n+\n+            public Path frameworkHeader(String frameworkName, String headerFileName) {\n+                return appLibFrameworks().resolve(frameworkName + \".framework\/Headers\/\" + headerFileName);\n+            }\n+\n+            public Path libFrameworks() {\n+                return Path.of(\"\/System\/Library\/Frameworks\");\n+            }\n+\n+            public Path frameworkLibrary(String frameworkName) {\n+                return libFrameworks().resolve(frameworkName + \".framework\/\" + frameworkName);\n+            }\n+        }\n+\n+        static OS get() {\n+            String arch = System.getProperty(\"os.arch\");\n+            String name = System.getProperty(\"os.name\");\n+            String version = System.getProperty(\"os.version\");\n+            return switch (name) {\n+\n+                case \"Mac OS X\" -> new Mac(arch, name, version);\n+                case \"Linux\" -> new Linux(arch, name, version);\n+                default -> throw new IllegalStateException(\"No os mapping for \" + name);\n+            };\n+        }\n+    }\n+\n+\n+    public static OS os = OS.get();\n+\n+    public record Java(String version, File home) {\n+    }\n+\n+    public static Java java = new Java(System.getProperty(\"java.version\"), new File(System.getProperty(\"java.home\")));\n+\n+    public record User(File home, File pwd) {\n+    }\n+\n+    public static User user = new User(new File(System.getProperty(\"user.home\")), new File(System.getProperty(\"user.dir\")));\n+\n+\n+    \/*\n+        static class POM {\n+            static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+            static public String varExpand(Map<String, String> props, String value) { \/\/ recurse\n+                String result = value;\n+                if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+                    var v = matcher.groupId(1);\n+                    result = varExpand(props, value.substring(0, matcher.start())\n+                            + (v.startsWith(\"env\")\n+                            ? System.getenv(v.substring(4))\n+                            : props.get(v))\n+                            + value.substring(matcher.end()));\n+                    \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+                }\n+                return result;\n+            }\n+\n+            POM(Path dir) throws Throwable {\n+                var topPom = new XMLNode(new File(dir.toFile(), \"pom.xml\"));\n+                var babylonDirKey = \"babylon.dir\";\n+                var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n+                var hatDirKey = \"hat.dir\";\n+                var interestingKeys = Set.of(spirvDirKey, babylonDirKey, hatDirKey);\n+                var requiredDirKeys = Set.of(babylonDirKey, hatDirKey);\n+                var dirKeyToDirMap = new HashMap<String, File>();\n+                var props = new HashMap<String, String>();\n+\n+                topPom.children.stream().filter(e -> e.element.getNodeName().equals(\"properties\")).forEach(properties ->\n+                        properties.children.stream().forEach(property -> {\n+                            var key = property.element.getNodeName();\n+                            var value = varExpand(props, property.element.getTextContent());\n+                            props.put(key, value);\n+                            if (interestingKeys.contains(key)) {\n+                                var file = new File(value);\n+                                if (requiredDirKeys.contains(key) && !file.exists()) {\n+                                    System.err.println(\"ERR pom.xml has property '\" + key + \"' with value '\" + value + \"' but that dir does not exists!\");\n+                                    System.exit(1);\n+                                }\n+                                dirKeyToDirMap.put(key, file);\n+                            }\n+                        })\n+                );\n+                for (var key : requiredDirKeys) {\n+                    if (!props.containsKey(key)) {\n+                        System.err.println(\"ERR pom.xml expected to have property '\" + key + \"' \");\n+                        System.exit(1);\n+                    }\n+                }\n+            }\n+        }\n+    *\/\n+\n+    public static String charSeparatedClassPath(List<ClassPathEntry> classPathEntries) {\n+        StringBuilder sb = new StringBuilder();\n+        classPathEntries.forEach(classPathEntry -> {\n+            if (!sb.isEmpty()) {\n+                sb.append(File.pathSeparatorChar);\n+            }\n+            sb.append(classPathEntry.path());\n+        });\n+        return sb.toString();\n+    }\n+    public static String charSeparatedDirPathHolders(List<DirPathHolder<?>> dirPathHolderEntries) {\n+        StringBuilder sb = new StringBuilder();\n+        dirPathHolderEntries.forEach(dirPathHolderEntry -> {\n+            if (!sb.isEmpty()) {\n+                sb.append(File.pathSeparatorChar);\n+            }\n+            sb.append(dirPathHolderEntry.path());\n+        });\n+        return sb.toString();\n+    }\n+\n+    public abstract static class Builder<T extends Builder<T>> {\n+        @SuppressWarnings(\"unchecked\") T self() {\n+            return (T) this;\n+        }\n+\n+        public List<String> opts = new ArrayList<>();\n+        public boolean verbose;\n+        public T verbose(boolean verbose) {\n+            this.verbose= verbose;\n+            return self();\n+        }\n+        public T verbose() {\n+            verbose(true);\n+            return self();\n+        }\n+\n+        public abstract T show(Consumer<String> stringConsumer);\n+\n+        public T opts(List<String> opts) {\n+            this.opts.addAll(opts);\n+            return self();\n+        }\n+\n+        public T opts(String... opts) {\n+            opts(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+        public T basedOn(T stem) {\n+            if (stem != null) {\n+                opts.addAll(stem.opts);\n+            }\n+            return self();\n+        }\n+\n+        public T when(boolean condition, Consumer<T> consumer) {\n+            if (condition) {\n+                consumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+        public T either(boolean condition, Consumer<T> trueConsumer, Consumer<T> falseConsumer) {\n+            if (condition) {\n+                trueConsumer.accept(self());\n+            } else {\n+                falseConsumer.accept(self());\n+            }\n+            return self();\n+        }\n+\n+    }\n+\n+    public static abstract class ExecBuilder<T extends ExecBuilder<T>> extends Builder<T> {\n+        abstract public List<String> execOpts();\n+\n+        public void execInheritIO(Path path) {\n+            try {\n+                var processBuilder = new ProcessBuilder();\n+\n+                if (path != null) {\n+                    processBuilder.directory(path.toFile());\n+                }\n+                processBuilder\n+                        .inheritIO()\n+                        .command(execOpts());\n+                var process = processBuilder\n+                        .start();\n+                if (verbose){\n+                   print(execOpts());\n+                    \/\/ show((s)->print(execOpts()));\n+                }\n+                process.waitFor();\n+\n+            } catch (InterruptedException ie) {\n+                System.out.println(ie);\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+            }\n+        }\n+\n+        public void execInheritIO() {\n+            execInheritIO(null);\n+        }\n+    }\n+\n+    public static class JavacBuilder extends Builder<JavacBuilder> {\n+        public ClassDir classDir;\n+        public List<DirPathHolder<?>> sourcePath ;\n+        public List<ClassPathEntry> classPath;\n+\n+        @Override\n+        public JavacBuilder show(Consumer<String> stringConsumer) {\n+             return self();\n+        }\n+\n+        public JavacBuilder basedOn(JavacBuilder stem) {\n+            super.basedOn(stem);\n+            if (stem != null) {\n+                if (stem.classDir != null) {\n+                    this.classDir = stem.classDir;\n+                }\n+                if (stem.sourcePath != null) {\n+                    this.sourcePath = new ArrayList<>(stem.sourcePath);\n+                }\n+                if (stem.classPath != null) {\n+                    this.classPath = new ArrayList<>(stem.classPath);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        public JavacBuilder class_dir(Path classDir) {\n+            this.classDir = ClassDir.of(classDir);\n+            return this;\n+        }\n+\n+        public JavacBuilder class_dir(ClassDir classDir) {\n+            this.classDir = classDir;\n+            return this;\n+        }\n+\n+        public JavacBuilder source_path(List<DirPathHolder<?>> sourcePaths) {\n+            this.sourcePath = this.sourcePath == null ? new ArrayList<>() : this.sourcePath;\n+            this.sourcePath.addAll(sourcePaths);\n+            return this;\n+        }\n+\n+        public JavacBuilder source_path(DirPathHolder<?>... sourcePaths) {\n+            return source_path(List.of(sourcePaths));\n+        }\n+\n+        public JavacBuilder class_path(ClassPathEntry... classPathEntries) {\n+            this.classPath = this.classPath == null ? new ArrayList<>() : this.classPath;\n+            this.classPath.addAll(Arrays.asList(classPathEntries));\n+            return this;\n+        }\n+\n+    }\n+\n+\n+\n+\n+\n+    public static JavacBuilder javac(JavacBuilder javacBuilder) {\n+        try {\n+            if (javacBuilder.classDir == null) {\n+                javacBuilder.classDir = ClassDir.temp(\"javacclasses\");\n+              }\n+            javacBuilder.opts.addAll(List.of(\"-d\", javacBuilder.classDir.path().toString()));\n+            javacBuilder.classDir.clean();\n+\n+\n+            if (javacBuilder.classPath != null) {\n+                javacBuilder.opts.addAll(List.of(\"--class-path\", charSeparatedClassPath(javacBuilder.classPath)));\n+            }\n+\n+            javacBuilder.opts.addAll(List.of(\"--source-path\", charSeparatedDirPathHolders(javacBuilder.sourcePath)));\n+            var compilationUnits = new ArrayList<JavaSourceFile>();\n+            javacBuilder.sourcePath.forEach(entry ->\n+                    entry.findFiles( file -> file.toString().endsWith(\".java\"))\n+                            .map(JavaSourceFile::new)\n+                            .forEach(compilationUnits::add));\n+\n+            DiagnosticListener<JavaFileObject> dl = (diagnostic) -> {\n+                if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n+                    System.out.println(diagnostic.getKind()\n+                            + \" \" + diagnostic.getLineNumber() + \":\" + diagnostic.getColumnNumber() + \" \" + diagnostic.getMessage(null));\n+                }\n+            };\n+\n+            \/\/   List<RootAndPath> pathsToJar = new ArrayList<>();\n+            JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n+            JavaCompiler.CompilationTask compilationTask = (javac.getTask(\n+                    new PrintWriter(System.err),\n+                    javac.getStandardFileManager(dl, null, null),\n+                    dl,\n+                    javacBuilder.opts,\n+                    null,\n+                    compilationUnits\n+\n+            ));\n+            ((com.sun.source.util.JavacTask) compilationTask)\n+                    .generate();\n+            \/\/.forEach(fileObject -> pathsToJar.add(new RootAndPath(javacBuilder.classesDir, Path.of(fileObject.toUri()))));\n+\n+\n+            return javacBuilder;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static JavacBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+        JavacBuilder javacBuilder = new JavacBuilder();\n+        javacBuilderConsumer.accept(javacBuilder);\n+        return javac(javacBuilder);\n+    }\n+\n+    public static class JarBuilder extends Builder<JarBuilder> {\n+        public JarFile jar;\n+        public JavacBuilder javacBuilder;\n+        public List<DirPathHolder<?>> dirList;\n+\n+        public JarBuilder basedOn(JarBuilder stem) {\n+            super.basedOn(stem);\n+            if (stem != null) {\n+                if (stem.jar != null) {\n+                    this.jar = stem.jar;\n+                }\n+                if (stem.dirList != null) {\n+                    this.dirList = new ArrayList<>(stem.dirList);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        public JarBuilder jar(JarFile jar) {\n+            this.jar = jar;\n+            return this;\n+        }\n+        public JarBuilder javac( JavacBuilder javacBuilder) {\n+            this.javacBuilder = Bldr.javac(javacBuilder);\n+            this.dirList = (this.dirList == null) ? new ArrayList<>() : this.dirList;\n+            this.dirList.add(this.javacBuilder.classDir);\n+            return this;\n+        }\n+        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n+            this.javacBuilder = new JavacBuilder();\n+            javacBuilderConsumer.accept(this.javacBuilder);\n+            return javac(this.javacBuilder);\n+        }\n+        public JarBuilder dir_list(Predicate<DirPathHolder<?>> predicate, DirPathHolder<?>... dirs) {\n+            Stream.of(dirs).filter(predicate).forEach(optionalDir->{\n+                this.dirList = (this.dirList == null) ? new ArrayList<>() : this.dirList;\n+                this.dirList.add(optionalDir);\n+            });\n+            return this;\n+        }\n+        public JarBuilder dir_list(DirPathHolder<?>... dirs) {\n+            return dir_list(_->true, dirs);\n+        }\n+        @Override\n+        public JarBuilder show(Consumer<String> stringConsumer) {\n+            return self();\n+        }\n+    }\n+\n+    public static JarFile jar(Consumer<JarBuilder> jarBuilderConsumer) {\n+        try {\n+            JarBuilder jarBuilder = new JarBuilder();\n+            jarBuilderConsumer.accept(jarBuilder);\n+\n+            List<RootDirAndSubPath> pathsToJar = new ArrayList<>();\n+            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar.path()));\n+            jarBuilder.dirList.forEach(root -> root\n+                    .findFiles()\n+                    .map(path -> new RootDirAndSubPath(root, path))\n+                    .forEach(pathsToJar::add));\n+            pathsToJar.stream().sorted(Comparator.comparing(RootDirAndSubPath::path)).forEach(rootAndPath -> {\n+                try {\n+                    var entry = new JarEntry(rootAndPath.relativize().toString());\n+                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                    jarStream.putNextEntry(entry);\n+                    Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                    jarStream.closeEntry();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            jarStream.finish();\n+            jarStream.close();\n+            return jarBuilder.jar;\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+    }\n+\n+    public static class JavaBuilder extends ExecBuilder<JavaBuilder> {\n+        public Path jdk = Path.of(System.getProperty(\"java.home\"));\n+        public String mainClass;\n+        public List<ClassPathEntry> classPath;\n+        public List<DirPathHolder<?>> libraryPath;\n+        public List<String> vmopts = new ArrayList<>();\n+        public List<String> args = new ArrayList<>();\n+        @Override\n+        public JavaBuilder show(Consumer<String> stringConsumer) {\n+            return self();\n+        }\n+        public JavaBuilder vmopts(List<String> opts) {\n+            this.vmopts.addAll(opts);\n+            return self();\n+        }\n+\n+        public JavaBuilder vmopts(String... opts) {\n+            vmopts(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+\n+        public JavaBuilder args(List<String> opts) {\n+            this.args.addAll(opts);\n+            return self();\n+        }\n+\n+        public JavaBuilder args(String... opts) {\n+            args(Arrays.asList(opts));\n+            return self();\n+        }\n+\n+\n+        public JavaBuilder basedOn(JavaBuilder stem) {\n+            super.basedOn(stem);\n+            if (stem != null) {\n+                vmopts.addAll(stem.vmopts);\n+                args.addAll(stem.args);\n+                if (stem.mainClass != null) {\n+                    this.mainClass = stem.mainClass;\n+                }\n+                if (stem.jdk != null) {\n+                    this.jdk = stem.jdk;\n+                }\n+                if (stem.classPath != null) {\n+                    this.classPath = new ArrayList<>(stem.classPath);\n+                }\n+\n+                opts.addAll(stem.opts);\n+\n+            }\n+            return this;\n+        }\n+\n+        public JavaBuilder main_class(String mainClass) {\n+            this.mainClass = mainClass;\n+            return this;\n+        }\n+\n+        public JavaBuilder jdk(Path jdk) {\n+            this.jdk = jdk;\n+            return this;\n+        }\n+\n+        public JavaBuilder class_path(List<ClassPathEntry> classPathEntries) {\n+            this.classPath = (this.classPath == null) ? new ArrayList<>() : this.classPath;\n+            this.classPath.addAll(classPathEntries);\n+            return this;\n+        }\n+\n+        public JavaBuilder class_path(ClassPathEntry... classPathEntries) {\n+            return this.class_path(List.of(classPathEntries));\n+        }\n+        public JavaBuilder library_path(List<DirPathHolder<?>> libraryPathEntries) {\n+            this.libraryPath = (this.libraryPath == null) ? new ArrayList<>() : this.libraryPath;\n+            this.libraryPath.addAll(libraryPathEntries);\n+            return this;\n+        }\n+        public JavaBuilder library_path(DirPathHolder<?>... libraryPathEntries) {\n+            return this.library_path(List.of(libraryPathEntries));\n+        }\n+\n+        @Override\n+        public List<String> execOpts() {\n+            List<String> execOpts = new ArrayList<>();\n+            execOpts.add(jdk.resolve(\"bin\/java\").toString());\n+            execOpts.addAll(vmopts);\n+            if (classPath != null) {\n+                execOpts.addAll(List.of(\"--class-path\", charSeparatedClassPath(classPath)));\n+            }\n+            if (libraryPath!= null) {\n+                execOpts.add(\"-Djava.library.path=\"+ charSeparatedDirPathHolders(libraryPath));\n+            }\n+            execOpts.add(mainClass);\n+            execOpts.addAll(args);\n+            return execOpts;\n+        }\n+    }\n+    public static JavaBuilder java(JavaBuilder javaBuilder) {\n+        javaBuilder.execInheritIO();\n+        return javaBuilder;\n+    }\n+\n+    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n+        JavaBuilder javaBuilder = new JavaBuilder();\n+        javaBuilderConsumer.accept(javaBuilder);\n+        return java(javaBuilder);\n+    }\n+\n+    public static JavaBuilder javaBuilder() {\n+        return new JavaBuilder();\n+    }\n+\n+\n+    public static class CMakeBuilder extends ExecBuilder<CMakeBuilder> {\n+        public List<String> libraries = new ArrayList<>();\n+        public CMakeBuildDir cmakeBuildDir;\n+        public Dir sourceDir;\n+        private Path output;\n+        public BuildDir copyToDir;\n+\n+        public CMakeBuilder() {\n+            opts.add(\"cmake\");\n+        }\n+        @Override\n+        public CMakeBuilder show(Consumer<String> stringConsumer) {\n+            return self();\n+        }\n+        public CMakeBuilder basedOn(CMakeBuilder stem) {\n+            \/\/ super.basedOn(stem); you will get two cmakes ;)\n+            if (stem != null) {\n+                if (stem.output != null) {\n+                    this.output = stem.output;\n+                }\n+                if (stem.copyToDir != null) {\n+                    this.copyToDir = stem.copyToDir;\n+                }\n+                if (stem.libraries != null) {\n+                    this.libraries = new ArrayList<>(stem.libraries);\n+                }\n+                if (stem.cmakeBuildDir != null) {\n+                    this.cmakeBuildDir = stem.cmakeBuildDir;\n+                }\n+                if (stem.sourceDir != null) {\n+                    this.sourceDir = stem.sourceDir;\n+                }\n+            }\n+            return this;\n+        }\n+\n+        public CMakeBuilder build_dir(CMakeBuildDir cmakeBuildDir) {\n+            this.cmakeBuildDir = cmakeBuildDir;\n+            opts(\"-B\", cmakeBuildDir.path.toString());\n+            return this;\n+        }\n+        public CMakeBuilder copy_to(BuildDir copyToDir) {\n+            this.copyToDir = copyToDir;\n+            opts(\"-DHAT_TARGET=\" +this.copyToDir.path().toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder source_dir(Dir sourceDir) {\n+            this.sourceDir = sourceDir;\n+            opts(\"-S\", sourceDir.path().toString());\n+            return this;\n+        }\n+\n+        public CMakeBuilder build(CMakeBuildDir cmakeBuildDir) {\n+            this.cmakeBuildDir = cmakeBuildDir;\n+            opts(\"--build\", cmakeBuildDir.path().toString());\n+            return this;\n+        }\n+\n+        @Override\n+        public List<String> execOpts() {\n+            return opts;\n+        }\n+    }\n+\n+    public static void cmake(Consumer<CMakeBuilder> cmakeBuilderConsumer) {\n+\n+        CMakeBuilder cmakeBuilder = new CMakeBuilder();\n+        cmakeBuilderConsumer.accept(cmakeBuilder);\n+        cmakeBuilder.cmakeBuildDir.create();\n+        cmakeBuilder.execInheritIO();\n+    }\n+\n+\n+    static Path unzip(Path in, Path dir) {\n+        try {\n+            Files.createDirectories(dir);\n+            ZipFile zip = new ZipFile(in.toFile());\n+            zip.entries().asIterator().forEachRemaining(entry -> {\n+                try {\n+                    String currentEntry = entry.getName();\n+\n+                    Path destFile = dir.resolve(currentEntry);\n+                    \/\/destFile = new File(newPath, destFile.getName());\n+                    Path destinationParent = destFile.getParent();\n+                    Files.createDirectories(destinationParent);\n+                    \/\/ create the parent directory structure if needed\n+\n+\n+                    if (!entry.isDirectory()) {\n+                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(ioe);\n+                }\n+            });\n+            zip.close();\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return dir;\n+    }\n+\n+    public static class JExtractBuilder extends ExecBuilder<JExtractBuilder> {\n+        public List<String> compileFlags = new ArrayList<>();\n+        public List<Path> libraries = new ArrayList<>();\n+        public List<Path> headers = new ArrayList<>();\n+        public Path cwd;\n+\n+        public Path home;\n+        private String targetPackage;\n+        private Path output;\n+        @Override\n+        public JExtractBuilder show(Consumer<String> stringConsumer) {\n+            return self();\n+        }\n+        public JExtractBuilder() {\n+            opts.add(\"jextract\");\n+        }\n+\n+        public JExtractBuilder basedOn(JExtractBuilder stem) {\n+            super.basedOn(stem);\n+            if (stem != null) {\n+                if (stem.output != null) {\n+                    this.output = stem.output;\n+                }\n+                if (stem.compileFlags != null) {\n+                    this.compileFlags = new ArrayList<>(stem.compileFlags);\n+                }\n+                if (stem.libraries != null) {\n+                    this.libraries = new ArrayList<>(stem.libraries);\n+                }\n+                if (stem.home != null) {\n+                    this.home = stem.home;\n+                }\n+                if (stem.cwd != null) {\n+                    this.cwd = stem.cwd;\n+                }\n+                if (stem.headers != null) {\n+                    this.headers = new ArrayList<>(stem.headers);\n+                }\n+            }\n+            return this;\n+        }\n+\n+\n+        public JExtractBuilder cwd(Path cwd) {\n+            this.cwd = cwd;\n+            return this;\n+        }\n+\n+        public JExtractBuilder home(Path home) {\n+            this.home = home;\n+            opts.set(0, home.resolve(\"bin\/jextract\").toString());\n+            return this;\n+        }\n+\n+        public JExtractBuilder opts(String... opts) {\n+            this.opts.addAll(Arrays.asList(opts));\n+            return this;\n+        }\n+\n+        public JExtractBuilder target_package(String targetPackage) {\n+            this.targetPackage = targetPackage;\n+            opts(\"--target-package\", targetPackage);\n+            return this;\n+        }\n+\n+        public JExtractBuilder output(Path output) {\n+            this.output = output;\n+            opts(\"--output\", output.toString());\n+            return this;\n+        }\n+\n+        public JExtractBuilder library(Path... libraries) {\n+            this.libraries.addAll(Arrays.asList(libraries));\n+            for (Path library : libraries) {\n+                opts(\"--library\", \":\" + library);\n+            }\n+            return this;\n+        }\n+\n+        public JExtractBuilder compile_flag(String... compileFlags) {\n+            this.compileFlags.addAll(Arrays.asList(compileFlags));\n+            return this;\n+        }\n+\n+        public JExtractBuilder header(Path header) {\n+            this.headers.add(header);\n+            this.opts.add(header.toString());\n+            return this;\n+        }\n+\n+        @Override\n+        public List<String> execOpts() {\n+            return opts;\n+        }\n+    }\n+\n+    public static void jextract(Consumer<JExtractBuilder> jextractBuilderConsumer) {\n+        JExtractBuilder extractConfig = new JExtractBuilder();\n+        jextractBuilderConsumer.accept(extractConfig);\n+        System.out.println(extractConfig.opts);\n+        var compilerFlags = extractConfig.cwd.resolve(\"compiler_flags.txt\");\n+        try {\n+            PrintWriter compilerFlagsWriter = new PrintWriter(Files.newOutputStream(compilerFlags));\n+            compilerFlagsWriter.println(extractConfig.compileFlags);\n+            compilerFlagsWriter.close();\n+            Files.createDirectories(extractConfig.output);\n+            extractConfig.execInheritIO(extractConfig.cwd);\n+            Files.deleteIfExists(compilerFlags);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+\n+\n+    public record SearchableTextFile(Path path) implements TextFile {\n+        public Stream<Line> lines() {\n+            try {\n+                int num[] = new int[]{1};\n+                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream().map(line -> new Line(line, num[0]++));\n+            } catch (IOException ioe) {\n+                System.out.println(ioe);\n+                return new ArrayList<Line>().stream();\n+            }\n+        }\n+\n+        public boolean grep(Pattern pattern) {\n+            return lines().anyMatch(line -> pattern.matcher(line.line).matches());\n+        }\n+\n+        public boolean hasSuffix(String... suffixes) {\n+            var suffixSet = Set.of(suffixes);\n+            int dotIndex = path().toString().lastIndexOf('.');\n+            return dotIndex == -1 || suffixSet.contains(path().toString().substring(dotIndex + 1));\n+        }\n+    }\n+\n+    public record Line(String line, int num) {\n+        public boolean grep(Pattern pattern) {\n+            return pattern.matcher(line()).matches();\n+        }\n+    }\n+\n+    public static Path curl(URL url, Path file) {\n+        try {\n+            println(\"Downloading \" + url + \"->\" + file);\n+            url.openStream().transferTo(Files.newOutputStream(file));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return file;\n+    }\n+\n+    public static Optional<Path> which(String execName) {\n+        \/\/ which and whereis had issues.\n+        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n+                .map(dirName -> Path.of(dirName).resolve(execName).normalize())\n+                .filter(Files::isExecutable).findFirst();\n+    }\n+\n+    public static boolean canExecute(String execName) {\n+        \/\/ which and whereis had issues.\n+        return which(execName).isPresent();\n+    }\n+\n+    public static Path untar(Path tarFile, Path dir) {\n+        try {\n+            new ProcessBuilder().inheritIO().command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString()).start().waitFor();\n+            return dir;\n+        } catch (\n+                InterruptedException e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted means it exists\n+            return null;\n+        } catch (IOException e) { \/\/ We get IOException if the executable not found, at least on Mac\n+            \/\/throw new RuntimeException(e);\n+            return null;\n+        }\n+    }\n+\n+\n+\n+\n+    public record Root(Path path) implements DirPathHolder<Root> {\n+        public BuildDir buildDir() {\n+            return BuildDir.of(path(\"build\")).create();\n+        }\n+\n+        public BuildDir thirdPartyDir() {\n+            return BuildDir.of(path(\"thirdparty\")).create();\n+        }\n+\n+        public BuildDir repoDir() {\n+            return BuildDir.of(path(\"repoDir\")).create();\n+        }\n+\n+        public Root() {\n+            this(Path.of(System.getProperty(\"user.dir\")));\n+        }\n+    }\n+\n+\n+        public static Path requireJExtract(Dir thirdParty) {\n+            var optional = executablesInPath(\"jextract\").findFirst();\n+            if (optional.isPresent()) {\n+                println(\"Found jextract in PATH\");\n+                return optional.get().getParent().getParent(); \/\/ we want the 'HOME' dir\n+            }\n+            println(\"No jextract in PATH\");\n+            URL downloadURL = null;\n+            var extractVersionMaj = \"22\";\n+            var extractVersionMin = \"5\";\n+            var extractVersionPoint = \"33\";\n+\n+\n+            var nameArchTuple = switch (os.name()) {\n+                case OS.MacName -> \"macos\";\n+                default -> os.name().toLowerCase();\n+            } + '-' + os.arch();\n+\n+            try {\n+                downloadURL = new URI(\"https:\/\/download.java.net\/java\/early_access\"\n+                        + \"\/jextract\/\" + extractVersionMaj + \"\/\" + extractVersionMin\n+                        + \"\/openjdk-\" + extractVersionMaj + \"-jextract+\" + extractVersionMin + \"-\" + extractVersionPoint + \"_\"\n+                        + nameArchTuple + \"_bin.tar.gz\").toURL();\n+            } catch (MalformedURLException e) {\n+                throw new RuntimeException(e);\n+            } catch (URISyntaxException e) {\n+                throw new RuntimeException(e);\n+            }\n+            URL finalDownloadURL = downloadURL;\n+\n+            println(\"... attempting download from\" + downloadURL);\n+            var jextractTar = thirdParty.path(\"jextract.tar\");\n+\n+            if (!isRegularFile(jextractTar)) { \/\/ Have we downloaded already?\n+                jextractTar = curl(finalDownloadURL, jextractTar); \/\/ if not\n+            }\n+\n+            var jextractHome = thirdParty.path(\"jextract-22\");\n+            if (!isDirectory(jextractHome)) {\n+                untar(jextractTar, jextractHome);\n+            }\n+            return jextractHome;\n+\n+        }\n+\n+\n+\n+    public static Stream<Path> executablesInPath(String name) {\n+        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n+                .map(dirName -> Path.of(dirName).resolve(name).normalize())\n+                .filter(Files::isExecutable);\n+\n+    }\n+\n+    public static void sanity(Root hatDir) {\n+        var rleParserDir = hatDir.path().resolve(\"examples\/life\/src\/main\/java\/io\");\n+        Dir.of(hatDir.path).forEachSubDirectory( \"hat\", \"examples\", \"backends\", \"docs\").forEach(dir ->{\n+                dir.findFiles()\n+                        .filter((path)->Pattern.matches(\"^.*\\\\.(java|cpp|h|hpp|md)\", path.toString()))\n+                        .forEach(path -> println(path));\n+\n+                dir.findTextFiles(\"java\", \"cpp\", \"h\", \"hpp\", \"md\")\n+                        .forEach(searchableTextFile -> {\n+                            if (!searchableTextFile.path().getFileName().toString().equals(\"Makefile\") && !searchableTextFile.hasSuffix(\"md\")\n+                                    && !searchableTextFile.path().startsWith(rleParserDir)\n+                                    && !searchableTextFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n+                                System.err.println(\"ERR MISSING LICENSE \" + searchableTextFile.path());\n+                            }\n+                            searchableTextFile.lines().forEach(line -> {\n+                                if (!searchableTextFile.path().getFileName().toString().startsWith(\"Makefile\") && line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n+                                    System.err.println(\"ERR TAB \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                                }\n+                                if (line.grep(Pattern.compile(\"^.* $\"))) {\n+                                    System.err.println(\"ERR TRAILING WHITESPACE \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n+                                }\n+                            });\n+                        });}\n+        );\n+    }\n+\n+    public static <T> T assertOrThrow(T testme, Predicate<T> predicate, String message){\n+        if (predicate.test(testme)) {\n+            return testme;\n+        }else{\n+            throw new IllegalStateException(\"FAILED: \"+message+\" \"+testme);\n+        }\n+    }\n+\n+    public static <T extends PathHolder> T assertExists(T testme){\n+        if (Files.exists(testme.path())) {\n+            return testme;\n+        }else{\n+            throw new IllegalStateException(\"FAILED: \"+testme.path()+\" does not exist\");\n+        }\n+    }\n+    public static <T extends Path> T assertExists(T path){\n+        if (Files.exists(path)) {\n+            return path;\n+        }else{\n+            throw new IllegalStateException(\"FAILED: \"+path+\" does not exist\");\n+        }\n+    }\n+\n+    void main(String[] args) {\n+        var bldrDir = Dir.current().parent().parent().parent();\n+        var buildDir =BuildDir.of(bldrDir.path(\"build\")).create();\n+\n+        jar($->$\n+                .jar(buildDir.jarFile(\"bldr.jar\"))\n+                .javac($$->$$\n+                        .opts(\n+                                \"--source\", \"24\",\n+                                \"--enable-preview\",\n+                                \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n+                                \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n+                        )\n+                        .class_dir(buildDir.classDir(\"bld.jar.classes\"))\n+                        .source_path(bldrDir.dir(\"src\/main\/java\"))\n+                )\n+        );\n+    }\n+}\n","filename":"hat\/bldr\/Bldr.java","additions":1278,"deletions":0,"binary":false,"changes":1278,"status":"added"},{"patch":"@@ -1,2029 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package bldr;\n-\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.NodeList;\n-\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticListener;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.xml.transform.OutputKeys;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpression;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.net.URL;\n-import java.net.URLEncoder;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.LinkOption;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.PosixFileAttributes;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Consumer;\n-import java.util.function.Predicate;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-import java.util.zip.ZipFile;\n-\n-import static java.io.IO.println;\n-import static java.nio.file.Files.isDirectory;\n-import static java.nio.file.Files.isRegularFile;\n-\n-public class Bldr {\n-    public interface PathHolder {\n-        Path path();\n-    }\n-\n-    public interface TargetDirProvider extends PathHolder {\n-        Path targetDir();\n-    }\n-\n-    public interface JavaSourceDirProvider {\n-        Path javaSourceDir();\n-    }\n-\n-    public interface ResourceDirProvider {\n-        Path resourcesDir();\n-    }\n-\n-    public interface DirPathHolder extends PathHolder {\n-        public default Path subDir(String subdir){\n-            return path().resolve(subdir);\n-        }\n-    }\n-\n-    public interface FilePathHolder extends PathHolder {\n-    }\n-\n-    public interface ClassPathEntry extends PathHolder {\n-    }\n-\n-    public record ClassDir(Path path) implements ClassPathEntry, DirPathHolder {\n-    }\n-\n-    public record BuildDir(Path path) implements ClassPathEntry, DirPathHolder {\n-    }\n-\n-    public record JarFile(Path path) implements ClassPathEntry, FilePathHolder {\n-    }\n-\n-    public record SourcePathEntry(Path path) implements DirPathHolder {\n-    }\n-\n-    public interface TextFile extends FilePathHolder{\n-\n-    }\n-\n-    public interface SourceFile extends TextFile {\n-    }\n-\n-    public static class JavaSourceFile extends SimpleJavaFileObject implements SourceFile {\n-         Path path;\n-\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                try {\n-                    return Files.readString(Path.of(toUri()));\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-\n-        JavaSourceFile(Path path) {\n-         super(path.toUri(), JavaFileObject.Kind.SOURCE);\n-\n-        }\n-\n-        @Override\n-        public Path path() {\n-            return null;\n-        }\n-    }\n-\n-    public record CppSourceFile(Path path) implements SourceFile {\n-    }\n-\n-    public record CppHeaderSourceFile(Path path) implements SourceFile {\n-    }\n-\n-\n-    public record ClassPath(List<ClassPathEntry> entries) {\n-    }\n-\n-    public record SourcePath(List<SourcePathEntry> entries) {\n-    }\n-\n-    public record XMLFile(Path path) implements TextFile {\n-    }\n-\n-    public static class Repo {\n-\n-        private final String repoBase = \"https:\/\/repo1.maven.org\/maven2\/\";\n-        private final String searchBase = \"https:\/\/search.maven.org\/solrsearch\/\";\n-        private Path path;\n-\n-        public record Id(Repo repo, String groupId, String artifactId, String versionId) {\n-            static String groupId(XMLNode xmlNode) {\n-                return xmlNode.xpathQueryString(\"groupId\/text()\");\n-            }\n-\n-            static String artifactId(XMLNode xmlNode) {\n-                return xmlNode.xpathQueryString(\"artifactId\/text()\");\n-            }\n-\n-            static String versionId(XMLNode xmlNode) {\n-                return xmlNode.xpathQueryString(\"versionId\/text()\");\n-            }\n-\n-            public Id(Repo repo, XMLNode xmlNode) {\n-                this(repo, groupId(xmlNode), artifactId(xmlNode), versionId(xmlNode));\n-            }\n-\n-            private String artifactAndVersion() {\n-                return artifactId() + '-' + versionId();\n-            }\n-\n-            private String pathName() {\n-                return groupId() + '.' + artifactAndVersion();\n-            }\n-\n-            private String name(String suffix) {\n-                return artifactAndVersion() + \".\" + suffix;\n-            }\n-        }\n-\n-\n-        public Repo(Path path) {\n-            this.path = path;\n-        }\n-\n-        public XMLNode select(String query) {\n-            try {\n-                URL url = new URI(searchBase + \"select?q=\" +\n-                        URLEncoder.encode(query, StandardCharsets.UTF_8)\n-                        + \"&core=gav&wt=xml\").toURL();\n-                try {\n-                    return new XMLNode(url);\n-                } catch (Throwable e) {\n-                    throw new RuntimeException(e);\n-                }\n-            } catch (MalformedURLException | URISyntaxException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public XMLNode queryXMLByGroup(String groupId) {\n-            return select(\"g:\" + groupId);\n-        }\n-\n-        public XMLNode queryXMLByArtifact(String artifactId) {\n-            return select(\"a:\" + artifactId);\n-        }\n-\n-        public XMLNode queryByGroupAndArtifact(String groupId, String artifactId) {\n-            return select(\"g:\" + groupId + \" AND a:\" + artifactId);\n-        }\n-\n-        public XMLNode queryByGroupArtifactAndVersion(String groupId, String artifactId, String versionId) {\n-            return select(\"g:\" + groupId + \" AND a:\" + artifactId + \" AND v:\" + versionId);\n-        }\n-\n-        public Optional<Id> id(String groupId, String artifactId, String versionId) {\n-            var xmlNode = queryByGroupArtifactAndVersion(groupId, artifactId, versionId);\n-            var numFound = xmlNode.xpathQueryString(\"\/response\/result\/@numFound\");\n-            if (numFound.isEmpty() || numFound.equals(\"0\")) {\n-                return Optional.empty();\n-            } else {\n-                return Optional.of(new Id(this, groupId, artifactId, versionId));\n-            }\n-        }\n-\n-        public Stream<String> versions(String groupId, String artifactId) {\n-            var xmlNode = queryByGroupAndArtifact(groupId, artifactId);\n-            return xmlNode.xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n-                    .map(xmln -> xmln.xpathQueryString(\"str[@name='v']\/text()\"));\n-        }\n-\n-        public boolean forEachVersion(String groupId, String artifactId, Consumer<String> idConsumer) {\n-            boolean[] found = new boolean[]{false};\n-            versions(groupId, artifactId).forEach(id -> {\n-                idConsumer.accept(id);\n-                found[0] = true;\n-            });\n-            return found[0];\n-        }\n-\n-        public Stream<Id> ids(String groupId, String artifactId) {\n-            var xmlNode = queryByGroupAndArtifact(groupId, artifactId);\n-            var numFound = xmlNode.xpathQueryString(\"\/response\/result\/@numFound\");\n-            if (numFound.isEmpty() || numFound.equals(\"0\")) {\n-                return Stream.empty();\n-            } else {\n-                return xmlNode.xmlNodes(xmlNode.xpath(\"\/response\/result\/doc\"))\n-                        .map(xmln -> {\n-                            var a = xmln.xpathQueryString(\"str[@name='a']\/text()\");\n-                            var g = xmln.xpathQueryString(\"str[@name='g']\/text()\");\n-                            var v = xmln.xpathQueryString(\"str[@name='v']\/text()\");\n-                            return new Id(this, g, a, v);\n-                        });\n-            }\n-        }\n-\n-        public boolean forEachId(String groupId, String artifactId, Consumer<Id> idConsumer) {\n-            boolean[] found = new boolean[]{false};\n-            ids(groupId, artifactId).forEach(id -> {\n-                idConsumer.accept(id);\n-                found[0] = true;\n-            });\n-            return found[0];\n-        }\n-\n-    }\n-\n-    public interface OS {\n-        String arch();\n-\n-        String name();\n-\n-        String version();\n-\n-        static final String MacName = \"Mac OS X\";\n-        static final String LinuxName = \"Linux\";\n-\n-        default String nameArchTuple() {\n-            return switch (name()) {\n-                case MacName -> \"macos\";\n-                default -> name().toLowerCase();\n-            } + '-' + arch();\n-        }\n-\n-        record Linux(String arch, String name, String version) implements OS {\n-        }\n-\n-        record Mac(String arch, String name, String version) implements OS {\n-            public Path appLibFrameworks() {\n-                return Path.of(\"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/\"\n-                        + \"MacOSX.sdk\/System\/Library\/Frameworks\");\n-            }\n-\n-            public Path frameworkHeader(String frameworkName, String headerFileName) {\n-                return appLibFrameworks().resolve(frameworkName + \".framework\/Headers\/\" + headerFileName);\n-            }\n-\n-            public Path libFrameworks() {\n-                return Path.of(\"\/System\/Library\/Frameworks\");\n-            }\n-\n-            public Path frameworkLibrary(String frameworkName) {\n-                return libFrameworks().resolve(frameworkName + \".framework\/\" + frameworkName);\n-            }\n-        }\n-\n-        static OS get() {\n-            String arch = System.getProperty(\"os.arch\");\n-            String name = System.getProperty(\"os.name\");\n-            String version = System.getProperty(\"os.version\");\n-            return switch (name) {\n-\n-                case \"Mac OS X\" -> new Mac(arch, name, version);\n-                case \"Linux\" -> new Linux(arch, name, version);\n-                default -> throw new IllegalStateException(\"No os mapping for \" + name);\n-            };\n-        }\n-    }\n-\n-\n-    public static OS os = OS.get();\n-\n-    public record Java(String version, File home) {\n-    }\n-\n-    public static Java java = new Java(System.getProperty(\"java.version\"), new File(System.getProperty(\"java.home\")));\n-\n-    public record User(File home, File pwd) {\n-    }\n-\n-    public static User user = new User(new File(System.getProperty(\"user.home\")), new File(System.getProperty(\"user.dir\")));\n-\n-\n-    public static class XMLNode {\n-        org.w3c.dom.Element element;\n-        List<XMLNode> children = new ArrayList<>();\n-        Map<String, String> attrMap = new HashMap<>();\n-\n-        XMLNode(org.w3c.dom.Element element) {\n-            this.element = element;\n-            this.element.normalize();\n-            NodeList nodeList = element.getChildNodes();\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                if (nodeList.item(i) instanceof org.w3c.dom.Element e) {\n-                    this.children.add(new XMLNode(e));\n-                }\n-            }\n-            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n-                if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr) {\n-                    this.attrMap.put(attr.getName(), attr.getValue());\n-                }\n-            }\n-        }\n-\n-        public boolean hasAttr(String name) {\n-            return attrMap.containsKey(name);\n-        }\n-\n-        public String attr(String name) {\n-            return attrMap.get(name);\n-        }\n-\n-        XMLNode(Path path) throws Throwable {\n-            this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(path.toFile()).getDocumentElement());\n-        }\n-\n-        XMLNode(File file) throws Throwable {\n-            this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file).getDocumentElement());\n-        }\n-\n-        XMLNode(URL url) throws Throwable {\n-            this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(url.openStream()).getDocumentElement());\n-        }\n-\n-        void write(StreamResult streamResult) throws Throwable {\n-            var transformer = TransformerFactory.newInstance().newTransformer();\n-            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-            transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n-        }\n-\n-        void write(File file) throws Throwable {\n-            write(new StreamResult(file));\n-        }\n-\n-        @Override\n-        public String toString() {\n-            var stringWriter = new StringWriter();\n-            try {\n-                var transformer = TransformerFactory.newInstance().newTransformer();\n-                transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n-                transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n-                transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n-                transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n-                return stringWriter.toString();\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-        }\n-\n-        XPathExpression xpath(String expression) {\n-            XPath xpath = XPathFactory.newInstance().newXPath();\n-            try {\n-                return xpath.compile(expression);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Node node(XPathExpression xPathExpression) {\n-            try {\n-                return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        String str(XPathExpression xPathExpression) {\n-            try {\n-                return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        String xpathQueryString(String xpathString) {\n-            try {\n-                return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        NodeList nodeList(XPathExpression xPathExpression) {\n-            try {\n-                return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n-            } catch (XPathExpressionException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        Stream<org.w3c.dom.Node> nodes(XPathExpression xPathExpression) {\n-            var nodeList = nodeList(xPathExpression);\n-            List<org.w3c.dom.Node> nodes = new ArrayList<>();\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                nodes.add(nodeList.item(i));\n-            }\n-            return nodes.stream();\n-        }\n-\n-        Stream<org.w3c.dom.Element> elements(XPathExpression xPathExpression) {\n-            return nodes(xPathExpression).filter(n -> n instanceof org.w3c.dom.Element).map(n -> (Element) n);\n-        }\n-\n-        Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n-            return elements(xPathExpression).map(e -> new XMLNode(e));\n-        }\n-    }\n-\n-    \/*\n-        static class POM {\n-            static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n-            static public String varExpand(Map<String, String> props, String value) { \/\/ recurse\n-                String result = value;\n-                if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n-                    var v = matcher.groupId(1);\n-                    result = varExpand(props, value.substring(0, matcher.start())\n-                            + (v.startsWith(\"env\")\n-                            ? System.getenv(v.substring(4))\n-                            : props.get(v))\n-                            + value.substring(matcher.end()));\n-                    \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n-                }\n-                return result;\n-            }\n-\n-            POM(Path dir) throws Throwable {\n-                var topPom = new XMLNode(new File(dir.toFile(), \"pom.xml\"));\n-                var babylonDirKey = \"babylon.dir\";\n-                var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n-                var hatDirKey = \"hat.dir\";\n-                var interestingKeys = Set.of(spirvDirKey, babylonDirKey, hatDirKey);\n-                var requiredDirKeys = Set.of(babylonDirKey, hatDirKey);\n-                var dirKeyToDirMap = new HashMap<String, File>();\n-                var props = new HashMap<String, String>();\n-\n-                topPom.children.stream().filter(e -> e.element.getNodeName().equals(\"properties\")).forEach(properties ->\n-                        properties.children.stream().forEach(property -> {\n-                            var key = property.element.getNodeName();\n-                            var value = varExpand(props, property.element.getTextContent());\n-                            props.put(key, value);\n-                            if (interestingKeys.contains(key)) {\n-                                var file = new File(value);\n-                                if (requiredDirKeys.contains(key) && !file.exists()) {\n-                                    System.err.println(\"ERR pom.xml has property '\" + key + \"' with value '\" + value + \"' but that dir does not exists!\");\n-                                    System.exit(1);\n-                                }\n-                                dirKeyToDirMap.put(key, file);\n-                            }\n-                        })\n-                );\n-                for (var key : requiredDirKeys) {\n-                    if (!props.containsKey(key)) {\n-                        System.err.println(\"ERR pom.xml expected to have property '\" + key + \"' \");\n-                        System.exit(1);\n-                    }\n-                }\n-            }\n-        }\n-    *\/\n-    public static String pathCharSeparated(List<Path> paths) {\n-        StringBuilder sb = new StringBuilder();\n-        paths.forEach(path -> {\n-            if (!sb.isEmpty()) {\n-                sb.append(File.pathSeparatorChar);\n-            }\n-            sb.append(path);\n-        });\n-        return sb.toString();\n-    }\n-\n-    public static Path rmdir(Path path) {\n-        try {\n-            if (Files.exists(path)) {\n-                Files.walk(path).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n-            }\n-        } catch (IOException ioe) {\n-            System.out.println(ioe);\n-        }\n-        return path;\n-    }\n-\n-    public static Stream<Path> subDirStream(Path path, String... dirNames) {\n-        return Stream.of(dirNames).map(path::resolve).filter(Files::isDirectory);\n-    }\n-\n-    public static void forEachSubDir(Path path, Stream<String> dirNames, Consumer<Path> pathConsumer) {\n-        dirNames.map(path::resolve).filter(Files::isDirectory).forEach(pathConsumer);\n-    }\n-\n-    public static void forEachSubDir(Path path, Consumer<Path> pathConsumer) {\n-        try {\n-            Files.walk(path, 1).filter(file -> !file.equals(path)).filter(Files::isDirectory).forEach(pathConsumer);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static Stream<Path> findFiles(Path dir) {\n-        return find(dir, Files::isRegularFile);\n-    }\n-\n-    public static Stream<Path> findDirs(Path dir) {\n-        return find(dir, Files::isDirectory);\n-    }\n-\n-    public static Stream<Path> findFiles(Path dir, Predicate<Path> predicate) {\n-        return findFiles(dir).filter(predicate);\n-    }\n-\n-    public static Stream<SearchableTextFile> findTextFiles(Path dir, String... suffixes) {\n-        return findFiles(dir).map(SearchableTextFile::new).filter(searchableTextFile -> searchableTextFile.hasSuffix(suffixes));\n-    }\n-\n-    public static Stream<Path> findDirs(Path dir, Predicate<Path> predicate) {\n-        return find(dir, Files::isDirectory).filter(predicate);\n-    }\n-\n-    public static class Builder<T extends Builder<T>> {\n-        @SuppressWarnings(\"unchecked\") T self() {\n-            return (T) this;\n-        }\n-\n-        public List<String> opts = new ArrayList<>();\n-\n-        public T opts(List<String> opts) {\n-            this.opts.addAll(opts);\n-            return self();\n-        }\n-\n-        public T opts(String... opts) {\n-            opts(Arrays.asList(opts));\n-            return self();\n-        }\n-\n-        public T basedOn(T stem) {\n-            if (stem != null) {\n-                opts.addAll(stem.opts);\n-            }\n-            return self();\n-        }\n-\n-        public T when(boolean condition, Consumer<T> consumer) {\n-            if (condition) {\n-                consumer.accept(self());\n-            }\n-            return self();\n-        }\n-\n-        public T either(boolean condition, Consumer<T> trueConsumer, Consumer<T> falseConsumer) {\n-            if (condition) {\n-                trueConsumer.accept(self());\n-            } else {\n-                falseConsumer.accept(self());\n-            }\n-            return self();\n-        }\n-\n-    }\n-\n-    public static abstract class ExecBuilder<T extends ExecBuilder<T>> extends Builder<T> {\n-        abstract public List<String> execOpts();\n-\n-        public void execInheritIO(Path path) {\n-            try {\n-                var processBuilder = new ProcessBuilder();\n-\n-                if (path != null) {\n-                    processBuilder.directory(path.toFile());\n-                }\n-                processBuilder\n-                        .inheritIO()\n-                        .command(execOpts());\n-                var process = processBuilder\n-                        .start();\n-                process.waitFor();\n-            } catch (InterruptedException ie) {\n-                System.out.println(ie);\n-            } catch (IOException ioe) {\n-                System.out.println(ioe);\n-            }\n-        }\n-\n-        public void execInheritIO() {\n-            execInheritIO(null);\n-        }\n-    }\n-\n-    public static class JavacBuilder extends Builder<JavacBuilder> {\n-        public Path classesDir;\n-        public List<Path> sourcePath ;\n-        public List<Path> classPath;\n-\n-        public JavacBuilder basedOn(JavacBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                if (stem.classesDir != null) {\n-                    this.classesDir = stem.classesDir;\n-                }\n-                if (stem.sourcePath != null) {\n-                    this.sourcePath = new ArrayList<>(stem.sourcePath);\n-                }\n-                if (stem.classPath != null) {\n-                    this.classPath = new ArrayList<>(stem.classPath);\n-                }\n-            }\n-            return this;\n-        }\n-\n-        public JavacBuilder classes_dir(Path classesDir) {\n-            this.classesDir = classesDir;\n-            return this;\n-        }\n-\n-        public JavacBuilder source_path(Path... sourcePaths) {\n-            this.sourcePath = this.sourcePath == null ? new ArrayList<>() : this.sourcePath;\n-            this.sourcePath.addAll(Arrays.asList(sourcePaths));\n-            return this;\n-        }\n-\n-        public JavacBuilder class_path(Path... classPaths) {\n-            this.classPath = this.classPath == null ? new ArrayList<>() : this.classPath;\n-            this.classPath.addAll(Arrays.asList(classPaths));\n-            return this;\n-        }\n-    }\n-\n-    public static Stream<Path> find(Path dir) {\n-        try {\n-            return Files.walk(dir);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static Stream<Path> find(Path dir, Predicate<Path> predicate) {\n-        return find(dir).filter(predicate);\n-    }\n-\n-    record RootAndPath(Path root, Path path) {\n-        Path relativize() {\n-            return root().relativize(path());\n-        }\n-    }\n-\n-    public static JavacBuilder javac(JavacBuilder javacBuilder) {\n-        try {\n-            if (javacBuilder.classesDir == null) {\n-                javacBuilder.classesDir = Files.createTempDirectory(\"javacClasses\");\n-                \/\/   javacBuilder.classesDir = javacBuilder.jar.resolveSibling(javacBuilder.jar.getFileName().toString() + \".classes\");\n-            }\n-            javacBuilder.opts.addAll(List.of(\"-d\", javacBuilder.classesDir.toString()));\n-            mkdir(rmdir(javacBuilder.classesDir));\n-\n-            if (javacBuilder.classPath != null) {\n-                javacBuilder.opts.addAll(List.of(\"--class-path\", pathCharSeparated(javacBuilder.classPath)));\n-            }\n-\n-            javacBuilder.opts.addAll(List.of(\"--source-path\", pathCharSeparated(javacBuilder.sourcePath)));\n-            var compilationUnits = new ArrayList<JavaSourceFile>();\n-            javacBuilder.sourcePath.forEach(entry ->\n-                    findFiles(entry, file -> file.toString().endsWith(\".java\"))\n-                            .map(JavaSourceFile::new)\n-                            .forEach(compilationUnits::add));\n-\n-            DiagnosticListener<JavaFileObject> dl = (diagnostic) -> {\n-                if (!diagnostic.getKind().equals(Diagnostic.Kind.NOTE)) {\n-                    System.out.println(diagnostic.getKind()\n-                            + \" \" + diagnostic.getLineNumber() + \":\" + diagnostic.getColumnNumber() + \" \" + diagnostic.getMessage(null));\n-                }\n-            };\n-\n-            \/\/   List<RootAndPath> pathsToJar = new ArrayList<>();\n-            JavaCompiler javac = javax.tools.ToolProvider.getSystemJavaCompiler();\n-            JavaCompiler.CompilationTask compilationTask = (javac.getTask(\n-                    new PrintWriter(System.err),\n-                    javac.getStandardFileManager(dl, null, null),\n-                    dl,\n-                    javacBuilder.opts,\n-                    null,\n-                    compilationUnits\n-\n-            ));\n-            ((com.sun.source.util.JavacTask) compilationTask)\n-                    .generate();\n-            \/\/.forEach(fileObject -> pathsToJar.add(new RootAndPath(javacBuilder.classesDir, Path.of(fileObject.toUri()))));\n-\n-\n-            return javacBuilder;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static JavacBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-        JavacBuilder javacBuilder = new JavacBuilder();\n-        javacBuilderConsumer.accept(javacBuilder);\n-        return javac(javacBuilder);\n-    }\n-\n-    public static class JarBuilder extends Builder<JarBuilder> {\n-        public Path jar;\n-        public List<Path> pathList;\n-\n-        public JarBuilder basedOn(JarBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                if (stem.jar != null) {\n-                    this.jar = stem.jar;\n-                }\n-                if (stem.pathList != null) {\n-                    this.pathList = new ArrayList<>(stem.pathList);\n-                }\n-            }\n-            return this;\n-        }\n-\n-        public JarBuilder jar(Path jar) {\n-            this.jar = jar;\n-            return this;\n-        }\n-\n-        public JarBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-            JavacBuilder javacBuilder = new JavacBuilder();\n-            javacBuilderConsumer.accept(javacBuilder);\n-            var result = Bldr.javac(javacBuilder);\n-            pathList = (pathList == null) ? new ArrayList<>() : pathList;\n-            pathList.add(result.classesDir);\n-            return this;\n-        }\n-\n-        public JarBuilder path_list(Path... paths) {\n-            this.pathList = new ArrayList<>(Arrays.asList(paths));\n-            return this;\n-        }\n-    }\n-\n-    public static JarBuilder jar(Consumer<JarBuilder> jarBuilderConsumer) {\n-        try {\n-            JarBuilder jarBuilder = new JarBuilder();\n-            jarBuilderConsumer.accept(jarBuilder);\n-\n-            List<RootAndPath> pathsToJar = new ArrayList<>();\n-            var jarStream = new JarOutputStream(Files.newOutputStream(jarBuilder.jar));\n-            var setOfDirs = new HashSet<Path>();\n-            jarBuilder.pathList.stream().sorted().filter(Files::isDirectory).forEach(root ->\n-                    pathsToJar.addAll(findFiles(root).map(path -> new RootAndPath(root, path)).toList()));\n-\n-            pathsToJar.stream().sorted(Comparator.comparing(RootAndPath::path)).forEach(rootAndPath -> {\n-                var parentDir = rootAndPath.path().getParent();\n-                try {\n-                    if (!setOfDirs.contains(parentDir)) {\n-                        setOfDirs.add(parentDir);\n-                        PosixFileAttributes attributes = Files.readAttributes(rootAndPath.path(), PosixFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n-                        var entry = new JarEntry(rootAndPath.relativize() + \"\/\");\n-                        entry.setTime(attributes.lastModifiedTime().toMillis());\n-                        jarStream.putNextEntry(entry);\n-                        jarStream.closeEntry();\n-                    }\n-                    PosixFileAttributes attributes = Files.readAttributes(rootAndPath.path(), PosixFileAttributes.class, LinkOption.NOFOLLOW_LINKS);\n-                    var entry = new JarEntry(rootAndPath.relativize().toString());\n-                    entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n-                    jarStream.putNextEntry(entry);\n-                    if (attributes.isRegularFile()) {\n-                        Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n-                    }\n-                    jarStream.closeEntry();\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-            jarStream.finish();\n-            jarStream.close();\n-            return jarBuilder;\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static class JavaBuilder extends ExecBuilder<JavaBuilder> {\n-        public Path jdk = Path.of(System.getProperty(\"java.home\"));\n-        public String mainClass;\n-        public List<Path> classPath;\n-        public List<String> vmopts = new ArrayList<>();\n-        public List<String> args = new ArrayList<>();\n-\n-        public JavaBuilder vmopts(List<String> opts) {\n-            this.vmopts.addAll(opts);\n-            return self();\n-        }\n-\n-        public JavaBuilder vmopts(String... opts) {\n-            vmopts(Arrays.asList(opts));\n-            return self();\n-        }\n-\n-\n-        public JavaBuilder args(List<String> opts) {\n-            this.args.addAll(opts);\n-            return self();\n-        }\n-\n-        public JavaBuilder args(String... opts) {\n-            args(Arrays.asList(opts));\n-            return self();\n-        }\n-\n-\n-        public JavaBuilder basedOn(JavaBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                vmopts.addAll(stem.vmopts);\n-                args.addAll(stem.args);\n-                if (stem.mainClass != null) {\n-                    this.mainClass = stem.mainClass;\n-                }\n-                if (stem.jdk != null) {\n-                    this.jdk = stem.jdk;\n-                }\n-                if (stem.classPath != null) {\n-                    this.classPath = new ArrayList<>(stem.classPath);\n-                }\n-\n-                opts.addAll(stem.opts);\n-\n-            }\n-            return this;\n-        }\n-\n-        public JavaBuilder main_class(String mainClass) {\n-            this.mainClass = mainClass;\n-            return this;\n-        }\n-\n-        public JavaBuilder jdk(Path jdk) {\n-            this.jdk = jdk;\n-            return this;\n-        }\n-\n-        public JavaBuilder javac(Consumer<JavacBuilder> javacBuilderConsumer) {\n-            JavacBuilder javacBuilder = new JavacBuilder();\n-            javacBuilderConsumer.accept(javacBuilder);\n-            var result = Bldr.javac(javacBuilder);\n-            classPath = (classPath == null) ? new ArrayList<>() : classPath;\n-            classPath.add(result.classesDir);\n-            return this;\n-        }\n-        public JavaBuilder class_path(List<Path> classPathEntries) {\n-            this.classPath = (this.classPath == null) ? new ArrayList<>() : this.classPath;\n-            this.classPath.addAll(classPathEntries);\n-            return this;\n-        }\n-\n-        public JavaBuilder class_path(Path... classPathEntries) {\n-            return this.class_path(List.of(classPathEntries));\n-        }\n-\n-        @Override\n-        public List<String> execOpts() {\n-            List<String> execOpts = new ArrayList<>();\n-            execOpts.add(jdk.resolve(\"bin\/java\").toString());\n-            execOpts.addAll(vmopts);\n-            if (classPath != null) {\n-                execOpts.addAll(List.of(\"--class-path\", pathCharSeparated(classPath)));\n-            }\n-            execOpts.add(mainClass);\n-            execOpts.addAll(args);\n-            return execOpts;\n-        }\n-    }\n-    public static JavaBuilder java(JavaBuilder javaBuilder) {\n-        javaBuilder.execInheritIO();\n-        return javaBuilder;\n-    }\n-\n-    public static JavaBuilder java(Consumer<JavaBuilder> javaBuilderConsumer) {\n-        JavaBuilder javaBuilder = new JavaBuilder();\n-        javaBuilderConsumer.accept(javaBuilder);\n-        return java(javaBuilder);\n-    }\n-\n-\n-    public static class CMake {\n-        record Regex(Pattern pattern) {\n-            Regex(String regex) {\n-                this(Pattern.compile(regex));\n-            }\n-\n-            boolean matches(String text, Consumer<Matcher> matcherConsumer) {\n-                if (pattern().matcher(text) instanceof Matcher matcher && matcher.matches()) {\n-                    matcherConsumer.accept(matcher);\n-                    return true;\n-                } else {\n-                    return false;\n-                }\n-            }\n-\n-        }\n-\n-        public interface CMakeVar {\n-            String name();\n-\n-            String value();\n-        }\n-\n-        public record CMakeTypedVar(String name, String type, String value, String comment) implements CMakeVar {\n-            static final Regex regex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+):([^=]*)=(.*)$\");\n-\n-            CMakeTypedVar(Matcher matcher, String comment) {\n-                this(\"CMAKE_\" + matcher.group(1).trim(), matcher.group(2).trim(), matcher.group(3).trim(), comment.substring(2).trim());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeTypedVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeTypedVar(matcher, comment)));\n-            }\n-        }\n-\n-        public record CMakeSimpleVar(String name, String value) implements CMakeVar {\n-            static final Regex regex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)\\\\}>\\\\}$\");\n-\n-            CMakeSimpleVar(Matcher matcher) {\n-                this(\"CMAKE_\" + matcher.group(1).trim(), (matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeSimpleVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeSimpleVar(matcher)));\n-            }\n-        }\n-\n-        public record CMakeContentVar(String name, String value) implements CMakeVar {\n-            static final Regex startRegex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{(.*)$\");\n-            static final Regex endRegex = new Regex(\"^(.*)\\\\}>\\\\}$\");\n-\n-        }\n-\n-        public record CMakeRecipeVar(String name, String value) implements CMakeVar {\n-            static final Regex varPattern = new Regex(\"<([^>]*)>\");\n-            static final Regex regex = new Regex(\"^_*(?:CMAKE_)?([A-Za-z0-9_]+)=\\\\{<\\\\{<(.*)>\\\\}>\\\\}$\");\n-\n-            CMakeRecipeVar(Matcher matcher) {\n-                this(\"CMAKE_\" + matcher.group(1).trim(), \"<\" + ((matcher.group(2).isEmpty()) ? \"\" : matcher.group(2).trim()) + \">\");\n-            }\n-\n-            public String expandRecursively(Map<String, CMakeVar> varMap, String value) { \/\/ recurse\n-                String result = value;\n-                if (varPattern.pattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n-                    var v = matcher.group(1);\n-                    if (varMap.containsKey(v)) {\n-                        String replacement = varMap.get(v).value();\n-                        result = expandRecursively(varMap,\n-                                value.substring(0, matcher.start()) + replacement + value.substring(matcher.end()));\n-                    }\n-                }\n-                return result;\n-            }\n-\n-\n-            public String expand(Map<String, CMakeVar> vars) {\n-                return expandRecursively(vars, value());\n-            }\n-\n-            static boolean onMatch(String line, String comment, Consumer<CMakeRecipeVar> consumer) {\n-                return regex.matches(line, matcher -> consumer.accept(new CMakeRecipeVar(matcher)));\n-            }\n-        }\n-\n-        Path dir;\n-        String[] packages;\n-        Map<String, CMakeVar> varMap = new HashMap<>();\n-\n-        CMake(Path _dir, String... packages) {\n-            this.dir = _dir.resolve(\"cmakeprobe\");\n-            mkdir(rmdir(this.dir));\n-            this.packages = packages;\n-\n-            try {\n-                Files.createDirectories(this.dir);\n-                var CMakeListsTxt = new StringBuilder(\n-                        \"\"\"\n-                                cmake_minimum_required(VERSION 3.21)\n-                                project(cmakeprobe)\n-                                set(CMAKE_CXX_STANDARD 14)\n-\n-                                get_cmake_property(VarNames VARIABLES)\n-                                #set(VARS_FILE ${CMAKE_SOURCE_DIR}\/vars.txt)\n-\n-                                #file(WRITE ${VARS_FILE} \"\")\n-                                foreach(VarName ${VarNames})\n-                                    message(\"${VarName}={<{${${VarName}}}>}\\n\")\n-                                endforeach()\n-                                \"\"\");\n-\n-                Stream.of(packages).forEach(p ->\n-                        CMakeListsTxt.append(\"find_package(\").append(p).append(\")\\n\"));\n-                Files.writeString(this.dir.resolve(\"CMakeLists.txt\"), CMakeListsTxt.toString());\n-                var cmakeProcessBuilder = new ProcessBuilder()\n-                        .directory(this.dir.toFile())\n-                        .redirectErrorStream(true)\n-                        .command(\"cmake\", \"-LAH\")\n-                        .start();\n-                List<String> lines = new BufferedReader(new InputStreamReader(cmakeProcessBuilder.getInputStream())).lines().toList();\n-\n-                String comment = null;\n-                String contentName = null;\n-                StringBuilder content = null;\n-\n-                for (String line : lines) {\n-                    if (line.startsWith(\"\/\/\")) {\n-                        comment = line;\n-                        content = null;\n-\n-                    } else if (comment != null) {\n-                        if (CMakeTypedVar.onMatch(line, comment, v -> {\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    println(\"replacing duplicate variable with typed variant with the name same value\" + v + theVar);\n-                                } else {\n-                                    throw new IllegalStateException(\"Duplicate variable name different value: \" + v + theVar);\n-                                }\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        })) {\n-                        } else {\n-                            println(\"failed to parse \" + line);\n-                        }\n-                        comment = null;\n-                        content = null;\n-                        contentName = null;\n-                    } else if (!line.isEmpty()) {\n-                        if (content != null) {\n-                            if (CMakeContentVar.endRegex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n-                                content.append(\"\\n\").append(matcher.group(1));\n-                                var v = new CMakeContentVar(contentName, content.toString());\n-                                contentName = null;\n-                                content = null;\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                content.append(\"\\n\").append(line);\n-                            }\n-                        } else if (!line.endsWith(\"}>}\") && CMakeContentVar.startRegex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n-                            contentName = \"CMAKE_\" + matcher.group(1);\n-                            content = new StringBuilder(matcher.group(2));\n-                        } else if (CMakeRecipeVar.regex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n-                            CMakeVar v = new CMakeRecipeVar(matcher);\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                                } else {\n-                                    throw new IllegalStateException(\"Duplicate variable name different value: \" + v + theVar);\n-                                }\n-                                varMap.put(v.name(), v);\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        } else if (CMakeSimpleVar.regex.pattern().matcher(line) instanceof Matcher matcher && matcher.matches()) {\n-                            CMakeVar v = new CMakeSimpleVar(matcher);\n-                            if (varMap.containsKey(v.name())) {\n-                                var theVar = varMap.get(v.name());\n-                                if (theVar.value().equals(v.value())) {\n-                                    println(\"Skipping duplicate variable name different value: \" + v + theVar);\n-                                } else {\n-                                    throw new IllegalStateException(\"Duplicate variable name vifferent vars: \" + v + theVar);\n-                                }\n-                                \/\/ note we don't replace a Typed with a Simple\n-                            } else {\n-                                varMap.put(v.name(), v);\n-                            }\n-                        } else {\n-                            println(\"Skipping \" + line);\n-                        }\n-                    }\n-                }\n-\n-            } catch (IOException ioe) {\n-                throw new RuntimeException(ioe);\n-            }\n-        }\n-\n-        Path cxxCompileObject(Path target, Path source, List<String> frameworks) {\n-            CMakeRecipeVar compileObject = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_COMPILE_OBJECT\");\n-            Map<String, CMakeVar> localVars = new HashMap<>(varMap);\n-            localVars.put(\"DEFINES\", new CMakeSimpleVar(\"DEFINES\", \"\"));\n-            localVars.put(\"INCLUDES\", new CMakeSimpleVar(\"INCLUDES\", \"\"));\n-            localVars.put(\"FLAGS\", new CMakeSimpleVar(\"FLAGS\", \"\"));\n-            localVars.put(\"OBJECT\", new CMakeSimpleVar(\"OBJECT\", target.toString()));\n-            localVars.put(\"SOURCE\", new CMakeSimpleVar(\"SOURCE\", source.toString()));\n-            String executable = compileObject.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-        Path cxxLinkExecutable(Path target, List<Path> objFiles, List<String> frameworks) {\n-            CMakeRecipeVar linkExecutable = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_LINK_EXECUTABLE\");\n-            Map<String, CMakeVar> localVars = new HashMap<>(varMap);\n-            String executable = linkExecutable.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-        Path cxxcreateSharedLibrary(Path target, List<Path> objFiles, List<String> frameworks) {\n-            CMakeRecipeVar createSharedLibrary = (CMakeRecipeVar) varMap.get(\"CMAKE_CXX_CREATE_SHARED_LIBRARY\");\n-            Map<String, CMakeVar> localVars = new HashMap<>(varMap);\n-            String executable = createSharedLibrary.expand(localVars);\n-            println(executable);\n-            return target;\n-        }\n-\n-    }\n-\n-    public static class CMakeBuilder extends ExecBuilder<CMakeBuilder> {\n-        public List<String> libraries = new ArrayList<>();\n-        public Path buildDir;\n-        public Path sourceDir;\n-        private Path output;\n-\n-        public CMakeBuilder() {\n-            opts.add(\"cmake\");\n-        }\n-\n-        public CMakeBuilder basedOn(CMakeBuilder stem) {\n-            \/\/ super.basedOn(stem); you will get two cmakes ;)\n-            if (stem != null) {\n-                if (stem.output != null) {\n-                    this.output = stem.output;\n-                }\n-                if (stem.libraries != null) {\n-                    this.libraries = new ArrayList<>(stem.libraries);\n-                }\n-                if (stem.buildDir != null) {\n-                    this.buildDir = stem.buildDir;\n-                }\n-                if (stem.sourceDir != null) {\n-                    this.sourceDir = stem.sourceDir;\n-                }\n-            }\n-            return this;\n-        }\n-\n-        public CMakeBuilder B(Path buildDir) {\n-            this.buildDir = buildDir;\n-            opts(\"-B\", buildDir.toString());\n-            return this;\n-        }\n-\n-        public CMakeBuilder S(Path sourceDir) {\n-            this.sourceDir = sourceDir;\n-            opts(\"-S\", sourceDir.toString());\n-            return this;\n-        }\n-\n-        public CMakeBuilder build(Path buildDir) {\n-            this.buildDir = buildDir;\n-            opts(\"--build\", buildDir.toString());\n-            return this;\n-        }\n-\n-        @Override\n-        public List<String> execOpts() {\n-            return opts;\n-        }\n-    }\n-\n-    public static void cmake(Consumer<CMakeBuilder> cmakeBuilderConsumer) {\n-\n-        CMakeBuilder cmakeBuilder = new CMakeBuilder();\n-        cmakeBuilderConsumer.accept(cmakeBuilder);\n-\n-        try {\n-            Files.createDirectories(cmakeBuilder.buildDir);\n-            cmakeBuilder.execInheritIO();\n-        } catch (IOException ioe) {\n-            throw new IllegalStateException(ioe);\n-        }\n-    }\n-\n-\n-    static Path unzip(Path in, Path dir) {\n-        try {\n-            Files.createDirectories(dir);\n-            ZipFile zip = new ZipFile(in.toFile());\n-            zip.entries().asIterator().forEachRemaining(entry -> {\n-                try {\n-                    String currentEntry = entry.getName();\n-\n-                    Path destFile = dir.resolve(currentEntry);\n-                    \/\/destFile = new File(newPath, destFile.getName());\n-                    Path destinationParent = destFile.getParent();\n-                    Files.createDirectories(destinationParent);\n-                    \/\/ create the parent directory structure if needed\n-\n-\n-                    if (!entry.isDirectory()) {\n-                        zip.getInputStream(entry).transferTo(Files.newOutputStream(destFile));\n-                    }\n-                } catch (IOException ioe) {\n-                    throw new RuntimeException(ioe);\n-                }\n-            });\n-            zip.close();\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return dir;\n-    }\n-\n-    public static class JExtractBuilder extends ExecBuilder<JExtractBuilder> {\n-        public List<String> compileFlags = new ArrayList<>();\n-        public List<Path> libraries = new ArrayList<>();\n-        public List<Path> headers = new ArrayList<>();\n-        public Path cwd;\n-\n-        public Path home;\n-        private String targetPackage;\n-        private Path output;\n-\n-        public JExtractBuilder() {\n-            opts.add(\"jextract\");\n-        }\n-\n-        public JExtractBuilder basedOn(JExtractBuilder stem) {\n-            super.basedOn(stem);\n-            if (stem != null) {\n-                if (stem.output != null) {\n-                    this.output = stem.output;\n-                }\n-                if (stem.compileFlags != null) {\n-                    this.compileFlags = new ArrayList<>(stem.compileFlags);\n-                }\n-                if (stem.libraries != null) {\n-                    this.libraries = new ArrayList<>(stem.libraries);\n-                }\n-                if (stem.home != null) {\n-                    this.home = stem.home;\n-                }\n-                if (stem.cwd != null) {\n-                    this.cwd = stem.cwd;\n-                }\n-                if (stem.headers != null) {\n-                    this.headers = new ArrayList<>(stem.headers);\n-                }\n-            }\n-            return this;\n-        }\n-\n-\n-        public JExtractBuilder cwd(Path cwd) {\n-            this.cwd = cwd;\n-            return this;\n-        }\n-\n-        public JExtractBuilder home(Path home) {\n-            this.home = home;\n-            opts.set(0, home.resolve(\"bin\/jextract\").toString());\n-            return this;\n-        }\n-\n-        public JExtractBuilder opts(String... opts) {\n-            this.opts.addAll(Arrays.asList(opts));\n-            return this;\n-        }\n-\n-        public JExtractBuilder target_package(String targetPackage) {\n-            this.targetPackage = targetPackage;\n-            opts(\"--target-package\", targetPackage);\n-            return this;\n-        }\n-\n-        public JExtractBuilder output(Path output) {\n-            this.output = output;\n-            opts(\"--output\", output.toString());\n-            return this;\n-        }\n-\n-        public JExtractBuilder library(Path... libraries) {\n-            this.libraries.addAll(Arrays.asList(libraries));\n-            for (Path library : libraries) {\n-                opts(\"--library\", \":\" + library);\n-            }\n-            return this;\n-        }\n-\n-        public JExtractBuilder compile_flag(String... compileFlags) {\n-            this.compileFlags.addAll(Arrays.asList(compileFlags));\n-            return this;\n-        }\n-\n-        public JExtractBuilder header(Path header) {\n-            this.headers.add(header);\n-            this.opts.add(header.toString());\n-            return this;\n-        }\n-\n-        @Override\n-        public List<String> execOpts() {\n-            return opts;\n-        }\n-    }\n-\n-    public static void jextract(Consumer<JExtractBuilder> jextractBuilderConsumer) {\n-        JExtractBuilder extractConfig = new JExtractBuilder();\n-        jextractBuilderConsumer.accept(extractConfig);\n-        System.out.println(extractConfig.opts);\n-        var compilerFlags = extractConfig.cwd.resolve(\"compiler_flags.txt\");\n-        try {\n-            PrintWriter compilerFlagsWriter = new PrintWriter(Files.newOutputStream(compilerFlags));\n-            compilerFlagsWriter.println(extractConfig.compileFlags);\n-            compilerFlagsWriter.close();\n-            Files.createDirectories(extractConfig.output);\n-            extractConfig.execInheritIO(extractConfig.cwd);\n-            Files.deleteIfExists(compilerFlags);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static Path mkdir(Path path) {\n-        try {\n-            return Files.createDirectories(path);\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public record SearchableTextFile(Path path) implements TextFile {\n-        public Stream<Line> lines() {\n-            try {\n-                int num[] = new int[]{1};\n-                return Files.readAllLines(path(), StandardCharsets.UTF_8).stream().map(line -> new Line(line, num[0]++));\n-            } catch (IOException ioe) {\n-                System.out.println(ioe);\n-                return new ArrayList<Line>().stream();\n-            }\n-        }\n-\n-        public boolean grep(Pattern pattern) {\n-            return lines().anyMatch(line -> pattern.matcher(line.line).matches());\n-        }\n-\n-        public boolean hasSuffix(String... suffixes) {\n-            var suffixSet = Set.of(suffixes);\n-            int dotIndex = path().toString().lastIndexOf('.');\n-            return dotIndex == -1 || suffixSet.contains(path().toString().substring(dotIndex + 1));\n-        }\n-    }\n-\n-    public record Line(String line, int num) {\n-        public boolean grep(Pattern pattern) {\n-            return pattern.matcher(line()).matches();\n-        }\n-    }\n-\n-    public enum Scope {\n-        TEST, COMPILE, PROVIDED, RUNTIME, SYSTEM;\n-\n-        static Scope of(String name) {\n-            return switch (name.toLowerCase()) {\n-                case \"test\" -> TEST;\n-                case \"compile\" -> COMPILE;\n-                case \"provided\" -> PROVIDED;\n-                case \"runtime\" -> RUNTIME;\n-                case \"system\" -> SYSTEM;\n-                default -> COMPILE;\n-            };\n-        }\n-    }\n-\n-    public record Version(int maj, int min, int point, String modifier) {\n-        public String spec() {\n-            StringBuilder stringBuilder = new StringBuilder();\n-            if (maj >= 0) {\n-                stringBuilder.append(maj);\n-                if (min >= 0) {\n-                    stringBuilder.append(\".\").append(min);\n-                    if (point >= 0) {\n-                        stringBuilder.append(\".\").append(point);\n-                        if (modifier != null && !modifier.isEmpty()) {\n-                            stringBuilder.append(\"-\").append(modifier);\n-                        }\n-                    }\n-                }\n-            } else {\n-                stringBuilder.append(1);\n-            }\n-            return stringBuilder.toString();\n-        }\n-\n-        record Spec(int maj, int min, int point, String modifier) {\n-        }\n-\n-        static Pattern IntPrefixPattern = Pattern.compile(\"^\\\\.?([0-9]+)(.*)$\");\n-\n-        static Spec parse(String spec) {\n-\n-            if (spec.isEmpty()) {\n-                return new Spec(-1, -1, -1, null);\n-            } else {\n-                var majMatch = IntPrefixPattern.matcher(spec);\n-                if (majMatch.matches()) {\n-                    int maj = Integer.parseInt(majMatch.group(1));\n-                    var minMatch = IntPrefixPattern.matcher(majMatch.group(2));\n-                    if (minMatch.matches()) {\n-                        int min = Integer.parseInt(minMatch.group(1));\n-                        var pointMatch = IntPrefixPattern.matcher(minMatch.group(2));\n-                        if (pointMatch.matches()) {\n-                            int point = Integer.parseInt(pointMatch.group(1));\n-                            return new Spec(maj, min, point, pointMatch.group(2));\n-                        } else {\n-                            return new Spec(maj, min, -1, null);\n-                        }\n-                    } else {\n-                        return new Spec(maj, -1, -1, null);\n-                    }\n-                } else {\n-                    throw new IllegalArgumentException(\"Invalid spec: \" + spec);\n-                }\n-            }\n-\n-            \/\/var matcher = Pattern.compile(\"^([0-9]*)\\\\.([0-9]*)\\\\.([0-9]*)(.*)$\").matcher(spec);\n-            \/\/ return new Spec(1,-1,-1,\"\");\n-        }\n-\n-        Version() {\n-            this(-1, -1, -1, null);\n-        }\n-\n-        Version(int maj) {\n-            this(maj, -1, -1, null);\n-        }\n-\n-        Version(int maj, int min) {\n-            this(maj, min, -1, null);\n-        }\n-\n-        Version(int maj, int min, int point) {\n-            this(maj, min, point, null);\n-        }\n-\n-\n-        Version(String spec) {\n-            this(parse(spec));\n-        }\n-\n-        Version(Spec spec) {\n-            this(spec.maj, spec.min, spec.point, spec.modifier);\n-        }\n-    }\n-\n-    public record Artifact(Path dir, String groupId, String artifactId, Version version, Scope scope,\n-                           boolean optional) {\n-        static final String MAVEN_REPO = \"https:\/\/repo.maven.apache.org\/maven2\/\";\n-\n-        static String groupId(XMLNode xmlNode) {\n-            return xmlNode.xpathQueryString(\"groupId\/text()\");\n-        }\n-\n-        static String artifactId(XMLNode xmlNode) {\n-            return xmlNode.xpathQueryString(\"artifactId\/text()\");\n-        }\n-\n-        static String versionId(XMLNode xmlNode) {\n-            return xmlNode.xpathQueryString(\"versionId\/text()\");\n-        }\n-\n-        Artifact(Path dir, XMLNode xmlNode) {\n-            this(dir,\n-                    groupId(xmlNode), artifactId(xmlNode),\n-                    new Version(versionId(xmlNode)),\n-                    Scope.of(xmlNode.xpathQueryString(\"scope\/text()\")),\n-                    Boolean.parseBoolean(xmlNode.xpathQueryString(\"optional\/text()\"))\n-            );\n-        }\n-\n-        public Artifact(Path dir, String group, String artifact, Version version) {\n-            this(dir, group, artifact, version, Scope.COMPILE, false);\n-        }\n-\n-        public String artifactAndVersion() {\n-            return artifactId() + '-' + version().spec();\n-        }\n-\n-        public String pathName() {\n-            return groupId() + '.' + artifactAndVersion();\n-        }\n-\n-        private String location() {\n-            return MAVEN_REPO + groupId().replace('.', '\/') + \"\/\" + artifactId() + \"\/\" + version().spec();\n-        }\n-\n-        private String name(String suffix) {\n-            return artifactAndVersion() + \".\" + suffix;\n-        }\n-\n-        public Path pomPath() {\n-            return dir.resolve(name(\"pom\"));\n-        }\n-\n-        public URL url(String suffix) {\n-            try {\n-                return new URI(location() + \"\/\" + name(suffix)).toURL();\n-            } catch (MalformedURLException e) {\n-                throw new RuntimeException(e);\n-            } catch (URISyntaxException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public URL pomURL() {\n-            return url(\"pom\");\n-        }\n-\n-        public URL jarURL() {\n-            return url(\"jar\");\n-        }\n-\n-\n-        public Path jarPath() {\n-            return dir.resolve(name(\"jar\"));\n-        }\n-\n-        public Artifact download() {\n-            if (isRegularFile(pomPath())) {\n-                println(\"We already have \" + pomPath());\n-            } else {\n-                println(\"Downloading \" + pomPath() + \" and \" + jarPath());\n-                try {\n-                    pomURL().openStream().transferTo(Files.newOutputStream(pomPath()));\n-                    jarURL().openStream().transferTo(Files.newOutputStream(jarPath()));\n-                    dependencies();\n-                } catch (IOException e) {\n-                    if (version.maj() == -1) {\n-                        Artifact artifact = new Artifact(this.dir, this.groupId, this.artifactId, new Version(1));\n-                        artifact.download();\n-                    } else if (version.min() == -1) {\n-                        Artifact artifact = new Artifact(this.dir, this.groupId, this.artifactId, new Version(version.maj, 0));\n-                        artifact.download();\n-                    } else {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            return this;\n-        }\n-\n-        public XMLNode pomXML() {\n-            try {\n-                return new XMLNode(dir.resolve(name(\"pom\")));\n-            } catch (Throwable e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        public List<Artifact> dependencies() {\n-            List<Artifact> artifacts = new ArrayList<>();\n-            var xmlNode = pomXML();\n-            var nodeList = xmlNode.nodeList(xmlNode.xpath(\"\/project\/dependencies\/dependency\"));\n-            for (int i = 0; i < nodeList.getLength(); i++) {\n-                var node = nodeList.item(i);\n-                var dependency = new Artifact(dir, new XMLNode((Element) node));\n-                \/\/ if (!Files.exists(dependency.pomPath())){\n-                dependency.download();\n-                \/\/\/ }\n-                if (dependency.optional()) {\n-                    println(dependency + \" is optional\");\n-                } else if (dependency.scope.equals(Scope.COMPILE)) {\n-                    artifacts.add(dependency);\n-                    artifacts.addAll(dependency.dependencies());\n-                } else {\n-                    println(\"skipping \" + dependency);\n-                }\n-            }\n-            return artifacts;\n-        }\n-\n-    }\n-\n-    public static Path curl(URL url, Path file) {\n-        try {\n-            println(\"Downloading \" + url + \"->\" + file);\n-            url.openStream().transferTo(Files.newOutputStream(file));\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return file;\n-    }\n-\n-    public static Optional<Path> which(String execName) {\n-        \/\/ which and whereis had issues.\n-        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n-                .map(dirName -> Path.of(dirName).resolve(execName).normalize())\n-                .filter(Files::isExecutable).findFirst();\n-    }\n-\n-    public static boolean canExecute(String execName) {\n-        \/\/ which and whereis had issues.\n-        return which(execName).isPresent();\n-    }\n-\n-    public static Path untar(Path tarFile, Path dir) {\n-        try {\n-            new ProcessBuilder().inheritIO().command(\"tar\", \"xvf\", tarFile.toString(), \"--directory\", tarFile.getParent().toString()).start().waitFor();\n-            return dir;\n-        } catch (\n-                InterruptedException e) { \/\/ We get IOException if the executable not found, at least on Mac so interuppted means it exists\n-            return null;\n-        } catch (IOException e) { \/\/ We get IOException if the executable not found, at least on Mac\n-            \/\/throw new RuntimeException(e);\n-            return null;\n-        }\n-    }\n-\n-\n-    public static Matcher pathMatcher(Path path, Pattern pattern) {\n-        return pattern.matcher(path.toString());\n-    }\n-\n-    public static boolean matches(Path path, Pattern pattern) {\n-        return pathMatcher(path, pattern).matches();\n-    }\n-\n-    public static boolean matches(Path path, String pattern) {\n-        return pathMatcher(path, Pattern.compile(pattern)).matches();\n-    }\n-\n-    public static boolean failsAndMatches(Path path, String failMe, String passMe) {\n-        return !matches(path, failMe) && matches(path, Pattern.compile(passMe));\n-    }\n-\n-    public static Artifact artifact(Path path, String group, String artifact, Version version) {\n-        return new Artifact(path, group, artifact, version);\n-    }\n-\n-\n-    public record Project(Path targetDir, Path path,\n-                          String variant) implements TargetDirProvider, JavaSourceDirProvider, ResourceDirProvider {\n-\n-\n-        public Path javaSourceDir() {\n-            return path().resolve(\"src\/main\/java\");\n-        }\n-\n-        public Path resourcesDir() {\n-            return path().resolve(\"src\/main\/resources\");\n-        }\n-\n-        public String prefixNameVariantSuffix(String prefix, String suffix) {\n-            return (prefix.isEmpty() ? \"\" : prefix + \"-\") + path().getFileName() + \"-\" + variant() + suffix;\n-        }\n-\n-        public Path target(String prefix, String suffix) {\n-            return targetDir.resolve(prefixNameVariantSuffix(prefix, suffix));\n-        }\n-\n-        public JarBuilder build(String prefix, JavacBuilder javacBuilder) {\n-            println(\"Building  \" + path().getFileName() + \"-\" + variant());\n-            return jar($ -> $\n-                    .jar(target(prefix, \".jar\"))\n-                    .when(isDirectory(resourcesDir()), $$ -> $$.path_list(resourcesDir()))\n-                    .javac($$ -> $$.basedOn(javacBuilder)\n-                            .classes_dir(target(prefix, \".jar.classes\"))\n-                            .source_path(javaSourceDir())\n-                    )\n-            );\n-        }\n-\n-        public JarBuilder build(JavacBuilder javacBuilder) {\n-            return build(\"\", javacBuilder);\n-        }\n-    }\n-\n-    public static boolean withOptionalDirectory(Path dir, Consumer<Path> pathConsumer) {\n-        if (isDirectory(dir)) {\n-            pathConsumer.accept(dir);\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    public static void withExpectedDirectory(Path dir, Consumer<Path> pathConsumer) {\n-        if (isDirectory(dir)) {\n-            pathConsumer.accept(dir);\n-        } else {\n-            throw new IllegalStateException(\"Failed to find directory \" + dir);\n-        }\n-    }\n-\n-    public record Root(Path path) implements DirPathHolder {\n-\n-\n-        public Path buildDir() {\n-            return mkdir(subDir(\"build\"));\n-        }\n-\n-        public Path thirdPartyDir() {\n-            return mkdir(subDir(\"thirdparty\"));\n-        }\n-\n-        public Path repoDir() {\n-            return mkdir(subDir(\"repoDir\"));\n-        }\n-\n-        public Root() {\n-            this(Path.of(System.getProperty(\"user.dir\")));\n-        }\n-\n-        public Repo repo() {\n-            return new Repo(repoDir());\n-        }\n-\n-\n-        public Path requireJExtract() {\n-            var optional = executablesInPath(\"jextract\").findFirst();\n-            if (optional.isPresent()) {\n-                println(\"Found jextract in PATH\");\n-                return optional.get().getParent().getParent(); \/\/ we want the 'HOME' dir\n-            }\n-            println(\"No jextract in PATH\");\n-            URL downloadURL = null;\n-            var extractVersionMaj = \"22\";\n-            var extractVersionMin = \"5\";\n-            var extractVersionPoint = \"33\";\n-            try {\n-                downloadURL = new URI(\"https:\/\/download.java.net\/java\/early_access\"\n-                        + \"\/jextract\/\" + extractVersionMaj + \"\/\" + extractVersionMin\n-                        + \"\/openjdk-\" + extractVersionMaj + \"-jextract+\" + extractVersionMin + \"-\" + extractVersionPoint + \"_\"\n-                        + os.nameArchTuple() + \"_bin.tar.gz\").toURL();\n-            } catch (MalformedURLException e) {\n-                throw new RuntimeException(e);\n-            } catch (URISyntaxException e) {\n-                throw new RuntimeException(e);\n-            }\n-            URL finalDownloadURL = downloadURL;\n-\n-            println(\"... attempting download from\" + downloadURL);\n-            var jextractTar = thirdPartyDir().resolve(\"jextract.tar\");\n-\n-            if (!isRegularFile(jextractTar)) { \/\/ Have we downloaded already?\n-                jextractTar = curl(finalDownloadURL, jextractTar); \/\/ if not\n-            }\n-\n-            var jextractHome = thirdPartyDir().resolve(\"jextract-22\");\n-            if (!isDirectory(jextractHome)) {\n-                untar(jextractTar, jextractHome);\n-            }\n-            return jextractHome;\n-\n-        }\n-    }\n-\n-    public static Stream<Path> executablesInPath(String name) {\n-        return Arrays.asList(System.getenv(\"PATH\").split(File.pathSeparator)).stream()\n-                .map(dirName -> Path.of(dirName).resolve(name).normalize())\n-                .filter(Files::isExecutable);\n-\n-    }\n-\n-    public static void sanity(Root hatDir) {\n-        var rleParserDir = hatDir.path().resolve(\"examples\/life\/src\/main\/java\/io\");\n-        subDirStream(hatDir.path(), \"hat\", \"examples\", \"backends\", \"docs\").forEach(dir ->\n-                findTextFiles(dir, \"java\", \"cpp\", \"h\", \"hpp\", \"md\")\n-                        .forEach(searchableTextFile -> {\n-                            if (!searchableTextFile.path().getFileName().toString().equals(\"Makefile\") && !searchableTextFile.hasSuffix(\"md\")\n-                                    && !searchableTextFile.path().startsWith(rleParserDir)\n-                                    && !searchableTextFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n-                                System.err.println(\"ERR MISSING LICENSE \" + searchableTextFile.path());\n-                            }\n-                            searchableTextFile.lines().forEach(line -> {\n-                                if (!searchableTextFile.path().getFileName().toString().startsWith(\"Makefile\") && line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n-                                    System.err.println(\"ERR TAB \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n-                                }\n-                                if (line.grep(Pattern.compile(\"^.* $\"))) {\n-                                    System.err.println(\"ERR TRAILING WHITESPACE \" + searchableTextFile.path() + \":\" + line.line() + \"#\" + line.num());\n-                                }\n-                            });\n-                        })\n-        );\n-    }\n-\n-    public static <T> T assertOrThrow(T testme, Predicate<T> predicate, String message){\n-        if (predicate.test(testme)) {\n-            return testme;\n-        }else{\n-            throw new IllegalStateException(\"FAILED: \"+message+\" \"+testme);\n-        }\n-    }\n-\n-    \/\/  https:\/\/stackoverflow.com\/questions\/23272861\/how-to-call-testng-xml-from-java-main-method\n-    public static void lomain(String[] args) throws Throwable {\n-        var hatDir = new Root(Path.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\"));\n-\n-        \/\/ varMap.entrySet().forEach(value->println(\"+\"+value) );\n-        var cmake = new CMake(hatDir.buildDir(), \"OpenCL\", \"CUDAToolkit\", \"OpenGL\", \"GLUT\");\n-        var clinfoObj = cmake.cxxCompileObject(\n-                hatDir.buildDir().resolve(\"clinfo.cpp.o\"),\n-                hatDir.path().resolve(\"backends\/opencl\/cpp\/clinfo.cpp\"),\n-                List.of(\"OpenCL\")\n-        );\n-        var clinfo = cmake.cxxLinkExecutable(\n-                hatDir.buildDir().resolve(\"clinfo\"),\n-                List.of(clinfoObj),\n-                List.of(\"OpenCL\")\n-        );\n-        \/\/ System.exit(1);\n-        \/\/ println(which(\"java\")+\"?\");\n-        \/\/  System.exit(1);\n-\n-        \/\/repo.versions(\"org.testng\", \"testng\").forEach(s->println(s));\n-\n-        println(hatDir.repo().forEachVersion(\"org.testng\", \"testng\", version -> println(version)));\n-\n-        println(hatDir.repo().forEachId(\"org.testng\", \"testng\", id -> println(id)));\n-        \/\/   var testng = artifact(thirdPartyDir,\"org.testng\", \"testng\", new Version(7,1,0));\n-        \/\/   testng.download().dependencies();\n-        \/\/ g.dependencies().stream().forEach(artifactId->println(artifactId.artifactAndVersion()));\n-        \/\/ println(g.pathName());\n-\n-        \/\/  Artifact aparapi = Artifact.of(\"com.aparapi\", \"aparapi\", \"3.0.2\").download(thirdPartyDir);\n-        \/\/  Artifact aparapi_jni = Artifact.of(\"com.aparapi\", \"aparapi-jni\", \"1.4.3\").download(thirdPartyDir);\n-        \/\/  Artifact aparapi_examples = Artifact.of(\"com.aparapi\", \"aparapi-examples\", \"3.0.0\").download(thirdPartyDir);\n-        \/\/  RepoPom testng = repo.get(\"org.testng\", \"testng\", \"7.1.0\");\n-\n-        \/\/  var url = new URI(\"https:\/\/repo1.maven.org\/maven2\/org\/testng\/testng\/7.1.0\/testng-7.1.0.pom\").toURL();\n-        \/\/  var node = new XMLNode(url);\n-        \/\/  RepoPom testng = new RepoPom(new XMLNode(new URI(\"https:\/\/repo1.maven.org\/maven2\/org\/testng\/testng\/7.1.0\/testng-7.1.0.pom\").toURL()));\n-        \/\/  testng.downloadTo(repo.dir, \"jar\");\n-        \/\/ testng.dependencies().stream().forEach(dependency->println(dependency.groupId()));\n-        \/\/ testng.dependencies().stream().forEach(dependency->println(dependency.pomURL()));\n-\n-        \/\/ https:\/\/repo1.maven.org\/maven2\/org\/testng\/testng\/7.1.0\/testng-7.1.0.jar\n-        \/\/ var hatDir = path(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n-\n-        sanity(hatDir);\n-\n-        withExpectedDirectory(hatDir.subDir(\"hat\"), hatProjectDir -> {\n-            var hatJavacOpts = new JavacBuilder().opts(\n-                    \"--source\", \"24\",\n-                    \"--enable-preview\",\n-                    \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                    \"--add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\"\n-            );\n-\n-            var hatJarResult = new Project(hatDir.buildDir(), hatProjectDir, \"1.0\").build(hatJavacOpts);\n-\n-            var hatExampleJavacConfig = new JavacBuilder().basedOn(hatJavacOpts).class_path(hatJarResult.jar);\n-\n-            withExpectedDirectory(hatDir.subDir(\"backends\"), backendsDir -> {\n-                subDirStream(backendsDir, \"opencl\", \"ptx\")\n-                        .map(backendDir -> new Project(hatDir.buildDir(), backendDir, \"1.0\"))\n-                        .parallel()\n-                        .forEach(project -> project.build(\"hat-backend\", hatExampleJavacConfig));\n-\n-                var cmakeBuildDir = hatDir.buildDir().resolve(\"cmake-build-debug\");\n-\n-                if (!isDirectory(cmakeBuildDir)) { \/\/ We need to rerun build -B defaultCMakeBuilder.buildDir\n-                    mkdir(cmakeBuildDir);\n-                    cmake($ -> $\n-                            .S(backendsDir)\n-                            .B(cmakeBuildDir)\n-                            .opts(\"-DHAT_TARGET=\" + hatDir.buildDir())\n-                    );\n-                }\n-\n-                cmake($ -> $\n-                        \/\/ .S(backendsDir)\n-                        .build(cmakeBuildDir)\n-                );\n-            });\n-            assertOrThrow(hatDir.path.resolve(\"examples\"), Files::isDirectory, \"Examples Dir\" );\n-\n-            withExpectedDirectory(hatDir.subDir(\"examples\"), examplesDir ->\n-                    subDirStream(examplesDir, \"blackscholes\", \"mandel\", \"squares\", \"heal\", \"violajones\", \"life\")\n-                            .map(exampleDir -> new Project(hatDir.buildDir(), exampleDir, \"1.0\"))\n-                            .parallel()\n-                            .forEach(project -> project.build(\"hat-example\", hatExampleJavacConfig))\n-            );\n-\n-            withOptionalDirectory(hatDir.subDir(\"hattricks\"), hattricksDir -> {\n-                subDirStream(hattricksDir, \"chess\", \"view\")\n-                        .map(hattrickDir -> new Project(hatDir.buildDir(), hattrickDir, \"1.0\"))\n-                        .parallel()\n-                        .forEach(project -> project.build(\"hat-example\", hatExampleJavacConfig));\n-\n-\n-                withOptionalDirectory(hattricksDir.resolve(\"nbody\"), nbody -> {\n-                    var jextractedJava = mkdir(hatDir.buildDir().resolve(\"jextracted-java\"));\n-                    var extractedOpenCLCode = jextractedJava.resolve(\"opencl\");\n-                    if (!isDirectory(extractedOpenCLCode)) {\n-                        mkdir(extractedOpenCLCode);\n-                        jextract($$ -> $$\n-                                .home(hatDir.requireJExtract())\n-                                .cwd(nbody)\n-                                .output(jextractedJava)\n-                                .target_package(\"opencl\")\n-                                .when(os instanceof OS.Mac, $$$ -> $$$\n-                                        .compile_flag(\"-F\" + ((OS.Mac) os).appLibFrameworks())\n-                                        .library(((OS.Mac) os).frameworkLibrary(\"OpenCL\"))\n-                                        .header(((OS.Mac) os).frameworkHeader(\"OpenCL\", \"opencl.h\"))\n-                                )\n-                        );\n-                    }\n-                    var extractedOpenGLCode = jextractedJava.resolve(\"opengl\");\n-                    if (!isDirectory(extractedOpenGLCode)) {\n-                        mkdir(extractedOpenGLCode);\n-                        jextract($$ -> $$\n-                                .home(hatDir.requireJExtract())\n-                                .cwd(nbody)\n-                                .output(jextractedJava)\n-                                .target_package(\"opengl\")\n-                                .when(os instanceof OS.Mac, $$$ -> $$$\n-                                        .compile_flag(\"-F\" + ((OS.Mac) os).libFrameworks())\n-                                        .library(\n-                                                ((OS.Mac) os).frameworkLibrary(\"GLUT\"),\n-                                                ((OS.Mac) os).frameworkLibrary(\"OpenGL\")\n-                                        )\n-                                        .header(((OS.Mac) os).frameworkHeader(\"GLUT\", \"glut.h\"))\n-                                )\n-                                .when(os instanceof OS.Linux, $$$ -> {\n-\n-                                })\n-                        );\n-                    }\n-\n-                    var nbodyJar = jar($ -> $\n-                            .jar(hatDir.buildDir().resolve(\"hat-example-nbody-1.0.jar\"))\n-                            .path_list(nbody.resolve(\"src\/main\/resources\"))\n-                            .javac($$ -> $$.basedOn(hatExampleJavacConfig)\n-                                    .source_path(nbody.resolve(\"src\/main\/java\"), extractedOpenCLCode, extractedOpenGLCode)\n-                            )\n-                    );\n-\n-                    java($ -> $\n-                            .jdk(Path.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/build\/macosx-aarch64-server-release\/jdk\"))\n-                            .vmopts(\n-                                    \"--enable-preview\",\n-                                    \"--enable-native-access=ALL-UNNAMED\",\n-                                    \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                                    \"-XstartOnFirstThread\"\n-                            )\n-                            .class_path(nbodyJar.jar)\n-                            .main_class(\"nbody.Main\")\n-                    );\n-                });\n-            });\n-        });\n-    }\n-}\n","filename":"hat\/bldr\/src\/main\/java\/bldr\/Bldr.java","additions":0,"deletions":2029,"binary":false,"changes":2029,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+\/* vim: set ft=java:\n@@ -28,0 +28,1 @@\n+ \n@@ -30,59 +31,49 @@\n-   var hatDir = new Root();\n-   if (args.length==0){\n-      println(\"\"\"\n-              usage:\n-                 hatrun [headless] backend package args ...\n-                 headless : Optional passes -Dheadless=true to app\n-                 backend  : opencl|cuda|spirv|ptx|mock\n-                 package  : the examples package (and dirname under hat\/examples)\n-                 Class name is assumed to be package.Main \n-              \"\"\");\n-      System.exit(1);\n-   } else{\n-     var buildDir = assertOrThrow(hatDir.buildDir(), Files::isDirectory, \"Build Directory\");\n-     \n-     int argc=0;\n-     boolean headless = args[argc].equals(\"headless\");\n-     if (headless){\n-        argc++;\n-     }\n-     if (argc<args.length \n-           && hatDir.path().resolve(\"backends\") instanceof Path backendsDir && Files.isDirectory(backendsDir)){\n-        var classPath = new ArrayList<>(List.of(buildDir.resolve(\"hat-1.0.jar\")));\n-        var backendDir = backendsDir.resolve(args[argc++]);\n-        if (argc<args.length && (Files.isDirectory(backendDir) || backendDir.getFileName().toString().equals(\"java\"))){\n-           if (Files.isDirectory(backendDir)){\n-              classPath.add(assertOrThrow(buildDir.resolve(\"hat-backend-\"+backendDir.getFileName()+\"-1.0.jar\"), Files::isRegularFile,\" backend dir\"));\n-           }else{\n-              classPath.add(assertOrThrow(backendsDir.resolve(\"shared\/src\/main\/resources\"), Files::isDirectory, \"backend dir\"));\n-           }\n-           if (argc<args.length &&\n-                assertOrThrow(hatDir.path().resolve(\"examples\"), Files::isDirectory, \"Examples Dir\") instanceof Path examplesDir){\n-              var exampleDir = assertOrThrow(examplesDir.resolve(args[argc++]), Files::isDirectory, \"Example dir\");\n-              classPath.add(assertOrThrow(buildDir.resolve(\"hat-example-\"+exampleDir.getFileName()+\"-1.0.jar\"), Files::isRegularFile,\" example jar \"));\n-              final int finalArgc = argc; \/\/sigh\n-              \n-              java($->$\n-                 .vmopts(\n-                   \"--enable-preview\",\n-                   \"--enable-native-access=ALL-UNNAMED\",\n-                   \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\",\n-                   \"-Djava.library.path=build:\/usr\/local\/lib\"\n-                 )\n-                 .when(headless, $$->$$\n-                    .vmopts(\"-Dheadless=true\")\n-                 )\n-                 .class_path(classPath)\n-                 .main_class(exampleDir.getFileName() + \".Main\")\n-                 .args(Arrays.copyOfRange(args, finalArgc, args.length))\n-              );\n- \n-           }else{\n-              println(\"no example\");\n-           }\n-        }else{\n-           println(\"no backend\");\n-        }\n-     }else{\n-        println(\"junk\");\n-     }\n+ var usage =\n+    \"\"\"\n+    usage:\n+      java @bldr\/args hatrun [headless] backend package args ...\n+         [headless] : Optional passes -Dheadless=true to app\n+          backend   : opencl|cuda|spirv|ptx|mock\n+          package   : the examples package (and dirname under hat\/examples)\n+\n+      class name is assumed to be package.Main  (i.e. mandel.main) \n+\n+      examples:\n+         java @bldr\/args opencl mandel\n+         java @bldr\/args headless opencl mandel\n+    \"\"\";\n+\n+  var hatDir =  Dir.current();\n+  var backends = assertExists(hatDir.dir(\"backends\"));\n+  var examples = assertExists(hatDir.dir(\"examples\"));\n+  var buildDir = assertExists(BuildDir.of(hatDir.path(\"build\")));\n+\n+  var javaBuilder = javaBuilder().vmopts(\n+                  \"--enable-preview\",\n+                  \"--enable-native-access=ALL-UNNAMED\",\n+                  \"--add-exports=java.base\/jdk.internal=ALL-UNNAMED\"\n+          )\n+          .library_path(buildDir)\n+          .class_path(buildDir.jarFile(\"hat-1.0.jar\"));\n+\n+  int argn = 0;\n+  if (args.length > 0 && args[argn].equals(\"headless\")) {\n+      javaBuilder.vmopts(\"-Dheadless=true\");\n+      argn++;\n+  }\n+  if ((argn + 2) > args.length) {\n+      print(\"args[\" + args.length + \"] = [ \");\n+      List.of(args).forEach(a -> print(\" \" + a));\n+      println(\" ]\");\n+      println(usage);\n+  } else {\n+      var backendName = args[argn++];\n+      var exampleName = args[argn++];\n+\n+      if (backendName.equals(\"java\")) {\n+          javaBuilder.class_path(ClassDir.of(backends.path(\"shared\/src\/main\/resources\")));\n+      } else if (backends.dir(backendName) instanceof Dir backend && backend.exists()) {\n+          javaBuilder.class_path(buildDir.jarFile(\"hat-backend-\" + backendName + \"-1.0.jar\"));\n+      } else {\n+          println(\"No backend \" + backendName);\n+      }\n@@ -90,1 +81,11 @@\n-   }\n+      if (examples.dir(exampleName) instanceof Dir example && example.exists()) {\n+          java(javaBuilder\n+                  .verbose()\n+                  .class_path(buildDir.jarFile(\"hat-example-\" + exampleName + \"-1.0.jar\"))\n+                  .main_class(exampleName + \".Main\")\n+                  .args(Arrays.copyOfRange(args, argn, args.length))\n+          );\n+      } else {\n+          println(\"no example \" + exampleName);\n+      }\n+  }\n","filename":"hat\/hatrun","additions":62,"deletions":61,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-\/*\n+\/* vim: set ft=java: \n+ *\n@@ -27,1 +28,0 @@\n-\/\/import static java.nio.file.Files.*; \/\/ so we can use isDirectory(path);\n@@ -30,21 +30,21 @@\n-     var hatDir = new Root();\n-     var rleParserDir = hatDir.path().resolve(\"examples\/life\/src\/main\/java\/io\");\n-     subDirStream(hatDir.path(), \"hat\", \"examples\", \"backends\", \"docs\", \"bldr\")\n-        .forEach(dir ->\n-           findTextFiles(dir, \"java\", \"cpp\", \"h\", \"hpp\", \"md\")\n-              .forEach(textFile -> {\n-                 if (!textFile.hasSuffix(\"md\")\n-                    && !textFile.path().startsWith(rleParserDir)\n-                    && !textFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n-                      System.err.println(\"ERR MISSING LICENSE \" + textFile.path());\n-                 }\n-                 textFile.lines().forEach(line -> {\n-                    if (line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n-                       System.err.println(\"ERR TAB \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n-                    }\n-                    if (line.grep(Pattern.compile(\"^.* $\"))) {\n-                       System.err.println(\"ERR TRAILING WHITESPACE \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n-                    }\n-                 });\n-              })\n-        );\n+  Dir.current().forEachSubDirectory(\"hat\", \"examples\", \"backends\", \"docs\", \"bldr\")\n+    .forEach(dir->dir\n+       .findFiles()\n+          .filter((path)->Pattern.matches(\"^.*\\\\.(java|cpp|h|hpp|md)$\", path.toString()))\n+          .filter((path)->!Pattern.matches(\"^.*examples\/life\/src\/main\/java\/io.*$\", path.toString()))\n+          .map(path->new SearchableTextFile(path))\n+          .forEach(textFile ->{\n+             if (!textFile.hasSuffix(\"md\")\n+               && !textFile.grep(Pattern.compile(\"^.*Copyright.*202[4-9].*(Intel|Oracle).*$\"))) {\n+                  println(\"ERR NO LICENCE \" + textFile.path());\n+             }\n+             textFile.lines().forEach(line -> {\n+               if (line.grep(Pattern.compile(\"^.*\\\\t.*\"))) {\n+                  println(\"ERR        TAB \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+               }\n+               if (line.grep(Pattern.compile(\"^.* $\"))) {\n+                  println(\"ERR EOL WSPACE \" + textFile.path() + \":\" + line.line() + \"#\" + line.num());\n+               }\n+            });\n+          })\n+   );\n","filename":"hat\/sanity","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"}]}