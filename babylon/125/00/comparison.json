{"files":[{"patch":"@@ -0,0 +1,73 @@\n+\n+\n+\n+    \/*\n+     * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+     *\n+     * This code is free software; you can redistribute it and\/or modify it\n+     * under the terms of the GNU General Public License version 2 only, as\n+     * published by the Free Software Foundation.  Oracle designates this\n+     * particular file as subject to the \"Classpath\" exception as provided\n+     * by Oracle in the LICENSE file that accompanied this code.\n+     *\n+     * This code is distributed in the hope that it will be useful, but WITHOUT\n+     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+     * version 2 for more details (a copy is included in the LICENSE file that\n+     * accompanied this code).\n+     *\n+     * You should have received a copy of the GNU General Public License version\n+     * 2 along with this work; if not, write to the Free Software Foundation,\n+     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+     *\n+     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+     * or visit www.oracle.com if you need additional information or have any\n+     * questions.\n+     *\/\n+\n+    package experiments;\n+\n+\n+    import java.lang.reflect.Method;\n+    import java.lang.reflect.code.CopyContext;\n+    import java.lang.reflect.code.Op;\n+    import java.lang.reflect.code.OpTransformer;\n+    import java.lang.reflect.code.TypeElement;\n+    import java.lang.reflect.code.Value;\n+    import java.lang.reflect.code.interpreter.Interpreter;\n+    import java.lang.reflect.code.op.CoreOp;\n+    import java.lang.reflect.code.type.JavaType;\n+    import java.lang.reflect.code.type.MethodRef;\n+    import java.lang.runtime.CodeReflection;\n+    import java.util.List;\n+    import java.util.Map;\n+\n+    public class PrePostInc {\n+        @CodeReflection\n+        public static int  preInc(int value) {\n+            int pre = 25 + ++value;\n+            return pre;\n+        }\n+\n+        @CodeReflection\n+        public static int  postInc(int value) {\n+           int post = 25 + value++;\n+           return post;\n+        }\n+\n+        static public void main(String[] args) throws Exception {\n+            Method pre = PrePostInc.class.getDeclaredMethod(\"preInc\",  int.class);\n+            Method post = PrePostInc.class.getDeclaredMethod(\"postInc\",  int.class);\n+            CoreOp.FuncOp preFunc = pre.getCodeModel().get();\n+            CoreOp.FuncOp postFunc = post.getCodeModel().get();\n+\n+            Object preResult = Interpreter.invoke(preFunc,5);\n+            System.out.println(\"Pre \"+ preResult);\n+            Object postResult = Interpreter.invoke(postFunc,5);\n+            System.out.println(\"Pre \"+ postResult);\n+          \/\/  javaFunc.writeTo(System.out);\n+\n+        }\n+    }\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrePostInc.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\n+\n+\n+    \/*\n+     * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+     * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+     *\n+     * This code is free software; you can redistribute it and\/or modify it\n+     * under the terms of the GNU General Public License version 2 only, as\n+     * published by the Free Software Foundation.  Oracle designates this\n+     * particular file as subject to the \"Classpath\" exception as provided\n+     * by Oracle in the LICENSE file that accompanied this code.\n+     *\n+     * This code is distributed in the hope that it will be useful, but WITHOUT\n+     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+     * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+     * version 2 for more details (a copy is included in the LICENSE file that\n+     * accompanied this code).\n+     *\n+     * You should have received a copy of the GNU General Public License version\n+     * 2 along with this work; if not, write to the Free Software Foundation,\n+     * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+     *\n+     * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+     * or visit www.oracle.com if you need additional information or have any\n+     * questions.\n+     *\/\n+\n+    package experiments;\n+\n+\n+    import hat.Accelerator;\n+    import hat.backend.Backend;\n+    import hat.buffer.S32Array;\n+    import hat.optools.FuncOpWrapper;\n+    import hat.optools.InvokeOpWrapper;\n+    import hat.util.Result;\n+\n+    import java.lang.invoke.MethodHandles;\n+    import java.lang.management.OperatingSystemMXBean;\n+    import java.lang.reflect.Method;\n+    import java.lang.reflect.code.Block;\n+    import java.lang.reflect.code.Body;\n+    import java.lang.reflect.code.CopyContext;\n+    import java.lang.reflect.code.Op;\n+    import java.lang.reflect.code.OpTransformer;\n+    import java.lang.reflect.code.TypeElement;\n+    import java.lang.reflect.code.Value;\n+    import java.lang.reflect.code.interpreter.Interpreter;\n+    import java.lang.reflect.code.op.CoreOp;\n+    import java.lang.reflect.code.op.ExternalizableOp;\n+    import java.lang.reflect.code.type.JavaType;\n+    import java.lang.reflect.code.type.PrimitiveType;\n+    import java.lang.runtime.CodeReflection;\n+    import java.util.ArrayList;\n+    import java.util.List;\n+    import java.util.Map;\n+\n+    public class Ptr {\n+\n+\n+        @CodeReflection\n+        public static void addMul(S32Array s32Array, int add, int mul) {\n+            for (int i = 0; i < s32Array.length(); i++) {\n+                s32Array.array(i, (s32Array.array(i) + add) * mul);\n+            }\n+        }\n+\n+        public static abstract class HatOp extends ExternalizableOp {\n+            private final TypeElement type;\n+\n+            HatOp(String opName) {\n+                super(opName, List.of());\n+                this.type = JavaType.INT;\n+            }\n+\n+            HatOp(String opName, TypeElement type, List<Value> operands) {\n+                super(opName, operands);\n+                this.type = type;\n+            }\n+\n+            HatOp(String opName, TypeElement type, List<Value> operands, Map<String, Object> attributes) {\n+                super(opName, operands);\n+                this.type = type;\n+            }\n+\n+            HatOp(HatOp that, CopyContext cc) {\n+                super(that, cc);\n+                this.type = that.type;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return type;\n+            }\n+\n+           \/\/ @Override\n+           \/\/ public Body body() {\n+          \/\/      return body;\n+          \/\/  }\n+\n+           \/\/ public String functionName() {\n+             \/\/   return functionName;\n+          \/\/  }\n+        }\n+        public static class HatPtrOp extends HatOp  {\n+          \/\/  InvokeOpWrapper ifaceInvokeOpWrapper;\n+\n+            public HatPtrOp(TypeElement typeElement, List<Value> operands) {\n+\n+                super(\"Ptr\",typeElement,operands);\n+            }\n+\n+          \/\/  public HatPtrOp(InvokeOpWrapper ifaceInvokeOpWrapper) {\n+            \/\/    this();\n+            \/\/    this.ifaceInvokeOpWrapper = ifaceInvokeOpWrapper;\n+           \/\/ }\n+\n+            public HatPtrOp(HatOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public Op transform(CopyContext cc, OpTransformer ot) {\n+                return new HatPtrOp(this, cc);\n+            }\n+\n+\n+           \/\/ @Override\n+           \/\/ public Block.Builder lower(Block.Builder builder, OpTransformer opTransformer) {\n+\n+             \/\/   builder.op(ifaceInvokeOpWrapper.op());\n+             \/\/   return builder;\n+           \/\/ }\n+        }\n+\n+\n+        static public void main(String[] args) throws Exception {\n+            Method method = Ptr.class.getDeclaredMethod(\"addMul\", S32Array.class, int.class, int.class);\n+            FuncOpWrapper funcOpWrapper = new FuncOpWrapper(method.getCodeModel().get());\n+            FuncOpWrapper transformedFuncOpWrapper = funcOpWrapper.transformIfaceInvokes((builder, invokeOpWrapper)->{\n+                CopyContext cc = builder.context();\n+                Value arg2 = cc.getValue(funcOpWrapper.parameter(2));\n+              \/\/  Value receiver = cc.\n+               \/\/ Value receiver = cc.getValue(invokeOpWrapper.operandNAsValue(0));\n+                List<Value> operands = new ArrayList<>();\n+                operands.add(arg2);\n+                builder.op(new HatPtrOp( JavaType.INT,operands));\n+            });\n+\n+            System.out.println(transformedFuncOpWrapper.toText());\n+\n+            var loweredFuncOpWrapper =  transformedFuncOpWrapper.lower();\n+            System.out.println(transformedFuncOpWrapper.toText());\n+            Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+            var s32Array = S32Array.create(accelerator, 64);\n+            for (int i = 0; i < 64; i++) {\n+                s32Array.array(i, i);\n+            }\n+\n+            Interpreter.invoke(MethodHandles.lookup(),loweredFuncOpWrapper.op(), s32Array, 2, 2);\n+            for (int i = 0; i < 6; i++) {\n+                System.out.println(s32Array.array(i));\n+            }\n+        }\n+    }\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Ptr.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"}]}