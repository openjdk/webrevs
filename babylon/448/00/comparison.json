{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,12 +29,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n@@ -67,1 +55,3 @@\n-            return SSAConstruction.transform(nestedOp);\n+            return SSABraun.transform(nestedOp);\n+        } else {\n+            return SSACytron.transform(nestedOp);\n@@ -69,299 +59,0 @@\n-        Map<Block, Set<CoreOp.VarOp>> joinPoints = new HashMap<>();\n-        Map<CoreOp.VarAccessOp.VarLoadOp, Object> loadValues = new HashMap<>();\n-        Map<Block.Reference, List<Object>> joinSuccessorValues = new HashMap<>();\n-\n-        Map<Body, Boolean> visited = new HashMap<>();\n-        Map<Block, Map<CoreOp.VarOp, Block.Parameter>> joinBlockArguments = new HashMap<>();\n-        @SuppressWarnings(\"unchecked\")\n-        T ssaOp = (T) nestedOp.transform(CopyContext.create(), (block, op) -> {\n-            \/\/ Compute join points and value mappings for body\n-            visited.computeIfAbsent(op.ancestorBody(), b -> {\n-                findJoinPoints(b, joinPoints);\n-                variableToValue(b, joinPoints, loadValues, joinSuccessorValues);\n-                return true;\n-            });\n-\n-            if (op instanceof CoreOp.VarOp || op instanceof CoreOp.VarAccessOp) {\n-                \/\/ Drop var operations\n-                if (op instanceof CoreOp.VarAccessOp.VarLoadOp vl) {\n-                    \/\/ Replace result of load\n-                    Object loadValue = loadValues.get(vl);\n-                    CopyContext cc = block.context();\n-                    Value v = loadValue instanceof VarOpBlockArgument vba\n-                            ? joinBlockArguments.get(vba.b()).get(vba.vop())\n-                            : cc.getValue((Value) loadValue);\n-                    cc.mapValue(op.result(), v);\n-                }\n-            } else if (op instanceof Op.Terminating) {\n-                for (Block.Reference s : op.successors()) {\n-                    List<Object> joinValues = joinSuccessorValues.get(s);\n-                    \/\/ Successor has join values\n-                    if (joinValues != null) {\n-                        CopyContext cc = block.context();\n-\n-                        \/\/ Lazily append target block arguments\n-                        joinBlockArguments.computeIfAbsent(s.targetBlock(), b -> {\n-                            Block.Builder bb = cc.getBlock(b);\n-                            return joinPoints.get(b).stream().collect(Collectors.toMap(\n-                                    varOp -> varOp,\n-                                    varOp -> bb.parameter(varOp.varValueType())));\n-                        });\n-\n-                        \/\/ Append successor arguments\n-                        List<Value> values = new ArrayList<>();\n-                        for (Object o : joinValues) {\n-                            Value v = o instanceof VarOpBlockArgument vba\n-                                    ? joinBlockArguments.get(vba.b()).get(vba.vop())\n-                                    : cc.getValue((Value) o);\n-                            values.add(v);\n-                        }\n-\n-                        \/\/ Map successor with append arguments\n-                        List<Value> toArgs = cc.getValues(s.arguments());\n-                        toArgs.addAll(values);\n-                        Block.Reference toS = cc.getBlock(s.targetBlock()).successor(toArgs);\n-                        cc.mapSuccessor(s, toS);\n-                    }\n-                }\n-\n-                block.apply(op);\n-            } else {\n-                block.apply(op);\n-            }\n-\n-            return block;\n-        });\n-        return ssaOp;\n-    }\n-\n-    record VarOpBlockArgument(Block b, CoreOp.VarOp vop) {\n-    }\n-\n-    enum Uninitialized {\n-        UNINITIALIZED;\n-    }\n-\n-    \/\/ @@@ Check for var uses in exception regions\n-    \/\/     A variable cannot be converted to SAA form if the variable is stored\n-    \/\/     to in an exception region and accessed from an associated catch region\n-\n-    static void variableToValue(Body body,\n-                                Map<Block, Set<CoreOp.VarOp>> joinPoints,\n-                                Map<CoreOp.VarAccessOp.VarLoadOp, Object> loadValues,\n-                                Map<Block.Reference, List<Object>> joinSuccessorValues) {\n-        Map<CoreOp.VarOp, Deque<Object>> variableStack = new HashMap<>();\n-        Node top = buildDomTree(body.entryBlock(), body.immediateDominators());\n-        variableToValue(top, variableStack, joinPoints, loadValues, joinSuccessorValues);\n-    }\n-\n-    \/**\n-     * Replaces usages of a variable with the corresponding value, from a given block node in the dominator tree.\n-     * <p>\n-     * The result of a {@code VarLoadOp} for variable, {@code V} say the result of a {@code VarOp} operation,\n-     * is replaced with the value passed as an operand to the immediately dominating {@code VarStoreOp} that operates\n-     * on {@code V}, or a block argument representing the equivalent of a phi-value of {@code V}.\n-     * After which, any related {@code VarOp}, {@code VarLoadOp}, or {@code VarStoreOp} operations are removed.\n-     *\n-     * @param n             the node in the dominator tree\n-     * @param variableStack the variable stack\n-     * @param joinPoints    the join points\n-     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n-     * Section 5.2 and Figure 12.\n-     *\/\n-    static void variableToValue(Node n,\n-                                Map<CoreOp.VarOp, Deque<Object>> variableStack,\n-                                Map<Block, Set<CoreOp.VarOp>> joinPoints,\n-                                Map<CoreOp.VarAccessOp.VarLoadOp, Object> loadValues,\n-                                Map<Block.Reference, List<Object>> joinSuccessorValues) {\n-        int size = n.b().ops().size();\n-\n-        \/\/ Check if V is associated with block argument (phi)\n-        \/\/ Push argument onto V's stack\n-        {\n-            Set<CoreOp.VarOp> varOps = joinPoints.get(n.b());\n-            if (varOps != null) {\n-                varOps.forEach(v -> {\n-                    assert variableStack.containsKey(v);\n-                    variableStack.get(v).push(new VarOpBlockArgument(n.b(), v));\n-                });\n-            }\n-        }\n-\n-        {\n-            for (int i = 0; i < size - 1; i++) {\n-                Op op = n.b().ops().get(i);\n-\n-                if (op instanceof CoreOp.VarOp varOp) {\n-                    \/\/ Initial value assigned to variable\n-                    Object current = varOp.isUninitialized()\n-                            ? Uninitialized.UNINITIALIZED\n-                            : op.operands().get(0);\n-                    assert !variableStack.containsKey(varOp);\n-                    variableStack.computeIfAbsent(varOp, _ -> new ArrayDeque<>())\n-                            .push(current);\n-                } else if (op instanceof CoreOp.VarAccessOp.VarStoreOp storeOp) {\n-                    \/\/ Value assigned to variable\n-                    Value current = op.operands().get(1);\n-                    variableStack.get(storeOp.varOp()).push(current);\n-                } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp loadOp &&\n-                           loadOp.varOp().ancestorBody() == op.ancestorBody()) {\n-                    Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n-                    loadValues.put(loadOp, to);\n-                } else if (op instanceof Op.Nested) {\n-                    \/\/ Traverse descendant variable loads for variables\n-                    \/\/ declared in the block's parent body\n-                    op.traverse(null, (_, ce) -> {\n-                        if (ce instanceof CoreOp.VarAccessOp.VarLoadOp loadOp &&\n-                                loadOp.varOp().ancestorBody() == op.ancestorBody()) {\n-                            Object to = peekAtCurrentVariable(variableStack, loadOp.varOp());\n-                            loadValues.put(loadOp, to);\n-                        }\n-                        return null;\n-                    });\n-                }\n-            }\n-\n-            \/\/ Add successor args for joint points\n-            for (Block.Reference succ : n.b().successors()) {\n-                Set<CoreOp.VarOp> varOps = joinPoints.get(succ.targetBlock());\n-                if (varOps != null) {\n-                    List<Object> joinValues = varOps.stream()\n-                            .map(vop -> peekAtCurrentVariable(variableStack, vop)).toList();\n-                    joinSuccessorValues.put(succ, joinValues);\n-                }\n-            }\n-\n-            \/\/ The result of a VarOp, a variable value, can only be used in VarStoreOp and VarLoadOp\n-            \/\/ therefore there is no need to check existing successor arguments\n-        }\n-\n-        \/\/ Traverse children of dom tree\n-        for (Node y : n.children()) {\n-            variableToValue(y, variableStack, joinPoints, loadValues, joinSuccessorValues);\n-        }\n-\n-        \/\/ Pop off values for variables\n-        {\n-            Set<CoreOp.VarOp> varOps = joinPoints.get(n.b());\n-            if (varOps != null) {\n-                varOps.forEach(v -> {\n-                    variableStack.get(v).pop();\n-                });\n-            }\n-\n-            for (int i = 0; i < size - 1; i++) {\n-                Op op = n.b().ops().get(i);\n-\n-                if (op instanceof CoreOp.VarOp varOp) {\n-                    variableStack.get(varOp).pop();\n-                } else if (op instanceof CoreOp.VarAccessOp.VarStoreOp storeOp) {\n-                    variableStack.get(storeOp.varOp()).pop();\n-                }\n-            }\n-        }\n-    }\n-\n-    static Object peekAtCurrentVariable(Map<CoreOp.VarOp, Deque<Object>> variableStack, CoreOp.VarOp vop) {\n-        Object to = variableStack.get(vop).peek();\n-        return throwIfUninitialized(vop, to);\n-    }\n-\n-    static Object throwIfUninitialized(CoreOp.VarOp vop, Object to) {\n-        if (to instanceof Uninitialized) {\n-            throw new IllegalStateException(\"Loading from uninitialized variable: \" + vop);\n-        }\n-        return to;\n-    }\n-\n-    \/**\n-     * Finds the join points of a body.\n-     * <p>\n-     * A join point is a block that is in the dominance frontier of one or more predecessors, that make one or more\n-     * stores to variables (using the {@code VarStoreOp} operation on the result of a {@code VarOp} operation).\n-     * The join point contains the set variables ({@code VarOp} operations) that are stored to.\n-     * <p>\n-     * A variable of a joint point indicates that a block argument may need to be added to the join point's block\n-     * when converting variables to SSA form. Different values of a variable may occur at different control flow\n-     * paths at the join point. The block argument represents the convergence of multiple values for the same\n-     * variable, where a predecessor assigns to the block argument.\n-     * (Block arguments are equivalent to phi-values, or phi-nodes, used in other representations.)\n-     *\n-     * @param body the body.\n-     * @param joinPoints the returned join points.\n-     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n-     * Section 5.1 and Figure 11.\n-     *\/\n-    public static void findJoinPoints(Body body, Map<Block, Set<CoreOp.VarOp>> joinPoints) {\n-        Map<Block, Set<Block>> df = body.dominanceFrontier();\n-        Map<CoreOp.VarOp, Set<Block>> a = findVarStores(body);\n-\n-        int iterCount = 0;\n-        int[] hasAlready = new int[body.blocks().size()];\n-        int[] work = new int[body.blocks().size()];\n-\n-        Deque<Block> w = new ArrayDeque<>();\n-\n-        for (CoreOp.VarOp v : a.keySet()) {\n-            iterCount++;\n-\n-            for (Block x : a.get(v)) {\n-                work[x.index()] = iterCount;\n-                w.push(x);\n-            }\n-\n-            while (!w.isEmpty()) {\n-                Block x = w.pop();\n-\n-                for (Block y : df.getOrDefault(x, Set.of())) {\n-                    if (hasAlready[y.index()] < iterCount) {\n-                        \/\/ Only add to the join points if y is dominated by the var's block\n-                        if (y.isDominatedBy(v.parentBlock())) {\n-                            joinPoints.computeIfAbsent(y, _k -> new LinkedHashSet<>()).add(v);\n-                        }\n-                        hasAlready[y.index()] = iterCount;\n-\n-                        if (work[y.index()] < iterCount) {\n-                            work[y.index()] = iterCount;\n-                            w.push(y);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ Returns map of variable to blocks that contain stores to the variables declared in the body\n-    \/\/ Throws ISE if a descendant store operation is encountered\n-    \/\/ @@@ Compute map for whole tree, then traverse keys with filter\n-    static Map<CoreOp.VarOp, Set<Block>> findVarStores(Body r) {\n-        return r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((stores, op) -> {\n-            if (op instanceof CoreOp.VarAccessOp.VarStoreOp storeOp) {\n-                if (storeOp.varOp().ancestorBody() != storeOp.ancestorBody()) {\n-                    throw new IllegalStateException(\"Descendant variable store operation\");\n-                }\n-                if (storeOp.varOp().ancestorBody() == r) {\n-                    stores.computeIfAbsent(storeOp.varOp(), _v -> new LinkedHashSet<>()).add(storeOp.parentBlock());\n-                }\n-            }\n-            return stores;\n-        }));\n-    }\n-\n-    record Node(Block b, Set<Node> children) {\n-    }\n-\n-    static Node buildDomTree(Block entryBlock, Map<Block, Block> idoms) {\n-        Map<Block, Node> tree = new HashMap<>();\n-        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n-            Block id = e.getValue();\n-            Block b = e.getKey();\n-\n-            Node parent = tree.computeIfAbsent(id, _k -> new Node(_k, new HashSet<>()));\n-            if (b == entryBlock) {\n-                continue;\n-            }\n-\n-            Node child = tree.computeIfAbsent(b, _k -> new Node(_k, new HashSet<>()));\n-            parent.children.add(child);\n-        }\n-        return tree.get(entryBlock);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSA.java","additions":4,"deletions":313,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.code.analysis;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SequencedSet;\n+import java.util.Set;\n+\n+\/**\n+ * An implementation of SSA construction based on\n+ * <a href=\"https:\/\/doi.org\/10.1007\/978-3-642-37051-9\">\n+ * Simple end Efficient Construction of Static Single Assignment Form (pp 102-122)\n+ * <\/a>.\n+ * <p>\n+ * This implementation contains some adaptions, notably:\n+ * <ul>\n+ *     <li>Adapt to block parameters rather than phi functions.<\/li>\n+ *     <li>Adapt to work with multiple bodies.<\/li>\n+ * <\/ul>\n+ *\/\n+final class SSABraun implements OpTransformer {\n+    private final Map<CoreOp.VarOp, Map<Block, Val>> currentDef = new HashMap<>();\n+    private final Set<Block> sealedBlocks = new HashSet<>();\n+    private final Map<Block, Map<CoreOp.VarOp, Phi>> incompletePhis = new HashMap<>();\n+\n+    \/\/ according to the algorithm:\n+    \/\/ \"As only filled blocks may have successors, predecessors are always filled.\"\n+    \/\/ In consequence, this means that only filled predecessors should be considered\n+    \/\/ when recursively searching for a definition\n+    private final Map<Block, SequencedSet<Block>> predecessors = new HashMap<>();\n+    \/\/ as we can't modify the graph at the same time as we analyze it,\n+    \/\/ we need to store which load op needs to remapped to which value\n+    private final Map<CoreOp.VarAccessOp.VarLoadOp, Val> loads = new HashMap<>();\n+    private final Map<Block, List<Phi>> additionalParameters = new HashMap<>();\n+    \/\/ as we look up definitions during the actual transformation again,\n+    \/\/ we might encounter deleted phis.\n+    \/\/ we use this set to be able to correct that during transformation\n+    private final Set<Phi> deletedPhis = new HashSet<>();\n+\n+    static <O extends Op & Op.Nested> O transform(O nestedOp) {\n+        SSABraun construction = new SSABraun();\n+        construction.prepare(nestedOp);\n+        @SuppressWarnings(\"unchecked\")\n+        O ssaOp = (O) nestedOp.transform(CopyContext.create(), construction);\n+        return ssaOp;\n+    }\n+\n+    private SSABraun() {\n+    }\n+\n+    private void prepare(Op nestedOp) {\n+        nestedOp.traverse(null, CodeElement.opVisitor((_, op) -> {\n+            switch (op) {\n+                case CoreOp.VarAccessOp.VarLoadOp load -> {\n+                    Val val = readVariable(load.varOp(), load.parentBlock());\n+                    registerLoad(load, val);\n+                }\n+                case CoreOp.VarAccessOp.VarStoreOp store ->\n+                        writeVariable(store.varOp(), store.parentBlock(), new Holder(store.storeOperand()));\n+                case CoreOp.VarOp initialStore -> {\n+                    Val val = initialStore.isUninitialized()\n+                            ? Uninitialized.VALUE\n+                            : new Holder(initialStore.initOperand());\n+                    writeVariable(initialStore, initialStore.parentBlock(), val);\n+                }\n+                case Op.Terminating _ -> {\n+                    Block block = op.parentBlock();\n+                    \/\/ handle the sealing, i.e. only now make this block a predecessor of its successors\n+                    for (Block.Reference successor : block.successors()) {\n+                        Block successorBlock = successor.targetBlock();\n+                        Set<Block> blocks = this.predecessors.computeIfAbsent(successorBlock, _ -> new LinkedHashSet<>());\n+                        blocks.add(block);\n+                        \/\/ if this was the last predecessor added to successorBlock, seal it\n+                        if (blocks.size() == successorBlock.predecessors().size()) {\n+                            sealBlock(successorBlock);\n+                        }\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return null;\n+        }));\n+    }\n+\n+    private void registerLoad(CoreOp.VarAccessOp.VarLoadOp load, Val val) {\n+        this.loads.put(load, val);\n+        if (val instanceof Phi phi) {\n+            phi.users.add(load);\n+        }\n+    }\n+\n+    private void writeVariable(CoreOp.VarOp variable, Block block, Val value) {\n+        this.currentDef.computeIfAbsent(variable, _ -> new HashMap<>()).put(block, value);\n+    }\n+\n+    private Val readVariable(CoreOp.VarOp variable, Block block) {\n+        Val value = this.currentDef.getOrDefault(variable, Map.of()).get(block);\n+        if (value == null\n+            \/\/ deleted Phi, this is an old reference\n+            \/\/ due to our 2-step variant of the original algorithm, we might encounter outdated definitions\n+            \/\/ when we read to prepare block arguments\n+            || value instanceof Phi phi && this.deletedPhis.contains(phi)) {\n+            return readVariableRecursive(variable, block);\n+        }\n+        return value;\n+    }\n+\n+    private Val readVariableRecursive(CoreOp.VarOp variable, Block block) {\n+        Val value;\n+        if (!block.isEntryBlock() && !this.sealedBlocks.contains(block)) {\n+            Phi phi = new Phi(variable, block);\n+            value = phi;\n+            this.incompletePhis.computeIfAbsent(block, _ -> new HashMap<>()).put(variable, phi);\n+            this.additionalParameters.computeIfAbsent(block, _ -> new ArrayList<>()).add(phi);\n+        } else if (block.isEntryBlock() && variable.ancestorBody() != block.parentBody()) {\n+            \/\/ we are in an entry block but didn't find a definition yet\n+            Block enclosingBlock = block.parent().parent().parent();\n+            assert enclosingBlock != null : \"def not found in entry block, with no enclosing block\";\n+            value = readVariable(variable, enclosingBlock);\n+        } else if (this.predecessors.get(block).size() == 1) {\n+            value = readVariable(variable, this.predecessors.get(block).getFirst());\n+        } else {\n+            Phi param = new Phi(variable, block);\n+            writeVariable(variable, block, param);\n+            value = addPhiOperands(variable, param);\n+            \/\/ To go from Phis to block parameters, we remember that we produced a Phi here.\n+            \/\/ This means that edges to this block need to pass a value via parameter\n+            if (value == param) {\n+                this.additionalParameters.computeIfAbsent(block, _ -> new ArrayList<>()).add(param);\n+            }\n+        }\n+        writeVariable(variable, block, value); \/\/ cache value for this variable + block\n+        return value;\n+    }\n+\n+    private Val addPhiOperands(CoreOp.VarOp variable, Phi value) {\n+        for (Block pred : this.predecessors.getOrDefault(value.block(), Collections.emptySortedSet())) {\n+            value.appendOperand(readVariable(variable, pred));\n+        }\n+        return tryRemoveTrivialPhi(value);\n+    }\n+\n+    private Val tryRemoveTrivialPhi(Phi phi) {\n+        Val same = null;\n+        for (Val op : phi.operands()) {\n+            if (op == same || op == phi) {\n+                continue;\n+            }\n+            if (same != null) {\n+                return phi;\n+            }\n+            same = op;\n+        }\n+        \/\/ we shouldn't have phis without operands (other than itself)\n+        assert same != null : \"phi without different operands\";\n+        List<Phi> phiUsers = phi.replaceBy(same, this);\n+        List<Phi> phis = this.additionalParameters.get(phi.block());\n+        if (phis != null) {\n+            phis.remove(phi);\n+        }\n+        for (Phi user : phiUsers) {\n+            tryRemoveTrivialPhi(user);\n+        }\n+        return same;\n+    }\n+\n+    private void sealBlock(Block block) {\n+        this.incompletePhis.getOrDefault(block, Map.of()).forEach(this::addPhiOperands);\n+        this.sealedBlocks.add(block);\n+    }\n+\n+    \/\/ only used during transformation\n+\n+    private Value resolveValue(CopyContext context, Val val) {\n+        return switch (val) {\n+            case Uninitialized _ -> throw new IllegalStateException(\"Uninitialized variable\");\n+            case Holder holder -> context.getValueOrDefault(holder.value(), holder.value());\n+            case Phi phi -> {\n+                List<Phi> phis = this.additionalParameters.get(phi.block());\n+                int additionalParameterIndex = phis.indexOf(phi);\n+                assert additionalParameterIndex >= 0 : \"phi not in parameters \" + phi;\n+                int index = additionalParameterIndex + phi.block().parameters().size();\n+                Block.Builder b = context.getBlock(phi.block());\n+                yield b.parameters().get(index);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public Block.Builder apply(Block.Builder block, Op op) {\n+        Block originalBlock = op.parentBlock();\n+        CopyContext context = block.context();\n+        switch (op) {\n+            case CoreOp.VarAccessOp.VarLoadOp load -> {\n+                Val val = this.loads.get(load);\n+                context.mapValue(load.result(), resolveValue(context, val));\n+            }\n+            case CoreOp.VarOp _, CoreOp.VarAccessOp.VarStoreOp _ -> {\n+            }\n+            case Op.Terminating _ -> {\n+                \/\/ make sure outgoing branches are corrected\n+                for (Block.Reference successor : originalBlock.successors()) {\n+                    Block successorBlock = successor.targetBlock();\n+                    List<Phi> successorParams = this.additionalParameters.getOrDefault(successorBlock, List.of());\n+                    List<Value> additionalParams = successorParams.stream()\n+                            .map(phi -> readVariable(phi.variable, originalBlock))\n+                            .map(val -> resolveValue(context, val))\n+                            .toList();\n+                    List<Value> values = context.getValues(successor.arguments());\n+                    values.addAll(additionalParams);\n+                    Block.Builder successorBlockBuilder = context.getBlock(successorBlock);\n+                    context.mapSuccessor(successor, successorBlockBuilder.successor(values));\n+                }\n+                block.op(op);\n+            }\n+            default -> block.op(op);\n+        }\n+        return block;\n+    }\n+\n+    @Override\n+    public void apply(Block.Builder block, Block b) {\n+        \/\/ add the required additional parameters to this block\n+        boolean isEntry = b.isEntryBlock();\n+        for (Phi phi : this.additionalParameters.getOrDefault(b, List.of())) {\n+            if (isEntry) {\n+                \/\/ Phis in entry blocks denote captured values. Do not add as param but make sure\n+                \/\/ the original value is used\n+                assert phi.operands().size() == 1 : \"entry block phi with multiple operands\";\n+                CopyContext context = block.context();\n+                context.mapValue(resolveValue(context, phi), resolveValue(context, phi.operands().getFirst()));\n+            } else {\n+                block.parameter(phi.variable.varValueType());\n+            }\n+        }\n+\n+        \/\/ actually visit ops in this block\n+        OpTransformer.super.apply(block, b);\n+    }\n+\n+    sealed interface Val {\n+    }\n+\n+    record Holder(Value value) implements Val {\n+    }\n+\n+    enum Uninitialized implements Val {\n+        VALUE;\n+    }\n+\n+    record Phi(CoreOp.VarOp variable, Block block, List<Val> operands, Set<Object> users) implements Val {\n+        Phi(CoreOp.VarOp variable, Block block) {\n+            this(variable, block, new ArrayList<>(), new HashSet<>());\n+        }\n+\n+        void appendOperand(Val val) {\n+            this.operands.add(val);\n+            if (val instanceof Phi phi) { \/\/ load op uses are added separately\n+                phi.users.add(this);\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return this == obj;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(this.variable, this.block);\n+        }\n+\n+        public List<Phi> replaceBy(Val same, SSABraun construction) {\n+            List<Phi> usingPhis = new ArrayList<>();\n+            for (Object user : this.users) {\n+                if (user == this) {\n+                    continue;\n+                }\n+                if (same instanceof Phi samePhi) {\n+                    samePhi.users.add(user);\n+                }\n+                switch (user) {\n+                    case Phi phi -> {\n+                        int i = phi.operands.indexOf(this);\n+                        assert i >= 0 : \"use does not have this as operand\";\n+                        phi.operands.set(i, same);\n+                        usingPhis.add(phi);\n+                    }\n+                    case CoreOp.VarAccessOp.VarLoadOp load -> construction.loads.put(load, same);\n+                    default -> throw new UnsupportedOperationException(user + \":\" + user.getClass());\n+                }\n+            }\n+            if (same instanceof Phi samePhi) {\n+                samePhi.users.remove(this);\n+            }\n+            construction.currentDef.get(this.variable).put(this.block, same);\n+            construction.deletedPhis.add(this); \/\/ we might not replace all current defs, so mark this phi as deleted\n+            this.users.clear();\n+            return usingPhis;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Phi[\" + variable.varName() + \"(\" + block.index() + \"),\" + \"operands: \" + operands.size() + \"}\";\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSABraun.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -1,321 +0,0 @@\n-package jdk.incubator.code.analysis;\n-\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.SequencedSet;\n-import java.util.Set;\n-\n-\/**\n- * This is an implementation of SSA construction based on\n- * <a href=\"https:\/\/doi.org\/10.1007\/978-3-642-37051-9\">\n- * Simple end Efficient Construction of Static Single Assignment Form (pp 102-122)\n- * <\/a>.\n- * <p>\n- * This implementation contains some adaptions, notably:\n- * <ul>\n- *     <li>Adapt to block parameters rather than phi functions.<\/li>\n- *     <li>Adapt to work with multiple bodies.<\/li>\n- * <\/ul>\n- *\/\n-public class SSAConstruction implements OpTransformer {\n-\n-    private final Map<CoreOp.VarOp, Map<Block, Val>> currentDef = new HashMap<>();\n-    private final Set<Block> sealedBlocks = new HashSet<>();\n-    private final Map<Block, Map<CoreOp.VarOp, Phi>> incompletePhis = new HashMap<>();\n-\n-    \/\/ according to the algorithm:\n-    \/\/ \"As only filled blocks may have successors, predecessors are always filled.\"\n-    \/\/ In consequence, this means that only filled predecessors should be considered\n-    \/\/ when recursively searching for a definition\n-    private final Map<Block, SequencedSet<Block>> predecessors = new HashMap<>();\n-    \/\/ as we can't modify the graph at the same time as we analyze it,\n-    \/\/ we need to store which load op needs to remapped to which value\n-    private final Map<CoreOp.VarAccessOp.VarLoadOp, Val> loads = new HashMap<>();\n-    private final Map<Block, List<Phi>> additionalParameters = new HashMap<>();\n-    \/\/ as we look up definitions during the actual transformation again,\n-    \/\/ we might encounter deleted phis.\n-    \/\/ we use this set to be able to correct that during transformation\n-    private final Set<Phi> deletedPhis = new HashSet<>();\n-\n-    public static <O extends Op> O transform(O nestedOp) {\n-        SSAConstruction construction = new SSAConstruction();\n-        construction.prepare(nestedOp);\n-        @SuppressWarnings(\"unchecked\")\n-        O temp = (O) nestedOp.transform(CopyContext.create(), construction);\n-        return temp;\n-    }\n-\n-    private SSAConstruction() {\n-    }\n-\n-    private void prepare(Op nestedOp) {\n-        nestedOp.traverse(null, CodeElement.opVisitor((_, op) -> {\n-            switch (op) {\n-                case CoreOp.VarAccessOp.VarLoadOp load -> {\n-                    Val val = readVariable(load.varOp(), load.parentBlock());\n-                    registerLoad(load, val);\n-                }\n-                case CoreOp.VarAccessOp.VarStoreOp store ->\n-                        writeVariable(store.varOp(), store.parentBlock(), new Holder(store.storeOperand()));\n-                case CoreOp.VarOp initialStore -> {\n-                    Val val = initialStore.isUninitialized()\n-                            ? Uninitialized.VALUE\n-                            : new Holder(initialStore.initOperand());\n-                    writeVariable(initialStore, initialStore.parentBlock(), val);\n-                }\n-                case Op.Terminating _ -> {\n-                    Block block = op.parentBlock();\n-                    \/\/ handle the sealing, i.e. only now make this block a predecessor of its successors\n-                    for (Block.Reference successor : block.successors()) {\n-                        Block successorBlock = successor.targetBlock();\n-                        Set<Block> blocks = this.predecessors.computeIfAbsent(successorBlock, _ -> new LinkedHashSet<>());\n-                        blocks.add(block);\n-                        \/\/ if this was the last predecessor added to successorBlock, seal it\n-                        if (blocks.size() == successorBlock.predecessors().size()) {\n-                            sealBlock(successorBlock);\n-                        }\n-                    }\n-                }\n-                default -> {\n-                }\n-            }\n-            return null;\n-        }));\n-    }\n-\n-    private void registerLoad(CoreOp.VarAccessOp.VarLoadOp load, Val val) {\n-        this.loads.put(load, val);\n-        if (val instanceof Phi phi) {\n-            phi.users.add(load);\n-        }\n-    }\n-\n-    private void writeVariable(CoreOp.VarOp variable, Block block, Val value) {\n-        this.currentDef.computeIfAbsent(variable, _ -> new HashMap<>()).put(block, value);\n-    }\n-\n-    private Val readVariable(CoreOp.VarOp variable, Block block) {\n-        Val value = this.currentDef.getOrDefault(variable, Map.of()).get(block);\n-        if (value == null\n-            \/\/ deleted Phi, this is an old reference\n-            \/\/ due to our 2-step variant of the original algorithm, we might encounter outdated definitions\n-            \/\/ when we read to prepare block arguments\n-            || value instanceof Phi phi && this.deletedPhis.contains(phi)) {\n-            return readVariableRecursive(variable, block);\n-        }\n-        return value;\n-    }\n-\n-    private Val readVariableRecursive(CoreOp.VarOp variable, Block block) {\n-        Val value;\n-        if (!block.isEntryBlock() && !this.sealedBlocks.contains(block)) {\n-            Phi phi = new Phi(variable, block);\n-            value = phi;\n-            this.incompletePhis.computeIfAbsent(block, _ -> new HashMap<>()).put(variable, phi);\n-            this.additionalParameters.computeIfAbsent(block, _ -> new ArrayList<>()).add(phi);\n-        } else if (block.isEntryBlock() && variable.ancestorBody() != block.parentBody()) {\n-            \/\/ we are in an entry block but didn't find a definition yet\n-            Block enclosingBlock = block.parent().parent().parent();\n-            assert enclosingBlock != null : \"def not found in entry block, with no enclosing block\";\n-            value = readVariable(variable, enclosingBlock);\n-        } else if (this.predecessors.get(block).size() == 1) {\n-            value = readVariable(variable, this.predecessors.get(block).getFirst());\n-        } else {\n-            Phi param = new Phi(variable, block);\n-            writeVariable(variable, block, param);\n-            value = addPhiOperands(variable, param);\n-            \/\/ To go from Phis to block parameters, we remember that we produced a Phi here.\n-            \/\/ This means that edges to this block need to pass a value via parameter\n-            if (value == param) {\n-                this.additionalParameters.computeIfAbsent(block, _ -> new ArrayList<>()).add(param);\n-            }\n-        }\n-        writeVariable(variable, block, value); \/\/ cache value for this variable + block\n-        return value;\n-    }\n-\n-    private Val addPhiOperands(CoreOp.VarOp variable, Phi value) {\n-        for (Block pred : this.predecessors.getOrDefault(value.block(), Collections.emptySortedSet())) {\n-            value.appendOperand(readVariable(variable, pred));\n-        }\n-        return tryRemoveTrivialPhi(value);\n-    }\n-\n-    private Val tryRemoveTrivialPhi(Phi phi) {\n-        Val same = null;\n-        for (Val op : phi.operands()) {\n-            if (op == same || op == phi) {\n-                continue;\n-            }\n-            if (same != null) {\n-                return phi;\n-            }\n-            same = op;\n-        }\n-        \/\/ we shouldn't have phis without operands (other than itself)\n-        assert same != null : \"phi without different operands\";\n-        List<Phi> phiUsers = phi.replaceBy(same, this);\n-        List<Phi> phis = this.additionalParameters.get(phi.block());\n-        if (phis != null) {\n-            phis.remove(phi);\n-        }\n-        for (Phi user : phiUsers) {\n-            tryRemoveTrivialPhi(user);\n-        }\n-        return same;\n-    }\n-\n-    private void sealBlock(Block block) {\n-        this.incompletePhis.getOrDefault(block, Map.of()).forEach(this::addPhiOperands);\n-        this.sealedBlocks.add(block);\n-    }\n-\n-    \/\/ only used during transformation\n-\n-    private Value resolveValue(CopyContext context, Val val) {\n-        return switch (val) {\n-            case Uninitialized _ -> throw new IllegalStateException(\"Uninitialized variable\");\n-            case Holder holder -> context.getValueOrDefault(holder.value(), holder.value());\n-            case Phi phi -> {\n-                List<Phi> phis = this.additionalParameters.get(phi.block());\n-                int additionalParameterIndex = phis.indexOf(phi);\n-                assert additionalParameterIndex >= 0 : \"phi not in parameters \" + phi;\n-                int index = additionalParameterIndex + phi.block().parameters().size();\n-                Block.Builder b = context.getBlock(phi.block());\n-                yield b.parameters().get(index);\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public Block.Builder apply(Block.Builder block, Op op) {\n-        Block originalBlock = op.parentBlock();\n-        CopyContext context = block.context();\n-        switch (op) {\n-            case CoreOp.VarAccessOp.VarLoadOp load -> {\n-                Val val = this.loads.get(load);\n-                context.mapValue(load.result(), resolveValue(context, val));\n-            }\n-            case CoreOp.VarOp _, CoreOp.VarAccessOp.VarStoreOp _ -> {\n-            }\n-            case Op.Terminating _ -> {\n-                \/\/ make sure outgoing branches are corrected\n-                for (Block.Reference successor : originalBlock.successors()) {\n-                    Block successorBlock = successor.targetBlock();\n-                    List<Phi> successorParams = this.additionalParameters.getOrDefault(successorBlock, List.of());\n-                    List<Value> additionalParams = successorParams.stream()\n-                            .map(phi -> readVariable(phi.variable, originalBlock))\n-                            .map(val -> resolveValue(context, val))\n-                            .toList();\n-                    List<Value> values = context.getValues(successor.arguments());\n-                    values.addAll(additionalParams);\n-                    Block.Builder successorBlockBuilder = context.getBlock(successorBlock);\n-                    context.mapSuccessor(successor, successorBlockBuilder.successor(values));\n-                }\n-                block.op(op);\n-            }\n-            default -> block.op(op);\n-        }\n-        return block;\n-    }\n-\n-    @Override\n-    public void apply(Block.Builder block, Block b) {\n-        \/\/ add the required additional parameters to this block\n-        boolean isEntry = b.isEntryBlock();\n-        for (Phi phi : this.additionalParameters.getOrDefault(b, List.of())) {\n-            if (isEntry) {\n-                \/\/ Phis in entry blocks denote captured values. Do not add as param but make sure\n-                \/\/ the original value is used\n-                assert phi.operands().size() == 1 : \"entry block phi with multiple operands\";\n-                CopyContext context = block.context();\n-                context.mapValue(resolveValue(context, phi), resolveValue(context, phi.operands().getFirst()));\n-            } else {\n-                block.parameter(phi.variable.varValueType());\n-            }\n-        }\n-\n-        \/\/ actually visit ops in this block\n-        OpTransformer.super.apply(block, b);\n-    }\n-\n-    sealed interface Val {\n-    }\n-\n-    record Holder(Value value) implements Val {\n-    }\n-\n-    enum Uninitialized implements Val {\n-        VALUE;\n-    }\n-\n-    record Phi(CoreOp.VarOp variable, Block block, List<Val> operands, Set<Object> users) implements Val {\n-        Phi(CoreOp.VarOp variable, Block block) {\n-            this(variable, block, new ArrayList<>(), new HashSet<>());\n-        }\n-\n-        void appendOperand(Val val) {\n-            this.operands.add(val);\n-            if (val instanceof Phi phi) { \/\/ load op uses are added separately\n-                phi.users.add(this);\n-            }\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            return this == obj;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(this.variable, this.block);\n-        }\n-\n-        public List<Phi> replaceBy(Val same, SSAConstruction construction) {\n-            List<Phi> usingPhis = new ArrayList<>();\n-            for (Object user : this.users) {\n-                if (user == this) {\n-                    continue;\n-                }\n-                if (same instanceof Phi samePhi) {\n-                    samePhi.users.add(user);\n-                }\n-                switch (user) {\n-                    case Phi phi -> {\n-                        int i = phi.operands.indexOf(this);\n-                        assert i >= 0 : \"use does not have this as operand\";\n-                        phi.operands.set(i, same);\n-                        usingPhis.add(phi);\n-                    }\n-                    case CoreOp.VarAccessOp.VarLoadOp load -> construction.loads.put(load, same);\n-                    default -> throw new UnsupportedOperationException(user + \":\" + user.getClass());\n-                }\n-            }\n-            if (same instanceof Phi samePhi) {\n-                samePhi.users.remove(this);\n-            }\n-            construction.currentDef.get(this.variable).put(this.block, same);\n-            construction.deletedPhis.add(this); \/\/ we might not replace all current defs, so mark this phi as deleted\n-            this.users.clear();\n-            return usingPhis;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"Phi[\" + variable.varName() + \"(\" + block.index() + \"),\" + \"operands: \" + operands.size() + \"}\";\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSAConstruction.java","additions":0,"deletions":321,"binary":false,"changes":321,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,10 +30,2 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+\n+import java.util.*;\n@@ -43,2 +35,8 @@\n- * Functionality to transform a code model into pure SSA form, replacing operations that declare variables and\n- * access them with the use of values they depend on or additional block parameters.\n+ * An implementation of SSA construction based on\n+ * \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+ * <p>\n+ * This implementation contains some adaptions, notably:\n+ * <ul>\n+ *     <li>Adapt to block parameters rather than phi functions.<\/li>\n+ *     <li>Adapt to work with multiple bodies.<\/li>\n+ * <\/ul>\n@@ -46,2 +44,2 @@\n-public final class SSA {\n-    private SSA() {\n+final class SSACytron {\n+    private SSACytron() {\n@@ -64,5 +62,1 @@\n-    public static <T extends Op & Op.Nested> T transform(T nestedOp) {\n-        \/\/ @@@ property is used to test both impls\n-        if (!\"cytron\".equalsIgnoreCase(System.getProperty(\"babylon.ssa\"))) {\n-            return SSAConstruction.transform(nestedOp);\n-        }\n+    static <T extends Op & Op.Nested> T transform(T nestedOp) {\n@@ -294,1 +288,1 @@\n-    public static void findJoinPoints(Body body, Map<Block, Set<CoreOp.VarOp>> joinPoints) {\n+    static void findJoinPoints(Body body, Map<Block, Set<CoreOp.VarOp>> joinPoints) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSACytron.java","additions":15,"deletions":21,"binary":false,"changes":36,"previous_filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSA.java","status":"copied"}]}