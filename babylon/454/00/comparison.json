{"files":[{"patch":"@@ -12,0 +12,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -67,1 +68,1 @@\n-        FunctionType ft = FunctionType.functionType(lambda.invokableType().returnType(), normalizedCaptureTypes);\n+        FunctionType ft = CoreType.functionType(lambda.invokableType().returnType(), normalizedCaptureTypes);\n@@ -163,1 +164,1 @@\n-            return CoreOp.func(f.funcName(), FunctionType.functionType(ft.returnType(), Stream.concat(ft.parameterTypes().stream(), initTypes.stream()).toList()))\n+            return CoreOp.func(f.funcName(), CoreType.functionType(ft.returnType(), Stream.concat(ft.parameterTypes().stream(), initTypes.stream()).toList()))\n@@ -173,1 +174,1 @@\n-                                FunctionType newType = FunctionType.functionType(fco.opType().returnType(),\n+                                FunctionType newType = CoreType.functionType(fco.opType().returnType(),\n@@ -273,1 +274,1 @@\n-                                                            FunctionType.functionType(fco.opType().returnType(),\n+                                                            CoreType.functionType(fco.opType().returnType(),\n@@ -298,1 +299,1 @@\n-        var funcType = FunctionType.functionType(func.invokableType().returnType(), usedParameters.stream().map(Value::type).toList());\n+        var funcType = CoreType.functionType(func.invokableType().returnType(), usedParameters.stream().map(Value::type).toList());\n@@ -453,1 +454,1 @@\n-        FunctionType outputType = FunctionType.functionType(\n+        FunctionType outputType = CoreType.functionType(\n@@ -538,1 +539,1 @@\n-        return TupleType.tupleType(tupleComponentTypes);\n+        return CoreType.tupleType(tupleComponentTypes);\n@@ -574,1 +575,1 @@\n-        return FunctionType.functionType(convertType(l, t.returnType()), t.parameterTypes().stream().map(pt -> convertType(l, pt)).toList());\n+        return CoreType.functionType(convertType(l, t.returnType()), t.parameterTypes().stream().map(pt -> convertType(l, pt)).toList());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -35,1 +35,1 @@\n-public abstract sealed class OnnxType implements TypeElement {\n+public abstract sealed class OnnxType implements ExternalizableTypeElement {\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/ir\/OnnxType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -156,1 +157,1 @@\n-        FunctionType functionType = FunctionType.functionType(\n+        FunctionType functionType = CoreType.functionType(\n@@ -218,1 +219,1 @@\n-            var pool1Result = b.op(OnnxOps.MaxPool(TupleType.tupleType(relu1.type(), OnnxType.TENSOR_INT64),\n+            var pool1Result = b.op(OnnxOps.MaxPool(CoreType.tupleType(relu1.type(), OnnxType.TENSOR_INT64),\n@@ -246,1 +247,1 @@\n-            var pool2Result = b.op(OnnxOps.MaxPool(TupleType.tupleType(relu2.type(), OnnxType.TENSOR_INT64),\n+            var pool2Result = b.op(OnnxOps.MaxPool(CoreType.tupleType(relu2.type(), OnnxType.TENSOR_INT64),\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -89,2 +90,2 @@\n-                : TupleType.tupleType(g.output().stream().map(OnnxModel.ValueInfoProto::type).map(OnnxModelTest::toOnnxType).toList());\n-        return FunctionType.functionType(returnType, paramTypes);\n+                : CoreType.tupleType(g.output().stream().map(OnnxModel.ValueInfoProto::type).map(OnnxModelTest::toOnnxType).toList());\n+        return CoreType.functionType(returnType, paramTypes);\n@@ -284,1 +285,1 @@\n-                        : TupleType.tupleType(rawOp.onnxOutputs().stream().map(o -> inferTypeVariableType(o.type(), rawOp, n)).toList());\n+                        : CoreType.tupleType(rawOp.onnxOutputs().stream().map(o -> inferTypeVariableType(o.type(), rawOp, n)).toList());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/proto\/OnnxModelTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -30,1 +30,1 @@\n-public abstract sealed class SpirvType implements TypeElement permits PointerType, StorageType {\n+public abstract sealed class SpirvType implements ExternalizableTypeElement permits PointerType, StorageType {\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        return new ExternalizedTypeElement(NAME,\n+        return ExternalizedTypeElement.of(NAME,\n@@ -68,1 +68,1 @@\n-                        new ExternalizedTypeElement(\"c\" + value, List.of())));\n+                        ExternalizedTypeElement.of(\"c\" + value)));\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+        return ExternalizedTypeElement.of(NAME, List.of(rType.externalize()));\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -32,1 +33,0 @@\n-import jdk.incubator.code.dialect.core.TupleType;\n@@ -141,1 +141,1 @@\n-                return TupleType.tupleTypeFromValues(values);\n+                return CoreType.tupleTypeFromValues(values);\n@@ -151,1 +151,1 @@\n-                : TupleType.tupleTypeFromValues(iterValues);\n+                : CoreType.tupleTypeFromValues(iterValues);\n@@ -156,1 +156,1 @@\n-        FunctionType bodyType = FunctionType.functionType(yieldType, bodyParameterTypes);\n+        FunctionType bodyType = CoreType.functionType(yieldType, bodyParameterTypes);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        return new ExternalizedTypeElement(NAME, args);\n+        return ExternalizedTypeElement.of(NAME, args);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-import jdk.incubator.code.dialect.DialectFactory;\n-import jdk.incubator.code.dialect.ExternalizableOp;\n-import jdk.incubator.code.dialect.OpFactory;\n-import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.*;\n@@ -34,0 +31,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -118,1 +116,1 @@\n-            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n+            Body.Builder bodyC = Body.Builder.of(null, CoreType.FUNCTION_TYPE_VOID);\n@@ -838,1 +836,1 @@\n-        public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n+        public TypeElement constructType(ExternalizableTypeElement.ExternalizedTypeElement tree) {\n@@ -862,1 +860,1 @@\n-                        TypeElement.ExternalizedTypeElement a = tree.arguments().get(i);\n+                        ExternalizableTypeElement.ExternalizedTypeElement a = tree.arguments().get(i);\n@@ -896,1 +894,1 @@\n-            CoreOp.coreTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n+            CoreType.coreTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -30,1 +30,1 @@\n-public abstract sealed class TritonType implements TypeElement\n+public abstract sealed class TritonType implements ExternalizableTypeElement\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -43,0 +44,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -126,1 +128,1 @@\n-        return FunctionType.functionType(\n+        return CoreType.functionType(\n@@ -208,1 +210,1 @@\n-    public static final class PtrType implements TypeElement {\n+    public static final class PtrType implements ExternalizableTypeElement {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -42,0 +43,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -153,1 +155,1 @@\n-        FunctionType functionType = FunctionType.functionType(\n+        FunctionType functionType = CoreType.functionType(\n@@ -239,1 +241,1 @@\n-    public static final class PtrType implements TypeElement {\n+    public static final class PtrType implements ExternalizableTypeElement {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.VOID;\n+import static jdk.incubator.code.dialect.core.CoreType.FUNCTION_TYPE_VOID;\n@@ -72,1 +72,1 @@\n-                this.type = VOID;\n+                this.type = FUNCTION_TYPE_VOID;\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        <module>experiments<\/module>\n","filename":"hat\/examples\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,6 +42,2 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n+\n+import jdk.incubator.code.*;\n@@ -49,0 +45,1 @@\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -51,0 +48,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -114,1 +112,1 @@\n-        return FunctionType.functionType(returnTypeElement, transformedTypeElements);\n+        return CoreType.functionType(returnTypeElement, transformedTypeElements);\n@@ -237,1 +235,1 @@\n-    public abstract sealed static class HatType implements TypeElement permits HatPtrType {\n+    public abstract sealed static class HatType implements ExternalizableTypeElement permits HatPtrType {\n","filename":"hat\/hat-core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -128,1 +129,1 @@\n-        return FunctionType.functionType(yieldType, entryBlock.parameterTypes());\n+        return CoreType.functionType(yieldType, entryBlock.parameterTypes());\n@@ -645,1 +646,1 @@\n-            return FunctionType.functionType(returnType, eb.parameterTypes());\n+            return CoreType.functionType(returnType, eb.parameterTypes());\n@@ -722,1 +723,1 @@\n-                FunctionType.functionType(yieldType),\n+                CoreType.functionType(yieldType),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Body.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -404,1 +405,1 @@\n-        return FunctionType.functionType(resultType(), operandTypes);\n+        return CoreType.functionType(resultType(), operandTypes);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,3 +3,1 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n-import java.util.List;\n-import java.util.stream.Collectors;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -23,91 +21,0 @@\n-    \/**\n-     * A type element's externalized content in structured symbolic form.\n-     * <p>\n-     * A {@link TypeElement type element} can be constructed from an externalized type element\n-     * using a {@link TypeElementFactory}.\n-     *\n-     * @param identifier the externalized type's identifier\n-     * @param arguments  the externalized type's arguments\n-     *\/\n-    record ExternalizedTypeElement(String identifier, List<ExternalizedTypeElement> arguments) {\n-\n-        public ExternalizedTypeElement {\n-            arguments = List.copyOf(arguments);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return toString(this);\n-        }\n-\n-        static String toString(ExternalizedTypeElement t) {\n-            if (t.arguments.isEmpty()) {\n-                return t.identifier;\n-            }\n-\n-            StringBuilder s = new StringBuilder();\n-            s.append(t.identifier);\n-            if (!t.arguments.isEmpty()) {\n-                String args = t.arguments.stream()\n-                        .map(Object::toString)\n-                        .collect(Collectors.joining(\", \", \"<\", \">\"));\n-                s.append(args);\n-            }\n-\n-            return s.toString();\n-        }\n-\n-        \/\/ Factories\n-\n-        public static ExternalizedTypeElement of(String s) {\n-            return new ExternalizedTypeElement(s, List.of());\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a) {\n-            return new ExternalizedTypeElement(s, List.of(a));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2) {\n-            return new ExternalizedTypeElement(s, List.of(a1, a2));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n-                                                 ExternalizedTypeElement a3) {\n-            return new ExternalizedTypeElement(s, List.of(a1, a2, a3));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n-                                                 ExternalizedTypeElement a3, ExternalizedTypeElement a4) {\n-            return new ExternalizedTypeElement(s, List.of(a1, a2, a3, a4));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 ExternalizedTypeElement... arguments) {\n-            return new ExternalizedTypeElement(s, List.of(arguments));\n-        }\n-\n-        public static ExternalizedTypeElement of(String s,\n-                                                 List<ExternalizedTypeElement> arguments) {\n-            return new ExternalizedTypeElement(s, arguments);\n-        }\n-\n-        \/**\n-         * Parses a string as an externalized type element.\n-         * <p>\n-         * For any given externalized type element, {@code te}, the following\n-         * expression returns {@code true}.\n-         * {@snippet lang=java :\n-         * te.equals(ExternalizedTypeElement.ofString(te.toString()));\n-         * }\n-         * @param s the string\n-         * @return the externalized code type.\n-         *\/\n-        public static ExternalizedTypeElement ofString(String s) {\n-            return jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(s);\n-        }\n-    }\n-\n@@ -117,0 +24,5 @@\n+     * @implSpec\n+     * The default implementation returns an externalized type element with\n+     * an identifier that is the result of applying {@code toString} to this object, and\n+     * with no arguments.\n+     *\n@@ -118,1 +30,0 @@\n-     * @throws UnsupportedOperationException if the type element is not externalizable\n@@ -120,1 +31,9 @@\n-    ExternalizedTypeElement externalize();\n+    default ExternalizableTypeElement.ExternalizedTypeElement externalize() {\n+        \/\/ @@@ Certain externalizable type elements are composed of other type elements,\n+        \/\/ which may or may not be externalizable. OpWriter is designed to work with\n+        \/\/ non-externalizable type elements, but in such cases OpParser will fail\n+        \/\/ to parse what OpWriter produces.\n+        \/\/ @@@ Should this throw UnsupportedOperationException\n+        \/\/ @@@ Should this be a static helper method on ExternalizableTypeElement?\n+        return ExternalizableTypeElement.ExternalizedTypeElement.of(toString());\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/TypeElement.java","additions":15,"deletions":96,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -1292,1 +1293,1 @@\n-        FunctionType ft = FunctionType.functionType(QuotedOp.QUOTED_TYPE, params);\n+        FunctionType ft = CoreType.functionType(QuotedOp.QUOTED_TYPE, params);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -471,1 +472,1 @@\n-                        FunctionType lambdaFunc = FunctionType.functionType(JavaType.type(mt.returnType()),\n+                        FunctionType lambdaFunc = CoreType.functionType(JavaType.type(mt.returnType()),\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeLift.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -42,1 +43,1 @@\n-        private static final TypeElement.ExternalizedTypeElement UNRESOLVED_REF = new TypeElement.ExternalizedTypeElement(\"?REF\", List.of());\n+        private static final ExternalizableTypeElement.ExternalizedTypeElement UNRESOLVED_REF = new ExternalizableTypeElement.ExternalizedTypeElement(\"?REF\", List.of());\n@@ -45,1 +46,1 @@\n-        public TypeElement.ExternalizedTypeElement externalize() {\n+        public ExternalizableTypeElement.ExternalizedTypeElement externalize() {\n@@ -51,1 +52,1 @@\n-        private static final TypeElement.ExternalizedTypeElement UNRESOLVED_INT = new TypeElement.ExternalizedTypeElement(\"?INT\", List.of());\n+        private static final ExternalizableTypeElement.ExternalizedTypeElement UNRESOLVED_INT = new ExternalizableTypeElement.ExternalizedTypeElement(\"?INT\", List.of());\n@@ -54,1 +55,1 @@\n-        public TypeElement.ExternalizedTypeElement externalize() {\n+        public ExternalizableTypeElement.ExternalizedTypeElement externalize() {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/UnresolvedType.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+package jdk.incubator.code.dialect;\n+\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A type element that supports externalization of its content and reconstruction\n+ * via an instance of {@link ExternalizedTypeElement}.\n+ *\/\n+public interface ExternalizableTypeElement extends TypeElement {\n+\n+    \/**\n+     * A type element's externalized content in structured symbolic form.\n+     * <p>\n+     * A {@link TypeElement type element} can be constructed from an externalized type element\n+     * using a {@link TypeElementFactory}.\n+     *\n+     * @param identifier the externalized type's identifier\n+     * @param arguments  the externalized type's arguments\n+     *\/\n+    record ExternalizedTypeElement(String identifier, List<ExternalizedTypeElement> arguments) {\n+\n+        public ExternalizedTypeElement {\n+            arguments = List.copyOf(arguments);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return toString(this);\n+        }\n+\n+        static String toString(ExternalizedTypeElement t) {\n+            if (t.arguments.isEmpty()) {\n+                return t.identifier;\n+            }\n+\n+            StringBuilder s = new StringBuilder();\n+            s.append(t.identifier);\n+            if (!t.arguments.isEmpty()) {\n+                String args = t.arguments.stream()\n+                        .map(Object::toString)\n+                        .collect(Collectors.joining(\", \", \"<\", \">\"));\n+                s.append(args);\n+            }\n+\n+            return s.toString();\n+        }\n+\n+        \/\/ Factories\n+\n+        public static ExternalizedTypeElement of(String s) {\n+            return new ExternalizedTypeElement(s, List.of());\n+        }\n+\n+        public static ExternalizedTypeElement of(String s,\n+                                                 ExternalizedTypeElement a) {\n+            return new ExternalizedTypeElement(s, List.of(a));\n+        }\n+\n+        public static ExternalizedTypeElement of(String s,\n+                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2) {\n+            return new ExternalizedTypeElement(s, List.of(a1, a2));\n+        }\n+\n+        public static ExternalizedTypeElement of(String s,\n+                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n+                                                 ExternalizedTypeElement a3) {\n+            return new ExternalizedTypeElement(s, List.of(a1, a2, a3));\n+        }\n+\n+        public static ExternalizedTypeElement of(String s,\n+                                                 ExternalizedTypeElement a1, ExternalizedTypeElement a2,\n+                                                 ExternalizedTypeElement a3, ExternalizedTypeElement a4) {\n+            return new ExternalizedTypeElement(s, List.of(a1, a2, a3, a4));\n+        }\n+\n+        public static ExternalizedTypeElement of(String s,\n+                                                 ExternalizedTypeElement... arguments) {\n+            return new ExternalizedTypeElement(s, List.of(arguments));\n+        }\n+\n+        public static ExternalizedTypeElement of(String s,\n+                                                 List<ExternalizedTypeElement> arguments) {\n+            return new ExternalizedTypeElement(s, arguments);\n+        }\n+\n+        \/**\n+         * Parses a string as an externalized type element.\n+         * <p>\n+         * For any given externalized type element, {@code te}, the following\n+         * expression returns {@code true}.\n+         * {@snippet lang = java:\n+         * te.equals(ExternalizableTypeElement.ExternalizedTypeElement.ofString(te.toString()));\n+         *}\n+         * @param s the string\n+         * @return the externalized code type.\n+         *\/\n+        public static ExternalizedTypeElement ofString(String s) {\n+            return jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(s);\n+        }\n+    }\n+\n+    \/**\n+     * Externalizes this type element's content.\n+     *\n+     * @return the type element's content.\n+     *\/\n+    ExternalizedTypeElement externalize();\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/ExternalizableTypeElement.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -7,1 +7,1 @@\n- * {@link TypeElement.ExternalizedTypeElement external content}.\n+ * {@link ExternalizableTypeElement.ExternalizedTypeElement external content}.\n@@ -14,1 +14,1 @@\n-     * {@link TypeElement.ExternalizedTypeElement external content}.\n+     * {@link ExternalizableTypeElement.ExternalizedTypeElement external content}.\n@@ -22,1 +22,1 @@\n-    TypeElement constructType(TypeElement.ExternalizedTypeElement tree);\n+    TypeElement constructType(ExternalizableTypeElement.ExternalizedTypeElement tree);\n@@ -39,1 +39,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/TypeElementFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -310,1 +309,1 @@\n-            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n+            Body.Builder bodyC = Body.Builder.of(null, CoreType.FUNCTION_TYPE_VOID);\n@@ -968,1 +967,1 @@\n-                    ? VarType.varType(initOperand().type()) : that.resultType;\n+                    ? CoreType.varType(initOperand().type()) : that.resultType;\n@@ -988,1 +987,1 @@\n-            this.resultType = VarType.varType(type);\n+            this.resultType = CoreType.varType(type);\n@@ -997,1 +996,1 @@\n-            this.resultType = VarType.varType(type);\n+            this.resultType = CoreType.varType(type);\n@@ -1200,1 +1199,1 @@\n-            return TupleType.tupleTypeFromValues(operands());\n+            return CoreType.tupleTypeFromValues(operands());\n@@ -1345,1 +1344,1 @@\n-            return TupleType.tupleType(tupleComponentTypes);\n+            return CoreType.tupleType(tupleComponentTypes);\n@@ -1349,3 +1348,0 @@\n-    \/\/\n-    \/\/ Arithmetic ops\n-\n@@ -1358,71 +1354,0 @@\n-    \/**\n-     * Creates a composed type element factory for core type elements and type elements from the given\n-     * type element factory, where the core type elements can refer to type elements from the\n-     * given type element factory.\n-     *\n-     * @param f the type element factory.\n-     * @return the composed type element factory.\n-     *\/\n-    public static TypeElementFactory coreTypeFactory(TypeElementFactory f) {\n-        class CodeModelFactory implements TypeElementFactory {\n-            final TypeElementFactory thisThenF = this.andThen(f);\n-\n-            @Override\n-            public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n-                return switch (tree.identifier()) {\n-                    case VarType.NAME -> {\n-                        if (tree.arguments().size() != 1) {\n-                            throw new IllegalArgumentException();\n-                        }\n-\n-                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n-                        if (v == null) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-                        yield VarType.varType(v);\n-                    }\n-                    case TupleType.NAME -> {\n-                        if (tree.arguments().isEmpty()) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-\n-                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n-                        for (TypeElement.ExternalizedTypeElement child : tree.arguments()) {\n-                            TypeElement c = thisThenF.constructType(child);\n-                            if (c == null) {\n-                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                            }\n-                            cs.add(c);\n-                        }\n-                        yield TupleType.tupleType(cs);\n-                    }\n-                    case FunctionType.NAME -> {\n-                        if (tree.arguments().isEmpty()) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-\n-                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n-                        if (rt == null) {\n-                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                        }\n-                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n-                        for (TypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n-                            TypeElement c = thisThenF.constructType(child);\n-                            if (c == null) {\n-                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n-                            }\n-                            pts.add(c);\n-                        }\n-                        yield FunctionType.functionType(rt, pts);\n-                    }\n-                    default -> null;\n-                };\n-            }\n-        }\n-        if (f instanceof CodeModelFactory) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        return new CodeModelFactory().thisThenF;\n-    }\n-\n@@ -1526,1 +1451,1 @@\n-        Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        Body.Builder body = Body.Builder.of(ancestorBody, CoreType.FUNCTION_TYPE_VOID);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreOp.java","additions":7,"deletions":82,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+package jdk.incubator.code.dialect.core;\n+\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.TypeElementFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+\/**\n+ *  The symbolic description of a core type.\n+ *\/\n+public sealed interface CoreType extends ExternalizableTypeElement\n+        permits FunctionType, TupleType, VarType {\n+\n+    \/**\n+     * Creates a composed type element factory for core type elements and type elements from the given\n+     * type element factory, where the core type elements can refer to type elements from the\n+     * given type element factory.\n+     *\n+     * @param f the type element factory.\n+     * @return the composed type element factory.\n+     *\/\n+    static TypeElementFactory coreTypeFactory(TypeElementFactory f) {\n+        class CodeModelFactory implements TypeElementFactory {\n+            final TypeElementFactory thisThenF = this.andThen(f);\n+\n+            @Override\n+            public TypeElement constructType(ExternalizableTypeElement.ExternalizedTypeElement tree) {\n+                return switch (tree.identifier()) {\n+                    case VarType.NAME -> {\n+                        if (tree.arguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        yield varType(v);\n+                    }\n+                    case TupleType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n+                        for (ExternalizableTypeElement.ExternalizedTypeElement child : tree.arguments()) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            cs.add(c);\n+                        }\n+                        yield tupleType(cs);\n+                    }\n+                    case FunctionType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (rt == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n+                        for (ExternalizableTypeElement.ExternalizedTypeElement child : tree.arguments().subList(1, tree.arguments().size())) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            pts.add(c);\n+                        }\n+                        yield functionType(rt, pts);\n+                    }\n+                    default -> null;\n+                };\n+            }\n+        }\n+        if (f instanceof CodeModelFactory) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new CodeModelFactory().thisThenF;\n+    }\n+\n+\n+    \/**\n+     * The function type with no parameters, returning void.\n+     *\/\n+    \/\/ @@@ Uses JavaType\n+    FunctionType FUNCTION_TYPE_VOID = functionType(JavaType.VOID);\n+\n+    \/**\n+     * Constructs a function type.\n+     *\n+     * @param returnType the function type's return type.\n+     * @param parameterTypes the function type's parameter types.\n+     * @return a function type.\n+     *\/\n+    static FunctionType functionType(TypeElement returnType, List<? extends TypeElement> parameterTypes) {\n+        Objects.requireNonNull(returnType);\n+        Objects.requireNonNull(parameterTypes);\n+        return new FunctionType(returnType, parameterTypes);\n+    }\n+\n+    \/**\n+     * Constructs a function type.\n+     *\n+     * @param returnType the function type's return type.\n+     * @param parameterTypes the function type's parameter types.\n+     * @return a function type.\n+     *\/\n+    static FunctionType functionType(TypeElement returnType, TypeElement... parameterTypes) {\n+        return functionType(returnType, List.of(parameterTypes));\n+    }\n+\n+    \/**\n+     * Constructs a tuple type.\n+     *\n+     * @param componentTypes the tuple type's component types.\n+     * @return a tuple type.\n+     *\/\n+    static TupleType tupleType(TypeElement... componentTypes) {\n+        return tupleType(List.of(componentTypes));\n+    }\n+\n+    \/**\n+     * Constructs a tuple type.\n+     *\n+     * @param componentTypes the tuple type's component types.\n+     * @return a tuple type.\n+     *\/\n+    static TupleType tupleType(List<? extends TypeElement> componentTypes) {\n+        Objects.requireNonNull(componentTypes);\n+        return new TupleType(componentTypes);\n+    }\n+\n+    \/**\n+     * Constructs a tuple type whose components are the types of\n+     * the given values.\n+     *\n+     * @param values the values.\n+     * @return a tuple type.\n+     *\/\n+    static TupleType tupleTypeFromValues(Value... values) {\n+        return tupleType(Stream.of(values).map(Value::type).toList());\n+    }\n+\n+    \/**\n+     * Constructs a tuple type whose components are the types of\n+     * the given values.\n+     *\n+     * @param values the values.\n+     * @return a tuple type.\n+     *\/\n+    static TupleType tupleTypeFromValues(List<? extends Value> values) {\n+        return tupleType(values.stream().map(Value::type).toList());\n+    }\n+\n+    \/**\n+     * Constructs a variable type.\n+     *\n+     * @param valueType the variable's value type.\n+     * @return a variable type.\n+     *\/\n+    static VarType varType(TypeElement valueType) {\n+        Objects.requireNonNull(valueType);\n+        return new VarType(valueType);\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/CoreType.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -4,1 +4,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -7,1 +6,0 @@\n-import java.util.Objects;\n@@ -13,1 +11,1 @@\n-public final class FunctionType implements TypeElement {\n+public final class FunctionType implements CoreType {\n@@ -17,6 +15,0 @@\n-    \/**\n-     * The function type with no parameters, returning void.\n-     *\/\n-    \/\/ @@@ Uses JavaType\n-    public static final FunctionType VOID = functionType(JavaType.VOID);\n-\n@@ -47,1 +39,1 @@\n-        return new ExternalizedTypeElement(NAME,\n+        return ExternalizedTypeElement.of(NAME,\n@@ -71,24 +63,0 @@\n-\n-    \/**\n-     * Constructs a function type.\n-     *\n-     * @param returnType the function type's return type.\n-     * @param parameterTypes the function type's parameter types.\n-     * @return a function type.\n-     *\/\n-    public static FunctionType functionType(TypeElement returnType, List<? extends TypeElement> parameterTypes) {\n-        Objects.requireNonNull(returnType);\n-        Objects.requireNonNull(parameterTypes);\n-        return new FunctionType(returnType, parameterTypes);\n-    }\n-    \/**\n-     * Constructs a function type.\n-     *\n-     * @param returnType the function type's return type.\n-     * @param parameterTypes the function type's parameter types.\n-     * @return a function type.\n-     *\/\n-    public static FunctionType functionType(TypeElement returnType, TypeElement... parameterTypes) {\n-        return functionType(returnType, List.of(parameterTypes));\n-    }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/FunctionType.java","additions":2,"deletions":34,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import jdk.incubator.code.Value;\n+\n@@ -6,2 +6,0 @@\n-import java.util.Objects;\n-import java.util.stream.Stream;\n@@ -12,1 +10,1 @@\n-public final class TupleType implements TypeElement {\n+public final class TupleType implements CoreType {\n@@ -30,1 +28,2 @@\n-        return new ExternalizedTypeElement(NAME, componentTypes.stream().map(TypeElement::externalize).toList());\n+        return ExternalizedTypeElement.of(NAME,\n+                componentTypes.stream().map(TypeElement::externalize).toList());\n@@ -48,43 +47,0 @@\n-\n-    \/**\n-     * Constructs a tuple type.\n-     *\n-     * @param componentTypes the tuple type's component types.\n-     * @return a tuple type.\n-     *\/\n-    public static TupleType tupleType(List<? extends TypeElement> componentTypes) {\n-        Objects.requireNonNull(componentTypes);\n-        return new TupleType(componentTypes);\n-    }\n-\n-    \/**\n-     * Constructs a tuple type.\n-     *\n-     * @param componentTypes the tuple type's component types.\n-     * @return a tuple type.\n-     *\/\n-    public static TupleType tupleType(TypeElement... componentTypes) {\n-        return tupleType(List.of(componentTypes));\n-    }\n-\n-    \/**\n-     * Constructs a tuple type whose components are the types of\n-     * the given values.\n-     *\n-     * @param values the values.\n-     * @return a tuple type.\n-     *\/\n-    public static TupleType tupleTypeFromValues(List<? extends Value> values) {\n-        return tupleType(values.stream().map(Value::type).toList());\n-    }\n-\n-    \/**\n-     * Constructs a tuple type whose components are the types of\n-     * the given values.\n-     *\n-     * @param values the values.\n-     * @return a tuple type.\n-     *\/\n-    public static TupleType tupleTypeFromValues(Value... values) {\n-        return tupleType(Stream.of(values).map(Value::type).toList());\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/TupleType.java","additions":4,"deletions":48,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-import java.util.List;\n-import java.util.Objects;\n@@ -10,1 +8,1 @@\n-public final class VarType implements TypeElement {\n+public final class VarType implements CoreType {\n@@ -28,1 +26,2 @@\n-        return new ExternalizedTypeElement(NAME, List.of(valueType.externalize()));\n+        return ExternalizedTypeElement.of(NAME,\n+                valueType.externalize());\n@@ -47,11 +46,0 @@\n-\n-    \/**\n-     * Constructs a variable type.\n-     *\n-     * @param valueType the variable's value type.\n-     * @return a variable type.\n-     *\/\n-    public static VarType varType(TypeElement valueType) {\n-        Objects.requireNonNull(valueType);\n-        return new VarType(valueType);\n-    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/core\/VarType.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ConstructorRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2698,1 +2698,1 @@\n-        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n+        static final FunctionType PREDICATE_TYPE = CoreType.functionType(BOOLEAN);\n@@ -2700,1 +2700,1 @@\n-        static final FunctionType ACTION_TYPE = FunctionType.VOID;\n+        static final FunctionType ACTION_TYPE = CoreType.FUNCTION_TYPE_VOID;\n@@ -2817,1 +2817,1 @@\n-                        FunctionType.VOID);\n+                        CoreType.FUNCTION_TYPE_VOID);\n@@ -2834,1 +2834,1 @@\n-                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                    if (!fromPred.bodyType().equals(CoreType.functionType(BOOLEAN))) {\n@@ -2838,1 +2838,1 @@\n-                if (!action.bodyType().equals(FunctionType.VOID)) {\n+                if (!action.bodyType().equals(CoreType.FUNCTION_TYPE_VOID)) {\n@@ -3201,1 +3201,1 @@\n-                this.initTypes = initTypes.stream().map(VarType::varType).toList();\n+                this.initTypes = initTypes.stream().map(CoreType::varType).toList();\n@@ -3206,1 +3206,1 @@\n-                        FunctionType.functionType(TupleType.tupleType(initTypes)));\n+                        CoreType.functionType(CoreType.tupleType(initTypes)));\n@@ -3228,1 +3228,1 @@\n-                        FunctionType.functionType(BOOLEAN, initTypes));\n+                        CoreType.functionType(BOOLEAN, initTypes));\n@@ -3252,1 +3252,1 @@\n-                        FunctionType.functionType(VOID, initTypes));\n+                        CoreType.functionType(VOID, initTypes));\n@@ -3279,1 +3279,1 @@\n-                        FunctionType.functionType(VOID, initTypes));\n+                        CoreType.functionType(VOID, initTypes));\n@@ -3468,1 +3468,1 @@\n-                        FunctionType.functionType(iterableType));\n+                        CoreType.functionType(iterableType));\n@@ -3493,1 +3493,1 @@\n-                        FunctionType.functionType(bodyElementType, elementType));\n+                        CoreType.functionType(bodyElementType, elementType));\n@@ -3516,1 +3516,1 @@\n-                        FunctionType.functionType(VOID, elementType));\n+                        CoreType.functionType(VOID, elementType));\n@@ -3723,1 +3723,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.functionType(BOOLEAN));\n@@ -3740,1 +3740,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.FUNCTION_TYPE_VOID);\n@@ -3773,1 +3773,1 @@\n-            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+            if (!bodies.get(0).bodyType().equals(CoreType.functionType(BOOLEAN))) {\n@@ -3775,1 +3775,1 @@\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + CoreType.functionType(BOOLEAN) +\n@@ -3778,1 +3778,1 @@\n-            if (!bodies.get(1).bodyType().equals(FunctionType.VOID)) {\n+            if (!bodies.get(1).bodyType().equals(CoreType.FUNCTION_TYPE_VOID)) {\n@@ -3780,1 +3780,1 @@\n-                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                        \"Body descriptor should be \" + CoreType.functionType(VOID) +\n@@ -3871,1 +3871,1 @@\n-                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, CoreType.functionType(BOOLEAN));\n@@ -3886,1 +3886,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.FUNCTION_TYPE_VOID);\n@@ -3918,1 +3918,1 @@\n-            if (!bodies.get(0).bodyType().equals(FunctionType.VOID)) {\n+            if (!bodies.get(0).bodyType().equals(CoreType.FUNCTION_TYPE_VOID)) {\n@@ -3920,1 +3920,1 @@\n-                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                        \"Body descriptor should be \" + CoreType.functionType(VOID) +\n@@ -3923,1 +3923,1 @@\n-            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+            if (!bodies.get(1).bodyType().equals(CoreType.functionType(BOOLEAN))) {\n@@ -3925,1 +3925,1 @@\n-                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                        \"Predicate body descriptor should be \" + CoreType.functionType(BOOLEAN) +\n@@ -4033,1 +4033,1 @@\n-                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                if (!b.bodyType().equals(CoreType.functionType(BOOLEAN))) {\n@@ -4129,1 +4129,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.functionType(BOOLEAN));\n@@ -4184,1 +4184,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.functionType(BOOLEAN));\n@@ -4273,1 +4273,1 @@\n-            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+            if (!cond.bodyType().equals(CoreType.functionType(BOOLEAN))) {\n@@ -4347,1 +4347,1 @@\n-                        FunctionType.functionType(VOID, resourceTypes));\n+                        CoreType.functionType(VOID, resourceTypes));\n@@ -4370,1 +4370,1 @@\n-                        FunctionType.functionType(VOID, exceptionType));\n+                        CoreType.functionType(VOID, exceptionType));\n@@ -4378,1 +4378,1 @@\n-                Body.Builder _finally = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                Body.Builder _finally = Body.Builder.of(ancestorBody, CoreType.FUNCTION_TYPE_VOID);\n@@ -5316,1 +5316,1 @@\n-    public static final TypeElementFactory TYPE_FACTORY = CoreOp.coreTypeFactory(JAVA_TYPE_FACTORY);\n+    public static final TypeElementFactory TYPE_FACTORY = CoreType.coreTypeFactory(JAVA_TYPE_FACTORY);\n@@ -6357,1 +6357,1 @@\n-        Body.Builder _try = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        Body.Builder _try = Body.Builder.of(ancestorBody, CoreType.FUNCTION_TYPE_VOID);\n@@ -6373,1 +6373,1 @@\n-        resourceTypes = resourceTypes.stream().map(VarType::varType).toList();\n+        resourceTypes = resourceTypes.stream().map(CoreType::varType).toList();\n@@ -6375,1 +6375,1 @@\n-                FunctionType.functionType(TupleType.tupleType(resourceTypes)));\n+                CoreType.functionType(CoreType.tupleType(resourceTypes)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -14,2 +14,2 @@\n-public sealed interface JavaRef extends TypeElement\n-    permits MethodRef, ConstructorRef, FieldRef, RecordTypeRef {\n+public sealed interface JavaRef extends ExternalizableTypeElement\n+        permits MethodRef, ConstructorRef, FieldRef, RecordTypeRef {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaRef.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -56,2 +56,2 @@\n-public sealed interface JavaType extends TypeElement permits ClassType, ArrayType,\n-                                                             PrimitiveType, WildcardType, TypeVariableType {\n+public sealed interface JavaType extends ExternalizableTypeElement\n+        permits ClassType, ArrayType, PrimitiveType, WildcardType, TypeVariableType {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -41,1 +42,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n@@ -106,1 +107,1 @@\n-        return FunctionType.functionType(\n+        return CoreType.functionType(\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/MethodRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -139,1 +139,1 @@\n-    public sealed interface Owner extends TypeElement permits ClassType, MethodRef, ConstructorRef { }\n+    public sealed interface Owner extends ExternalizableTypeElement permits ClassType, MethodRef, ConstructorRef { }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/TypeVariableType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-import jdk.incubator.code.TypeElement.ExternalizedTypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement.ExternalizedTypeElement;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/JavaTypeUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,4 +91,1 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.core.TupleType;\n-import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.core.*;\n@@ -559,1 +556,1 @@\n-            FunctionType bodyType = FunctionType.functionType(\n+            FunctionType bodyType = CoreType.functionType(\n@@ -601,1 +598,1 @@\n-            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+            FunctionType mtDesc = CoreType.functionType(typeToTypeElement(mtype.restype),\n@@ -870,1 +867,1 @@\n-                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+                    CoreType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n@@ -884,1 +881,1 @@\n-                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+                    CoreType.functionType(typeToTypeElement(unboxedType)));\n@@ -1362,1 +1359,1 @@\n-            pushBody(pattern, FunctionType.functionType(patternType));\n+            pushBody(pattern, CoreType.functionType(patternType));\n@@ -1438,1 +1435,1 @@\n-            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+            FunctionType matchFuncType = CoreType.functionType(JavaType.VOID, patternDescParams);\n@@ -1495,1 +1492,1 @@\n-            FunctionType constructorType = FunctionType.functionType(\n+            FunctionType constructorType = CoreType.functionType(\n@@ -1548,1 +1545,1 @@\n-                pushBody(tree.body, FunctionType.VOID);\n+                pushBody(tree.body, CoreType.FUNCTION_TYPE_VOID);\n@@ -1626,1 +1623,1 @@\n-                        FunctionType.functionType(JavaType.BOOLEAN));\n+                        CoreType.functionType(JavaType.BOOLEAN));\n@@ -1637,1 +1634,1 @@\n-                pushBody(tree.thenpart, FunctionType.VOID);\n+                pushBody(tree.thenpart, CoreType.FUNCTION_TYPE_VOID);\n@@ -1653,1 +1650,1 @@\n-                    pushBody(elsepart, FunctionType.VOID);\n+                    pushBody(elsepart, CoreType.FUNCTION_TYPE_VOID);\n@@ -1675,1 +1672,1 @@\n-            FunctionType caseBodyType = FunctionType.functionType(typeToTypeElement(switchType));\n+            FunctionType caseBodyType = CoreType.functionType(typeToTypeElement(switchType));\n@@ -1687,1 +1684,1 @@\n-            FunctionType actionType = FunctionType.VOID;\n+            FunctionType actionType = CoreType.FUNCTION_TYPE_VOID;\n@@ -1720,1 +1717,1 @@\n-                pushBody(tree, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1739,1 +1736,1 @@\n-            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            FunctionType caseLabelType = CoreType.functionType(JavaType.BOOLEAN, target.type());\n@@ -1754,1 +1751,1 @@\n-                    pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                    pushBody(pcl.pat, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1760,1 +1757,1 @@\n-                    pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                    pushBody(c.guard, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1796,1 +1793,1 @@\n-                        pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+                        pushBody(ccl, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1826,1 +1823,1 @@\n-                pushBody(headCl, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(headCl, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1904,1 +1901,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1915,1 +1912,1 @@\n-            pushBody(tree.body, FunctionType.VOID);\n+            pushBody(tree.body, CoreType.FUNCTION_TYPE_VOID);\n@@ -1933,1 +1930,1 @@\n-            pushBody(tree.body, FunctionType.VOID);\n+            pushBody(tree.body, CoreType.FUNCTION_TYPE_VOID);\n@@ -1942,1 +1939,1 @@\n-            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            pushBody(cond, CoreType.functionType(JavaType.BOOLEAN));\n@@ -1959,1 +1956,1 @@\n-            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            pushBody(tree.expr, CoreType.functionType(typeToTypeElement(tree.expr.type)));\n@@ -1970,1 +1967,1 @@\n-            VarType varEType = VarType.varType(typeToTypeElement(var.type));\n+            VarType varEType = CoreType.varType(typeToTypeElement(var.type));\n@@ -1975,1 +1972,1 @@\n-            pushBody(var, FunctionType.functionType(varEType, eType));\n+            pushBody(var, CoreType.functionType(varEType, eType));\n@@ -1983,1 +1980,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            pushBody(tree.body, CoreType.functionType(JavaType.VOID, varEType));\n@@ -2019,1 +2016,1 @@\n-                            .map(t -> VarType.varType(typeToTypeElement(t.type)))\n+                            .map(t -> CoreType.varType(typeToTypeElement(t.type)))\n@@ -2037,1 +2034,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                pushBody(null, CoreType.functionType(CoreType.tupleType(varTypes)));\n@@ -2043,1 +2040,1 @@\n-                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                pushBody(null, CoreType.functionType(varTypes.get(0)));\n@@ -2048,1 +2045,1 @@\n-                pushBody(null, FunctionType.VOID);\n+                pushBody(null, CoreType.FUNCTION_TYPE_VOID);\n@@ -2059,1 +2056,1 @@\n-            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            pushBody(tree.cond, CoreType.functionType(JavaType.BOOLEAN, varTypes));\n@@ -2076,1 +2073,1 @@\n-            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(null, CoreType.functionType(JavaType.VOID, varTypes));\n@@ -2089,1 +2086,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            pushBody(tree.body, CoreType.functionType(JavaType.VOID, varTypes));\n@@ -2113,1 +2110,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    CoreType.functionType(JavaType.BOOLEAN));\n@@ -2128,1 +2125,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    CoreType.functionType(typeToTypeElement(condType)));\n@@ -2142,1 +2139,1 @@\n-                    FunctionType.functionType(typeToTypeElement(condType)));\n+                    CoreType.functionType(typeToTypeElement(condType)));\n@@ -2178,1 +2175,1 @@\n-                    FunctionType.functionType(JavaType.BOOLEAN));\n+                    CoreType.functionType(JavaType.BOOLEAN));\n@@ -2192,1 +2189,1 @@\n-                        FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                        CoreType.functionType(typeToTypeElement(tree.detail.type)));\n@@ -2214,1 +2211,1 @@\n-                pushBody(tree, FunctionType.VOID);\n+                pushBody(tree, CoreType.FUNCTION_TYPE_VOID);\n@@ -2230,1 +2227,1 @@\n-            pushBody(tree.lock, FunctionType.functionType(typeToTypeElement(tree.lock.type)));\n+            pushBody(tree.lock, CoreType.functionType(typeToTypeElement(tree.lock.type)));\n@@ -2239,1 +2236,1 @@\n-            pushBody(tree.body, FunctionType.VOID);\n+            pushBody(tree.body, CoreType.FUNCTION_TYPE_VOID);\n@@ -2254,1 +2251,1 @@\n-            pushBody(tree, FunctionType.VOID);\n+            pushBody(tree, CoreType.FUNCTION_TYPE_VOID);\n@@ -2281,1 +2278,1 @@\n-                        rTypes.add(VarType.varType(typeToTypeElement(vdecl.type)));\n+                        rTypes.add(CoreType.varType(typeToTypeElement(vdecl.type)));\n@@ -2288,1 +2285,1 @@\n-                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+                pushBody(null, CoreType.functionType(CoreType.tupleType(rTypes)));\n@@ -2315,1 +2312,1 @@\n-            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            pushBody(tree.body, CoreType.functionType(JavaType.VOID, rVarTypes));\n@@ -2329,1 +2326,1 @@\n-                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                pushBody(catcher.body, CoreType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n@@ -2345,1 +2342,1 @@\n-                pushBody(tree.finalizer, FunctionType.VOID);\n+                pushBody(tree.finalizer, CoreType.FUNCTION_TYPE_VOID);\n@@ -2420,1 +2417,1 @@\n-                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.lhs, CoreType.functionType(JavaType.BOOLEAN));\n@@ -2430,1 +2427,1 @@\n-                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                pushBody(tree.rhs, CoreType.functionType(JavaType.BOOLEAN));\n@@ -2677,1 +2674,1 @@\n-            return FunctionType.functionType(\n+            return CoreType.functionType(\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":52,"deletions":55,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.code.TypeElement.ExternalizedTypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement.*;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -36,0 +37,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -38,1 +40,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -44,1 +45,0 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -141,1 +141,1 @@\n-    static final TypeElement.ExternalizedTypeElement VOID = JavaType.VOID.externalize();\n+    static final ExternalizedTypeElement VOID = JavaType.VOID.externalize();\n@@ -260,1 +260,1 @@\n-    static Op nodeToOp(OpNode opNode, TypeElement.ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n+    static Op nodeToOp(OpNode opNode, ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n@@ -265,1 +265,1 @@\n-    static ExternalizableOp.ExternalizedOp nodeToOpDef(OpNode opNode, TypeElement.ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n+    static ExternalizableOp.ExternalizedOp nodeToOpDef(OpNode opNode, ExternalizedTypeElement rtype, Context c, Body.Builder ancestorBody) {\n@@ -296,1 +296,1 @@\n-                FunctionType.functionType(c.typeFactory.constructType(n.rtype)));\n+                CoreType.functionType(c.typeFactory.constructType(n.rtype)));\n@@ -358,1 +358,1 @@\n-    record BodyNode(TypeElement.ExternalizedTypeElement rtype,\n+    record BodyNode(ExternalizedTypeElement rtype,\n@@ -368,1 +368,1 @@\n-                     TypeElement.ExternalizedTypeElement type) {\n+                     ExternalizedTypeElement type) {\n@@ -586,1 +586,1 @@\n-        TypeElement.ExternalizedTypeElement rtype = parseExTypeElem();\n+        ExternalizedTypeElement rtype = parseExTypeElem();\n@@ -624,1 +624,1 @@\n-        TypeElement.ExternalizedTypeElement type = parseExTypeElem();\n+        ExternalizedTypeElement type = parseExTypeElem();\n@@ -671,1 +671,1 @@\n-    TypeElement.ExternalizedTypeElement parseExTypeElem() {\n+    ExternalizedTypeElement parseExTypeElem() {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/OpParser.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -29,1 +30,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -42,1 +42,1 @@\n-    public static TypeElement.ExternalizedTypeElement parseExTypeElem(String desc) {\n+    public static ExternalizableTypeElement.ExternalizedTypeElement parseExTypeElem(String desc) {\n@@ -63,1 +63,1 @@\n-    public static TypeElement.ExternalizedTypeElement parseExTypeElem(Lexer l) {\n+    public static ExternalizableTypeElement.ExternalizedTypeElement parseExTypeElem(Lexer l) {\n@@ -71,1 +71,1 @@\n-        List<TypeElement.ExternalizedTypeElement> args = new ArrayList<>();\n+        List<ExternalizableTypeElement.ExternalizedTypeElement> args = new ArrayList<>();\n@@ -81,1 +81,1 @@\n-        return new TypeElement.ExternalizedTypeElement(identifier.toString(), args);\n+        return new ExternalizableTypeElement.ExternalizedTypeElement(identifier.toString(), args);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/DescParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -41,1 +42,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n@@ -88,1 +89,1 @@\n-    static final MethodRef FUNCTION_TYPE_FUNCTION_TYPE = MethodRef.method(FunctionType.class, \"functionType\",\n+    static final MethodRef FUNCTION_TYPE_FUNCTION_TYPE = MethodRef.method(CoreType.class, \"functionType\",\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -273,1 +274,1 @@\n-            return CoreOp.func(original.funcName(), FunctionType.functionType(retType, type, type))\n+            return CoreOp.func(original.funcName(), CoreType.functionType(retType, type, type))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockParameters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n-import static jdk.incubator.code.dialect.core.FunctionType.VOID;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.FUNCTION_TYPE_VOID;\n@@ -198,1 +198,1 @@\n-        var abody = Body.Builder.of(null, VOID);\n+        var abody = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -201,1 +201,1 @@\n-        var bbody = Body.Builder.of(null, VOID);\n+        var bbody = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -211,1 +211,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -218,1 +218,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -229,1 +229,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -235,1 +235,1 @@\n-        Assert.assertThrows(IllegalStateException.class, () -> Body.Builder.of(body, VOID));\n+        Assert.assertThrows(IllegalStateException.class, () -> Body.Builder.of(body, FUNCTION_TYPE_VOID));\n@@ -240,1 +240,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -244,1 +244,1 @@\n-        Body.Builder.of(body, VOID);\n+        Body.Builder.of(body, FUNCTION_TYPE_VOID);\n@@ -252,1 +252,1 @@\n-        var body1 = Body.Builder.of(null, VOID);\n+        var body1 = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -255,1 +255,1 @@\n-        var anotherBody = Body.Builder.of(null, VOID);\n+        var anotherBody = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -257,1 +257,1 @@\n-        var body2 = Body.Builder.of(anotherBody, VOID);\n+        var body2 = Body.Builder.of(anotherBody, FUNCTION_TYPE_VOID);\n@@ -268,1 +268,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -278,1 +278,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -288,1 +288,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -303,1 +303,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -311,1 +311,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -321,1 +321,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n@@ -333,1 +333,1 @@\n-        var body = Body.Builder.of(null, VOID);\n+        var body = Body.Builder.of(null, FUNCTION_TYPE_VOID);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -32,1 +33,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -57,1 +57,1 @@\n-        CoreOp.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+        CoreOp.FuncOp f = func(\"f\", CoreType.FUNCTION_TYPE_VOID).body(entry -> {\n@@ -87,1 +87,1 @@\n-        CoreOp.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+        CoreOp.FuncOp f = func(\"f\", CoreType.FUNCTION_TYPE_VOID).body(entry -> {\n@@ -114,1 +114,1 @@\n-        CoreOp.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+        CoreOp.FuncOp f = func(\"f\", CoreType.FUNCTION_TYPE_VOID).body(entry -> {\n@@ -150,1 +150,1 @@\n-        CoreOp.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+        CoreOp.FuncOp f = func(\"f\", CoreType.FUNCTION_TYPE_VOID).body(entry -> {\n@@ -193,1 +193,1 @@\n-        CoreOp.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+        CoreOp.FuncOp f = func(\"f\", CoreType.FUNCTION_TYPE_VOID).body(entry -> {\n@@ -234,1 +234,1 @@\n-        CoreOp.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+        CoreOp.FuncOp f = func(\"f\", CoreType.FUNCTION_TYPE_VOID).body(entry -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -51,1 +52,0 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.*;\n@@ -74,1 +74,1 @@\n-        CoreOp.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, type(IntConsumer.class)))\n@@ -166,1 +166,1 @@\n-        CoreOp.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, type(IntConsumer.class)))\n@@ -262,1 +262,1 @@\n-        CoreOp.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, type(IntConsumer.class)))\n@@ -385,1 +385,1 @@\n-        CoreOp.FuncOp f = func(\"f\", functionType(VOID, JavaType.type(IntConsumer.class)))\n+        CoreOp.FuncOp f = func(\"f\", CoreType.functionType(VOID, JavaType.type(IntConsumer.class)))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -40,1 +41,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -58,1 +58,1 @@\n-        CoreOp.FuncOp ft = CoreOp.func(\"f\", FunctionType.functionType(JavaType.J_L_OBJECT, JavaType.type(CharSequence.class)))\n+        CoreOp.FuncOp ft = CoreOp.func(\"f\", CoreType.functionType(JavaType.J_L_OBJECT, JavaType.type(CharSequence.class)))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestVarOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -125,1 +126,1 @@\n-    static final FunctionType D_D = FunctionType.functionType(DOUBLE, DOUBLE);\n+    static final FunctionType D_D = CoreType.functionType(DOUBLE, DOUBLE);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -52,1 +53,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(yieldType));\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.functionType(yieldType));\n@@ -112,1 +113,1 @@\n-                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(yieldType));\n+                Body.Builder body = Body.Builder.of(ancestorBody, CoreType.functionType(yieldType));\n@@ -184,1 +185,1 @@\n-                        FunctionType.functionType(yieldType));\n+                        CoreType.functionType(yieldType));\n@@ -202,1 +203,1 @@\n-                        FunctionType.functionType(thenBuilder.yieldType));\n+                        CoreType.functionType(thenBuilder.yieldType));\n@@ -490,1 +491,1 @@\n-        return new AnfFuncOp.Builder(ancestorBody, funcName, FunctionType.functionType(funcType.returnType(), params));\n+        return new AnfFuncOp.Builder(ancestorBody, funcName, CoreType.functionType(funcType.returnType(), params));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/AnfDialect.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n+import jdk.incubator.code.dialect.core.CoreType;\n+\n@@ -40,1 +41,1 @@\n-        outerBodyBuilder = Body.Builder.of(null, FunctionType.functionType(funcOp.body().yieldType()));\n+        outerBodyBuilder = Body.Builder.of(null, CoreType.functionType(funcOp.body().yieldType()));\n@@ -62,1 +63,1 @@\n-        var outerLetRecBody = Body.Builder.of(outerBodyBuilder, FunctionType.functionType(b.yieldType(), List.of()), CopyContext.create(builderEntry.context()));\n+        var outerLetRecBody = Body.Builder.of(outerBodyBuilder, CoreType.functionType(b.yieldType(), List.of()), CopyContext.create(builderEntry.context()));\n@@ -82,1 +83,1 @@\n-        var blockFType = FunctionType.functionType(blockReturnType);\n+        var blockFType = CoreType.functionType(blockReturnType);\n@@ -87,1 +88,1 @@\n-        var blockFTypeSynth = FunctionType.functionType(blockReturnType, synthParamTypes);\n+        var blockFTypeSynth = CoreType.functionType(blockReturnType, synthParamTypes);\n@@ -99,1 +100,1 @@\n-        var letBody = Body.Builder.of(newBodyBuilder, FunctionType.functionType(blockReturnType, List.of()), CopyContext.create(newBodyBuilder.entryBlock().context()));\n+        var letBody = Body.Builder.of(newBodyBuilder, CoreType.functionType(blockReturnType, List.of()), CopyContext.create(newBodyBuilder.entryBlock().context()));\n@@ -109,1 +110,1 @@\n-        var blockFType = FunctionType.functionType(blockReturnType);\n+        var blockFType = CoreType.functionType(blockReturnType);\n@@ -114,1 +115,1 @@\n-        var blockFTypeSynth = FunctionType.functionType(blockReturnType, synthParamTypes);\n+        var blockFTypeSynth = CoreType.functionType(blockReturnType, synthParamTypes);\n@@ -129,1 +130,1 @@\n-        Body.Builder letrecBody = Body.Builder.of(funcBodyBuilder, FunctionType.functionType(blockReturnType, List.of()), CopyContext.create(funcBodyBuilder.entryBlock().context()));\n+        Body.Builder letrecBody = Body.Builder.of(funcBodyBuilder, CoreType.functionType(blockReturnType, List.of()), CopyContext.create(funcBodyBuilder.entryBlock().context()));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/AnfTransformer.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -56,1 +56,1 @@\n-        return CoreOp.func(\"f\", FunctionType.functionType(JavaType.J_L_STRING)).body(b -> {\n+        return CoreOp.func(\"f\", CoreType.functionType(JavaType.J_L_STRING)).body(b -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlotOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.functionType;\n+import static jdk.incubator.code.dialect.core.CoreType.functionType;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -28,1 +29,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -187,1 +187,1 @@\n-            return func(\"fused.forEach\", FunctionType.functionType(JavaType.VOID, sourceType))\n+            return func(\"fused.forEach\", CoreType.functionType(JavaType.VOID, sourceType))\n@@ -216,1 +216,1 @@\n-            return func(\"fused.collect\", FunctionType.functionType(collectType, sourceType))\n+            return func(\"fused.collect\", CoreType.functionType(collectType, sourceType))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.code.dialect.core.CoreType;\n@@ -28,1 +29,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -208,1 +208,1 @@\n-            return func(\"fused.forEach\", FunctionType.functionType(JavaType.VOID, sourceType))\n+            return func(\"fused.forEach\", CoreType.functionType(JavaType.VOID, sourceType))\n@@ -242,1 +242,1 @@\n-            return func(\"fused.collect\", FunctionType.functionType(collectType, sourceType))\n+            return func(\"fused.collect\", CoreType.functionType(collectType, sourceType))\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.ExternalizableTypeElement;\n@@ -84,1 +84,1 @@\n-        TypeElement.ExternalizedTypeElement emr = TypeElement.ExternalizedTypeElement.ofString(mds);\n+        ExternalizableTypeElement.ExternalizedTypeElement emr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(mds);\n@@ -117,1 +117,1 @@\n-        TypeElement.ExternalizedTypeElement ecr = TypeElement.ExternalizedTypeElement.ofString(crs);\n+        ExternalizableTypeElement.ExternalizedTypeElement ecr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(crs);\n@@ -156,1 +156,1 @@\n-        TypeElement.ExternalizedTypeElement efr = TypeElement.ExternalizedTypeElement.ofString(frs);\n+        ExternalizableTypeElement.ExternalizedTypeElement efr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(frs);\n@@ -196,1 +196,1 @@\n-        TypeElement.ExternalizedTypeElement ertr = TypeElement.ExternalizedTypeElement.ofString(rtds);\n+        ExternalizableTypeElement.ExternalizedTypeElement ertr = ExternalizableTypeElement.ExternalizedTypeElement.ofString(rtds);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import static jdk.incubator.code.dialect.core.FunctionType.VOID;\n+import static jdk.incubator.code.dialect.core.CoreType.FUNCTION_TYPE_VOID;\n@@ -148,1 +148,1 @@\n-        return func(\"f\", VOID).body(fblock -> {\n+        return func(\"f\", FUNCTION_TYPE_VOID).body(fblock -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}