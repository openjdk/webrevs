{"files":[{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public enum Space {\n-    PRIVATE,\n-    SHARED\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/Space.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Space;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import hat.phases.HatDialectifyTier;\n@@ -46,1 +47,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -53,1 +53,0 @@\n-import java.util.Arrays;\n@@ -488,0 +487,1 @@\n+\n@@ -490,1 +490,3 @@\n-            CoreOp.FuncOp f = dialectifyToHat(entrypoint.funcOp());\n+            HatDialectifyTier tier = new HatDialectifyTier(entrypoint.funcOp(), computeContext.accelerator.lookup);\n+            CoreOp.FuncOp f = tier.run();\n+            \/\/CoreOp.FuncOp f = dialectifyToHat(entrypoint.funcOp());\n@@ -500,1 +502,3 @@\n-                CoreOp.FuncOp f = dialectifyToHat(kernelOp);\n+                \/\/CoreOp.FuncOp f = dialectifyToHat(kernelOp);\n+                HatDialectifyTier tier = new HatDialectifyTier(kernelOp, computeContext.accelerator.lookup);\n+                CoreOp.FuncOp f = tier.run();\n@@ -506,1 +510,3 @@\n-                CoreOp.FuncOp f = dialectifyToHat(kernel.funcOp());\n+                \/\/CoreOp.FuncOp f = dialectifyToHat(kernel.funcOp());\n+                HatDialectifyTier tier = new HatDialectifyTier(kernel.funcOp(), computeContext.accelerator.lookup);\n+                CoreOp.FuncOp f = tier.run();\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HatBarrierOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyBarrierPhase implements HatDialectifyPhase {\n+\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp\n+                .elements()\n+                .mapMulti((element, consumer) -> {\n+                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n+        if (collect.isEmpty()) {\n+            \/\/ Return the function with no modifications\n+            return funcOp;\n+        }\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!collect.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createBarrierNodeOp(context, invokeOp, blockBuilder);\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/ System.out.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyBarrierPhase.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatPrivateVarOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyMemoryPhase implements HatDialectifyPhase {\n+\n+    public enum Space {\n+        PRIVATE,\n+        SHARED,\n+    }\n+\n+    private final Space memorySpace;\n+    private final MethodHandles.Lookup lookup;\n+\n+    public HatDialectifyMemoryPhase(Space space, MethodHandles.Lookup lookup) {\n+        this.memorySpace = space;\n+        this.lookup = lookup;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+            String nameNode = switch (memorySpace) {\n+                case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n+                case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n+            };\n+\n+            \/\/IO.println(\"ORIGINAL: \" + funcOp.toText());\n+            Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                    .mapMulti((codeElement, consumer) -> {\n+                        if (codeElement instanceof CoreOp.VarOp varOp) {\n+                            List<Value> inputOperandsVarOp = varOp.operands();\n+                            for (Value inputOperand : inputOperandsVarOp) {\n+                                if (inputOperand instanceof Op.Result result) {\n+                                    if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                        if (OpTk.isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n+                                            \/\/ It is the node we are looking for\n+                                            consumer.accept(invokeOp);\n+                                            consumer.accept(varOp);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+            Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+            if (nodesInvolved.isEmpty()) {\n+                \/\/ No memory nodes involved\n+                return funcOp;\n+            }\n+\n+            funcOp = funcOp.transform((blockBuilder, op) -> {\n+                CopyContext context = blockBuilder.context();\n+                if (!nodesInvolved.contains(op)) {\n+                    blockBuilder.op(op);\n+                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    \/\/ Don't insert the invoke node\n+                    Op.Result result = invokeOp.result();\n+                    List<Op.Result> collect = result.uses().stream().toList();\n+                    for (Op.Result r : collect) {\n+                        if (r.op() instanceof CoreOp.VarOp varOp) {\n+                            \/\/ That's the node we want\n+                            List<Value> inputOperandsVarOp = invokeOp.operands();\n+                            List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                            HatMemoryOp memoryOp = switch (memorySpace) {\n+                                case SHARED ->\n+                                        new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                                default ->\n+                                        new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                            };\n+                            Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n+                            context.mapValue(invokeOp.result(), hatLocalResult);\n+                        }\n+                    }\n+                } else if (op instanceof CoreOp.VarOp varOp) {\n+                    \/\/ pass value\n+                    context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+                }\n+                return blockBuilder;\n+            });\n+            \/\/ IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+            \/\/entrypoint.funcOp(funcOp);\n+            return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyMemoryPhase.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+public interface HatDialectifyPhase {\n+\n+    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyPhase.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+\n+public class HatDialectifyTier {\n+\n+    private CoreOp.FuncOp funcOp;\n+    List<HatDialectifyPhase> hatPhases = new ArrayList<>();\n+\n+    public HatDialectifyTier(CoreOp.FuncOp funcOp, MethodHandles.Lookup lookup) {\n+        this.funcOp = funcOp;\n+        hatPhases.add(new HatDialectifyBarrierPhase());\n+        for (HatDialectifyMemoryPhase.Space space: HatDialectifyMemoryPhase.Space.values()) {\n+            hatPhases.add(new HatDialectifyMemoryPhase(space, lookup));\n+            hatPhases.add(new HatDialectifyMemoryPhase(space, lookup));\n+        }\n+        for (HatDilectifyThreadsPhase.ThreadAccess threadAccess: HatDilectifyThreadsPhase.ThreadAccess.values()) {\n+            hatPhases.add(new HatDilectifyThreadsPhase(threadAccess));\n+        }\n+    }\n+\n+    public CoreOp.FuncOp run() {\n+        BlockingQueue<HatDialectifyPhase> queue = new ArrayBlockingQueue<>(hatPhases.size());\n+        queue.addAll(hatPhases);\n+        CoreOp.FuncOp f = funcOp;\n+        while (!queue.isEmpty()) {\n+            HatDialectifyPhase phase;\n+            try {\n+                phase = queue.take();\n+                f = phase.run(f);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return f;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyTier.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HatBlockThreadIdOp;\n+import hat.dialect.HatGlobalSizeOp;\n+import hat.dialect.HatGlobalThreadIdOp;\n+import hat.dialect.HatLocalSizeOp;\n+import hat.dialect.HatLocalThreadIdOp;\n+import hat.dialect.HatThreadOP;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDilectifyThreadsPhase implements HatDialectifyPhase {\n+\n+    private final ThreadAccess threadAccess;\n+\n+    public HatDilectifyThreadsPhase(ThreadAccess threadAccess) {\n+        this.threadAccess =  threadAccess;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                        List<Value> operands = fieldLoadOp.operands();\n+                        for (Value inputOperand : operands) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                    boolean isThreadIntrinsic = switch (threadAccess) {\n+                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n+                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n+                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n+                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n+                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n+                                    };\n+                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n+                                        consumer.accept(fieldLoadOp);\n+                                        consumer.accept(varLoadOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            \/\/ No memory nodes involved\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                List<Value> operands = fieldLoadOp.operands();\n+                for (Value operand : operands) {\n+                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> varLoadOperands = varLoadOp.operands();\n+                        List<Value> outputOperands = context.getValues(varLoadOperands);\n+                        int dim = getDimension(threadAccess, fieldLoadOp);\n+                        if (dim < 0) {\n+                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n+                        }\n+                        HatThreadOP threadOP = switch (threadAccess) {\n+                            case GLOBAL_ID -> new HatGlobalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case GLOBAL_SIZE -> new HatGlobalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case LOCAL_ID -> new HatLocalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case LOCAL_SIZE -> new HatLocalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case BLOCK_ID -> new HatBlockThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                        };\n+                        Op.Result threadResult = blockBuilder.op(threadOP);\n+                        context.mapValue(fieldLoadOp.result(), threadResult);\n+                    }\n+                }\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+    public enum ThreadAccess {\n+        GLOBAL_ID,\n+        GLOBAL_SIZE,\n+        LOCAL_ID,\n+        LOCAL_SIZE,\n+        BLOCK_ID,\n+    }\n+\n+\n+    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        String fieldName = fieldLoadOp.fieldDescriptor().name();\n+        switch (threadAccess) {\n+            case GLOBAL_ID -> {\n+                if (fieldName.equals(\"y\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"z\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case GLOBAL_SIZE -> {\n+                if (fieldName.equals(\"gsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"gsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_ID -> {\n+                if (fieldName.equals(\"liy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lyz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_SIZE -> {\n+                if (fieldName.equals(\"lsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case BLOCK_ID ->  {\n+                if (fieldName.equals(\"biy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"biz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+\n+    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n+    }\n+\n+    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n+    }\n+\n+    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n+    }\n+\n+    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n+    }\n+\n+    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n+    }\n+\n+    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDilectifyThreadsPhase.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import hat.Space;\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}