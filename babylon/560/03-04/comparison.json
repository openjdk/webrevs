{"files":[{"patch":"@@ -143,1 +143,1 @@\n-    private void updateListOfSchemas(Op op, MethodHandles.Lookup lookup, List<String> localIfaceList) {\n+    private void updateListOfSchemas(Op op, List<String> localIfaceList) {\n@@ -151,0 +151,1 @@\n+\n@@ -170,3 +171,3 @@\n-                    .forEach((_, funcOp) -> {\n-                        funcOp.transform(CopyContext.create(), (blockBuilder, op) -> {\n-                            updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    .forEach((entryName, f) -> {\n+                        f.transform(CopyContext.create(), (blockBuilder, op) -> {\n+                            updateListOfSchemas(op, localIFaceList);\n@@ -182,1 +183,1 @@\n-                    updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    updateListOfSchemas(op, localIFaceList);\n@@ -192,1 +193,1 @@\n-                    updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    updateListOfSchemas(op, localIFaceList);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.incubator.code.dialect.core.FunctionType;\n@@ -250,2 +251,15 @@\n-    public void dialectifyToHatBarriers() {\n-        CoreOp.FuncOp funcOp = entrypoint.funcOp();\n+    public CoreOp.FuncOp dialectifyToHatBarriers(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp\n+                .elements()\n+                .mapMulti((element, consumer) -> {\n+                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n+        if (collect.isEmpty()) {\n+            \/\/ Return the function with no modifications\n+            return funcOp;\n+        }\n@@ -254,7 +268,1 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n-                    createBarrierNodeOp(context, invokeOp, blockBuilder);\n-                } else {\n-                    blockBuilder.op(op);\n-                }\n-            } else {\n+            if (!collect.contains(op)) {\n@@ -262,0 +270,2 @@\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createBarrierNodeOp(context, invokeOp, blockBuilder);\n@@ -266,1 +276,2 @@\n-        entrypoint.funcOp(funcOp);\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n@@ -269,1 +280,1 @@\n-    public void dialectifyToHatMemorySpace(Space memorySpace) {\n+    public CoreOp.FuncOp dialectifyToHatMemorySpace(CoreOp.FuncOp funcOp, Space memorySpace) {\n@@ -276,1 +287,0 @@\n-        CoreOp.FuncOp funcOp = entrypoint.funcOp();\n@@ -278,1 +288,1 @@\n-        Stream<CodeElement<?, ?>> elements = entrypoint.funcOp().elements()\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n@@ -299,1 +309,1 @@\n-            return;\n+            return funcOp;\n@@ -332,1 +342,2 @@\n-        entrypoint.funcOp(funcOp);\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n@@ -387,3 +398,2 @@\n-    public void dialectifyToHatThreadIds(ThreadAccess threadAccess) {\n-        CoreOp.FuncOp funcOp = entrypoint.funcOp();\n-        Stream<CodeElement<?, ?>> elements = entrypoint.funcOp().elements()\n+    public CoreOp.FuncOp dialectifyToHatThreadIds(CoreOp.FuncOp funcOp, ThreadAccess threadAccess) {\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n@@ -416,1 +426,1 @@\n-            return;\n+            return funcOp;\n@@ -451,1 +461,2 @@\n-        entrypoint.funcOp(funcOp);\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n@@ -462,5 +473,9 @@\n-    public void dialectifyToHat() {\n-        \/\/ Phases\n-        dialectifyToHatBarriers();\n-        Arrays.stream(Space.values()).forEach(this::dialectifyToHatMemorySpace);\n-        Arrays.stream(ThreadAccess.values()).forEach(this::dialectifyToHatThreadIds);\n+    private CoreOp.FuncOp dialectifyToHat(CoreOp.FuncOp funcOp) {\n+        CoreOp.FuncOp f = dialectifyToHatBarriers(funcOp);\n+        for (Space space : Space.values()) {\n+            f = dialectifyToHatMemorySpace(f, space);\n+        }\n+        for (ThreadAccess threadAccess : ThreadAccess.values()) {\n+            f = dialectifyToHatThreadIds(f, threadAccess);\n+        }\n+        return f;\n@@ -469,0 +484,23 @@\n+    public void dialectifyToHat() {\n+        \/\/ Analysis Phases to transform the Java Code Model to a HAT Code Model\n+\n+        \/\/ Main kernel\n+        {\n+            CoreOp.FuncOp f = dialectifyToHat(entrypoint.funcOp());\n+            entrypoint.funcOp(f);\n+        }\n+\n+\/\/        \/\/ Reachable functions\n+\/\/        if (moduleOp != null) {\n+\/\/            moduleOp.functionTable().forEach((entryPoint, kernelOp) -> {\n+\/\/                CoreOp.FuncOp f = dialectifyToHat(kernelOp);\n+\/\/                moduleOp.functionTable().put(entryPoint, f);\n+\/\/            });\n+\/\/        }\n+\/\/        } else {\n+\/\/            kernelReachableResolvedStream().forEach((kernel) -> {\n+\/\/                CoreOp.FuncOp f = dialectifyToHat(kernel.funcOp());\n+\/\/                kernel.funcOp(f);\n+\/\/            });\n+\/\/        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":63,"deletions":25,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,3 +107,0 @@\n-                    if (f != null) {\n-                        System.out.println(\"Analysing function? \" + f.funcName());\n-                    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}