{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import hat.dialect.HatOP;\n@@ -166,1 +167,1 @@\n-    public static class PTXPtrOp extends Op {\n+    public static class PTXPtrOp extends HatOP {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,0 +181,6 @@\n+    \/\/ \/\/ CUDA events for timing\n+    \/\/ cudaEvent_t start, stop;\n+    \/\/ cuEventCreate(&start, cudaEventDefault);\n+    \/\/ cuEventCreate(&stop, cudaEventDefault);\n+    \/\/ cuEventRecord(start, 0);\n+\n@@ -188,0 +194,6 @@\n+    \/\/ cuEventRecord(stop, 0);\n+    \/\/ cuEventSynchronize(stop); \/\/ Wait for completion\n+    \/\/\n+    \/\/ float elapsedTimeMs = 0.0f;\n+    \/\/ cuEventElapsedTime(&elapsedTimeMs, start, stop);\n+    \/\/ std::cout << \"Kernel Elapsed Time: \" << elapsedTimeMs << \" ms\\n\";\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -45,3 +46,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -145,6 +143,4 @@\n-    private void updateListOfSchemas(Op op, MethodHandles.Lookup lookup, List<String> localIfaceList) {\n-        if (Objects.requireNonNull(op) instanceof JavaOp.InvokeOp invokeOp) {\n-            if (OpTk.isIfaceAccessor(lookup, invokeOp)) {\n-                String klassName = invokeOp.resultType().toString();\n-                localIfaceList.add(klassName);\n-            }\n+    private void updateListOfSchemas(Op op, List<String> localIfaceList) {\n+        if (Objects.requireNonNull(op) instanceof HatMemoryOp hatMemoryOp) {\n+            String klassName = hatMemoryOp.invokeType().toString();\n+            localIfaceList.add(klassName);\n@@ -155,0 +151,1 @@\n+\n@@ -174,3 +171,3 @@\n-                    .forEach((_, funcOp) -> {\n-                        funcOp.transform(CopyContext.create(), (blockBuilder, op) -> {\n-                            updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    .forEach((entryName, f) -> {\n+                        f.transform(CopyContext.create(), (blockBuilder, op) -> {\n+                            updateListOfSchemas(op, localIFaceList);\n@@ -186,1 +183,1 @@\n-                    updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    updateListOfSchemas(op, localIFaceList);\n@@ -196,1 +193,1 @@\n-                    updateListOfSchemas(op, kernelCallGraph.computeContext.accelerator.lookup, localIFaceList);\n+                    updateListOfSchemas(op, localIFaceList);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.dialect.HatBarrierOp;\n@@ -35,0 +36,2 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n@@ -38,0 +41,1 @@\n+import jdk.incubator.code.Value;\n@@ -43,0 +47,1 @@\n+import java.util.List;\n@@ -135,0 +140,18 @@\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n@@ -140,1 +163,1 @@\n-        MethodRef methodRef =OpTk.getQuotableTargetInvokeOpWrapper( lambdaOp).invokeDescriptor();\n+        MethodRef methodRef = OpTk.getQuotableTargetInvokeOpWrapper( lambdaOp).invokeDescriptor();\n@@ -142,0 +165,8 @@\n+        \/\/ Analysis : dialect\n+        \/\/ NOTE: Keep the following boolean until we have the config available\/reachable\n+        \/\/ from this class\n+        boolean useDialect = true;\n+        if (useDialect) {\n+            \/\/System.out.println(\"[INFO] Using Hat Dialect?: \" + useDialect);\n+            kernelCallGraph.dialectifyToHat();\n+        }\n@@ -160,0 +191,1 @@\n+            t.printStackTrace();\n@@ -173,0 +205,1 @@\n+            t.printStackTrace();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat;\n-\n-public enum Space {\n-    PRIVATE,\n-    SHARED\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/Space.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Space;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -232,1 +232,2 @@\n-        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.accelerator.lookup,invokeOp)) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n+        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.accelerator.lookup,invokeOp))\n+                && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n@@ -234,1 +235,2 @@\n-                    new KernelCallGraph(this, methodRef, method, f).closeWithModuleOp()\n+                    new KernelCallGraph(this, methodRef, method, f)\n+                            .closeWithModuleOp()\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,10 @@\n+import hat.dialect.HatBarrierOp;\n+import hat.dialect.HatBlockThreadIdOp;\n+import hat.dialect.HatGlobalThreadIdOp;\n+import hat.dialect.HatGlobalSizeOp;\n+import hat.dialect.HatLocalSizeOp;\n+import hat.dialect.HatLocalThreadIdOp;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatPrivateVarOp;\n+import hat.dialect.HatThreadOP;\n@@ -30,0 +40,4 @@\n+import hat.phases.HatDialectifyTier;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n@@ -31,0 +45,1 @@\n+import jdk.incubator.code.Value;\n@@ -32,0 +47,1 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -36,1 +52,7 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n@@ -169,0 +191,326 @@\n+\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n+    }\n+\n+    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n+    }\n+\n+    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n+    }\n+\n+    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n+    }\n+\n+    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n+    public CoreOp.FuncOp dialectifyToHatBarriers(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp\n+                .elements()\n+                .mapMulti((element, consumer) -> {\n+                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n+        if (collect.isEmpty()) {\n+            \/\/ Return the function with no modifications\n+            return funcOp;\n+        }\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!collect.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createBarrierNodeOp(context, invokeOp, blockBuilder);\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/ System.out.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+    public CoreOp.FuncOp dialectifyToHatMemorySpace(CoreOp.FuncOp funcOp, Space memorySpace) {\n+\n+        String nameNode = switch (memorySpace) {\n+            case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n+            case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n+        };\n+\n+        \/\/IO.println(\"ORIGINAL: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = varOp.operands();\n+                        for (Value inputOperand : inputOperandsVarOp) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                    if (OpTk.isIfaceBufferMethod(computeContext.accelerator.lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n+                                        \/\/ It is the node we are looking for\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            \/\/ No memory nodes involved\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node\n+                Op.Result result = invokeOp.result();\n+                List<Op.Result> collect = result.uses().stream().toList();\n+                for (Op.Result r : collect) {\n+                    if (r.op() instanceof CoreOp.VarOp varOp) {\n+                        \/\/ That's the node we want\n+                        List<Value> inputOperandsVarOp = invokeOp.operands();\n+                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                        HatMemoryOp memoryOp = switch (memorySpace) {\n+                            case SHARED ->\n+                                    new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                            default ->\n+                                    new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                        };\n+                        Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n+                        context.mapValue(invokeOp.result(), hatLocalResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                \/\/ pass value\n+                context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/ IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+    private enum Space {\n+        PRIVATE,\n+        SHARED,\n+    }\n+\n+    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        String fieldName = fieldLoadOp.fieldDescriptor().name();\n+        switch (threadAccess) {\n+            case GLOBAL_ID -> {\n+                if (fieldName.equals(\"y\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"z\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case GLOBAL_SIZE -> {\n+                if (fieldName.equals(\"gsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"gsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_ID -> {\n+                if (fieldName.equals(\"liy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lyz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_SIZE -> {\n+                if (fieldName.equals(\"lsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case BLOCK_ID ->  {\n+                if (fieldName.equals(\"biy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"biz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public CoreOp.FuncOp dialectifyToHatThreadIds(CoreOp.FuncOp funcOp, ThreadAccess threadAccess) {\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                        List<Value> operands = fieldLoadOp.operands();\n+                        for (Value inputOperand : operands) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                    boolean isThreadIntrinsic = switch (threadAccess) {\n+                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n+                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n+                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n+                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n+                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n+                                    };\n+                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n+                                        consumer.accept(fieldLoadOp);\n+                                        consumer.accept(varLoadOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            \/\/ No memory nodes involved\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                List<Value> operands = fieldLoadOp.operands();\n+                for (Value operand : operands) {\n+                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> varLoadOperands = varLoadOp.operands();\n+                        List<Value> outputOperands = context.getValues(varLoadOperands);\n+                        int dim = getDimension(threadAccess, fieldLoadOp);\n+                        if (dim < 0) {\n+                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n+                        }\n+                        HatThreadOP threadOP = switch (threadAccess) {\n+                            case GLOBAL_ID -> new HatGlobalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case GLOBAL_SIZE -> new HatGlobalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case LOCAL_ID -> new HatLocalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case LOCAL_SIZE -> new HatLocalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case BLOCK_ID -> new HatBlockThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                        };\n+                        Op.Result threadResult = blockBuilder.op(threadOP);\n+                        context.mapValue(fieldLoadOp.result(), threadResult);\n+                    }\n+                }\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+    private enum ThreadAccess {\n+        GLOBAL_ID,\n+        GLOBAL_SIZE,\n+        LOCAL_ID,\n+        LOCAL_SIZE,\n+        BLOCK_ID,\n+    }\n+\n+    private CoreOp.FuncOp dialectifyToHat(CoreOp.FuncOp funcOp) {\n+        CoreOp.FuncOp f = dialectifyToHatBarriers(funcOp);\n+        for (Space space : Space.values()) {\n+            f = dialectifyToHatMemorySpace(f, space);\n+        }\n+        for (ThreadAccess threadAccess : ThreadAccess.values()) {\n+            f = dialectifyToHatThreadIds(f, threadAccess);\n+        }\n+        return f;\n+    }\n+\n+    public void dialectifyToHat() {\n+        \/\/ Analysis Phases to transform the Java Code Model to a HAT Code Model\n+\n+\n+        \/\/ Main kernel\n+        {\n+            HatDialectifyTier tier = new HatDialectifyTier(entrypoint.funcOp(), computeContext.accelerator.lookup);\n+            CoreOp.FuncOp f = tier.run();\n+            \/\/CoreOp.FuncOp f = dialectifyToHat(entrypoint.funcOp());\n+            entrypoint.funcOp(f);\n+        }\n+\n+\/\/        \/\/ Reachable functions\n+        if (moduleOp != null) {\n+            List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+            moduleOp.functionTable().forEach((_, kernelOp) -> {\n+                \/\/ ModuleOp is an Immutable Collection, thus, we need to create a new one from a\n+                \/\/ new list of methods\n+                \/\/CoreOp.FuncOp f = dialectifyToHat(kernelOp);\n+                HatDialectifyTier tier = new HatDialectifyTier(kernelOp, computeContext.accelerator.lookup);\n+                CoreOp.FuncOp f = tier.run();\n+                funcs.add(f);\n+            });\n+            moduleOp = CoreOp.module(funcs);\n+        } else {\n+            kernelReachableResolvedStream().forEach((kernel) -> {\n+                \/\/CoreOp.FuncOp f = dialectifyToHat(kernel.funcOp());\n+                HatDialectifyTier tier = new HatDialectifyTier(kernel.funcOp(), computeContext.accelerator.lookup);\n+                CoreOp.FuncOp f = tier.run();\n+                kernel.funcOp(f);\n+            });\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":349,"deletions":1,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -27,0 +27,8 @@\n+import hat.dialect.HatBarrierOp;\n+import hat.dialect.HatBlockThreadIdOp;\n+import hat.dialect.HatGlobalThreadIdOp;\n+import hat.dialect.HatGlobalSizeOp;\n+import hat.dialect.HatLocalSizeOp;\n+import hat.dialect.HatLocalThreadIdOp;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatPrivateVarOp;\n@@ -87,0 +95,16 @@\n+    T barrier(ScopedCodeBuilderContext buildContext, HatBarrierOp barrierOp);\n+\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HatLocalVarOp barrierOp);\n+\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HatPrivateVarOp hatLocalVarOp);\n+\n+    T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HatGlobalThreadIdOp hatGlobalThreadIdOp);\n+\n+    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HatGlobalSizeOp hatGlobalSizeOp);\n+\n+    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HatLocalThreadIdOp hatLocalThreadIdOp);\n+\n+    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HatLocalSizeOp hatLocalSizeOp);\n+\n+    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HatBlockThreadIdOp hatBlockThreadIdOp);\n+\n@@ -114,0 +138,8 @@\n+            case HatBarrierOp $ -> barrier(buildContext, $);\n+            case HatLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+            case HatPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n+            case HatGlobalThreadIdOp $ -> hatGlobalThreadOp(buildContext, $);\n+            case HatGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n+            case HatLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n+            case HatLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n+            case HatBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.NDRange;\n@@ -29,0 +28,5 @@\n+import hat.dialect.HatBlockThreadIdOp;\n+import hat.dialect.HatGlobalThreadIdOp;\n+import hat.dialect.HatGlobalSizeOp;\n+import hat.dialect.HatLocalSizeOp;\n+import hat.dialect.HatLocalThreadIdOp;\n@@ -50,21 +54,21 @@\n-        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n-            switch (fieldLoadOp.fieldDescriptor().name()){\n-                case \"x\",\"gix\"->globalId(0);\n-                case \"y\",\"giy\"->globalId(1);\n-                case \"z\",\"giz\"->globalId(3);\n-                case \"maxX\",\"gsx\"->globalSize(0);\n-                case \"maxY\",\"gsy\"->globalSize(1);\n-                case \"maxZ\",\"gsz\"->globalSize(2);\n-                case \"lix\"->localId(0);\n-                case \"liy\"->localId(1);\n-                case \"liz\"->localId(2);\n-                case \"lsx\"->localSize(0);\n-                case \"lsy\"->localSize(1);\n-                case \"lsz\"->localSize(2);\n-                case \"bix\"->blockId(0);\n-                case \"biy\"->blockId(1);\n-                case \"biz\"->blockId(2);\n-                default ->  throw new IllegalStateException(\"handle ? kc.\"+fieldLoadOp.fieldDescriptor().name());\n-            }\n-\n-        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n+\/\/        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n+\/\/            switch (fieldLoadOp.fieldDescriptor().name()){\n+\/\/                case \"x\",\"gix\"->globalId(0);\n+\/\/                case \"y\",\"giy\"->globalId(1);\n+\/\/                case \"z\",\"giz\"->globalId(3);\n+\/\/                case \"maxX\",\"gsx\"->globalSize(0);\n+\/\/                case \"maxY\",\"gsy\"->globalSize(1);\n+\/\/                case \"maxZ\",\"gsz\"->globalSize(2);\n+\/\/                case \"lix\"->localId(0);\n+\/\/                case \"liy\"->localId(1);\n+\/\/                case \"liz\"->localId(2);\n+\/\/                case \"lsx\"->localSize(0);\n+\/\/                case \"lsy\"->localSize(1);\n+\/\/                case \"lsz\"->localSize(2);\n+\/\/                case \"bix\"->blockId(0);\n+\/\/                case \"biy\"->blockId(1);\n+\/\/                case \"biz\"->blockId(2);\n+\/\/                default ->  throw new IllegalStateException(\"handle ? kc.\"+fieldLoadOp.fieldDescriptor().name());\n+\/\/            }\n+\/\/        } else\n+        if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n@@ -78,0 +82,1 @@\n+\n@@ -152,0 +157,30 @@\n+    @Override\n+    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HatGlobalThreadIdOp globalThreadIdOp) {\n+        globalId(globalThreadIdOp.getDimension());\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HatGlobalSizeOp globalSizeOp) {\n+        globalSize(globalSizeOp.getDimension());\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HatLocalThreadIdOp localThreadIdOp) {\n+        localId(localThreadIdOp.getDimension());\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HatLocalSizeOp hatLocalSizeOp) {\n+        localSize(hatLocalSizeOp.getDimension());\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HatBlockThreadIdOp hatBlockThreadIdOp) {\n+        blockId(hatBlockThreadIdOp.getDimension());\n+        return self();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":57,"deletions":22,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -137,0 +138,5 @@\n+\n+    public T varName(HatMemoryOp hatLocalVarOp) {\n+        identifier(hatLocalVarOp.varName());\n+        return self();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import hat.Space;\n+import hat.dialect.HatBarrierOp;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatPrivateVarOp;\n@@ -35,4 +38,0 @@\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.Stack;\n@@ -41,2 +40,0 @@\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n@@ -44,1 +41,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -64,2 +60,7 @@\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-        varName(varOp);\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        switch (resolve) {\n+            case CoreOp.VarOp varOp -> varName(varOp);\n+            case HatMemoryOp hatMemoryOp -> varName(hatMemoryOp);\n+            case null, default -> {\n+            }\n+        }\n@@ -71,1 +72,1 @@\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+        CoreOp.VarOp varOp = (CoreOp.VarOp) buildContext.scope.resolve(varStoreOp.operands().getFirst());\n@@ -77,13 +78,1 @@\n-\n-\n-    public record LocalArrayDeclaration(ClassType classType, CoreOp.VarOp varOp) {}\n-    private final Stack<LocalArrayDeclaration> localArrayDeclarations = new Stack<>();\n-    private final Set<CoreOp.VarOp> localDataStructures = new HashSet<>();\n-\n-    private boolean isMappableIFace(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        return (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class));\n-    }\n-\n-    private void annotateTypeAndName( ClassType classType, CoreOp.VarOp varOp) {\n-        localArrayDeclarations.push(new LocalArrayDeclaration(classType, varOp));\n-    }\n+    public record LocalArrayDeclaration(ClassType classType, HatMemoryOp varOp) {}\n@@ -93,3 +82,0 @@\n-        if (isMappableIFace(buildContext, (JavaType) varOp.varValueType()) && (JavaType) varOp.varValueType() instanceof ClassType classType) {\n-            annotateTypeAndName( classType, varOp);\n-        }\n@@ -109,0 +95,14 @@\n+    @Override\n+    public T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HatLocalVarOp hatLocalVarOp) {\n+        LocalArrayDeclaration localArrayDeclaration = new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp);\n+        localDeclaration(localArrayDeclaration);\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HatPrivateVarOp hatLocalVarOp) {\n+        LocalArrayDeclaration localArrayDeclaration = new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp);\n+        privateDeclaration(localArrayDeclaration);\n+        return self();\n+    }\n+\n@@ -133,1 +133,0 @@\n-\n@@ -417,0 +416,5 @@\n+    @Override\n+    public T barrier(ScopedCodeBuilderContext buildContext, HatBarrierOp barrierOp) {\n+        return syncBlockThreads();\n+    }\n+\n@@ -432,36 +436,1 @@\n-                if (OpTk.funcName(invokeOp).equals(\"create\")) {\n-                    \/\/ If we decide to keep the version in which we pass the enum with the memory space\n-                    \/\/ to allocate a particular data structure (E.g., shared, or private)\n-\n-                    \/\/ Obtain the space in the first parameter\n-                    List<Value> operands = invokeOp.operands();\n-                    if (operands.size() != 1) {\n-                        throw new RuntimeException(\"[Fail] `create` method expects one parameter for the space\");\n-                    }\n-                    Value spaceValue = operands.getFirst();\n-                    if (spaceValue instanceof Op.Result instanceResult) {\n-                        if (instanceResult.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp ) {\n-                            \/\/ check type of field load\n-                            TypeElement typeElement = fieldLoadOp.fieldDescriptor().refType();\n-                            if (typeElement instanceof ClassType classType) {\n-                                if (!classType.toClassName().equals(Space.class.getCanonicalName())) {\n-                                    throw new RuntimeException(\"[Fail] Expected an instance from Space\");\n-                                }\n-                            }\n-\n-                            \/\/ If the type is correct, then we obtain the enum value and invoke the\n-                            \/\/ corresponding declaration\n-                            String spaceName = fieldLoadOp.fieldDescriptor().name();\n-                            LocalArrayDeclaration declaration = localArrayDeclarations.pop();\n-                            if (spaceName.equals(Space.PRIVATE.name())) {\n-                                privateDeclaration(declaration);\n-                            } else if (spaceName.equals(Space.SHARED.name())) {\n-                                localDeclaration(declaration);\n-                            }\n-                        }\n-                    }\n-                } else if (OpTk.funcName(invokeOp).equals(\"createLocal\")) {\n-                    LocalArrayDeclaration declaration = localArrayDeclarations.pop();\n-                    localDeclaration(declaration);\n-                    localDataStructures.add(declaration.varOp);\n-                } else if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+               if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -516,1 +485,1 @@\n-                    boolean isLocal = false;\n+                    boolean isLocalOrPrivateDS = false;\n@@ -518,3 +487,4 @@\n-                        CoreOp.VarOp resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-                        if (localDataStructures.contains(resolve)) {\n-                            isLocal = true;\n+                        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+                        \/\/if (localDataStructures.contains(resolve)) {\n+                        if (resolve instanceof HatMemoryOp) {\n+                            isLocalOrPrivateDS = true;\n@@ -524,1 +494,1 @@\n-                    either(isLocal, CodeBuilder::dot, CodeBuilder::rarrow);\n+                    either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n@@ -565,11 +535,5 @@\n-            \/\/ Detect well-known constructs\n-\n-            if (OpTk.funcName(invokeOp).equals(\"barrier\")) { \/\/ TODO:  only on kernel context?\n-                List<Value> operands = invokeOp.operands(); \/\/ map to Result and use stream filter and  find\n-                for (Value value : operands) {\n-                    if (value instanceof Op.Result instanceResult) {\n-                        FunctionType functionType = instanceResult.op().opType();\n-                        \/\/ if it is a barrier from the kernel context, then we generate\n-                        \/\/ a local barrier.\n-                        if (functionType.returnType().toString().equals(\"hat.KernelContext\")) {  \/\/ OpTk.isAssignable?\n-                            syncBlockThreads();\n+            \/\/ General case\n+            funcName(invokeOp).paren(_ ->\n+                    separated(invokeOp.operands(), ($) -> $.comma().space(), (op) -> {\n+                        if (op instanceof Op.Result result) {\n+                            recurse(buildContext, result.op());\n@@ -577,12 +541,2 @@\n-                    }\n-                }\n-            } else {\n-                \/\/ General case\n-                funcName(invokeOp).paren(_ ->\n-                        separated(invokeOp.operands(), ($)->$.comma().space(), (op) -> {\n-                            if (op instanceof Op.Result result) {\n-                                recurse(buildContext, result.op());\n-                            }\n-                        })\n-                );\n-            }\n+                    })\n+            );\n@@ -637,2 +591,2 @@\n-                case JavaOp.LabeledOp _ ->false;\n-                case JavaOp.YieldOp _ ->false;\n+                case JavaOp.LabeledOp _ -> false;\n+                case JavaOp.YieldOp _ -> false;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":48,"deletions":94,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -48,1 +49,1 @@\n-        public CoreOp.VarOp resolve(Value value) {\n+        public Op resolve(Value value) {\n@@ -52,0 +53,5 @@\n+\n+            if (value instanceof Op.Result result && result.op() instanceof HatMemoryOp hatMemoryOp) {\n+                return hatMemoryOp;\n+            }\n+\n@@ -67,1 +73,1 @@\n-        public CoreOp.VarOp resolve(Value value) {\n+        public Op resolve(Value value) {\n@@ -181,1 +187,0 @@\n-\n@@ -183,1 +188,1 @@\n-        public CoreOp.VarOp resolve(Value value) {\n+        public Op resolve(Value value) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatBarrierOp extends HatOP {\n+\n+    private static final String NAME = \"hat.dialect.sync.barrier\";\n+    public static final String INTRINSIC_NAME = \"barrier\";\n+\n+    public HatBarrierOp(List<Value> operands) {\n+        super(NAME, operands);\n+    }\n+\n+    public HatBarrierOp(HatBarrierOp hatBarrierOp, CopyContext copyContext) {\n+        super(hatBarrierOp, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatBarrierOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return JavaType.VOID;\n+    }\n+\n+    public Map<String, Object> externalize() {return Map.of(NAME, JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatBarrierOp.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatBlockThreadIdOp extends HatThreadOP {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"BlockThreadId\";\n+\n+    public HatBlockThreadIdOp(int dimension, TypeElement resultType, List<Value> operands) {\n+        super(NAME, dimension, operands);\n+        this.resultType = resultType;\n+    }\n+\n+    public HatBlockThreadIdOp(HatBlockThreadIdOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatBlockThreadIdOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatBlockThreadIdOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatGlobalSizeOp extends HatThreadOP {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"GlobalThreadSize\";\n+\n+    public HatGlobalSizeOp(int dimension, TypeElement resultType, List<Value> operands) {\n+        super(NAME, dimension, operands);\n+        this.resultType = resultType;\n+    }\n+\n+    public HatGlobalSizeOp(HatGlobalSizeOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatGlobalSizeOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatGlobalSizeOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatGlobalThreadIdOp extends HatThreadOP {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"GlobalThreadId\";\n+\n+    public HatGlobalThreadIdOp(int dimension, TypeElement resultType, List<Value> operands) {\n+        super(NAME, dimension, operands);\n+        this.resultType = resultType;\n+    }\n+\n+    public HatGlobalThreadIdOp(HatGlobalThreadIdOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatGlobalThreadIdOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatGlobalThreadIdOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatLocalSizeOp extends HatThreadOP {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"GlobalThreadSize\";\n+\n+    public HatLocalSizeOp(int dimension, TypeElement resultType, List<Value> operands) {\n+        super(NAME, dimension, operands);\n+        this.resultType = resultType;\n+    }\n+\n+    public HatLocalSizeOp(HatLocalSizeOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatLocalSizeOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalSizeOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatLocalThreadIdOp extends HatThreadOP {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"LocalThreadId\";\n+\n+    public HatLocalThreadIdOp(int dimension, TypeElement resultType, List<Value> operands) {\n+        super(NAME, dimension, operands);\n+        this.resultType = resultType;\n+    }\n+\n+    public HatLocalThreadIdOp(HatLocalThreadIdOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatLocalThreadIdOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalThreadIdOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatLocalVarOp extends HatMemoryOp {\n+\n+    public static final String INTRINSIC_NAME = \"createLocal\";\n+\n+    private final TypeElement typeElement;\n+    private final ClassType klassType;\n+    private final TypeElement invokeResultType;\n+\n+    public HatLocalVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType,  List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.klassType = javaType;\n+        this.invokeResultType = invokeResultType;\n+    }\n+\n+    public HatLocalVarOp(HatLocalVarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.resultType();\n+        this.klassType = op.klassType;\n+        this.invokeResultType = op.invokeResultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatLocalVarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.hatSharedVarOp.\" + opName(), typeElement);\n+    }\n+\n+    public String varName() {\n+        return opName();\n+    }\n+\n+    public ClassType classType() {\n+        return klassType;\n+    }\n+\n+    public TypeElement invokeType() {\n+        return invokeResultType;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalVarOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+\n+public abstract class HatMemoryOp extends HatOP {\n+\n+    public HatMemoryOp(String name, List<Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    protected HatMemoryOp(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+\n+    public String varName() {\n+        return opName();\n+    }\n+\n+    public abstract ClassType classType();\n+\n+    public abstract TypeElement invokeType();\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatMemoryOp.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HatOP extends Op {\n+\n+    public HatOP(String name, List<Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    protected HatOP(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatOP.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatPrivateVarOp extends HatMemoryOp {\n+\n+    public static final String INTRINSIC_NAME = \"createPrivate\";\n+\n+    private final TypeElement typeElement;\n+    private final ClassType klassType;\n+    private final TypeElement invokeResultType;\n+\n+    public HatPrivateVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.klassType = javaType;\n+        this.invokeResultType = invokeResultType;\n+    }\n+\n+    public HatPrivateVarOp(HatPrivateVarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.resultType();\n+        this.klassType = op.klassType;\n+        this.invokeResultType = op.invokeResultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatPrivateVarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.hatPrivateVarOp.\" + opName(), typeElement);\n+    }\n+\n+\n+    @Override\n+    public String varName() {\n+        return opName();\n+    }\n+\n+    @Override\n+    public ClassType classType() {\n+        return klassType;\n+    }\n+\n+    @Override\n+    public TypeElement invokeType() {\n+        return invokeResultType;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatPrivateVarOp.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HatThreadOP extends HatOP {\n+\n+    private final int dimension;\n+\n+    public HatThreadOP(String name, int dimension, List<Value> operands) {\n+        super(name, operands);\n+        this.dimension = dimension;\n+    }\n+\n+    protected HatThreadOP(HatThreadOP that, CopyContext cc) {\n+        super(that, cc);\n+        this.dimension = that.dimension;\n+    }\n+\n+    public int getDimension() {\n+        return dimension;\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatThreadOP.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -31,0 +31,2 @@\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatThreadOP;\n@@ -56,1 +58,0 @@\n-import java.util.function.Predicate;\n@@ -65,1 +66,0 @@\n-\n@@ -174,2 +174,1 @@\n-\n-    public static JavaOp.InvokeOp getQuotableTargetInvokeOpWrapper( JavaOp.LambdaOp lambdaOp) {\n+    public static JavaOp.InvokeOp getQuotableTargetInvokeOpWrapper(JavaOp.LambdaOp lambdaOp) {\n@@ -225,0 +224,1 @@\n+                        || (op instanceof HatMemoryOp)\n@@ -315,0 +315,1 @@\n+            case HatThreadOP o -> 0;\n@@ -344,1 +345,1 @@\n-            default -> throw new IllegalStateException(\"precedence \");\n+            default -> throw new IllegalStateException(\"[Illegal] Precedence Op not registered: \" + op.getClass().getSimpleName());\n@@ -410,0 +411,1 @@\n+\n@@ -413,0 +415,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HatBarrierOp;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyBarrierPhase implements HatDialectifyPhase {\n+\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp\n+                .elements()\n+                .mapMulti((element, consumer) -> {\n+                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n+        if (collect.isEmpty()) {\n+            \/\/ Return the function with no modifications\n+            return funcOp;\n+        }\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!collect.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createBarrierNodeOp(context, invokeOp, blockBuilder);\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/ System.out.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyBarrierPhase.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatPrivateVarOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDialectifyMemoryPhase implements HatDialectifyPhase {\n+\n+    public enum Space {\n+        PRIVATE,\n+        SHARED,\n+    }\n+\n+    private final Space memorySpace;\n+    private final MethodHandles.Lookup lookup;\n+\n+    public HatDialectifyMemoryPhase(Space space, MethodHandles.Lookup lookup) {\n+        this.memorySpace = space;\n+        this.lookup = lookup;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+            String nameNode = switch (memorySpace) {\n+                case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n+                case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n+            };\n+\n+            \/\/IO.println(\"ORIGINAL: \" + funcOp.toText());\n+            Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                    .mapMulti((codeElement, consumer) -> {\n+                        if (codeElement instanceof CoreOp.VarOp varOp) {\n+                            List<Value> inputOperandsVarOp = varOp.operands();\n+                            for (Value inputOperand : inputOperandsVarOp) {\n+                                if (inputOperand instanceof Op.Result result) {\n+                                    if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                        if (OpTk.isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n+                                            \/\/ It is the node we are looking for\n+                                            consumer.accept(invokeOp);\n+                                            consumer.accept(varOp);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+            Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+            if (nodesInvolved.isEmpty()) {\n+                \/\/ No memory nodes involved\n+                return funcOp;\n+            }\n+\n+            funcOp = funcOp.transform((blockBuilder, op) -> {\n+                CopyContext context = blockBuilder.context();\n+                if (!nodesInvolved.contains(op)) {\n+                    blockBuilder.op(op);\n+                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    \/\/ Don't insert the invoke node\n+                    Op.Result result = invokeOp.result();\n+                    List<Op.Result> collect = result.uses().stream().toList();\n+                    for (Op.Result r : collect) {\n+                        if (r.op() instanceof CoreOp.VarOp varOp) {\n+                            \/\/ That's the node we want\n+                            List<Value> inputOperandsVarOp = invokeOp.operands();\n+                            List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                            HatMemoryOp memoryOp = switch (memorySpace) {\n+                                case SHARED ->\n+                                        new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                                default ->\n+                                        new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                            };\n+                            Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n+                            context.mapValue(invokeOp.result(), hatLocalResult);\n+                        }\n+                    }\n+                } else if (op instanceof CoreOp.VarOp varOp) {\n+                    \/\/ pass value\n+                    context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+                }\n+                return blockBuilder;\n+            });\n+            \/\/ IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+            \/\/entrypoint.funcOp(funcOp);\n+            return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyMemoryPhase.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+public interface HatDialectifyPhase {\n+\n+    CoreOp.FuncOp run(CoreOp.FuncOp funcOp);\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyPhase.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+\n+public class HatDialectifyTier {\n+\n+    private CoreOp.FuncOp funcOp;\n+    List<HatDialectifyPhase> hatPhases = new ArrayList<>();\n+\n+    public HatDialectifyTier(CoreOp.FuncOp funcOp, MethodHandles.Lookup lookup) {\n+        this.funcOp = funcOp;\n+        hatPhases.add(new HatDialectifyBarrierPhase());\n+        for (HatDialectifyMemoryPhase.Space space: HatDialectifyMemoryPhase.Space.values()) {\n+            hatPhases.add(new HatDialectifyMemoryPhase(space, lookup));\n+            hatPhases.add(new HatDialectifyMemoryPhase(space, lookup));\n+        }\n+        for (HatDilectifyThreadsPhase.ThreadAccess threadAccess: HatDilectifyThreadsPhase.ThreadAccess.values()) {\n+            hatPhases.add(new HatDilectifyThreadsPhase(threadAccess));\n+        }\n+    }\n+\n+    public CoreOp.FuncOp run() {\n+        BlockingQueue<HatDialectifyPhase> queue = new ArrayBlockingQueue<>(hatPhases.size());\n+        queue.addAll(hatPhases);\n+        CoreOp.FuncOp f = funcOp;\n+        while (!queue.isEmpty()) {\n+            HatDialectifyPhase phase;\n+            try {\n+                phase = queue.take();\n+                f = phase.run(f);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return f;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyTier.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.dialect.HatBlockThreadIdOp;\n+import hat.dialect.HatGlobalSizeOp;\n+import hat.dialect.HatGlobalThreadIdOp;\n+import hat.dialect.HatLocalSizeOp;\n+import hat.dialect.HatLocalThreadIdOp;\n+import hat.dialect.HatThreadOP;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HatDilectifyThreadsPhase implements HatDialectifyPhase {\n+\n+    private final ThreadAccess threadAccess;\n+\n+    public HatDilectifyThreadsPhase(ThreadAccess threadAccess) {\n+        this.threadAccess =  threadAccess;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                        List<Value> operands = fieldLoadOp.operands();\n+                        for (Value inputOperand : operands) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                    boolean isThreadIntrinsic = switch (threadAccess) {\n+                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n+                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n+                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n+                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n+                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n+                                    };\n+                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n+                                        consumer.accept(fieldLoadOp);\n+                                        consumer.accept(varLoadOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            \/\/ No memory nodes involved\n+            return funcOp;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                List<Value> operands = fieldLoadOp.operands();\n+                for (Value operand : operands) {\n+                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> varLoadOperands = varLoadOp.operands();\n+                        List<Value> outputOperands = context.getValues(varLoadOperands);\n+                        int dim = getDimension(threadAccess, fieldLoadOp);\n+                        if (dim < 0) {\n+                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n+                        }\n+                        HatThreadOP threadOP = switch (threadAccess) {\n+                            case GLOBAL_ID -> new HatGlobalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case GLOBAL_SIZE -> new HatGlobalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case LOCAL_ID -> new HatLocalThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case LOCAL_SIZE -> new HatLocalSizeOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                            case BLOCK_ID -> new HatBlockThreadIdOp(dim, fieldLoadOp.resultType(), outputOperands);\n+                        };\n+                        Op.Result threadResult = blockBuilder.op(threadOP);\n+                        context.mapValue(fieldLoadOp.result(), threadResult);\n+                    }\n+                }\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+        \/\/entrypoint.funcOp(funcOp);\n+        return funcOp;\n+    }\n+\n+    public enum ThreadAccess {\n+        GLOBAL_ID,\n+        GLOBAL_SIZE,\n+        LOCAL_ID,\n+        LOCAL_SIZE,\n+        BLOCK_ID,\n+    }\n+\n+\n+    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        String fieldName = fieldLoadOp.fieldDescriptor().name();\n+        switch (threadAccess) {\n+            case GLOBAL_ID -> {\n+                if (fieldName.equals(\"y\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"z\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case GLOBAL_SIZE -> {\n+                if (fieldName.equals(\"gsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"gsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_ID -> {\n+                if (fieldName.equals(\"liy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lyz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_SIZE -> {\n+                if (fieldName.equals(\"lsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case BLOCK_ID ->  {\n+                if (fieldName.equals(\"biy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"biz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+\n+    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n+    }\n+\n+    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n+    }\n+\n+    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n+    }\n+\n+    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n+    }\n+\n+    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n+    }\n+\n+    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDilectifyThreadsPhase.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-    private interface MySharedArray extends Buffer {\n+    private interface MyArray extends Buffer {\n@@ -61,1 +61,1 @@\n-        Schema<MySharedArray> schema = Schema.of(MySharedArray.class,\n+        Schema<MyArray> schema = Schema.of(MyArray.class,\n@@ -65,1 +65,1 @@\n-        static MySharedArray create(Accelerator accelerator) {\n+        static MyArray create(Accelerator accelerator) {\n@@ -69,1 +69,1 @@\n-        static MySharedArray createLocal() {\n+        static MyArray createLocal() {\n@@ -77,1 +77,1 @@\n-        MySharedArray mySharedArray = MySharedArray.createLocal();\n+        MyArray mySharedArray = MyArray.createLocal();\n@@ -97,1 +97,1 @@\n-        MySharedArray.schema.toText(System.out::print);\n+        MyArray.schema.toText(System.out::print);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalArray.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import hat.Space;\n@@ -308,0 +307,1 @@\n+                case \"2D\" -> Configuration._2D;\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-                \"oracle.code.hat.TestReductions\"\n+                \"oracle.code.hat.TestReductions\",\n+                \"oracle.code.hat.TestPrivate\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.F32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.RW;\n+\n+public class TestPrivate {\n+\n+    private interface PrivateArray extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+\n+        Schema<PrivateArray> schema = Schema.of(PrivateArray.class,\n+                myPrivateArray -> myPrivateArray\n+                        .array(\"array\", 1));\n+\n+        static PrivateArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator, 1);\n+        }\n+\n+        static PrivateArray createPrivate() {\n+            return create(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static void compute(@RO KernelContext kernelContext, @RW F32Array data) {\n+        PrivateArray privateArray = PrivateArray.createPrivate();\n+        int lix = kernelContext.lix;\n+        int blockId = kernelContext.bix;\n+        int blockSize = kernelContext.lsx;\n+        privateArray.array(0, lix);\n+        data.array(lix + (long) blockId * blockSize, privateArray.array(0));\n+    }\n+\n+    @CodeReflection\n+    private static void myCompute(@RO ComputeContext computeContext, @RW F32Array data) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32));\n+        computeContext.dispatchKernel(computeRange,\n+                kernelContext -> compute(kernelContext, data)\n+        );\n+    }\n+\n+    @HatTest\n+    public void testPrivate() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        F32Array data = F32Array.create(accelerator, 32);\n+        accelerator.compute(computeContext -> {\n+            TestPrivate.myCompute(computeContext, data);\n+        });\n+\n+        \/\/ Check result\n+        boolean isCorrect = true;\n+        int jIndex = 0;\n+        for (int i = 0; i < data.length(); i++) {\n+            if (data.array(i) != jIndex++) {\n+                IO.println(data.array(i) + \" != \" + jIndex);\n+                isCorrect = false;\n+                \/\/break;\n+            }\n+        }\n+        HatAsserts.assertTrue(isCorrect);\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestPrivate.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -29,0 +29,5 @@\n+import hat.dialect.HatBlockThreadIdOp;\n+import hat.dialect.HatGlobalThreadIdOp;\n+import hat.dialect.HatGlobalSizeOp;\n+import hat.dialect.HatLocalSizeOp;\n+import hat.dialect.HatLocalThreadIdOp;\n@@ -93,0 +98,29 @@\n+    @Override\n+    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HatGlobalThreadIdOp globalThreadIdOp) {\n+        blockInlineComment(\"Thread ID access\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HatGlobalSizeOp hatGlobalThreadIdOp) {\n+        blockInlineComment(\"GlobalSize\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HatLocalThreadIdOp hatLocalThreadIdOp) {\n+        blockInlineComment(\"Local Thread ID\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HatLocalSizeOp hatLocalSizeOp) {\n+        blockInlineComment(\"Local Size\");\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HatBlockThreadIdOp hatBlockThreadIdOp) {\n+        blockInlineComment(\"Block ID \");\n+        return self();\n+    }\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}