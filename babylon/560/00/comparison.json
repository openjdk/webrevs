{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import hat.dialect.HatOP;\n@@ -166,1 +167,1 @@\n-    public static class PTXPtrOp extends Op {\n+    public static class PTXPtrOp extends HatOP {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,0 +181,6 @@\n+    \/\/ \/\/ CUDA events for timing\n+    \/\/ cudaEvent_t start, stop;\n+    \/\/ cuEventCreate(&start, cudaEventDefault);\n+    \/\/ cuEventCreate(&stop, cudaEventDefault);\n+    \/\/ cuEventRecord(start, 0);\n+\n@@ -188,0 +194,6 @@\n+    \/\/ cuEventRecord(stop, 0);\n+    \/\/ cuEventSynchronize(stop); \/\/ Wait for completion\n+    \/\/\n+    \/\/ float elapsedTimeMs = 0.0f;\n+    \/\/ cuEventElapsedTime(&elapsedTimeMs, start, stop);\n+    \/\/ std::cout << \"Kernel Elapsed Time: \" << elapsedTimeMs << \" ms\\n\";\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -45,3 +46,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -146,5 +144,3 @@\n-        if (Objects.requireNonNull(op) instanceof JavaOp.InvokeOp invokeOp) {\n-            if (OpTk.isIfaceAccessor(lookup, invokeOp)) {\n-                String klassName = invokeOp.resultType().toString();\n-                localIfaceList.add(klassName);\n-            }\n+        if (Objects.requireNonNull(op) instanceof HatMemoryOp hatMemoryOp) {\n+            String klassName = hatMemoryOp.invokeType().toString();\n+            localIfaceList.add(klassName);\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.dialect.HatBarrierOp;\n@@ -35,0 +36,2 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CopyContext;\n@@ -38,0 +41,1 @@\n+import jdk.incubator.code.Value;\n@@ -43,0 +47,1 @@\n+import java.util.List;\n@@ -135,0 +140,18 @@\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n@@ -140,1 +163,1 @@\n-        MethodRef methodRef =OpTk.getQuotableTargetInvokeOpWrapper( lambdaOp).invokeDescriptor();\n+        MethodRef methodRef = OpTk.getQuotableTargetInvokeOpWrapper( lambdaOp).invokeDescriptor();\n@@ -142,0 +165,9 @@\n+\n+        \/\/ Analysis : dialect\n+        \/\/ NOTE: Keep the following boolean until we have the config available\/reachable\n+        \/\/ from this class\n+        boolean useDialect = true;\n+        if (useDialect) {\n+            \/\/System.out.println(\"[INFO] Using Hat Dialect?: \" + useDialect);\n+            kernelCallGraph.dialectifyToHat();\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -232,1 +232,2 @@\n-        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.accelerator.lookup,invokeOp)) && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n+        if (entrypoint.method.getDeclaringClass().equals(OpTk.javaRefClassOrThrow(computeContext.accelerator.lookup,invokeOp))\n+                && isKernelDispatch(computeContext.accelerator.lookup,method, f)) {\n@@ -234,1 +235,2 @@\n-                    new KernelCallGraph(this, methodRef, method, f).closeWithModuleOp()\n+                    new KernelCallGraph(this, methodRef, method, f)\n+                            .closeWithModuleOp()\n@@ -237,0 +239,1 @@\n+            System.out.println(\"B\");\n@@ -239,0 +242,1 @@\n+            System.out.println(\"C\");\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import hat.dialect.HatBarrierOp;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatPrivateVarOp;\n@@ -30,0 +34,3 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n@@ -31,0 +38,1 @@\n+import jdk.incubator.code.Value;\n@@ -32,0 +40,1 @@\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -36,1 +45,6 @@\n-import java.util.*;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n@@ -169,0 +183,116 @@\n+\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n+    public void dialectifyToHatBarriers() {\n+        CoreOp.FuncOp funcOp = entrypoint.funcOp();\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n+                    createBarrierNodeOp(context, invokeOp, blockBuilder);\n+                } else {\n+                    blockBuilder.op(op);\n+                }\n+            } else {\n+                blockBuilder.op(op);\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/ System.out.println(\"[INFO] Code model: \" + funcOp.toText());\n+        entrypoint.funcOp(funcOp);\n+    }\n+\n+    public void dialectifyToHatMemorySpace(Space memorySpace) {\n+\n+        String nameNode = switch (memorySpace) {\n+            case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n+            case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n+        };\n+\n+        CoreOp.FuncOp funcOp = entrypoint.funcOp();\n+        \/\/IO.println(\"ORIGINAL: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> elements = entrypoint.funcOp().elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsAdd = varOp.operands();\n+                        for (Value inputOperand : inputOperandsAdd) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                    if (OpTk.isIfaceBufferMethod(computeContext.accelerator.lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n+                                        \/\/ It is the node we are looking for\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            \/\/ No memory nodes involved\n+            return;\n+        }\n+\n+        funcOp = funcOp.transform((blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node\n+                Op.Result result = invokeOp.result();\n+                List<Op.Result> collect = result.uses().stream().toList();\n+                for (Op.Result r : collect) {\n+                    if (r.op() instanceof CoreOp.VarOp varOp) {\n+                        \/\/ That's the node we want\n+                        List<Value> inputOperandsAdd = invokeOp.operands();\n+                        List<Value> outputOperandsAdd = context.getValues(inputOperandsAdd);\n+                        HatMemoryOp memoryOp;\n+                        if (memorySpace == Space.SHARED) {\n+                            memoryOp = new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsAdd);\n+                        } else {\n+                            memoryOp = new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsAdd);\n+                        }\n+                        Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n+                        context.mapValue(invokeOp.result(), hatLocalResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                \/\/ pass value\n+                context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+        \/\/ IO.println(\"[INFO] Code model: \" + funcOp.toText());\n+        entrypoint.funcOp(funcOp);\n+    }\n+\n+    private enum Space {\n+        PRIVATE,\n+        SHARED,\n+    }\n+\n+    public void dialectifyToHat() {\n+        \/\/ Phases\n+        dialectifyToHatBarriers();\n+        dialectifyToHatMemorySpace(Space.SHARED);\n+        dialectifyToHatMemorySpace(Space.PRIVATE);\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":131,"deletions":1,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import hat.dialect.HatBarrierOp;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatPrivateVarOp;\n@@ -87,0 +90,6 @@\n+    T barrier(ScopedCodeBuilderContext buildContext, HatBarrierOp barrierOp);\n+\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HatLocalVarOp barrierOp);\n+\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HatPrivateVarOp hatLocalVarOp);\n+\n@@ -114,0 +123,3 @@\n+            case HatBarrierOp $ -> barrier(buildContext, $);\n+            case HatLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+            case HatPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -137,0 +138,5 @@\n+\n+    public T varName(HatMemoryOp hatLocalVarOp) {\n+        identifier(hatLocalVarOp.varName());\n+        return self();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import hat.Space;\n+import hat.dialect.HatBarrierOp;\n+import hat.dialect.HatLocalVarOp;\n+import hat.dialect.HatMemoryOp;\n+import hat.dialect.HatPrivateVarOp;\n@@ -36,1 +39,0 @@\n-import java.util.List;\n@@ -41,2 +43,0 @@\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n@@ -44,1 +44,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n@@ -64,2 +63,7 @@\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-        varName(varOp);\n+        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+        switch (resolve) {\n+            case CoreOp.VarOp varOp -> varName(varOp);\n+            case HatMemoryOp hatMemoryOp -> varName(hatMemoryOp);\n+            case null, default -> {\n+            }\n+        }\n@@ -71,1 +75,1 @@\n-        CoreOp.VarOp varOp = buildContext.scope.resolve(varStoreOp.operands().getFirst());\n+        CoreOp.VarOp varOp = (CoreOp.VarOp) buildContext.scope.resolve(varStoreOp.operands().getFirst());\n@@ -77,13 +81,1 @@\n-\n-\n-    public record LocalArrayDeclaration(ClassType classType, CoreOp.VarOp varOp) {}\n-    private final Stack<LocalArrayDeclaration> localArrayDeclarations = new Stack<>();\n-    private final Set<CoreOp.VarOp> localDataStructures = new HashSet<>();\n-\n-    private boolean isMappableIFace(ScopedCodeBuilderContext buildContext, JavaType javaType) {\n-        return (OpTk.isAssignable(buildContext.lookup,javaType, MappableIface.class));\n-    }\n-\n-    private void annotateTypeAndName( ClassType classType, CoreOp.VarOp varOp) {\n-        localArrayDeclarations.push(new LocalArrayDeclaration(classType, varOp));\n-    }\n+    public record LocalArrayDeclaration(ClassType classType, HatMemoryOp varOp) {}\n@@ -93,3 +85,0 @@\n-        if (isMappableIFace(buildContext, (JavaType) varOp.varValueType()) && (JavaType) varOp.varValueType() instanceof ClassType classType) {\n-            annotateTypeAndName( classType, varOp);\n-        }\n@@ -109,0 +98,14 @@\n+    @Override\n+    public T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HatLocalVarOp hatLocalVarOp) {\n+        LocalArrayDeclaration localArrayDeclaration = new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp);\n+        localDeclaration(localArrayDeclaration);\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HatPrivateVarOp hatLocalVarOp) {\n+        LocalArrayDeclaration localArrayDeclaration = new LocalArrayDeclaration(hatLocalVarOp.classType(), hatLocalVarOp);\n+        privateDeclaration(localArrayDeclaration);\n+        return self();\n+    }\n+\n@@ -417,0 +420,5 @@\n+    @Override\n+    public T barrier(ScopedCodeBuilderContext buildContext, HatBarrierOp barrierOp) {\n+        return syncBlockThreads();\n+    }\n+\n@@ -432,36 +440,1 @@\n-                if (OpTk.funcName(invokeOp).equals(\"create\")) {\n-                    \/\/ If we decide to keep the version in which we pass the enum with the memory space\n-                    \/\/ to allocate a particular data structure (E.g., shared, or private)\n-\n-                    \/\/ Obtain the space in the first parameter\n-                    List<Value> operands = invokeOp.operands();\n-                    if (operands.size() != 1) {\n-                        throw new RuntimeException(\"[Fail] `create` method expects one parameter for the space\");\n-                    }\n-                    Value spaceValue = operands.getFirst();\n-                    if (spaceValue instanceof Op.Result instanceResult) {\n-                        if (instanceResult.op() instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp ) {\n-                            \/\/ check type of field load\n-                            TypeElement typeElement = fieldLoadOp.fieldDescriptor().refType();\n-                            if (typeElement instanceof ClassType classType) {\n-                                if (!classType.toClassName().equals(Space.class.getCanonicalName())) {\n-                                    throw new RuntimeException(\"[Fail] Expected an instance from Space\");\n-                                }\n-                            }\n-\n-                            \/\/ If the type is correct, then we obtain the enum value and invoke the\n-                            \/\/ corresponding declaration\n-                            String spaceName = fieldLoadOp.fieldDescriptor().name();\n-                            LocalArrayDeclaration declaration = localArrayDeclarations.pop();\n-                            if (spaceName.equals(Space.PRIVATE.name())) {\n-                                privateDeclaration(declaration);\n-                            } else if (spaceName.equals(Space.SHARED.name())) {\n-                                localDeclaration(declaration);\n-                            }\n-                        }\n-                    }\n-                } else if (OpTk.funcName(invokeOp).equals(\"createLocal\")) {\n-                    LocalArrayDeclaration declaration = localArrayDeclarations.pop();\n-                    localDeclaration(declaration);\n-                    localDataStructures.add(declaration.varOp);\n-                } else if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n+               if (invokeOp.operands().getFirst() instanceof Op.Result instanceResult) {\n@@ -516,1 +489,1 @@\n-                    boolean isLocal = false;\n+                    boolean isLocalOrPrivateDS = false;\n@@ -518,3 +491,4 @@\n-                        CoreOp.VarOp resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n-                        if (localDataStructures.contains(resolve)) {\n-                            isLocal = true;\n+                        Op resolve = buildContext.scope.resolve(varLoadOp.operands().getFirst());\n+                        \/\/if (localDataStructures.contains(resolve)) {\n+                        if (resolve instanceof HatMemoryOp) {\n+                            isLocalOrPrivateDS = true;\n@@ -524,1 +498,1 @@\n-                    either(isLocal, CodeBuilder::dot, CodeBuilder::rarrow);\n+                    either(isLocalOrPrivateDS, CodeBuilder::dot, CodeBuilder::rarrow);\n@@ -565,11 +539,5 @@\n-            \/\/ Detect well-known constructs\n-\n-            if (OpTk.funcName(invokeOp).equals(\"barrier\")) { \/\/ TODO:  only on kernel context?\n-                List<Value> operands = invokeOp.operands(); \/\/ map to Result and use stream filter and  find\n-                for (Value value : operands) {\n-                    if (value instanceof Op.Result instanceResult) {\n-                        FunctionType functionType = instanceResult.op().opType();\n-                        \/\/ if it is a barrier from the kernel context, then we generate\n-                        \/\/ a local barrier.\n-                        if (functionType.returnType().toString().equals(\"hat.KernelContext\")) {  \/\/ OpTk.isAssignable?\n-                            syncBlockThreads();\n+            \/\/ General case\n+            funcName(invokeOp).paren(_ ->\n+                    separated(invokeOp.operands(), ($) -> $.comma().space(), (op) -> {\n+                        if (op instanceof Op.Result result) {\n+                            recurse(buildContext, result.op());\n@@ -577,12 +545,2 @@\n-                    }\n-                }\n-            } else {\n-                \/\/ General case\n-                funcName(invokeOp).paren(_ ->\n-                        separated(invokeOp.operands(), ($)->$.comma().space(), (op) -> {\n-                            if (op instanceof Op.Result result) {\n-                                recurse(buildContext, result.op());\n-                            }\n-                        })\n-                );\n-            }\n+                    })\n+            );\n@@ -637,2 +595,2 @@\n-                case JavaOp.LabeledOp _ ->false;\n-                case JavaOp.YieldOp _ ->false;\n+                case JavaOp.LabeledOp _ -> false;\n+                case JavaOp.YieldOp _ -> false;\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":48,"deletions":90,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -48,1 +49,1 @@\n-        public CoreOp.VarOp resolve(Value value) {\n+        public Op resolve(Value value) {\n@@ -52,0 +53,5 @@\n+\n+            if (value instanceof Op.Result result && result.op() instanceof HatMemoryOp hatMemoryOp) {\n+                return hatMemoryOp;\n+            }\n+\n@@ -67,1 +73,1 @@\n-        public CoreOp.VarOp resolve(Value value) {\n+        public Op resolve(Value value) {\n@@ -181,1 +187,0 @@\n-\n@@ -183,1 +188,1 @@\n-        public CoreOp.VarOp resolve(Value value) {\n+        public Op resolve(Value value) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatBarrierOp extends HatOP {\n+\n+    private static final String NAME = \"hat.sync.barrier\";\n+    public static final String INTRINSIC_NAME = \"barrier\";\n+\n+    public HatBarrierOp(List<Value> operands) {\n+        super(NAME, operands);\n+    }\n+\n+    public HatBarrierOp(HatBarrierOp hatBarrierOp, CopyContext copyContext) {\n+        super(hatBarrierOp, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatBarrierOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return JavaType.VOID;\n+    }\n+\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"invoke.\" + NAME, JavaOp.InvokeOp.InvokeKind.INSTANCE);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatBarrierOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatLocalVarOp extends HatMemoryOp {\n+\n+    public static final String INTRINSIC_NAME = \"createLocal\";\n+\n+    private final TypeElement typeElement;\n+    private final ClassType klassType;\n+    private final TypeElement invokeResultType;\n+\n+    public HatLocalVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType,  List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.klassType = javaType;\n+        this.invokeResultType = invokeResultType;\n+    }\n+\n+    public HatLocalVarOp(HatLocalVarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.resultType();\n+        this.klassType = op.klassType;\n+        this.invokeResultType = op.invokeResultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatLocalVarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hatSharedVarOp.\" + opName(), typeElement);\n+    }\n+\n+\n+    public String varName() {\n+        return opName();\n+    }\n+\n+    public ClassType classType() {\n+        return klassType;\n+    }\n+\n+    public TypeElement invokeType() {\n+        return invokeResultType;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalVarOp.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+\n+public abstract class HatMemoryOp extends HatOP {\n+\n+    public HatMemoryOp(String name, List<Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    protected HatMemoryOp(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+\n+    public String varName() {\n+        return opName();\n+    }\n+\n+    public abstract ClassType classType();\n+\n+    public abstract TypeElement invokeType();\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatMemoryOp.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HatOP extends Op {\n+\n+    public HatOP(String name, List<Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    protected HatOP(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatOP.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HatPrivateVarOp extends HatMemoryOp {\n+\n+    public static final String INTRINSIC_NAME = \"createPrivate\";\n+\n+    private final TypeElement typeElement;\n+    private final ClassType klassType;\n+    private final TypeElement invokeResultType;\n+\n+    public HatPrivateVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.klassType = javaType;\n+        this.invokeResultType = invokeResultType;\n+    }\n+\n+    public HatPrivateVarOp(HatPrivateVarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.resultType();\n+        this.klassType = op.klassType;\n+        this.invokeResultType = op.invokeResultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HatPrivateVarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hatPrivateVarOp.\" + opName(), typeElement);\n+    }\n+\n+\n+    @Override\n+    public String varName() {\n+        return opName();\n+    }\n+\n+    @Override\n+    public ClassType classType() {\n+        return klassType;\n+    }\n+\n+    @Override\n+    public TypeElement invokeType() {\n+        return invokeResultType;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatPrivateVarOp.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.dialect.HatMemoryOp;\n@@ -56,1 +57,0 @@\n-import java.util.function.Predicate;\n@@ -107,0 +107,3 @@\n+                    if (f != null) {\n+                        System.out.println(\"Analysing function? \" + f.funcName());\n+                    }\n@@ -119,0 +122,1 @@\n+            System.out.println(\"Processing Function? : \" + rf.r);\n@@ -174,2 +178,1 @@\n-\n-    public static JavaOp.InvokeOp getQuotableTargetInvokeOpWrapper( JavaOp.LambdaOp lambdaOp) {\n+    public static JavaOp.InvokeOp getQuotableTargetInvokeOpWrapper(JavaOp.LambdaOp lambdaOp) {\n@@ -225,0 +228,1 @@\n+                        || (op instanceof HatMemoryOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    private interface MySharedArray extends Buffer {\n+    private interface MyArray extends Buffer {\n@@ -61,1 +61,1 @@\n-        Schema<MySharedArray> schema = Schema.of(MySharedArray.class,\n+        Schema<MyArray> schema = Schema.of(MyArray.class,\n@@ -65,1 +65,1 @@\n-        static MySharedArray create(Accelerator accelerator) {\n+        static MyArray create(Accelerator accelerator) {\n@@ -69,1 +69,1 @@\n-        static MySharedArray createLocal() {\n+        static MyArray createLocal() {\n@@ -77,1 +77,1 @@\n-        MySharedArray mySharedArray = MySharedArray.createLocal();\n+        MyArray mySharedArray = MyArray.createLocal();\n@@ -97,1 +97,1 @@\n-        MySharedArray.schema.toText(System.out::print);\n+        MyArray.schema.toText(System.out::print);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalArray.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -308,0 +308,1 @@\n+                case \"2D\" -> Configuration._2D;\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-                \"oracle.code.hat.TestReductions\"\n+                \"oracle.code.hat.TestReductions\",\n+                \"oracle.code.hat.TestPrivate\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.Buffer;\n+import hat.buffer.F32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.Schema;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.RW;\n+\n+public class TestPrivate {\n+\n+    private interface PrivateArray extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+\n+        Schema<PrivateArray> schema = Schema.of(PrivateArray.class,\n+                myPrivateArray -> myPrivateArray\n+                        .array(\"array\", 1));\n+\n+        static PrivateArray create(Accelerator accelerator) {\n+            return schema.allocate(accelerator, 1);\n+        }\n+\n+        static PrivateArray createPrivate() {\n+            return create(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+    }\n+\n+    @CodeReflection\n+    private static void compute(@RO KernelContext kernelContext, @RW F32Array data) {\n+        PrivateArray privateArray = PrivateArray.createPrivate();\n+        int lix = kernelContext.lix;\n+        int blockId = kernelContext.bix;\n+        int blockSize = kernelContext.lsx;\n+        privateArray.array(0, lix);\n+        data.array(lix + (long) blockId * blockSize, privateArray.array(0));\n+    }\n+\n+    @CodeReflection\n+    private static void myCompute(@RO ComputeContext computeContext, @RW F32Array data) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32));\n+        computeContext.dispatchKernel(computeRange,\n+                kernelContext -> compute(kernelContext, data)\n+        );\n+    }\n+\n+    @HatTest\n+    public void testPrivate() {\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        F32Array data = F32Array.create(accelerator, 32);\n+        accelerator.compute(computeContext -> {\n+            TestPrivate.myCompute(computeContext, data);\n+        });\n+\n+        \/\/ Check result\n+        boolean isCorrect = true;\n+        int jIndex = 0;\n+        for (int i = 0; i < data.length(); i++) {\n+            if (data.array(i) != jIndex++) {\n+                IO.println(data.array(i) + \" != \" + jIndex);\n+                isCorrect = false;\n+                \/\/break;\n+            }\n+        }\n+        HatAsserts.assertTrue(isCorrect);\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestPrivate.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}