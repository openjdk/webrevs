{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.reflect.code.parser.impl.Tokens.Token;\n+import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n@@ -36,0 +38,1 @@\n+import java.util.stream.Collectors;\n@@ -88,2 +91,0 @@\n-        \/\/ Type\n-        Tokens.Token t = l.accept(Tokens.TokenKind.IDENTIFIER);\n@@ -91,5 +92,19 @@\n-        identifier.append(t.name());\n-        while (l.acceptIf(Tokens.TokenKind.DOT)) {\n-            identifier.append(Tokens.TokenKind.DOT.name);\n-            t = l.accept(Tokens.TokenKind.IDENTIFIER);\n-            identifier.append(t.name());\n+        if (l.token().kind == TokenKind.HASH) {\n+            \/\/ Quoted identifier\n+            l.accept(TokenKind.HASH);\n+            Token t = l.token();\n+            while (t.kind != TokenKind.LT) {\n+                identifier.append(t.kind == TokenKind.IDENTIFIER ? t.name() : t.kind.name);\n+                l.nextToken();\n+                t = l.token();\n+            }\n+        } else {\n+            \/\/ Qualified identifier\n+            Tokens.Token t = l.accept(TokenKind.IDENTIFIER,\n+                    TokenKind.PLUS, TokenKind.SUB);\n+            identifier.append(t.kind == TokenKind.IDENTIFIER ? t.name() : t.kind.name);\n+            while (l.acceptIf(Tokens.TokenKind.DOT)) {\n+                identifier.append(Tokens.TokenKind.DOT.name);\n+                t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+                identifier.append(t.name());\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n@@ -863,0 +864,5 @@\n+                    case '#':\n+                        next();\n+                        tk = TokenKind.HASH;\n+                        break loop;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/JavaBasedTokenizer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.code.parser.impl.Tokens.Token;\n+import java.util.Arrays;\n@@ -102,0 +104,15 @@\n+    default Tokens.Token accept(Tokens.TokenKind... tks) {\n+        Token t = token();\n+        for (Tokens.TokenKind tk : tks) {\n+            if (acceptIf(tk)) {\n+                return t;\n+            }\n+        }\n+        \/\/ @@@ Exception\n+        LineMap lineMap = getLineMap();\n+        int lineNumber = lineMap.getLineNumber(t.pos);\n+        int columnNumber = lineMap.getColumnNumber(t.pos);\n+        throw new IllegalArgumentException(\"Expected one of \" + Arrays.toString(tks) + \" but observed \" + t.kind +\n+                \" \" + lineNumber + \":\" + columnNumber);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Lexer.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+        HASH(\"#\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Tokens.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+    @Override\n+    public JavaType erasure() {\n+        return JavaType.array(componentType.erasure());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+    @Override\n+    public JavaType erasure() {\n+        return rawType();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n@@ -117,0 +118,23 @@\n+            if (identifier.equals(\"+\") || identifier.equals(\"-\")) {\n+                \/\/ wildcard type\n+                BoundKind kind = identifier.equals(\"+\") ?\n+                        BoundKind.EXTENDS : BoundKind.SUPER;\n+                return JavaType.wildcard(kind, typeArguments.get(0));\n+            } else if (identifier.contains(\"::\")) {\n+                \/\/ type-var\n+                if (typeArguments.size() != 1) {\n+                    throw new IllegalArgumentException(\"Bad type-variable bounds: \" + tree);\n+                }\n+                String[] parts = identifier.split(\"::\");\n+                if (parts.length == 2) {\n+                    \/\/ class type-var\n+                    return JavaType.typeVarRef(parts[1],\n+                            (JavaType)constructType(parseTypeDef(parts[0])),\n+                            typeArguments.get(0));\n+                } else {\n+                    \/\/ method type-var\n+                    return JavaType.typeVarRef(parts[2],\n+                            parseMethodRef(String.format(\"%s::%s\", parts[0], parts[1])),\n+                            typeArguments.get(0));\n+                }\n+            }\n@@ -144,0 +168,10 @@\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodRef parseMethodRef(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(desc);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static TypeDefinition parseTypeDef(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(desc);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n@@ -39,1 +40,2 @@\n-public sealed interface JavaType extends TypeElement permits ClassType, ArrayType, PrimitiveType {\n+public sealed interface JavaType extends TypeElement permits ClassType, ArrayType,\n+                                                             PrimitiveType, WildcardType, TypeVarRef {\n@@ -150,0 +152,5 @@\n+    \/**\n+     * {@return the erasure of this Java type, as per JLS 4.6}\n+     *\/\n+    JavaType erasure();\n+\n@@ -257,0 +264,40 @@\n+    \/**\n+     * Constructs an unbounded wildcard type.\n+     *\n+     * @return an unbounded wildcard type.\n+     *\/\n+    static WildcardType wildcard() {\n+        return new WildcardType(BoundKind.EXTENDS, JavaType.J_L_OBJECT);\n+    }\n+\n+    \/**\n+     * Constructs a bounded wildcard type of the given kind.\n+     *\n+     * @return a bounded wildcard type.\n+     *\/\n+    static WildcardType wildcard(BoundKind kind, JavaType bound) {\n+        return new WildcardType(kind, bound);\n+    }\n+\n+    \/**\n+     * Constructs a reference to a class type-variable.\n+     *\n+     * @param bound the type-variable bound.\n+     * @param owner the class where the type-variable is declared.\n+     * @return a type-variable reference.\n+     *\/\n+    static TypeVarRef typeVarRef(String name, JavaType owner, JavaType bound) {\n+        return new TypeVarRef(name, owner, bound);\n+    }\n+\n+    \/**\n+     * Constructs a reference to a method type-variable.\n+     *\n+     * @param bound the type-variable bound.\n+     * @param owner the method where the type-variable is declared.\n+     * @return a type-variable reference.\n+     *\/\n+    static TypeVarRef typeVarRef(String name, MethodRef owner, JavaType bound) {\n+        return new TypeVarRef(name, owner, bound);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -67,0 +67,5 @@\n+    @Override\n+    public JavaType erasure() {\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+\/**\n+ * A type-variable reference.\n+ *\/\n+public final class TypeVarRef implements JavaType {\n+\n+    final String name;\n+    final Object owner;\n+    final JavaType bound;\n+\n+    TypeVarRef(String name, Object owner, JavaType bound) {\n+        this.name = name;\n+        this.owner = owner;\n+        this.bound = bound;\n+    }\n+\n+    \/**\n+     * {@return the type-variable name}\n+     *\/\n+    public String name() {\n+        return name;\n+    }\n+\n+    \/**\n+     * {@return the type-variable bound}\n+     *\/\n+    public JavaType bound() {\n+        return bound;\n+    }\n+\n+    \/**\n+     * {@return the method owner of this type-variable}\n+     *\/\n+    public Optional<MethodRef> methodOwner() {\n+        return owner instanceof MethodRef methodRef ?\n+                Optional.of(methodRef) : Optional.empty();\n+    }\n+\n+    \/**\n+     * {@return the class owner of this type-variable}\n+     *\/\n+    public Optional<JavaType> classOwner() {\n+        return owner instanceof JavaType typeRef ?\n+                Optional.of(typeRef) : Optional.empty();\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        return bound.erasure();\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(String.format(\"#%s::%s\", owner, name),\n+                List.of(bound.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof TypeVarRef that &&\n+                name.equals(that.name) &&\n+                bound.equals(that.bound);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return name.hashCode();\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        throw new UnsupportedOperationException(\"Type var\");\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        throw new UnsupportedOperationException(\"Type var\");\n+    }\n+\n+    @Override\n+    public boolean isClass() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPrimitive() {\n+        return false;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * A wildcard type.\n+ *\/\n+public final class WildcardType implements JavaType {\n+\n+    final BoundKind kind;\n+    final JavaType boundType;\n+\n+    WildcardType(BoundKind kind, JavaType boundType) {\n+        this.kind = kind;\n+        this.boundType = boundType;\n+    }\n+\n+    \/**\n+     * {@return the wildcard type's bound type}\n+     *\/\n+    public JavaType boundType() {\n+        return boundType;\n+    }\n+\n+    \/**\n+     * {@return the wildcard type's bound kind}\n+     *\/\n+    public BoundKind boundKind() {\n+        return kind;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        String prefix = kind == BoundKind.EXTENDS ? \"+\" : \"-\";\n+        return new TypeDefinition(prefix, List.of(boundType.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof WildcardType that &&\n+                kind.equals(that.kind) &&\n+                boundType.equals(that.boundType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(boundType, kind);\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        throw new UnsupportedOperationException(\"Wildcard type\");\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        throw new UnsupportedOperationException(\"Wildcard type\");\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        throw new UnsupportedOperationException(\"Wildcard type\");\n+    }\n+\n+    @Override\n+    public boolean isClass() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPrimitive() {\n+        return false;\n+    }\n+\n+    public enum BoundKind {\n+        EXTENDS,\n+        SUPER\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/WildcardType.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -201,0 +201,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -207,0 +217,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -210,0 +262,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -248,5 +302,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -307,0 +368,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -310,0 +372,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -324,1 +387,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -333,1 +396,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -351,1 +414,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -355,1 +418,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -365,1 +428,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -388,2 +451,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -417,1 +480,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":89,"deletions":13,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.tools.javac.code.Type.IntersectionClassType;\n@@ -41,0 +42,1 @@\n+import com.sun.tools.javac.code.Type.UnionClassType;\n@@ -86,0 +88,1 @@\n+import jdk.internal.java.lang.reflect.code.type.WildcardType.BoundKind;\n@@ -96,0 +99,1 @@\n+import static com.sun.tools.javac.code.TypeTag.METHOD;\n@@ -490,6 +494,1 @@\n-            Type quotedOpType = kind == FunctionalExpressionKind.QUOTABLE\n-                    ? syms.lambdaOpType\n-                    : syms.closureOpType;\n-            Type quotedReturnType = new ClassType(null,\n-                    com.sun.tools.javac.util.List.of(quotedOpType), syms.quotedType.tsym);\n-            MethodType mtype = new MethodType(nil, quotedReturnType, nil, syms.methodClass);\n+            MethodType mtype = new MethodType(nil, syms.quotedType, nil, syms.methodClass);\n@@ -1949,5 +1948,0 @@\n-                \/\/ @@@ Support union types, how to express that plus lub?\n-                if (catcher.param.type.isUnion()) {\n-                    throw unsupported(tree);\n-                }\n-\n@@ -2183,4 +2177,0 @@\n-        JavaType symbolToDesc(Symbol s) {\n-            return typeToTypeElement(s.type);\n-        }\n-\n@@ -2207,0 +2197,11 @@\n+                case WILDCARD -> {\n+                    Type.WildcardType wt = (Type.WildcardType)t;\n+                    yield wt.isUnbound() ?\n+                            JavaType.wildcard() :\n+                            JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n+                }\n+                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound())) :\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedDesc(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound()));\n@@ -2208,0 +2209,1 @@\n+                    Assert.check(!t.isIntersection() && !t.isUnion());\n@@ -2239,1 +2241,1 @@\n-            return symbolToFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n+            return symbolToErasedFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n@@ -2242,1 +2244,2 @@\n-        FieldRef symbolToFieldRef(Symbol s) {\n+        FieldRef symbolToErasedFieldRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n@@ -2244,8 +2247,1 @@\n-                    typeToTypeElement(s.owner.type),\n-                    s.name.toString(),\n-                    typeToTypeElement(s.type));\n-        }\n-\n-        MethodRef symbolToMethodRef(Symbol s) {\n-            return MethodRef.method(\n-                    typeToTypeElement(s.owner.type),\n+                    typeToTypeElement(s.owner.erasure(types)),\n@@ -2253,2 +2249,1 @@\n-                    typeToTypeElement(s.type.getReturnType()),\n-                    s.type.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+                    typeToTypeElement(erasedType));\n@@ -2318,6 +2313,2 @@\n-            return switch (t.getTag()) {\n-                case METHOD -> new MethodType(t.getParameterTypes().map(this::normalizeType),\n-                        normalizeType(t.getReturnType()), t.getThrownTypes().map(this::normalizeType),\n-                        syms.methodClass);\n-                default -> checkDenotableInTypeDesc(t) ? t : types.erasure(t);\n-            };\n+            Assert.check(!t.hasTag(METHOD));\n+            return types.upward(t, false, types.captures(t));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":24,"deletions":33,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-        Assert.assertEquals(JavaType.type(Quoted.class, CoreOps.ClosureOp.class), fop.invokableType().returnType());\n+        Assert.assertEquals(JavaType.type(Quoted.class), fop.invokableType().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestErasure\n+ *\/\n+\n+import static org.testng.Assert.*;\n+import org.testng.annotations.*;\n+\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Test\n+public class TestErasure {\n+\n+    @Test(dataProvider = \"typesAndErasures\")\n+    public void testErasure(String testName, TypeAndErasure typeAndErasure) {\n+        assertEquals(typeAndErasure.type.erasure(), typeAndErasure.erasure);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] typesAndErasures() {\n+        List<TypeAndErasure> typeAndErasures = new ArrayList<>();\n+        typeAndErasures.addAll(primitives());\n+        typeAndErasures.addAll(references());\n+        typeAndErasures.addAll(genericReferences());\n+        typeAndErasures.addAll(arrays());\n+        typeAndErasures.addAll(typeVars());\n+        return typeAndErasures.stream()\n+                .map(t -> new Object[] { t.type.toString(), t })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    static List<TypeAndErasure> primitives() {\n+        return List.of(\n+                new TypeAndErasure(JavaType.BOOLEAN, JavaType.BOOLEAN),\n+                new TypeAndErasure(JavaType.CHAR, JavaType.CHAR),\n+                new TypeAndErasure(JavaType.BYTE, JavaType.BYTE),\n+                new TypeAndErasure(JavaType.SHORT, JavaType.SHORT),\n+                new TypeAndErasure(JavaType.INT, JavaType.INT),\n+                new TypeAndErasure(JavaType.FLOAT, JavaType.FLOAT),\n+                new TypeAndErasure(JavaType.LONG, JavaType.LONG),\n+                new TypeAndErasure(JavaType.DOUBLE, JavaType.DOUBLE),\n+                new TypeAndErasure(JavaType.VOID, JavaType.VOID));\n+    }\n+\n+    static List<TypeAndErasure> references() {\n+        return List.of(\n+                new TypeAndErasure(JavaType.J_L_STRING, JavaType.J_L_STRING),\n+                new TypeAndErasure(JavaType.J_L_OBJECT, JavaType.J_L_OBJECT));\n+    }\n+\n+    static List<TypeAndErasure> genericReferences() {\n+        JavaType LIST = JavaType.type(List.class);\n+        List<TypeAndErasure> genericTypes = new ArrayList<>();\n+        BoundKind[] kinds = new BoundKind[] { null, BoundKind.EXTENDS, BoundKind.SUPER };\n+        for (BoundKind kind : kinds) {\n+            for (TypeAndErasure t : references()) {\n+                JavaType arg = t.type;\n+                if (kind != null) {\n+                    arg = JavaType.wildcard(kind, arg);\n+                }\n+                genericTypes.add(new TypeAndErasure(JavaType.type(LIST, arg), LIST));\n+            }\n+            for (TypeAndErasure t : primitives()) {\n+                JavaType arg = JavaType.array(t.type);\n+                if (kind != null) {\n+                    arg = JavaType.wildcard(kind, arg);\n+                }\n+                genericTypes.add(new TypeAndErasure(JavaType.type(LIST, arg), LIST));\n+            }\n+        }\n+        return genericTypes;\n+    }\n+\n+    static List<TypeAndErasure> arrays() {\n+        List<TypeAndErasure> arrayTypes = new ArrayList<>();\n+        for (int dims = 1 ; dims <= 3 ; dims++) {\n+            for (TypeAndErasure t : primitives()) {\n+                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+            for (TypeAndErasure t : references()) {\n+                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+            for (TypeAndErasure t : genericReferences()) {\n+                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+        }\n+        return arrayTypes;\n+    }\n+\n+    static List<TypeAndErasure> typeVars() {\n+        List<TypeAndErasure> typeVars = new ArrayList<>();\n+        for (int dims = 1 ; dims <= 3 ; dims++) {\n+            for (TypeAndErasure t : references()) {\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+            for (TypeAndErasure t : genericReferences()) {\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+            for (TypeAndErasure t : arrays()) {\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+        }\n+        return typeVars;\n+    }\n+\n+    record TypeAndErasure(JavaType type, JavaType erasure) { }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestErasure.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -156,1 +156,1 @@\n-        Assert.assertEquals(type(Quoted.class, LambdaOp.class), fop.invokableType().returnType());\n+        Assert.assertEquals(type(Quoted.class), fop.invokableType().returnType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n@@ -210,1 +210,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n@@ -222,1 +222,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n@@ -234,1 +234,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n@@ -246,1 +246,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n@@ -258,1 +258,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n@@ -270,1 +270,1 @@\n-                %2 : Var<java.lang.Class> = var %1 @\"s\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConstantsTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-                %0 : java.lang.Number = constant @null;\n-                %1 : java.lang.Number = invoke %0 @\"DenotableTypesTest::m1(java.lang.Number)java.lang.Number\";\n-                return;\n+                  %0 : java.lang.Number = constant @null;\n+                  %1 : java.lang.Number = invoke %0 @\"DenotableTypesTest::m1(java.lang.Number)java.lang.Number\";\n+                  return;\n@@ -52,6 +52,6 @@\n-                %0 : int = constant @\"1\";\n-                %1 : java.lang.Integer = invoke %0 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n-                %2 : double = constant @\"3.0\";\n-                %3 : java.lang.Double = invoke %2 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n-                %4 : java.util.List = invoke %1 %3 @\"java.util.List::of(java.lang.Object, java.lang.Object)java.util.List\";\n-                return;\n+                  %0 : int = constant @\"1\";\n+                  %1 : java.lang.Integer = invoke %0 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                  %2 : double = constant @\"3.0\";\n+                  %3 : java.lang.Double = invoke %2 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                  %4 : java.util.List<+<java.lang.Number>> = invoke %1 %3 @\"java.util.List::of(java.lang.Object, java.lang.Object)java.util.List\";\n+                  return;\n@@ -88,6 +88,6 @@\n-                %0 : java.lang.Object = constant @null;\n-                %1 : DenotableTypesTest$C = cast %0 @\"DenotableTypesTest$C\";\n-                %2 : java.lang.Object = constant @null;\n-                %3 : DenotableTypesTest$D = cast %2 @\"DenotableTypesTest$D\";\n-                %4 : DenotableTypesTest$A = invoke %1 %3 @\"DenotableTypesTest::pick(java.lang.Object, java.lang.Object)java.lang.Object\";\n-                return;\n+                  %0 : java.lang.Object = constant @null;\n+                  %1 : DenotableTypesTest$C = cast %0 @\"DenotableTypesTest$C\";\n+                  %2 : java.lang.Object = constant @null;\n+                  %3 : DenotableTypesTest$D = cast %2 @\"DenotableTypesTest$D\";\n+                  %4 : DenotableTypesTest$A = invoke %1 %3 @\"DenotableTypesTest::pick(java.lang.Object, java.lang.Object)java.lang.Object\";\n+                  return;\n@@ -103,3 +103,3 @@\n-                  %0 : java.util.List = constant @null;\n-                  %1 : Var<java.util.List> = var %0 @\"l\";\n-                  %2 : java.util.List = var.load %1;\n+                  %0 : java.util.List<+<java.lang.Number>> = constant @null;\n+                  %1 : Var<java.util.List<+<java.lang.Number>>> = var %0 @\"l\";\n+                  %2 : java.util.List<+<java.lang.Number>> = var.load %1;\n@@ -119,3 +119,3 @@\n-                  %0 : java.util.List = constant @null;\n-                  %1 : Var<java.util.List> = var %0 @\"l\";\n-                  %2 : java.util.List = var.load %1;\n+                  %0 : java.util.List<-<java.lang.Number>> = constant @null;\n+                  %1 : Var<java.util.List<-<java.lang.Number>>> = var %0 @\"l\";\n+                  %2 : java.util.List<-<java.lang.Number>> = var.load %1;\n@@ -137,6 +137,6 @@\n-                %0 : java.lang.Object = constant @null;\n-                %1 : Var<java.lang.Object> = var %0 @\"x\";\n-                %2 : java.lang.Object = var.load %1;\n-                %3 : java.lang.Runnable = cast %2 @\"java.lang.Runnable\";\n-                invoke %3 @\"DenotableTypesTest::consume(java.lang.Runnable)void\";\n-                return;\n+                  %0 : #DenotableTypesTest::test7()void::X<java.lang.Object> = constant @null;\n+                  %1 : Var<#DenotableTypesTest::test7()void::X<java.lang.Object>> = var %0 @\"x\";\n+                  %2 : #DenotableTypesTest::test7()void::X<java.lang.Object> = var.load %1;\n+                  %3 : java.lang.Runnable = cast %2 @\"java.lang.Runnable\";\n+                  invoke %3 @\"DenotableTypesTest::consume(java.lang.Runnable)void\";\n+                  return;\n@@ -156,3 +156,3 @@\n-            func @\"test8\" (%0 : java.util.List)void -> {\n-                  %1 : Var<java.util.List> = var %0 @\"list\";\n-                  %2 : java.util.List = var.load %1;\n+            func @\"test8\" (%0 : java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>>)void -> {\n+                  %1 : Var<java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>>> = var %0 @\"list\";\n+                  %2 : java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>> = var.load %1;\n@@ -160,2 +160,2 @@\n-                  %4 : DenotableTypesTest$Adder = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n-                  %5 : java.util.List = var.load %1;\n+                  %4 : DenotableTypesTest$Adder<java.lang.Integer> = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  %5 : java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>> = var.load %1;\n@@ -163,1 +163,1 @@\n-                  %7 : DenotableTypesTest$Adder = invoke %5 %6 @\"java.util.List::get(int)java.lang.Object\";\n+                  %7 : DenotableTypesTest$Adder<java.lang.Integer> = invoke %5 %6 @\"java.util.List::get(int)java.lang.Object\";\n@@ -178,3 +178,3 @@\n-            func @\"test9\" (%0 : java.util.List)void -> {\n-                  %1 : Var<java.util.List> = var %0 @\"list\";\n-                  %2 : java.util.List = var.load %1;\n+            func @\"test9\" (%0 : java.util.List<+<DenotableTypesTest$Box<java.lang.Integer>>>)void -> {\n+                  %1 : Var<java.util.List<+<DenotableTypesTest$Box<java.lang.Integer>>>> = var %0 @\"list\";\n+                  %2 : java.util.List<+<DenotableTypesTest$Box<java.lang.Integer>>> = var.load %1;\n@@ -182,1 +182,1 @@\n-                  %4 : DenotableTypesTest$Box = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  %4 : DenotableTypesTest$Box<java.lang.Integer> = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n@@ -191,0 +191,40 @@\n+\n+    interface E {\n+        void m();\n+    }\n+\n+    static class XA extends Exception implements E {\n+        public void m() { }\n+    }\n+\n+    static class XB extends Exception implements E {\n+        public void m() { }\n+    }\n+\n+    static void g() throws XA, XB { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" ()void -> {\n+                  java.try\n+                      ()void -> {\n+                          invoke @\"DenotableTypesTest::g()void\";\n+                          yield;\n+                      }\n+                      (%0 : java.lang.Exception)void -> {\n+                          %1 : Var<java.lang.Exception> = var %0 @\"x\";\n+                          %2 : java.lang.Exception = var.load %1;\n+                          %3 : DenotableTypesTest$E = cast %2 @\"DenotableTypesTest$E\";\n+                          invoke %3 @\"DenotableTypesTest$E::m()void\";\n+                          yield;\n+                      };\n+                  return;\n+            };\n+            \"\"\")\n+    static void test10() {\n+        try {\n+            g();\n+        } catch (XA | XB x) {\n+            x.m();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":77,"deletions":37,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -650,8 +650,8 @@\n-                  %0 : java.lang.String = constant @\"abc\";\n-                  %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"func<FieldAccessTest$Box, java.lang.Object>\";\n-                  %2 : Var<FieldAccessTest$Box<java.lang.String>> = var %1 @\"b\";\n-                  %3 : FieldAccessTest$Box<java.lang.String> = var.load %2;\n-                  %4 : java.lang.String = field.load %3 @\"FieldAccessTest$Box::v()java.lang.Object\";\n-                  %5 : Var<java.lang.String> = var %4 @\"s\";\n-                  return;\n-              };\n+                    %0 : java.lang.String = constant @\"abc\";\n+                    %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"func<FieldAccessTest$Box, java.lang.Object>\";\n+                    %2 : Var<FieldAccessTest$Box<java.lang.String>> = var %1 @\"b\";\n+                    %3 : FieldAccessTest$Box<java.lang.String> = var.load %2;\n+                    %4 : java.lang.String = field.load %3 @\"FieldAccessTest$Box::v()java.lang.Object\";\n+                    %5 : Var<java.lang.String> = var %4 @\"s\";\n+                    return;\n+            };\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,3 +52,3 @@\n-              func @\"test1\" (%0 : IntersectionTypeTest$A)void -> {\n-                  %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n-                  %2 : IntersectionTypeTest$A = var.load %1;\n+            func @\"test1\" (%0 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -56,1 +56,1 @@\n-                  %3 : IntersectionTypeTest$A = var.load %1;\n+                  %3 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -59,1 +59,1 @@\n-                  %5 : IntersectionTypeTest$A = var.load %1;\n+                  %5 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -63,1 +63,1 @@\n-              };\n+            };\n@@ -73,12 +73,12 @@\n-            func @\"test2\" (%0 : IntersectionTypeTest$A)void -> {\n-                %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n-                %2 : IntersectionTypeTest$A = var.load %1;\n-                %3 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n-                %4 : Var<java.lang.Object> = var %3 @\"oA\";\n-                %5 : IntersectionTypeTest$A = var.load %1;\n-                %6 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n-                %7 : Var<java.lang.Object> = var %6 @\"oB\";\n-                %8 : IntersectionTypeTest$A = var.load %1;\n-                %9 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n-                %10 : Var<java.lang.Object> = var %9 @\"oC\";\n-                return;\n+            func @\"test2\" (%0 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %3 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n+                  %4 : Var<java.lang.Object> = var %3 @\"oA\";\n+                  %5 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %6 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n+                  %7 : Var<java.lang.Object> = var %6 @\"oB\";\n+                  %8 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %9 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n+                  %10 : Var<java.lang.Object> = var %9 @\"oC\";\n+                  return;\n@@ -95,29 +95,29 @@\n-            func @\"test3\" (%0 : IntersectionTypeTest$A)void -> {\n-                %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n-                %2 : IntersectionTypeTest$A = var.load %1;\n-                %3 : Var<IntersectionTypeTest$A> = var %2 @\"rec$\";\n-                %4 : java.lang.Runnable = lambda ()void -> {\n-                    %5 : IntersectionTypeTest$A = var.load %3;\n-                    invoke %5 @\"IntersectionTypeTest$A::m_A()void\";\n-                    return;\n-                };\n-                %6 : Var<java.lang.Runnable> = var %4 @\"rA\";\n-                %7 : IntersectionTypeTest$A = var.load %1;\n-                %8 : IntersectionTypeTest$B = cast %7 @\"IntersectionTypeTest$B\";\n-                %9 : Var<IntersectionTypeTest$B> = var %8 @\"rec$\";\n-                %10 : java.lang.Runnable = lambda ()void -> {\n-                    %11 : IntersectionTypeTest$B = var.load %9;\n-                    invoke %11 @\"IntersectionTypeTest$B::m_B()void\";\n-                    return;\n-                };\n-                %12 : Var<java.lang.Runnable> = var %10 @\"rB\";\n-                %13 : IntersectionTypeTest$A = var.load %1;\n-                %14 : IntersectionTypeTest$C = cast %13 @\"IntersectionTypeTest$C\";\n-                %15 : Var<IntersectionTypeTest$C> = var %14 @\"rec$\";\n-                %16 : java.lang.Runnable = lambda ()void -> {\n-                    %17 : IntersectionTypeTest$C = var.load %15;\n-                    invoke %17 @\"IntersectionTypeTest$C::m_C()void\";\n-                    return;\n-                };\n-                %18 : Var<java.lang.Runnable> = var %16 @\"rC\";\n-                return;\n+            func @\"test3\" (%0 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %3 : Var<IntersectionTypeTest$A> = var %2 @\"rec$\";\n+                  %4 : java.lang.Runnable = lambda ()void -> {\n+                      %5 : IntersectionTypeTest$A = var.load %3;\n+                      invoke %5 @\"IntersectionTypeTest$A::m_A()void\";\n+                      return;\n+                  };\n+                  %6 : Var<java.lang.Runnable> = var %4 @\"rA\";\n+                  %7 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %8 : IntersectionTypeTest$B = cast %7 @\"IntersectionTypeTest$B\";\n+                  %9 : Var<IntersectionTypeTest$B> = var %8 @\"rec$\";\n+                  %10 : java.lang.Runnable = lambda ()void -> {\n+                      %11 : IntersectionTypeTest$B = var.load %9;\n+                      invoke %11 @\"IntersectionTypeTest$B::m_B()void\";\n+                      return;\n+                  };\n+                  %12 : Var<java.lang.Runnable> = var %10 @\"rB\";\n+                  %13 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %14 : IntersectionTypeTest$C = cast %13 @\"IntersectionTypeTest$C\";\n+                  %15 : Var<IntersectionTypeTest$C> = var %14 @\"rec$\";\n+                  %16 : java.lang.Runnable = lambda ()void -> {\n+                      %17 : IntersectionTypeTest$C = var.load %15;\n+                      invoke %17 @\"IntersectionTypeTest$C::m_C()void\";\n+                      return;\n+                  };\n+                  %18 : Var<java.lang.Runnable> = var %16 @\"rC\";\n+                  return;\n@@ -138,12 +138,12 @@\n-              func @\"test4\" (%0 : IntersectionTypeTest$A)void -> {\n-                  %1 : Var<IntersectionTypeTest$A> = var %0 @\"x\";\n-                  %2 : IntersectionTypeTest$A = var.load %1;\n-                  invoke %2 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n-                  %3 : IntersectionTypeTest$A = var.load %1;\n-                  %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n-                  invoke %4 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n-                  %5 : IntersectionTypeTest$A = var.load %1;\n-                  %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n-                  invoke %6 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n-                  return;\n-              };\n+            func @\"test4\" (%0 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                %1 : Var<#IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                %2 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                invoke %2 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                %3 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                invoke %4 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                %5 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                invoke %6 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                return;\n+            };\n@@ -181,17 +181,17 @@\n-              func @\"test5\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n-                  %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n-                  %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n-                  %4 : IntersectionTypeTest$E1 = var.load %2;\n-                  %5 : IntersectionTypeTest$E2 = var.load %3;\n-                  %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n-                  %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n-                  %8 : IntersectionTypeTest$A = var.load %7;\n-                  invoke %8 @\"IntersectionTypeTest$A::m_A()void\";\n-                  %9 : IntersectionTypeTest$A = var.load %7;\n-                  %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n-                  invoke %10 @\"IntersectionTypeTest$B::m_B()void\";\n-                  %11 : IntersectionTypeTest$A = var.load %7;\n-                  %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n-                  invoke %12 @\"IntersectionTypeTest$C::m_C()void\";\n-                  return;\n-              };\n+            func @\"test5\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                invoke %8 @\"IntersectionTypeTest$A::m_A()void\";\n+                %9 : IntersectionTypeTest$A = var.load %7;\n+                %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                invoke %10 @\"IntersectionTypeTest$B::m_B()void\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                invoke %12 @\"IntersectionTypeTest$C::m_C()void\";\n+                return;\n+            };\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":76,"deletions":76,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-                  %2 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor\";\n@@ -63,1 +63,1 @@\n-                  %2 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException>\";\n+                  %2 : java.lang.StringTemplate$Processor<java.lang.StringTemplate, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::RAW()java.lang.StringTemplate$Processor\";\n@@ -84,1 +84,1 @@\n-                  %6 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %6 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor\";\n@@ -105,1 +105,1 @@\n-                  %18 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n+                  %18 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor\";\n@@ -130,3 +130,3 @@\n-                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException>\";\n-                  %1 : Var<java.lang.StringTemplate$Processor> = var %0 @\"X\";\n-                  %2 : java.lang.StringTemplate$Processor = var.load %1;\n+                  %0 : java.lang.StringTemplate$Processor<java.lang.String, java.lang.RuntimeException> = field.load @\"java.lang.StringTemplate::STR()java.lang.StringTemplate$Processor\";\n+                  %1 : Var<java.lang.StringTemplate$Processor<+<java.lang.Object>, java.lang.RuntimeException>> = var %0 @\"X\";\n+                  %2 : java.lang.StringTemplate$Processor<+<java.lang.Object>, java.lang.RuntimeException> = var.load %1;\n","filename":"test\/langtools\/tools\/javac\/reflect\/StringTemplateTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}