{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.code.parser.impl.Tokens.Token;\n@@ -37,0 +38,1 @@\n+import java.util.stream.Collectors;\n@@ -89,0 +91,5 @@\n+        boolean isTypeVar = false;\n+        if (l.token().kind == TokenKind.HASH) {\n+            l.accept(TokenKind.HASH);\n+            isTypeVar = true;\n+        }\n@@ -91,2 +98,1 @@\n-                TokenKind.PLUS, TokenKind.SUB,\n-                TokenKind.COLCOL);\n+                TokenKind.PLUS, TokenKind.SUB);\n@@ -94,5 +100,0 @@\n-        if (t.kind == TokenKind.COLCOL) {\n-            \/\/ type var, add '::' and parse next ident\n-            identifier.append(t.kind.name);\n-            t = l.accept(TokenKind.IDENTIFIER);\n-        }\n@@ -106,0 +107,20 @@\n+        if (l.token().kind == TokenKind.COLCOL && isTypeVar) {\n+            \/\/ type-variable\n+            l.accept(TokenKind.COLCOL);\n+            identifier.append(TokenKind.COLCOL.name);\n+            t = l.accept(TokenKind.IDENTIFIER); \/\/ type-var or method name\n+            identifier.append(t.name());\n+            if (l.token().kind == TokenKind.LPAREN) {\n+                FunctionType functionType = parseMethodType(l);\n+                \/\/ we need to serialize the function type back as part of the tvar identifier\n+                identifier.append(functionType.parameterTypes().stream()\n+                                .map(TypeElement::toString)\n+                                .collect(Collectors.joining(\",\", \"(\", \")\")));\n+                identifier.append(functionType.returnType().toString());\n+                l.accept(TokenKind.COLCOL);\n+                identifier.append(TokenKind.COLCOL.name);\n+                t = l.accept(TokenKind.IDENTIFIER); \/\/ type-var name\n+                identifier.append(t.name());\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n@@ -863,0 +864,5 @@\n+                    case '#':\n+                        next();\n+                        tk = TokenKind.HASH;\n+                        break loop;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/JavaBasedTokenizer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+        HASH(\"#\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Tokens.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-            } else if (identifier.startsWith(\"::\")) {\n+            } else if (identifier.contains(\"::\")) {\n@@ -128,1 +128,12 @@\n-                return JavaType.typeVarRef(identifier.substring(2), typeArguments.get(0));\n+                String[] parts = identifier.split(\"::\");\n+                if (parts.length == 2) {\n+                    \/\/ class type-var\n+                    return JavaType.typeVarRef(parts[1],\n+                            (JavaType)constructType(parseTypeDef(parts[0])),\n+                            typeArguments.get(0));\n+                } else {\n+                    \/\/ method type-var\n+                    return JavaType.typeVarRef(parts[2],\n+                            parseMethodRef(String.format(\"%s::%s\", parts[0], parts[1])),\n+                            typeArguments.get(0));\n+                }\n@@ -157,0 +168,10 @@\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodRef parseMethodRef(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(desc);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static TypeDefinition parseTypeDef(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(desc);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-     * Constructs a type-variable reference.\n+     * Constructs a reference to a class type-variable.\n@@ -286,0 +286,1 @@\n+     * @param owner the class where the type-variable is declared.\n@@ -288,2 +289,13 @@\n-    static TypeVarRef typeVarRef(String name, JavaType bound) {\n-        return new TypeVarRef(name, bound);\n+    static TypeVarRef typeVarRef(String name, JavaType owner, JavaType bound) {\n+        return new TypeVarRef(name, owner, bound);\n+    }\n+\n+    \/**\n+     * Constructs a reference to a method type-variable.\n+     *\n+     * @param bound the type-variable bound.\n+     * @param owner the method where the type-variable is declared.\n+     * @return a type-variable reference.\n+     *\/\n+    static TypeVarRef typeVarRef(String name, MethodRef owner, JavaType bound) {\n+        return new TypeVarRef(name, owner, bound);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Optional;\n@@ -35,1 +36,0 @@\n-    \/\/ @@@: how do we encode tvar owner?\n@@ -37,0 +37,1 @@\n+    final Object owner;\n@@ -39,1 +40,1 @@\n-    TypeVarRef(String name, JavaType bound) {\n+    TypeVarRef(String name, Object owner, JavaType bound) {\n@@ -41,0 +42,1 @@\n+        this.owner = owner;\n@@ -58,0 +60,16 @@\n+    \/**\n+     * {@return the method owner of this type-variable}\n+     *\/\n+    public Optional<MethodRef> methodOwner() {\n+        return owner instanceof MethodRef methodRef ?\n+                Optional.of(methodRef) : Optional.empty();\n+    }\n+\n+    \/**\n+     * {@return the class owner of this type-variable}\n+     *\/\n+    public Optional<JavaType> classOwner() {\n+        return owner instanceof JavaType typeRef ?\n+                Optional.of(typeRef) : Optional.empty();\n+    }\n+\n@@ -65,1 +83,1 @@\n-        return new TypeDefinition(\"::\" + name,\n+        return new TypeDefinition(String.format(\"#%s::%s\", owner, name),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2177,4 +2177,0 @@\n-        JavaType symbolToDesc(Symbol s) {\n-            return typeToTypeElement(s.type);\n-        }\n-\n@@ -2207,3 +2203,5 @@\n-                case TYPEVAR -> JavaType.typeVarRef(t.tsym.name.toString(),\n-                        typeToTypeElement(t.getUpperBound()));\n-\n+                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound())) :\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedDesc(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", t.type), t.erasure));\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n@@ -123,1 +123,1 @@\n-                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", t.type), t.erasure));\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n@@ -126,1 +126,1 @@\n-                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", t.type), t.erasure));\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestErasure.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,3 +137,3 @@\n-                  %0 : ::X<java.lang.Object> = constant @null;\n-                  %1 : Var<::X<java.lang.Object>> = var %0 @\"x\";\n-                  %2 : ::X<java.lang.Object> = var.load %1;\n+                  %0 : #DenotableTypesTest::test7()void::X<java.lang.Object> = constant @null;\n+                  %1 : Var<#DenotableTypesTest::test7()void::X<java.lang.Object>> = var %0 @\"x\";\n+                  %2 : #DenotableTypesTest::test7()void::X<java.lang.Object> = var.load %1;\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -52,12 +52,12 @@\n-              func @\"test1\" (%0 : ::X<IntersectionTypeTest$A>)void -> {\n-                    %1 : Var<::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                    %2 : ::X<IntersectionTypeTest$A> = var.load %1;\n-                    invoke %2 @\"IntersectionTypeTest$A::m_A()void\";\n-                    %3 : ::X<IntersectionTypeTest$A> = var.load %1;\n-                    %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n-                    invoke %4 @\"IntersectionTypeTest$B::m_B()void\";\n-                    %5 : ::X<IntersectionTypeTest$A> = var.load %1;\n-                    %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n-                    invoke %6 @\"IntersectionTypeTest$C::m_C()void\";\n-                    return;\n-              };\n+            func @\"test1\" (%0 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  invoke %2 @\"IntersectionTypeTest$A::m_A()void\";\n+                  %3 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                  invoke %4 @\"IntersectionTypeTest$B::m_B()void\";\n+                  %5 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                  invoke %6 @\"IntersectionTypeTest$C::m_C()void\";\n+                  return;\n+            };  \n@@ -73,3 +73,3 @@\n-            func @\"test2\" (%0 : ::X<IntersectionTypeTest$A>)void -> {\n-                  %1 : Var<::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                  %2 : ::X<IntersectionTypeTest$A> = var.load %1;\n+            func @\"test2\" (%0 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -78,1 +78,1 @@\n-                  %5 : ::X<IntersectionTypeTest$A> = var.load %1;\n+                  %5 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -81,1 +81,1 @@\n-                  %8 : ::X<IntersectionTypeTest$A> = var.load %1;\n+                  %8 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -95,3 +95,3 @@\n-            func @\"test3\" (%0 : ::X<IntersectionTypeTest$A>)void -> {\n-                  %1 : Var<::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                  %2 : ::X<IntersectionTypeTest$A> = var.load %1;\n+            func @\"test3\" (%0 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -105,1 +105,1 @@\n-                  %7 : ::X<IntersectionTypeTest$A> = var.load %1;\n+                  %7 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -114,1 +114,1 @@\n-                  %13 : ::X<IntersectionTypeTest$A> = var.load %1;\n+                  %13 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n@@ -138,12 +138,12 @@\n-              func @\"test4\" (%0 : ::X<IntersectionTypeTest$A>)void -> {\n-                    %1 : Var<::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                    %2 : ::X<IntersectionTypeTest$A> = var.load %1;\n-                    invoke %2 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n-                    %3 : ::X<IntersectionTypeTest$A> = var.load %1;\n-                    %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n-                    invoke %4 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n-                    %5 : ::X<IntersectionTypeTest$A> = var.load %1;\n-                    %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n-                    invoke %6 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n-                    return;\n-              };\n+            func @\"test4\" (%0 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                %1 : Var<#IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                %2 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                invoke %2 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                %3 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                invoke %4 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                %5 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                invoke %6 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                return;\n+            };\n@@ -181,17 +181,17 @@\n-              func @\"test5\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n-                    %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n-                    %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n-                    %4 : IntersectionTypeTest$E1 = var.load %2;\n-                    %5 : IntersectionTypeTest$E2 = var.load %3;\n-                    %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n-                    %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n-                    %8 : IntersectionTypeTest$A = var.load %7;\n-                    invoke %8 @\"IntersectionTypeTest$A::m_A()void\";\n-                    %9 : IntersectionTypeTest$A = var.load %7;\n-                    %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n-                    invoke %10 @\"IntersectionTypeTest$B::m_B()void\";\n-                    %11 : IntersectionTypeTest$A = var.load %7;\n-                    %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n-                    invoke %12 @\"IntersectionTypeTest$C::m_C()void\";\n-                    return;\n-              };\n+            func @\"test5\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                invoke %8 @\"IntersectionTypeTest$A::m_A()void\";\n+                %9 : IntersectionTypeTest$A = var.load %7;\n+                %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                invoke %10 @\"IntersectionTypeTest$B::m_B()void\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                invoke %12 @\"IntersectionTypeTest$C::m_C()void\";\n+                return;\n+            };\n@@ -209,16 +209,16 @@\n-                  %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n-                  %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n-                  %4 : IntersectionTypeTest$E1 = var.load %2;\n-                  %5 : IntersectionTypeTest$E2 = var.load %3;\n-                  %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n-                  %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n-                  %8 : IntersectionTypeTest$A = var.load %7;\n-                  %9 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n-                  %10 : Var<java.lang.Object> = var %9 @\"oA\";\n-                  %11 : IntersectionTypeTest$A = var.load %7;\n-                  %12 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n-                  %13 : Var<java.lang.Object> = var %12 @\"oB\";\n-                  %14 : IntersectionTypeTest$A = var.load %7;\n-                  %15 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n-                  %16 : Var<java.lang.Object> = var %15 @\"oC\";\n-                  return;\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                %9 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n+                %10 : Var<java.lang.Object> = var %9 @\"oA\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n+                %13 : Var<java.lang.Object> = var %12 @\"oB\";\n+                %14 : IntersectionTypeTest$A = var.load %7;\n+                %15 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n+                %16 : Var<java.lang.Object> = var %15 @\"oC\";\n+                return;\n@@ -237,33 +237,33 @@\n-                  %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n-                  %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n-                  %4 : IntersectionTypeTest$E1 = var.load %2;\n-                  %5 : IntersectionTypeTest$E2 = var.load %3;\n-                  %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n-                  %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n-                  %8 : IntersectionTypeTest$A = var.load %7;\n-                  %9 : Var<IntersectionTypeTest$A> = var %8 @\"rec$\";\n-                  %10 : java.lang.Runnable = lambda ()void -> {\n-                      %11 : IntersectionTypeTest$A = var.load %9;\n-                      invoke %11 @\"IntersectionTypeTest$A::m_A()void\";\n-                      return;\n-                  };\n-                  %12 : Var<java.lang.Runnable> = var %10 @\"rA\";\n-                  %13 : IntersectionTypeTest$A = var.load %7;\n-                  %14 : IntersectionTypeTest$B = cast %13 @\"IntersectionTypeTest$B\";\n-                  %15 : Var<IntersectionTypeTest$B> = var %14 @\"rec$\";\n-                  %16 : java.lang.Runnable = lambda ()void -> {\n-                      %17 : IntersectionTypeTest$B = var.load %15;\n-                      invoke %17 @\"IntersectionTypeTest$B::m_B()void\";\n-                      return;\n-                  };\n-                  %18 : Var<java.lang.Runnable> = var %16 @\"rB\";\n-                  %19 : IntersectionTypeTest$A = var.load %7;\n-                  %20 : IntersectionTypeTest$C = cast %19 @\"IntersectionTypeTest$C\";\n-                  %21 : Var<IntersectionTypeTest$C> = var %20 @\"rec$\";\n-                  %22 : java.lang.Runnable = lambda ()void -> {\n-                      %23 : IntersectionTypeTest$C = var.load %21;\n-                      invoke %23 @\"IntersectionTypeTest$C::m_C()void\";\n-                      return;\n-                  };\n-                  %24 : Var<java.lang.Runnable> = var %22 @\"rC\";\n-                  return;\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                %9 : Var<IntersectionTypeTest$A> = var %8 @\"rec$\";\n+                %10 : java.lang.Runnable = lambda ()void -> {\n+                    %11 : IntersectionTypeTest$A = var.load %9;\n+                    invoke %11 @\"IntersectionTypeTest$A::m_A()void\";\n+                    return;\n+                };\n+                %12 : Var<java.lang.Runnable> = var %10 @\"rA\";\n+                %13 : IntersectionTypeTest$A = var.load %7;\n+                %14 : IntersectionTypeTest$B = cast %13 @\"IntersectionTypeTest$B\";\n+                %15 : Var<IntersectionTypeTest$B> = var %14 @\"rec$\";\n+                %16 : java.lang.Runnable = lambda ()void -> {\n+                    %17 : IntersectionTypeTest$B = var.load %15;\n+                    invoke %17 @\"IntersectionTypeTest$B::m_B()void\";\n+                    return;\n+                };\n+                %18 : Var<java.lang.Runnable> = var %16 @\"rB\";\n+                %19 : IntersectionTypeTest$A = var.load %7;\n+                %20 : IntersectionTypeTest$C = cast %19 @\"IntersectionTypeTest$C\";\n+                %21 : Var<IntersectionTypeTest$C> = var %20 @\"rec$\";\n+                %22 : java.lang.Runnable = lambda ()void -> {\n+                    %23 : IntersectionTypeTest$C = var.load %21;\n+                    invoke %23 @\"IntersectionTypeTest$C::m_C()void\";\n+                    return;\n+                };\n+                %24 : Var<java.lang.Runnable> = var %22 @\"rC\";\n+                return;\n@@ -282,15 +282,15 @@\n-                  %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n-                  %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n-                  %4 : IntersectionTypeTest$E1 = var.load %2;\n-                  %5 : IntersectionTypeTest$E2 = var.load %3;\n-                  %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n-                  %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n-                  %8 : IntersectionTypeTest$A = var.load %7;\n-                  invoke %8 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n-                  %9 : IntersectionTypeTest$A = var.load %7;\n-                  %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n-                  invoke %10 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n-                  %11 : IntersectionTypeTest$A = var.load %7;\n-                  %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n-                  invoke %12 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n-                  return;\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                invoke %8 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                %9 : IntersectionTypeTest$A = var.load %7;\n+                %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                invoke %10 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                invoke %12 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                return;\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":115,"deletions":115,"binary":false,"changes":230,"status":"modified"}]}