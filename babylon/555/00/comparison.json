{"files":[{"patch":"@@ -395,2 +395,2 @@\n-    String createC99(KernelCallGraph kernelCallGraph, NDRange ndRange,  Object... args){\n-        return createCode(kernelCallGraph, new CudaHATKernelBuilder(ndRange), args);\n+    String createC99(KernelCallGraph kernelCallGraph, Object... args){\n+        return createCode(kernelCallGraph, new CudaHATKernelBuilder(), args);\n@@ -402,1 +402,1 @@\n-    String createPTX(KernelCallGraph kernelCallGraph, NDRange ndRange, Object... args){\n+    String createPTX(KernelCallGraph kernelCallGraph,  Object... args){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-    public CudaHATKernelBuilder(NDRange ndRange) {\n-        super(ndRange);\n-    }\n@@ -43,3 +40,1 @@\n-        return\n-               \/\/ .hashDefine(\"NDRANGE_CUDA\") \/\/ I dont think we need this\n-               hashDefine(\"__global\");  \/\/ nor this\n+        return hashDefine(\"__global\");  \/\/ nor this\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            String code = createC99(kernelCallGraph,  ndRange, args);\n+            String code = createC99(kernelCallGraph,  args);\n@@ -70,2 +70,2 @@\n-    String createC99(KernelCallGraph kernelCallGraph,  NDRange ndRange, Object[] args){\n-        return createCode(kernelCallGraph, new OpenCLHATKernelBuilder(ndRange), args);\n+    String createC99(KernelCallGraph kernelCallGraph,  Object[] args){\n+        return createCode(kernelCallGraph, new OpenCLHATKernelBuilder(), args);\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-    public OpenCLHATKernelBuilder(NDRange ndRange) {\n-        super(ndRange);\n-    }\n@@ -43,1 +40,0 @@\n-        hashDefine(\"NDRANGE_OPENCL\");\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -230,0 +231,3 @@\n+        ScopedCodeBuilderContext buildContext =\n+                new ScopedCodeBuilderContext(kernelCallGraph.entrypoint.callGraph.computeContext.accelerator.lookup,\n+                        kernelCallGraph.entrypoint.funcOp());\n@@ -235,1 +239,4 @@\n-                    .forEach((_, funcOp) -> builder.nl().kernelMethod(kernelCallGraph.computeContext.accelerator.lookup, funcOp).nl());\n+                    .forEach((_, funcOp) -> builder\n+                            .nl()\n+                            .kernelMethod(buildContext,funcOp)\n+                            .nl());\n@@ -239,1 +246,5 @@\n-                    .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n+                    .forEach(kernelReachableResolvedMethod ->\n+                            builder\n+                                    .nl()\n+                                    .kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp())\n+                                    .nl());\n@@ -242,1 +253,1 @@\n-        builder.nl().kernelEntrypoint(kernelCallGraph.entrypoint, args).nl();\n+        builder.nl().kernelEntrypoint(buildContext, args).nl();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(ndRange), args);\n+            String code = createCode(kernelCallGraph, new OpenCLHatKernelBuilder(), args);\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,4 +36,0 @@\n-    public OpenCLHatKernelBuilder(NDRange ndRange) {\n-        super(ndRange);\n-    }\n-\n@@ -42,6 +38,1 @@\n-        hashDefine(\"NDRANGE_OPENCL\");  \/\/ dont' thnk we need this\n-       \/\/ pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_global_int32_base_atomics\", \":\", \"enable\");\n-        \/\/pragma(\"OPENCL\", \"EXTENSION\", \"cl_khr_local_int32_base_atomics\", \":\", \"enable\");\n-        pragmas();\n-        hashIfndef(\"NULL\", _ -> hashDefine(\"NULL\", \"0\"));\n-        return self();\n+        return pragmas().hashIfndef(\"NULL\", _ -> hashDefine(\"NULL\", \"0\"));\n@@ -83,1 +74,0 @@\n-\n@@ -116,3 +106,0 @@\n-\n-\n-\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -92,1 +93,2 @@\n-\n+        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelCallGraph.computeContext.accelerator.lookup\n+                ,kernelCallGraph.entrypoint.funcOp());\n@@ -95,1 +97,1 @@\n-                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n+                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp()).nl());\n@@ -97,1 +99,1 @@\n-        builder.nl().kernelEntrypoint(kernelCallGraph.entrypoint, args).nl();\n+        builder.nl().kernelEntrypoint(buildContext, args).nl();\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-       \/\/ moduleOpWrapper = OpWrapper.wrap(computeContext.accelerator.lookup, moduleOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-     public T compute(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(lookup,funcOp);\n-        computeDeclaration(funcOp.resultType(), funcOp.funcName());\n+     public T compute(ScopedCodeBuilderContext buildContext) {\n+\n+        computeDeclaration(buildContext.funcOp.resultType(), buildContext.funcOp.funcName());\n@@ -47,5 +47,1 @@\n-                        , (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n-        );\n-\n-        braceNlIndented(_ -> OpTk.rootOpStream(funcOp).forEach(root ->\n-                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root)).nl()\n+                        , param -> declareParam(buildContext, param)\n@@ -55,0 +51,3 @@\n+        braceNlIndented(_ -> separated(OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()), (_)->nl(),\n+                statement ->statement(buildContext,statement).nl()));\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATComputeBuilder.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-\n-import hat.KernelContext;\n@@ -31,2 +29,0 @@\n-import hat.callgraph.KernelCallGraph;\n-import hat.callgraph.KernelEntrypoint;\n@@ -38,0 +34,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp;\n@@ -39,0 +36,1 @@\n+import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -40,1 +38,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -44,7 +41,4 @@\n-\n-    protected final NDRange ndRange;\n-\n-    public C99HATKernelBuilder(NDRange ndRange) {\n-        this.ndRange = ndRange;\n-    }\n-\n+   \/\/ protected final NDRange ndRange; \/\/ Should be in the context ?\n+   \/\/ public C99HATKernelBuilder(NDRange ndRange) {\n+       \/\/ this.ndRange = ndRange;\n+   \/\/ }\n@@ -53,1 +47,0 @@\n-\n@@ -55,16 +48,0 @@\n-                \/*\n-                .unsignedCharTypeDefs(\"u8_t\")\n-                .shortTypeDefs(\"s16_t\")\n-                .unsignedShortTypeDefs(\"u16_t\")\n-                .unsignedIntTypeDefs(\"u32_t\")\n-                .intTypeDefs(\"s32_t\")\n-                .floatTypeDefs(\"f32_t\")\n-                .longTypeDefs(\"s64_t\")\n-                .unsignedLongTypeDefs(\"u64_t\")\n-                *\/\n-                \/\/ Another generic way of declaring the kernelContext is as follows:\n-                \/\/ \/\/ It is reasonable to use hat.codebuilders.HATCodeBuilderWithContext.typedef()\n-                \/\/ \/\/ But note that we pass null as first arg which is normally expected to be a bound schema\n-                \/\/ \/\/ Clearly this will fail if we ever make KernelContext a variant array.  But that seems unlikely.\n-                \/\/ .typedef(null, hat.buffer.KernelContext.schema.rootIfaceType);\n-\n@@ -72,7 +49,0 @@\n-\n-                    intDeclaration(\"x\").semicolonNl();\n-                    intDeclaration(\"maxX\").semicolonNl();\n-                    intDeclaration(\"y\").semicolonNl();\n-                    intDeclaration(\"maxY\").semicolon().nl();\n-                    intDeclaration(\"z\").semicolonNl();\n-                    intDeclaration(\"maxZ\").semicolon().nl();\n@@ -80,22 +50,0 @@\n-\n-                    \/\/ Because of order of serialization, we need to put\n-                    \/\/ these new members at the end.\n-                    intDeclaration(\"gix\").semicolonNl();\n-                    intDeclaration(\"giy\").semicolonNl();\n-                    intDeclaration(\"giz\").semicolonNl();\n-\n-                    intDeclaration(\"gsx\").semicolonNl();\n-                    intDeclaration(\"gsy\").semicolonNl();\n-                    intDeclaration(\"gsz\").semicolonNl();\n-\n-                    intDeclaration(\"lix\").semicolonNl();\n-                    intDeclaration(\"liy\").semicolonNl();\n-                    intDeclaration(\"liz\").semicolonNl();\n-\n-                    intDeclaration(\"lsx\").semicolonNl();\n-                    intDeclaration(\"lsy\").semicolonNl();\n-                    intDeclaration(\"lsz\").semicolonNl();\n-\n-                    intDeclaration(\"bix\").semicolonNl();\n-                    intDeclaration(\"biy\").semicolonNl();\n-                    intDeclaration(\"biz\").semicolonNl();\n@@ -104,0 +52,21 @@\n+    @Override\n+    public T fieldLoadOp(ScopedCodeBuilderContext buildContext, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n+            switch (fieldLoadOp.fieldDescriptor().name()){\n+                case \"x\",\"gix\"->globalId(0);\n+                case \"y\",\"giy\"->globalId(1);\n+                case \"z\",\"giz\"->globalId(3);\n+                case \"maxX\",\"gsx\"->globalSize(0);\n+                case \"maxY\",\"gsy\"->globalSize(1);\n+                case \"maxZ\",\"gsz\"->globalSize(2);\n+                case \"lix\"->localId(0);\n+                case \"liy\"->localId(1);\n+                case \"liz\"->localId(2);\n+                case \"lsx\"->localSize(0);\n+                case \"lsy\"->localSize(1);\n+                case \"lsz\"->localSize(2);\n+                case \"bix\"->blockId(0);\n+                case \"biy\"->blockId(1);\n+                case \"biz\"->blockId(2);\n+                default ->  throw new IllegalStateException(\"handle ? kc.\"+fieldLoadOp.fieldDescriptor().name());\n+            }\n@@ -105,0 +74,8 @@\n+        } else if (fieldLoadOp.operands().isEmpty() && fieldLoadOp.result().type() instanceof PrimitiveType) {\n+            Object value = OpTk.getStaticFinalPrimitiveValue(buildContext.lookup,fieldLoadOp);\n+            literal(value.toString());\n+        } else {\n+            throw new IllegalStateException(\"What is this field load ?\" + fieldLoadOp);\n+        }\n+        return self();\n+    }\n@@ -116,42 +93,0 @@\n-    public final T scope() {\n-        identifier(\"KernelContext_t\").space().identifier(\"mine\").semicolon().nl();\n-        identifier(\"KernelContext_t\").asterisk().space().identifier(\"kc\").equals().ampersand().identifier(\"mine\").semicolon().nl();\n-        identifier(\"kc\").rarrow().identifier(\"x\").equals().globalId(0).semicolon().nl();\n-        identifier(\"kc\").rarrow().identifier(\"maxX\").equals().identifier(\"global_kc\").rarrow().identifier(\"maxX\").semicolon().nl();\n-\n-        \/\/\n-        identifier(\"kc\").rarrow().identifier(\"gix\").equals().globalId(0).semicolon().nl();\n-        identifier(\"kc\").rarrow().identifier(\"gsx\").equals().globalSize(0).semicolon().nl();\n-        identifier(\"kc\").rarrow().identifier(\"lix\").equals().localId(0).semicolon().nl();\n-        identifier(\"kc\").rarrow().identifier(\"lsx\").equals().localSize(0).semicolon().nl();\n-        identifier(\"kc\").rarrow().identifier(\"bix\").equals().blockId(0).semicolon().nl();\n-\n-\n-        if (ndRange.kid.getDimensions() > 1) { \/\/ do we need to guard this?\n-            identifier(\"kc\").rarrow().identifier(\"y\").equals().globalId(1).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"maxY\").equals().identifier(\"global_kc\").rarrow().identifier(\"maxY\").semicolon().nl();\n-\n-            identifier(\"kc\").rarrow().identifier(\"giy\").equals().globalId(1).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"gsy\").equals().globalSize(1).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"liy\").equals().localId(1).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"lsy\").equals().localSize(1).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"biy\").equals().blockId(1).semicolon().nl();\n-        }\n-\n-        if (ndRange.kid.getDimensions() > 2) { \/\/ do we need to guard this\n-            identifier(\"kc\").rarrow().identifier(\"z\").equals().globalId(2).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"maxZ\").equals().identifier(\"global_kc\").rarrow().identifier(\"maxZ\").semicolon().nl();\n-\n-            identifier(\"kc\").rarrow().identifier(\"giz\").equals().globalId(2).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"gsz\").equals().globalSize(1).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"liz\").equals().localId(2).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"lsz\").equals().localSize(2).semicolon().nl();\n-            identifier(\"kc\").rarrow().identifier(\"biz\").equals().blockId(2).semicolon().nl();\n-        }\n-        return self();\n-    }\n-\n-    public abstract T globalPtrPrefix();\n-\n-    public abstract T localPtrPrefix();\n-\n@@ -161,10 +96,3 @@\n-            \/\/  .isIfaceUsingLookup(buildContext.lookup,javaType) && javaType instanceof ClassType classType) {\n-            globalPtrPrefix().space();\n-            String name = classType.toClassName();\n-            int dotIdx = name.lastIndexOf('.');\n-            int dollarIdx = name.lastIndexOf('$');\n-            int idx = Math.max(dotIdx, dollarIdx);\n-            if (idx > 0) {\n-                name = name.substring(idx + 1);\n-            }\n-            suffix_t(name).asterisk();\n+            globalPtrPrefix().space().suffix_t(classType).asterisk();\n+        }else if (javaType instanceof ClassType classType && classType.toClassName().equals(\"hat.KernelContext\")){\n+            globalPtrPrefix().space().suffix_t(\"KernelContext\").asterisk();\n@@ -172,10 +100,1 @@\n-            \/\/ In the case we call a new invoke method and pass the kernel context around, t\n-            \/\/ then we need to do the mapping between the Java type and its low level interface\n-            \/\/ TODO: Check if there is a better way to obtain the type information using\n-            \/\/ the code reflection APIs and avoid string comparisons.\n-            String kernelContextFullClassName = KernelContext.class.getCanonicalName();\n-            if (javaType.toString().equals(kernelContextFullClassName)) {\n-                typeName(\"KernelContext_t *\");\n-            } else {\n-                typeName(javaType.toString());\n-            }\n+            typeName(javaType.toString());\n@@ -185,38 +104,14 @@\n-\n-    public T kernelMethod(KernelCallGraph.KernelReachableResolvedMethodCall kernelReachableResolvedMethodCall) {\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelReachableResolvedMethodCall.callGraph.computeContext.accelerator.lookup\n-                ,kernelReachableResolvedMethodCall.funcOp());\n-        buildContext.funcScope(buildContext.funcOp, () -> {\n-            nl();\n-            functionDeclaration(buildContext,(JavaType) buildContext.funcOp.body().yieldType(), buildContext.funcOp);\n-\n-            var list = buildContext.paramTable.list();\n-            parenNlIndented(_ ->\n-                    separated(list,(_)->comma().nl(), info ->\n-                            type(buildContext,info.javaType).space().varName(info.varOp))\n-            );\n-            braceNlIndented(_ ->\n-                separated(OpTk.rootOpStream(buildContext.funcOp),(_)->nl(),root ->\n-                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n-                )\n-            );\n-        });\n-        return self();\n-    }\n-\n-    public T kernelMethod(MethodHandles.Lookup lookup,CoreOp.FuncOp funcOp) {\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(lookup,funcOp);\n-        buildContext.funcScope(buildContext.funcOp, () -> {\n-            nl();\n-            functionDeclaration(buildContext,(JavaType) buildContext.funcOp.body().yieldType(),\n-                    buildContext.funcOp);\n-\n-            var list = buildContext.paramTable.list();\n-            parenNlIndented(_ ->\n-                    separated(list,(_)->comma().nl(), info ->\n-                            type(buildContext,info.javaType).space().varName(info.varOp))\n-            );\n-\n-            braceNlIndented(_ ->\n-                separated(OpTk.rootOpStream(buildContext.funcOp),(_)->nl(),root->\n-                       recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+    public T kernelMethod(ScopedCodeBuilderContext buildContext,CoreOp.FuncOp funcOp) {\n+          buildContext.funcScope(funcOp, () -> {\n+              nl();\n+              functionDeclaration(buildContext,(JavaType) funcOp.body().yieldType(), funcOp);\n+              var paramTable = new FuncOpParams(funcOp);\n+              parenNlIndented(_ ->\n+                    separated(paramTable.list(),(_)->comma().nl(), param ->\n+                        declareParam(buildContext,param)\n+                    )\n+              );\n+\n+              braceNlIndented(_ ->\n+                separated(OpTk.statements(funcOp.bodies().getFirst().entryBlock()),(_)->nl(),\n+                        statement->statement(buildContext,statement)\n@@ -224,2 +119,2 @@\n-            );\n-        });\n+              );\n+          });\n@@ -229,1 +124,2 @@\n-    public T kernelEntrypoint(KernelEntrypoint kernelEntrypoint,Object... args) {\n+    public T kernelEntrypoint(ScopedCodeBuilderContext buildContext,\n+                              Object... args) {\n@@ -231,1 +127,0 @@\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(kernelEntrypoint.callGraph.computeContext.accelerator.lookup,kernelEntrypoint.funcOp());\n@@ -236,1 +131,1 @@\n-            for (int arg = 1; arg < args.length; arg++) {\n+            for (int arg = 0; arg < args.length; arg++) {\n@@ -238,2 +133,1 @@\n-                    FuncOpParams.Info info = list.get(arg);\n-                    info.setClass(args[arg].getClass());\n+                    list.get(arg).setClass(args[arg].getClass());  \/\/ de we have to do this?\n@@ -242,7 +136,1 @@\n-            parenNlIndented(_ -> {\n-                        globalPtrPrefix().space().suffix_t(\"KernelContext\").space().asterisk().identifier(\"global_kc\");\n-                        list.stream().skip(1).forEach(info ->\n-                                comma().space().type(buildContext,info.javaType).space().varName(info.varOp)\n-                        );\n-                    }\n-            );\n+            parenNlIndented(_ -> separated(list.stream(),(_)->comma().nl(),param -> declareParam(buildContext,param)));\n@@ -251,3 +139,2 @@\n-                scope();\n-                separated(OpTk.rootOpStream(buildContext.funcOp), (_)->nl(), root ->\n-                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                 separated(OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()), (_)->nl(),\n+                        statement ->statement(buildContext,statement)\n@@ -260,0 +147,12 @@\n+    public T privateDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n+        return suffix_t(localArrayDeclaration.classType()).space().varName(localArrayDeclaration.varOp()).nl();\n+    }\n+\n+    public T localDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n+        return localPtrPrefix().space() \/\/ we should be able to compose-call to privateDeclaration?\n+                .suffix_t(localArrayDeclaration.classType()).space().varName(localArrayDeclaration.varOp());\n+    }\n+\n+    public abstract T globalPtrPrefix();\n+\n+    public abstract T localPtrPrefix();\n@@ -278,3 +177,0 @@\n-    final  public T privateDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n-        return suffix_t(localArrayDeclaration.ifaceStruct().name()).space().varName(localArrayDeclaration.varOp()).nl();\n-    }\n@@ -282,4 +178,0 @@\n-    final public T localDeclaration(HATCodeBuilderWithContext.LocalArrayDeclaration localArrayDeclaration) {\n-        return localPtrPrefix().space() \/\/ we should be able to compose-call to privateDeclaration?\n-                .suffix_t(localArrayDeclaration.ifaceStruct().name()).space().varName(localArrayDeclaration.varOp());\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":74,"deletions":182,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.optools.OpTk;\n@@ -28,0 +29,1 @@\n+import jdk.incubator.code.Op;\n@@ -43,8 +45,0 @@\n-    public T semicolonIf(boolean c) {\n-        if (c) {\n-            return semicolon();\n-        } else {\n-            return self();\n-        }\n-    }\n-\n@@ -55,23 +49,0 @@\n-    public T commaIf(boolean c) {\n-        if (c) {\n-            return comma();\n-        } else {\n-            return self();\n-        }\n-    }\n-\n-    public T commaSpaceIf(boolean c) {\n-        if (c) {\n-            return comma().space();\n-        } else {\n-            return self();\n-        }\n-    }\n-\n-    public T nlIf(boolean c) {\n-        if (c) {\n-            return nl();\n-        } else {\n-            return self();\n-        }\n-    }\n@@ -155,1 +126,0 @@\n-\n@@ -165,1 +135,0 @@\n-\n@@ -170,1 +139,0 @@\n-\n@@ -183,1 +151,1 @@\n-    public T nullKeyword() {\n+    public T nullConst() {\n@@ -445,35 +413,0 @@\n-    public T u08_t() {\n-        return typeName(\"u08_t\");\n-    }\n-\n-    public T s08_t() {\n-        return typeName(\"s08_t\");\n-    }\n-\n-    public T s32_t() {\n-        return typeName(\"s32_t\");\n-    }\n-\n-    public T s16_t() {\n-        return typeName(\"s16_t\");\n-    }\n-\n-    public T z8_t() {\n-        return typeName(\"z8_t\");\n-    }\n-\n-    public T u32_t() {\n-        return typeName(\"u32_t\");\n-    }\n-\n-    public T u16_t() {\n-        return typeName(\"u16_t\");\n-    }\n-\n-    public T f32_t() {\n-        return typeName(\"f32_t\");\n-    }\n-\n-    public T f64_t() {\n-        return typeName(\"f64_t\");\n-    }\n@@ -533,1 +466,1 @@\n-    public final T intZero() {\n+    public final T intConstZero() {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/CodeBuilder.java","additions":4,"deletions":71,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import hat.optools.FuncOpParams;\n@@ -54,8 +55,1 @@\n-            String name = classType.toClassName();\n-            int dotIdx = name.lastIndexOf('.');\n-            int dollarIdx = name.lastIndexOf('$');\n-            int idx = Math.max(dotIdx, dollarIdx);\n-            if (idx > 0) {\n-                name = name.substring(idx + 1);\n-            }\n-            suffix_t(name).asterisk();\n+            suffix_t(classType).asterisk();\n@@ -84,13 +78,2 @@\n-    public record IfaceStruct(ClassType classType){\n-       public  String name(){\n-            String name = classType.toClassName();\n-            int dotIdx = name.lastIndexOf('.');\n-            int dollarIdx = name.lastIndexOf('$');\n-            int idx = Math.max(dotIdx, dollarIdx);\n-            if (idx > 0) {\n-                name = name.substring(idx + 1);\n-            }\n-            return name;\n-        }\n-    }\n-    public record LocalArrayDeclaration(IfaceStruct ifaceStruct, CoreOp.VarOp varOp) {}\n+\n+    public record LocalArrayDeclaration(ClassType classType, CoreOp.VarOp varOp) {}\n@@ -105,1 +88,1 @@\n-        localArrayDeclarations.push(new LocalArrayDeclaration(new IfaceStruct(classType), varOp));\n+        localArrayDeclarations.push(new LocalArrayDeclaration(classType, varOp));\n@@ -196,1 +179,1 @@\n-            nullKeyword();\n+            nullConst();\n@@ -292,2 +275,2 @@\n-                                separated(OpTk.rootsExcludingVarFuncDeclarationsAndYields(ifOp.bodies().get(idx).entryBlock()),(_)->nl(),root->\n-                                       recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                                separated(OpTk.statements(ifOp.bodies().get(idx).entryBlock()),(_)->nl(), root->\n+                                        statement(buildContext,root)\n@@ -325,2 +308,2 @@\n-                separated(OpTk.loopRootOpStream(whileOp),(_)->nl(),root->\n-                        recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                separated(OpTk.statements(whileOp),(_)->nl(), statement->statement(buildContext,statement)\n+                       \/\/ recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -340,1 +323,1 @@\n-                    separated(OpTk.rootsExcludingVarFuncDeclarationsAndYields(OpTk.mutateBlock(forOp)), (_)->commaSpace(),\n+                    separated(OpTk.statements(OpTk.mutateBlock(forOp)), (_)->commaSpace(),\n@@ -344,2 +327,2 @@\n-                        separated(OpTk.loopRootOpStream(forOp), (_)->nl(),\n-                                root-> recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n+                        separated(OpTk.statements(forOp), (_)->nl(),statement ->statement(buildContext,statement)\n+                              \/\/  root-> recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root))\n@@ -449,1 +432,1 @@\n-                if (OpTk.funcName(invokeOp).equals(\"create\")) { \/\/ TODO:  only on iface buffers\n+                if (OpTk.funcName(invokeOp).equals(\"create\")) {\n@@ -480,1 +463,1 @@\n-                } else if (OpTk.funcName(invokeOp).equals(\"createLocal\")) { \/\/ TODO:  only on kernel iface buffers\n+                } else if (OpTk.funcName(invokeOp).equals(\"createLocal\")) {\n@@ -647,0 +630,31 @@\n+\n+    public T statement(ScopedCodeBuilderContext buildContext,Op op) {\n+        recurse(buildContext, op);\n+        if (switch (op){\n+                case JavaOp.ForOp _ -> false;\n+                case JavaOp.WhileOp _ -> false;\n+                case JavaOp.IfOp _ -> false;\n+                case JavaOp.LabeledOp _ ->false;\n+                case JavaOp.YieldOp _ ->false;\n+                case CoreOp.TupleOp _ ->false;\n+                default -> true;\n+            }\n+        ){\n+            semicolon();\n+        }\n+        return self();\n+    }\n+\n+    public T suffix_t(ClassType type){\n+        String name = type.toClassName();\n+        int dotIdx = name.lastIndexOf('.');\n+        int dollarIdx = name.lastIndexOf('$');\n+        int idx = Math.max(dotIdx, dollarIdx);\n+        if (idx > 0) {\n+            name = name.substring(idx + 1);\n+        }\n+        return suffix_t(name);\n+    }\n+    public T declareParam(ScopedCodeBuilderContext buildContext, FuncOpParams.Info param){\n+        return   type(buildContext,(JavaType) param.parameter.type()).space().varName(param.varOp);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":46,"deletions":32,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import java.util.LinkedHashMap;\n@@ -57,1 +56,0 @@\n-import java.util.Set;\n@@ -59,1 +57,0 @@\n-import java.util.stream.Collectors;\n@@ -88,2 +85,2 @@\n-    public static Stream<Op> loopRootOpStream(Op.Loop op) {\n-        var list = new ArrayList<>(rootsExcludingVarFuncDeclarationsAndYields( op.loopBody().entryBlock()).toList());\n+    public static Stream<Op> statements(Op.Loop op) {\n+        var list = new ArrayList<>(statements( op.loopBody().entryBlock()).toList());\n@@ -220,11 +217,3 @@\n-    public static Stream<Op> rootOpStream( CoreOp.FuncOp op) {\n-        return rootsExcludingVarFuncDeclarationsAndYields(op.bodies().getFirst().entryBlock());\n-    }\n-\n-\n-    static Predicate<Op> rootFilter = op->\n-            (   (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n-              || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n-            )\n-            && !(op instanceof CoreOp.VarOp varOp && paramVar(varOp) != null)\n-            && !(op instanceof CoreOp.YieldOp);\n+   \/\/ public static Stream<Op> statements(CoreOp.FuncOp op) {\n+     \/\/   return statements(op.bodies().getFirst().entryBlock());\n+   \/\/ }\n@@ -232,2 +221,7 @@\n-    static public Stream<Op> rootsExcludingVarFuncDeclarationsAndYields(Block block) {\n-        return block.ops().stream().filter(rootFilter);\n+    static public Stream<Op> statements(Block block) {\n+        return block.ops().stream().filter(op->\n+                (   (op instanceof CoreOp.VarAccessOp.VarStoreOp && op.operands().get(1).uses().size() < 2)\n+                        || (op instanceof CoreOp.VarOp || op.result().uses().isEmpty())\n+                )\n+                        && !(op instanceof CoreOp.VarOp varOp && paramVar(varOp) != null)\n+                        && !(op instanceof CoreOp.YieldOp));\n@@ -468,12 +462,0 @@\n-    public static boolean isStructural(Op op){\n-        return switch (op){\n-            case JavaOp.ForOp _ -> true;\n-            case JavaOp.WhileOp _ -> true;\n-            case JavaOp.IfOp _ -> true;\n-            case JavaOp.LabeledOp _ ->true;\n-            case JavaOp.YieldOp _ ->true;\n-            case CoreOp.TupleOp _ ->true;\n-            default -> false;\n-        };\n-    }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":12,"deletions":30,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -36,2 +35,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n@@ -96,12 +93,10 @@\n-    public T compute(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-        ScopedCodeBuilderContext buildContext = new ScopedCodeBuilderContext(lookup,funcOp);\n-        typeName(funcOp.resultType().toString()).space().funcName(funcOp);\n-        parenNlIndented(_ ->\n-                separated(buildContext.paramTable.list(),(_)->commaSpace(), (info) -> type(buildContext,(JavaType) info.parameter.type()).space().varName(info.varOp))\n-        );\n-        braceNlIndented(_ ->\n-                OpTk.rootOpStream(funcOp)\n-                        .forEach(root ->\n-                                recurse(buildContext, root).semicolonIf(!OpTk.isStructural(root)).nl()\n-                        )\n-        );\n+\n+    public T createJava(ScopedCodeBuilderContext buildContext) {\n+        buildContext.funcScope(buildContext.funcOp, () -> {\n+            typeName(buildContext.funcOp.resultType().toString()).space().funcName(buildContext.funcOp);\n+            parenNlIndented(_ -> separated(buildContext.paramTable.list(), (_) -> comma().nl(),\n+                    param -> declareParam(buildContext, param)));\n+            braceNlIndented(_ -> separated(OpTk.statements(buildContext.funcOp.bodies().getFirst().entryBlock()), (_) -> nl(),\n+                    statement -> statement(buildContext, statement))\n+            );\n+        });\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import hat.codebuilders.ScopedCodeBuilderContext;\n@@ -34,1 +35,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -42,1 +42,4 @@\n-        public static void mandel(@MappableIface.RO KernelContext kc, @MappableIface.RW S32Array2D s32Array2D, @MappableIface.RO S32Array pallette, float offsetx, float offsety, float scale) {\n+        public static void mandel(@MappableIface.RO KernelContext kc,\n+                                  @MappableIface.RO S32Array pallette,\n+                                  @MappableIface.RW S32Array2D s32Array2D,\n+                                  float offsetx, float offsety, float scale) {\n@@ -69,1 +72,1 @@\n-                    kc -> mandel(kc, s32Array2D, pallete, x, y, scale));\n+                    kc -> mandel(kc,  pallete,s32Array2D, x, y, scale));\n@@ -74,8 +77,9 @@\n-        var builder= new JavaHATCodeBuilder();\n-        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-        String methodName = \"mandel\";\n-        Method method = Compute.class.getDeclaredMethod(methodName,\n-                KernelContext.class, S32Array2D.class, S32Array.class, float.class, float.class,float.class);\n-        CoreOp.FuncOp javaFunc = Op.ofMethod(method).get();\n-        builder.compute(lookup,javaFunc);\n-        System.out.println(builder.toString());\n+           var builder=  new JavaHATCodeBuilder();\n+           builder.createJava(new ScopedCodeBuilderContext( MethodHandles.lookup(),Op.ofMethod(\n+                Compute.class.getDeclaredMethod(\"mandel\", KernelContext.class, S32Array.class,  S32Array2D.class, float.class, float.class,float.class)).get()\n+           ));\n+           builder.createJava(new ScopedCodeBuilderContext( MethodHandles.lookup(),Op.ofMethod(\n+               Compute.class.getDeclaredMethod(\"compute\", ComputeContext.class,  S32Array.class, S32Array2D.class,float.class, float.class,float.class)).get()\n+          ));\n+           System.out.println(builder);\n+\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"}]}