{"files":[{"patch":"@@ -142,0 +142,1 @@\n+        oparen();\n@@ -145,0 +146,1 @@\n+        cparen();\n@@ -159,0 +161,1 @@\n+        oparen();\n@@ -162,0 +165,1 @@\n+        cparen();\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-                \"oracle.code.hat.TestReductions\"\n+                \"oracle.code.hat.TestReductions\",\n+                \"oracle.code.hat.TestParenthesis\"\n","filename":"hat\/hat\/test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package oracle.code.hat;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import jdk.incubator.code.CodeReflection;\n+import oracle.code.hat.annotation.HatTest;\n+import oracle.code.hat.engine.HatAsserts;\n+\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.*;\n+\n+public class TestParenthesis {\n+\n+    @CodeReflection\n+    public static void compute(@RO KernelContext context, @RW S32Array data) {\n+        final int TN = 2;\n+        final int TF = 128;\n+        final int MAX = 1024;\n+        int c = MAX \/ (TN * TF);\n+        data.array(context.x, c);\n+    }\n+\n+    @CodeReflection\n+    public static void compute2(@RO KernelContext context, @RW S32Array data) {\n+        final int TN = 2;\n+        final int TF = 128;\n+        final int MAX = 1024;\n+        int c = MAX \/ ((TN * TF) \/ (TN * TN));\n+        data.array(context.x, c);\n+    }\n+\n+    @CodeReflection\n+    public static void compute(@RO ComputeContext cc, @RW S32Array data) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(data.length()));\n+        cc.dispatchKernel(computeRange,kc -> compute(kc, data));\n+    }\n+\n+    @CodeReflection\n+    public static void compute2(@RO ComputeContext cc, @RW S32Array data) {\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(data.length()));\n+        cc.dispatchKernel(computeRange,kc -> compute2(kc, data));\n+    }\n+\n+    @HatTest\n+    public static void testParenthesis01() {\n+        final int size = 1;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var data = S32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        data.fill(_ -> 0);\n+\n+        accelerator.compute(cc -> TestParenthesis.compute(cc, data));\n+\n+        final int TN = 2;\n+        final int TF = 128;\n+        final int MAX = 1024;\n+        int c = MAX \/ (TN * TF);\n+        HatAsserts.assertEquals(c, data.array(0));\n+    }\n+\n+    @HatTest\n+    public static void testParenthesis02() {\n+        final int size = 1;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var data = S32Array.create(accelerator, size);\n+\n+        \/\/ Initialize array\n+        data.fill(_ -> 0);\n+\n+        accelerator.compute(cc -> TestParenthesis.compute2(cc, data));\n+\n+        final int TN = 2;\n+        final int TF = 128;\n+        final int MAX = 1024;\n+        int c = MAX \/ ((TN * TF) \/ (TN * TN));\n+        HatAsserts.assertEquals(c, data.array(0));\n+    }\n+\n+}\n","filename":"hat\/tests\/src\/main\/java\/oracle\/code\/hat\/TestParenthesis.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}