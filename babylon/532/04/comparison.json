{"files":[{"patch":"@@ -739,0 +739,3 @@\n+            if (targetType.hasTag(TypeTag.VOID)) {\n+                return sourceValue;\n+            }\n@@ -1033,0 +1036,4 @@\n+                    } else if (isQuoted && top.localToOp.containsKey(sym)) {\n+                        \/\/ if we are scanning a quotable lambda\n+                        \/\/ and the field being loaded is registered as constant capture, load the associated VarOp result\n+                        result = loadVar(sym);\n@@ -1464,1 +1471,7 @@\n-            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+            \/\/ a lambda targeted to Quoted is always going to be quoted regardless of whether\n+            \/\/ we are visiting the method that contain it or we are visiting the lambda itself\n+            \/\/ a lambda target it to subtype of Quotable is only going to be quoted when we are visiting the lambda\n+            \/\/ also, we will not introduce nested quoting in case the top level lambda\n+            \/\/ contain other lambdas targeted for quoting\n+            boolean toQuote = (isQuoted && body == tree) || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+            if (toQuote) {\n@@ -1481,0 +1494,1 @@\n+            Type lambdaReturnType = tree.getDescriptorType(types).getReturnType();\n@@ -1482,2 +1496,2 @@\n-                Value exprVal = toValue(((JCExpression) tree.body), tree.getDescriptorType(types).getReturnType());\n-                if (!tree.body.type.hasTag(TypeTag.VOID)) {\n+                Value exprVal = toValue(((JCExpression) tree.body), lambdaReturnType);\n+                if (!lambdaReturnType.hasTag(TypeTag.VOID)) {\n@@ -1491,1 +1505,1 @@\n-                    bodyTarget = tree.getDescriptorType(types).getReturnType();\n+                    bodyTarget = lambdaReturnType;\n@@ -1515,1 +1529,1 @@\n-            if (isQuoted) {\n+            if (toQuote) {\n@@ -1521,1 +1535,1 @@\n-            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+            if (toQuote) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -254,0 +254,78 @@\n+\n+    static final int Z = 42;\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : Var<java.type:\"int\">)java.type:\"void\" -> {\n+                %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda ()java.type:\"void\" -> {\n+                    %2 : java.type:\"int\" = var.load %0;\n+                    %3 : Var<java.type:\"int\"> = var %2 @\"x\";\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static QuotableRunnable QUOTED_CAPTURE_FINAL_STATIC_FIELD = () -> {\n+        int x = Z;\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()java.type:\"void\" -> {\n+                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda ()java.type:\"void\" -> {\n+                      %2 : java.type:\"int\" = constant @1;\n+                      %3 : java.type:\"int\" = invoke %2 @java.ref:\"QuotableSubtypeTest::n(int):int\";\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    \/\/ the lambda model used to contain operation that perform unnecessary type conversion\n+    static QuotableRunnable QUOTED_RETURN_VOID = () -> {\n+        n(1);\n+    };\n+    static int n(int i) {\n+        return i;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()java.type:\"void\" -> {\n+                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda ()java.type:\"void\" -> {\n+                      %2 : java.type:\"java.lang.Object\" = new @java.ref:\"java.lang.Object::()\";\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    \/\/ the lambda model used to contain ReturnOp with a value, even though the lambda type is void\n+    static QuotableRunnable QUOTED_EXPRESSION_RETURN_VOID = () -> new Object();\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()java.type:\"void\" -> {\n+                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda ()java.type:\"void\" -> {\n+                      %2 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                          return;\n+                      };\n+                      %3 : Var<java.type:\"java.lang.Runnable\"> = var %2 @\"r\";\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static QuotableRunnable QUOTED_NESTED_LAMBDA = () -> {\n+        Runnable r = () -> {};\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()java.type:\"void\" -> {\n+                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda ()java.type:\"void\" -> {\n+                      %2 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda ()java.type:\"void\" -> {\n+                          return;\n+                      };\n+                      %3 : Var<java.type:\"QuotableSubtypeTest$QuotableRunnable\"> = var %2 @\"r\";\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    \/\/ @@@ should this be the excepted behaviour in case we have a nested quotable lambda ?\n+    static QuotableRunnable QUOTED_NESTED_QUOTABLE_LAMBDA = () -> {\n+        QuotableRunnable r = () -> {};\n+    };\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"}]}