{"files":[{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.reflect.code.Block;\n@@ -7,0 +8,1 @@\n+import java.lang.reflect.code.Op;\n@@ -12,0 +14,1 @@\n+import java.lang.reflect.code.type.MethodRef;\n@@ -13,0 +16,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -14,0 +18,1 @@\n+import java.util.function.Predicate;\n@@ -28,0 +33,9 @@\n+    static final MethodRef intToByte = MethodRef.method(ExactConversionsSupport.class, \"isIntToByteExact\",\n+            boolean.class, int.class);\n+    static final MethodRef intToShort = MethodRef.method(ExactConversionsSupport.class, \"isIntToShortExact\",\n+            boolean.class, int.class);\n+    static final MethodRef intToChar = MethodRef.method(ExactConversionsSupport.class, \"isIntToCharExact\",\n+            boolean.class, int.class);\n+    static final MethodRef intToFloat = MethodRef.method(ExactConversionsSupport.class, \"isIntToFloatExact\",\n+            boolean.class, int.class);\n+\n@@ -29,1 +43,1 @@\n-    public static Object[][] patternsOfInt() {\n+    public static Object[][] fromInt() {\n@@ -31,3 +45,6 @@\n-                {JavaType.BYTE, new int[] {Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MIN_VALUE -1, Byte.MAX_VALUE + 1}},\n-                {JavaType.SHORT, new int[] {Short.MIN_VALUE, Short.MAX_VALUE, Short.MIN_VALUE -1, Short.MAX_VALUE + 1}},\n-                {JavaType.CHAR, new int[] {Character.MIN_VALUE, Character.MAX_VALUE, Character.MIN_VALUE -1, Character.MAX_VALUE + 1}},\n+                {JavaType.BYTE, new int[] {Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MIN_VALUE - 1, Byte.MAX_VALUE + 1}, intToByte},\n+                {JavaType.SHORT, new int[] {Short.MIN_VALUE, Short.MAX_VALUE, Short.MIN_VALUE - 1, Short.MAX_VALUE + 1}, intToShort},\n+                {JavaType.CHAR, new int[] {Character.MIN_VALUE, Character.MAX_VALUE, Character.MIN_VALUE - 1, Character.MAX_VALUE + 1}, intToChar},\n+                \/\/ (1<<24) + 1 : first int that's not an instanceof float\n+                \/\/ 1<<31) - (1<<7): largest int that's an instance of float\n+                {JavaType.FLOAT, new int[] {1<<24, (1<<24) + 1, (1<<31) - (1<<7), -((1<<24) + 1)}, intToFloat}\n@@ -37,2 +54,2 @@\n-    @Test(dataProvider = \"patternsOfInt\")\n-    void testPatternsOfInt(JavaType targetType, int[] values) throws Throwable {\n+    @Test(dataProvider = \"fromInt\")\n+    void fromInt(JavaType targetType, int[] values, MethodRef expectedConversionMethod) throws Throwable {\n@@ -45,0 +62,4 @@\n+        Assert.assertTrue(\n+                containsOp(lmodel.body(), op -> op instanceof InvokeOp invOp && invOp.invokeDescriptor().equals(expectedConversionMethod))\n+        );\n+\n@@ -53,0 +74,18 @@\n+    static Op findOp(Body b, Predicate<Op> p) {\n+        for (Block block : b.blocks()) {\n+            for (Op op : block.ops()) {\n+                if (p.test(op)) {\n+                    return op;\n+                }\n+                for (Body body : op.bodies()) {\n+                    return findOp(body, p);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static boolean containsOp(Body b, Predicate<Op> p) {\n+        return findOp(b, p) != null;\n+    }\n+\n@@ -58,2 +97,1 @@\n-            var param = fblock.op(var(fblock.parameters().get(0)));\n-            var paramVal = fblock.op(varLoad(param));\n+            var paramVal = fblock.parameters().get(0);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":46,"deletions":8,"binary":false,"changes":54,"status":"modified"}]}