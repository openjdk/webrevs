{"files":[{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.runtime.ExactConversionsSupport;\n@@ -3165,1 +3164,2 @@\n-                    MethodRef mref = MethodRef.method(JavaType.type(ExactConversionsSupport.class), mn, BOOLEAN, st);\n+                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import java.lang.reflect.Method;\n@@ -9,1 +10,1 @@\n-import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.op.CoreOp;\n@@ -12,0 +13,2 @@\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n@@ -13,0 +16,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -38,1 +43,5 @@\n-        var model = buildTypePatternModel(JavaType.INT, targetType);\n+        var genericModel = getCodeModel(\"f\");\n+\n+        var model = buildTypePatternModel(genericModel, JavaType.INT, targetType);\n+        model.writeTo(System.out);\n+\n@@ -40,0 +49,1 @@\n+        lmodel.writeTo(System.out);\n@@ -48,19 +58,5 @@\n-    static FuncOp buildTypePatternModel(JavaType sourceType, JavaType targetType) {\n-        \/\/ builds the model of:\n-        \/\/ static boolean f(sourceType a) { return a instanceof targetType _; }\n-        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n-\n-            var param = fblock.op(var(fblock.parameters().get(0)));\n-            var paramVal = fblock.op(varLoad(param));\n-\n-            var patternVar = fblock.op(var(fblock.op(constant(targetType, defaultValue(targetType)))));\n-\n-            var pattern = Body.Builder.of(fblock.parentBody(), functionType(ExtendedOp.Pattern.bindingType(targetType)));\n-            pattern.entryBlock().op(_yield(\n-                    pattern.entryBlock().op(typePattern(targetType, null))\n-            ));\n-\n-            var match = Body.Builder.of(fblock.parentBody(), functionType(JavaType.VOID, targetType));\n-            var binding = match.entryBlock().parameters().get(0);\n-            match.entryBlock().op(varStore(patternVar, binding));\n-            match.entryBlock().op(_yield());\n+    @CodeReflection\n+    \/\/ works as generic model that will be transformed to test conversion from a sourceType to targetType\n+    static boolean f(byte b) {\n+        return b instanceof byte _;\n+    }\n@@ -68,1 +64,20 @@\n-            var result = fblock.op(match(paramVal, pattern, match));\n+    static FuncOp buildTypePatternModel(FuncOp genericModel, JavaType sourceType, JavaType targetType) {\n+        List<VarOp> patternVariables = getPatternVariables(genericModel);\n+        return func(genericModel.funcName(), functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+            fblock.transformBody(genericModel.body(), fblock.parameters(), ((block, op) -> {\n+               if (op instanceof ConstantOp cop && cop.parentBlock().nextOp(cop) instanceof VarOp vop &&\n+                       patternVariables.contains(vop)) {\n+                   var newCop = constant(targetType, defaultValue(targetType));\n+                   block.op(newCop);\n+                   block.context().mapValue(cop.result(), newCop.result());\n+               } else if (op instanceof PatternOps.TypePatternOp tpop) {\n+                   var newTpop = typePattern(targetType, tpop.bindingName());\n+                   block.op(newTpop);\n+                   block.context().mapValue(tpop.result(), newTpop.result());\n+               } else {\n+                   block.op(op);\n+               }\n+               return block;\n+           }));\n+        });\n+    }\n@@ -70,1 +85,10 @@\n-            fblock.op(_return(result));\n+    static List<VarOp> getPatternVariables(FuncOp f) {\n+        return f.traverse(new ArrayList<>(), (l, e) -> {\n+            if (e instanceof Block b && b.parentBody().parentOp() instanceof PatternOps.MatchOp) {\n+                b.ops().forEach(op -> {\n+                    if (op instanceof VarAccessOp.VarStoreOp vsop) {\n+                        l.add(vsop.varOp());\n+                    }\n+                });\n+            }\n+            return l;\n@@ -88,0 +112,8 @@\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestPrimitiveTypePatterns.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":55,"deletions":23,"binary":false,"changes":78,"status":"modified"}]}