{"files":[{"patch":"@@ -6,2 +6,2 @@\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.*;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.OpTransformer;\n@@ -10,1 +10,1 @@\n-import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExtendedOp;\n@@ -13,2 +13,0 @@\n-import java.lang.runtime.CodeReflection;\n-import java.util.ArrayList;\n@@ -16,2 +14,0 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n@@ -20,2 +16,3 @@\n-import static java.lang.reflect.code.op.ExtendedOp.*;\n-import static java.lang.reflect.code.type.FunctionType.*;\n+import static java.lang.reflect.code.op.ExtendedOp.match;\n+import static java.lang.reflect.code.op.ExtendedOp.typePattern;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n@@ -43,3 +40,1 @@\n-        var genericModel = getCodeModel(\"f\");\n-\n-        var model = buildTypePatternModel(genericModel, JavaType.INT, targetType);\n+        var model = buildTypePatternModel(JavaType.INT, targetType);\n@@ -58,5 +53,4 @@\n-    @CodeReflection\n-    \/\/ works as generic model that will be transformed to test conversion from a sourceType to targetType\n-    static boolean f(byte b) {\n-        return b instanceof byte _;\n-    }\n+    static FuncOp buildTypePatternModel(JavaType sourceType, JavaType targetType) {\n+        \/\/ builds the model of:\n+        \/\/ static boolean f(sourceType a) { return a instanceof targetType _; }\n+        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n@@ -64,20 +58,9 @@\n-    static FuncOp buildTypePatternModel(FuncOp genericModel, JavaType sourceType, JavaType targetType) {\n-        List<VarOp> patternVariables = getPatternVariables(genericModel);\n-        return func(genericModel.funcName(), functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n-            fblock.transformBody(genericModel.body(), fblock.parameters(), ((block, op) -> {\n-               if (op instanceof ConstantOp cop && cop.parentBlock().nextOp(cop) instanceof VarOp vop &&\n-                       patternVariables.contains(vop)) {\n-                   var newCop = constant(targetType, defaultValue(targetType));\n-                   block.op(newCop);\n-                   block.context().mapValue(cop.result(), newCop.result());\n-               } else if (op instanceof PatternOps.TypePatternOp tpop) {\n-                   var newTpop = typePattern(targetType, tpop.bindingName());\n-                   block.op(newTpop);\n-                   block.context().mapValue(tpop.result(), newTpop.result());\n-               } else {\n-                   block.op(op);\n-               }\n-               return block;\n-           }));\n-        });\n-    }\n+            var param = fblock.op(var(fblock.parameters().get(0)));\n+            var paramVal = fblock.op(varLoad(param));\n+\n+            var patternVar = fblock.op(var(fblock.op(constant(targetType, defaultValue(targetType)))));\n+\n+            var pattern = Body.Builder.of(fblock.parentBody(), functionType(ExtendedOp.Pattern.bindingType(targetType)));\n+            pattern.entryBlock().op(_yield(\n+                    pattern.entryBlock().op(typePattern(targetType, null))\n+            ));\n@@ -85,10 +68,8 @@\n-    static List<VarOp> getPatternVariables(FuncOp f) {\n-        return f.traverse(new ArrayList<>(), (l, e) -> {\n-            if (e instanceof Block b && b.parentBody().parentOp() instanceof PatternOps.MatchOp) {\n-                b.ops().forEach(op -> {\n-                    if (op instanceof VarAccessOp.VarStoreOp vsop) {\n-                        l.add(vsop.varOp());\n-                    }\n-                });\n-            }\n-            return l;\n+            var match = Body.Builder.of(fblock.parentBody(), functionType(JavaType.VOID, targetType));\n+            var binding = match.entryBlock().parameters().get(0);\n+            match.entryBlock().op(varStore(patternVar, binding));\n+            match.entryBlock().op(_yield());\n+\n+            var result = fblock.op(match(paramVal, pattern, match));\n+\n+            fblock.op(_return(result));\n@@ -112,8 +93,0 @@\n-\n-    private static CoreOp.FuncOp getCodeModel(String methodName) {\n-        Optional<Method> om = Stream.of(TestPrimitiveTypePatterns.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(methodName))\n-                .findFirst();\n-\n-        return om.get().getCodeModel().get();\n-    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":28,"deletions":55,"binary":false,"changes":83,"status":"modified"}]}