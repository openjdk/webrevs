{"files":[{"patch":"@@ -3161,1 +3161,1 @@\n-                    if (List.of(CHAR, SHORT).contains(st)) {\n+                    if (SHORT.equals(st) || CHAR.equals(st)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,0 @@\n-import java.lang.reflect.code.Block;\n@@ -8,1 +7,0 @@\n-import java.lang.reflect.code.Op;\n@@ -15,1 +13,0 @@\n-import java.lang.reflect.code.type.PrimitiveType;\n@@ -18,1 +15,0 @@\n-import java.util.function.Predicate;\n@@ -24,0 +20,1 @@\n+import static java.lang.reflect.code.type.PrimitiveType.*;\n@@ -33,25 +30,0 @@\n-    static final MethodRef intToByte = conversionMethodRef(JavaType.INT, JavaType.BYTE);\n-    static final MethodRef intToShort = conversionMethodRef(JavaType.INT, JavaType.SHORT);\n-    static final MethodRef intToChar = conversionMethodRef(JavaType.INT, JavaType.CHAR);\n-    static final MethodRef intToFloat = conversionMethodRef(JavaType.INT, JavaType.FLOAT);\n-    static final MethodRef longToByte = conversionMethodRef(JavaType.LONG, JavaType.BYTE);\n-    static final MethodRef longToShort = conversionMethodRef(JavaType.LONG, JavaType.SHORT);\n-    static final MethodRef longToChar = conversionMethodRef(JavaType.LONG, JavaType.CHAR);\n-    static final MethodRef longToInt = conversionMethodRef(JavaType.LONG, JavaType.INT);\n-    static final MethodRef longToFloat = conversionMethodRef(JavaType.LONG, JavaType.FLOAT);\n-    static final MethodRef longToDouble = conversionMethodRef(JavaType.LONG, JavaType.DOUBLE);\n-    static final MethodRef floatToByte = conversionMethodRef(JavaType.FLOAT, JavaType.BYTE);\n-    static final MethodRef floatToShort = conversionMethodRef(JavaType.FLOAT, JavaType.SHORT);\n-    static final MethodRef floatToChar = conversionMethodRef(JavaType.FLOAT, JavaType.CHAR);\n-    static final MethodRef floatToInt = conversionMethodRef(JavaType.FLOAT, JavaType.INT);\n-    static final MethodRef floatToLong = conversionMethodRef(JavaType.FLOAT, JavaType.LONG);\n-    static final MethodRef doubleToByte = conversionMethodRef(JavaType.DOUBLE, JavaType.BYTE);\n-    static final MethodRef doubleToShort = conversionMethodRef(JavaType.DOUBLE, JavaType.SHORT);\n-    static final MethodRef doubleToChar = conversionMethodRef(JavaType.DOUBLE, JavaType.CHAR);\n-    static final MethodRef doubleToInt = conversionMethodRef(JavaType.DOUBLE, JavaType.INT);\n-    static final MethodRef doubleToLong = conversionMethodRef(JavaType.DOUBLE, JavaType.LONG);\n-    static final MethodRef doubleToFloat = conversionMethodRef(JavaType.DOUBLE, JavaType.FLOAT);\n-\n-\n-\n-\n@@ -59,0 +31,3 @@\n+        if (SHORT.equals(sourceType) || CHAR.equals(sourceType)) {\n+            sourceType = INT;\n+        }\n@@ -61,1 +36,1 @@\n-        return MethodRef.method(c, n, PrimitiveType.BOOLEAN, sourceType);\n+        return MethodRef.method(c, n, BOOLEAN, sourceType);\n@@ -71,6 +46,9 @@\n-                {JavaType.INT, JavaType.BYTE, new Object[] {Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE,\n-                        Byte.MAX_VALUE + 1}, intToByte},\n-                {JavaType.INT, JavaType.SHORT, new Object[] {Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE,\n-                        Short.MAX_VALUE + 1}, intToShort},\n-                {JavaType.INT, JavaType.CHAR, new Object[] {Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE,\n-                        Character.MAX_VALUE + 1}, intToChar},\n+                {JavaType.INT, JavaType.BYTE, new Object[] {\n+                        Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE + 1\n+                }},\n+                {JavaType.INT, JavaType.SHORT, new Object[] {\n+                        Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE, Short.MAX_VALUE + 1\n+                }},\n+                {JavaType.INT, JavaType.CHAR, new Object[] {\n+                        Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE, Character.MAX_VALUE + 1\n+                }},\n@@ -79,18 +57,30 @@\n-                {JavaType.INT, JavaType.FLOAT, new Object[] {1<<24, (1<<24) + 1, (1<<31) - (1<<7), (1<<31) - (1<<7) + 1,\n-                        Integer.MAX_VALUE, Integer.MIN_VALUE}, intToFloat},\n-\n-                {JavaType.SHORT, JavaType.BYTE, new Object[]{(short) (Byte.MIN_VALUE - 1), Byte.MIN_VALUE, Byte.MAX_VALUE,\n-                        (short) (Byte.MAX_VALUE + 1)}, intToByte},\n-                {JavaType.SHORT, JavaType.CHAR, new Object[]{Short.MIN_VALUE, (short) -1, (short) 0, Short.MAX_VALUE}, intToChar},\n-\n-                {JavaType.CHAR, JavaType.BYTE, new Object[]{(char) 0, (char) Byte.MAX_VALUE, (char) (Byte.MAX_VALUE + 1)}, intToByte},\n-                {JavaType.CHAR, JavaType.SHORT, new Object[]{(char) 0, (char) Short.MAX_VALUE, (char) (Short.MAX_VALUE + 1)}, intToShort},\n-\n-                {JavaType.LONG, JavaType.BYTE, new Object[] {Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE,\n-                        Byte.MAX_VALUE + 1}, longToByte},\n-                {JavaType.LONG, JavaType.SHORT, new Object[] {Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE,\n-                        Short.MAX_VALUE + 1}, longToShort},\n-                {JavaType.LONG, JavaType.CHAR, new Object[] {Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE,\n-                        Character.MAX_VALUE + 1}, longToChar},\n-                {JavaType.LONG, JavaType.INT, new Object[] {(long)Integer.MIN_VALUE - 1, Integer.MIN_VALUE, Integer.MAX_VALUE,\n-                        (long)Integer.MAX_VALUE + 1}, longToInt},\n+                {JavaType.INT, JavaType.FLOAT, new Object[] {\n+                        1<<24, (1<<24) + 1, (1<<31) - (1<<7), (1<<31) - (1<<7) + 1, Integer.MAX_VALUE, Integer.MIN_VALUE\n+                }},\n+\n+                {JavaType.SHORT, JavaType.BYTE, new Object[]{\n+                        (short) (Byte.MIN_VALUE - 1), Byte.MIN_VALUE, Byte.MAX_VALUE, (short) (Byte.MAX_VALUE + 1)\n+                }},\n+                {JavaType.SHORT, JavaType.CHAR, new Object[]{\n+                        Short.MIN_VALUE, (short) -1, (short) 0, Short.MAX_VALUE\n+                }},\n+\n+                {JavaType.CHAR, JavaType.BYTE, new Object[]{\n+                        (char) 0, (char) Byte.MAX_VALUE, (char) (Byte.MAX_VALUE + 1)\n+                }},\n+                {JavaType.CHAR, JavaType.SHORT, new Object[]{\n+                        (char) 0, (char) Short.MAX_VALUE, (char) (Short.MAX_VALUE + 1)\n+                }},\n+\n+                {JavaType.LONG, JavaType.BYTE, new Object[] {\n+                        Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE + 1\n+                }},\n+                {JavaType.LONG, JavaType.SHORT, new Object[] {\n+                        Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE, Short.MAX_VALUE + 1\n+                }},\n+                {JavaType.LONG, JavaType.CHAR, new Object[] {\n+                        Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE, Character.MAX_VALUE + 1\n+                }},\n+                {JavaType.LONG, JavaType.INT, new Object[] {\n+                        (long)Integer.MIN_VALUE - 1, Integer.MIN_VALUE, Integer.MAX_VALUE, (long)Integer.MAX_VALUE + 1\n+                }},\n@@ -99,2 +89,3 @@\n-                {JavaType.LONG, JavaType.FLOAT, new Object[] {Long.MIN_VALUE, (1L<<24), (1<<24) + 1, (1L<<63) - (1L<<39),\n-                        (1L<<63) - (1L<<39) + 1, Long.MAX_VALUE}, longToFloat},\n+                {JavaType.LONG, JavaType.FLOAT, new Object[] {\n+                        Long.MIN_VALUE, (1L<<24), (1<<24) + 1, (1L<<63) - (1L<<39), (1L<<63) - (1L<<39) + 1, Long.MAX_VALUE\n+                }},\n@@ -103,26 +94,38 @@\n-                {JavaType.LONG, JavaType.DOUBLE, new Object[] {Long.MIN_VALUE, 1L<<53, (1L<<53) + 1, (1L<<63) - (1<<10),\n-                        (1L<<63) - (1<<10) + 1, Long.MAX_VALUE}, longToDouble},\n-\n-                {JavaType.FLOAT, JavaType.BYTE, new Object[] {Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE,\n-                        Byte.MIN_VALUE + 1}, floatToByte},\n-                {JavaType.FLOAT, JavaType.SHORT, new Object[] {Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE,\n-                        Short.MAX_VALUE + 1}, floatToShort},\n-                {JavaType.FLOAT, JavaType.CHAR, new Object[] {Character.MIN_VALUE - 1, Character.MIN_VALUE,\n-                        Character.MAX_VALUE, Character.MAX_VALUE + 1}, floatToChar},\n-                {JavaType.FLOAT, JavaType.INT, new Object[] {Float.MIN_VALUE, Float.NEGATIVE_INFINITY, 0f,\n-                        Float.POSITIVE_INFINITY, Float.MAX_VALUE}, floatToInt},\n-                {JavaType.FLOAT, JavaType.LONG, new Object[] {Float.MIN_VALUE, Float.NEGATIVE_INFINITY, 0f,\n-                        Float.POSITIVE_INFINITY, Float.MAX_VALUE}, floatToLong},\n-\n-                {JavaType.DOUBLE, JavaType.BYTE, new Object[] {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d,\n-                        Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN}, doubleToByte},\n-                {JavaType.DOUBLE, JavaType.SHORT, new Object[] {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d,\n-                        Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN}, doubleToShort},\n-                {JavaType.DOUBLE, JavaType.CHAR, new Object[] {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d,\n-                        Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN}, doubleToChar},\n-                {JavaType.DOUBLE, JavaType.INT, new Object[] {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d,\n-                        Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN}, doubleToInt},\n-                {JavaType.DOUBLE, JavaType.LONG, new Object[] {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d,\n-                        Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN}, doubleToLong},\n-                {JavaType.DOUBLE, JavaType.FLOAT, new Object[] {Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d,\n-                        Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN}, doubleToFloat}\n+                {JavaType.LONG, JavaType.DOUBLE, new Object[] {\n+                        Long.MIN_VALUE, 1L<<53, (1L<<53) + 1, (1L<<63) - (1<<10), (1L<<63) - (1<<10) + 1, Long.MAX_VALUE\n+                }},\n+\n+                {JavaType.FLOAT, JavaType.BYTE, new Object[] {\n+                        Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MIN_VALUE + 1\n+                }},\n+                {JavaType.FLOAT, JavaType.SHORT, new Object[] {\n+                        Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE, Short.MAX_VALUE + 1\n+                }},\n+                {JavaType.FLOAT, JavaType.CHAR, new Object[] {\n+                        Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE, Character.MAX_VALUE + 1\n+                }},\n+                {JavaType.FLOAT, JavaType.INT, new Object[] {\n+                        Float.MIN_VALUE, Float.NEGATIVE_INFINITY, 0f, Float.POSITIVE_INFINITY, Float.MAX_VALUE\n+                }},\n+                {JavaType.FLOAT, JavaType.LONG, new Object[] {\n+                        Float.MIN_VALUE, Float.NEGATIVE_INFINITY, 0f, Float.POSITIVE_INFINITY, Float.MAX_VALUE\n+                }},\n+\n+                {JavaType.DOUBLE, JavaType.BYTE, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.SHORT, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.CHAR, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.INT, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.LONG, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.FLOAT, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }}\n@@ -134,1 +137,1 @@\n-    void test(JavaType sourceType, JavaType targetType, Object[] values, MethodRef expectedConversionMethod) throws Throwable {\n+    void test(JavaType sourceType, JavaType targetType, Object[] values) throws Throwable {\n@@ -141,3 +144,11 @@\n-        Assert.assertTrue(\n-                containsOp(lmodel.body(), op -> op instanceof InvokeOp invOp && invOp.invokeDescriptor().equals(expectedConversionMethod))\n-        );\n+\n+\n+        var expectedConvMethod = conversionMethodRef(sourceType, targetType);\n+        var actualConvMethod = lmodel.elements()\n+                .mapMulti((ce, c) -> {\n+                    if (ce instanceof InvokeOp op) {\n+                        c.accept(op.invokeDescriptor());\n+                    }\n+                })\n+                .findFirst().orElseThrow();\n+        Assert.assertEquals(actualConvMethod, expectedConvMethod);\n@@ -152,18 +163,0 @@\n-    static Op findOp(Body b, Predicate<Op> p) {\n-        for (Block block : b.blocks()) {\n-            for (Op op : block.ops()) {\n-                if (p.test(op)) {\n-                    return op;\n-                }\n-                for (Body body : op.bodies()) {\n-                    return findOp(body, p);\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    static boolean containsOp(Body b, Predicate<Op> p) {\n-        return findOp(b, p) != null;\n-    }\n-\n@@ -196,1 +189,1 @@\n-        if (List.of(PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR, PrimitiveType.INT).contains(t)) {\n+        if (List.of(BYTE, SHORT, CHAR, INT).contains(t)) {\n@@ -198,1 +191,1 @@\n-        } else if (PrimitiveType.LONG.equals(t)) {\n+        } else if (LONG.equals(t)) {\n@@ -200,1 +193,1 @@\n-        } else if (PrimitiveType.FLOAT.equals(t)) {\n+        } else if (FLOAT.equals(t)) {\n@@ -202,1 +195,1 @@\n-        } else if (PrimitiveType.DOUBLE.equals(t)) {\n+        } else if (DOUBLE.equals(t)) {\n@@ -204,1 +197,1 @@\n-        } else if (PrimitiveType.BOOLEAN.equals(t)) {\n+        } else if (BOOLEAN.equals(t)) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":102,"deletions":109,"binary":false,"changes":211,"status":"modified"}]}