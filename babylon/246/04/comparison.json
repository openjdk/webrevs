{"files":[{"patch":"@@ -3115,1 +3115,1 @@\n-                    case TypePatternOp tp -> lowerBindingPattern(endNoMatchBlock, currentBlock, bindings, tp, target);\n+                    case TypePatternOp tp -> lowerTypePattern(endNoMatchBlock, currentBlock, bindings, tp, target);\n@@ -3149,3 +3149,3 @@\n-            static Block.Builder lowerBindingPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n-                                                     List<Value> bindings,\n-                                                     TypePatternOp tpOp, Value target) {\n+            static Block.Builder lowerTypePattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                                  List<Value> bindings,\n+                                                  TypePatternOp tpOp, Value target) {\n@@ -3157,2 +3157,15 @@\n-                currentBlock.op(conditionalBranch(currentBlock.op(CoreOp.instanceOf(targetType, target)),\n-                        nextBlock.successor(), endNoMatchBlock.successor()));\n+                Result p;\n+                boolean patternWithPrimitive = false;\n+                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n+                    patternWithPrimitive = true;\n+                    String s = capitalize(st.toString());\n+                    String t = capitalize(tt.toString());\n+                    String mn = \"is%sTo%sExact\".formatted(s, t);\n+                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n+                    p = currentBlock.op(invoke(mref, target));\n+                } else {\n+                    p = currentBlock.op(CoreOp.instanceOf(targetType, target));\n+                }\n+\n+                currentBlock.op(conditionalBranch(p, nextBlock.successor(), endNoMatchBlock.successor()));\n@@ -3162,1 +3175,5 @@\n-                target = currentBlock.op(CoreOp.cast(targetType, target));\n+                if (patternWithPrimitive) {\n+                    target = currentBlock.op(CoreOp.conv(targetType, target));\n+                } else {\n+                    target = currentBlock.op(CoreOp.cast(targetType, target));\n+                }\n@@ -3168,0 +3185,4 @@\n+            private static String capitalize(String s) {\n+                return s.substring(0, 1).toUpperCase() + s.substring(1);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOp.*;\n+import static java.lang.reflect.code.op.ExtendedOp.*;\n+import static java.lang.reflect.code.type.FunctionType.*;\n+\n+\/*\n+ * @test\n+ * @run testng TestPrimitiveTypePatterns\n+ * @enablePreview\n+ *\/\n+\n+public class TestPrimitiveTypePatterns {\n+\n+    @DataProvider\n+    public static Object[][] patternsOfInt() {\n+        return new Object[][]{\n+                {JavaType.BYTE, new int[] {Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MIN_VALUE -1, Byte.MAX_VALUE + 1}},\n+                {JavaType.SHORT, new int[] {Short.MIN_VALUE, Short.MAX_VALUE, Short.MIN_VALUE -1, Short.MAX_VALUE + 1}},\n+                {JavaType.CHAR, new int[] {Character.MIN_VALUE, Character.MAX_VALUE, Character.MIN_VALUE -1, Character.MAX_VALUE + 1}},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"patternsOfInt\")\n+    void testPatternsOfInt(JavaType targetType, int[] values) throws Throwable {\n+\n+        var genericModel = getCodeModel(\"f\");\n+\n+        var model = buildTypePatternModel(genericModel, JavaType.INT, targetType);\n+        model.writeTo(System.out);\n+\n+        var lmodel = model.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lmodel.writeTo(System.out);\n+\n+        var mh = BytecodeGenerator.generate(MethodHandles.lookup(), lmodel);\n+\n+        for (int v : values) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, v), mh.invoke(v));\n+        }\n+    }\n+\n+    @CodeReflection\n+    \/\/ works as generic model that will be transformed to test conversion from a sourceType to targetType\n+    static boolean f(byte b) {\n+        return b instanceof byte _;\n+    }\n+\n+    static FuncOp buildTypePatternModel(FuncOp genericModel, JavaType sourceType, JavaType targetType) {\n+        List<VarOp> patternVariables = getPatternVariables(genericModel);\n+        return func(genericModel.funcName(), functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+            fblock.transformBody(genericModel.body(), fblock.parameters(), ((block, op) -> {\n+               if (op instanceof ConstantOp cop && cop.parentBlock().nextOp(cop) instanceof VarOp vop &&\n+                       patternVariables.contains(vop)) {\n+                   var newCop = constant(targetType, defaultValue(targetType));\n+                   block.op(newCop);\n+                   block.context().mapValue(cop.result(), newCop.result());\n+               } else if (op instanceof PatternOps.TypePatternOp tpop) {\n+                   var newTpop = typePattern(targetType, tpop.bindingName());\n+                   block.op(newTpop);\n+                   block.context().mapValue(tpop.result(), newTpop.result());\n+               } else {\n+                   block.op(op);\n+               }\n+               return block;\n+           }));\n+        });\n+    }\n+\n+    static List<VarOp> getPatternVariables(FuncOp f) {\n+        return f.traverse(new ArrayList<>(), (l, e) -> {\n+            if (e instanceof Block b && b.parentBody().parentOp() instanceof PatternOps.MatchOp) {\n+                b.ops().forEach(op -> {\n+                    if (op instanceof VarAccessOp.VarStoreOp vsop) {\n+                        l.add(vsop.varOp());\n+                    }\n+                });\n+            }\n+            return l;\n+        });\n+    }\n+\n+    static Object defaultValue(JavaType t) {\n+        if (List.of(PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR, PrimitiveType.INT).contains(t)) {\n+            return 0;\n+        } else if (PrimitiveType.LONG.equals(t)) {\n+            return 0L;\n+        } else if (PrimitiveType.FLOAT.equals(t)) {\n+            return 0f;\n+        } else if (PrimitiveType.DOUBLE.equals(t)) {\n+            return 0d;\n+        } else if (PrimitiveType.BOOLEAN.equals(t)) {\n+            return false;\n+        }\n+        return null;\n+    }\n+\n+    private static CoreOp.FuncOp getCodeModel(String methodName) {\n+        Optional<Method> om = Stream.of(TestPrimitiveTypePatterns.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(methodName))\n+                .findFirst();\n+\n+        return om.get().getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}