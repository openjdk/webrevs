{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -31,0 +32,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -3157,2 +3159,19 @@\n-                currentBlock.op(conditionalBranch(currentBlock.op(CoreOp.instanceOf(targetType, target)),\n-                        nextBlock.successor(), endNoMatchBlock.successor()));\n+                Result p;\n+                boolean patternWithPrimitive = false;\n+                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n+                    patternWithPrimitive = true;\n+                    try {\n+                        String s = capitalize(st.toString());\n+                        String t = capitalize(tt.toString());\n+                        String mn = \"is%sTo%sExact\".formatted(s, t);\n+                        MethodRef mref = MethodRef.method(ExactConversionsSupport.class, mn, boolean.class,\n+                                st.toNominalDescriptor().resolveConstantDesc(MethodHandles.lookup()));\n+                        p = currentBlock.op(invoke(mref, target));\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                } else {\n+                    p = currentBlock.op(CoreOp.instanceOf(targetType, target));\n+                }\n+\n+                currentBlock.op(conditionalBranch(p, nextBlock.successor(), endNoMatchBlock.successor()));\n@@ -3162,1 +3181,5 @@\n-                target = currentBlock.op(CoreOp.cast(targetType, target));\n+                if (patternWithPrimitive) {\n+                    target = currentBlock.op(CoreOp.conv(targetType, target));\n+                } else {\n+                    target = currentBlock.op(CoreOp.cast(targetType, target));\n+                }\n@@ -3168,0 +3191,4 @@\n+            private static String capitalize(String s) {\n+                return s.substring(0, 1).toUpperCase() + s.substring(1);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestPatternsWithPrimitives\n+ * @enablePreview\n+ *\/\n+\n+public class TestPatternsWithPrimitives {\n+\n+    @CodeReflection\n+    static boolean f(int a) {\n+        return a instanceof byte _;\n+    }\n+\n+    @Test\n+    void test() {\n+\n+        CoreOp.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lf.writeTo(System.out);\n+\n+        int[] args = {1, 128, -129};\n+        for (int a : args) {\n+            Assert.assertEquals(Interpreter.invoke(lf, a), f(a));\n+        }\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestPatternsWithPrimitives.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatternsWithPrimitives.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"}]}