{"files":[{"patch":"@@ -2,0 +2,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -4,2 +5,3 @@\n-import java.lang.reflect.Method;\n-import java.lang.reflect.code.OpTransformer;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n@@ -7,4 +9,8 @@\n-import java.lang.reflect.code.op.CoreOp;\n-import java.lang.runtime.CodeReflection;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOp.*;\n+import static java.lang.reflect.code.op.ExtendedOp.*;\n+import static java.lang.reflect.code.type.FunctionType.*;\n@@ -20,3 +26,7 @@\n-    @CodeReflection\n-    static boolean f(int a) {\n-        return a instanceof byte _;\n+    @DataProvider\n+    public static Object[][] patternsOfInt() {\n+        return new Object[][]{\n+                {JavaType.BYTE, new int[] {Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MIN_VALUE -1, Byte.MAX_VALUE + 1}},\n+                {JavaType.SHORT, new int[] {Short.MIN_VALUE, Short.MAX_VALUE, Short.MIN_VALUE -1, Short.MAX_VALUE + 1}},\n+                {JavaType.CHAR, new int[] {Character.MIN_VALUE, Character.MAX_VALUE, Character.MIN_VALUE -1, Character.MAX_VALUE + 1}},\n+        };\n@@ -25,2 +35,2 @@\n-    @Test\n-    void test() {\n+    @Test(dataProvider = \"patternsOfInt\")\n+    void testPatternsOfInt(JavaType targetType, int[] values) throws Throwable {\n@@ -28,2 +38,2 @@\n-        CoreOp.FuncOp f = getFuncOp(\"f\");\n-        f.writeTo(System.out);\n+        var model = buildTypePatternModel(JavaType.INT, targetType);\n+        var lmodel = model.transform(OpTransformer.LOWERING_TRANSFORMER);\n@@ -31,2 +41,1 @@\n-        CoreOp.FuncOp lf = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n-        lf.writeTo(System.out);\n+        var mh = BytecodeGenerator.generate(MethodHandles.lookup(), lmodel);\n@@ -34,3 +43,2 @@\n-        int[] args = {1, 128, -129};\n-        for (int a : args) {\n-            Assert.assertEquals(Interpreter.invoke(lf, a), f(a));\n+        for (int v : values) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, v), mh.invoke(v));\n@@ -40,4 +48,19 @@\n-    static CoreOp.FuncOp getFuncOp(String name) {\n-        Optional<Method> om = Stream.of(TestPatternsWithPrimitives.class.getDeclaredMethods())\n-                .filter(m -> m.getName().equals(name))\n-                .findFirst();\n+    static FuncOp buildTypePatternModel(JavaType sourceType, JavaType targetType) {\n+        \/\/ builds the model of:\n+        \/\/ static boolean f(sourceType a) { return a instanceof targetType _; }\n+        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+\n+            var param = fblock.op(var(fblock.parameters().get(0)));\n+            var paramVal = fblock.op(varLoad(param));\n+\n+            var patternVar = fblock.op(var(fblock.op(constant(targetType, defaultValue(targetType)))));\n+\n+            var pattern = Body.Builder.of(fblock.parentBody(), functionType(ExtendedOp.Pattern.bindingType(targetType)));\n+            pattern.entryBlock().op(_yield(\n+                    pattern.entryBlock().op(typePattern(targetType, null))\n+            ));\n+\n+            var match = Body.Builder.of(fblock.parentBody(), functionType(JavaType.VOID, targetType));\n+            var binding = match.entryBlock().parameters().get(0);\n+            match.entryBlock().op(varStore(patternVar, binding));\n+            match.entryBlock().op(_yield());\n@@ -45,2 +68,19 @@\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n+            var result = fblock.op(match(paramVal, pattern, match));\n+\n+            fblock.op(_return(result));\n+        });\n+    }\n+\n+    static Object defaultValue(JavaType t) {\n+        if (List.of(PrimitiveType.BYTE, PrimitiveType.SHORT, PrimitiveType.CHAR, PrimitiveType.INT).contains(t)) {\n+            return 0;\n+        } else if (PrimitiveType.LONG.equals(t)) {\n+            return 0L;\n+        } else if (PrimitiveType.FLOAT.equals(t)) {\n+            return 0f;\n+        } else if (PrimitiveType.DOUBLE.equals(t)) {\n+            return 0d;\n+        } else if (PrimitiveType.BOOLEAN.equals(t)) {\n+            return false;\n+        }\n+        return null;\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatternsWithPrimitives.java","additions":64,"deletions":24,"binary":false,"changes":88,"status":"modified"}]}