{"files":[{"patch":"@@ -3115,1 +3115,1 @@\n-                    case TypePatternOp tp -> lowerBindingPattern(endNoMatchBlock, currentBlock, bindings, tp, target);\n+                    case TypePatternOp tp -> lowerTypePattern(endNoMatchBlock, currentBlock, bindings, tp, target);\n@@ -3149,3 +3149,3 @@\n-            static Block.Builder lowerBindingPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n-                                                     List<Value> bindings,\n-                                                     TypePatternOp tpOp, Value target) {\n+            static Block.Builder lowerTypePattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                                  List<Value> bindings,\n+                                                  TypePatternOp tpOp, Value target) {\n@@ -3157,2 +3157,18 @@\n-                currentBlock.op(conditionalBranch(currentBlock.op(CoreOp.instanceOf(targetType, target)),\n-                        nextBlock.successor(), endNoMatchBlock.successor()));\n+                Result p;\n+                boolean patternWithPrimitive = false;\n+                if (targetType instanceof PrimitiveType tt && target.type() instanceof PrimitiveType st) {\n+                    patternWithPrimitive = true;\n+                    if (SHORT.equals(st) || CHAR.equals(st)) {\n+                        st = INT;\n+                    }\n+                    String s = capitalize(st.toString());\n+                    String t = capitalize(tt.toString());\n+                    String mn = \"is%sTo%sExact\".formatted(s, t);\n+                    JavaType exactConversionSupport = JavaType.type(ClassDesc.of(\"java.lang.runtime.ExactConversionsSupport\"));\n+                    MethodRef mref = MethodRef.method(exactConversionSupport, mn, BOOLEAN, st);\n+                    p = currentBlock.op(invoke(mref, target));\n+                } else {\n+                    p = currentBlock.op(CoreOp.instanceOf(targetType, target));\n+                }\n+\n+                currentBlock.op(conditionalBranch(p, nextBlock.successor(), endNoMatchBlock.successor()));\n@@ -3162,1 +3178,5 @@\n-                target = currentBlock.op(CoreOp.cast(targetType, target));\n+                if (patternWithPrimitive) {\n+                    target = currentBlock.op(CoreOp.conv(targetType, target));\n+                } else {\n+                    target = currentBlock.op(CoreOp.cast(targetType, target));\n+                }\n@@ -3168,0 +3188,4 @@\n+            private static String capitalize(String s) {\n+                return s.substring(0, 1).toUpperCase() + s.substring(1);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOp.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.ExtendedOp;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.runtime.ExactConversionsSupport;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOp.*;\n+import static java.lang.reflect.code.op.ExtendedOp.match;\n+import static java.lang.reflect.code.op.ExtendedOp.typePattern;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.PrimitiveType.*;\n+\n+\/*\n+ * @test\n+ * @run testng TestPrimitiveTypePatterns\n+ * @enablePreview\n+ *\/\n+\n+public class TestPrimitiveTypePatterns {\n+\n+    static MethodRef conversionMethodRef(JavaType sourceType, JavaType targetType) {\n+        if (SHORT.equals(sourceType) || CHAR.equals(sourceType)) {\n+            sourceType = INT;\n+        }\n+        String n = \"is%sTo%sExact\".formatted(capitalize(sourceType.toString()), capitalize(targetType.toString()));\n+        JavaType c = JavaType.type(ExactConversionsSupport.class);\n+        return MethodRef.method(c, n, BOOLEAN, sourceType);\n+    }\n+\n+    static String capitalize(String s) {\n+        return s.substring(0, 1).toUpperCase() + s.substring(1);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] dp() {\n+        return new Object[][]{\n+                {JavaType.INT, JavaType.BYTE, new Object[] {\n+                        Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE + 1\n+                }},\n+                {JavaType.INT, JavaType.SHORT, new Object[] {\n+                        Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE, Short.MAX_VALUE + 1\n+                }},\n+                {JavaType.INT, JavaType.CHAR, new Object[] {\n+                        Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE, Character.MAX_VALUE + 1\n+                }},\n+                \/\/ (1<<24) + 1 : first int that's not an instanceof float\n+                \/\/ 1<<31) - (1<<7): largest int that's an instance of float\n+                {JavaType.INT, JavaType.FLOAT, new Object[] {\n+                        1<<24, (1<<24) + 1, (1<<31) - (1<<7), (1<<31) - (1<<7) + 1, Integer.MAX_VALUE, Integer.MIN_VALUE\n+                }},\n+\n+                {JavaType.SHORT, JavaType.BYTE, new Object[]{\n+                        (short) (Byte.MIN_VALUE - 1), Byte.MIN_VALUE, Byte.MAX_VALUE, (short) (Byte.MAX_VALUE + 1)\n+                }},\n+                {JavaType.SHORT, JavaType.CHAR, new Object[]{\n+                        Short.MIN_VALUE, (short) -1, (short) 0, Short.MAX_VALUE\n+                }},\n+\n+                {JavaType.CHAR, JavaType.BYTE, new Object[]{\n+                        (char) 0, (char) Byte.MAX_VALUE, (char) (Byte.MAX_VALUE + 1)\n+                }},\n+                {JavaType.CHAR, JavaType.SHORT, new Object[]{\n+                        (char) 0, (char) Short.MAX_VALUE, (char) (Short.MAX_VALUE + 1)\n+                }},\n+\n+                {JavaType.LONG, JavaType.BYTE, new Object[] {\n+                        Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE + 1\n+                }},\n+                {JavaType.LONG, JavaType.SHORT, new Object[] {\n+                        Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE, Short.MAX_VALUE + 1\n+                }},\n+                {JavaType.LONG, JavaType.CHAR, new Object[] {\n+                        Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE, Character.MAX_VALUE + 1\n+                }},\n+                {JavaType.LONG, JavaType.INT, new Object[] {\n+                        (long)Integer.MIN_VALUE - 1, Integer.MIN_VALUE, Integer.MAX_VALUE, (long)Integer.MAX_VALUE + 1\n+                }},\n+                \/\/ (1<<24) + 1 : first long that can't be represented as float\n+                \/\/ (1L<<63) - (1L<<39) : largest long that can be represented as float\n+                {JavaType.LONG, JavaType.FLOAT, new Object[] {\n+                        Long.MIN_VALUE, (1L<<24), (1<<24) + 1, (1L<<63) - (1L<<39), (1L<<63) - (1L<<39) + 1, Long.MAX_VALUE\n+                }},\n+                \/\/ (1L<<53) + 1 : first long that can't be represented as double\n+                \/\/ (1L<<63) - (1<<10) : largest long that can be represented as double\n+                {JavaType.LONG, JavaType.DOUBLE, new Object[] {\n+                        Long.MIN_VALUE, 1L<<53, (1L<<53) + 1, (1L<<63) - (1<<10), (1L<<63) - (1<<10) + 1, Long.MAX_VALUE\n+                }},\n+\n+                {JavaType.FLOAT, JavaType.BYTE, new Object[] {\n+                        Byte.MIN_VALUE - 1, Byte.MIN_VALUE, Byte.MAX_VALUE, Byte.MIN_VALUE + 1\n+                }},\n+                {JavaType.FLOAT, JavaType.SHORT, new Object[] {\n+                        Short.MIN_VALUE - 1, Short.MIN_VALUE, Short.MAX_VALUE, Short.MAX_VALUE + 1\n+                }},\n+                {JavaType.FLOAT, JavaType.CHAR, new Object[] {\n+                        Character.MIN_VALUE - 1, Character.MIN_VALUE, Character.MAX_VALUE, Character.MAX_VALUE + 1\n+                }},\n+                {JavaType.FLOAT, JavaType.INT, new Object[] {\n+                        Float.MIN_VALUE, Float.NEGATIVE_INFINITY, 0f, Float.POSITIVE_INFINITY, Float.MAX_VALUE\n+                }},\n+                {JavaType.FLOAT, JavaType.LONG, new Object[] {\n+                        Float.MIN_VALUE, Float.NEGATIVE_INFINITY, 0f, Float.POSITIVE_INFINITY, Float.MAX_VALUE\n+                }},\n+\n+                {JavaType.DOUBLE, JavaType.BYTE, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.SHORT, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.CHAR, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.INT, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.LONG, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }},\n+                {JavaType.DOUBLE, JavaType.FLOAT, new Object[] {\n+                        Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -0d, +0d, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN\n+                }}\n+\n+        };\n+    }\n+\n+    @Test(dataProvider = \"dp\")\n+    void test(JavaType sourceType, JavaType targetType, Object[] values) throws Throwable {\n+\n+        var model = buildTypePatternModel(sourceType, targetType);\n+        model.writeTo(System.out);\n+\n+        var lmodel = model.transform(OpTransformer.LOWERING_TRANSFORMER);\n+        lmodel.writeTo(System.out);\n+\n+\n+        var expectedConvMethod = conversionMethodRef(sourceType, targetType);\n+        var actualConvMethod = lmodel.elements()\n+                .mapMulti((ce, c) -> {\n+                    if (ce instanceof InvokeOp op) {\n+                        c.accept(op.invokeDescriptor());\n+                    }\n+                })\n+                .findFirst().orElseThrow();\n+        Assert.assertEquals(actualConvMethod, expectedConvMethod);\n+\n+        var mh = BytecodeGenerator.generate(MethodHandles.lookup(), lmodel);\n+\n+        for (Object v : values) {\n+            Assert.assertEquals(Interpreter.invoke(lmodel, v), mh.invoke(v));\n+        }\n+    }\n+\n+    static FuncOp buildTypePatternModel(JavaType sourceType, JavaType targetType) {\n+        \/\/ builds the model of:\n+        \/\/ static boolean f(sourceType a) { return a instanceof targetType _; }\n+        return func(\"f\", functionType(JavaType.BOOLEAN, sourceType)).body(fblock -> {\n+\n+            var paramVal = fblock.parameters().get(0);\n+\n+            var patternVar = fblock.op(var(fblock.op(constant(targetType, defaultValue(targetType)))));\n+\n+            var pattern = Body.Builder.of(fblock.parentBody(), functionType(ExtendedOp.Pattern.bindingType(targetType)));\n+            pattern.entryBlock().op(_yield(\n+                    pattern.entryBlock().op(typePattern(targetType, null))\n+            ));\n+\n+            var match = Body.Builder.of(fblock.parentBody(), functionType(JavaType.VOID, targetType));\n+            var binding = match.entryBlock().parameters().get(0);\n+            match.entryBlock().op(varStore(patternVar, binding));\n+            match.entryBlock().op(_yield());\n+\n+            var result = fblock.op(match(paramVal, pattern, match));\n+\n+            fblock.op(_return(result));\n+        });\n+    }\n+\n+    static Object defaultValue(JavaType t) {\n+        if (List.of(BYTE, SHORT, CHAR, INT).contains(t)) {\n+            return 0;\n+        } else if (LONG.equals(t)) {\n+            return 0L;\n+        } else if (FLOAT.equals(t)) {\n+            return 0f;\n+        } else if (DOUBLE.equals(t)) {\n+            return 0d;\n+        } else if (BOOLEAN.equals(t)) {\n+            return false;\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveTypePatterns.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}