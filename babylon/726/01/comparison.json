{"files":[{"patch":"@@ -131,1 +131,1 @@\n-    public static <T> T execute(OnnxFunction<T> codeLambda) {\n+    public static <T> T execute(Supplier<T> codeLambda) {\n@@ -135,1 +135,1 @@\n-    public static <T> T execute(MethodHandles.Lookup l, OnnxFunction<T> codeLambda) {\n+    public static <T> T execute(MethodHandles.Lookup l, Supplier<T> codeLambda) {\n@@ -162,1 +162,1 @@\n-    public static <T> T execute(Arena arena, MethodHandles.Lookup l, OnnxFunction<T> codeLambda) {\n+    public static <T> T execute(Arena arena, MethodHandles.Lookup l, Supplier<T> codeLambda) {\n@@ -166,1 +166,1 @@\n-    public static <T> T execute(Arena arena, MethodHandles.Lookup l, OnnxFunction<T> codeLambda, SessionOptions options) {\n+    public static <T> T execute(Arena arena, MethodHandles.Lookup l, Supplier<T> codeLambda, SessionOptions options) {\n@@ -440,5 +440,0 @@\n-    @FunctionalInterface\n-    @Reflect\n-    public interface OnnxFunction<T> extends Supplier<T> {\n-    }\n-\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.function.Supplier;\n@@ -373,1 +374,1 @@\n-            test(arena, inputImage -> OnnxRuntime.execute(arena, MethodHandles.lookup(), () ->\n+            test(arena, inputImage -> OnnxRuntime.execute(arena, MethodHandles.lookup(), (@Reflect Supplier<Tensor<Float>>) () ->\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    @Reflect\n@@ -58,0 +59,1 @@\n+    @Reflect\n@@ -72,0 +74,1 @@\n+    @Reflect\n@@ -85,0 +88,1 @@\n+    @Reflect\n@@ -98,0 +102,1 @@\n+    @Reflect\n@@ -111,0 +116,1 @@\n+    @Reflect\n@@ -124,0 +130,1 @@\n+    @Reflect\n@@ -139,0 +146,1 @@\n+    @Reflect\n@@ -152,0 +160,1 @@\n+    @Reflect\n@@ -166,0 +175,1 @@\n+    @Reflect\n@@ -192,0 +202,1 @@\n+    @Reflect\n@@ -218,0 +229,1 @@\n+    @Reflect\n@@ -239,0 +251,1 @@\n+    @Reflect\n@@ -261,0 +274,1 @@\n+    @Reflect\n@@ -289,0 +303,1 @@\n+    @Reflect\n@@ -309,0 +324,1 @@\n+    @Reflect\n@@ -324,0 +340,1 @@\n+    @Reflect\n@@ -335,0 +352,1 @@\n+    @Reflect\n@@ -349,0 +367,1 @@\n+    @Reflect\n@@ -359,0 +378,1 @@\n+    @Reflect\n@@ -372,0 +392,1 @@\n+    @Reflect\n@@ -388,0 +409,1 @@\n+    @Reflect\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Supplier;\n@@ -171,1 +172,1 @@\n-            var directions = execute(arena, MethodHandles.lookup(), () -> walkAroundTheMaze());\n+            var directions = execute(arena, MethodHandles.lookup(), (@Reflect Supplier<Tensor<Byte>>)() -> walkAroundTheMaze());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/WalkTheMazeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -128,1 +129,2 @@\n-        accelerator.compute(cc -> blackScholes(cc, call, put, S, X, T, r, v));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> blackScholes(cc, call, put, S, X, T, r, v));\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -94,1 +95,1 @@\n-        accelerator.compute(\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ForTests.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -99,1 +100,1 @@\n-        accelerator.compute(computeContext -> {\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer) computeContext -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -83,1 +84,2 @@\n-        accelerator.compute( cc -> LocalIds.mySimpleCompute(cc, arrayA, arrayB, arrayC));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> LocalIds.mySimpleCompute(cc, arrayA, arrayB, arrayC));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalIds.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -163,1 +164,2 @@\n-            accelerator.compute(cc -> Compute.buildMesh(cc, meshData));\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    cc -> Compute.buildMesh(cc, meshData));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -64,1 +65,2 @@\n-        accelerator.compute(cc -> Compute.add(cc, s32Array, len, valueToAdd));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> Compute.add(cc, s32Array, len, valueToAdd));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -382,1 +383,2 @@\n-        accelerator.compute(cc -> PrefixSum.compute(cc, input));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> PrefixSum.compute(cc, input));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -58,1 +59,2 @@\n-            accelerator.compute(computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out,lvar));\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out,lvar));\n@@ -61,1 +63,2 @@\n-                accelerator.compute(computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, array[index]));\n+                accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                        computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, array[index]));\n@@ -63,1 +66,2 @@\n-                accelerator.compute(computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, array[0]));\n+                accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                        computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, array[0]));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedArrayArg.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -55,1 +56,2 @@\n-            accelerator.compute(computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, value));\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, value));\n@@ -57,1 +59,2 @@\n-            accelerator.compute(computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, 1));\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    computeContext -> QuotedConstantArgs.addScalerCompute(computeContext, in, out, 1));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/QuotedConstantArgs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -155,1 +156,2 @@\n-        accelerator.compute( cc -> Reduction.mySimpleCompute(cc, input, partialSums));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> Reduction.mySimpleCompute(cc, input, partialSums));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Reduction.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import experiments.spirv.Bad.AcceleratorProxy.QuotableComputeConsumer;\n+import hat.Accelerator;\n@@ -34,1 +36,0 @@\n-        @Reflect\n@@ -41,1 +42,1 @@\n-        public void compute(AcceleratorProxy.QuotableComputeConsumer cqr) {\n+        public void compute(QuotableComputeConsumer cqr) {\n@@ -63,1 +64,2 @@\n-        accelerator.compute(cc -> MatrixMultiplyCompute.compute(cc, a, b, c, size));\n+        accelerator.compute((@Reflect QuotableComputeConsumer)\n+                cc -> MatrixMultiplyCompute.compute(cc, a, b, c, size));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/Bad.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -123,1 +124,2 @@\n-        accelerator.compute(cc -> MatrixMultiply.compute(cc, a, b, c, 100));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> MatrixMultiply.compute(cc, a, b, c, 100));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/GetBackend.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -135,1 +136,1 @@\n-        accelerator.compute(\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -323,2 +324,2 @@\n-            accelerator.compute(cc->\n-                    Compute.bestFitCompute(cc, bestMatchOffset, s32Array2D, searchArea, selectionBox, xyrgbList\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    cc -> Compute.bestFitCompute(cc, bestMatchOffset, s32Array2D, searchArea, selectionBox, xyrgbList\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Compute.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -258,1 +259,2 @@\n-         accelerator.compute(cc -> Compute.compute(cc, viewer, control, cellGrid));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> Compute.compute(cc, viewer, control, cellGrid));\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -101,1 +102,2 @@\n-        accelerator.compute(cc -> Main.compute(cc, pallette, s32Array2D, originX, originY, defaultScale));\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                cc -> Main.compute(cc, pallette, s32Array2D, originX, originY, defaultScale));\n@@ -131,1 +133,2 @@\n-                        accelerator.compute(cc -> Main.compute(cc, pallette, s32Array2D, fx, fy, fscale));\n+                        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                                cc -> Main.compute(cc, pallette, s32Array2D, fx, fy, fscale));\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -899,1 +900,1 @@\n-                case _1D -> accelerator.compute(cc ->\n+                case _1D -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -901,1 +902,1 @@\n-                case _1DFC -> accelerator.compute(cc ->\n+                case _1DFC -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -903,1 +904,1 @@\n-                case _2D -> accelerator.compute(cc ->\n+                case _2D -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -905,1 +906,1 @@\n-                case _2DLI -> accelerator.compute(cc ->\n+                case _2DLI -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -907,1 +908,1 @@\n-                case _2DTILING -> accelerator.compute(cc ->\n+                case _2DTILING -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -909,1 +910,1 @@\n-                case _2DREGISTER_TILING -> accelerator.compute(cc ->\n+                case _2DREGISTER_TILING -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -911,1 +912,1 @@\n-                case _2DREGISTER_TILING_VECTORIZED -> accelerator.compute(cc ->\n+                case _2DREGISTER_TILING_VECTORIZED -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n@@ -913,1 +914,1 @@\n-                case _2DREGISTER_TILING_FP16 -> accelerator.compute(cc ->\n+                case _2DREGISTER_TILING_FP16 -> accelerator.compute((@Reflect QuotableComputeContextConsumer) cc ->\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -371,1 +372,2 @@\n-            accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -65,1 +66,1 @@\n-        accelerator.compute(\n+        accelerator.compute((@Reflect QuotableComputeContextConsumer)\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.Accelerator.QuotableComputeContextConsumer;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -71,1 +73,2 @@\n-            accelerator.compute(cc -> ViolaJonesCoreCompute.compute(cc, cascade, rgbImage, resultTable,scaleTable));\n+            accelerator.compute((@Reflect QuotableComputeContextConsumer)\n+                    cc -> ViolaJonesCoreCompute.compute(cc, cascade, rgbImage, resultTable,scaleTable));\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/Main.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    @Reflect\n@@ -99,0 +100,1 @@\n+    @Reflect\n@@ -129,0 +131,1 @@\n+    @Reflect\n@@ -278,0 +281,1 @@\n+    @Reflect\n@@ -398,0 +402,1 @@\n+    @Reflect\n@@ -524,0 +529,1 @@\n+    @Reflect\n@@ -631,0 +637,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    @Reflect\n@@ -125,0 +126,1 @@\n+    @Reflect\n@@ -151,0 +153,1 @@\n+    @Reflect\n@@ -181,0 +184,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrays.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -343,0 +343,1 @@\n+    @Reflect\n@@ -362,0 +363,1 @@\n+    @Reflect\n@@ -387,0 +389,1 @@\n+    @Reflect\n@@ -414,0 +417,1 @@\n+    @Reflect\n@@ -449,0 +453,1 @@\n+    @Reflect\n@@ -469,0 +474,1 @@\n+    @Reflect\n@@ -489,0 +495,1 @@\n+    @Reflect\n@@ -507,0 +514,1 @@\n+    @Reflect\n@@ -527,0 +535,1 @@\n+    @Reflect\n@@ -548,0 +557,1 @@\n+    @Reflect\n@@ -562,0 +572,1 @@\n+    @Reflect\n@@ -582,0 +593,1 @@\n+    @Reflect\n@@ -604,0 +616,1 @@\n+    @Reflect\n@@ -626,0 +639,1 @@\n+    @Reflect\n@@ -647,0 +661,1 @@\n+    @Reflect\n@@ -668,0 +683,1 @@\n+    @Reflect\n@@ -684,0 +700,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBFloat16Type.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBlackscholes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+    @Reflect\n@@ -115,0 +116,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestConstants.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.code.Reflect;\n+\n@@ -72,0 +74,1 @@\n+    @Reflect\n@@ -107,0 +110,1 @@\n+    @Reflect\n@@ -150,0 +154,1 @@\n+    @Reflect\n@@ -189,0 +194,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestDeviceType.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -390,0 +390,1 @@\n+    @Reflect\n@@ -410,0 +411,1 @@\n+    @Reflect\n@@ -437,0 +439,1 @@\n+    @Reflect\n@@ -464,0 +467,1 @@\n+    @Reflect\n@@ -499,0 +503,1 @@\n+    @Reflect\n@@ -519,0 +524,1 @@\n+    @Reflect\n@@ -539,0 +545,1 @@\n+    @Reflect\n@@ -557,0 +564,1 @@\n+    @Reflect\n@@ -577,0 +585,1 @@\n+    @Reflect\n@@ -598,0 +607,1 @@\n+    @Reflect\n@@ -612,0 +622,1 @@\n+    @Reflect\n@@ -632,0 +643,1 @@\n+    @Reflect\n@@ -654,0 +666,1 @@\n+    @Reflect\n@@ -676,0 +689,1 @@\n+    @Reflect\n@@ -697,0 +711,1 @@\n+    @Reflect\n@@ -717,0 +732,1 @@\n+@Reflect\n@@ -741,0 +757,1 @@\n+    @Reflect\n@@ -756,0 +773,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestF16Type.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+    @Reflect\n@@ -368,0 +369,1 @@\n+    @Reflect\n@@ -388,0 +390,1 @@\n+    @Reflect\n@@ -408,0 +411,1 @@\n+    @Reflect\n@@ -428,0 +432,1 @@\n+    @Reflect\n@@ -449,0 +454,1 @@\n+    @Reflect\n@@ -470,0 +476,1 @@\n+    @Reflect\n@@ -491,0 +498,1 @@\n+    @Reflect\n@@ -513,0 +521,1 @@\n+    @Reflect\n@@ -535,0 +544,1 @@\n+    @Reflect\n@@ -555,0 +565,1 @@\n+    @Reflect\n@@ -575,0 +586,1 @@\n+    @Reflect\n@@ -595,0 +607,1 @@\n+    @Reflect\n@@ -626,0 +639,1 @@\n+    @Reflect\n@@ -644,0 +658,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestFloat2.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMandel.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -289,0 +289,1 @@\n+    @Reflect\n@@ -323,0 +324,1 @@\n+    @Reflect\n@@ -358,0 +360,1 @@\n+    @Reflect\n@@ -392,0 +395,1 @@\n+    @Reflect\n@@ -426,0 +430,1 @@\n+    @Reflect\n@@ -463,0 +468,1 @@\n+    @Reflect\n@@ -755,0 +761,1 @@\n+    @Reflect\n@@ -789,0 +796,1 @@\n+    @Reflect\n@@ -1112,0 +1120,1 @@\n+    @Reflect\n@@ -1147,0 +1156,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestMatMul.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestNbody.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+    @Reflect\n@@ -105,0 +106,1 @@\n+    @Reflect\n@@ -123,0 +125,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestParenthesis.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestPrivate.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+    @Reflect\n@@ -173,0 +174,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestReductions.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.code.Reflect;\n+\n@@ -405,0 +407,1 @@\n+    @Reflect\n@@ -427,0 +430,1 @@\n+    \/\/ @Reflect\n@@ -449,0 +453,1 @@\n+    \/\/ @Reflect\n@@ -471,0 +476,1 @@\n+    @Reflect\n@@ -493,0 +499,1 @@\n+    @Reflect\n@@ -515,0 +522,1 @@\n+    @Reflect\n@@ -537,0 +545,1 @@\n+    @Reflect\n@@ -558,0 +567,1 @@\n+    @Reflect\n@@ -579,0 +589,1 @@\n+    @Reflect\n@@ -600,0 +611,1 @@\n+    @Reflect\n@@ -622,0 +634,1 @@\n+    @Reflect\n@@ -644,0 +657,1 @@\n+    @Reflect\n@@ -664,0 +678,1 @@\n+    @Reflect\n@@ -684,0 +699,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorArrayView.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+    @Reflect\n@@ -372,0 +373,1 @@\n+    @Reflect\n@@ -394,0 +396,1 @@\n+    @Reflect\n@@ -416,0 +419,1 @@\n+    @Reflect\n@@ -438,0 +442,1 @@\n+    @Reflect\n@@ -459,0 +464,1 @@\n+    @Reflect\n@@ -480,0 +486,1 @@\n+    @Reflect\n@@ -501,0 +508,1 @@\n+    @Reflect\n@@ -523,0 +531,1 @@\n+    @Reflect\n@@ -545,0 +554,1 @@\n+    @Reflect\n@@ -565,0 +575,1 @@\n+    @Reflect\n@@ -585,0 +596,1 @@\n+    @Reflect\n@@ -605,0 +617,1 @@\n+    @Reflect\n@@ -646,0 +659,1 @@\n+    @Reflect\n@@ -664,0 +678,1 @@\n+    @Reflect\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorTypes.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4324,2 +4324,2 @@\n-compiler.err.quoted.method.inner.class=\\\n-    unsupported quoted method in inner class {0}\n+compiler.warn.reflectable.method.inner.class=\\\n+    unsupported reflectable method in inner class {0}\n@@ -4328,2 +4328,2 @@\n-compiler.err.quoted.lambda.inner.class=\\\n-    unsupported quoted lambda in inner class {0}\n+compiler.warn.reflectable.lambda.inner.class=\\\n+    unsupported reflectable lambda in inner class {0}\n@@ -4332,2 +4332,2 @@\n-compiler.err.quoted.mref.inner.class=\\\n-    unsupported quoted method reference in inner class {0}\n+compiler.warn.reflectable.mref.inner.class=\\\n+    unsupported reflectable method reference in inner class {0}\n@@ -4339,2 +4339,2 @@\n-compiler.note.method.ir.dump=\\\n-    code reflection enabled for method {0}.{1}\\n\\\n+compiler.note.reflectable.method.ir.dump=\\\n+    reflectable method found {0}.{1}\\n\\\n@@ -4344,2 +4344,7 @@\n-compiler.note.quoted.ir.dump=\\\n-    code reflection enabled for method quoted lambda\\n\\\n+compiler.note.reflectable.lambda.ir.dump=\\\n+    reflectable lambda found\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.reflectable.mref.ir.dump=\\\n+    reflectable method reference found\\n\\\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.Method;\n@@ -31,1 +32,16 @@\n- * Enables code reflection for a method annotated with this annotation.\n+ * A program element annotated with this annotation enables code reflection in the annotated program element,\n+ * or in one or more program elements contained within the annotated program element.\n+ * <p>\n+ * The program elements for which code reflection is enabled are said to be a <em>reflectable<\/em> program elements.\n+ * There are three kinds of reflectable program elements: methods, lambda expressions and method references.\n+ * Code models for reflectable methods can be obtained using the {@link Op#ofMethod(Method)} method. Code\n+ * models for reflectable lambdas and method references can be obtained using the {@link Op#ofQuotable(Object)} method.\n+ * <p>\n+ * This annotation only has effect on the program elements listed below:\n+ * <li>When a method is annotated with this annotation, the method becomes reflectable, and all the lambda expressions\n+ * and method references enclosed in it also become reflectable.<\/li>\n+ * <li>When a variable declaration (a field, or a local variable) is annotated with this annotation, all lambda expressions\n+ * and method references enclosed in the variable initializer (if present) also become reflectable.<\/li>\n+ * <li>When the type of a cast expression is annotated with this annotation, the lambda expression\n+ * or method reference the cast refers to (if any) becomes reflectable.<\/li>\n+ * <\/ul>\n@@ -33,1 +49,2 @@\n-@Target({ElementType.METHOD, ElementType.TYPE_USE, ElementType.TYPE})\n+@Target({ElementType.LOCAL_VARIABLE, ElementType.FIELD,\n+         ElementType.METHOD, ElementType.TYPE_USE})\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Reflect.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import com.sun.tools.javac.comp.Resolve;\n@@ -103,0 +102,1 @@\n+import java.util.List;\n@@ -116,2 +116,0 @@\n-import static com.sun.tools.javac.resources.CompilerProperties.Errors.*;\n-import static com.sun.tools.javac.resources.CompilerProperties.Notes.*;\n@@ -130,0 +128,3 @@\n+import static com.sun.tools.javac.resources.CompilerProperties.Notes.*;\n+import static com.sun.tools.javac.resources.CompilerProperties.Warnings.*;\n+\n@@ -148,1 +149,0 @@\n-    private final Resolve resolve;\n@@ -157,1 +157,0 @@\n-    private final CodeModelStorageOption codeModelStorageOption;\n@@ -165,0 +164,1 @@\n+    private boolean codeReflectionEnabled = false;\n@@ -175,1 +175,0 @@\n-        codeModelStorageOption = CodeModelStorageOption.parse(options.get(\"codeModelStorageOption\"));\n@@ -178,1 +177,0 @@\n-        resolve = Resolve.instance(context);\n@@ -188,0 +186,12 @@\n+    @Override\n+    public void visitVarDef(JCVariableDecl tree) {\n+        boolean prevCodeReflectionEnabled = codeReflectionEnabled;\n+        try {\n+            codeReflectionEnabled = codeReflectionEnabled ||\n+                    tree.sym.attribute(crSyms.codeReflectionType.tsym) != null;\n+            super.visitVarDef(tree);\n+        } finally {\n+            codeReflectionEnabled = prevCodeReflectionEnabled;\n+        }\n+    }\n+\n@@ -190,1 +200,2 @@\n-        if (tree.sym.attribute(crSyms.codeReflectionType.tsym) != null) {\n+        boolean isReflectable = isReflectable(tree);\n+        if (isReflectable) {\n@@ -192,2 +203,4 @@\n-                \/\/ Reflectable methods in inner classes are not supported\n-                log.error(tree, QuotedMethodInnerClass(currentClassSym.enclClass()));\n+                \/\/ Reflectable methods in local classes are not supported\n+                log.warning(tree, ReflectableMethodInnerClass(currentClassSym.enclClass()));\n+                super.visitMethodDef(tree);\n+                return;\n@@ -200,1 +213,1 @@\n-                    log.note(MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                    log.note(ReflectableMethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n@@ -208,1 +221,7 @@\n-        super.visitMethodDef(tree);\n+        boolean prevCodeReflectionEnabled = codeReflectionEnabled;\n+        try {\n+            codeReflectionEnabled = isReflectable;\n+            super.visitMethodDef(tree);\n+        } finally {\n+            codeReflectionEnabled = prevCodeReflectionEnabled;\n+        }\n@@ -269,1 +288,2 @@\n-        if (isQuotable(tree, prevNode())) {\n+        boolean isReflectable = isReflectable(tree);\n+        if (isReflectable) {\n@@ -271,2 +291,3 @@\n-                \/\/ Quotable lambdas in inner classes are not supported\n-                log.error(tree, QuotedLambdaInnerClass(currentClassSym.enclClass()));\n+                \/\/ Reflectable lambdas in local classes are not supported\n+                log.warning(tree, ReflectableLambdaInnerClass(currentClassSym.enclClass()));\n+                super.visitLambda(tree);\n@@ -281,1 +302,1 @@\n-                log.note(QuotedIrDump(funcOp.toText()));\n+                log.note(ReflectableLambdaIrDump(funcOp.toText()));\n@@ -292,1 +313,7 @@\n-        super.visitLambda(tree);\n+        boolean prevCodeReflectionEnabled = codeReflectionEnabled;\n+        try {\n+            codeReflectionEnabled = isReflectable;\n+            super.visitLambda(tree);\n+        } finally {\n+            codeReflectionEnabled = prevCodeReflectionEnabled;\n+        }\n@@ -300,1 +327,1 @@\n-        if (isQuotable(tree, prevNode())) {\n+        if (isReflectable(tree)) {\n@@ -302,2 +329,3 @@\n-                \/\/ Quotable lambdas in inner classes are not supported\n-                log.error(tree, QuotedMrefInnerClass(currentClassSym.enclClass()));\n+                \/\/ Reflectable method references in local classes are not supported\n+                log.warning(tree, ReflectableMrefInnerClass(currentClassSym.enclClass()));\n+                super.visitReference(tree);\n@@ -312,1 +340,1 @@\n-                log.note(QuotedIrDump(funcOp.toText()));\n+                log.note(ReflectableMrefIrDump(funcOp.toText()));\n@@ -1008,1 +1036,1 @@\n-                case INTERFACE, CLASS, RECORD, ENUM -> {\n+                case PACKAGE, INTERFACE, CLASS, RECORD, ENUM -> {\n@@ -1068,1 +1096,1 @@\n-                    case INTERFACE, CLASS, RECORD, ENUM -> {\n+                    case PACKAGE, INTERFACE, CLASS, RECORD, ENUM -> {\n@@ -1471,1 +1499,1 @@\n-            Op lambdaOp = JavaOp.lambda(fiType, stack.body, isQuotable(tree, prevNode()));\n+            Op lambdaOp = JavaOp.lambda(fiType, stack.body, true);\n@@ -2477,0 +2505,11 @@\n+\n+        @Override\n+        public String toString() {\n+            return super.toString() + \":\" + tree;\n+        }\n+    }\n+\n+    boolean isReflectable(JCMethodDecl tree) {\n+        return codeReflectionEnabled ||\n+                (tree.body != null &&\n+                tree.sym.attribute(crSyms.codeReflectionType.tsym) != null);\n@@ -2479,3 +2518,3 @@\n-    boolean isQuotable(JCFunctionalExpression expr, JCTree prev) {\n-        return isQuotable(expr.target, true) ||\n-                (prev instanceof JCTypeCast castTree && isQuotable(castTree.clazz.type, false));\n+    boolean isReflectable(JCFunctionalExpression expr) {\n+        return codeReflectionEnabled ||\n+                (prevNode() instanceof JCTypeCast castTree && isReflectable(castTree.clazz.type));\n@@ -2484,1 +2523,1 @@\n-    boolean isQuotable(Type target, boolean declAnnos) {\n+    boolean isReflectable(Type target) {\n@@ -2487,1 +2526,1 @@\n-                    .anyMatch(t -> isQuotable(t, declAnnos));\n+                    .anyMatch(this::isReflectable);\n@@ -2489,3 +2528,2 @@\n-            return declAnnos ?\n-                    target.tsym.attribute(crSyms.codeReflectionType.tsym) != null :\n-                    target.getAnnotationMirrors().stream().anyMatch(tc -> tc.type.tsym == crSyms.codeReflectionType.tsym);\n+            return target.getAnnotationMirrors().stream()\n+                    .anyMatch(tc -> tc.type.tsym == crSyms.codeReflectionType.tsym);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":70,"deletions":32,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-    @FunctionalInterface\n@@ -165,7 +164,2 @@\n-    public interface QuotableIntSupplier extends IntSupplier {\n-    }\n-\n-    @Reflect\n-    static QuotableIntSupplier quote(int i) {\n-        QuotableIntSupplier s = () -> i;\n-        return s;\n+    static IntSupplier quote(int i) {\n+        return () -> i;\n@@ -180,1 +174,1 @@\n-            QuotableIntSupplier op = (QuotableIntSupplier) Interpreter.invoke(MethodHandles.lookup(), g, 42);\n+            IntSupplier op = (IntSupplier) Interpreter.invoke(MethodHandles.lookup(), g, 42);\n@@ -198,1 +192,1 @@\n-            QuotableIntSupplier op = quote(42);\n+            IntSupplier op = quote(42);\n@@ -217,9 +211,0 @@\n-    @Reflect\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator {}\n-\n-    @Reflect\n-    interface QuotableFunction<T, R> extends Function<T, R> {}\n-\n-    @Reflect\n-    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R> {}\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator {}\n-\n-    @Reflect\n-    interface QuotableFunction<T, R> extends Function<T, R> {}\n-\n-    @Reflect\n-    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R> {}\n-\n@@ -60,6 +52,6 @@\n-                (QuotableIntUnaryOperator) TestMethodRefLambda::m1,\n-                (QuotableIntUnaryOperator) TestMethodRefLambda::m2,\n-                (QuotableFunction<Integer, Integer>) TestMethodRefLambda::m1,\n-                (QuotableFunction<Integer, Integer>) TestMethodRefLambda::m2,\n-                (QuotableIntUnaryOperator) this::m3,\n-                (QuotableBiFunction<TestMethodRefLambda, Integer, Integer>) TestMethodRefLambda::m4\n+                (IntUnaryOperator) TestMethodRefLambda::m1,\n+                (IntUnaryOperator) TestMethodRefLambda::m2,\n+                (Function<Integer, Integer>) TestMethodRefLambda::m1,\n+                (Function<Integer, Integer>) TestMethodRefLambda::m2,\n+                (IntUnaryOperator) this::m3,\n+                (BiFunction<TestMethodRefLambda, Integer, Integer>) TestMethodRefLambda::m4\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestMethodRefLambda.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.function.IntUnaryOperator;\n@@ -375,14 +376,1 @@\n-    public interface Func {\n-        int apply(int a);\n-    }\n-\n-    @Reflect\n-    public interface QuotableFunc {\n-        int apply(int a);\n-    }\n-\n-    static int consume(int i, Func f) {\n-        return f.apply(i + 1);\n-    }\n-\n-    static int consumeQuotable(int i, QuotableFunc f) {\n+    static int consumeQuotable(int i, IntUnaryOperator f) {\n@@ -392,6 +380,1 @@\n-        return f.apply(i + 1);\n-    }\n-\n-    @Reflect\n-    static int lambda(int i) {\n-        return consume(i, a -> -a);\n+        return f.applyAsInt(i + 1);\n@@ -405,5 +388,0 @@\n-    @Reflect\n-    static int lambdaWithCapture(int i, String s) {\n-        return consume(i, a -> a + s.length());\n-    }\n-\n@@ -415,5 +393,0 @@\n-    @Reflect\n-    static int nestedLambdasWithCaptures(int i, int j, String s) {\n-        return consume(i, a -> consume(a, b -> a + b + j - s.length()) + s.length());\n-    }\n-\n@@ -427,1 +400,1 @@\n-        return consume(i, Math::negateExact);\n+        return consumeQuotable(i, Math::negateExact);\n@@ -436,1 +409,1 @@\n-        return consume(i, this::instanceMethod);\n+        return consumeQuotable(i, this::instanceMethod);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.function.IntUnaryOperator;\n@@ -371,14 +372,1 @@\n-    public interface Func {\n-        int apply(int a);\n-    }\n-\n-    @Reflect\n-    public interface QuotableFunc {\n-        int apply(int a);\n-    }\n-\n-    static int consume(int i, Func f) {\n-        return f.apply(i + 1);\n-    }\n-\n-    static int consumeQuotable(int i, QuotableFunc f) {\n+    static int consumeQuotable(int i, IntUnaryOperator f) {\n@@ -388,6 +376,1 @@\n-        return f.apply(i + 1);\n-    }\n-\n-    @Reflect\n-    static int lambda(int i) {\n-        return consume(i, a -> -a);\n+        return f.applyAsInt(i + 1);\n@@ -401,5 +384,0 @@\n-    @Reflect\n-    static int lambdaWithCapture(int i, String s) {\n-        return consume(i, a -> a + s.length());\n-    }\n-\n@@ -411,5 +389,0 @@\n-    @Reflect\n-    static int nestedLambdasWithCaptures(int i, int j, String s) {\n-        return consume(i, a -> consume(a, b -> a + b + j - s.length()) + s.length());\n-    }\n-\n@@ -423,1 +396,1 @@\n-        return consume(i, Math::negateExact);\n+        return consumeQuotable(i, Math::negateExact);\n@@ -432,1 +405,1 @@\n-        return consume(i, this::instanceMethod);\n+        return consumeQuotable(i, this::instanceMethod);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/TestBytecodeLift.java","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n@@ -50,1 +53,1 @@\n-    default Queryable<T> where(QuotablePredicate<T> f) {\n+    default Queryable<T> where(Predicate<T> f) {\n@@ -56,1 +59,1 @@\n-    default <R> Queryable<R> select(QuotableFunction<T, R> f) {\n+    default <R> Queryable<R> select(Function<T, R> f) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-\n-import java.util.function.Function;\n-\n-@FunctionalInterface\n-@Reflect\n-public interface QuotableFunction<T, R> extends Function<T, R> {\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotableFunction.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-\n-import java.util.function.Predicate;\n-\n-@FunctionalInterface\n-@Reflect\n-public interface QuotablePredicate<T> extends Predicate<T> {\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotablePredicate.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -49,0 +50,1 @@\n+        @Reflect\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestLinq.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,23 +44,0 @@\n-    \/\/ Quotable functional interfaces\n-\n-    @Reflect\n-    public interface QuotablePredicate<T> extends Predicate<T> {\n-    }\n-\n-    @Reflect\n-    public interface QuotableFunction<T, R> extends Function<T, R> {\n-    }\n-\n-    @Reflect\n-    public interface QuotableSupplier<T> extends Supplier<T> {\n-    }\n-\n-    @Reflect\n-    public interface QuotableConsumer<T> extends Consumer<T> {\n-    }\n-\n-    @Reflect\n-    public interface QuotableBiConsumer<T, U> extends BiConsumer<T, U> {\n-    }\n-\n-\n@@ -139,1 +116,1 @@\n-        public <R> StreamExprBuilder<R> map(QuotableFunction<T, R> f) {\n+        public <R> StreamExprBuilder<R> map(Function<T, R> f) {\n@@ -145,1 +122,1 @@\n-        public <R> StreamExprBuilder<R> flatMap(QuotableFunction<T, Iterable<R>> f) {\n+        public <R> StreamExprBuilder<R> flatMap(Function<T, Iterable<R>> f) {\n@@ -150,1 +127,1 @@\n-        public StreamExprBuilder<T> filter(QuotablePredicate<T> f) {\n+        public StreamExprBuilder<T> filter(Predicate<T> f) {\n@@ -207,1 +184,1 @@\n-        public FuncOp forEach(QuotableConsumer<T> quotableConsumer) {\n+        public FuncOp forEach(Consumer<T> quotableConsumer) {\n@@ -234,1 +211,1 @@\n-        public <C> FuncOp collect(QuotableSupplier<C> quotableSupplier, QuotableBiConsumer<C, T> quotableAccumulator) {\n+        public <C> FuncOp collect(Supplier<C> quotableSupplier, BiConsumer<C, T> quotableAccumulator) {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -45,0 +46,1 @@\n+        @Reflect\n@@ -65,0 +67,1 @@\n+        @Reflect\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -227,5 +227,6 @@\n-compiler.note.method.ir.dump\n-compiler.note.quoted.ir.dump\n-compiler.err.quoted.method.inner.class\n-compiler.err.quoted.lambda.inner.class\n-compiler.err.quoted.mref.inner.class\n+compiler.note.reflectable.method.ir.dump\n+compiler.note.reflectable.lambda.ir.dump\n+compiler.note.reflectable.mref.ir.dump\n+compiler.warn.reflectable.method.inner.class\n+compiler.warn.reflectable.lambda.inner.class\n+compiler.warn.reflectable.mref.inner.class\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda ()java.type:\"java.lang.Integer\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n@@ -282,1 +282,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda ()java.type:\"java.lang.Integer\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            error(\"No @IR annotation found on reflective method\");\n+            \/\/ nothing to check\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                        %9 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda ()java.type:\"java.lang.Double\" -> {\n+                        %9 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Double\" -> {\n@@ -115,1 +115,1 @@\n-                        %13 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda ()java.type:\"java.lang.Double\" -> {\n+                        %13 : java.type:\"java.util.function.Supplier<java.lang.Double>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Double\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalExpressionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-                        %5 : java.type:\"java.util.function.Predicate<java.lang.String>\" = lambda (%6 : java.type:\"java.lang.String\")java.type:\"boolean\" -> {\n+                        %5 : java.type:\"java.util.function.Predicate<java.lang.String>\" = lambda @lambda.isQuotable=true (%6 : java.type:\"java.lang.String\")java.type:\"boolean\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-                %1 : java.type:\"java.util.function.LongSupplier\" = lambda ()java.type:\"long\" -> {\n+                %1 : java.type:\"java.util.function.LongSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"long\" -> {\n@@ -200,1 +200,1 @@\n-                %1 : java.type:\"java.util.function.LongSupplier\" = lambda ()java.type:\"long\" -> {\n+                %1 : java.type:\"java.util.function.LongSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"long\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                %4 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                %4 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -111,1 +111,1 @@\n-                %10 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                %10 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -120,1 +120,1 @@\n-                %16 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                %16 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -248,1 +248,1 @@\n-                %10 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                %10 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -257,1 +257,1 @@\n-                %16 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                %16 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n@@ -266,1 +266,1 @@\n-                %22 : java.type:\"java.lang.Runnable\" = lambda ()java.type:\"void\" -> {\n+                %22 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -66,1 +66,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n@@ -87,1 +87,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n@@ -104,1 +104,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n@@ -125,1 +125,1 @@\n-                %7 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda ()java.type:\"java.lang.Integer\" -> {\n+                %7 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n@@ -128,1 +128,1 @@\n-                    %10 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda ()java.type:\"java.lang.Integer\" -> {\n+                    %10 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n@@ -173,1 +173,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda ()java.type:\"java.lang.Integer\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.Integer>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.Integer\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n- * @build MethodReferenceTest\n- * @build CodeReflectionTester\n- * @run main CodeReflectionTester MethodReferenceTest\n+ * @compile MethodReferenceTest.java\n@@ -49,1 +47,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -66,1 +64,1 @@\n-                %1 : java.type:\"java.util.function.BiConsumer<MethodReferenceTest, java.lang.String>\" = lambda (%2 : java.type:\"MethodReferenceTest\", %3 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.BiConsumer<MethodReferenceTest, java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"MethodReferenceTest\", %3 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -85,1 +83,1 @@\n-                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %1 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -111,1 +109,1 @@\n-                %4 : java.type:\"java.util.function.Function<java.lang.String, java.lang.String>\" = lambda (%5 : java.type:\"java.lang.String\")java.type:\"java.lang.String\" -> {\n+                %4 : java.type:\"java.util.function.Function<java.lang.String, java.lang.String>\" = lambda @lambda.isQuotable=true (%5 : java.type:\"java.lang.String\")java.type:\"java.lang.String\" -> {\n@@ -131,1 +129,1 @@\n-                %3 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda (%4 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n+                %3 : java.type:\"java.util.function.Consumer<java.lang.String>\" = lambda @lambda.isQuotable=true (%4 : java.type:\"java.lang.String\")java.type:\"void\" -> {\n@@ -153,1 +151,1 @@\n-                %1 : java.type:\"java.util.function.Function<java.lang.Integer, MethodReferenceTest$X>\" = lambda (%2 : java.type:\"java.lang.Integer\")java.type:\"MethodReferenceTest$X\" -> {\n+                %1 : java.type:\"java.util.function.Function<java.lang.Integer, MethodReferenceTest$X>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"java.lang.Integer\")java.type:\"MethodReferenceTest$X\" -> {\n@@ -171,1 +169,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<MethodReferenceTest::A<java.lang.String>>\" = lambda ()java.type:\"MethodReferenceTest::A<java.lang.String>\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<MethodReferenceTest::A<java.lang.String>>\" = lambda @lambda.isQuotable=true ()java.type:\"MethodReferenceTest::A<java.lang.String>\" -> {\n@@ -186,1 +184,1 @@\n-                %1 : java.type:\"java.util.function.IntFunction<MethodReferenceTest::A<java.lang.String>[]>\" = lambda (%2 : java.type:\"int\")java.type:\"MethodReferenceTest::A<java.lang.String>[]\" -> {\n+                %1 : java.type:\"java.util.function.IntFunction<MethodReferenceTest::A<java.lang.String>[]>\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"MethodReferenceTest::A<java.lang.String>[]\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda ()java.type:\"java.lang.String\" -> {\n+                %1 : java.type:\"java.util.function.Supplier<java.lang.String>\" = lambda @lambda.isQuotable=true ()java.type:\"java.lang.String\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,336 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Smoke test for code reflection with quotable lambdas.\n- * @modules jdk.incubator.code\n- * @build QuotableSubtypeTest\n- * @build CodeReflectionTester\n- * @run main CodeReflectionTester QuotableSubtypeTest\n- *\/\n-\n-import jdk.incubator.code.Reflect;\n-import java.util.function.IntBinaryOperator;\n-import java.util.function.IntFunction;\n-import java.util.function.IntSupplier;\n-import java.util.function.IntUnaryOperator;\n-\n-public class QuotableSubtypeTest {\n-\n-    @Reflect\n-    interface QuotableRunnable extends Runnable { }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                    return;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableRunnable QUOTED_NO_PARAM_VOID = () -> { };\n-\n-    @Reflect\n-    interface QuotableIntSupplier extends IntSupplier { }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableIntSupplier\" = lambda @lambda.isQuotable=true ()java.type:\"int\" -> {\n-                    %1 : java.type:\"int\" = constant @1;\n-                    return %1;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntSupplier QUOTED_NO_PARAM_CONST = () -> 1;\n-\n-    @Reflect\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator { }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n-                    %2 : Var<java.type:\"int\"> = var %1 @\"x\";\n-                    %3 : java.type:\"int\" = var.load %2;\n-                    return %3;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntUnaryOperator QUOTED_ID = x -> x;\n-\n-    @Reflect\n-    interface QuotableIntBinaryOperator extends IntBinaryOperator { }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableIntBinaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\", %2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %1 @\"x\";\n-                    %4 : Var<java.type:\"int\"> = var %2 @\"y\";\n-                    %5 : java.type:\"int\" = var.load %3;\n-                    %6 : java.type:\"int\" = var.load %4;\n-                    %7 : java.type:\"int\" = add %5 %6;\n-                    return %7;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntBinaryOperator QUOTED_PLUS = (x, y) -> x + y;\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                    %1 : java.type:\"java.lang.AssertionError\" = new @java.ref:\"java.lang.AssertionError::()\";\n-                    throw %1;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableRunnable QUOTED_THROW_NO_PARAM = () -> { throw new AssertionError(); };\n-\n-    @IR(\"\"\"\n-            func @\"f\" (%0 : Var<java.type:\"int\">)java.type:\"void\" -> {\n-                %1 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"y\";\n-                    %4 : java.type:\"int\" = var.load %0;\n-                    %5 : java.type:\"int\" = var.load %3;\n-                    %6 : java.type:\"int\" = add %4 %5;\n-                    return %6;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntUnaryOperator QUOTED_CAPTURE_PARAM = new Object() {\n-        QuotableIntUnaryOperator captureContext(int x) {\n-            return y -> x + y;\n-        }\n-    }.captureContext(42);\n-\n-    static class Context {\n-        int x, y;\n-\n-        QuotableIntUnaryOperator capture() {\n-            return z -> x + y + z;\n-        }\n-    }\n-\n-    @IR(\"\"\"\n-            func @\"f\" (%0 : java.type:\"QuotableSubtypeTest$Context\")java.type:\"void\" -> {\n-                %1 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"z\";\n-                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableSubtypeTest$Context::x:int\";\n-                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableSubtypeTest$Context::y:int\";\n-                    %6 : java.type:\"int\" = add %4 %5;\n-                    %7 : java.type:\"int\" = var.load %3;\n-                    %8 : java.type:\"int\" = add %6 %7;\n-                    return %8;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntUnaryOperator QUOTED_CAPTURE_FIELD = new Context().capture();\n-\n-    @Reflect\n-    @IR(\"\"\"\n-            func @\"captureParam\" (%0 : java.type:\"int\")java.type:\"void\" -> {\n-                %1 : Var<java.type:\"int\"> = var %0 @\"x\";\n-                %2 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%3 : java.type:\"int\")java.type:\"int\" -> {\n-                    %4 : Var<java.type:\"int\"> = var %3 @\"y\";\n-                    %5 : java.type:\"int\" = var.load %1;\n-                    %6 : java.type:\"int\" = var.load %4;\n-                    %7 : java.type:\"int\" = add %5 %6;\n-                    return %7;\n-                };\n-                %8 : Var<java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\"> = var %2 @\"op\";\n-                return;\n-            };\n-            \"\"\")\n-    static void captureParam(int x) {\n-        QuotableIntUnaryOperator op = y -> x + y;\n-    }\n-\n-    int x, y;\n-\n-    @Reflect\n-    @IR(\"\"\"\n-            func @\"captureField\" (%0 : java.type:\"QuotableSubtypeTest\")java.type:\"void\" -> {\n-                %1 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"z\";\n-                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableSubtypeTest::x:int\";\n-                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableSubtypeTest::y:int\";\n-                    %6 : java.type:\"int\" = add %4 %5;\n-                    %7 : java.type:\"int\" = var.load %3;\n-                    %8 : java.type:\"int\" = add %6 %7;\n-                    return %8;\n-                };\n-                %9 : Var<java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\"> = var %1 @\"op\";\n-                return;\n-            };\n-            \"\"\")\n-    void captureField() {\n-        QuotableIntUnaryOperator op = z -> x + y + z;\n-    }\n-\n-    static void m() { }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                    invoke @java.ref:\"QuotableSubtypeTest::m():void\";\n-                    return;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableRunnable QUOTED_NO_PARAM_VOID_REF = QuotableSubtypeTest::m;\n-\n-    static int g(int i) { return i; }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n-                    %2 : Var<java.type:\"int\"> = var %1 @\"x$0\";\n-                    %3 : java.type:\"int\" = var.load %2;\n-                    %4 : java.type:\"int\" = invoke %3 @java.ref:\"QuotableSubtypeTest::g(int):int\";\n-                    return %4;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntUnaryOperator QUOTED_INT_PARAM_INT_RET_REF = QuotableSubtypeTest::g;\n-\n-    @Reflect\n-    interface QuotableIntFunction<A> extends IntFunction<A> { }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                %0 : java.type:\"QuotableSubtypeTest$QuotableIntFunction<int[]>\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int[]\" -> {\n-                    %2 : Var<java.type:\"int\"> = var %1 @\"x$0\";\n-                    %3 : java.type:\"int\" = var.load %2;\n-                    %4 : java.type:\"int[]\" = new %3 @java.ref:\"int[]::(int)\";\n-                    return %4;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntFunction<int[]> QUOTED_INT_PARAM_ARR_RET_REF = int[]::new;\n-\n-    static class ContextRef {\n-        int g(int i) { return i; }\n-\n-        QuotableIntUnaryOperator capture() {\n-            return this::g;\n-        }\n-    }\n-\n-    @IR(\"\"\"\n-            func @\"f\" (%0 : java.type:\"QuotableSubtypeTest$ContextRef\")java.type:\"void\" -> {\n-                %1 : java.type:\"QuotableSubtypeTest$QuotableIntUnaryOperator\" = lambda @lambda.isQuotable=true (%2 : java.type:\"int\")java.type:\"int\" -> {\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"x$0\";\n-                    %4 : java.type:\"int\" = var.load %3;\n-                    %5 : java.type:\"int\" = invoke %0 %4 @java.ref:\"QuotableSubtypeTest$ContextRef::g(int):int\";\n-                    return %5;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static final QuotableIntUnaryOperator QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n-\n-    static final int Z = 42;\n-    @IR(\"\"\"\n-            func @\"f\" (%0 : Var<java.type:\"int\">)java.type:\"void\" -> {\n-                %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                    %2 : java.type:\"int\" = var.load %0;\n-                    %3 : Var<java.type:\"int\"> = var %2 @\"x\";\n-                    return;\n-                };\n-                return;\n-            };\n-            \"\"\")\n-    static QuotableRunnable QUOTED_CAPTURE_FINAL_STATIC_FIELD = () -> {\n-        int x = Z;\n-    };\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                      %2 : java.type:\"int\" = constant @1;\n-                      %3 : java.type:\"int\" = invoke %2 @java.ref:\"QuotableSubtypeTest::n(int):int\";\n-                      return;\n-                  };\n-                  return;\n-            };\n-            \"\"\")\n-    \/\/ the lambda model used to contain operation that perform unnecessary type conversion\n-    static QuotableRunnable QUOTED_RETURN_VOID = () -> {\n-        n(1);\n-    };\n-    static int n(int i) {\n-        return i;\n-    }\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                      %2 : java.type:\"java.lang.Object\" = new @java.ref:\"java.lang.Object::()\";\n-                      return;\n-                  };\n-                  return;\n-            };\n-            \"\"\")\n-    \/\/ the lambda model used to contain ReturnOp with a value, even though the lambda type is void\n-    static QuotableRunnable QUOTED_EXPRESSION_RETURN_VOID = () -> new Object();\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                      %2 : java.type:\"java.lang.Runnable\" = lambda @lambda.isQuotable=false ()java.type:\"void\" -> {\n-                          return;\n-                      };\n-                      %3 : Var<java.type:\"java.lang.Runnable\"> = var %2 @\"r\";\n-                      return;\n-                  };\n-                  return;\n-            };\n-            \"\"\")\n-    static QuotableRunnable QUOTED_NESTED_LAMBDA = () -> {\n-        Runnable r = () -> {};\n-    };\n-\n-    @IR(\"\"\"\n-            func @\"f\" ()java.type:\"void\" -> {\n-                  %1 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                      %2 : java.type:\"QuotableSubtypeTest$QuotableRunnable\" = lambda @lambda.isQuotable=true ()java.type:\"void\" -> {\n-                          return;\n-                      };\n-                      %3 : Var<java.type:\"QuotableSubtypeTest$QuotableRunnable\"> = var %2 @\"r\";\n-                      return;\n-                  };\n-                  return;\n-            };\n-            \"\"\")\n-    \/\/ @@@ should this be the excepted behaviour in case we have a nested quotable lambda ?\n-    static QuotableRunnable QUOTED_NESTED_QUOTABLE_LAMBDA = () -> {\n-        QuotableRunnable r = () -> {};\n-    };\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":0,"deletions":336,"binary":false,"changes":336,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-import jdk.incubator.code.Reflect;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.interpreter.Interpreter;\n-\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.IntSupplier;\n-import java.util.function.IntUnaryOperator;\n-import java.util.stream.IntStream;\n-\n-\/*\n- * @test\n- * @summary test that invoking Op#ofQuotable returns the same instance\n- * @modules jdk.incubator.code\n- * @run junit QuotedSameInstanceTest\n- *\/\n-\n-public class QuotedSameInstanceTest {\n-\n-    private static final Runnable q1 = (@Reflect Runnable) () -> {\n-    };\n-\n-    @Test\n-    public void testWithOneThread() {\n-        Assertions.assertSame(Op.ofQuotable(q1).get(), Op.ofQuotable(q1).get());\n-    }\n-\n-    @Reflect\n-    interface QuotableIntUnaryOperator extends IntUnaryOperator { }\n-    private static final QuotableIntUnaryOperator q2 = x -> x;\n-\n-    @Test\n-    public void testWithMultiThreads() {\n-        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(q2).get()).toArray();\n-        for (int i = 1; i < quotedObjects.length; i++) {\n-            Assertions.assertSame(quotedObjects[i], quotedObjects[i - 1]);\n-        }\n-    }\n-\n-    @Reflect\n-    public interface QuotableIntSupplier extends IntSupplier {}\n-    @Reflect\n-    static QuotableIntSupplier q() {\n-        QuotableIntSupplier r = () -> 8;\n-        return r;\n-    }\n-\n-    @Test\n-    public void testMultiThreadsViaInterpreter() throws NoSuchMethodException {\n-        var qm = this.getClass().getDeclaredMethod(\"q\");\n-        var q = Op.ofMethod(qm).get();\n-        QuotableIntSupplier quotable = (QuotableIntSupplier) Interpreter.invoke(MethodHandles.lookup(), q);\n-        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(quotable).get()).toArray();\n-        for (int i = 1; i < quotedObjects.length; i++) {\n-            Assertions.assertSame(quotedObjects[i-1], quotedObjects[i]);\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -0,0 +1,56 @@\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.interpreter.Interpreter;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @summary test that invoking Op#ofQuotable returns the same instance\n+ * @modules jdk.incubator.code\n+ * @run junit ReflectableLambdaSameInstanceTest\n+ *\/\n+\n+public class ReflectableLambdaSameInstanceTest {\n+\n+    @Reflect\n+    private static final Runnable q1 = () -> { };\n+\n+    @Test\n+    public void testWithOneThread() {\n+        Assertions.assertSame(Op.ofQuotable(q1).get(), Op.ofQuotable(q1).get());\n+    }\n+\n+    @Reflect\n+    private static final IntUnaryOperator q2 = x -> x;\n+\n+    @Test\n+    public void testWithMultiThreads() {\n+        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(q2).get()).toArray();\n+        for (int i = 1; i < quotedObjects.length; i++) {\n+            Assertions.assertSame(quotedObjects[i], quotedObjects[i - 1]);\n+        }\n+    }\n+\n+    @Reflect\n+    static IntSupplier q() {\n+        return () -> 8;\n+    }\n+\n+    @Test\n+    public void testMultiThreadsViaInterpreter() throws NoSuchMethodException {\n+        var qm = this.getClass().getDeclaredMethod(\"q\");\n+        var q = Op.ofMethod(qm).get();\n+        IntSupplier quotable = (IntSupplier) Interpreter.invoke(MethodHandles.lookup(), q);\n+        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> Op.ofQuotable(quotable).get()).toArray();\n+        for (int i = 1; i < quotedObjects.length; i++) {\n+            Assertions.assertSame(quotedObjects[i-1], quotedObjects[i]);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ReflectableLambdaSameInstanceTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @build QuotableIntersectionTest\n+ * @build ReflectableLambdaTest\n@@ -30,1 +30,1 @@\n- * @run main CodeReflectionTester QuotableIntersectionTest\n+ * @run main CodeReflectionTester ReflectableLambdaTest\n@@ -39,1 +39,1 @@\n-public class QuotableIntersectionTest {\n+public class ReflectableLambdaTest {\n@@ -129,1 +129,1 @@\n-            func @\"f\" (%0 : java.type:\"QuotableIntersectionTest$Context\")java.type:\"void\" -> {\n+            func @\"f\" (%0 : java.type:\"ReflectableLambdaTest$Context\")java.type:\"void\" -> {\n@@ -132,2 +132,2 @@\n-                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableIntersectionTest$Context::x:int\";\n-                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableIntersectionTest$Context::y:int\";\n+                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"ReflectableLambdaTest$Context::x:int\";\n+                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"ReflectableLambdaTest$Context::y:int\";\n@@ -167,1 +167,1 @@\n-            func @\"captureField\" (%0 : java.type:\"QuotableIntersectionTest\")java.type:\"void\" -> {\n+            func @\"captureField\" (%0 : java.type:\"ReflectableLambdaTest\")java.type:\"void\" -> {\n@@ -170,2 +170,2 @@\n-                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableIntersectionTest::x:int\";\n-                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"QuotableIntersectionTest::y:int\";\n+                    %4 : java.type:\"int\" = field.load %0 @java.ref:\"ReflectableLambdaTest::x:int\";\n+                    %5 : java.type:\"int\" = field.load %0 @java.ref:\"ReflectableLambdaTest::y:int\";\n@@ -191,1 +191,1 @@\n-                    invoke @java.ref:\"QuotableIntersectionTest::m():void\";\n+                    invoke @java.ref:\"ReflectableLambdaTest::m():void\";\n@@ -197,1 +197,1 @@\n-    static final Runnable QUOTED_NO_PARAM_VOID_REF = (@Reflect Runnable) QuotableIntersectionTest::m;\n+    static final Runnable QUOTED_NO_PARAM_VOID_REF = (@Reflect Runnable) ReflectableLambdaTest::m;\n@@ -208,1 +208,1 @@\n-                    %4 : java.type:\"int\" = invoke %3 @java.ref:\"QuotableIntersectionTest::g(int):int\";\n+                    %4 : java.type:\"int\" = invoke %3 @java.ref:\"ReflectableLambdaTest::g(int):int\";\n@@ -214,1 +214,1 @@\n-    static final IntUnaryOperator QUOTED_INT_PARAM_INT_RET_REF = (@Reflect IntUnaryOperator) QuotableIntersectionTest::g;\n+    static final IntUnaryOperator QUOTED_INT_PARAM_INT_RET_REF = (@Reflect IntUnaryOperator) ReflectableLambdaTest::g;\n@@ -240,1 +240,1 @@\n-            func @\"f\" (%0 : java.type:\"QuotableIntersectionTest$ContextRef\")java.type:\"void\" -> {\n+            func @\"f\" (%0 : java.type:\"ReflectableLambdaTest$ContextRef\")java.type:\"void\" -> {\n@@ -244,1 +244,1 @@\n-                    %5 : java.type:\"int\" = invoke %0 %4 @java.ref:\"QuotableIntersectionTest$ContextRef::g(int):int\";\n+                    %5 : java.type:\"int\" = invoke %0 %4 @java.ref:\"ReflectableLambdaTest$ContextRef::g(int):int\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/ReflectableLambdaTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"previous_filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","status":"renamed"},{"patch":"@@ -4,1 +4,1 @@\n- * @compile\/fail\/ref=TestNoCodeReflectionInInnerClasses.out -Xlint:-incubating -XDrawDiagnostics TestNoCodeReflectionInInnerClasses.java\n+ * @compile\/fail\/ref=TestNoCodeReflectionInInnerClasses.out -Werror -Xlint:-incubating -XDrawDiagnostics TestNoCodeReflectionInInnerClasses.java\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,4 +1,6 @@\n-TestNoCodeReflectionInInnerClasses.java:12:21: compiler.err.quoted.method.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-TestNoCodeReflectionInInnerClasses.java:15:46: compiler.err.quoted.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-TestNoCodeReflectionInInnerClasses.java:19:46: compiler.err.quoted.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n-3 errors\n+TestNoCodeReflectionInInnerClasses.java:12:21: compiler.warn.reflectable.method.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+TestNoCodeReflectionInInnerClasses.java:15:46: compiler.warn.reflectable.lambda.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+TestNoCodeReflectionInInnerClasses.java:19:46: compiler.warn.reflectable.mref.inner.class: TestNoCodeReflectionInInnerClasses.Inner\n+- compiler.err.warnings.and.werror\n+1 error\n+3 warnings\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestNoCodeReflectionInInnerClasses.out","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=false (%1 : java.type:\"int\")java.type:\"int\" -> {\n+                %0 : java.type:\"java.util.function.IntUnaryOperator\" = lambda @lambda.isQuotable=true (%1 : java.type:\"int\")java.type:\"int\" -> {\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnreachableTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}