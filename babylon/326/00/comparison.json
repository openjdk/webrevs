{"files":[{"patch":"@@ -57,1 +57,1 @@\n-                              .map(i -> ((Tensor)(i instanceof Optional o ? o.get() : i)).tensorAddr)\n+                              .map(i -> (Tensor)(i instanceof Optional o ? o.get() : i))\n@@ -62,1 +62,1 @@\n-                return new Tensor(outTensors.getFirst());\n+                return outTensors.getFirst();\n@@ -64,1 +64,1 @@\n-                return outTensors.stream().map(Tensor::new).toArray();\n+                return outTensors.toArray();\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxInterpreter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-import java.nio.ByteBuffer;\n@@ -268,1 +267,1 @@\n-    static ByteBuffer buildFuncModel(FuncOp model) {\n+    static byte[] build(FuncOp model) {\n@@ -279,3 +278,3 @@\n-        return buildModel(\n-                model.body().entryBlock().parameters().stream().map(v -> new Input(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n-                model.body().entryBlock().ops().stream().<OpNode>mapMulti((op, opNodes) -> {\n+        return build(\n+                model.body().entryBlock().parameters().stream().map(v -> tensorInfo(indexer.getName(v), ((OnnxType.TensorType)v.type()).eType().id())).toList(),\n+                model.body().entryBlock().ops().stream().<NodeProto>mapMulti((op, opNodes) -> {\n@@ -284,1 +283,1 @@\n-                            opNodes.accept(new OpNode(\n+                            opNodes.accept(node(\n@@ -300,5 +299,2 @@\n-    record Input(String name, int tensorElementType) {}\n-    record OpNode(String opName, List<String> inputNames, List<String> outputNames, java.util.Map<String, Object> attributes) {}\n-\n-    static ByteBuffer buildModel(List<Input> inputs, List<OpNode> ops, List<String> outputNames) {\n-        var bytes = new ModelProto()\n+    static byte[] build(List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n+        return new ModelProto()\n@@ -306,10 +302,1 @@\n-                .graph(new GraphProto()\n-                        .forEach(inputs, (g, input) -> g\n-                                .input(new ValueInfoProto().name(input.name())\n-                                        .type(new TypeProto().tensor_type(new Tensor().elem_type(input.tensorElementType())))))\n-                        .forEach(ops, (g, op) -> g.node(new NodeProto()\n-                                .forEach(op.inputNames(), (n, iName) -> n.input(iName))\n-                                .forEach(op.outputNames(), (n, oName) -> n.output(oName))\n-                                .op_type(op.opName())\n-                                .forEach(op.attributes().entrySet(), (n, ae) -> n.attribute(buildAttribute(ae.getKey(), ae.getValue())))))\n-                        .forEach(outputNames, (g, oName) -> g.output(new ValueInfoProto().name(oName))))\n+                .graph(graph(inputs, ops, outputNames))\n@@ -318,2 +305,0 @@\n-\/\/        OnnxProtoPrinter.printModel(ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN));\n-        return ByteBuffer.allocateDirect(bytes.length).put(bytes).asReadOnlyBuffer();\n@@ -322,1 +307,33 @@\n-    static Attribute buildAttribute(String name, Object value) {\n+    static GraphProto graph(List<ValueInfoProto> inputs, List<NodeProto> ops, List<String> outputNames) {\n+        return new GraphProto()\n+                .forEach(inputs, (g, i) -> g.input(i))\n+                .forEach(ops, (g, op) -> g.node(op))\n+                .forEach(outputNames, (g, oName) -> g.output(new ValueInfoProto().name(oName)));\n+    }\n+\n+    static NodeProto node(String opName, List<String> inputNames, List<String> outputNames, java.util.Map<String, Object> attributes) {\n+        return new NodeProto()\n+                .forEach(inputNames, (n, iName) -> n.input(iName))\n+                .forEach(outputNames, (n, oName) -> n.output(oName))\n+                .op_type(opName)\n+                .forEach(attributes.entrySet(), (n, ae) -> n.attribute(attribute(ae.getKey(), ae.getValue())));\n+    }\n+\n+    static ValueInfoProto tensorInfo(String name, int tensorElementType) {\n+        return new ValueInfoProto()\n+                .name(name)\n+                .type(new TypeProto()\n+                        .tensor_type(new Tensor()\n+                                .elem_type(tensorElementType)));\n+    }\n+\n+    static ValueInfoProto scalarInfo(String name, int tensorElementType) {\n+        return new ValueInfoProto()\n+                .name(name)\n+                .type(new TypeProto()\n+                        .tensor_type(new Tensor()\n+                                .elem_type(tensorElementType)\n+                                .shape(new TensorShapeProto())));\n+    }\n+\n+    static Attribute attribute(String name, Object value) {\n@@ -331,0 +348,3 @@\n+            case GraphProto g -> {\n+                attr.type(5).g(g.name(name));\n+            }\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":44,"deletions":24,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -6,2 +6,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n@@ -14,1 +12,0 @@\n-import java.util.Optional;\n@@ -20,1 +17,0 @@\n-import oracle.code.onnx.ir.OnnxOp;\n@@ -77,1 +73,1 @@\n-    public List<MemorySegment> runOp(String opName, List<MemorySegment> inputValues, int numOutputs, Map<String, Object> attributes) {\n+    public List<Tensor> runOp(String opName, List<Tensor> inputValues, int numOutputs, Map<String, Object> attributes) {\n@@ -79,3 +75,3 @@\n-        var protoModel = OnnxProtoBuilder.buildModel(\n-                IntStream.range(0, inputValues.size()).mapToObj(i -> new OnnxProtoBuilder.Input(\"i\" + i, tensorElementType(inputValues.get(i)).id)).toList(),\n-                List.of(new OnnxProtoBuilder.OpNode(\n+        var protoModel = OnnxProtoBuilder.build(\n+                IntStream.range(0, inputValues.size()).mapToObj(i -> OnnxProtoBuilder.tensorInfo(\"i\" + i, inputValues.get(i).elementType().id)).toList(),\n+                List.of(OnnxProtoBuilder.node(\n@@ -92,2 +88,2 @@\n-    public List<MemorySegment> runFunc(CoreOp.FuncOp model, List<MemorySegment> inputValues) {\n-        var protoModel = OnnxProtoBuilder.buildFuncModel(model);\n+    public List<Tensor> runFunc(CoreOp.FuncOp model, List<Tensor> inputValues) {\n+        var protoModel = OnnxProtoBuilder.build(model);\n@@ -107,1 +103,1 @@\n-    public Session createSession(ByteBuffer model) {\n+    public Session createSession(byte[] model) {\n@@ -111,2 +107,2 @@\n-    private Session createSession(ByteBuffer model, SessionOptions options) {\n-        return new Session(retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, MemorySegment.ofBuffer(model.rewind()), model.limit(), options.sessionOptionsAddress, ret)));\n+    private Session createSession(byte[] model, SessionOptions options) {\n+        return new Session(retAddr(OrtApi.CreateSessionFromArray(runtimeAddress, envAddress, arena.allocateFrom(ValueLayout.JAVA_BYTE, model), model.length, options.sessionOptionsAddress, ret)));\n@@ -140,1 +136,1 @@\n-        public List<MemorySegment> run(List<MemorySegment> inputValues) {\n+        public List<Tensor> run(List<Tensor> inputValues) {\n@@ -149,1 +145,1 @@\n-                inputs.setAtIndex(C_POINTER, index++, inputValues.get(i));\n+                inputs.setAtIndex(C_POINTER, index++, inputValues.get(i).tensorAddr);\n@@ -158,1 +154,1 @@\n-            var retArr = new MemorySegment[outputLen];\n+            var retArr = new Tensor[outputLen];\n@@ -160,2 +156,2 @@\n-                retArr[i] = outputs.getAtIndex(C_POINTER, i)\n-                        .reinterpret(arena, null);\n+                retArr[i] = new Tensor(outputs.getAtIndex(C_POINTER, i)\n+                        .reinterpret(arena, null));\n@@ -191,1 +187,1 @@\n-    public ByteBuffer tensorBuffer(MemorySegment tensorAddr) {\n+    public MemorySegment tensorData(MemorySegment tensorAddr) {\n@@ -196,2 +192,1 @@\n-                .reinterpret(size)\n-                .asByteBuffer().order(ByteOrder.nativeOrder());\n+                .reinterpret(size);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.ByteOrder;\n@@ -69,0 +70,5 @@\n+    public static Tensor<Boolean> ofScalar(boolean b) {\n+        var data = Arena.ofAuto().allocateFrom(ValueLayout.JAVA_BYTE, b ? (byte)1 : 0);\n+        return new Tensor(data, ElementType.BOOL, SCALAR_SHAPE);\n+    }\n+\n@@ -118,1 +124,1 @@\n-        this(null, tensorAddr);\n+        this(OnnxRuntime.getInstance().tensorData(tensorAddr), tensorAddr);\n@@ -126,0 +132,8 @@\n+    public ElementType elementType() {\n+        return OnnxRuntime.getInstance().tensorElementType(tensorAddr);\n+    }\n+\n+    public long[] shape() {\n+        return OnnxRuntime.getInstance().tensorShape(tensorAddr);\n+    }\n+\n@@ -127,1 +141,1 @@\n-        return OnnxRuntime.getInstance().tensorBuffer(tensorAddr);\n+        return dataAddr.asByteBuffer().order(ByteOrder.nativeOrder());\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/Tensor.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    static List<Tensor<Float>> loadWeights() throws IOException {\n+    static List<Tensor> loadWeights() throws IOException {\n@@ -390,1 +390,1 @@\n-        test(inputImage -> new Tensor(OnnxRuntime.getInstance().runFunc(\n+        test(inputImage -> OnnxRuntime.getInstance().runFunc(\n@@ -392,2 +392,1 @@\n-                    Stream.concat(weights.stream(), Stream.of(inputImage))\n-                            .map(t -> t.tensorAddr).toList()).getFirst()));\n+                    Stream.concat(weights.stream(), Stream.of(inputImage)).toList()).getFirst());\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                OnnxProtoBuilder.buildFuncModel(\n+                OnnxProtoBuilder.build(\n@@ -130,1 +130,1 @@\n-        var inputArguments = List.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE).tensorAddr);\n+        var inputArguments = List.of(new Tensor(MemorySegment.ofBuffer(scaledImageDataBuffer), FLOAT, 1, 1, IMAGE_SIZE, IMAGE_SIZE));\n@@ -162,1 +162,1 @@\n-                    FloatBuffer result = OnnxRuntime.getInstance().tensorBuffer(modelRuntimeSession.run(inputArguments).getFirst()).asFloatBuffer();\n+                    FloatBuffer result = modelRuntimeSession.run(inputArguments).getFirst().asByteBuffer().asFloatBuffer();\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/MNISTDemo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+import static oracle.code.onnx.OnnxProtoBuilder.*;\n@@ -16,3 +17,3 @@\n-        try (var absOp = ort.createSession(OnnxProtoBuilder.buildModel(\n-                List.of(new OnnxProtoBuilder.Input(\"x\", FLOAT.id)),\n-                List.of(new OnnxProtoBuilder.OpNode(\"Abs\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n+        try (var absOp = ort.createSession(build(\n+                List.of(tensorInfo(\"x\", FLOAT.id)),\n+                List.of(node(\"Abs\", List.of(\"x\"), List.of(\"y\"), Map.of())),\n@@ -20,3 +21,3 @@\n-             var addOp = ort.createSession(OnnxProtoBuilder.buildModel(\n-                List.of(new OnnxProtoBuilder.Input(\"a\", FLOAT.id), new OnnxProtoBuilder.Input(\"b\", FLOAT.id)),\n-                List.of(new OnnxProtoBuilder.OpNode(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n+             var addOp = ort.createSession(build(\n+                List.of(tensorInfo(\"a\", FLOAT.id), tensorInfo(\"b\", FLOAT.id)),\n+                List.of(node(\"Add\", List.of(\"a\", \"b\"), List.of(\"y\"), Map.of())),\n@@ -35,1 +36,1 @@\n-            var absResult = absOp.run(List.of(inputTensor.tensorAddr));\n+            var absResult = absOp.run(List.of(inputTensor));\n@@ -39,1 +40,1 @@\n-            var absOutputTensor = new Tensor(absResult.getFirst());\n+            var absOutputTensor = absResult.getFirst();\n@@ -43,1 +44,1 @@\n-            var addResult = addOp.run(List.of(inputTensor.tensorAddr, absOutputTensor.tensorAddr));\n+            var addResult = addOp.run(List.of(inputTensor, absOutputTensor));\n@@ -47,1 +48,1 @@\n-            var addOutputTensor = new Tensor(addResult.getFirst());\n+            var addOutputTensor = addResult.getFirst();\n@@ -54,0 +55,40 @@\n+\n+    @Test\n+    public void testIf() throws Exception {\n+        var ort = OnnxRuntime.getInstance();\n+        try (var ifOp = ort.createSession(build(\n+                List.of(tensorInfo(\"cond\", BOOL.id), tensorInfo(\"a\", INT64.id), tensorInfo(\"b\", INT64.id)),\n+                List.of(node(\"If\", List.of(\"cond\"), List.of(\"y\"), Map.of(\n+                        \"then_branch\", graph(\n+                                List.of(),\n+                                List.of(node(\"Identity\", List.of(\"a\"), List.of(\"y\"), Map.of())),\n+                                List.of(\"y\")),\n+                        \"else_branch\", graph(\n+                                List.of(),\n+                                List.of(node(\"Identity\", List.of(\"b\"), List.of(\"y\"), Map.of())),\n+                                List.of(\"y\"))))),\n+                List.of(\"y\")))) {\n+\n+            var a = Tensor.ofScalar(1l);\n+            var b = Tensor.ofScalar(2l);\n+            SimpleTest.assertEquals(a, ifOp.run(List.of(Tensor.ofScalar(true), a, b)).getFirst());\n+            SimpleTest.assertEquals(b, ifOp.run(List.of(Tensor.ofScalar(false), a, b)).getFirst());\n+        }\n+    }\n+\n+    @Test\n+    public void testLoop() throws Exception {\n+        var ort = OnnxRuntime.getInstance();\n+        try (var forOp = ort.createSession(build(\n+                List.of(tensorInfo(\"max\", INT64.id), tensorInfo(\"cond\", BOOL.id), tensorInfo(\"a\", INT64.id)),\n+                List.of(node(\"Loop\", List.of(\"max\", \"cond\", \"a\"), List.of(\"a_out\"), Map.of(\n+                        \"body\", graph(\n+                                List.of(scalarInfo(\"i\", INT64.id), scalarInfo(\"cond_in\", BOOL.id), tensorInfo(\"a_in\", INT64.id)),\n+                                List.of(node(\"Identity\", List.of(\"cond_in\"), List.of(\"cond_out\"), Map.of()),\n+                                        node(\"Add\", List.of(\"a_in\", \"a_in\"), List.of(\"a_out\"), Map.of())),\n+                                List.of(\"cond_out\", \"a_out\"))))),\n+                List.of(\"a_out\")))) {\n+\n+            SimpleTest.assertEquals(Tensor.ofScalar(65536l), forOp.run(List.of(Tensor.ofScalar(15l), Tensor.ofScalar(true), Tensor.ofScalar(2l))).getFirst());\n+        }\n+    }\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/RuntimeTest.java","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -8,0 +7,1 @@\n+import java.util.List;\n@@ -114,3 +114,1 @@\n-        return new Tensor(OnnxRuntime.getInstance().runFunc(\n-                getOnnxModel(name),\n-                Stream.of(params).map(t -> t.tensorAddr).toList()).getFirst());\n+        return OnnxRuntime.getInstance().runFunc(getOnnxModel(name), List.of(params)).getFirst();\n@@ -125,14 +123,0 @@\n-        assertEquals(expected.tensorAddr, actual.tensorAddr);\n-    }\n-\n-    static void assertEquals(MemorySegment expectedTensorAddr, MemorySegment actualTensorAddr) {\n-\n-        var rt = OnnxRuntime.getInstance();\n-\n-        var expectedType = rt.tensorElementType(expectedTensorAddr);\n-        var expectedShape = rt.tensorShape(expectedTensorAddr);\n-        var expectedBB = rt.tensorBuffer(expectedTensorAddr);\n-\n-        var actualType = rt.tensorElementType(actualTensorAddr);\n-        var actualShape = rt.tensorShape(actualTensorAddr);\n-        var actualBB = rt.tensorBuffer(actualTensorAddr);\n@@ -140,1 +124,2 @@\n-        Assertions.assertSame(expectedType, actualType);\n+        var expectedType = expected.elementType();\n+        Assertions.assertSame(expectedType, actual.elementType());\n@@ -142,1 +127,1 @@\n-        Assertions.assertArrayEquals(expectedShape, actualShape);\n+        Assertions.assertArrayEquals(expected.shape(), actual.shape());\n@@ -144,1 +129,1 @@\n-        switch (actualType) {\n+        switch (expectedType) {\n@@ -146,1 +131,1 @@\n-                assertEquals(expectedBB, actualBB);\n+                assertEquals(expected.asByteBuffer(), actual.asByteBuffer());\n@@ -148,1 +133,1 @@\n-                assertEquals(expectedBB.asFloatBuffer(), actualBB.asFloatBuffer());\n+                assertEquals(expected.asByteBuffer().asFloatBuffer(), actual.asByteBuffer().asFloatBuffer());\n@@ -150,1 +135,1 @@\n-                assertEquals(expectedBB.asDoubleBuffer(), actualBB.asDoubleBuffer());\n+                assertEquals(expected.asByteBuffer().asDoubleBuffer(), actual.asByteBuffer().asDoubleBuffer());\n@@ -152,1 +137,1 @@\n-                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + actualType);\n+                throw new UnsupportedOperationException(\"Unsupported tensor element type \" + expectedType);\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"}]}