{"files":[{"patch":"@@ -36,0 +36,4 @@\n+    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+            Op.Result.class, Op.class);\n+    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n+            Block.Parameter.class, TypeElement.class);\n@@ -70,7 +74,5 @@\n-        if (t instanceof JCExpression e) {\n-            return e;\n-        } else if (t instanceof JCTree.JCVariableDecl vd) {\n-            return treeMaker.Ident(vd);\n-        } else {\n-            throw new IllegalArgumentException();\n-        }\n+        return switch (t) {\n+            case JCExpression e -> e;\n+            case JCTree.JCVariableDecl vd -> treeMaker.Ident(vd);\n+            case null, default -> throw new IllegalArgumentException();\n+        };\n@@ -121,7 +123,5 @@\n-        final MethodRef BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n-                Op.Result.class, Op.class);\n-        final MethodRef BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n-                Block.Parameter.class, TypeElement.class);\n-        Set<Value> vals = funcOp.traverse(new HashSet<>(), (l, ce) -> {\n-           if (ce instanceof CoreOp.InvokeOp invokeOp && (invokeOp.invokeDescriptor().equals(BLOCK_BUILDER_OP)\n-                   || invokeOp.invokeDescriptor().equals(BLOCK_BUILDER_PARAM))) {\n+        java.util.List<Value> rootValues = funcOp.traverse(new ArrayList<>(), (l, ce) -> {\n+            if (ce instanceof Op op && op.result() != null && op.result().uses().size() != 1) {\n+                l.add(op.result());\n+            } else if (ce instanceof CoreOp.InvokeOp invokeOp && (invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n+                   || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM))) {\n@@ -129,1 +129,1 @@\n-           }\n+            }\n@@ -132,10 +132,0 @@\n-        Map<Value, Node<Value>> prunedGraphs = prunedExpressionGraphs(funcOp, vals);\n-        java.util.List<Node<Value>> prunedRootGraphs = prunedGraphs.values().stream()\n-                .filter(n -> n.value() instanceof Op.Result opr &&\n-                        switch (opr.op()) {\n-                            \/\/ Variable declarations modeling local variables\n-                            case CoreOp.VarOp vop -> vop.operands().get(0) instanceof Op.Result;\n-                            \/\/ An operation result with no uses or more than one\n-                            default -> opr.uses().size() != 1 || vals.contains(opr);\n-                        })\n-                .toList();\n@@ -144,4 +134,2 @@\n-        \/\/ instead, we will traverse the root expr graphs\n-        for (Node<Value> root : prunedRootGraphs) {\n-            JCTree tree = opToTree(root.value());\n-            \/\/ in the code model we don't have VarOp\n+        for (Value root : rootValues) {\n+            JCTree tree = opToTree(root);\n@@ -151,1 +139,1 @@\n-                valueToTree.put(root.value(), tree);\n+                valueToTree.put(root, tree);\n@@ -220,51 +208,0 @@\n-    static Map<Value, Node<Value>> prunedExpressionGraphs(CoreOp.FuncOp f, Set<Value> vals) {\n-        return prunedExpressionGraphs(f.body(), vals);\n-    }\n-\n-    static Map<Value, Node<Value>> prunedExpressionGraphs(Body b, Set<Value> vals) {\n-        \/\/ Traverse the model building structurally shared expression graphs\n-        return b.traverse(new LinkedHashMap<>(), (graphs, codeElement) -> {\n-            switch (codeElement) {\n-                case Body _ -> {\n-                    \/\/ Do nothing\n-                }\n-                case Block block -> {\n-                    \/\/ Create the expression graphs for each block parameter\n-                    \/\/ A block parameter has no outgoing edges\n-                    for (Block.Parameter parameter : block.parameters()) {\n-                        graphs.put(parameter, new Node<>(parameter, java.util.List.of()));\n-                    }\n-                }\n-                \/\/ Prune graph for variable load operation\n-                case CoreOp.VarAccessOp.VarLoadOp op -> {\n-                    \/\/ Ignore edge for the variable value operand\n-                    graphs.put(op.result(), new Node<>(op.result(), java.util.List.of()));\n-                }\n-                \/\/ Prune graph for variable store operation\n-                case CoreOp.VarAccessOp.VarStoreOp op -> {\n-                    \/\/ Ignore edge for the variable value operand\n-                    \/\/ Add edge for value to store\n-                    java.util.List<Node<Value>> edges = java.util.List.of(graphs.get(op.operands().get(1)));\n-                    graphs.put(op.result(), new Node<>(op.result(), edges));\n-                }\n-                case Op op -> {\n-                    \/\/ Find the expression graphs for each operand\n-                    java.util.List<Node<Value>> edges = new ArrayList<>();\n-                    for (Value operand : op.result().dependsOn()) {\n-                        \/\/ Ignore edge for operand if also used by other operations\n-                        if (operand.uses().size() == 1 && !vals.contains(operand)) {\n-                            \/\/ Get expression graph for the operand\n-                            \/\/ It must be previously computed since we encounter the\n-                            \/\/ declaration of values before their use\n-                            edges.add(graphs.get(operand));\n-                        }\n-                    }\n-                    \/\/ Create the expression graph for this operation result\n-                    graphs.put(op.result(), new Node<>(op.result(), edges));\n-                }\n-            }\n-            return graphs;\n-        });\n-    }\n-    record Node<T>(T value, java.util.List<Node<T>> edges) {}\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":18,"deletions":81,"binary":false,"changes":99,"status":"modified"}]}