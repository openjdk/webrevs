{"files":[{"patch":"@@ -14,0 +14,1 @@\n+import com.sun.tools.javac.util.List;\n@@ -18,2 +19,1 @@\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -33,1 +33,0 @@\n-    private final Map<Value, Symbol.VarSymbol> valueToVarSym = new HashMap<>();\n@@ -36,0 +35,5 @@\n+    private final Map<Value, JCTree> valueToTree = new HashMap<>();\n+    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+            Op.Result.class, Op.class);\n+    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n+            Block.Parameter.class, TypeElement.class);\n@@ -69,0 +73,8 @@\n+    private JCExpression toExpr(JCTree t) {\n+        return switch (t) {\n+            case JCExpression e -> e;\n+            case JCTree.JCVariableDecl vd -> treeMaker.Ident(vd);\n+            case null, default -> throw new IllegalArgumentException();\n+        };\n+    }\n+\n@@ -78,1 +90,1 @@\n-                treeMaker.Select(exprTree(receiver), methodSym);\n+                treeMaker.Select(toExpr(opToTree(receiver)), methodSym);\n@@ -81,1 +93,1 @@\n-            args.add(exprTree(operand));\n+            args.add(toExpr(opToTree(operand)));\n@@ -99,1 +111,42 @@\n-    private JCTree opToTree(Op op) {\n+    public JCTree.JCMethodDecl transformFuncOpToAST(CoreOp.FuncOp funcOp, Name methodName) {\n+        Assert.check(funcOp.body().blocks().size() == 1);\n+\n+        var paramTypes = List.of(crSym.opFactoryType, crSym.typeElementFactoryType);\n+        var mt = new Type.MethodType(paramTypes, crSym.opType, List.nil(), syms.methodClass);\n+        ms = new Symbol.MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currClassSym);\n+        currClassSym.members().enter(ms);\n+\n+        for (int i = 0; i < funcOp.parameters().size(); i++) {\n+            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n+        }\n+\n+        java.util.List<Value> rootValues = funcOp.traverse(new ArrayList<>(), (l, ce) -> {\n+            if (ce instanceof Op op && op.result() != null && op.result().uses().size() != 1) {\n+                l.add(op.result());\n+            } else if (ce instanceof CoreOp.InvokeOp invokeOp && (invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_OP)\n+                   || invokeOp.invokeDescriptor().equals(M_BLOCK_BUILDER_PARAM))) {\n+               l.add(invokeOp.result());\n+            }\n+            return l;\n+        });\n+\n+        var stats = new ListBuffer<JCTree.JCStatement>();\n+        for (Value root : rootValues) {\n+            JCTree tree = opToTree(root);\n+            if (tree instanceof JCExpression e) {\n+                var vs = new Symbol.VarSymbol(LocalVarFlags | SYNTHETIC, names.fromString(\"_$\" + localVarCount++), tree.type, ms);\n+                tree = treeMaker.VarDef(vs, e);\n+                valueToTree.put(root, tree);\n+            }\n+            stats.add((JCTree.JCStatement) tree);\n+        }\n+        var mb = treeMaker.Block(0, stats.toList());\n+\n+        return treeMaker.MethodDef(ms, mb);\n+    }\n+\n+    private JCTree opToTree(Value v) {\n+        if (valueToTree.containsKey(v)) {\n+            return valueToTree.get(v);\n+        }\n+        Op op = ((Op.Result) v).op();\n@@ -109,1 +162,1 @@\n-                    dims.add(exprTree(newOp.operands().get(d)));\n+                    dims.add(toExpr(opToTree(newOp.operands().get(d))));\n@@ -120,1 +173,1 @@\n-                    args.add(exprTree(operand));\n+                    args.add(toExpr(opToTree(operand)));\n@@ -132,1 +185,1 @@\n-                    treeMaker.Return(exprTree(returnOp.returnValue()));\n+                    treeMaker.Return(toExpr(opToTree(returnOp.returnValue())));\n@@ -143,1 +196,2 @@\n-                        treeMaker.Indexed(exprTree(array), exprTree(index)), exprTree(val)\n+                        treeMaker.Indexed(\n+                                toExpr(opToTree(array)), toExpr(opToTree(index))), toExpr(opToTree(val))\n@@ -150,50 +204,2 @@\n-        if (tree instanceof JCTree.JCExpression expr) {\n-            \/\/ introduce a local variable to hold the expr, to make sure an op's tree is inserted right away\n-            \/\/ for some operations this is essential, e.g. to ensure the correct order of operations\n-            Type type;\n-            if (op instanceof CoreOp.ConstantOp cop && cop.value() == null) {\n-                \/\/ if ConstantOp value is null, tree.type will be null_type\n-                \/\/ if null_type is used to create a VarSymbol, an exception will be thrown\n-                type = typeElementToType(cop.resultType());\n-            } else {\n-                type = tree.type;\n-            }\n-            var vs = new Symbol.VarSymbol(LocalVarFlags, names.fromString(\"_$\" + localVarCount++), type, ms);\n-            var varDef = treeMaker.VarDef(vs, expr);\n-            map(op.result(), vs);\n-            return varDef;\n-        } else {\n-            return tree;\n-        }\n-    }\n-\n-    private JCTree.JCExpression exprTree(Value v) {\n-        return treeMaker.Ident(valueToVarSym.get(v));\n-    }\n-\n-    private void map(Value v, Symbol.VarSymbol vs) {\n-        valueToVarSym.put(v, vs);\n-    }\n-\n-    public JCTree.JCMethodDecl transformFuncOpToAST(CoreOp.FuncOp funcOp, Name methodName) {\n-        Assert.check(funcOp.body().blocks().size() == 1);\n-\n-        var paramTypes = List.of(crSym.opFactoryType, crSym.typeElementFactoryType);\n-        var mt = new Type.MethodType(paramTypes, crSym.opType, List.nil(), syms.methodClass);\n-        ms = new Symbol.MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currClassSym);\n-        currClassSym.members().enter(ms);\n-\n-        for (int i = 0; i < funcOp.parameters().size(); i++) {\n-            map(funcOp.parameters().get(i), ms.params().get(i));\n-        }\n-\n-        var stats = new ListBuffer<JCTree.JCStatement>();\n-        for (Op op : funcOp.body().entryBlock().ops()) {\n-            var tree = opToTree(op);\n-            if (tree instanceof JCTree.JCStatement stat) {\n-                stats.add(stat);\n-            }\n-        }\n-        var mb = treeMaker.Block(0, stats.toList());\n-\n-        return treeMaker.MethodDef(ms, mb);\n+        valueToTree.put(v, tree);\n+        return tree;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":66,"deletions":60,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-                return CodeModelStorageOption.TEXT;\n+                return CodeModelStorageOption.CODE_BUILDER;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}