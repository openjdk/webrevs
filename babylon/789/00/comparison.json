{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import hat.optools.IfaceBufferPattern;\n@@ -37,1 +38,1 @@\n-import hat.optools.OpTk;\n+\n@@ -445,1 +446,1 @@\n-                if (OpTk.isIfaceBufferMethod(lookup,invokeOp)\n+                if (IfaceBufferPattern.isInvokeOp(lookup,invokeOp)\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static hat.optools.OpTk.isIfaceBufferMethod;\n@@ -144,1 +143,1 @@\n-            if (op instanceof JavaOp.InvokeOp invoke && !isIfaceBufferMethod(MethodHandles.lookup(),invoke)) {  \/\/ We should pass lookup down\n+            if (op instanceof JavaOp.InvokeOp invoke && !IfaceBufferPattern.isInvokeOp(MethodHandles.lookup(),invoke)) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import hat.optools.ComputeContextPattern;\n+import hat.optools.IfaceBufferPattern;\n+import hat.optools.KernelContextPattern;\n@@ -36,1 +39,0 @@\n-import hat.optools.OpTk;\n@@ -54,2 +56,0 @@\n-import static hat.optools.OpTk.isComputeContextMethod;\n-import static hat.optools.OpTk.isIfaceBufferMethod;\n@@ -143,1 +143,1 @@\n-                    if (isIfaceBufferMethod(lookup(), invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n+                    if (IfaceBufferPattern.isInvokeOp(lookup(), invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n@@ -148,1 +148,1 @@\n-                    } else if (isIfaceBufferMethod(lookup(), invokeOp)\n+                    } else if (IfaceBufferPattern.isInvokeOp(lookup(), invokeOp)\n@@ -162,1 +162,1 @@\n-                    } else if (isComputeContextMethod(lookup(),invokeOp) || OpTk.isKernelContextInvokeOp(lookup(),invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n+                    } else if (ComputeContextPattern.isComputeContextMethod(lookup(),invokeOp) || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup(),invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import hat.optools.ComputeContextPattern;\n+import hat.optools.IfaceBufferPattern;\n+import hat.optools.KernelContextPattern;\n@@ -36,1 +39,0 @@\n-import hat.optools.OpTk;\n@@ -50,2 +52,0 @@\n-import static hat.optools.OpTk.isComputeContextMethod;\n-import static hat.optools.OpTk.isIfaceBufferMethod;\n@@ -97,1 +97,1 @@\n-                if (isIfaceBufferMethod(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n+                if (IfaceBufferPattern.isInvokeOp(lookup, invokeOp) && javaReturnType(invokeOp).equals(JavaType.VOID)) {                    \/\/ iface.v(newV)\n@@ -102,1 +102,1 @@\n-                } else if (isIfaceBufferMethod(lookup, invokeOp)\n+                } else if (IfaceBufferPattern.isInvokeOp(lookup, invokeOp)\n@@ -112,1 +112,1 @@\n-                } else if (isComputeContextMethod(lookup, invokeOp) || OpTk.isKernelContextInvokeOp(lookup, invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n+                } else if (ComputeContextPattern.isComputeContextMethod(lookup, invokeOp) || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup, invokeOp,OpTkl.AnyInvoke)) { \/\/dispatchKernel\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import hat.optools.OpTk;\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import hat.optools.OpTk;\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.optools.OpTk;\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp hatGlobalThreadIdOp);\n+    T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp hatGlobalThreadIdOp);\n@@ -123,1 +123,1 @@\n-            case HATGlobalThreadIdOp $ -> hatGlobalThreadOp(buildContext, $);\n+            case HATGlobalThreadIdOp $ -> hatGlobalThreadIdOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonKernelOpBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import hat.optools.IfaceBufferPattern;\n+import hat.optools.RefactorMe;\n@@ -38,1 +40,0 @@\n-import hat.optools.OpTk;\n@@ -356,2 +357,2 @@\n-        if (OpTk.isIfaceBufferMethod(buildContext.lookup, invokeOp)\n-                || OpTk.isInvokeDescriptorSubtypeOfAnyMatch(buildContext.lookup,invokeOp, HAType.class, DeviceType.class)) {\n+        if (IfaceBufferPattern.isInvokeOp(buildContext.lookup, invokeOp)\n+                || RefactorMe.isInvokeDescriptorSubtypeOfAnyMatch(buildContext.lookup,invokeOp, HAType.class, DeviceType.class)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import static optkl.OpTkl.statements;\n@@ -102,19 +103,0 @@\n-    public T HAT_GS(int id) {\n-        return (switch (id) {\n-            case 0 -> HAT_GSX();\n-            case 1 -> HAT_GSY();\n-            case 2 -> HAT_GSZ();\n-            default -> throw new RuntimeException(\"globalSize id = \" + id);\n-        });\n-    }\n-\n-    public T HAT_GI(int id) {\n-        switch (id) {\n-            case 0 -> HAT_GIX();\n-            case 1 -> HAT_GIY();\n-            case 2 -> HAT_GIZ();\n-            default -> throw new RuntimeException(\"globalId id = \" + id);\n-        }\n-        return self();\n-    }\n-\n@@ -145,17 +127,0 @@\n-    public T HAT_LI(int id) {\n-        return (switch (id) {\n-            case 0 -> HAT_LIX();\n-            case 1 -> HAT_LIY();\n-            case 2 -> HAT_LIZ();\n-            default -> throw new RuntimeException(\"localId id = \" + id);\n-        });\n-    }\n-\n-    public T HAT_LS(int id) {\n-        return (switch (id) {\n-            case 0 -> HAT_LSX();\n-            case 1 -> HAT_LSY();\n-            case 2 -> HAT_LSZ();\n-            default -> throw new RuntimeException(\"localSize id = \" + id);\n-        });\n-    }\n@@ -175,2 +140,47 @@\n-    public T HAT_BI(int id) {\n-        return (switch (id) {\n+\n+    @Override\n+    public T hatGlobalThreadIdOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp globalThreadIdOp) {\n+        switch (globalThreadIdOp.getDimension()) {\n+            case 0 -> HAT_GIX();\n+            case 1 -> HAT_GIY();\n+            case 2 -> HAT_GIZ();\n+            default -> throw new RuntimeException(\"globalId id = \" + globalThreadIdOp.getDimension());\n+        }\n+        return self();\n+    }\n+\n+    @Override\n+    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp globalSizeOp) {\n+        return (switch (globalSizeOp.getDimension()) {\n+            case 0 -> HAT_GSX();\n+            case 1 -> HAT_GSY();\n+            case 2 -> HAT_GSZ();\n+            default -> throw new RuntimeException(\"globalSize id = \" + globalSizeOp.getDimension());\n+        });\n+\n+    }\n+\n+    @Override\n+    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp localThreadIdOp) {\n+        return (switch (localThreadIdOp.getDimension()) {\n+            case 0 -> HAT_LIX();\n+            case 1 -> HAT_LIY();\n+            case 2 -> HAT_LIZ();\n+            default -> throw new RuntimeException(\"localId id = \" + localThreadIdOp.getDimension());\n+        });\n+\n+    }\n+\n+    @Override\n+    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp) {\n+        return (switch (hatLocalSizeOp.getDimension()) {\n+            case 0 -> HAT_LSX();\n+            case 1 -> HAT_LSY();\n+            case 2 -> HAT_LSZ();\n+            default -> throw new RuntimeException(\"localSize id = \" + hatLocalSizeOp.getDimension());\n+        });\n+    }\n+\n+    @Override\n+    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp) {\n+        return (switch (hatBlockThreadIdOp.getDimension()) {\n@@ -180,1 +190,1 @@\n-            default -> throw new RuntimeException(\"blockId id = \" + id);\n+            default -> throw new RuntimeException(\"blockId id = \" + hatBlockThreadIdOp.getDimension());\n@@ -258,14 +268,13 @@\n-                                        if (boundSchema != null) {\n-                                            boolean[] done = new boolean[]{false};\n-                                            boundSchema.boundArrayFields().forEach(a -> {\n-                                                if (a.field.equals(ifaceField)) {\n-                                                    sbrace(_ -> literal(a.len));\n-                                                    done[0] = true;\n-                                                }\n-                                            });\n-                                            if (!done[0]) {\n-                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n-                                            }\n-                                        } else {\n-                                            throw new IllegalStateException(\"bound schema is null  !\");\n-                                        }\n+                                      \/\/  if (boundSchema != null) {\n+                                          \/\/  var done = StreamMutable.of(false);\n+                                            boundSchema.boundArrayFields().stream()\n+                                                    .filter(a->a.field.equals(ifaceField))\n+                                                    .findFirst()\n+                                                    .ifPresentOrElse(\n+                                                            a-> sbrace(_ -> literal(a.len)),\n+                                                            ()->{\n+                                                                throw new IllegalStateException(\"we need to extract the array size hat kind of array \");\n+                                                            });\n+                                        \/\/} else {\n+                                          \/\/  throw new IllegalStateException(\"bound schema is null  !\");\n+                                      \/\/  }\n@@ -355,1 +364,1 @@\n-        if (isAssignable(buildContext.lookup, javaType, MappableIface.class) && javaType instanceof ClassType classType) {\n+        if (javaType instanceof ClassType classType && isAssignable(buildContext.lookup, javaType, MappableIface.class)) {\n@@ -357,1 +366,1 @@\n-        } else if (javaType instanceof ClassType classType && classType.toClassName().equals(KernelContext.class.getName())) {\n+        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,KernelContext.class)) {\n@@ -359,3 +368,1 @@\n-        } else if (javaType instanceof ClassType classType && classType.toClassName().equals(F16.class.getCanonicalName())) {\n-            \/\/ Check for special types (e.g., FP16)\n-            \/\/ TODO: We need to update this with a custom op, so we avoid direct use of Impls\n+        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,F16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n@@ -363,3 +370,1 @@\n-        } else if (javaType instanceof ClassType classType && classType.toClassName().equals(BF16.class.getCanonicalName())) {\n-            \/\/ Special type: BFLOAT16\n-            \/\/ TODO: We need to update this with a custom op, so we avoid direct use of Impls\n+        } else if (OpTkl.isAssignable(buildContext.lookup, javaType,BF16.class)) {\/\/ TODO: update this with a custom op, to avoid direct use of Impls\n@@ -386,1 +391,1 @@\n-                        OpTkl.statements(funcOp.bodies().getFirst().entryBlock()),\n+                        statements(funcOp.bodies().getFirst().entryBlock()),\n@@ -403,1 +408,1 @@\n-                    OpTkl.statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n+                    statements(buildContext.funcOp.bodies().getFirst().entryBlock()),\n@@ -411,24 +416,0 @@\n-    @Override\n-    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp globalThreadIdOp) {\n-        return HAT_GI(globalThreadIdOp.getDimension());\n-    }\n-\n-    @Override\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp globalSizeOp) {\n-        return HAT_GS(globalSizeOp.getDimension());\n-    }\n-\n-    @Override\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp localThreadIdOp) {\n-        return HAT_LI(localThreadIdOp.getDimension());\n-    }\n-\n-    @Override\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp) {\n-        return HAT_LS(hatLocalSizeOp.getDimension());\n-    }\n-\n-    @Override\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp) {\n-        return HAT_BI(hatBlockThreadIdOp.getDimension());\n-    }\n@@ -665,1 +646,3 @@\n-        String identifier = \"b\";\n+        String b16 = \"b16\";\n+        String s = \"s\";\n+        String f = \"f\";\n@@ -669,4 +652,4 @@\n-                       _ -> bfloat16Type(identifier).semicolonNl()\n-                               .identifier(identifier).dot().identifier(\"s\").sbrace( _ -> intConstZero()).equals().intConstZero().semicolonNl()\n-                               .identifier(identifier).dot().identifier(\"s\").sbrace( _ -> intConstOne()).equals().constant(parameterName).semicolonNl()\n-                               .returnKeyword(_-> identifier(\"b\").dot().identifier(\"f\")));\n+                       _ -> bfloat16Type(b16).semicolonNl()\n+                               .identifier(b16).dot().identifier(s).sbrace( _ -> intConstZero()).equals().intConstZero().semicolonNl()\n+                               .identifier(b16).dot().identifier(s).sbrace( _ -> intConstOne()).equals().constant(parameterName).semicolonNl()\n+                               .returnKeyword(_-> identifier(b16).dot().identifier(f)));\n@@ -686,0 +669,2 @@\n+        String b16 = \"b16\";\n+        String s = \"s\";\n@@ -690,1 +675,1 @@\n-                _ -> assign(_ -> bfloat16Type(\"b\"),\n+                _ -> assign(_ -> bfloat16Type(b16),\n@@ -692,1 +677,1 @@\n-                                .returnKeyword(_ ->identifier(\"b\").dot().identifier(\"s\").sbrace(_ -> intConstOne()))));\n+                                .returnKeyword(_ ->identifier(b16).dot().identifier(s).sbrace(_ -> intConstOne()))));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":79,"deletions":94,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.OpTk;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBlockThreadIdOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.OpTk;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalSizeOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.OpTk;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalThreadIdOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.optools.OpTk;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalSizeOp.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import hat.optools.OpTk;\n+\n@@ -33,1 +33,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalThreadIdOp.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import jdk.incubator.code.CodeElement;\n+\n+import java.util.Set;\n+\n+public interface CodeModelPattern {\n+    Set<CodeElement<?, ?>> codeElements();\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/CodeModelPattern.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.Regex;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import static optkl.OpTkl.AnyFieldAccess;\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.javaRefType;\n+\n+public interface ComputeContextPattern extends CodeModelPattern {\n+\n+    static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ComputeContextPattern.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import hat.device.DeviceType;\n+import hat.types.HAType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.ifacemapper.MappableIface;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.function.Predicate;\n+\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isAssignableTo;\n+import static optkl.OpTkl.isMethod;\n+import static optkl.OpTkl.javaRefType;\n+\n+public interface IfaceBufferPattern extends CodeModelPattern {\n+\n+    static boolean isInvokeOp(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n+    }\n+\n+    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+        return isInvokeOp(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n+                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n+                && isMethod(invokeOp, namePredicate);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfaceBufferPattern.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import hat.KernelContext;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.Regex;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import static optkl.OpTkl.AnyFieldAccess;\n+import static optkl.OpTkl.isAssignable;\n+\n+public interface KernelContextPattern extends CodeModelPattern {\n+\n+    static boolean isKernelContext(MethodHandles.Lookup lookup, TypeElement typeElement) {\n+        return isAssignable(lookup, typeElement, KernelContext.class);\n+    }\n+\n+\n+    interface KernelContextFieldAccessPattern extends KernelContextPattern {\n+        static boolean isVarAccessFromKernelContextFieldOp(MethodHandles.Lookup lookup, CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return isKernelContextFieldAccessOp(lookup, varLoadOp, AnyFieldAccess);\/\/varLoadOp.resultType());\n+        }\n+\n+        static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n+            if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp && KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType())) {\n+                return predicate.test(fieldAccessOp) ? fieldAccessOp : null;\n+            }\n+            return null;\n+        }\n+\n+        static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, String name) {\n+            return asKernelContextFieldAccessOrNull(lookup, ce, fieldAccessOp -> name.equals(fieldAccessOp.fieldDescriptor().name()));\n+        }\n+\n+        static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Regex regex) {\n+            return asKernelContextFieldAccessOrNull(lookup, ce, fieldAccessOp -> regex.matches(fieldAccessOp.fieldDescriptor().name()));\n+        }\n+\n+        static boolean isKernelContextFieldAccessOp(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n+            return Objects.nonNull(asKernelContextFieldAccessOrNull(lookup, ce, predicate));\n+        }\n+\n+        static KernelContextFieldAccessPattern matches(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement, Predicate<JavaOp.FieldAccessOp> fieldAccessOpPredicate) {\n+            if (codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp) {\n+                if (KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType()) && fieldAccessOpPredicate.test(fieldAccessOp)) {\n+                    try {\n+                        Field field = fieldAccessOp.fieldDescriptor().resolveToField(lookup);\n+                        record KernelContextFieldAccessPatternImpl(Set<CodeElement<?, ?>> codeElements,\n+                                                                   JavaOp.FieldAccessOp fieldAccessOp,\n+                                                                   Field field, String fieldName,\n+                                                                   TypeElement typeElement) implements KernelContextFieldAccessPattern {\n+                        }\n+                        return new KernelContextFieldAccessPatternImpl(Set.of(fieldAccessOp), fieldAccessOp, field, fieldAccessOp.fieldDescriptor().name(), fieldAccessOp.fieldDescriptor().refType());\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+    }\n+\n+    interface KernelContextInvokePattern extends KernelContextPattern {\n+\n+        static JavaOp.InvokeOp asKernelContextInvokeOpOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n+            return ce instanceof JavaOp.InvokeOp invokeOp\n+                    && KernelContextPattern.isKernelContext(lookup, invokeOp.invokeDescriptor().refType())\n+                    && predicate.test(invokeOp)\n+                    ? invokeOp\n+                    : null;\n+        }\n+\n+        static boolean isKernelContextInvokeOp(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n+            return Objects.nonNull(asKernelContextInvokeOpOrNull(lookup, ce, predicate));\n+        }\n+\n+\n+        static KernelContextInvokePattern matches(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement, Predicate<JavaOp.InvokeOp> invokeOpPredicate) {\n+            record KernelContextInvokePatternImpl(\n+                    Set<CodeElement<?, ?>> codeElements,\n+                    JavaOp.InvokeOp invokeOp,\n+                    Method method,\n+                    String methodName,\n+                    TypeElement typeElement) implements KernelContextInvokePattern {\n+            }\n+\n+            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                if (KernelContextPattern.isKernelContext(lookup, invokeOp.invokeDescriptor().refType()) && invokeOpPredicate.test(invokeOp)) {\n+                    try {\n+                        Method method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n+                        return new KernelContextInvokePatternImpl(Set.of(invokeOp), invokeOp, method, invokeOp.invokeDescriptor().name(), invokeOp.invokeDescriptor().refType());\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/KernelContextPattern.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.types.HAType;\n-import hat.device.DeviceType;\n-import optkl.LookupCarrier;\n-import optkl.OpTkl;\n-import optkl.Regex;\n-import optkl.ifacemapper.MappableIface;\n-import hat.types._V;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-\n-import static optkl.OpTkl.AnyFieldAccess;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.isAssignableTo;\n-import static optkl.OpTkl.isMethod;\n-import static optkl.OpTkl.javaRefType;\n-\n-public interface OpTk extends LookupCarrier  {\n-\n-    static OpTk impl(LookupCarrier lookupCarrier){\n-        record Impl(MethodHandles.Lookup lookup) implements LookupCarrier,OpTk{}\n-        return new Impl(lookupCarrier.lookup());\n-    }\n-\n-    \/* KernelContext *\/\n-\n-   static boolean isKernelContext(MethodHandles.Lookup lookup,TypeElement typeElement){\n-       return isAssignable(lookup,typeElement,KernelContext.class);\n-   }\n-\n-\n-    static JavaOp.InvokeOp asKernelContextInvokeOpOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n-        if (ce instanceof JavaOp.InvokeOp invokeOp) {\n-            if (isKernelContext(lookup, invokeOp.invokeDescriptor().refType())) {\n-                return predicate.test(invokeOp) ? invokeOp : null;\n-            } else if (invokeOp.operands().size() > 1\n-                    && invokeOp.operands().getFirst() instanceof Value value\n-                    && isKernelContext(lookup, value.type())) {\n-             }\n-        }\n-        return null;\n-    }\n-\n-    static boolean isKernelContextInvokeOp(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n-        return Objects.nonNull(asKernelContextInvokeOpOrNull(lookup,ce, predicate));\n-    }\n-\n-\n-    static boolean isVarAccessFromKernelContextFieldOp(MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return isKernelContextFieldAccessOp(lookup, varLoadOp, AnyFieldAccess);\/\/varLoadOp.resultType());\n-    }\n-    static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n-        if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp && isKernelContext(lookup,fieldAccessOp.fieldDescriptor().refType())){\n-            return predicate.test(fieldAccessOp)?fieldAccessOp:null;\n-        }\n-        return null;\n-    }\n-    static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, String name) {\n-        return asKernelContextFieldAccessOrNull(lookup,ce,fieldAccessOp->name.equals(fieldAccessOp.fieldDescriptor().name()));\n-    }\n-    static JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Regex regex) {\n-        return asKernelContextFieldAccessOrNull(lookup,ce,fieldAccessOp->regex.matches(fieldAccessOp.fieldDescriptor().name()));\n-    }\n-    default JavaOp.FieldAccessOp asNamedKernelContextFieldAccessOrNull( CodeElement<?,?> ce, Regex regex) {\n-        return asKernelContextFieldAccessOrNull(lookup(),ce,fieldAccessOp->regex.matches(fieldAccessOp.fieldDescriptor().name()));\n-    }\n-    static boolean isKernelContextFieldAccessOp(MethodHandles.Lookup lookup,CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n-        return Objects.nonNull(asKernelContextFieldAccessOrNull(lookup,ce, predicate));\n-    }\n-\n-    \/* ComputeContext *\/\n-\n-    static boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n-    }\n-\n-    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-        return isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, namePredicate)\n-                || isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class)\n-                && isMethod(invokeOp, namePredicate);\n-    }\n-\n-\n-    \/* ComputeContext *\/\n-\n-    static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n-    }\n-\n-    \/* these seem to be just replacements for isAssignable *\/\n-\n-    static void inspectNewLevelWhy(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n-        if (interfaceClass != null && interfaceSet.add(interfaceClass)) {\n-            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n-            Arrays.stream(interfaceClass.getInterfaces())\n-                    .forEach(superInterface -> inspectNewLevelWhy(superInterface, interfaceSet));\n-        }\n-    }\n-    static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n-        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            Set<Class<?>> interfaces = Set.of();\n-            try {\n-                Class<?> aClass = Class.forName(typeElement.toString());\n-                interfaces = inspectAllInterfacesWhy(aClass);\n-            } catch (ClassNotFoundException _) {\n-            }\n-            return interfaces.contains(_V.class) && isMethod(invokeOp, namePredicate);\n-        }\n-        return false;\n-    }\n-    static boolean isVectorOperation(JavaOp.InvokeOp invokeOp, boolean laneOk) {\n-        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n-        Set<Class<?>> interfaces;\n-        try {\n-            Class<?> aClass = Class.forName(typeElement);\n-            interfaces = inspectAllInterfacesWhy(aClass);\n-        } catch (ClassNotFoundException _) {\n-            return false;\n-        }\n-        return interfaces.contains(_V.class) && laneOk;\n-    }\n-\n-    static Set<Class<?>> inspectAllInterfacesWhy(Class<?> klass) {\n-        Set<Class<?>> interfaceSet = new HashSet<>();\n-        while (klass != null) {\n-            Arrays.stream(klass.getInterfaces())\n-                    .forEach(interfaceClass -> inspectNewLevelWhy(interfaceClass, interfaceSet));\n-            klass = klass.getSuperclass();\n-        }\n-        return interfaceSet;\n-    }\n-\n-\n-    static boolean isInvokeDescriptorSubtypeOf(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Class<?> klass) {\n-\n-        var wouldReturn =  (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt,klass));\n-\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfacesWhy(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        var butReturns =  interfaces.contains(klass);\n-        if (butReturns != wouldReturn){\n-           \/\/ System.out.print(\"isInvokeDescriptorSubtypeOf\");\n-        }\n-        return butReturns;\n-\n-    }\n-\n-    static boolean isInvokeDescriptorSubtypeOfAnyMatch(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Class<?> ... klasses) {\n-\n-        boolean wouldReturn=  (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt,klasses));\n-       boolean butReturns = false;\n-        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfacesWhy(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        for (Class<?> klass : klasses) {\n-            if (interfaces.contains(klass)) {\n-                butReturns =  true;\n-            }\n-        }\n-        if (butReturns != wouldReturn){\n-         \/\/   System.out.print(\"isInvokeDescriptorSubtypeOfAnyMatch\");\n-        }\n-        return butReturns;\n-    }\n-\n-\n-    static int dimIdx(String name){\n-            int dim = name.length()==3?name.charAt(2)-'x':-1;\n-            if (dim <0||dim>3){\n-                throw new IllegalStateException();\/\/'x'=1,'y'=2....\n-            }\n-            return dim;\n-    }\n-    static int dimIdx(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n-        return dimIdx(fieldLoadOp.fieldDescriptor().name());\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import hat.types._V;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import optkl.OpTkl;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import static optkl.OpTkl.isAssignable;\n+import static optkl.OpTkl.isMethod;\n+\n+\/**\n+ * This class needs refactoring\n+ *\n+ * It seems to be a reimplementation of Optkl isAssignable\n+ *\/\n+public class RefactorMe {\n+    private static void inspectNewLevel(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n+        if (interfaceClass != null && interfaceSet.add(interfaceClass)) {\n+            \/\/ only if we add a new interface class, we inspect all interfaces that extends the current inspected class\n+            Arrays.stream(interfaceClass.getInterfaces())\n+                    .forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n+        }\n+    }\n+\n+\n+    public static Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n+        Set<Class<?>> interfaceSet = new HashSet<>();\n+        while (klass != null) {\n+            Arrays.stream(klass.getInterfaces())\n+                    .forEach(interfaceClass -> RefactorMe.inspectNewLevel(interfaceClass, interfaceSet));\n+            klass = klass.getSuperclass();\n+        }\n+        return interfaceSet;\n+    }\n+\n+\n+    public static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n+        if (OpTkl.asResultOrNull(varValue) instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            TypeElement typeElement = varLoadOp.resultType();\n+            Set<Class<?>> interfaces = Set.of();\n+            try {\n+                Class<?> aClass = Class.forName(typeElement.toString());\n+                interfaces = inspectAllInterfaces(aClass);\n+            } catch (ClassNotFoundException _) {\n+            }\n+            return interfaces.contains(_V.class) && isMethod(invokeOp, namePredicate);\n+        }\n+        return false;\n+    }\n+    public static boolean isInvokeDescriptorSubtypeOf(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Class<?> klass) {\n+\n+        var wouldReturn = (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt, klass));\n+\n+        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement.toString());\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+        }\n+        var butReturns = interfaces.contains(klass);\n+        if (butReturns != wouldReturn) {\n+            \/\/ System.out.print(\"isInvokeDescriptorSubtypeOf\");\n+        }\n+        return butReturns;\n+\n+    }\n+\n+    public static boolean isInvokeDescriptorSubtypeOfAnyMatch(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Class<?>... klasses) {\n+\n+        boolean wouldReturn = (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt, klasses));\n+        boolean butReturns = false;\n+        TypeElement typeElement = invokeOp.invokeDescriptor().refType();\n+        Set<Class<?>> interfaces = Set.of();\n+        try {\n+            Class<?> aClass = Class.forName(typeElement.toString());\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+        }\n+        for (Class<?> klass : klasses) {\n+            if (interfaces.contains(klass)) {\n+                butReturns = true;\n+            }\n+        }\n+        if (butReturns != wouldReturn) {\n+            \/\/   System.out.print(\"isInvokeDescriptorSubtypeOfAnyMatch\");\n+        }\n+        return butReturns;\n+    }\n+\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/RefactorMe.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -47,1 +47,0 @@\n-import static hat.optools.OpTk.isVarAccessFromKernelContextFieldOp;\n@@ -340,1 +339,1 @@\n-                            && isVarAccessFromKernelContextFieldOp(lookup,varLoadOp))\n+                            && KernelContextPattern.KernelContextFieldAccessPattern.isVarAccessFromKernelContextFieldOp(lookup,varLoadOp))\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.optools.OpTk;\n+import hat.optools.KernelContextPattern;\n@@ -34,0 +34,2 @@\n+import java.util.Objects;\n+\n@@ -47,2 +49,1 @@\n-                \/* filter op                    *\/ ce -> OpTk.isKernelContextInvokeOp(lookup(), ce,\n-                                                    invokeOp->invokeOp.invokeDescriptor().name().equals(HATBarrierOp.NAME)),\n+                \/* filter op                    *\/ ce -> Objects.nonNull(KernelContextPattern.KernelContextInvokePattern.matches(lookup(), ce, invokeOp->invokeOp.invokeDescriptor().name().equals(HATBarrierOp.NAME))),\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-\n+\/\/recursive\n@@ -99,1 +99,1 @@\n-\n+\/\/recursive\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-import hat.optools.OpTk;\n+import hat.optools.IfaceBufferPattern;\n+import hat.optools.RefactorMe;\n@@ -53,1 +54,0 @@\n-import static hat.optools.OpTk.isIfaceBufferInvokeOpWithName;\n@@ -136,1 +136,1 @@\n-            if (isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n+            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n@@ -166,1 +166,1 @@\n-            if (isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n+            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n@@ -197,1 +197,1 @@\n-            return isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+            return IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n@@ -208,1 +208,1 @@\n-            return OpTk.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n+            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import hat.optools.KernelContextPattern;\n@@ -36,1 +37,1 @@\n-import hat.optools.OpTk;\n+\n@@ -53,1 +54,10 @@\n-\n+    static int dimIdx(String name){\n+        int dim = name.length()==3?name.charAt(2)-'x':-1;\n+        if (dim <0||dim>3){\n+            throw new IllegalStateException();\/\/'x'=1,'y'=2....\n+        }\n+        return dim;\n+    }\n+    static int dimIdx(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp){\n+        return dimIdx(fieldLoadOp.fieldDescriptor().name());\n+    }\n@@ -66,0 +76,4 @@\n+       \/\/ var collect =  funcOp.elements().map(ce-> KernelContextFieldAccessPattern.matches(lookup(),ce, _->true)).filter(Objects::nonNull).toList();\n+        \/\/System.out.println(\"@@@@@@@@@@@@@@@@Found \"+collect.size());\n+\n+\n@@ -67,1 +81,1 @@\n-                ce->OpTk.asNamedKernelContextFieldAccessOrNull(lookup(),ce,regex())!=null,(s,o)->\n+                ce-> KernelContextPattern.KernelContextFieldAccessPattern.asNamedKernelContextFieldAccessOrNull(lookup(),ce,regex())!=null,(s, o)->\n@@ -93,1 +107,1 @@\n-                return HATBlockThreadIdOp.of(OpTk.dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n+                return HATBlockThreadIdOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n@@ -106,1 +120,1 @@\n-                return HATGlobalThreadIdOp.of(OpTk.dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n+                return HATGlobalThreadIdOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n@@ -119,1 +133,1 @@\n-                return  HATGlobalSizeOp.of(OpTk.dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n+                return  HATGlobalSizeOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n@@ -132,1 +146,1 @@\n-                return HATLocalThreadIdOp.of(OpTk.dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n+                return HATLocalThreadIdOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n@@ -145,1 +159,1 @@\n-            return HATLocalSizeOp.of(OpTk.dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n+            return HATLocalSizeOp.of(dimIdx(fieldLoadOp), fieldLoadOp.resultType());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.incubator.code.CodeContext;\n@@ -77,9 +76,1 @@\n-\n-    private final OpView vectorOperation;\n-\n-    public HATDialectifyVectorOpPhase(KernelCallGraph kernelCallGraph, OpView vectorOperation) {\n-        this.kernelCallGraph = kernelCallGraph;\n-        this.vectorOperation = vectorOperation;\n-    }\n-\n-    public enum OpView {\n+    public enum VectorOperation {\n@@ -96,1 +87,1 @@\n-        OpView(String methodName) {\n+        VectorOperation(String methodName) {\n@@ -101,0 +92,8 @@\n+    private final VectorOperation vectorOperation;\n+\n+    public HATDialectifyVectorOpPhase(KernelCallGraph kernelCallGraph, VectorOperation vectorOperation) {\n+        this.kernelCallGraph = kernelCallGraph;\n+        this.vectorOperation = vectorOperation;\n+    }\n+\n+\n@@ -107,1 +106,1 @@\n-\n+    \/\/recursive\n@@ -112,0 +111,1 @@\n+    \/\/recursive\n@@ -123,1 +123,2 @@\n-    private HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType, TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n+    private HATVectorBinaryOp buildVectorBinaryOp(BinaryOpEnum opType, String varName, TypeElement resultType,\n+                                                  TypeElement vectorElementType, int witdh, List<Value> outputOperands) {\n@@ -152,1 +153,2 @@\n-    public void insertBinaryOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData, Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n+    public void insertBinaryOp(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp,\n+                               Map<Op, VectorMetaData> vectorMetaData, Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n@@ -157,1 +159,2 @@\n-        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperands);\n+        HATVectorOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(),\n+                invokeOp.resultType(), vmd.vectorTypeElement(), vmd.lanes(), outputOperands);\n@@ -175,1 +178,2 @@\n-    public void insertVectorBinaryOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n+    public void insertVectorBinaryOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp,\n+                                     Map<JavaOp.InvokeOp, BinaryOpEnum> binaryOperation) {\n@@ -185,1 +189,2 @@\n-    public void insertVectorOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData) {\n+    public void insertVectorOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp,\n+                                 Map<Op, VectorMetaData> vectorMetaData) {\n@@ -195,1 +200,2 @@\n-    public void insertVectorMakeOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp, Map<Op, VectorMetaData> vectorMetaData) {\n+    public void insertVectorMakeOfOp(Block.Builder blockBuilder, JavaOp.InvokeOp invokeOp,\n+                                     Map<Op, VectorMetaData> vectorMetaData) {\n@@ -235,1 +241,0 @@\n-            CodeContext context = blockBuilder.context();\n@@ -445,1 +450,0 @@\n-\n@@ -447,1 +451,1 @@\n-            super(kernelCallGraph, OpView.ADD);\n+            super(kernelCallGraph, VectorOperation.ADD);\n@@ -454,1 +458,1 @@\n-            super(kernelCallGraph, OpView.DIV);\n+            super(kernelCallGraph, VectorOperation.DIV);\n@@ -461,1 +465,1 @@\n-            super(kernelCallGraph, OpView.MAKE_MUTABLE);\n+            super(kernelCallGraph, VectorOperation.MAKE_MUTABLE);\n@@ -468,1 +472,1 @@\n-            super(kernelCallGraph, OpView.FLOAT4_LOAD);\n+            super(kernelCallGraph, VectorOperation.FLOAT4_LOAD);\n@@ -475,1 +479,1 @@\n-            super(kernelCallGraph, OpView.FLOAT2_LOAD);\n+            super(kernelCallGraph, VectorOperation.FLOAT2_LOAD);\n@@ -482,1 +486,1 @@\n-            super(kernelCallGraph, OpView.OF);\n+            super(kernelCallGraph, VectorOperation.OF);\n@@ -489,1 +493,1 @@\n-            super(kernelCallGraph, OpView.MUL);\n+            super(kernelCallGraph, VectorOperation.MUL);\n@@ -496,1 +500,1 @@\n-            super(kernelCallGraph, OpView.SUB);\n+            super(kernelCallGraph, VectorOperation.SUB);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import hat.optools.OpTk;\n+import hat.types._V;\n@@ -48,0 +48,1 @@\n+import static hat.optools.RefactorMe.inspectAllInterfaces;\n@@ -58,1 +59,11 @@\n-\n+    static boolean isVectorOperation(JavaOp.InvokeOp invokeOp, boolean laneOk) {\n+        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n+        Set<Class<?>> interfaces;\n+        try {\n+            Class<?> aClass = Class.forName(typeElement);\n+            interfaces = inspectAllInterfaces(aClass);\n+        } catch (ClassNotFoundException _) {\n+            return false;\n+        }\n+        return interfaces.contains(_V.class) && laneOk;\n+    }\n@@ -101,1 +112,1 @@\n-                        if (OpTk.isVectorOperation(invokeOp, isVectorLane(invokeOp)) && (invokeOp.resultType() != JavaType.VOID)) {\n+                        if (isVectorOperation(invokeOp, isVectorLane(invokeOp)) && (invokeOp.resultType() != JavaType.VOID)) {\n@@ -156,1 +167,1 @@\n-                        if (OpTk.isVectorOperation(invokeOp, isVectorLane(invokeOp))) {\n+                        if (isVectorOperation(invokeOp, isVectorLane(invokeOp))) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-import hat.optools.OpTk;\n+import hat.optools.RefactorMe;\n+import hat.types._V;\n@@ -47,1 +48,0 @@\n-\n@@ -50,1 +50,2 @@\n-public abstract sealed class HATDialectifyVectorStorePhase implements HATDialectPhase {\n+public abstract sealed class HATDialectifyVectorStorePhase implements HATDialectPhase\n+        permits HATDialectifyVectorStorePhase.Float2StorePhase,HATDialectifyVectorStorePhase.Float4StorePhase{\n@@ -56,3 +57,1 @@\n-    private final StoreView vectorOperation;\n-\n-    public HATDialectifyVectorStorePhase(KernelCallGraph kernelCallGraph, StoreView vectorOperation) {\n+    public HATDialectifyVectorStorePhase(KernelCallGraph kernelCallGraph\/*, StoreView vectorOperation*\/) {\n@@ -60,1 +59,0 @@\n-        this.vectorOperation = vectorOperation;\n@@ -63,8 +61,0 @@\n-    public enum StoreView {\n-        FLOAT4_STORE(\"storeFloat4View\"),\n-        FLOAT2_STORE(\"storeFloat2View\");\n-        final String methodName;\n-        StoreView(String methodName) {\n-            this.methodName = methodName;\n-        }\n-    }\n@@ -91,0 +81,2 @@\n+\n+\n@@ -94,0 +86,4 @@\n+        String vectorOperation = switch (this) {\n+            case Float2StorePhase _ -> \"storeFloat2View\";\n+            case Float4StorePhase _ -> \"storeFloat4View\";\n+        };\n@@ -99,1 +95,1 @@\n-                            (OpTk.isVectorOperation(invokeOp, invokeOp.operands().get(1),n->n.equals(vectorOperation.methodName)))) {\n+                            (RefactorMe.isVectorOperation(invokeOp, invokeOp.operands().get(1), n->n.equals(vectorOperation)))) {\n@@ -134,1 +130,1 @@\n-            super(kernelCallGraph, StoreView.FLOAT4_STORE);\n+            super(kernelCallGraph);\n@@ -140,1 +136,1 @@\n-            super(kernelCallGraph, StoreView.FLOAT2_STORE);\n+            super(kernelCallGraph);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.optools.KernelContextPattern;\n@@ -32,1 +33,0 @@\n-import hat.optools.OpTk;\n@@ -38,0 +38,1 @@\n+import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.isKernelContextFieldAccessOp;\n@@ -50,1 +51,1 @@\n-        if (OpTk.isKernelContextFieldAccessOp(buildContext.lookup,fieldLoadOp,_->true)) {\n+        if (isKernelContextFieldAccessOp(buildContext.lookup,fieldLoadOp, _->true)) {\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}