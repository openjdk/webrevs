{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import hat.optools.IfaceBufferPattern;\n@@ -35,0 +34,1 @@\n+import optkl.Invoke;\n@@ -46,1 +46,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -55,0 +54,1 @@\n+import static optkl.Invoke.invokeOpHelper;\n@@ -445,3 +445,3 @@\n-            if (op instanceof JavaOp.InvokeOp invokeOp){\n-                if (IfaceBufferPattern.isInvokeOp(lookup,invokeOp)\n-                        && invokeOp.operands().getFirst() instanceof Op.Result invokeResult\n+            if (invokeOpHelper(lookup,op) instanceof Invoke invoke){\n+                if (invoke.isMappableIface()\n+                        && invoke.op().operands().getFirst() instanceof Op.Result invokeResult\n@@ -451,1 +451,1 @@\n-                    List<Value> inputOperands = invokeOp.operands();\n+                    List<Value> inputOperands = invoke.op().operands();\n@@ -453,1 +453,1 @@\n-                    Op.Result inputResult = invokeOp.result();\n+                   \/\/ Op.Result inputResult = invokeOp.result();\n@@ -455,1 +455,1 @@\n-                    PTXPtrOp ptxOp = new PTXPtrOp(inputResult.type(), invokeOp.invokeDescriptor().name(), outputOperands, boundSchema);\n+                    PTXPtrOp ptxOp = new PTXPtrOp(invoke.returnType(), invoke.name(), outputOperands, boundSchema);\n@@ -457,4 +457,4 @@\n-                    cc.mapValue(inputResult, outputResult);\n-                } else if (invokeOp.invokeDescriptor().refType().toString().equals(\"java.lang.Math\")\n-                        && mathFns.containsKey(invokeOp.invokeDescriptor().name() + \"_\" + invokeOp.resultType().toString())){\n-                    usedMathFns.add(invokeOp.invokeDescriptor().name() + \"_\" + invokeOp.resultType().toString());\n+                    cc.mapValue(invoke.op().result(), outputResult);\n+                } else if (invoke.refIs(Math.class)\n+                        && mathFns.containsKey(invoke.name() + \"_\" + invoke.returnType().toString())){\n+                    usedMathFns.add(invoke.name() + \"_\" + invoke.returnType().toString());\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import hat.optools.*;\n-import optkl.FieldAccess;\n@@ -31,1 +29,0 @@\n-import optkl.OpTkl;\n@@ -49,1 +46,1 @@\n-import static optkl.Invoke.methodOrThrow;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -147,1 +144,1 @@\n-            if (op instanceof JavaOp.InvokeOp invoke && !IfaceBufferPattern.isInvokeOp(MethodHandles.lookup(),invoke)) {\n+            if (invokeOpHelper(lookup,op) instanceof Invoke invoke && !invoke.isMappableIface()) {\n@@ -188,1 +185,1 @@\n-            case JavaOp.InvokeOp $ -> methodCall($);\n+            case JavaOp.InvokeOp $ -> methodCall(invokeOpHelper(lookup,$));\n@@ -453,3 +450,3 @@\n-    public void methodCall(JavaOp.InvokeOp invokeOp) {\n-        Invoke invoke = Invoke.invokeOpHelper(MethodHandles.lookup(),invokeOp);\n-        switch (invokeOp.invokeDescriptor().toString()) {\n+    public void methodCall(Invoke invoke) {\n+       \/\/ Invoke invoke = Invoke.invokeOpHelper(MethodHandles.lookup(),invokeOp);\n+        switch (invoke.op().invokeDescriptor().toString()) {\n@@ -493,1 +490,1 @@\n-                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(methodOrThrow(MethodHandles.lookup(),invoke).getName()).commaSpace();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().identifier(invoke.name()).commaSpace();\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-import hat.optools.ComputeContextPattern;\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.KernelContextPattern;\n+import hat.KernelContext;\n@@ -36,1 +34,0 @@\n-import optkl.OpTkl;\n@@ -47,1 +44,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -59,1 +55,0 @@\n-import static optkl.Invoke.methodOrThrow;\n@@ -144,1 +139,1 @@\n-                    if (IfaceBufferPattern.isInvokeOp(lookup(), invoke.op()) && invoke.returnsVoid()) {                    \/\/ iface.v(newV)\n+                    if (invoke.isMappableIface() && invoke.returnsVoid()) {                    \/\/ iface.v(newV)\n@@ -149,1 +144,1 @@\n-                    } else if (IfaceBufferPattern.isInvokeOp(lookup(), invoke.op())\n+                    } else if (invoke.isMappableIface()\n@@ -163,2 +158,1 @@\n-                    } else if (ComputeContextPattern.isComputeContextMethod(lookup(),invoke.op())\n-                            || KernelContextPattern.KernelContextInvokePattern.isKernelContextInvokeOp(lookup(),invoke.op(),OpTkl.AnyInvoke)) { \/\/dispatchKernel\n+                    } else if (invoke.refIs(ComputeContext.class,KernelContext.class)) { \/\/dispatchKernel\n@@ -171,1 +165,0 @@\n-                            var m = methodOrThrow(lookup(), invoke);\n@@ -173,1 +166,3 @@\n-                            Annotation[][] parameterAnnotations = m.getParameterAnnotations();\n+                            var method = invoke.resolveMethodOrThrow();\n+\n+                            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import hat.optools.ComputeContextPattern;\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.KernelContextPattern;\n@@ -34,3 +31,0 @@\n-import optkl.util.CallSite;\n-import optkl.OpTkl;\n-import optkl.ifacemapper.Buffer;\n@@ -38,3 +32,0 @@\n-import optkl.ifacemapper.MappableIface;\n-import optkl.FuncOpParams;\n-import jdk.incubator.code.Value;\n@@ -43,3 +34,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -51,6 +39,0 @@\n-import static hat.ComputeContext.WRAPPER.ACCESS;\n-import static hat.ComputeContext.WRAPPER.MUTATE;\n-import static optkl.OpTkl.classTypeToTypeOrThrow;\n-import static optkl.OpTkl.isAssignable;\n-import static optkl.OpTkl.transform;\n-\n@@ -64,1 +46,0 @@\n-        var here = CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import static optkl.Invoke.methodOrThrow;\n+import static optkl.Invoke.getTargetInvoke;\n@@ -53,1 +53,0 @@\n-import static optkl.OpTkl.getTargetInvokeOp;\n@@ -197,1 +196,1 @@\n-        Method method = methodOrThrow(lookup,getTargetInvokeOp(this.lookup,lambda, ComputeContext.class));\n+        Method method = getTargetInvoke(this.lookup,lambda, ComputeContext.class).resolveMethodOrThrow();\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static optkl.Invoke.getTargetInvoke;\n@@ -51,1 +52,0 @@\n-import static optkl.OpTkl.getTargetInvokeOp;\n@@ -163,1 +163,1 @@\n-            MethodRef methodRef = getTargetInvokeOp(this.lookup(), lambdaOp, KernelContext.class).op().invokeDescriptor();\n+            MethodRef methodRef = getTargetInvoke(this.lookup(), lambdaOp, KernelContext.class).op().invokeDescriptor();\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import static optkl.Invoke.javaRefClassOrThrow;\n@@ -86,1 +85,1 @@\n-                Class<?> javaRefTypeClass = javaRefClassOrThrow(lookup(), invoke.op());\n+                Class<?> javaRefTypeClass = invoke.classOrThrow();\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import static optkl.Invoke.javaRefClassOrThrow;\n+import static optkl.Invoke.invokeOpHelper;\n@@ -140,3 +140,4 @@\n-    public boolean filterCalls(CoreOp.FuncOp f, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n-        if (entrypoint.method.getDeclaringClass().equals(javaRefClassOrThrow(computeContext.lookup(),invokeOp))\n-                && isValidKernelDispatch(computeContext.lookup(),method, f)) {\n+    public boolean filterCalls(CoreOp.FuncOp funcOp, JavaOp.InvokeOp invokeOp, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n+        var invoke = invokeOpHelper(computeContext.lookup(),invokeOp);\n+        if (entrypoint.method.getDeclaringClass().equals(invoke.classOrThrow())\n+                && isValidKernelDispatch(computeContext.lookup(),method, funcOp)) {\n@@ -145,1 +146,1 @@\n-                    new KernelCallGraph(this, methodRef, method, f)\n+                    new KernelCallGraph(this, methodRef, method, funcOp)\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import hat.optools.IfaceBufferPattern;\n-import hat.optools.RefactorMe;\n@@ -45,1 +43,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n@@ -48,1 +45,0 @@\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -53,2 +49,0 @@\n-import java.lang.invoke.MethodHandles;\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.KernelContext;\n@@ -29,0 +30,1 @@\n+import optkl.FieldAccess;\n@@ -40,1 +42,0 @@\n-import static hat.optools.KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull;\n@@ -54,1 +55,1 @@\n-        if (asKernelContextFieldAccessOrNull(buildContext.lookup,fieldLoadOp, _->true)!=null) {\n+        if ( fieldAccess.refType(KernelContext.class)) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/JavaHATCodeBuilder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+    public HATBarrierOp() {\n+        super(List.of());\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBarrierOp.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import jdk.incubator.code.CodeElement;\n-\n-import java.util.Set;\n-\n-public interface CodeModelPattern {\n-    Set<CodeElement<?, ?>> codeElements();\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/CodeModelPattern.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.ComputeContext;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.Invoke;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static optkl.Invoke.invokeOpHelper;\n-\n-public interface ComputeContextPattern extends CodeModelPattern {\n-\n-    static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return invokeOpHelper(lookup,invokeOp) instanceof Invoke invoke && invoke.refIs( ComputeContext.class);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ComputeContextPattern.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.device.DeviceType;\n-import hat.types.HAType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.Invoke;\n-import optkl.ifacemapper.MappableIface;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.function.Predicate;\n-\n-import static optkl.Invoke.invokeOpHelper;\n-\n-public interface IfaceBufferPattern extends CodeModelPattern {\n-\n-    static boolean isInvokeOp(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return invokeOpHelper(lookup,invokeOp) instanceof Invoke invoke && invoke.refIs(MappableIface.class);\/\/;isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n-    }\n-\n-    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n-\n-        return invokeOpHelper(lookup,invokeOp) instanceof Invoke  invoke\n-                && invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n-                && namePredicate.test(invoke.name());\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/IfaceBufferPattern.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.optools;\n-\n-import hat.KernelContext;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import optkl.util.Regex;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.function.Predicate;\n-\n-import static optkl.OpTkl.AnyFieldAccess;\n-import static optkl.OpTkl.isAssignable;\n-\n-public interface KernelContextPattern extends CodeModelPattern {\n-\n-    private static boolean isKernelContext(MethodHandles.Lookup lookup, TypeElement typeElement) {\n-        return isAssignable(lookup, typeElement, KernelContext.class);\n-    }\n-\n-\n-    interface KernelContextFieldAccessPattern extends KernelContextPattern {\n-\n-        static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n-            if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp\n-                    && KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType())) {\n-                return predicate.test(fieldAccessOp) ? fieldAccessOp : null;\n-            }\n-            return null;\n-        }\n-\n-        static KernelContextFieldAccessPattern matches(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement, Predicate<JavaOp.FieldAccessOp> fieldAccessOpPredicate) {\n-            if (codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp) {\n-                if (KernelContextPattern.isKernelContext(lookup, fieldAccessOp.fieldDescriptor().refType()) && fieldAccessOpPredicate.test(fieldAccessOp)) {\n-                    try {\n-                        Field field = fieldAccessOp.fieldDescriptor().resolveToField(lookup);\n-                        record KernelContextFieldAccessPatternImpl(Set<CodeElement<?, ?>> codeElements,\n-                                                                   JavaOp.FieldAccessOp fieldAccessOp,\n-                                                                   Field field, String fieldName,\n-                                                                   TypeElement typeElement) implements KernelContextFieldAccessPattern {\n-                        }\n-                        return new KernelContextFieldAccessPatternImpl(Set.of(fieldAccessOp), fieldAccessOp, field, fieldAccessOp.fieldDescriptor().name(), fieldAccessOp.fieldDescriptor().refType());\n-                    } catch (ReflectiveOperationException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n-    }\n-\n-    interface KernelContextInvokePattern extends KernelContextPattern {\n-\n-        static JavaOp.InvokeOp asKernelContextInvokeOpOrNull(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n-            return ce instanceof JavaOp.InvokeOp invokeOp\n-                    && KernelContextPattern.isKernelContext(lookup, invokeOp.invokeDescriptor().refType())\n-                    && predicate.test(invokeOp)\n-                    ? invokeOp\n-                    : null;\n-        }\n-\n-        static boolean isKernelContextInvokeOp(MethodHandles.Lookup lookup, CodeElement<?, ?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n-            return Objects.nonNull(asKernelContextInvokeOpOrNull(lookup, ce, predicate));\n-        }\n-\n-\n-        static KernelContextInvokePattern matches(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement, Predicate<JavaOp.InvokeOp> invokeOpPredicate) {\n-            record KernelContextInvokePatternImpl(\n-                    Set<CodeElement<?, ?>> codeElements,\n-                    JavaOp.InvokeOp invokeOp,\n-                    Method method,\n-                    String methodName,\n-                    TypeElement typeElement) implements KernelContextInvokePattern {\n-            }\n-\n-            if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                if (KernelContextPattern.isKernelContext(lookup, invokeOp.invokeDescriptor().refType()) && invokeOpPredicate.test(invokeOp)) {\n-                    try {\n-                        Method method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n-                        return new KernelContextInvokePatternImpl(Set.of(invokeOp), invokeOp, method, invokeOp.invokeDescriptor().name(), invokeOp.invokeDescriptor().refType());\n-                    } catch (ReflectiveOperationException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/KernelContextPattern.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.CodeElement;\n@@ -35,1 +36,0 @@\n-import java.util.List;\n@@ -37,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -43,18 +42,12 @@\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp fromFuncOp) {\n-         Set<CoreOp.VarAccessOp.VarLoadOp> varLoadOpSet = new HashSet<>();\n-         var trxfmr = Trxfmr.of(fromFuncOp);\n-         trxfmr.transform(\n-                 \/* predicate *\/     ce-> invokeOpHelper(lookup(),ce) instanceof Invoke $&&$ .named(HATBarrierOp.NAME),\n-                 \/* transformation *\/c-> {\n-                     varLoadOpSet.add((CoreOp.VarAccessOp.VarLoadOp) ((Op.Result)c.op().operands().getFirst()).op());\n-                     c.replace(new HATBarrierOp(List.of()));\n-                 });\n-         var newSet=     varLoadOpSet.stream().map(varLoadOp ->trxfmr.biMap.getTo(varLoadOp)).collect(Collectors.toSet());\n-         trxfmr.transform(\n-                \/* predicate *\/   ce-> ce instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n-                         \/\/&& trxfmr.biMap.containsFrom(varLoadOp),\n-                         && newSet.contains(varLoadOp),\n-                \/* transformation *\/c-> c.remove()\n-        );\n-\n-         return trxfmr.funcOp();\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+         Set<CodeElement<?,?>> removeMe = new HashSet<>();\n+         return Trxfmr.of(funcOp)\n+                 .transform(\n+                     ce-> invokeOpHelper(lookup(),ce) instanceof Invoke $ && $.named(HATBarrierOp.NAME), \/* predicate *\/\n+                     c-> {\n+                        removeMe.add(((Op.Result)c.op().operands().getFirst()).op());\n+                        c.replace(new HATBarrierOp());\n+                    })\n+                 .remap(removeMe) \/\/ replaced varOps with new identities\n+                 .remove(removeMe::contains)\n+                 .funcOp();\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATBarrierPhase.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import hat.optools.IfaceBufferPattern;\n@@ -33,0 +32,1 @@\n+import hat.types.HAType;\n@@ -39,2 +39,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.PrimitiveType;\n@@ -42,0 +40,1 @@\n+import optkl.ifacemapper.MappableIface;\n@@ -53,1 +52,0 @@\n-import static optkl.OpTkl.isAssignable;\n@@ -55,0 +53,1 @@\n+import static optkl.Trxfmr.copyLocation;\n@@ -77,1 +76,1 @@\n-    protected abstract boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp);\n+    protected abstract boolean isIfaceBufferInvokeWithName(Invoke invoke);\n@@ -98,1 +97,1 @@\n-                                && isIfaceBufferInvokeWithName(invokeOp))\n+                                && isIfaceBufferInvokeWithName(invokeOpHelper(lookup(),invokeOp)))\n@@ -108,4 +107,3 @@\n-                invokeOp.result()\n-                        .uses()\n-                        .stream()\n-                        .filter(r->r.op() instanceof CoreOp.VarOp).map(r->(CoreOp.VarOp)r.op())\n+                invokeOp.result().uses().stream()\n+                        .filter(result->result.op() instanceof CoreOp.VarOp)\n+                        .map(r->(CoreOp.VarOp)r.op())\n@@ -116,1 +114,1 @@\n-                      blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n+                blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n@@ -133,4 +131,3 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp) {\n-            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(), invokeOp, n->n.equals(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME))) {\n-                return true;\n-            } else {\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke) {\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                    && invoke.named(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME);\n@@ -138,4 +135,0 @@\n-                return invokeOpHelper(lookup(),invokeOp) instanceof  Invoke invoke\n-                        && invoke.named(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME)\n-                        && invoke.refIs(DeviceType.class);\n-            }\n@@ -159,1 +152,0 @@\n-\n@@ -165,10 +157,4 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            if (IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))) {\n-                return true;\n-            } else {\n-                return invokeOpHelper(lookup(),invokeOp) instanceof  Invoke invoke\n-                      && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME)\n-                        && invoke.refIs(DeviceType.class);\n-                     \/\/   && invokeOp.resultType() instanceof JavaType javaType &&\n-                       \/\/ isAssignable(lookup(),javaType,DeviceType.class));\n-            }\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                    && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME);\n+\n@@ -179,1 +165,1 @@\n-            var op = new HATMemoryVarOp.HATLocalVarOp(\n+            return  copyLocation(varOp,new HATMemoryVarOp.HATLocalVarOp(\n@@ -185,3 +171,1 @@\n-            );\n-            op.setLocation(varOp.location());\n-            return op;\n+            ));\n@@ -198,7 +182,3 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            return IfaceBufferPattern.isIfaceBufferInvokeOpWithName(lookup(),invokeOp, n->n.equals(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-               || (\n-                    invokeOpHelper(lookup(),invokeOp) instanceof  Invoke invoke\n-                    && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME))\n-                    && invoke.returnType() instanceof JavaType javaType\n-                    && invoke.returns(DeviceType.class);\n+        protected boolean isIfaceBufferInvokeWithName(Invoke invoke){\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n+                 || invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME);\n@@ -207,3 +187,0 @@\n-         private boolean isDeviceTypeReservedMethod(JavaOp.InvokeOp invokeOp){\n-            return reservedMethods.contains(invokeOp.invokeDescriptor().name());\n-        }\n@@ -211,5 +188,5 @@\n-        private boolean meetConditionsForMemoryLoadOp(JavaOp.InvokeOp invokeOp) {\n-            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invokeOp, DeviceType.class)\n-                    && (invokeOp.resultType() != JavaType.VOID)\n-                    && (!(invokeOp.resultType() instanceof PrimitiveType))\n-                    && (!isDeviceTypeReservedMethod(invokeOp));\n+        private boolean meetConditionsForMemoryLoadOp(Invoke invoke) {\n+            return RefactorMe.isInvokeDescriptorSubtypeOf(lookup(),invoke.op(), DeviceType.class)\n+                    && !invoke.returnsVoid()\n+                    && !invoke.returnsPrimitive()\n+                    && !reservedMethods.contains(invoke.name());\n@@ -225,3 +202,3 @@\n-                        if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                            if (meetConditionsForMemoryLoadOp(invokeOp)) {\n-                                Op.Result result = invokeOp.result();\n+                        if (invokeOpHelper(lookup(),codeElement) instanceof Invoke invoke) {\n+                            if (meetConditionsForMemoryLoadOp(invoke)) {\n+                                Op.Result result = invoke.op().result();\n@@ -231,2 +208,2 @@\n-                                        varTable.put(varOp, invokeOp);\n-                                        consumer.accept(invokeOp);\n+                                        varTable.put(varOp, invoke.op());\n+                                        consumer.accept(invoke.op());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":31,"deletions":54,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.KernelContext;\n@@ -30,1 +31,1 @@\n-import hat.optools.KernelContextPattern;\n+import optkl.FieldAccess;\n@@ -40,0 +41,2 @@\n+\n+import static optkl.FieldAccess.fieldAccessOpHelper;\n@@ -69,2 +72,6 @@\n-                ce-> KernelContextPattern.KernelContextFieldAccessPattern.asKernelContextFieldAccessOrNull(\n-                        lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null,(s, o)->\n+                ce-> fieldAccessOpHelper(lookup(),ce) instanceof FieldAccess fieldAccess\n+                        && fieldAccess.refType(KernelContext.class)\n+                && fieldAccess.named(fieldNameRegex)\n+              \/\/  fieldAccessOpKernelContextPattern.asKernelContextFieldAccessOrNull(\n+        \/\/                lookup(),ce,fieldAccessOp->fieldNameRegex.matches(fieldAccessOp.fieldDescriptor().name()))!=null\n+        ,(s, o)->\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATThreadsPhase.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -53,1 +53,3 @@\n-\n+    default boolean refType(Class<?> ... classes){\n+        return OpTkl.isAssignable(lookup(),refType(),classes);\n+    }\n@@ -68,4 +70,0 @@\n-    default  <T>boolean of(Class<T> clazz){\n-        return isAssignable((JavaType) op().resultType(),clazz);\n-    }\n-\n@@ -75,1 +73,0 @@\n-\n@@ -77,3 +74,0 @@\n-\n-\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/FieldAccess.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import optkl.ifacemapper.MappableIface;\n@@ -39,0 +40,1 @@\n+import java.util.function.Predicate;\n@@ -130,1 +132,1 @@\n-    static Method methodOrThrow(MethodHandles.Lookup lookup, Invoke invoke) {\n+    default Method resolveMethodOrNull() {\n@@ -132,1 +134,8 @@\n-            return invoke.op().invokeDescriptor().resolveToMethod(lookup);\n+            return op().invokeDescriptor().resolveToMethod(lookup());\n+        } catch (ReflectiveOperationException e) {\n+           return null;\n+        }\n+    }\n+    default Method resolveMethodOrThrow() {\n+        try {\n+            return op().invokeDescriptor().resolveToMethod(lookup());\n@@ -138,3 +147,3 @@\n-    static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-        if (invokeOpHelper(lookup,op) instanceof Invoke invoke && invoke.refType() instanceof ClassType classType) {\n-            return (Class<?>) OpTkl.classTypeToTypeOrThrow(lookup, classType);\n+    default Class<?> classOrThrow() {\n+        if (refType() instanceof ClassType classType) {\n+            return (Class<?>) OpTkl.classTypeToTypeOrThrow(lookup(), classType);\n@@ -146,0 +155,13 @@\n+    default boolean isMappableIface() {\n+        return refIs(MappableIface.class);\n+    }\n+    static Invoke getTargetInvoke(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n+        return lambdaOp.body().entryBlock().ops().stream()\n+                .filter(ce -> ce instanceof JavaOp.InvokeOp)\n+                .map(ce -> invokeOpHelper(lookup,ce))\n+                .filter(Invoke::isStatic)\n+                .filter(invoke -> OpTkl.isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n+                .findFirst()\n+                .orElseThrow();\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Invoke.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -33,3 +31,0 @@\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n@@ -38,1 +33,0 @@\n-import static optkl.Invoke.invokeOpHelper;\n@@ -108,3 +102,0 @@\n-\n-\n-\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import optkl.util.carriers.LookupCarrier;\n@@ -44,1 +43,0 @@\n-import java.lang.reflect.Field;\n@@ -57,1 +55,0 @@\n-import static optkl.Invoke.invokeOpHelper;\n@@ -60,3 +57,0 @@\n-    Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _ -> true;\n-    Predicate<JavaOp.InvokeOp> AnyInvoke = _ -> true;\n-\n@@ -81,9 +75,1 @@\n-    static Invoke getTargetInvokeOp(MethodHandles.Lookup lookup, JavaOp.LambdaOp lambdaOp, Class<?>... classes) {\n-        return lambdaOp.body().entryBlock().ops().stream()\n-                .filter(ce -> ce instanceof JavaOp.InvokeOp)\n-                .map(ce -> invokeOpHelper(lookup,ce))\n-                .filter(Invoke::isStatic)\n-                .filter(invoke -> isAssignable(lookup, invoke.op().operands().getFirst().type(), classes))\n-                .findFirst()\n-                .orElseThrow();\n-    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -57,0 +58,12 @@\n+\n+    public Trxfmr remove(Predicate<CodeElement<?,?>> codeElementPredicate) {\n+        return transform(codeElementPredicate, c-> c.remove());\n+    }\n+\n+    public Trxfmr remap(Set<CodeElement<?,?>> set) {\n+        var newSet =  set.stream().map(biMap::getTo).collect(Collectors.toSet());\n+        set.clear();\n+        set.addAll(newSet);\n+        return this;\n+    }\n+\n@@ -288,1 +301,1 @@\n-    public final BiMap<Op,Op> biMap = new BiMap<>();\n+    public final BiMap<CodeElement<?,?>,CodeElement<?,?>> biMap = new BiMap<>();\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/Trxfmr.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}