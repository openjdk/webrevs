{"files":[{"patch":"@@ -127,0 +127,2 @@\n+    private final TypeEnvs typeEnvs;\n+    private final Flow flow;\n@@ -151,0 +153,2 @@\n+        typeEnvs = TypeEnvs.instance(context);\n+        flow = Flow.instance(context);\n@@ -704,0 +708,17 @@\n+        private void appendReturnOrUnreachable(JCTree body) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                \/\/ If control can continue after the body append return.\n+                \/\/ Otherwise, append unreachable.\n+                if (isAliveAfter(body)) {\n+                    append(CoreOp._return());\n+                } else {\n+                    append(CoreOp.unreachable());\n+                }\n+            }\n+        }\n+\n+        private boolean isAliveAfter(JCTree node) {\n+            return flow.aliveAfter(typeEnvs.get(currentClassSym), node, make);\n+        }\n+\n@@ -1491,2 +1512,1 @@\n-                    \/\/ @@@ Check if unreachable\n-                    appendTerminating(CoreOp::_return);\n+                    appendReturnOrUnreachable(tree.body);\n@@ -2482,2 +2502,1 @@\n-            \/\/ @@@ Check if unreachable\n-            appendTerminating(CoreOp::_return);\n+            appendReturnOrUnreachable(body);\n@@ -2491,0 +2510,1 @@\n+            \/\/ Return the quoted result\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                return;\n+                unreachable;\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-                return;\n+                unreachable;\n@@ -447,1 +447,1 @@\n-                return;\n+                unreachable;\n@@ -473,1 +473,1 @@\n-                return;\n+                unreachable;\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-              return;\n+              unreachable;\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                return;\n+                unreachable;\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-                return;\n+                unreachable;\n","filename":"test\/langtools\/tools\/javac\/reflect\/TryTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.IntUnaryOperator;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with unreachable areas.\n+ * @enablePreview\n+ * @build UnreachableTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester UnreachableTest\n+ *\/\n+\n+public class UnreachableTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" ()void -> {\n+                java.block ()void -> {\n+                    return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    static void test1() {\n+        {\n+            return;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : int)int -> {\n+                %1 : Var<int> = var %0 @\"i\";\n+                java.block ()void -> {\n+                    %2 : int = var.load %1;\n+                    return %2;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    static int test2(int i) {\n+        {\n+            return i;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : int)int -> {\n+                %1 : Var<int> = var %0 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %2 : boolean = constant @\"true\";\n+                        yield %2;\n+                    }\n+                    ()void -> {\n+                        %3 : int = var.load %1;\n+                        return %3;\n+                    }\n+                    ()void -> {\n+                        %4 : int = var.load %1;\n+                        return %4;\n+                    };\n+                unreachable;\n+            };\n+            \"\"\")\n+    static int test3(int i) {\n+        if (true) {\n+            return i;\n+        } else {\n+            return i;\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" ()void -> {\n+                %0 : java.util.function.IntUnaryOperator = lambda (%1 : int)int -> {\n+                    %2 : Var<int> = var %1 @\"i\";\n+                    java.if\n+                        ()boolean -> {\n+                            %3 : boolean = constant @\"true\";\n+                            yield %3;\n+                        }\n+                        ()void -> {\n+                            %4 : int = var.load %2;\n+                            return %4;\n+                        }\n+                        ()void -> {\n+                            %5 : int = var.load %2;\n+                            return %5;\n+                        };\n+                    unreachable;\n+                };\n+                %6 : Var<java.util.function.IntUnaryOperator> = var %0 @\"f\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test4() {\n+        IntUnaryOperator f = (int i) -> {\n+            if (true) {\n+                return i;\n+            } else {\n+                return i;\n+            }\n+        };\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %1 : java.util.function.IntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"i\";\n+                    java.if\n+                        ()boolean -> {\n+                            %4 : boolean = constant @\"true\";\n+                            yield %4;\n+                        }\n+                        ()void -> {\n+                            %5 : int = var.load %3;\n+                            return %5;\n+                        }\n+                        ()void -> {\n+                            %6 : int = var.load %3;\n+                            return %6;\n+                        };\n+                    unreachable;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTABLE_TEST = (IntUnaryOperator & Quotable) (int i) -> {\n+        if (true) {\n+            return i;\n+        } else {\n+            return i;\n+        }\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %1 : func<int, int> = closure (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"i\";\n+                    java.if\n+                        ()boolean -> {\n+                            %4 : boolean = constant @\"true\";\n+                            yield %4;\n+                        }\n+                        ()void -> {\n+                            %5 : int = var.load %3;\n+                            return %5;\n+                        }\n+                        ()void -> {\n+                            %6 : int = var.load %3;\n+                            return %6;\n+                        };\n+                    unreachable;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_TEST = (int i) -> {\n+        if (true) {\n+            return i;\n+        } else {\n+            return i;\n+        }\n+    };\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/UnreachableTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"}]}