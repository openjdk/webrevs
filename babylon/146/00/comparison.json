{"files":[{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package experiments;\n+\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.constant.ClassDesc;\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+public class LayoutExample {\n+\n+    \/*\n+    struct {\n+      StructTwo struct;\n+      int i;\n+    }\n+     *\/\n+    @Struct\n+    public interface StructOne {\n+        StructTwo struct();\n+\n+        int i();\n+\n+        void i(int v);\n+\n+        static MemoryLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                        StructTwo.layout().withName(StructTwo.layout().name().orElseThrow() + \"::struct\"),\n+                        ValueLayout.JAVA_INT.withName(\"i\"))\n+                \/\/ Symbolic reference to interface\n+                \/\/ @@@ Use externalized type element form?\n+                .withName(\"layouts.LayoutExample$StructOne\");\n+    }\n+\n+    \/*\n+    struct {\n+      int i;\n+      float f;\n+    }\n+     *\/\n+    @Struct\n+    public interface StructTwo {\n+        int i();\n+\n+        void i(int v);\n+\n+        float f();\n+\n+        void f(float v);\n+\n+        static MemoryLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"i\"),\n+                        ValueLayout.JAVA_FLOAT.withName(\"f\"))\n+                \/\/ Symbolic reference to interface\n+                \/\/ @@@ Use externalized type element form?\n+                .withName(\"layouts.LayoutExample$StructTwo\");\n+    }\n+\n+    @CodeReflection\n+    static float m(StructOne s1) {\n+        \/\/ StructOne* s1\n+        \/\/ s1 -> i\n+        int i = s1.i();\n+        \/\/ s1 -> *s2\n+        StructTwo s2 = s1.struct();\n+        \/\/ s2 -> i\n+        i += s2.i();\n+        \/\/ s2 -> f\n+        float f = s2.f();\n+        return i + f;\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        CoreOp.FuncOp m = getFuncOp(\"m\");\n+        m = SSA.transform(m);\n+        System.out.println(m.toText());\n+\n+        CoreOp.FuncOp pm = transformInvokesToPtrs(MethodHandles.lookup(), m);\n+        System.out.println(pm.toText());\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(LayoutExample.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    \/\/\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface Struct {\n+    }\n+\n+    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n+                                                CoreOp.FuncOp f) {\n+        List<TypeElement> pTypes = new ArrayList<>();\n+        for (Block.Parameter p : f.parameters()) {\n+            pTypes.add(transformStructClassToPtr(l, p.type()));\n+        }\n+        FunctionType functionType = FunctionType.functionType(\n+                transformStructClassToPtr(l, f.invokableType().returnType()),\n+                pTypes);\n+        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n+            funcBlock.transformBody(f.body(), funcBlock.parameters(), (b, op) -> {\n+                if (op instanceof CoreOp.InvokeOp iop && iop.hasReceiver()) {\n+                    Value receiver = iop.operands().getFirst();\n+                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n+                        Value ptr = b.context().getValue(receiver);\n+                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n+                        Op.Result memberPtr = b.op(ptrToMemberOp);\n+\n+                        if (iop.operands().size() == 1) {\n+                            \/\/ Pointer access and (possibly) value load\n+                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n+                                Op.Result v = b.op(new PtrLoadValue(memberPtr));\n+                                b.context().mapValue(iop.result(), v);\n+                            } else {\n+                                b.context().mapValue(iop.result(), memberPtr);\n+                            }\n+                        } else {\n+                            \/\/ @@@\n+                            \/\/ Value store\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    } else {\n+                        b.op(op);\n+                    }\n+                } else {\n+                    b.op(op);\n+                }\n+                return b;\n+            });\n+        });\n+    };\n+\n+\n+    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n+        if (structClass(l, type) instanceof Class<?> sc) {\n+            return new PtrType(structClassLayout(l, sc));\n+        } else {\n+            return type;\n+        }\n+    }\n+\n+    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n+                                          Class<?> c) {\n+        if (!c.isAnnotationPresent(Struct.class)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        Method layoutMethod;\n+        try {\n+            layoutMethod = c.getMethod(\"layout\");\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+        MethodHandle layoutHandle;\n+        try {\n+            layoutHandle = l.unreflect(layoutMethod);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        try {\n+            return (MemoryLayout) layoutHandle.invoke();\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n+        try {\n+            return _structClass(l, t);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n+            return null;\n+        }\n+\n+        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n+    }\n+\n+\n+    public static final class PtrType implements TypeElement {\n+        static final String NAME = \"ptr\";\n+        final MemoryLayout layout;\n+        final JavaType rType;\n+\n+        public PtrType(MemoryLayout layout) {\n+            this.layout = layout;\n+            this.rType = switch (layout) {\n+                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n+                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n+                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+            };\n+        }\n+\n+        public JavaType rType() {\n+            return rType;\n+        }\n+\n+        public MemoryLayout layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PtrType ptrType = (PtrType) o;\n+            return Objects.equals(layout, ptrType.layout);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(layout);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrToMember extends ExternalizableOp {\n+        public static final String NAME = \"ptr.to.member\";\n+        public static final String ATTRIBUTE_OFFSET = \"offset\";\n+        public static final String ATTRIBUTE_NAME = \"name\";\n+\n+        final String simpleMemberName;\n+        final long memberOffset;\n+        final PtrType resultType;\n+\n+        PtrToMember(PtrToMember that, CopyContext cc) {\n+            super(that, cc);\n+            this.simpleMemberName = that.simpleMemberName;\n+            this.memberOffset = that.memberOffset;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public PtrToMember transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrToMember(this, cc);\n+        }\n+\n+        public PtrToMember(Value ptr, String simpleMemberName) {\n+            super(NAME, List.of(ptr));\n+            this.simpleMemberName = simpleMemberName;\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            \/\/ @@@ Support group layout\n+            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n+            }\n+\n+            \/\/ Find the actual member name from the simple member name\n+            String memberName = findMemberName(structLayout, simpleMemberName);\n+            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n+            this.memberOffset = structLayout.byteOffset(p);\n+            MemoryLayout memberLayout = structLayout.select(p);\n+            \/\/ Remove any simple member name from the layout\n+            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n+                    ? memberLayout.withName(className(memberName))\n+                    : memberLayout.withoutName();\n+            this.resultType = new PtrType(ptrLayout);\n+        }\n+\n+        \/\/ @@@ Change to return member index\n+        static String findMemberName(StructLayout sl, String simpleMemberName) {\n+            for (MemoryLayout layout : sl.memberLayouts()) {\n+                String memberName = layout.name().orElseThrow();\n+                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n+                    return memberName;\n+                }\n+            }\n+            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n+        }\n+\n+        static String simpleMemberName(String memberName) {\n+            int i = memberName.indexOf(\"::\");\n+            return i != -1\n+                    ? memberName.substring(i + 2)\n+                    : memberName;\n+        }\n+\n+        static String className(String memberName) {\n+            int i = memberName.indexOf(\"::\");\n+            return i != -1\n+                    ? memberName.substring(0, i)\n+                    : null;\n+        }\n+\n+        @Override\n+        public PtrType resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", simpleMemberName);\n+            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n+            return attrs;\n+        }\n+\n+        public String simpleMemberName() {\n+            return simpleMemberName;\n+        }\n+\n+        public long memberOffset() {\n+            return memberOffset;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrAddOffset extends Op {\n+        public static final String NAME = \"ptr.add.offset\";\n+\n+        PtrAddOffset(PtrAddOffset that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrAddOffset transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrAddOffset(this, cc);\n+        }\n+\n+        public PtrAddOffset(Value ptr, Value offset) {\n+            super(NAME, List.of(ptr, offset));\n+\n+            if (!(ptr.type() instanceof PtrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n+                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return ptrValue().type();\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+\n+        public Value offsetValue() {\n+            return operands().get(1);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrLoadValue extends Op {\n+        public static final String NAME = \"ptr.load.value\";\n+\n+        final JavaType resultType;\n+\n+        PtrLoadValue(PtrLoadValue that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrLoadValue(this, cc);\n+        }\n+\n+        public PtrLoadValue(Value ptr) {\n+            super(NAME, List.of(ptr));\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(ptrType.layout() instanceof ValueLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n+            }\n+            this.resultType = ptrType.rType();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrStoreValue extends Op {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        PtrStoreValue(PtrStoreValue that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrStoreValue(this, cc);\n+        }\n+\n+        public PtrStoreValue(Value ptr, Value v) {\n+            super(NAME, List.of(ptr));\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(ptrType.layout() instanceof ValueLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n+            }\n+            if (!(ptrType.rType().equals(v.type()))) {\n+                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n+                        + ptrType.rType() + \" \" + v.type());\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+    import java.util.List;\n@@ -45,3 +46,2 @@\n-        public static void addMul(KernelContext kernelContext, S32Array s32Array, int add, int mul) {\n-            int x = kernelContext.x();\n-            s32Array.array(x, (s32Array.array(x) + add) * mul);\n+        public static void mulAdd(KernelContext kernelContext, S32Array s32Array, int mul, int add) {\n+            s32Array.array(kernelContext.x(), s32Array.array(kernelContext.x()) * mul + add);\n@@ -52,1 +52,1 @@\n-            Method method = Ptr.class.getDeclaredMethod(\"addMul\", KernelContext.class, S32Array.class, int.class, int.class);\n+            Method method = Ptr.class.getDeclaredMethod(\"mulAdd\", KernelContext.class, S32Array.class, int.class, int.class);\n@@ -57,1 +57,2 @@\n-            FuncOpWrapper transformedFuncOpWrapper = funcOpWrapper.findMapAndReplace(\n+            \/*\n+            FuncOpWrapper transformedFuncOpWrapper1 = funcOpWrapper.findMapAndReplace(\n@@ -60,5 +61,5 @@\n-                    (wb) -> {\n-                if (wb.current().isIfaceBufferMethod()) {\n-                    if (wb.current().isIfaceAccessor()) {\n-                        if (wb.current().isKernelContextAccessor()) {\n-                            wb.replace(new HatOps.HatKernelContextOp(wb.resultType(), wb.operandValues()));\n+                    (wr) -> {\n+                if (wr.current().isIfaceBufferMethod()) {\n+                    if (wr.current().isIfaceAccessor()) {\n+                        if (wr.current().isKernelContextAccessor()) {\n+                           wr.replace(new HatOps.HatKernelContextOp(wr.current().name(),wr));\n@@ -66,1 +67,1 @@\n-                            wb.replace(new HatOps.HatPtrLoadOp(wb.resultType(), wb.operandValues()));\n+                            wr.replace(new HatOps.HatPtrLoadOp(wr));\n@@ -69,1 +70,1 @@\n-                        wb.replace(new HatOps.HatPtrStoreOp(wb.resultType(), wb.operandValues()));\n+                        wr.replace(new HatOps.HatPtrStoreOp(wr));\n@@ -72,1 +73,15 @@\n-            });\n+            }); *\/\n+            FuncOpWrapper transformedFuncOpWrapper = funcOpWrapper.replace((wr) -> {\n+                        if (wr.current()  instanceof InvokeOpWrapper invokeOpWrapper&& invokeOpWrapper.isIfaceBufferMethod()) {\n+                            if (invokeOpWrapper.isIfaceAccessor()) {\n+                                if (invokeOpWrapper.isKernelContextAccessor()) {\n+                                    wr.replace(new HatOps.HatKernelContextOp(invokeOpWrapper.name(),wr));\n+                                } else {\n+                                    wr.replace(new HatOps.HatPtrLoadOp(wr));\n+                                }\n+                            } else {\n+                                wr.replace(new HatOps.HatPtrStoreOp(wr));\n+                            }\n+                        }\n+                    });\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Ptr.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+import hat.optools.FuncOpWrapper;\n+\n@@ -31,2 +33,4 @@\n-        public HatKernelContextOp(TypeElement typeElement, List<Value> operands) {\n-            super(NAME, typeElement, operands);\n+        public final String fieldName;\n+        public HatKernelContextOp(String fieldName, TypeElement typeElement, List<Value> operands) {\n+            super(NAME+\".\"+fieldName, typeElement, operands);\n+            this.fieldName=fieldName;\n@@ -34,0 +38,3 @@\n+        public HatKernelContextOp(String fieldName, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME+\".\"+fieldName, replacer.currentResultType(), replacer.currentOperandValues());\n+            this.fieldName=fieldName;\n@@ -35,2 +42,7 @@\n-        public HatKernelContextOp(HatOp that, CopyContext cc) {\n-            super(that, cc);\n+        }\n+        public HatKernelContextOp(String fieldName,TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME+\".\"+fieldName, typeElement, replacer.currentOperandValues());\n+            this.fieldName=fieldName;\n+        }\n+        public HatKernelContextOp(HatKernelContextOp that, CopyContext cc) {\n+            super(that, cc); this.fieldName = that.fieldName;\n@@ -51,0 +63,6 @@\n+        public HatPtrOp(String name, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(name, replacer.currentResultType(), replacer.currentOperandValues());\n+        }\n+        public HatPtrOp(String name, TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(name, typeElement, replacer.currentOperandValues());\n+        }\n@@ -63,1 +81,6 @@\n-\n+        public HatPtrStoreOp(FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, replacer);\n+        }\n+        public HatPtrStoreOp(TypeElement typeElement,FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement,replacer);\n+        }\n@@ -78,1 +101,6 @@\n-\n+        public HatPtrLoadOp(TypeElement typeElement, FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME, typeElement, replacer);\n+        }\n+        public HatPtrLoadOp( FuncOpWrapper.WrappedOpReplacer replacer) {\n+            super(NAME,  replacer);\n+        }\n","filename":"hat\/hat\/src\/main\/java\/hat\/HatOps.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-\n@@ -105,1 +104,1 @@\n-            public boolean isKernelContext() {\n+            public static boolean isKernelContext(JavaType javaType) {\n@@ -112,1 +111,3 @@\n-                    return KernelContext.class.isAssignableFrom(hopefullyAKernelContext);\n+                    \/\/ Note we alow either the buffer form here.  Common iface? or maybe we should just not use same name\n+                    return hat.KernelContext.class.isAssignableFrom(hopefullyAKernelContext)\n+                        || hat.buffer.KernelContext.class.isAssignableFrom(hopefullyAKernelContext);\n@@ -117,0 +118,2 @@\n+            public boolean isKernelContext() {\n+                return isKernelContext(javaType);\n@@ -118,0 +121,1 @@\n+            }\n@@ -321,1 +325,1 @@\n-        public List<Value> operandValues(){\n+        public List<Value> currentOperandValues(){\n@@ -334,1 +338,1 @@\n-        public TypeElement resultType() {\n+        public TypeElement currentResultType() {\n@@ -339,1 +343,1 @@\n-    public <T extends Op, WT extends OpWrapper<T>>FuncOpWrapper transform(Consumer<WrappedOpReplacer<T,WT>> wrappedOpTransformer) {\n+    public FuncOpWrapper replace(Consumer<WrappedOpReplacer<?,OpWrapper<?>>> wrappedOpTransformer) {\n@@ -341,1 +345,1 @@\n-            var replacer = new WrappedOpReplacer<T,WT>(b, (WT)OpWrapper.wrap(op));\n+            var replacer = new WrappedOpReplacer(b, OpWrapper.wrap(op));\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/FuncOpWrapper.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+    public boolean isKernelContextMethod() {\n+        return FuncOpWrapper.ParamTable.Info.isKernelContext(javaRefType());\n@@ -32,0 +34,1 @@\n+    }\n@@ -69,1 +72,0 @@\n-\n@@ -78,6 +80,1 @@\n-\n-        if (isIfaceBufferMethod() && !returnsVoid()) {\n-            return !isReturnTypeAssignableFrom(KernelContext.class);\n-        } else {\n-            return false;\n-        }\n+        return isKernelContextMethod();\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -10,1 +10,0 @@\n-        <!--<babylon.repo.name>babylon-grfrost-fork<\/babylon.repo.name>  replace with your fork name -->\n","filename":"hat\/pom.xml","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}