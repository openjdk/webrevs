{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=babylon\n@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    jdk.code.tools \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+DISABLED_WARNINGS_java += preview\n@@ -32,3 +33,4 @@\n-DOCLINT += -Xdoclint:all\/protected \\\n-    '-Xdoclint\/package:java.*,javax.*'\n-JAVAC_FLAGS += -XDstringConcat=inline\n+# DOCLINT += -Xdoclint:all\/protected \\\n+#     '-Xdoclint\/package:java.*,javax.*'\n+JAVAC_FLAGS += -XDstringConcat=inline \\\n+    --enable-preview\n","filename":"make\/modules\/java.base\/Java.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -38,2 +43,1 @@\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n+import java.util.*;\n@@ -65,0 +69,1 @@\n+    private static final String DESCR_METHOD_QUOTED = \"()Ljava\/lang\/reflect\/code\/Quoted;\";\n@@ -69,0 +74,1 @@\n+    private static final String NAME_METHOD_QUOTED = \"quoted\";\n@@ -90,0 +96,11 @@\n+    \/\/ condy to load reflective field from class data\n+    private static final ConstantDynamic reflectiveFieldCondy;\n+\n+    private static final ConstantDynamic makeQuotedMethodCondy;\n+\n+    private static final MethodHandle HANDLE_MAKE_QUOTED;\n+\n+    private static final String quotedInstanceFieldName = \"quoted\";\n+    private static final String quotedInstanceFieldDesc = Quoted.class.descriptorString();\n+\n+\n@@ -101,4 +118,14 @@\n-        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n-        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n-                                         classDataMType.descriptorString(), false);\n-        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm);\n+        MethodType classDataAtMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class, int.class);\n+        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classDataAt\",\n+                                         classDataAtMType.descriptorString(), false);\n+        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 0);\n+        reflectiveFieldCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 1);\n+        makeQuotedMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 2);\n+\n+        try {\n+            HANDLE_MAKE_QUOTED = MethodHandles.lookup().findStatic(\n+                    InnerClassLambdaMetafactory.class, \"makeQuoted\",\n+                    MethodType.methodType(Quoted.class, String.class, Object[].class));\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n@@ -152,0 +179,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -166,1 +196,2 @@\n-                                       MethodType[] altMethods)\n+                                       MethodType[] altMethods,\n+                                       MethodHandle reflectiveField)\n@@ -170,1 +201,1 @@\n-              isSerializable, altInterfaces, altMethods);\n+              isSerializable, altInterfaces, altMethods, reflectiveField);\n@@ -332,0 +363,8 @@\n+        \/\/ if quotable, generate the field that will hold the value of quoted\n+        if (quotableOpField != null) {\n+            cw.visitField(ACC_PRIVATE + ACC_FINAL,\n+                          quotedInstanceFieldName,\n+                          quotedInstanceFieldDesc,\n+                          null, null);\n+        }\n+\n@@ -357,0 +396,4 @@\n+        if (quotableOpField != null) {\n+            generateQuotableMethod();\n+        }\n+\n@@ -364,1 +407,8 @@\n-            var classdata = useImplMethodHandle? implementation : null;\n+            List<?> classdata;\n+            if (useImplMethodHandle || quotableOpField != null) {\n+                classdata = quotableOpField == null ?\n+                        List.of(implementation) :\n+                        List.of(implementation, quotableOpField, HANDLE_MAKE_QUOTED);\n+            } else {\n+                classdata = null;\n+            }\n@@ -418,0 +468,5 @@\n+\n+        if (quotableOpField != null) {\n+            generateQuotedFieldInitializer(ctor);\n+        }\n+\n@@ -424,0 +479,41 @@\n+    private void generateQuotedFieldInitializer(MethodVisitor ctor) {\n+        ctor.visitCode();\n+\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        ctor.visitVarInsn(ALOAD, 0);\n+\n+        ctor.visitLdcInsn(makeQuotedMethodCondy);\n+\n+        \/\/ load op string from field\n+\n+        ctor.visitLdcInsn(reflectiveFieldCondy);\n+        MethodType mtype = quotableOpFieldInfo.getMethodType();\n+        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+            mtype = mtype.insertParameterTypes(0, implClass);\n+        }\n+        ctor.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n+                \"invokeExact\", mtype.descriptorString(), false);\n+\n+        \/\/ load captured args in array\n+\n+        ctor.visitLdcInsn(quotableOpType.parameterCount());\n+        ctor.visitTypeInsn(ANEWARRAY, JAVA_LANG_OBJECT);\n+        int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n+        \/\/ initialize quoted captures\n+        TypeConvertingMethodAdapter tcmv = new TypeConvertingMethodAdapter(ctor);\n+        for (int i = 0; i < reflectiveCaptureCount(); i++) {\n+            ctor.visitInsn(DUP);\n+            ctor.visitIntInsn(BIPUSH, i); \/\/ is it possible that i can be greater than Byte.MAX_VALUE ?\n+            ctor.visitVarInsn(ALOAD, 0);\n+            ctor.visitFieldInsn(GETFIELD, lambdaClassName, argNames[capturedArity + i], argDescs[capturedArity + i]);\n+            tcmv.boxIfTypePrimitive(Type.getType(argDescs[capturedArity + i]));\n+            ctor.visitInsn(AASTORE);\n+        }\n+\n+        \/\/ now create a Quoted from String and captured args Object[]\n+\n+        ctor.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n+                \"invokeExact\", HANDLE_MAKE_QUOTED.type().toMethodDescriptorString(), false);\n+        ctor.visitFieldInsn(PUTFIELD, lambdaClassName, quotedInstanceFieldName, quotedInstanceFieldDesc);\n+    }\n+\n@@ -464,0 +560,17 @@\n+    \/**\n+     * Generate a writeReplace method that supports serialization\n+     *\/\n+    private void generateQuotableMethod() {\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL,\n+                                          NAME_METHOD_QUOTED, DESCR_METHOD_QUOTED,\n+                                          null, null);\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, lambdaClassName, quotedInstanceFieldName, quotedInstanceFieldDesc);\n+        mv.visitInsn(ARETURN);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n@@ -515,1 +628,1 @@\n-            for (int i = 0; i < argNames.length; i++) {\n+            for (int i = 0; i < argNames.length - reflectiveCaptureCount(); i++) {\n@@ -550,1 +663,1 @@\n-            int captureArity = factoryType.parameterCount();\n+            int captureArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -609,0 +722,4 @@\n+    private static Quoted makeQuoted(String opText, Object[] args) {\n+        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n+        return (Quoted)Interpreter.invoke(Lookup.IMPL_LOOKUP, op, args);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":128,"deletions":11,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.analysis;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Provides liveness information for values declared in the bodies of an operation.\n+ *\/\n+public class Liveness {\n+\n+    \/**\n+     * Liveness information associated with a block.\n+     * Each block has two sets of values, live-in values and live-out values.\n+     *\/\n+    public static final class BlockInfo {\n+        final Block block;\n+        final Deque<Value> inValues;\n+        final Deque<Value> outValues;\n+\n+        BlockInfo(Block block) {\n+            this.block = block;\n+            this.inValues = new ArrayDeque<>();\n+            this.outValues = new ArrayDeque<>();\n+        }\n+\n+        \/**\n+         * {@return the block associated with the liveness information}\n+         *\/\n+        public Block getBlock() {\n+            return block;\n+        }\n+\n+        \/**\n+         * Returns true if a value is live-in for the associated block.\n+         * <p>\n+         * A value is live-in for a block if it is not declared in the block\n+         * and is used in the block or (transitively) by some successor.\n+         *\n+         * @param value the value\n+         * @return true if the value is live-in\n+         *\/\n+        public boolean isLiveIn(Value value) {\n+            return inValues.contains(value);\n+        }\n+\n+        \/**\n+         * {@return the set of live-in values}\n+         *\/\n+        public Set<Value> liveIn() {\n+            return new HashSet<>(inValues);\n+        }\n+\n+        \/**\n+         * Returns true if a value is live-out for the associated block.\n+         * <p>\n+         * A value is live-out for a block if it is used (transitively) by some successor.\n+         *\n+         * @param value the value\n+         * @return true if the value is live-out\n+         *\/\n+        public boolean isLiveOut(Value value) {\n+            return outValues.contains(value);\n+        }\n+\n+        \/**\n+         * {@return the set of live-out values}\n+         *\/\n+        public Set<Value> liveOut() {\n+            return new HashSet<>(outValues);\n+        }\n+\n+        \/**\n+         * Returns the first operation associated with a value and the associated block.\n+         * <p>\n+         * If the value is live-in or a block argument then the blocks first operation\n+         * is returned. Otherwise, the value is an operation result and its operation\n+         * is returned.\n+         *\n+         * @param value the value\n+         * @return first operation associated with a value and the associated block.\n+         *\/\n+        public Op getStartOperation(Value value) {\n+            if (isLiveIn(value) || value instanceof Block.Parameter) {\n+                \/\/ @@@ Check value is from this block\n+                return block.firstOp();\n+            } else {\n+                \/\/ @@@ Check value is from block\n+                Op.Result or = (Op.Result) value;\n+                return or.op();\n+            }\n+        }\n+\n+        \/**\n+         * Returns the end operation associated with a value and the associated block.\n+         * <p>\n+         * If the value is live-out then the blocks last (and terminating) operation\n+         * is returned. Otherwise, the value is dying in this block and the last\n+         * operation to use this value is returned.\n+         *\n+         * @param value the value\n+         * @return first operation associated with a value and the associated block.\n+         *\/\n+        public Op getEndOperation(Value value, Op startOp) {\n+            \/\/ Value is used by some other operation\n+            if (isLiveOut(value)) {\n+                return block.terminatingOp();\n+            }\n+\n+            \/\/ Value may be last used in this block, if so find it\n+            \/\/ @@@ Check startOp is of this block\n+            Op endOp = startOp;\n+            for (Op.Result useOpr : value.uses()) {\n+                Op useOp = useOpr.op();\n+                \/\/ Find the operation in the current block\n+                useOp = block.findAncestorOpInBlock(useOp);\n+                \/\/ Update if after\n+                if (useOp != null && isBeforeInBlock(endOp, useOp)) {\n+                    endOp = useOp;\n+                }\n+            }\n+            return endOp;\n+        }\n+    }\n+\n+    final Op op;\n+    final Map<Block, BlockInfo> livenessMapping;\n+\n+    \/**\n+     * Constructs liveness information for values declared in the bodies\n+     * of an operation.\n+     *\n+     * @param op the operation.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    public Liveness(Op op) {\n+        this.op = op;\n+        this.livenessMapping = new HashMap<>();\n+        for (Body cfg : op.bodies()) {\n+            Compute_LiveSets_SSA_ByVar(cfg);\n+        }\n+    }\n+\n+    \/*\n+    The algorithm to compute liveness information is derived from\n+    Domaine, & Brandner, Florian & Boissinot, Benoit & Darte, Alain & Dinechin, Benoit & Rastello, Fabrice.\n+    (2011). Computing Liveness Sets for SSA-Form Programs.\n+    https:\/\/inria.hal.science\/inria-00558509v2\/document\n+    Specifically Algorithm 6 & 7, adapted to work with block arguments and\n+    block parameters instead of phi operations.\n+    This is a simple algorithm that is easy to understand. We may need to review\n+    its usage within exception regions.\n+    We also may revisit this later with a more performant implementation\n+    perhaps based on the well known algorithm that uses fixpoint iteration.\n+     *\/\n+\n+    void Compute_LiveSets_SSA_ByVar(Body CFG) {\n+        for (Block b : CFG.blocks()) {\n+            livenessMapping.put(b, new BlockInfo(b));\n+        }\n+        for (Block b : CFG.blocks()) {\n+            for (Block.Parameter p : b.parameters()) {\n+                Compute_LiveSets_SSA_ByVar(CFG, p);\n+            }\n+\n+            for (Op op : b.ops()) {\n+                Compute_LiveSets_SSA_ByVar(CFG, op.result());\n+            }\n+        }\n+    }\n+\n+    void Compute_LiveSets_SSA_ByVar(Body CFG, Value v) {\n+        for (Op.Result use : v.uses()) {\n+            Block B = CFG.findAncestorBlockInBody(use.declaringBlock());\n+            Up_and_Mark_Stack(B, v);\n+        }\n+    }\n+\n+    void Up_and_Mark_Stack(Block B, Value v) {\n+        if (v.declaringBlock() == B) {\n+            return;\n+        }\n+        var lbi = livenessMapping.get(B);\n+        if (lbi.inValues.peek() == v) {\n+            return;\n+        }\n+        lbi.inValues.push(v);\n+        for (Block P : B.predecessors()) {\n+            lbi = livenessMapping.get(P);\n+            if (lbi.outValues.peek() != v) {\n+                lbi.outValues.push(v);\n+            }\n+            Up_and_Mark_Stack(P, v);\n+        }\n+    }\n+\n+    \/**\n+     * {@return the liveness information as a string}\n+     *\/\n+    public String toString() {\n+        StringWriter w = new StringWriter();\n+        writeTo(w);\n+        return w.toString();\n+    }\n+\n+    \/**\n+     * Writes the liveness information to the given writer.\n+     *\n+     * @param w the writer to write to.\n+     *\/\n+    public void writeTo(Writer w) {\n+        OpWriter ow = new OpWriter(w);\n+        ow.writeOp(op);\n+        try {\n+            w.write(\"\\n\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        Function<CodeItem, String> namer = ow.namer();\n+        op.traverse(null, CodeElement.blockVisitor((_, b) -> {\n+            BlockInfo liveness = getLiveness(b);\n+            try {\n+                w.write(\"^\" + namer.apply(b));\n+                w.write(\"\\n\");\n+                w.write(\"  Live-in values: \");\n+                w.write(liveness.inValues.stream()\n+                        .map(v -> \"%\" + namer.apply(v))\n+                        .collect(Collectors.joining(\",\")));\n+                w.write(\"\\n\");\n+                w.write(\"  Live-out values: \");\n+                w.write(liveness.outValues.stream()\n+                        .map(v -> \"%\" + namer.apply(v))\n+                        .collect(Collectors.joining(\",\")));\n+                w.write(\"\\n\");\n+                return null;\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }));\n+    }\n+\n+    \/**\n+     * Returns true if a value is last used by an operation.\n+     * <p>\n+     * The liveness information for the operation's parent block\n+     * is obtained. If the value is live-out then the value escapes\n+     * the block and is therefore not the last use, and this method\n+     * returns false.\n+     * If the operation is the last to use the value, this method\n+     * returns true. If the operation does not use the value and\n+     * the {@link BlockInfo#getEndOperation end operation}\n+     * occurs before the operation, this method returns true.\n+     * Otherwise, this method returns false.\n+     *\n+     * @param value the value\n+     * @param op    the operation\n+     * @return true if a value is last used by an operation\n+     *\/\n+    public boolean isLastUse(Value value, Op op) {\n+        Block block = op.parentBlock();\n+        BlockInfo liveness = getLiveness(block);\n+\n+        \/\/ Value is used by some successor\n+        if (liveness.isLiveOut(value))\n+            return false;\n+\n+        Op endOp = liveness.getEndOperation(value, op);\n+        \/\/ Last use or operation is after last use\n+        return endOp == op || isBeforeInBlock(endOp, op);\n+    }\n+\n+    \/**\n+     * {@return the liveness information associated with a block}\n+     *\n+     * @param block the block\n+     * @throws IllegalArgumentException if the block has no liveness information\n+     *\/\n+    public BlockInfo getLiveness(Block block) {\n+        BlockInfo lbi = livenessMapping.get(block);\n+        if (lbi == null) {\n+            throw new IllegalArgumentException(\"Block has no liveness information\");\n+        }\n+        return lbi;\n+    }\n+\n+    private static boolean isBeforeInBlock(Op thisOp, Op thatOp) {\n+        if (thisOp.result() == null || thatOp.result() == null) {\n+            throw new IllegalArgumentException(\"This or the given operation is not assigned to a block\");\n+        }\n+\n+        if (thisOp.parentBlock() != thatOp.parentBlock()) {\n+            throw new IllegalArgumentException(\"This and that operation are not assigned to the same blocks\");\n+        }\n+\n+        List<Op> ops = thisOp.parentBlock().ops();\n+        return ops.indexOf(thisOp) < ops.indexOf(thatOp);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,3151 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.JavaType.*;\n+\n+\/**\n+ * The set of extended operations. A code model, produced by the Java compiler from Java program source, may consist of\n+ * extended operations and core operations. Such a model represents the same Java program and preserves the program\n+ * meaning as defined by the Java Language Specification\n+ * <p>\n+ * Extended operations model specific Java language constructs, often those with structured control flow and nested\n+ * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n+ * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n+ * that are not explicitly lowerable.\n+ * <p>\n+ * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n+ * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n+ * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n+ *\/\n+public class ExtendedOps {\n+    \/\/ Split string to ensure the name does not get rewritten\n+    \/\/ when the script copies this source to the jdk.compiler module\n+    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n+\n+    static final String ExtendedOps_CLASS_NAME = PACKAGE_NAME + \".\" + ExtendedOps.class.getSimpleName();\n+\n+    ExtendedOps() {\n+    }\n+\n+    \/**\n+     * The label operation, that can model Java language statements with label identifiers.\n+     *\/\n+    public static sealed abstract class JavaLabelOp extends OpWithDefinition implements Op.Lowerable, Op.BodyTerminating {\n+        JavaLabelOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        JavaLabelOp(JavaLabelOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        JavaLabelOp(String name, Value label) {\n+            super(name, checkLabel(label));\n+        }\n+\n+        static List<Value> checkLabel(Value label) {\n+            return label == null ? List.of() : List.of(label);\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            \/*\n+                A break statement with no label attempts to transfer control to the\n+                innermost enclosing switch, while, do, or for statement; this enclosing statement,\n+                which is called the break target, then immediately completes normally.\n+\n+                A break statement with label Identifier attempts to transfer control to the\n+                enclosing labeled statement (14.7) that has the same Identifier as its label;\n+                this enclosing statement, which is called the break target, then immediately completes normally.\n+                In this case, the break target need not be a switch, while, do, or for statement.\n+             *\/\n+\n+            \/\/ No label\n+            \/\/ Get innermost enclosing loop operation\n+            \/\/ @@@ expand to support innermost enclosing switch operation\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing loop\");\n+                }\n+            } while (!(op instanceof Op.Loop));\n+            \/\/ } while (!(op instanceof Op.Loop lop));\n+            \/\/ error: variable lop might not have been initialized\n+            Op.Loop lop = (Op.Loop) op;\n+            return lop.loopBody() == b ? op : null;\n+        }\n+\n+        boolean isUnlabeled() {\n+            return operands().isEmpty();\n+        }\n+\n+        Op target() {\n+            \/\/ If unlabeled then find the nearest enclosing op\n+            \/\/ Otherwise obtain the label target\n+            if (isUnlabeled()) {\n+                return innerMostEnclosingTarget();\n+            }\n+\n+            Value value = operands().get(0);\n+            if (value instanceof Result r && r.op().ancestorBody().parentOp() instanceof JavaLabeledOp lop) {\n+                return lop.target();\n+            } else {\n+                throw new IllegalStateException(\"Bad label value: \" + value + \" \" + ((Result) value).op());\n+            }\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language break statements with label identifiers.\n+     *\/\n+    @OpDeclaration(JavaBreakOp.NAME)\n+    public static final class JavaBreakOp extends JavaLabelOp {\n+        public static final String NAME = \"java.break\";\n+\n+        public JavaBreakOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaBreakOp(JavaBreakOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaBreakOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBreakOp(this, cc);\n+        }\n+\n+        JavaBreakOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language continue statements with label identifiers.\n+     *\/\n+    @OpDeclaration(JavaContinueOp.NAME)\n+    public static final class JavaContinueOp extends JavaLabelOp {\n+        public static final String NAME = \"java.continue\";\n+\n+        public JavaContinueOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaContinueOp(JavaContinueOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaContinueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaContinueOp(this, cc);\n+        }\n+\n+        JavaContinueOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+    }\n+\n+    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+    }\n+\n+    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n+\n+    static BranchTarget getBranchTarget(CopyContext cc, Op op) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Op, BranchTarget> m = (Map<Op, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(op);\n+        }\n+\n+        return null;\n+    }\n+\n+    static void setBranchTarget(CopyContext cc, Op label, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Op, BranchTarget> x = (Map<Op, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(label, t);\n+    }\n+\n+    \/**\n+     * The yield operation, that can model Java language yield statements.\n+     *\/\n+    @OpDeclaration(JavaYieldOp.NAME)\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"java.yield\";\n+\n+        public JavaYieldOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaYieldOp(JavaYieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaYieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaYieldOp(this, cc);\n+        }\n+\n+        JavaYieldOp() {\n+            super(NAME,\n+                    List.of());\n+        }\n+\n+        JavaYieldOp(Value operand) {\n+            super(NAME, List.of(operand));\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The block operation, that can model Java language blocks.\n+     *\/\n+    @OpDeclaration(JavaBlockOp.NAME)\n+    \/\/ @@@ Support synchronized attribute\n+    public static final class JavaBlockOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.block\";\n+\n+        final Body body;\n+\n+        public JavaBlockOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaBlockOp(JavaBlockOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaBlockOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBlockOp(this, cc, ot);\n+        }\n+\n+        \/\/ @@@ Support non-void result type\n+        JavaBlockOp(Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The labeled operation, that can model Java language labeled statements.\n+     *\/\n+    @OpDeclaration(JavaLabeledOp.NAME)\n+    public static final class JavaLabeledOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.labeled\";\n+\n+        final Body body;\n+\n+        public JavaLabeledOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaLabeledOp(JavaLabeledOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaLabeledOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaLabeledOp(this, cc, ot);\n+        }\n+\n+        JavaLabeledOp(Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Op label() {\n+            return body.entryBlock().firstOp();\n+        }\n+\n+        public Op target() {\n+            return body.entryBlock().nextOp(label());\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            AtomicBoolean first = new AtomicBoolean();\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                \/\/ Drop first operation that corresponds to the label\n+                if (!first.get()) {\n+                    first.set(true);\n+                    return block;\n+                }\n+\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The if operation, that can model Java language if, if-then, and if-then-else statements.\n+     *\/\n+    @OpDeclaration(JavaIfOp.NAME)\n+    public static final class JavaIfOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n+\n+        static final FunctionType ACTION_TYPE = FunctionType.VOID;\n+\n+        public static class IfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            IfBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+            }\n+\n+            public ThenBuilder _if(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ThenBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ThenBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ElseIfBuilder then(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+\n+            public ElseIfBuilder then() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ElseIfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ElseIfBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ThenBuilder elseif(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+\n+            public JavaIfOp _else(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+\n+            public JavaIfOp _else() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.if\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaIfOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaIfOp(JavaIfOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaIfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaIfOp(this, cc, ot);\n+        }\n+\n+        JavaIfOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            \/\/ Normalize by adding an empty else action\n+            \/\/ @@@ Is this needed?\n+            if (bodyCs.size() % 2 == 0) {\n+                bodyCs = new ArrayList<>(bodyCs);\n+                Body.Builder end = Body.Builder.of(bodyCs.get(0).ancestorBody(),\n+                        FunctionType.VOID);\n+                end.entryBlock().op(_yield());\n+                bodyCs.add(end);\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+\n+            if (bodies.size() < 2) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body action;\n+                if (i == bodies.size() - 1) {\n+                    action = bodies.get(i);\n+                } else {\n+                    action = bodies.get(i + 1);\n+                    Body fromPred = bodies.get(i);\n+                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.bodyType());\n+                    }\n+                }\n+                if (!action.bodyType().equals(FunctionType.VOID)) {\n+                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.bodyType());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Create predicate and action blocks\n+            List<Block.Builder> builders = new ArrayList<>();\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                if (i == bodies.size() - 1) {\n+                    builders.add(b.block());\n+                } else {\n+                    builders.add(i == 0 ? b : b.block());\n+                    builders.add(b.block());\n+                }\n+            }\n+\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body actionBody;\n+                Block.Builder action;\n+                if (i == bodies.size() - 1) {\n+                    actionBody = bodies.get(i);\n+                    action = builders.get(i);\n+                } else {\n+                    Body predBody = bodies.get(i);\n+                    actionBody = bodies.get(i + 1);\n+\n+                    Block.Builder pred = builders.get(i);\n+                    action = builders.get(i + 1);\n+                    Block.Builder next = builders.get(i + 2);\n+\n+                    pred.transformBody(predBody, List.of(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yo) {\n+                            block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                                    action.successor(), next.successor()));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+\n+                action.transformBody(actionBody, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The switch expression operation, that can model Java language switch expressions.\n+     *\/\n+    @OpDeclaration(JavaSwitchExpressionOp.NAME)\n+    public static final class JavaSwitchExpressionOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.switch.expression\";\n+\n+        final TypeElement resultType;\n+        final List<Body> bodies;\n+\n+        public JavaSwitchExpressionOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case expression or statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements\/expression body has no parameters and returns the result whose type is the result of\n+            \/\/ the switch expression\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            \/\/ @@@ when resultType is null, we assume statements\/expressions bodies have the same yieldType\n+            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The switch fall-through operation, that can model fall-through to the next statement in the switch block after\n+     * the last statement of the current switch label.\n+     *\/\n+    @OpDeclaration(JavaSwitchFallthroughOp.NAME)\n+    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"java.switch.fallthrough\";\n+\n+        public JavaSwitchFallthroughOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaSwitchFallthroughOp(JavaSwitchFallthroughOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaSwitchFallthroughOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchFallthroughOp(this, cc);\n+        }\n+\n+        JavaSwitchFallthroughOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The for operation, that can model a Java language for statement.\n+     *\/\n+    @OpDeclaration(JavaForOp.NAME)\n+    public static final class JavaForOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static final class InitBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+\n+            InitBuilder(Body.Builder ancestorBody,\n+                        List<? extends TypeElement> initTypes) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes.stream().map(VarType::varType).toList();\n+            }\n+\n+            public JavaForOp.CondBuilder init(Consumer<Block.Builder> c) {\n+                Body.Builder init = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(TupleType.tupleType(initTypes)));\n+                c.accept(init.entryBlock());\n+\n+                return new CondBuilder(ancestorBody, initTypes, init);\n+            }\n+        }\n+\n+        public static final class CondBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+\n+            public CondBuilder(Body.Builder ancestorBody,\n+                               List<? extends TypeElement> initTypes,\n+                               Body.Builder init) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+            }\n+\n+            public JavaForOp.UpdateBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder cond = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(BOOLEAN, initTypes));\n+                c.accept(cond.entryBlock());\n+\n+                return new UpdateBuilder(ancestorBody, initTypes, init, cond);\n+            }\n+        }\n+\n+        public static final class UpdateBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+\n+            public UpdateBuilder(Body.Builder ancestorBody,\n+                                 List<? extends TypeElement> initTypes,\n+                                 Body.Builder init, Body.Builder cond) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+            }\n+\n+            public JavaForOp.BodyBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder update = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, initTypes));\n+                c.accept(update.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, initTypes, init, cond, update);\n+            }\n+\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+            final Body.Builder update;\n+\n+            public BodyBuilder(Body.Builder ancestorBody,\n+                               List<? extends TypeElement> initTypes,\n+                               Body.Builder init, Body.Builder cond, Body.Builder update) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+                this.update = update;\n+            }\n+\n+            public JavaForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, initTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaForOp(init, cond, update, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.for\";\n+\n+        final Body init;\n+        final Body cond;\n+        final Body update;\n+        final Body body;\n+\n+        public static JavaForOp create(OpDefinition def) {\n+            return new JavaForOp(def);\n+        }\n+\n+        public JavaForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.init = def.bodyDefinitions().get(0).build(this);\n+            this.cond = def.bodyDefinitions().get(1).build(this);\n+            this.update = def.bodyDefinitions().get(2).build(this);\n+            this.body = def.bodyDefinitions().get(3).build(this);\n+        }\n+\n+        JavaForOp(JavaForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.cond = that.cond.transform(cc, ot).build(this);\n+            this.update = that.update.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaForOp(this, cc, ot);\n+        }\n+\n+        JavaForOp(Body.Builder initC,\n+                  Body.Builder condC,\n+                  Body.Builder updateC,\n+                  Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.init = initC.build(this);\n+\n+            this.cond = condC.build(this);\n+\n+            this.update = updateC.build(this);\n+            if (!update.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Update should return void: \" + update.bodyType());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(init, cond, update, body);\n+        }\n+\n+        public Body init() {\n+            return init;\n+        }\n+\n+        public Body cond() {\n+            return cond;\n+        }\n+\n+        public Body update() {\n+            return update;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder update = b.block();\n+            Block.Builder exit = b.block();\n+\n+            List<Value> initValues = new ArrayList<>();\n+            \/\/ @@@ Init body has one yield operation yielding\n+            \/\/  void, a single variable, or a tuple of one or more variables\n+            b.transformBody(init, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.TupleOp) {\n+                    \/\/ Drop Tuple if a yielded\n+                    boolean isResult = op.result().uses().size() == 1 &&\n+                            op.result().uses().stream().allMatch(r -> r.op() instanceof YieldOp);\n+                    if (!isResult) {\n+                        block.op(op);\n+                    }\n+                } else if (op instanceof YieldOp yop) {\n+                    if (yop.yieldValue() == null) {\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    } else if (yop.yieldValue() instanceof Result or) {\n+                        if (or.op() instanceof CoreOps.TupleOp top) {\n+                            initValues.addAll(block.context().getValues(top.operands()));\n+                        } else {\n+                            initValues.addAll(block.context().getValues(yop.operands()));\n+                        }\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    }\n+\n+                    throw new IllegalStateException(\"Bad yield operation\");\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(cond, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+            body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            update.transformBody(this.update, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(header.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The enhanced for operation, that can model a Java language enhanced for statement.\n+     *\/\n+    @OpDeclaration(JavaEnhancedForOp.NAME)\n+    public static final class JavaEnhancedForOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static final class ExpressionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement iterableType;\n+            final TypeElement elementType;\n+\n+            ExpressionBuilder(Body.Builder ancestorBody,\n+                              TypeElement iterableType, TypeElement elementType) {\n+                this.ancestorBody = ancestorBody;\n+                this.iterableType = iterableType;\n+                this.elementType = elementType;\n+            }\n+\n+            public DefinitionBuilder expression(Consumer<Block.Builder> c) {\n+                Body.Builder expression = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(iterableType));\n+                c.accept(expression.entryBlock());\n+\n+                return new DefinitionBuilder(ancestorBody, elementType, expression);\n+            }\n+        }\n+\n+        public static final class DefinitionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement elementType;\n+            final Body.Builder expression;\n+\n+            DefinitionBuilder(Body.Builder ancestorBody,\n+                              TypeElement elementType, Body.Builder expression) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+            }\n+\n+            public BodyBuilder definition(Consumer<Block.Builder> c) {\n+                return definition(elementType, c);\n+            }\n+\n+            public BodyBuilder definition(TypeElement bodyElementType, Consumer<Block.Builder> c) {\n+                Body.Builder definition = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(bodyElementType, elementType));\n+                c.accept(definition.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, elementType, expression, definition);\n+            }\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement elementType;\n+            final Body.Builder expression;\n+            final Body.Builder definition;\n+\n+            BodyBuilder(Body.Builder ancestorBody,\n+                        TypeElement elementType, Body.Builder expression, Body.Builder definition) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+                this.definition = definition;\n+            }\n+\n+            public JavaEnhancedForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, elementType));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaEnhancedForOp(expression, definition, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.enhancedFor\";\n+\n+        final Body expression;\n+        final Body init;\n+        final Body body;\n+\n+        public static JavaEnhancedForOp create(OpDefinition def) {\n+            return new JavaEnhancedForOp(def);\n+        }\n+\n+        public JavaEnhancedForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expression = def.bodyDefinitions().get(0).build(this);\n+            this.init = def.bodyDefinitions().get(1).build(this);\n+            this.body = def.bodyDefinitions().get(2).build(this);\n+        }\n+\n+        JavaEnhancedForOp(JavaEnhancedForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expression = that.expression.transform(cc, ot).build(this);\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaEnhancedForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaEnhancedForOp(this, cc, ot);\n+        }\n+\n+        JavaEnhancedForOp(Body.Builder expressionC, Body.Builder initC, Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.expression = expressionC.build(this);\n+            if (expression.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.bodyType());\n+            }\n+            if (!expression.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.bodyType());\n+            }\n+\n+            this.init = initC.build(this);\n+            if (init.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.bodyType());\n+            }\n+            if (init.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.bodyType());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (body.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(expression, init, body);\n+        }\n+\n+        public Body expression() {\n+            return expression;\n+        }\n+\n+        public Body initialization() {\n+            return init;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        static final MethodRef ITERABLE_ITERATOR = MethodRef.method(Iterable.class, \"iterator\", Iterator.class);\n+        static final MethodRef ITERATOR_HAS_NEXT = MethodRef.method(Iterator.class, \"hasNext\", boolean.class);\n+        static final MethodRef ITERATOR_NEXT = MethodRef.method(Iterator.class, \"next\", Object.class);\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            JavaType elementType = (JavaType) init.entryBlock().parameters().get(0).type();\n+            boolean isArray = expression.bodyType().returnType() instanceof ArrayType;\n+\n+            Block.Builder preHeader = b.block(expression.bodyType().returnType());\n+            Block.Builder header = b.block(isArray ? List.of(INT) : List.of());\n+            Block.Builder init = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yop) {\n+                    Value loopSource = block.context().getValue(yop.yieldValue());\n+                    block.op(branch(preHeader.successor(loopSource)));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            if (isArray) {\n+                Value array = preHeader.parameters().get(0);\n+                Value arrayLength = preHeader.op(arrayLength(array));\n+                Value i = preHeader.op(constant(INT, 0));\n+                preHeader.op(branch(header.successor(i)));\n+\n+                i = header.parameters().get(0);\n+                Value p = header.op(lt(i, arrayLength));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(arrayLoadOp(array, i));\n+                List<Value> initValues = new ArrayList<>();\n+                \/\/ @@@ Init body has one yield operation yielding a single variable\n+                init.transformBody(this.init, List.of(e), (block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                });\n+\n+                Block.Builder update = b.block();\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                i = update.op(add(i, update.op(constant(INT, 1))));\n+                update.op(branch(header.successor(i)));\n+            } else {\n+                JavaType iterable = type(type(Iterator.class), elementType);\n+                Value iterator = preHeader.op(CoreOps.invoke(iterable, ITERABLE_ITERATOR, preHeader.parameters().get(0)));\n+                preHeader.op(branch(header.successor()));\n+\n+                Value p = header.op(CoreOps.invoke(ITERATOR_HAS_NEXT, iterator));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(CoreOps.invoke(elementType, ITERATOR_NEXT, iterator));\n+                List<Value> initValues = new ArrayList<>();\n+                init.transformBody(this.init, List.of(e), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The while operation, that can model a Java language while statement.\n+     *\/\n+    @OpDeclaration(JavaWhileOp.NAME)\n+    public static final class JavaWhileOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            PredicateBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaWhileOp.BodyBuilder predicate(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp.BodyBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder predicate;\n+\n+            BodyBuilder(Body.Builder ancestorBody, Body.Builder predicate) {\n+                this.ancestorBody = ancestorBody;\n+                this.predicate = predicate;\n+            }\n+\n+            public JavaWhileOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp(List.of(predicate, body));\n+            }\n+        }\n+\n+        private static final String NAME = \"java.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaWhileOp(OpDefinition def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(Body.Builder predicate, Body.Builder body) {\n+            super(NAME, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(predicate, body).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            \/\/ @@@ This will change with pattern bindings\n+            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n+            }\n+            if (!bodies.get(1).bodyType().equals(FunctionType.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n+            }\n+        }\n+\n+        JavaWhileOp(JavaWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(header.successor()));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The do-while operation, that can model a Java language do statement.\n+     *\/\n+    \/\/ @@@ Unify JavaDoWhileOp and JavaWhileOp with common abstract superclass\n+    @OpDeclaration(JavaDoWhileOp.NAME)\n+    public static final class JavaDoWhileOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder body;\n+\n+            PredicateBuilder(Body.Builder ancestorBody, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.body = body;\n+            }\n+\n+            public JavaDoWhileOp predicate(Consumer<Block.Builder> c) {\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(predicate.entryBlock());\n+\n+                return new JavaDoWhileOp(List.of(body, predicate));\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            BodyBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaDoWhileOp.PredicateBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaDoWhileOp.PredicateBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        private static final String NAME = \"java.do.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaDoWhileOp(OpDefinition def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(Body.Builder body, Body.Builder predicate) {\n+            super(NAME, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(body, predicate).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            if (!bodies.get(0).bodyType().equals(FunctionType.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n+            }\n+            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n+            }\n+        }\n+\n+        JavaDoWhileOp(JavaDoWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaDoWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaDoWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder body = b.block();\n+            Block.Builder header = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(body.successor()));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and-or operation, that can model Java language condition-or or conditional-and expressions.\n+     *\/\n+    public static sealed abstract class JavaConditionalOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        final List<Body> bodies;\n+\n+        public JavaConditionalOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(JavaConditionalOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(String name, List<Body.Builder> bodyCs) {\n+            super(name, List.of());\n+\n+            if (bodyCs.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            for (Body b : bodies) {\n+                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.bodyType());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        static Block.Builder lower(Block.Builder startBlock, OpTransformer opT, JavaConditionalOp cop) {\n+            List<Body> bodies = cop.bodies();\n+\n+            Block.Builder exit = startBlock.block();\n+            TypeElement oprType = cop.result().type();\n+            Block.Parameter arg = exit.parameter(oprType);\n+            startBlock.context().mapValue(cop.result(), arg);\n+\n+            \/\/ Transform bodies in reverse order\n+            \/\/ This makes available the blocks to be referenced as successors in prior blocks\n+\n+            Block.Builder pred = null;\n+            for (int i = bodies.size() - 1; i >= 0; i--) {\n+                OpTransformer opt;\n+                if (i == bodies.size() - 1) {\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOps.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            block.op(branch(exit.successor(p)));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                } else {\n+                    Block.Builder nextPred = pred;\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOps.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            if (cop instanceof JavaConditionalAndOp) {\n+                                block.op(conditionalBranch(p, nextPred.successor(), exit.successor(p)));\n+                            } else {\n+                                block.op(conditionalBranch(p, exit.successor(p), nextPred.successor()));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                }\n+\n+                Body fromPred = bodies.get(i);\n+                if (i == 0) {\n+                    startBlock.transformBody(fromPred, List.of(), opt);\n+                } else {\n+                    pred = startBlock.block(fromPred.bodyType().parameterTypes());\n+                    pred.transformBody(fromPred, pred.parameters(), opT.andThen(opt));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and operation, that can model Java language conditional-and expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalAndOp.NAME)\n+    public static final class JavaConditionalAndOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                and(lhs);\n+                and(rhs);\n+            }\n+\n+            public Builder and(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalAndOp build() {\n+                return new JavaConditionalAndOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cand\";\n+\n+        public JavaConditionalAndOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalAndOp(JavaConditionalAndOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalAndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalAndOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalAndOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-or operation, that can model Java language conditional-or expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalOrOp.NAME)\n+    public static final class JavaConditionalOrOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                or(lhs);\n+                or(rhs);\n+            }\n+\n+            public Builder or(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalOrOp build() {\n+                return new JavaConditionalOrOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cor\";\n+\n+        public JavaConditionalOrOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalOrOp(JavaConditionalOrOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalOrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalOrOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalOrOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional operation, that can model Java language conditional operator {@code ?} expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalExpressionOp.NAME)\n+    public static final class JavaConditionalExpressionOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        public static final String NAME = \"java.cexpression\";\n+\n+        final TypeElement resultType;\n+        \/\/ {cond, truepart, falsepart}\n+        final List<Body> bodies;\n+\n+        public JavaConditionalExpressionOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaConditionalExpressionOp(JavaConditionalExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaConditionalExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalExpressionOp(TypeElement expressionType, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            \/\/ @@@ when expressionType is null, we assume truepart and falsepart have the same yieldType\n+            this.resultType = expressionType == null ? bodies.get(1).yieldType() : expressionType;\n+\n+            if (bodies.size() < 3) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+\n+            Body cond = bodies.get(0);\n+            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block(resultType());\n+            exit.context().mapValue(result(), exit.parameters().get(0));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            List<Block.Builder> builders = List.of(b.block(), b.block());\n+            b.transformBody(bodies.get(0), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            builders.get(0).successor(), builders.get(1).successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            for (int i = 0; i < 2; i++) {\n+                builders.get(i).transformBody(bodies.get(i + 1), List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The try operation, that can model Java language try statements.\n+     *\/\n+    @OpDeclaration(JavaTryOp.NAME)\n+    public static final class JavaTryOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> resourceTypes;\n+            final Body.Builder resources;\n+\n+            BodyBuilder(Body.Builder ancestorBody, List<? extends TypeElement> resourceTypes, Body.Builder resources) {\n+                this.ancestorBody = ancestorBody;\n+                this.resourceTypes = resourceTypes;\n+                this.resources = resources;\n+            }\n+\n+            public CatchBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, resourceTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new CatchBuilder(ancestorBody, resources, body);\n+            }\n+        }\n+\n+        public static final class CatchBuilder {\n+            final Body.Builder ancestorBody;\n+            final Body.Builder resources;\n+            final Body.Builder body;\n+            final List<Body.Builder> catchers;\n+\n+            CatchBuilder(Body.Builder ancestorBody, Body.Builder resources, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.resources = resources;\n+                this.body = body;\n+                this.catchers = new ArrayList<>();\n+            }\n+\n+            \/\/ @@@ multi-catch\n+            public CatchBuilder _catch(TypeElement exceptionType, Consumer<Block.Builder> c) {\n+                Body.Builder _catch = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, exceptionType));\n+                c.accept(_catch.entryBlock());\n+                catchers.add(_catch);\n+\n+                return this;\n+            }\n+\n+            public JavaTryOp _finally(Consumer<Block.Builder> c) {\n+                Body.Builder _finally = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(_finally.entryBlock());\n+\n+                return new JavaTryOp(resources, body, catchers, _finally);\n+            }\n+\n+            public JavaTryOp noFinalizer() {\n+                return new JavaTryOp(resources, body, catchers, null);\n+            }\n+        }\n+\n+        static final String NAME = \"java.try\";\n+\n+        final Body resources;\n+        final Body body;\n+        final List<Body> catchers;\n+        final Body finalizer;\n+\n+        public static JavaTryOp create(OpDefinition def) {\n+            return new JavaTryOp(def);\n+        }\n+\n+        public JavaTryOp(OpDefinition def) {\n+            super(def);\n+\n+            List<Body> bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n+            Body first = bodies.get(0);\n+            if (first.bodyType().returnType().equals(VOID)) {\n+                this.resources = null;\n+                this.body = first;\n+            } else {\n+                this.resources = first;\n+                this.body = bodies.get(1);\n+            }\n+\n+            Body last = bodies.get(bodies.size() - 1);\n+            if (last.bodyType().parameterTypes().isEmpty()) {\n+                this.finalizer = last;\n+            } else {\n+                this.finalizer = null;\n+            }\n+            this.catchers = bodies.subList(\n+                    resources == null ? 1 : 2,\n+                    bodies.size() - (finalizer == null ? 0 : 1));\n+        }\n+\n+        JavaTryOp(JavaTryOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            if (that.resources != null) {\n+                this.resources = that.resources.transform(cc, ot).build(this);\n+            } else {\n+                this.resources = null;\n+            }\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.catchers = that.catchers.stream()\n+                    .map(b -> b.transform(cc, ot).build(this))\n+                    .toList();\n+            if (that.finalizer != null) {\n+                this.finalizer = that.finalizer.transform(cc, ot).build(this);\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public JavaTryOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaTryOp(this, cc, ot);\n+        }\n+\n+        JavaTryOp(Body.Builder resourcesC,\n+                  Body.Builder bodyC,\n+                  List<Body.Builder> catchersC,\n+                  Body.Builder finalizerC) {\n+            super(NAME, List.of());\n+\n+            if (resourcesC != null) {\n+                this.resources = resourcesC.build(this);\n+                if (resources.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.bodyType());\n+                }\n+                if (!resources.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.bodyType());\n+                }\n+            } else {\n+                this.resources = null;\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Try should return void: \" + body.bodyType());\n+            }\n+\n+            this.catchers = catchersC.stream().map(c -> c.build(this)).toList();\n+            for (Body _catch : catchers) {\n+                if (!_catch.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.bodyType());\n+                }\n+                if (_catch.bodyType().parameterTypes().size() != 1) {\n+                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.bodyType());\n+                }\n+            }\n+\n+            if (finalizerC != null) {\n+                this.finalizer = finalizerC.build(this);\n+                if (!finalizer.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.bodyType());\n+                }\n+                if (!finalizer.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.bodyType());\n+                }\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            ArrayList<Body> bodies = new ArrayList<>();\n+            if (resources != null) {\n+                bodies.add(resources);\n+            }\n+            bodies.add(body);\n+            bodies.addAll(catchers);\n+            if (finalizer != null) {\n+                bodies.add(finalizer);\n+            }\n+            return bodies;\n+        }\n+\n+        public Body resources() {\n+            return resources;\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public List<Body> catchers() {\n+            return catchers;\n+        }\n+\n+        public Body finalizer() {\n+            return finalizer;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            if (resources != null) {\n+                throw new UnsupportedOperationException(\"Lowering of try-with-resources is unsupported\");\n+            }\n+\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Simple case with no catch and finally bodies\n+            if (catchers.isEmpty() && finalizer == null) {\n+                b.transformBody(body, List.of(), (block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                });\n+                return exit;\n+            }\n+\n+            Block.Builder tryRegionEnter = b.block();\n+            Block.Builder tryRegionExit = b.block();\n+\n+            \/\/ Construct the catcher block builders\n+            List<Block.Builder> catchers = catchers().stream()\n+                    .map(catcher -> b.block())\n+                    .toList();\n+            Block.Builder catcherFinally = null;\n+            if (finalizer != null) {\n+                catcherFinally = b.block();\n+                catchers = new ArrayList<>(catchers);\n+                catchers.add(catcherFinally);\n+            }\n+\n+            \/\/ Enter the try exception region\n+            Result tryExceptionRegion = b.op(exceptionRegionEnter(tryRegionEnter.successor(), catchers.stream()\n+                    .map(Block.Builder::successor)\n+                    .toList()));\n+\n+            OpTransformer tryExitTransformer;\n+            if (finalizer != null) {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    if (op instanceof CoreOps.ReturnOp) {\n+                        return inlineFinalizer(block, tryExceptionRegion, opT);\n+                    } else if (op instanceof ExtendedOps.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                        return inlineFinalizer(block, tryExceptionRegion, opT);\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            } else {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    \/\/ @@@ break and continue\n+                    \/\/ when target break\/continue is enclosing the try\n+                    if (op instanceof CoreOps.ReturnOp) {\n+                        Block.Builder tryRegionReturnExit = block.block();\n+                        block.op(exceptionRegionExit(tryExceptionRegion, tryRegionReturnExit.successor()));\n+                        return tryRegionReturnExit;\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            }\n+            \/\/ Inline the try body\n+            AtomicBoolean hasTryRegionExit = new AtomicBoolean();\n+            tryRegionEnter.transformBody(body, List.of(), tryExitTransformer.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    hasTryRegionExit.set(true);\n+                    block.op(branch(tryRegionExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, tryExitTransformer);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            Block.Builder finallyEnter = null;\n+            if (finalizer != null) {\n+                finallyEnter = b.block();\n+                if (hasTryRegionExit.get()) {\n+                    \/\/ Exit the try exception region\n+                    tryRegionExit.op(exceptionRegionExit(tryExceptionRegion, finallyEnter.successor()));\n+                }\n+            } else if (hasTryRegionExit.get()) {\n+                \/\/ Exit the try exception region\n+                tryRegionExit.op(exceptionRegionExit(tryExceptionRegion, exit.successor()));\n+            }\n+\n+            \/\/ Inline the catch bodies\n+            for (int i = 0; i < this.catchers.size(); i++) {\n+                Block.Builder catcher = catchers.get(i);\n+                Body catcherBody = this.catchers.get(i);\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcher.parameter(catcherBody.bodyType().parameterTypes().get(0));\n+\n+                if (finalizer != null) {\n+                    Block.Builder catchRegionEnter = b.block();\n+                    Block.Builder catchRegionExit = b.block();\n+\n+                    \/\/ Enter the catch exception region\n+                    Result catchExceptionRegion = catcher.op(\n+                            exceptionRegionEnter(catchRegionEnter.successor(), catcherFinally.successor()));\n+\n+                    OpTransformer catchExitTransformer = opT.compose((block, op) -> {\n+                        if (op instanceof CoreOps.ReturnOp) {\n+                            return inlineFinalizer(block, catchExceptionRegion, opT);\n+                        } else if (op instanceof ExtendedOps.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                            return inlineFinalizer(block, catchExceptionRegion, opT);\n+                        } else {\n+                            return block;\n+                        }\n+                    });\n+                    \/\/ Inline the catch body\n+                    AtomicBoolean hasCatchRegionExit = new AtomicBoolean();\n+                    catchRegionEnter.transformBody(catcherBody, List.of(t), catchExitTransformer.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            hasCatchRegionExit.set(true);\n+                            block.op(branch(catchRegionExit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, catchExitTransformer);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+\n+                    \/\/ Exit the catch exception region\n+                    if (hasCatchRegionExit.get()) {\n+                        hasTryRegionExit.set(true);\n+                        catchRegionExit.op(exceptionRegionExit(catchExceptionRegion, finallyEnter.successor()));\n+                    }\n+                } else {\n+                    \/\/ Inline the catch body\n+                    catcher.transformBody(catcherBody, List.of(t), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            block.op(branch(exit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, opT);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            if (finalizer != null && hasTryRegionExit.get()) {\n+                \/\/ Inline the finally body\n+                finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            \/\/ Inline the finally body as a catcher of Throwable and adjusting to throw\n+            if (finalizer != null) {\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n+\n+                catcherFinally.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(_throw(t));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+            return exit;\n+        }\n+\n+        boolean ifExitFromTry(JavaLabelOp lop) {\n+            Op target = lop.target();\n+            return target == this || ifAncestorOp(target, this);\n+        }\n+\n+        static boolean ifAncestorOp(Op ancestor, Op op) {\n+            while (op.ancestorBody() != null) {\n+                op = op.ancestorBody().parentOp();\n+                if (op == ancestor) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        Block.Builder inlineFinalizer(Block.Builder block1, Value exceptionRegion, OpTransformer opT) {\n+            Block.Builder finallyEnter = block1.block();\n+            Block.Builder finallyExit = block1.block();\n+\n+            block1.op(exceptionRegionExit(exceptionRegion, finallyEnter.successor()));\n+\n+            \/\/ Inline the finally body\n+            finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block2, op2) -> {\n+                if (op2 instanceof YieldOp) {\n+                    block2.op(branch(finallyExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op2 instanceof Lowerable lop2) {\n+                        block2 = lop2.lower(block2, opT);\n+                    } else {\n+                        block2.op(op2);\n+                    }\n+                }\n+                return block2;\n+            }));\n+\n+            return finallyExit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    static final String Pattern_CLASS_NAME = ExtendedOps_CLASS_NAME + \"$\" + Pattern.class.getSimpleName();\n+\n+    \/\/ Reified pattern nodes\n+\n+    \/**\n+     * Synthetic pattern types\n+     * \/\/ @@@ Replace with types extending from TypeElement\n+     *\/\n+    public sealed interface Pattern {\n+\n+        \/**\n+         * Synthetic binding pattern type.\n+         *\n+         * @param <T> the type of values that are bound\n+         *\/\n+        final class Binding<T> implements Pattern {\n+            Binding() {\n+            }\n+        }\n+\n+        \/**\n+         * Synthetic record pattern type.\n+         *\n+         * @param <T> the type of records that are bound\n+         *\/\n+        final class Record<T> implements Pattern {\n+            Record() {\n+            }\n+        }\n+\n+        \/\/ @@@ Pattern types\n+\n+        JavaType PATTERN_BINDING_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Binding.class.getSimpleName()));\n+        JavaType PATTERN_RECORD_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Pattern.Record.class.getSimpleName()));\n+\n+        static JavaType bindingType(TypeElement t) {\n+            return type(PATTERN_BINDING_TYPE, (JavaType) t);\n+        }\n+\n+        static JavaType recordType(TypeElement t) {\n+            return type(PATTERN_RECORD_TYPE, (JavaType) t);\n+        }\n+\n+        static TypeElement targetType(TypeElement t) {\n+            return ((ClassType) t).typeArguments().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * Pattern operations.\n+     *\/\n+    public static final class PatternOps {\n+        PatternOps() {\n+        }\n+\n+        \/**\n+         * The pattern operation.\n+         *\/\n+        public static sealed abstract class PatternOp extends OpWithDefinition implements Op.Pure {\n+            PatternOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            PatternOp(PatternOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            PatternOp(String name, List<Value> operands) {\n+                super(name, operands);\n+            }\n+        }\n+\n+        \/**\n+         * The binding pattern operation, that can model Java language type patterns.\n+         *\/\n+        @OpDeclaration(BindingPatternOp.NAME)\n+        public static final class BindingPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.binding\";\n+\n+            public static final String ATTRIBUTE_BINDING_NAME = NAME + \".binding.name\";\n+\n+            final TypeElement resultType;\n+            final String bindingName;\n+\n+            public static BindingPatternOp create(OpDefinition def) {\n+                String name = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n+                        v -> switch (v) {\n+                            case String s -> s;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported pattern binding name value:\" + v);\n+                        });\n+                return new BindingPatternOp(def, name);\n+            }\n+\n+            BindingPatternOp(OpDefinition def, String bindingName) {\n+                super(def);\n+\n+                this.bindingName = bindingName;\n+                this.resultType = def.resultType();\n+            }\n+\n+            BindingPatternOp(BindingPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.bindingName = that.bindingName;\n+                this.resultType = that.resultType;\n+            }\n+\n+            @Override\n+            public BindingPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new BindingPatternOp(this, cc);\n+            }\n+\n+            BindingPatternOp(TypeElement targetType, String bindingName) {\n+                super(NAME, List.of());\n+\n+                this.bindingName = bindingName;\n+                this.resultType = Pattern.bindingType(targetType);\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+                attrs.put(\"\", bindingName);\n+                return attrs;\n+            }\n+\n+            public String bindingName() {\n+                return bindingName;\n+            }\n+\n+            public TypeElement targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return resultType;\n+            }\n+        }\n+\n+        \/**\n+         * The record pattern operation, that can model Java language record patterns.\n+         *\/\n+        @OpDeclaration(RecordPatternOp.NAME)\n+        public static final class RecordPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.record\";\n+\n+            public static final String ATTRIBUTE_RECORD_DESCRIPTOR = NAME + \".descriptor\";\n+\n+            final RecordTypeRef recordDescriptor;\n+\n+            public static RecordPatternOp create(OpDefinition def) {\n+                RecordTypeRef recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR,true,\n+                        v -> switch (v) {\n+                            case String s -> RecordTypeRef.ofString(s);\n+                            case RecordTypeRef rtd -> rtd;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported record type descriptor value:\" + v);\n+                        });\n+\n+                return new RecordPatternOp(def, recordDescriptor);\n+            }\n+\n+            RecordPatternOp(OpDefinition def, RecordTypeRef recordDescriptor) {\n+                super(def);\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            RecordPatternOp(RecordPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.recordDescriptor = that.recordDescriptor;\n+            }\n+\n+            @Override\n+            public RecordPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new RecordPatternOp(this, cc);\n+            }\n+\n+            RecordPatternOp(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n+                \/\/ The type of each value is a subtype of Pattern\n+                \/\/ The number of values corresponds to the number of components of the record\n+                super(NAME, List.copyOf(nestedPatterns));\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> m = new HashMap<>(super.attributes());\n+                m.put(\"\", recordDescriptor);\n+                return Collections.unmodifiableMap(m);\n+            }\n+\n+            public RecordTypeRef recordDescriptor() {\n+                return recordDescriptor;\n+            }\n+\n+            public TypeElement targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return Pattern.recordType(recordDescriptor.recordType());\n+            }\n+        }\n+\n+        \/**\n+         * The match operation, that can model Java language pattern matching.\n+         *\/\n+        @OpDeclaration(MatchOp.NAME)\n+        public static final class MatchOp extends OpWithDefinition implements Op.Isolated, Op.Lowerable {\n+            public static final String NAME = \"pattern.match\";\n+\n+            final Body pattern;\n+            final Body match;\n+\n+            public MatchOp(OpDefinition def) {\n+                super(def);\n+\n+                this.pattern = def.bodyDefinitions().get(0).build(this);\n+                this.match = def.bodyDefinitions().get(1).build(this);\n+            }\n+\n+            MatchOp(MatchOp that, CopyContext cc, OpTransformer ot) {\n+                super(that, cc);\n+\n+                this.pattern = that.pattern.transform(cc, ot).build(this);\n+                this.match = that.match.transform(cc, ot).build(this);\n+            }\n+\n+            @Override\n+            public MatchOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MatchOp(this, cc, ot);\n+            }\n+\n+            MatchOp(Value target, Body.Builder patternC, Body.Builder matchC) {\n+                super(NAME,\n+                        List.of(target));\n+\n+                this.pattern = patternC.build(this);\n+                this.match = matchC.build(this);\n+            }\n+\n+            @Override\n+            public List<Body> bodies() {\n+                return List.of(pattern, match);\n+            }\n+\n+            public Body pattern() {\n+                return pattern;\n+            }\n+\n+            public Body match() {\n+                return match;\n+            }\n+\n+            public Value target() {\n+                return operands().get(0);\n+            }\n+\n+            @Override\n+            public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+                \/\/ No match block\n+                Block.Builder endNoMatchBlock = b.block();\n+                \/\/ Match block\n+                Block.Builder endMatchBlock = b.block();\n+                \/\/ End block\n+                Block.Builder endBlock = b.block();\n+                Block.Parameter matchResult = endBlock.parameter(resultType());\n+                \/\/ Map match operation result\n+                b.context().mapValue(result(), matchResult);\n+\n+                List<Value> patternValues = new ArrayList<>();\n+                Op patternYieldOp = pattern.entryBlock().terminatingOp();\n+                Op.Result rootPatternValue = (Op.Result) patternYieldOp.operands().get(0);\n+                Block.Builder currentBlock = lower(endNoMatchBlock, b,\n+                        patternValues,\n+                        rootPatternValue.op(),\n+                        b.context().getValue(target()));\n+                currentBlock.op(branch(endMatchBlock.successor()));\n+\n+                \/\/ No match block\n+                \/\/ Pass false\n+                endNoMatchBlock.op(branch(endBlock.successor(\n+                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n+\n+                \/\/ Match block\n+                \/\/ Lower match body and pass true\n+                endMatchBlock.transformBody(match, patternValues, opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(endBlock.successor(\n+                                block.op(constant(BOOLEAN, true)))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                return endBlock;\n+            }\n+\n+            static Block.Builder lower(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       Op pattern, Value target) {\n+                if (pattern instanceof ExtendedOps.PatternOps.RecordPatternOp rp) {\n+                    return lowerRecordPattern(endNoMatchBlock, currentBlock, bindings, rp, target);\n+                } else if (pattern instanceof ExtendedOps.PatternOps.BindingPatternOp bp) {\n+                    return lowerBindingPattern(endNoMatchBlock, currentBlock, bindings, bp, target);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unknown pattern op: \" + pattern);\n+                }\n+            }\n+\n+            static Block.Builder lowerRecordPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       ExtendedOps.PatternOps.RecordPatternOp rpOp, Value target) {\n+                TypeElement targetType = rpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                Op.Result isInstance = currentBlock.op(CoreOps.instanceOf(targetType, target));\n+                currentBlock.op(conditionalBranch(isInstance, nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(CoreOps.cast(targetType, target));\n+\n+                \/\/ Access component values of record and match on each as nested target\n+                List<Value> dArgs = rpOp.operands();\n+                for (int i = 0; i < dArgs.size(); i++) {\n+                    Op.Result nestedPattern = (Op.Result) dArgs.get(i);\n+                    \/\/ @@@ Handle exceptions?\n+                    Value nestedTarget = currentBlock.op(CoreOps.invoke(rpOp.recordDescriptor().methodForComponent(i), target));\n+\n+                    currentBlock = lower(endNoMatchBlock, currentBlock, bindings, nestedPattern.op(), nestedTarget);\n+                }\n+\n+                return currentBlock;\n+            }\n+\n+            static Block.Builder lowerBindingPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       ExtendedOps.PatternOps.BindingPatternOp bpOp, Value target) {\n+                TypeElement targetType = bpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                currentBlock.op(conditionalBranch(currentBlock.op(CoreOps.instanceOf(targetType, target)),\n+                        nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(CoreOps.cast(targetType, target));\n+                bindings.add(target);\n+\n+                return currentBlock;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return BOOLEAN;\n+            }\n+        }\n+    }\n+\n+\n+    \/**\n+     * A factory for extended and core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = CoreOps.FACTORY.andThen(OpFactory.OP_FACTORY.get(ExtendedOps.class));\n+\n+\n+    \/**\n+     * Creates a continue operation.\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue() {\n+        return _continue(null);\n+    }\n+\n+    \/**\n+     * Creates a continue operation.\n+     * @param label the value associated with where to continue from\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue(Value label) {\n+        return new JavaContinueOp(label);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break() {\n+        return _break(null);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     * @param label the value associated with where to continue from\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break(Value label) {\n+        return new JavaBreakOp(label);\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield() {\n+        return new JavaYieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @param operand the value to yield\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield(Value operand) {\n+        return new JavaYieldOp(operand);\n+    }\n+\n+    \/**\n+     * Creates a block operation.\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaBlockOp block(Body.Builder body) {\n+        return new JavaBlockOp(body);\n+    }\n+\n+    \/**\n+     * Creates a labeled operation.\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaLabeledOp labeled(Body.Builder body) {\n+        return new JavaLabeledOp(body);\n+    }\n+\n+    \/**\n+     * Creates an if operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the if operation builder\n+     *\/\n+    public static JavaIfOp.IfBuilder _if(Body.Builder ancestorBody) {\n+        return new JavaIfOp.IfBuilder(ancestorBody);\n+    }\n+\n+    \/\/ Pairs of\n+    \/\/   predicate ()boolean, body ()void\n+    \/\/ And one optional body ()void at the end\n+\n+    \/**\n+     * Creates an if operation.\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the if operation\n+     *\/\n+    public static JavaIfOp _if(List<Body.Builder> bodies) {\n+        return new JavaIfOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     * <p>\n+     * The result type of the operation will be derived from the yield type of the second body\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchExpressionOp(null, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     *\n+     * @param resultType the result type of the expression\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(TypeElement resultType, Value target,\n+                                                          List<Body.Builder> bodies) {\n+        Objects.requireNonNull(resultType);\n+        return new JavaSwitchExpressionOp(resultType, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch fallthrough operation.\n+     * @return the switch fallthrough operation\n+     *\/\n+    public static JavaSwitchFallthroughOp switchFallthroughOp() {\n+        return new JavaSwitchFallthroughOp();\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param initTypes the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeElement... initTypes) {\n+        return _for(ancestorBody, List.of(initTypes));\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param initTypes the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<? extends TypeElement> initTypes) {\n+        return new JavaForOp.InitBuilder(ancestorBody, initTypes);\n+    }\n+\n+\n+    \/**\n+     * Creates a for operation.\n+     * @param init the init body builder of the operation to be built and become its child\n+     * @param cond the cond body builder of the operation to be built and become its child\n+     * @param update the update body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the for operation\n+     *\/\n+    \/\/ init ()Tuple<Var<T1>, Var<T2>, ..., Var<TN>>, or init ()void\n+    \/\/ cond (Var<T1>, Var<T2>, ..., Var<TN>)boolean\n+    \/\/ update (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    \/\/ body (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    public static JavaForOp _for(Body.Builder init,\n+                                 Body.Builder cond,\n+                                 Body.Builder update,\n+                                 Body.Builder body) {\n+        return new JavaForOp(init, cond, update, body);\n+    }\n+\n+    \/**\n+     * Creates an enhanced for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param iterableType the iterable type\n+     * @param elementType the element type\n+     * @return the enhanced for operation builder\n+     *\/\n+    public static JavaEnhancedForOp.ExpressionBuilder enhancedFor(Body.Builder ancestorBody,\n+                                                                  TypeElement iterableType, TypeElement elementType) {\n+        return new JavaEnhancedForOp.ExpressionBuilder(ancestorBody, iterableType, elementType);\n+    }\n+\n+    \/\/ expression ()I<E>\n+    \/\/ init (E )Var<T>\n+    \/\/ body (Var<T> )void\n+\n+    \/**\n+     * Creates an enhanced for operation.\n+     * @param expression the expression body builder of the operation to be built and become its child\n+     * @param init the init body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the enhanced for operation\n+     *\/\n+    public static JavaEnhancedForOp enhancedFor(Body.Builder expression,\n+                                                Body.Builder init,\n+                                                Body.Builder body) {\n+        return new JavaEnhancedForOp(expression, init, body);\n+    }\n+\n+    \/**\n+     * Creates a while operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the while operation builder\n+     *\/\n+    public static JavaWhileOp.PredicateBuilder _while(Body.Builder ancestorBody) {\n+        return new JavaWhileOp.PredicateBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a while operation.\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the while operation\n+     *\/\n+    \/\/ predicate, ()boolean, may be null for predicate returning true\n+    \/\/ body, ()void\n+    public static JavaWhileOp _while(Body.Builder predicate, Body.Builder body) {\n+        return new JavaWhileOp(predicate, body);\n+    }\n+\n+    \/**\n+     * Creates a do operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the do operation builder\n+     *\/\n+    public static JavaDoWhileOp.BodyBuilder doWhile(Body.Builder ancestorBody) {\n+        return new JavaDoWhileOp.BodyBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a do operation.\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the do operation\n+     *\/\n+    public static JavaDoWhileOp doWhile(Body.Builder body, Body.Builder predicate) {\n+        return new JavaDoWhileOp(body, predicate);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param lhs a consumer that builds the left-hand side body\n+     * @param rhs a consumer that builds the right-hand side body\n+     * @return the conditional-and operation builder\n+     *\/\n+    public static JavaConditionalAndOp.Builder conditionalAnd(Body.Builder ancestorBody,\n+                                                              Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalAndOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param lhs a consumer that builds the left-hand side body\n+     * @param rhs a consumer that builds the right-hand side body\n+     * @return the conditional-or operation builder\n+     *\/\n+    public static JavaConditionalOrOp.Builder conditionalOr(Body.Builder ancestorBody,\n+                                                            Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalOrOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-and operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalAndOp conditionalAnd(List<Body.Builder> bodies) {\n+        return new JavaConditionalAndOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-or operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalOrOp conditionalOr(List<Body.Builder> bodies) {\n+        return new JavaConditionalOrOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     * @param expressionType the result type of the expression\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(TypeElement expressionType,\n+                                                                    List<Body.Builder> bodies) {\n+        Objects.requireNonNull(expressionType);\n+        return new JavaConditionalExpressionOp(expressionType, bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     * <p>\n+     * The result type of the operation will be derived from the yield type of the second body\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(List<Body.Builder> bodies) {\n+        return new JavaConditionalExpressionOp(null, bodies);\n+    }\n+\n+    \/**\n+     * Creates try operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param c a consumer that builds the try body\n+     * @return the try operation builder\n+     *\/\n+    public static JavaTryOp.CatchBuilder _try(Body.Builder ancestorBody, Consumer<Block.Builder> c) {\n+        Body.Builder _try = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        c.accept(_try.entryBlock());\n+        return new JavaTryOp.CatchBuilder(ancestorBody, null, _try);\n+    }\n+\n+    \/**\n+     * Creates try-with-resources operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param c a consumer that builds the resources body\n+     * @return the try-with-resources operation builder\n+     *\/\n+    public static JavaTryOp.BodyBuilder tryWithResources(Body.Builder ancestorBody,\n+                                                         List<? extends TypeElement> resourceTypes,\n+                                                         Consumer<Block.Builder> c) {\n+        resourceTypes = resourceTypes.stream().map(VarType::varType).toList();\n+        Body.Builder resources = Body.Builder.of(ancestorBody,\n+                FunctionType.functionType(TupleType.tupleType(resourceTypes)));\n+        c.accept(resources.entryBlock());\n+        return new JavaTryOp.BodyBuilder(ancestorBody, resourceTypes, resources);\n+    }\n+\n+    \/\/ resources ()Tuple<Var<R1>, Var<R2>, ..., Var<RN>>, or null\n+    \/\/ try (Var<R1>, Var<R2>, ..., Var<RN>)void, or try ()void\n+    \/\/ catch (E )void, where E <: Throwable\n+    \/\/ finally ()void, or null\n+\n+    \/**\n+     * Creates a try or try-with-resources operation.\n+     * @param resources the try body builder of the operation to be built and become its child,\n+     *                  may be null\n+     * @param body the try body builder of the operation to be built and become its child\n+     * @param catchers the catch body builders of the operation to be built and become its children\n+     * @param finalizer the finalizer body builder of the operation to be built and become its child\n+     * @return the try or try-with-resources operation\n+     *\/\n+    public static JavaTryOp _try(Body.Builder resources,\n+                                 Body.Builder body,\n+                                 List<Body.Builder> catchers,\n+                                 Body.Builder finalizer) {\n+        return new JavaTryOp(resources, body, catchers, finalizer);\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    \/**\n+     * Creates a pattern match operation.\n+     * @param target the target value\n+     * @param pattern the pattern body builder of the operation to be built and become its child\n+     * @param match the match body builder of the operation to be built and become its child\n+     * @return the pattern match operation\n+     *\/\n+    public static PatternOps.MatchOp match(Value target,\n+                                           Body.Builder pattern, Body.Builder match) {\n+        return new PatternOps.MatchOp(target, pattern, match);\n+    }\n+\n+    \/**\n+     * Creates a pattern binding operation.\n+     * @param type the type of value to be bound\n+     * @param bindingName the binding name\n+     * @return the pattern binding operation\n+     *\/\n+    public static PatternOps.BindingPatternOp bindingPattern(TypeElement type, String bindingName) {\n+        return new PatternOps.BindingPatternOp(type, bindingName);\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, Value... nestedPatterns) {\n+        return recordPattern(recordDescriptor, List.of(nestedPatterns));\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n+        return new PatternOps.RecordPatternOp(recordDescriptor, nestedPatterns);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":3151,"deletions":0,"binary":false,"changes":3151,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.*;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * An operation that may be constructed with an operation {@link OpDefinition definition}.\n+ *\/\n+public abstract class OpWithDefinition extends Op {\n+\n+    \/**\n+     * The attribute name associated with the location attribute.\n+     *\/\n+    public static final String ATTRIBUTE_LOCATION = \"loc\";\n+\n+    \/**\n+     * Constructs an operation by copying given operation.\n+     *\n+     * @param that the operation to copy.\n+     * @param cc   the copy context.\n+     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n+     * values computed, in order, by mapping the operation's operands using the copy context.\n+     *\/\n+    protected OpWithDefinition(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+\n+    \/**\n+     * Constructs an operation with a name, operation result type, and list of operands.\n+     *\n+     * @param name     the operation name.\n+     * @param operands the list of operands, a copy of the list is performed if required.\n+     *\/\n+    protected OpWithDefinition(String name, List<? extends Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    \/**\n+     * Constructs an operation from its operation definition.\n+     *\n+     * @param def the operation definition.\n+     * @implSpec This implementation invokes the {@link Op#Op(String, List) constructor}\n+     * accepting the non-optional components of the operation definition, {@code name}, {@code resultType},\n+     * and {@code operands}:\n+     * <pre> {@code\n+     *  this(def.name(), def.resultType(), def.operands());\n+     * }<\/pre>\n+     * If the attributes component of the operation definition is copied as if by {@code Map.copyOf}.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected OpWithDefinition(OpDefinition def) {\n+        super(def.name(), def.operands());\n+        setLocation(extractLocation(def));\n+    }\n+\n+    static Location extractLocation(OpDefinition def) {\n+        Object v = def.attributes().get(ATTRIBUTE_LOCATION);\n+        return switch(v) {\n+            case String s -> Location.fromString(s);\n+            case Location loc -> loc;\n+            case null -> null;\n+            default -> throw new UnsupportedOperationException(\"Unsupported location value:\" + v);\n+        };\n+    }\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        Location l = location();\n+        return l == null ? Map.of() : Map.of(ATTRIBUTE_LOCATION, l);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpWithDefinition.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -971,0 +972,16 @@\n+\n+    \/**\n+     * Returns the code model of provided executable element (if any).\n+     * <p>\n+     * If the executable element has a code model then it will be an instance of\n+     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n+     * Note: due to circular dependencies we cannot refer to the type explicitly.\n+     *\n+     * @implSpec The default implementation unconditionally returns an empty optional.\n+     * @param e the executable element.\n+     * @return the code model of the provided executable element (if any).\n+     * @since 99\n+     *\/\n+    default Optional<Object> getBody(ExecutableElement e) {\n+        return Optional.empty();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -245,0 +246,12 @@\n+    \/\/ For code reflection\n+    public final Type codeReflectionType;\n+    public final Type quotedType;\n+    public final Type quotableType;\n+    public final Type closureOpType;\n+    public final Type lambdaOpType;\n+    public final Type opInterpreterType;\n+    public final Type opParserType;\n+    public final Type opType;\n+    public final MethodSymbol opInterpreterInvoke;\n+    public final MethodSymbol opParserFromString;\n+\n@@ -628,0 +641,19 @@\n+        \/\/ For code reflection\n+        codeReflectionType = enterClass(\"java.lang.runtime.CodeReflection\");\n+        quotedType = enterClass(\"java.lang.reflect.code.Quoted\");\n+        quotableType = enterClass(\"java.lang.reflect.code.Quotable\");\n+        closureOpType = enterClass(\"java.lang.reflect.code.op.CoreOps$ClosureOp\");\n+        lambdaOpType = enterClass(\"java.lang.reflect.code.op.CoreOps$LambdaOp\");\n+        opInterpreterType = enterClass(\"java.lang.reflect.code.interpreter.Interpreter\");\n+        opType = enterClass(\"java.lang.reflect.code.Op\");\n+        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n+                names.fromString(\"invoke\"),\n+                new MethodType(List.of(opType, new ArrayType(objectType, arrayClass)), objectType,\n+                        List.nil(), methodClass),\n+                opInterpreterType.tsym);\n+        opParserType = enterClass(\"java.lang.reflect.code.parser.OpParser\");\n+        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"fromStringOfFuncOp\"),\n+                new MethodType(List.of(stringType), opType,\n+                        List.nil(), methodClass),\n+                opParserType.tsym);\n@@ -634,0 +666,2 @@\n+        synthesizeEmptyInterfaceIfMissing(quotedType);\n+        synthesizeEmptyInterfaceIfMissing(quotableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -207,0 +217,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -210,0 +262,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -248,5 +302,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -307,0 +368,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -310,0 +372,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -324,1 +387,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -333,1 +396,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -351,1 +414,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -355,1 +418,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -365,1 +428,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -388,2 +451,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -417,1 +480,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5325,0 +5401,6 @@\n+\n+    \/\/ code reflection\n+\n+    public boolean isQuoted(Type type) {\n+        return type.tsym == syms.quotedType.tsym;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":96,"deletions":14,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -64,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -426,0 +432,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3118,0 +3137,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3261,0 +3288,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -442,0 +445,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                syntheticInits.append(capturedArg);\n+            }\n+        }\n+\n@@ -523,0 +532,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                indy_args = indy_args.append(capturedArg);\n+            }\n+        }\n+\n@@ -924,0 +939,1 @@\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n@@ -1143,0 +1159,1 @@\n+                    t.tsym != syms.quotableType.tsym &&\n@@ -1149,0 +1166,1 @@\n+            flags |= context.isQuotable() ? FLAG_QUOTABLE : 0;\n@@ -1171,0 +1189,4 @@\n+            if (context.isQuotable()) {\n+                VarSymbol reflectField = (VarSymbol)tree.codeReflectionInfo.quotedField();\n+                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+            }\n@@ -1865,0 +1887,1 @@\n+                        isQuotable() ||\n@@ -1875,0 +1898,4 @@\n+\n+            boolean isQuotable() {\n+                return tree.codeReflectionInfo != null;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,2625 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.IntersectionClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.UnionClassType;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.DeferredAttr.FilterScanner;\n+import com.sun.tools.javac.jvm.ByteCodes;\n+import com.sun.tools.javac.jvm.Gen;\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCArrayAccess;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression.CodeReflectionInfo;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewArray;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.JCAssert;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n+import jdk.internal.java.lang.reflect.code.*;\n+import jdk.internal.java.lang.reflect.code.op.CoreOps;\n+import jdk.internal.java.lang.reflect.code.op.ExtendedOps;\n+import jdk.internal.java.lang.reflect.code.type.*;\n+import jdk.internal.java.lang.reflect.code.type.WildcardType.BoundKind;\n+\n+import javax.lang.model.element.Modifier;\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.METHOD;\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static com.sun.tools.javac.main.Option.G_CUSTOM;\n+\n+\/**\n+ * This a tree translator that adds the code model to all method declaration marked\n+ * with the {@code CodeReflection} annotation. The model is expressed using the code\n+ * reflection API (see jdk.internal.java.lang.reflect.code).\n+ *\/\n+public class ReflectMethods extends TreeTranslator {\n+    protected static final Context.Key<ReflectMethods> reflectMethodsKey = new Context.Key<>();\n+\n+    public static ReflectMethods instance(Context context) {\n+        ReflectMethods instance = context.get(reflectMethodsKey);\n+        if (instance == null)\n+            instance = new ReflectMethods(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Gen gen;\n+    private final Log log;\n+    private final boolean dumpIR;\n+    private final boolean lineDebugInfo;\n+\n+    \/\/ @@@ Separate out mutable state\n+    private TreeMaker make;\n+    private ListBuffer<JCTree> classOps;\n+    \/\/ Also used by BodyScanner\n+    private Symbol.ClassSymbol currentClassSym;\n+    private int lambdaCount;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ReflectMethods(Context context) {\n+        context.put(reflectMethodsKey, this);\n+        Options options = Options.instance(context);\n+        dumpIR = options.isSet(\"dumpIR\");\n+        lineDebugInfo =\n+                options.isUnset(G_CUSTOM) ||\n+                        options.isSet(G_CUSTOM, \"lines\");\n+        names = Names.instance(context);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        gen = Gen.instance(context);\n+        log = Log.instance(context);\n+\n+\n+    }\n+\n+    \/\/ Cannot compute within constructor due to circular dependencies on bootstrap compilation\n+    \/\/ syms.objectType == null\n+    private Map<JavaType, Type> primitiveAndBoxTypeMap;\n+    Map<JavaType, Type> primitiveAndBoxTypeMap() {\n+        Map<JavaType, Type> m = primitiveAndBoxTypeMap;\n+        if (m == null) {\n+            m = primitiveAndBoxTypeMap = Map.ofEntries(\n+                    Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                    Map.entry(JavaType.BYTE, syms.byteType),\n+                    Map.entry(JavaType.SHORT, syms.shortType),\n+                    Map.entry(JavaType.CHAR, syms.charType),\n+                    Map.entry(JavaType.INT, syms.intType),\n+                    Map.entry(JavaType.LONG, syms.longType),\n+                    Map.entry(JavaType.FLOAT, syms.floatType),\n+                    Map.entry(JavaType.DOUBLE, syms.doubleType),\n+                    Map.entry(JavaType.J_L_OBJECT, syms.objectType),\n+                    Map.entry(JavaType.J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n+                    Map.entry(JavaType.J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n+                    Map.entry(JavaType.J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n+                    Map.entry(JavaType.J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n+                    Map.entry(JavaType.J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n+                    Map.entry(JavaType.J_L_LONG, types.boxedTypeOrType(syms.longType)),\n+                    Map.entry(JavaType.J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n+                    Map.entry(JavaType.J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n+            );\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (tree.sym.attribute(syms.codeReflectionType.tsym) != null) {\n+            \/\/ if the method is annotated, scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanMethod();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                classOps.add(opFieldDecl(tree.name, tree.getModifiers().flags, funcOp));\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the method body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n+            }\n+        }\n+        super.visitMethodDef(tree);\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ListBuffer<JCTree> prevClassOps = classOps;\n+        Symbol.ClassSymbol prevClassSym = currentClassSym;\n+        int prevLambdaCount = lambdaCount;\n+        try {\n+            lambdaCount = 0;\n+            currentClassSym = tree.sym;\n+            classOps = new ListBuffer<>();\n+            super.visitClassDef(tree);\n+            tree.defs = tree.defs.prependList(classOps.toList());\n+        } finally {\n+            lambdaCount = prevLambdaCount;\n+            classOps = prevClassOps;\n+            currentClassSym = prevClassSym;\n+            result = tree;\n+        }\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree, kind);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, null);\n+\n+                switch (kind) {\n+                    case QUOTED_STRUCTURAL -> {\n+                        JCIdent opFieldId = make.Ident(opField.sym);\n+                        ListBuffer<JCExpression> interpreterArgs = new ListBuffer<>();\n+                        JCMethodInvocation parsedOp = make.App(make.Ident(syms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n+                        interpreterArgs.append(parsedOp);\n+                        \/\/ append captured vars\n+                        interpreterArgs.appendList(capturedArgs.toList());\n+\n+                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(syms.opInterpreterInvoke), interpreterArgs.toList());\n+                        interpreterInvoke.varargsElement = syms.objectType;\n+                        super.visitLambda(tree);\n+                        result = interpreterInvoke;\n+                    }\n+                    case QUOTABLE -> {\n+                        \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                        tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                        super.visitLambda(tree);\n+                    }\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitLambda(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        Assert.check(kind != FunctionalExpressionKind.QUOTED_STRUCTURAL,\n+                \"structural quoting not supported for method references\");\n+        MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+        JCVariableDecl recvDecl = memberReferenceToLambda.receiverVar();\n+        JCLambda lambdaTree = memberReferenceToLambda.lambda();\n+\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(lambdaTree, kind);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, recvDecl);\n+                tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                super.visitReference(tree);\n+                if (recvDecl != null) {\n+                    result = copyReferenceWithReceiverVar(tree, recvDecl);\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+\n+    ListBuffer<JCExpression> quotedCapturedArgs(DiagnosticPosition pos, BodyScanner bodyScanner, JCVariableDecl recvDecl) {\n+        ListBuffer<JCExpression> capturedArgs = new ListBuffer<>();\n+        for (Symbol capturedSym : bodyScanner.stack.localToOp.keySet()) {\n+            if (capturedSym.kind == Kind.TYP) {\n+                \/\/ captured this\n+                capturedArgs.add(make.at(pos).This(capturedSym.type));\n+            } else if (recvDecl != null && capturedSym == recvDecl.sym) {\n+                \/\/ captured method reference receiver\n+                capturedArgs.add(make.at(pos).Ident(recvDecl.sym));\n+            } else if (capturedSym.kind == Kind.VAR) {\n+                \/\/ captured var\n+                VarSymbol var = (VarSymbol)capturedSym;\n+                if (var.getConstValue() == null) {\n+                    capturedArgs.add(make.at(pos).Ident(capturedSym));\n+                } else {\n+                    capturedArgs.add(make.at(pos).Literal(var.getConstValue()));\n+                }\n+            } else {\n+                throw new AssertionError(\"Unexpected captured symbol: \" + capturedSym);\n+            }\n+        }\n+        return capturedArgs;\n+    }\n+\n+    \/*\n+     * Creates a let expression of the kind:\n+     * let $recv in $recv::memberRef\n+     *\n+     * This is required to make sure that LambdaToMethod doesn't end up emitting the\n+     * code for capturing the bound method reference receiver twice.\n+     *\/\n+    JCExpression copyReferenceWithReceiverVar(JCMemberReference ref, JCVariableDecl recvDecl) {\n+        JCMemberReference newRef = make.at(ref).Reference(ref.mode, ref.name, make.Ident(recvDecl.sym), ref.typeargs);\n+        newRef.type = ref.type;\n+        newRef.target = ref.target;\n+        newRef.refPolyKind = ref.refPolyKind;\n+        newRef.referentType = ref.referentType;\n+        newRef.kind = ref.kind;\n+        newRef.varargsElement = ref.varargsElement;\n+        newRef.ownerAccessible = ref.ownerAccessible;\n+        newRef.sym = ref.sym;\n+        newRef.codeReflectionInfo = ref.codeReflectionInfo;\n+        return make.at(ref).LetExpr(recvDecl, newRef).setType(newRef.type);\n+    }\n+\n+    Name lambdaName() {\n+        return names.fromString(\"lambda\").append('$', names.fromString(String.valueOf(lambdaCount++)));\n+    }\n+\n+    private JCVariableDecl opFieldDecl(Name prefix, long flags, CoreOps.FuncOp op) {\n+        VarSymbol opFieldSym = new VarSymbol(flags | Flags.STATIC | Flags.FINAL | Flags.SYNTHETIC,\n+                prefix.append('$', names.fromString(\"op\")),\n+                syms.stringType,\n+                currentClassSym);\n+\n+        currentClassSym.members().enter(opFieldSym);\n+        JCLiteral opText = make.Literal(op.toText());\n+        JCVariableDecl opFieldTree = make.VarDef(opFieldSym, opText);\n+        return opFieldTree;\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        \/\/ note that this method does NOT support recursion.\n+        this.make = make;\n+        JCTree res = translate(cdef);\n+        return res;\n+    }\n+\n+    public CoreOps.FuncOp getMethodBody(Symbol.ClassSymbol classSym, JCMethodDecl methodDecl, JCBlock attributedBody, TreeMaker make) {\n+        \/\/ if the method is annotated, scan it\n+        \/\/ Called from JavacElements::getBody\n+        try {\n+            this.make = make;\n+            currentClassSym = classSym;\n+            BodyScanner bodyScanner = new BodyScanner(methodDecl, attributedBody);\n+            return bodyScanner.scanMethod();\n+        } finally {\n+            currentClassSym = null;\n+            this.make = null;\n+        }\n+    }\n+\n+    static class BodyStack {\n+        final BodyStack parent;\n+\n+        \/\/ Tree associated with body\n+        final JCTree tree;\n+\n+        \/\/ Body to add blocks\n+        final Body.Builder body;\n+        \/\/ Current block to add operations\n+        Block.Builder block;\n+\n+        \/\/ Map of symbols (method arguments and local variables) to varOp values\n+        final Map<Symbol, Value> localToOp;\n+\n+        \/\/ Label\n+        Map.Entry<String, Op.Result> label;\n+\n+        BodyStack(BodyStack parent, JCTree tree, FunctionType bodyType) {\n+            this.parent = parent;\n+\n+            this.tree = tree;\n+\n+            this.body = Body.Builder.of(parent != null ? parent.body : null, bodyType);\n+            this.block = body.entryBlock();\n+\n+            this.localToOp = new LinkedHashMap<>(); \/\/ order is important for captured values\n+        }\n+\n+        public void setLabel(String labelName, Op.Result labelValue) {\n+            if (label != null) {\n+                throw new IllegalStateException(\"Label already defined: \" + labelName);\n+            }\n+            label = Map.entry(labelName, labelValue);\n+        }\n+    }\n+\n+    class BodyScanner extends FilterScanner {\n+        private final JCTree body;\n+        private final Name name;\n+        private final BodyStack top;\n+        private BodyStack stack;\n+        private Op lastOp;\n+        private Value result;\n+        private Type pt = Type.noType;\n+        private boolean isQuoted;\n+        private Type bodyTarget;\n+        private JCTree currentNode;\n+\n+        \/\/ Only few AST nodes supported for now\n+        private static final Set<JCTree.Tag> SUPPORTED_TAGS =\n+                Set.of(Tag.VARDEF,\n+                        Tag.RETURN, Tag.THROW, Tag.BREAK, Tag.CONTINUE,\n+                        Tag.PLUS, Tag.MINUS, Tag.MUL, Tag.DIV, Tag.MOD,\n+                        Tag.NEG, Tag.NOT,\n+                        Tag.BITOR, Tag.BITAND, Tag.BITXOR,\n+                        Tag.SL, Tag.SR, Tag.USR,\n+                        Tag.PLUS_ASG, Tag.MINUS_ASG, Tag.MUL_ASG, Tag.DIV_ASG, Tag.MOD_ASG,\n+                        Tag.POSTINC, Tag.PREINC, Tag.POSTDEC, Tag.PREDEC,\n+                        Tag.EQ, Tag.NE, Tag.LT, Tag.LE, Tag.GT, Tag.GE,\n+                        Tag.AND, Tag.OR,\n+                        Tag.LITERAL, Tag.IDENT, Tag.TYPEIDENT, Tag.ASSIGN, Tag.EXEC, Tag.PARENS,\n+                        Tag.SELECT, Tag.INDEXED, Tag.APPLY,\n+                        Tag.TYPECAST, Tag.TYPETEST,\n+                        Tag.NEWCLASS, Tag.NEWARRAY, Tag.LAMBDA, Tag.REFERENCE,\n+                        Tag.BLOCK, Tag.IF, Tag.WHILELOOP, Tag.DOLOOP, Tag.FOREACHLOOP, Tag.FORLOOP, Tag.TRY,\n+                        Tag.SWITCH_EXPRESSION, Tag.YIELD,\n+                        Tag.CONDEXPR,\n+                        Tag.ASSERT,\n+                        Tag.LABELLED,\n+                        Tag.SKIP,\n+                        Tag.TYPEARRAY);\n+\n+        BodyScanner(JCMethodDecl tree) {\n+            this(tree, tree.body);\n+        }\n+\n+        BodyScanner(JCMethodDecl tree, JCBlock body) {\n+            super(SUPPORTED_TAGS);\n+\n+            this.currentNode = tree;\n+            this.body = body;\n+            this.name = tree.name;\n+            this.isQuoted = false;\n+\n+            List<TypeElement> parameters = new ArrayList<>();\n+            int blockArgOffset = 0;\n+            \/\/ Instance methods model \"this\" as an additional argument occurring\n+            \/\/ before all other arguments.\n+            \/\/ @@@ Inner classes.\n+            \/\/ We need to capture all \"this\", in nested order, as arguments.\n+            if (!tree.getModifiers().getFlags().contains(Modifier.STATIC)) {\n+                parameters.add(typeToTypeElement(tree.sym.owner.type));\n+                blockArgOffset++;\n+            }\n+            tree.sym.type.getParameterTypes().stream().map(this::typeToTypeElement).forEach(parameters::add);\n+\n+            FunctionType bodyType = FunctionType.functionType(\n+                    typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, bodyType);\n+\n+            \/\/ @@@ this as local variable? (it can never be stored to)\n+            for (int i = 0 ; i < tree.params.size() ; i++) {\n+                Op.Result paramOp = append(CoreOps.var(\n+                        tree.params.get(i).name.toString(),\n+                        top.block.parameters().get(blockArgOffset + i)));\n+                top.localToOp.put(tree.params.get(i).sym, paramOp);\n+            }\n+\n+            bodyTarget = tree.sym.type.getReturnType();\n+        }\n+\n+        BodyScanner(JCLambda tree, FunctionalExpressionKind kind) {\n+            super(SUPPORTED_TAGS);\n+            assert kind != FunctionalExpressionKind.NOT_QUOTED;\n+\n+            this.currentNode = tree;\n+            this.body = tree;\n+            this.name = names.fromString(\"quotedLambda\");\n+            this.isQuoted = true;\n+\n+            com.sun.tools.javac.util.List<Type> nil = com.sun.tools.javac.util.List.nil();\n+            MethodType mtype = new MethodType(nil, syms.quotedType, nil, syms.methodClass);\n+            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+                    mtype.getParameterTypes().map(this::typeToTypeElement));\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+\n+            bodyTarget = tree.target.getReturnType();\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            JCTree prev = currentNode;\n+            currentNode = tree;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                currentNode = prev;\n+            }\n+        }\n+\n+        void pushBody(JCTree tree, FunctionType bodyType) {\n+            stack = new BodyStack(stack, tree, bodyType);\n+            lastOp = null; \/\/ reset\n+        }\n+\n+        void popBody() {\n+            stack = stack.parent;\n+        }\n+\n+        Value varOpValue(Symbol sym) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                Value v = s.localToOp.get(sym);\n+                if (v != null) {\n+                    return v;\n+                }\n+                s = s.parent;\n+            }\n+            if (isQuoted) {\n+                return capturedOpValue(sym);\n+            } else {\n+                throw new NoSuchElementException(sym.toString());\n+            }\n+        }\n+\n+        Value capturedOpValue(Symbol sym) {\n+            var capturedVar = top.localToOp.get(sym);\n+            if (capturedVar == null) {\n+                var capturedArg = top.block.parameter(typeToTypeElement(sym.type));\n+                capturedVar = top.block.op(CoreOps.var(sym.name.toString(), capturedArg));\n+                top.localToOp.put(sym, capturedVar);\n+            }\n+            return capturedVar;\n+        }\n+\n+        Value thisValue() { \/\/ @@@: outer this?\n+            if (isQuoted) {\n+                \/\/ capture this - add captured class symbol to the stack top local mappings\n+                var capturedThis = top.localToOp.get(currentClassSym);\n+                if (capturedThis == null) {\n+                    capturedThis = top.block.parameter(typeToTypeElement(currentClassSym.type));\n+                    top.localToOp.put(currentClassSym, capturedThis);\n+                }\n+                return capturedThis;\n+            } else {\n+                return top.block.parameters().get(0);\n+            }\n+        }\n+\n+        Value getLabel(String labelName) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                if (s.label != null && s.label.getKey().equals(labelName)) {\n+                    return s.label.getValue();\n+                }\n+                s = s.parent;\n+            }\n+            throw new NoSuchElementException(labelName);\n+        }\n+\n+        private Op.Result append(Op op) {\n+            return append(op, generateLocation(currentNode, false), stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l) {\n+            return append(op, l, stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l, BodyStack stack) {\n+            lastOp = op;\n+            op.setLocation(l);\n+            return stack.block.apply(op);\n+        }\n+\n+        Location generateLocation(JCTree node, boolean includeSourceReference) {\n+            if (!lineDebugInfo) {\n+                return Location.NO_LOCATION;\n+            }\n+\n+            int pos = node.getStartPosition();\n+            int line = log.currentSource().getLineNumber(pos);\n+            int col = log.currentSource().getColumnNumber(pos, false);\n+            String path;\n+            if (includeSourceReference) {\n+                path = log.currentSource().getFile().toUri().toString();\n+            } else {\n+                path = null;\n+            }\n+            return new Location(path, line, col);\n+        }\n+\n+        private <O extends Op & Op.Terminating> void appendTerminating(Supplier<O> sop) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                append(sop.get());\n+            }\n+        }\n+\n+        public Value toValue(JCTree tree) {\n+            return toValue(tree, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree tree, Type target) {\n+            result = null; \/\/ reset\n+            Type prevPt = pt;\n+            try {\n+                pt = target;\n+                scan(tree);\n+                return result != null ?\n+                        coerce(result, tree.type, target) :\n+                        null;\n+            } finally {\n+                pt = prevPt;\n+            }\n+        }\n+\n+        Value coerce(Value sourceValue, Type sourceType, Type targetType) {\n+            if (sourceType.isReference() && targetType.isReference() &&\n+                    !types.isSubtype(types.erasure(sourceType), types.erasure(targetType))) {\n+                return append(CoreOps.cast(typeToTypeElement(targetType), sourceValue));\n+            } else {\n+                return convert(sourceValue, targetType);\n+            }\n+        }\n+\n+        Value boxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.boxedTypeOrType(source));\n+        }\n+\n+        Value unboxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.unboxedTypeOrType(source));\n+        }\n+\n+        Value convert(Value exprVal, Type target) {\n+            Type source = typeElementToType(exprVal.type());\n+            boolean sourcePrimitive = source.isPrimitive();\n+            boolean targetPrimitive = target.isPrimitive();\n+            if (target.hasTag(NONE)) {\n+                return exprVal;\n+            } else if (sourcePrimitive == targetPrimitive) {\n+                if (!sourcePrimitive || types.isSameType(source, target)) {\n+                    return exprVal;\n+                } else {\n+                    \/\/ implicit primitive conversion\n+                    return append(CoreOps.conv(typeToTypeElement(target), exprVal));\n+                }\n+            } else if (sourcePrimitive) {\n+                \/\/ we need to box\n+                Type unboxedTarget = types.unboxedType(target);\n+                if (!unboxedTarget.hasTag(NONE)) {\n+                    \/\/ non-Object target\n+                    return box(exprVal, target);\n+                } else {\n+                    \/\/ Object target\n+                    return box(exprVal, types.boxedClass(source).type);\n+                }\n+            } else {\n+                \/\/ we need to unbox\n+                return unbox(exprVal, source, target, types.unboxedType(source));\n+            }\n+        }\n+\n+        Value box(Value valueExpr, Type box) {\n+            \/\/ Boxing is a static method e.g., java.lang.Integer::valueOf(int)java.lang.Integer\n+            MethodRef boxMethod = MethodRef.method(typeToTypeElement(box), names.valueOf.toString(),\n+                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+            return append(CoreOps.invoke(boxMethod, valueExpr));\n+        }\n+\n+        Value unbox(Value valueExpr, Type box, Type primitive, Type unboxedType) {\n+            if (unboxedType.hasTag(NONE)) {\n+                \/\/ Object target, first downcast to correct wrapper type\n+                unboxedType = primitive;\n+                box = types.boxedClass(unboxedType).type;\n+                valueExpr = append(CoreOps.cast(typeToTypeElement(box), valueExpr));\n+            }\n+            \/\/ Unboxing is a virtual method e.g., java.lang.Integer::intValue()int\n+            MethodRef unboxMethod = MethodRef.method(typeToTypeElement(box),\n+                    unboxedType.tsym.name.append(names.Value).toString(),\n+                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+            return append(CoreOps.invoke(unboxMethod, valueExpr));\n+        }\n+\n+        @Override\n+        void skip(JCTree tree) {\n+            \/\/ this method is called for unsupported AST nodes (see 'SUPPORTED_TAGS')\n+            throw unsupported(tree);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            Value initOp;\n+            if (tree.init != null) {\n+                initOp = toValue(tree.init, tree.type);\n+            } else {\n+                initOp = append(defaultValue(tree.type));\n+            }\n+            result = append(CoreOps.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n+            stack.localToOp.put(tree.sym, result);\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            \/\/ Consume top node that applies to write access\n+            JCTree lhs = TreeInfo.skipParens(tree.lhs);\n+            Type target = tree.lhs.type;\n+            switch (lhs.getTag()) {\n+                case IDENT: {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+                            append(CoreOps.varStore(varOp, result));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fd = symbolToFieldRef(sym, symbolSiteType(sym));\n+                            if (sym.isStatic()) {\n+                                append(CoreOps.fieldStore(fd, result));\n+                            } else {\n+                                append(CoreOps.fieldStore(fd, thisValue(), result));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(tree);\n+                        }\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+                    if (sym.isStatic()) {\n+                        append(CoreOps.fieldStore(fr, result));\n+                    } else {\n+                        append(CoreOps.fieldStore(fr, receiver, result));\n+                    }\n+                    break;\n+                }\n+                case INDEXED: {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    append(CoreOps.arrayStoreOp(array, index, result));\n+                    break;\n+                }\n+                default:\n+                    throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssignop(JCTree.JCAssignOp tree) {\n+            \/\/ Capture applying rhs and operation\n+            Function<Value, Value> scanRhs = (lhs) -> {\n+                Type unboxedType = types.unboxedTypeOrType(tree.type);\n+                JavaType resultType = typeToTypeElement(unboxedType);\n+                Value rhs = toValue(tree.rhs, unboxedType);\n+                lhs = unboxIfNeeded(lhs);\n+\n+                Value assignOpResult = switch (tree.getTag()) {\n+\n+                    \/\/ Arithmetic operations\n+                    case PLUS_ASG -> append(CoreOps.add(lhs, rhs));\n+                    case MINUS_ASG -> append(CoreOps.sub(lhs, rhs));\n+                    case MUL_ASG -> append(CoreOps.mul(lhs, rhs));\n+                    case DIV_ASG -> append(CoreOps.div(lhs, rhs));\n+                    case MOD_ASG -> append(CoreOps.mod(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+                return result = convert(assignOpResult, tree.type);\n+            };\n+\n+            applyCompoundAssign(tree.lhs, scanRhs);\n+        }\n+\n+        void applyCompoundAssign(JCTree.JCExpression lhs, Function<Value, Value> scanRhs) {\n+            \/\/ Consume top node that applies to access\n+            lhs = TreeInfo.skipParens(lhs);\n+            switch (lhs.getTag()) {\n+                case IDENT -> {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+\n+                            Op.Result lhsOpValue = append(CoreOps.varLoad(varOp));\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            append(CoreOps.varStore(varOp, r));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+\n+                            Op.Result lhsOpValue;\n+                            TypeElement resultType = typeToTypeElement(sym.type);\n+                            if (sym.isStatic()) {\n+                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fr));\n+                            } else {\n+                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fr, thisValue()));\n+                            }\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            if (sym.isStatic()) {\n+                                append(CoreOps.fieldStore(fr, r));\n+                            } else {\n+                                append(CoreOps.fieldStore(fr, thisValue(), r));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(lhs);\n+                        }\n+                    }\n+                }\n+                case SELECT -> {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+\n+                    Op.Result lhsOpValue;\n+                    TypeElement resultType = typeToTypeElement(sym.type);\n+                    if (sym.isStatic()) {\n+                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fr));\n+                    } else {\n+                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fr, receiver));\n+                    }\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    if (sym.isStatic()) {\n+                        append(CoreOps.fieldStore(fr, r));\n+                    } else {\n+                        append(CoreOps.fieldStore(fr, receiver, r));\n+                    }\n+                }\n+                case INDEXED -> {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    Op.Result lhsOpValue = append(CoreOps.arrayLoadOp(array, index));\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    append(CoreOps.arrayStoreOp(array, index, r));\n+                }\n+                default -> throw unsupported(lhs);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            \/\/ Visited only for read access\n+\n+            Symbol sym = tree.sym;\n+            switch (sym.getKind()) {\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER -> {\n+                    Value varOp = varOpValue(sym);\n+                    if (varOp.type() instanceof VarType) {\n+                        \/\/ regular var\n+                        result = append(CoreOps.varLoad(varOp));\n+                    } else {\n+                        \/\/ captured value\n+                        result = varOp;\n+                    }\n+                }\n+                case FIELD, ENUM_CONSTANT -> {\n+                    if (sym.name.equals(names._this)) {\n+                        result = thisValue();\n+                    } else {\n+                        FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+                        TypeElement resultType = typeToTypeElement(sym.type);\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOps.fieldLoad(resultType, fr));\n+                        } else {\n+                            result = append(CoreOps.fieldLoad(resultType, fr, thisValue()));\n+                        }\n+                    }\n+                }\n+                case INTERFACE, CLASS, ENUM -> {\n+                    result = null;\n+                }\n+                default -> {\n+                    \/\/ @@@ Cannot reach here?\n+                    throw unsupported(tree);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeIdent(JCTree.JCPrimitiveTypeTree tree) {\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitTypeArray(JCTree.JCArrayTypeTree tree) {\n+            result = null; \/\/ MyType[].class is handled in visitSelect just as MyType.class\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Type qualifierTarget = qualifierTarget(tree);\n+            \/\/ @@@: might cause redundant load if accessed symbol is static but the qualifier is not a type\n+            Value receiver = toValue(tree.selected);\n+\n+            if (tree.name.equals(names._class)) {\n+                result = append(CoreOps.constant(JavaType.J_L_CLASS, typeToTypeElement(tree.selected.type)));\n+            } else if (types.isArray(tree.selected.type)) {\n+                if (tree.sym.equals(syms.lengthVar)) {\n+                    result = append(CoreOps.arrayLength(receiver));\n+                } else {\n+                    \/\/ Should not reach here\n+                    throw unsupported(tree);\n+                }\n+            } else {\n+                Symbol sym = tree.sym;\n+                switch (sym.getKind()) {\n+                    case FIELD, ENUM_CONSTANT -> {\n+                        FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n+                                tree.selected.type : qualifierTarget);\n+                        TypeElement resultType = typeToTypeElement(types.memberType(tree.selected.type, sym));\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOps.fieldLoad(resultType, fr));\n+                        } else {\n+                            result = append(CoreOps.fieldLoad(resultType, fr, receiver));\n+                        }\n+                    }\n+                    case INTERFACE, CLASS, ENUM -> {\n+                        result = null;\n+                    }\n+                    default -> {\n+                        \/\/ @@@ Cannot reach here?\n+                        throw unsupported(tree);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitIndexed(JCArrayAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Value array = toValue(tree.indexed);\n+\n+            Value index = toValue(tree.index);\n+\n+            result = append(CoreOps.arrayLoadOp(array, index));\n+        }\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            \/\/ @@@ Symbol.externalType, for use with inner classes\n+\n+            \/\/ @@@ this.xyz(...) calls in a constructor\n+\n+            \/\/ @@@ super.xyz(...) calls\n+            \/\/ Modeling with a call operation would result in the receiver type differing from that\n+            \/\/ in the method reference, perhaps that is sufficient?\n+\n+            JCTree meth = TreeInfo.skipParens(tree.meth);\n+            switch (meth.getTag()) {\n+                case IDENT: {\n+                    JCIdent access = (JCIdent) meth;\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    if (!sym.isStatic()) {\n+                        args.add(thisValue());\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, symbolSiteType(sym));\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess access = (JCFieldAccess) meth;\n+\n+                    Type qualifierTarget = qualifierTarget(access);\n+                    Value receiver = toValue(access.selected, qualifierTarget);\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    if (!sym.isStatic()) {\n+                        args.add(receiver);\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n+                            access.selected.type : qualifierTarget);\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                default:\n+                    unsupported(meth);\n+            }\n+        }\n+\n+        List<Value> scanMethodArguments(List<JCExpression> args, Type methodType, Type varargsElement) {\n+            ListBuffer<Value> argValues = new ListBuffer<>();\n+            com.sun.tools.javac.util.List<Type> targetTypes = methodType.getParameterTypes();\n+            if (varargsElement != null) {\n+                targetTypes = targetTypes.reverse().tail;\n+                for (int i = 0 ; i < args.size() - (methodType.getParameterTypes().size() - 1) ; i++) {\n+                    targetTypes = targetTypes.prepend(varargsElement);\n+                }\n+                targetTypes = targetTypes.reverse();\n+            }\n+\n+            for (JCTree.JCExpression arg : args) {\n+                argValues.add(toValue(arg, targetTypes.head));\n+                targetTypes = targetTypes.tail;\n+            }\n+            return argValues.toList();\n+        }\n+\n+        @Override\n+        public void visitReference(JCTree.JCMemberReference tree) {\n+            MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+            JCVariableDecl recv = memberReferenceToLambda.receiverVar();\n+            if (recv != null) {\n+                scan(recv);\n+            }\n+            scan(memberReferenceToLambda.lambda());\n+        }\n+\n+        Type qualifierTarget(JCFieldAccess tree) {\n+            Type selectedType = types.skipTypeVars(tree.selected.type, true);\n+            return selectedType.isCompound() ?\n+                    tree.sym.owner.type :\n+                    Type.noType;\n+        }\n+\n+        @Override\n+        public void visitTypeCast(JCTree.JCTypeCast tree) {\n+            Value v = toValue(tree.expr);\n+\n+            Type expressionType = tree.expr.type;\n+            Type type = tree.type;\n+            if (expressionType.isPrimitive() && type.isPrimitive()) {\n+                if (expressionType.equals(type)) {\n+                    \/\/ Redundant cast\n+                    result = v;\n+                } else {\n+                    result = append(CoreOps.conv(typeToTypeElement(type), v));\n+                }\n+            } else if (expressionType.isPrimitive() || type.isPrimitive()) {\n+                result = convert(v, tree.type);\n+            } else if (!expressionType.hasTag(BOT) &&\n+                    types.isAssignable(expressionType, type)) {\n+                \/\/ Redundant cast\n+                result = v;\n+            } else {\n+                \/\/ Reference cast\n+                JavaType jt = typeToTypeElement(types.erasure(type));\n+                result = append(CoreOps.cast(typeToTypeElement(type), jt, v));\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeTest(JCTree.JCInstanceOf tree) {\n+            Value target = toValue(tree.expr);\n+\n+            if (tree.pattern.getTag() != Tag.IDENT) {\n+                result = scanPattern(tree.getPattern(), target);\n+            } else {\n+                result = append(CoreOps.instanceOf(typeToTypeElement(tree.pattern.type), target));\n+            }\n+        }\n+\n+        Value scanPattern(JCTree.JCPattern pattern, Value target) {\n+            \/\/ Type of pattern\n+            JavaType patternType;\n+            if (pattern instanceof JCTree.JCBindingPattern p) {\n+                patternType = ExtendedOps.Pattern.bindingType(typeToTypeElement(p.type));\n+            } else if (pattern instanceof JCTree.JCRecordPattern p) {\n+                patternType = ExtendedOps.Pattern.recordType(typeToTypeElement(p.record.type));\n+            } else {\n+                throw unsupported(pattern);\n+            }\n+\n+            \/\/ Push pattern body\n+            pushBody(pattern, FunctionType.functionType(patternType));\n+\n+            \/\/ @@@ Assumes just pattern nodes, likely will change when method patterns are supported\n+            \/\/     that have expressions for any arguments (which perhaps in turn may have pattern expressions)\n+            List<JCVariableDecl> variables = new ArrayList<>();\n+            class PatternScanner extends FilterScanner {\n+\n+                private Value result;\n+\n+                public PatternScanner() {\n+                    super(Set.of(Tag.BINDINGPATTERN, Tag.RECORDPATTERN));\n+                }\n+\n+                @Override\n+                public void visitBindingPattern(JCTree.JCBindingPattern binding) {\n+                    JCVariableDecl var = binding.var;\n+                    variables.add(var);\n+\n+                    result = append(ExtendedOps.bindingPattern(typeToTypeElement(var.type), var.name.toString()));\n+                }\n+\n+                @Override\n+                public void visitRecordPattern(JCTree.JCRecordPattern record) {\n+                    \/\/ @@@ Is always Identifier to record?\n+                    \/\/ scan(record.deconstructor);\n+\n+                    List<Value> nestedValues = new ArrayList<>();\n+                    for (JCTree.JCPattern jcPattern : record.nested) {\n+                        nestedValues.add(toValue(jcPattern));\n+                    }\n+\n+                    result = append(ExtendedOps.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n+                }\n+\n+                Value toValue(JCTree tree) {\n+                    result = null;\n+                    scan(tree);\n+                    return result;\n+                }\n+            }\n+            \/\/ Scan pattern\n+            Value patternValue = new PatternScanner().toValue(pattern);\n+            append(CoreOps._yield(patternValue));\n+            Body.Builder patternBody = stack.body;\n+\n+            \/\/ Pop body\n+            popBody();\n+\n+            \/\/ Find nearest ancestor body stack element associated with a statement tree\n+            \/\/ @@@ Strengthen check of tree?\n+            BodyStack _variablesStack = stack;\n+            while (!(_variablesStack.tree instanceof JCTree.JCStatement)) {\n+                _variablesStack = _variablesStack.parent;\n+            }\n+            BodyStack variablesStack = _variablesStack;\n+\n+            \/\/ Create pattern var ops for pattern variables using the\n+            \/\/ builder associated with the nearest statement tree\n+            for (JCVariableDecl jcVar : variables) {\n+                Value init = variablesStack.block.op(defaultValue(jcVar.type));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n+                variablesStack.localToOp.put(jcVar.sym, op);\n+            }\n+\n+            \/\/ Create pattern descriptor\n+            List<JavaType> patternDescParams = variables.stream().map(var -> typeToTypeElement(var.type)).toList();\n+            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+\n+            \/\/ Create the match body, assigning pattern values to pattern variables\n+            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), matchFuncType);\n+            Block.Builder matchBuilder = matchBody.entryBlock();\n+            for (int i = 0; i < variables.size(); i++) {\n+                Value v = matchBuilder.parameters().get(i);\n+                Value var = variablesStack.localToOp.get(variables.get(i).sym);\n+                matchBuilder.op(CoreOps.varStore(var, v));\n+            }\n+            matchBuilder.op(CoreOps._yield());\n+\n+            \/\/ Create the match operation\n+            return append(ExtendedOps.match(target, patternBody, matchBody));\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCTree.JCNewClass tree) {\n+            \/\/ @@@ Support anonymous classes\n+            if (tree.def != null) {\n+                throw unsupported(tree);\n+            }\n+\n+            Type type = tree.type;\n+            Type outer = type.getEnclosingType();\n+            List<Value> args = new ArrayList<>();\n+            if (!outer.hasTag(TypeTag.NONE)) {\n+                \/\/ Obtain outer value for inner class, and add as first argument\n+                JCTree.JCExpression encl = tree.encl;\n+                Value outerInstance;\n+                if (encl == null) {\n+                    outerInstance = thisValue();\n+                } else {\n+                    outerInstance = toValue(tree.encl);\n+                }\n+                args.add(outerInstance);\n+            }\n+\n+            \/\/ Create erased method type reference for constructor, where\n+            \/\/ the return type declares the class to instantiate\n+            \/\/ @@@ require symbol site type?\n+            MethodRef methodRef = symbolToErasedMethodRef(tree.constructor);\n+            FunctionType constructorType = FunctionType.functionType(\n+                    symbolToErasedDesc(tree.constructor.owner),\n+                    methodRef.type().parameterTypes());\n+\n+            args.addAll(scanMethodArguments(tree.args, tree.constructorType, tree.varargsElement));\n+\n+            result = append(CoreOps._new(typeToTypeElement(type), constructorType, args));\n+        }\n+\n+        @Override\n+        public void visitNewArray(JCTree.JCNewArray tree) {\n+            if (tree.elems != null) {\n+                int length = tree.elems.size();\n+                Op.Result a = append(CoreOps.newArray(\n+                        typeToTypeElement(tree.type),\n+                        append(CoreOps.constant(JavaType.INT, length))));\n+                int i = 0;\n+                for (JCExpression elem : tree.elems) {\n+                    Value element = toValue(elem, types.elemtype(tree.type));\n+                    append(CoreOps.arrayStoreOp(\n+                            a,\n+                            append(CoreOps.constant(JavaType.INT, i)),\n+                            element));\n+                    i++;\n+                }\n+\n+                result = a;\n+            } else {\n+                List<Value> indexes = new ArrayList<>();\n+                for (JCTree.JCExpression dim : tree.dims) {\n+                    indexes.add(toValue(dim));\n+                }\n+\n+                JavaType arrayType = typeToTypeElement(tree.type);\n+                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                        indexes.stream().map(Value::type).toList());\n+                result = append(CoreOps._new(arrayType, constructorType, indexes));\n+            }\n+        }\n+\n+        @Override\n+        public void visitLambda(JCTree.JCLambda tree) {\n+            FunctionalExpressionKind kind = functionalKind(tree);\n+            final FunctionType lambdaType = switch (kind) {\n+                case QUOTED_STRUCTURAL -> typeToFunctionType(tree.target);\n+                default -> typeToFunctionType(types.findDescriptorType(tree.target));\n+            };\n+\n+            \/\/ Push quoted body\n+            \/\/ We can either be explicitly quoted or a structural quoted expression\n+            \/\/ within some larger reflected code\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                pushBody(tree.body, FunctionType.VOID);\n+            }\n+\n+            \/\/ Push lambda body\n+            pushBody(tree.body, lambdaType);\n+\n+            \/\/ Map lambda parameters to varOp values\n+            for (int i = 0; i < tree.params.size(); i++) {\n+                JCVariableDecl p = tree.params.get(i);\n+                Op.Result paramOp = append(CoreOps.var(\n+                        p.name.toString(),\n+                        stack.block.parameters().get(i)));\n+                stack.localToOp.put(p.sym, paramOp);\n+            }\n+\n+            \/\/ Scan the lambda body\n+            if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION) {\n+                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                if (!tree.body.type.hasTag(TypeTag.VOID)) {\n+                    append(CoreOps._return(exprVal));\n+                } else {\n+                    appendTerminating(CoreOps::_return);\n+                }\n+            } else {\n+                Type prevBodyTarget = bodyTarget;\n+                try {\n+                    bodyTarget = tree.getDescriptorType(types).getReturnType();\n+                    toValue(tree.body);\n+                    \/\/ @@@ Check if unreachable\n+                    appendTerminating(CoreOps::_return);\n+                } finally {\n+                    bodyTarget = prevBodyTarget;\n+                }\n+            }\n+\n+            Op lambdaOp = switch (kind) {\n+                case QUOTED_STRUCTURAL -> {\n+                    yield CoreOps.closure(stack.body);\n+                }\n+                case QUOTABLE, NOT_QUOTED -> {\n+                    \/\/ Get the functional interface type\n+                    JavaType fiType = typeToTypeElement(tree.target);\n+                    \/\/ build functional lambda\n+                    yield CoreOps.lambda(fiType, stack.body);\n+                }\n+            };\n+\n+            \/\/ Pop lambda body\n+            popBody();\n+\n+            Value lambdaResult;\n+            if (isQuoted) {\n+                lambdaResult = append(lambdaOp, generateLocation(tree, true));\n+            } else {\n+                lambdaResult = append(lambdaOp);\n+            }\n+\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                append(CoreOps._yield(lambdaResult));\n+                CoreOps.QuotedOp quotedOp = CoreOps.quoted(stack.body);\n+\n+                \/\/ Pop quoted body\n+                popBody();\n+\n+                lambdaResult = append(quotedOp);\n+            }\n+\n+            result = lambdaResult;\n+        }\n+\n+        @Override\n+        public void visitIf(JCTree.JCIf tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            boolean first = true;\n+            while (tree != null) {\n+                \/\/ @@@ cond.type can be boolean or Boolean\n+                JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+                \/\/ Push if condition\n+                pushBody(cond,\n+                        FunctionType.functionType(JavaType.BOOLEAN));\n+                Value last = toValue(cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(last));\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if condition\n+                popBody();\n+\n+                \/\/ Push if body\n+                pushBody(tree.thenpart, FunctionType.VOID);\n+\n+                scan(tree.thenpart);\n+                appendTerminating(CoreOps::_yield);\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if body\n+                popBody();\n+\n+                JCTree.JCStatement elsepart = tree.elsepart;\n+                if (elsepart == null) {\n+                    tree = null;\n+                }\n+                else if (elsepart.getTag() == Tag.BLOCK) {\n+                    \/\/ Push else body\n+                    pushBody(elsepart, FunctionType.VOID);\n+\n+                    scan(elsepart);\n+                    appendTerminating(CoreOps::_yield);\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop else body\n+                    popBody();\n+\n+                    tree = null;\n+                } else if (elsepart.getTag() == Tag.IF) {\n+                    tree = (JCTree.JCIf) elsepart;\n+                }\n+                first = false;\n+            }\n+\n+            append(ExtendedOps._if(bodies));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSwitchExpression(JCTree.JCSwitchExpression tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            Type switchType = adaptBottom(tree.type);\n+            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOps._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        append(CoreOps._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOps.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOps._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ @@@ Conversion of localTarget\n+                        if (ccl.expr.type.isPrimitive()) {\n+                            localResult = append(CoreOps.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOps.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            \/\/ @@@ Conversion of localTarget\n+                            final Value labelResult;\n+                            if (ccl.expr.type.isPrimitive()) {\n+                                labelResult = append(CoreOps.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOps.invoke(\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOps._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOps.conditionalOr(clBodies));\n+                    }\n+\n+                    append(CoreOps._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, FunctionType.VOID);\n+\n+                    append(CoreOps._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        Type yieldType = adaptBottom(tree.type);\n+                        if (c.body instanceof JCExpression) {\n+                            \/\/ Yield the boolean result of the condition\n+                            Value bodyVal = toValue(c.body, yieldType);\n+                            append(CoreOps._yield(bodyVal));\n+                        } else {\n+                            \/\/ Otherwise there is a yield statement\n+                            Type prevBodyTarget = bodyTarget;\n+                            try {\n+                                bodyTarget = yieldType;\n+                                Value bodyVal = toValue(c.body);\n+                            } finally {\n+                                bodyTarget = prevBodyTarget;\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally\n+                                ? ExtendedOps::switchFallthroughOp\n+                                : CoreOps::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            result = append(ExtendedOps.switchExpression(actionType.returnType(), target, bodies));\n+        }\n+\n+        @Override\n+        public void visitYield(JCTree.JCYield tree) {\n+            Value retVal = toValue(tree.value, bodyTarget);\n+            if (retVal == null) {\n+                result = append(ExtendedOps.java_yield());\n+            } else {\n+                result = append(ExtendedOps.java_yield(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            \/\/ @@@ cond.type can be boolean or Boolean\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            append(ExtendedOps._while(condition, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            \/\/ @@@ cond.type can be boolean or Boolean\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            append(ExtendedOps.doWhile(body, condition));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+            \/\/ Push expression\n+            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            Value last = toValue(tree.expr);\n+            \/\/ Yield the Iterable result of the expression\n+            append(CoreOps._yield(last));\n+            Body.Builder expression = stack.body;\n+\n+            \/\/ Pop expression\n+            popBody();\n+\n+            JCVariableDecl var = tree.getVariable();\n+            JavaType eType = typeToTypeElement(var.type);\n+            VarType varEType = VarType.varType(typeToTypeElement(var.type));\n+\n+            \/\/ Push init\n+            \/\/ @@@ When lhs assignment is a pattern we embed the pattern match into the init body and\n+            \/\/ return the bound variables\n+            pushBody(var, FunctionType.functionType(varEType, eType));\n+            Op.Result varEResult = append(CoreOps.var(var.name.toString(), stack.block.parameters().get(0)));\n+            append(CoreOps._yield(varEResult));\n+            Body.Builder init = stack.body;\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            stack.localToOp.put(var.sym, stack.block.parameters().get(0));\n+\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+            \/\/ Pop body\n+            popBody();\n+\n+            append(ExtendedOps.enhancedFor(expression, init, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForLoop(JCTree.JCForLoop tree) {\n+            class VarDefScanner extends FilterScanner {\n+                final List<JCVariableDecl> decls;\n+\n+                public VarDefScanner() {\n+                    super(Set.of(Tag.VARDEF));\n+                    this.decls = new ArrayList<>();\n+                }\n+\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    decls.add(tree);\n+                }\n+\n+                void mapVarsToBlockArguments() {\n+                    for (int i = 0; i < decls.size(); i++) {\n+                        stack.localToOp.put(decls.get(i).sym, stack.block.parameters().get(i));\n+                    }\n+                }\n+\n+                List<VarType> varTypes() {\n+                    return decls.stream()\n+                            .map(t -> VarType.varType(typeToTypeElement(t.type)))\n+                            .toList();\n+                }\n+\n+                List<Value> varValues() {\n+                    return decls.stream()\n+                            .map(t -> stack.localToOp.get(t.sym))\n+                            .toList();\n+                }\n+            }\n+\n+            \/\/ Scan local variable declarations\n+            VarDefScanner vds = new VarDefScanner();\n+            vds.scan(tree.init);\n+            List<VarType> varTypes = vds.varTypes();\n+\n+            \/\/ Push init\n+            if (varTypes.size() > 1) {\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                scan(tree.init);\n+\n+                \/\/ Capture all local variable declarations in tuple\n+                append(CoreOps._yield(append(CoreOps.tuple(vds.varValues()))));\n+            } else if (varTypes.size() == 1) {\n+                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                scan(tree.init);\n+\n+                append(CoreOps._yield(vds.varValues().get(0)));\n+            } else {\n+                pushBody(null, FunctionType.VOID);\n+                scan(tree.init);\n+\n+                append(CoreOps._yield());\n+            }\n+            Body.Builder init = stack.body;\n+\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push cond\n+            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            if (tree.cond != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                Value last = toValue(tree.cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(last));\n+            } else {\n+                append(CoreOps._yield(append(CoreOps.constant(JavaType.BOOLEAN, true))));\n+            }\n+            Body.Builder cond = stack.body;\n+\n+            \/\/ Pop cond\n+            popBody();\n+\n+            \/\/ Push update\n+            \/\/ @@@ tree.step is a List<JCStatement>\n+            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (!tree.step.isEmpty()) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.step);\n+            }\n+            append(CoreOps._yield());\n+            Body.Builder update = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (tree.body != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.body);\n+            }\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            append(ExtendedOps._for(init, cond, update, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitConditional(JCTree.JCConditional tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            JCTree.JCExpression truepart = TreeInfo.skipParens(tree.truepart);\n+\n+            Type condType = adaptBottom(tree.type);\n+\n+            \/\/ Push true body\n+            pushBody(truepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value trueVal = toValue(truepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOps._yield(trueVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop true body\n+            popBody();\n+\n+            JCTree.JCExpression falsepart = TreeInfo.skipParens(tree.falsepart);\n+\n+            \/\/ Push false body\n+            pushBody(falsepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value falseVal = toValue(falsepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOps._yield(falseVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop false body\n+            popBody();\n+\n+            result = append(ExtendedOps.conditionalExpression(typeToTypeElement(condType), bodies));\n+        }\n+\n+        private Type condType(JCExpression tree, Type type) {\n+            if (type.hasTag(BOT)) {\n+                return adaptBottom(tree.type);\n+            } else {\n+                return type;\n+            }\n+        }\n+\n+        private Type adaptBottom(Type type) {\n+            return type.hasTag(BOT) ?\n+                    (pt.hasTag(NONE) ? syms.objectType : pt) :\n+                    type;\n+        }\n+\n+        @Override\n+        public void visitAssert(JCAssert tree) {\n+            \/\/ assert <cond:body1> [detail:body2]\n+\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            if (tree.detail != null) {\n+                JCTree.JCExpression detail = TreeInfo.skipParens(tree.detail);\n+\n+                pushBody(detail,\n+                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                Value detailVal = toValue(detail);\n+\n+                append(CoreOps._yield(detailVal));\n+                bodies.add(stack.body);\n+\n+                \/\/Pop detail\n+                popBody();\n+            }\n+\n+            result = append(CoreOps._assert(bodies));\n+\n+        }\n+\n+        @Override\n+        public void visitBlock(JCTree.JCBlock tree) {\n+            if (stack.tree == tree) {\n+                \/\/ Block is associated with the visit of a parent structure\n+                scan(tree.stats);\n+            } else {\n+                \/\/ Otherwise, independent block structure\n+                \/\/ @@@ Support synchronized blocks\n+                \/\/ Push block\n+                pushBody(tree, FunctionType.VOID);\n+                scan(tree.stats);\n+                appendTerminating(CoreOps::_yield);\n+                Body.Builder body = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+\n+                append(ExtendedOps.block(body));\n+            }\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n+            \/\/ Push block\n+            pushBody(tree, FunctionType.VOID);\n+            \/\/ Create constant for label\n+            String labelName = tree.label.toString();\n+            Op.Result label = append(CoreOps.constant(JavaType.J_L_STRING, labelName));\n+            \/\/ Set label on body stack\n+            stack.setLabel(labelName, label);\n+            scan(tree.body);\n+            appendTerminating(CoreOps::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            result = append(ExtendedOps.labeled(body));\n+        }\n+\n+        @Override\n+        public void visitTry(JCTree.JCTry tree) {\n+            List<JCVariableDecl> rVariableDecls = new ArrayList<>();\n+            List<TypeElement> rTypes = new ArrayList<>();\n+            Body.Builder resources;\n+            if (!tree.resources.isEmpty()) {\n+                \/\/ Resources body returns a tuple that contains the resource variables\/values\n+                \/\/ in order of declaration\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCVariableDecl vdecl) {\n+                        rVariableDecls.add(vdecl);\n+                        rTypes.add(VarType.varType(typeToTypeElement(vdecl.type)));\n+                    } else {\n+                        rTypes.add(typeToTypeElement(resource.type));\n+                    }\n+                }\n+\n+                \/\/ Push resources body\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+\n+                List<Value> rValues = new ArrayList<>();\n+                for (JCTree resource : tree.resources) {\n+                    rValues.add(toValue(resource));\n+                }\n+\n+                append(CoreOps._yield(append(CoreOps.tuple(rValues))));\n+                resources = stack.body;\n+\n+                \/\/ Pop resources body\n+                popBody();\n+            } else {\n+                resources = null;\n+            }\n+\n+            \/\/ Push body\n+            \/\/ Try body accepts the resource variables (in order of declaration).\n+            List<VarType> rVarTypes = rTypes.stream().<VarType>mapMulti((t, c) -> {\n+                if (t instanceof VarType vt) {\n+                    c.accept(vt);\n+                }\n+            }).toList();\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            for (int i = 0; i < rVariableDecls.size(); i++) {\n+                stack.localToOp.put(rVariableDecls.get(i).sym, stack.block.parameters().get(i));\n+            }\n+            scan(tree.body);\n+            appendTerminating(CoreOps::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            List<Body.Builder> catchers = new ArrayList<>();\n+            for (JCTree.JCCatch catcher : tree.catchers) {\n+                \/\/ Push body\n+                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                Op.Result exVariable = append(CoreOps.var(\n+                        catcher.param.name.toString(),\n+                        stack.block.parameters().get(0)));\n+                stack.localToOp.put(catcher.param.sym, exVariable);\n+                scan(catcher.body);\n+                appendTerminating(CoreOps::_yield);\n+                catchers.add(stack.body);\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+\n+            Body.Builder finalizer;\n+            if (tree.finalizer != null) {\n+                \/\/ Push body\n+                pushBody(tree.finalizer, FunctionType.VOID);\n+                scan(tree.finalizer);\n+                appendTerminating(CoreOps::_yield);\n+                finalizer = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+            else {\n+                finalizer = null;\n+            }\n+\n+            result = append(ExtendedOps._try(resources, body, catchers, finalizer));\n+        }\n+\n+        @Override\n+        public void visitUnary(JCTree.JCUnary tree) {\n+            Tag tag = tree.getTag();\n+            switch (tag) {\n+                case POSTINC, POSTDEC, PREINC, PREDEC -> {\n+                    \/\/ Capture applying rhs and operation\n+                    Function<Value, Value> scanRhs = (lhs) -> {\n+                        Value one = append(numericOneValue(tree.type));\n+                        Value unboxedLhs = unboxIfNeeded(lhs);\n+\n+                        Value unboxedLhsPlusOne = switch (tree.getTag()) {\n+                            \/\/ Arithmetic operations\n+                            case POSTINC, PREINC -> append(CoreOps.add(unboxedLhs, one));\n+                            case POSTDEC, PREDEC -> append(CoreOps.sub(unboxedLhs, one));\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        Value lhsPlusOne = convert(unboxedLhsPlusOne, tree.type);\n+\n+                        \/\/ Assign expression result\n+                        result =  switch (tree.getTag()) {\n+                            case POSTINC, POSTDEC -> lhs;\n+                            case PREINC, PREDEC -> lhsPlusOne;\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        return lhsPlusOne;\n+                    };\n+\n+                    applyCompoundAssign(tree.arg, scanRhs);\n+                }\n+                case NEG -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOps.neg(rhs));\n+                }\n+                case NOT -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOps.not(rhs));\n+                }\n+                default -> throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitBinary(JCBinary tree) {\n+            Tag tag = tree.getTag();\n+            if (tag == Tag.AND || tag == Tag.OR) {\n+                \/\/ Logical operations\n+                \/\/ @@@ Flatten nested sequences\n+\n+                \/\/ Push lhs\n+                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value lhs = toValue(tree.lhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(lhs));\n+                Body.Builder bodyLhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                \/\/ Push rhs\n+                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value rhs = toValue(tree.rhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(rhs));\n+                Body.Builder bodyRhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                List<Body.Builder> bodies = List.of(bodyLhs, bodyRhs);\n+                result = append(tag == Tag.AND\n+                        ? ExtendedOps.conditionalAnd(bodies)\n+                        : ExtendedOps.conditionalOr(bodies));\n+            } else if (tag == Tag.PLUS && tree.operator.opcode == ByteCodes.string_add) {\n+                \/\/Ignore the operator and query both subexpressions for their type with concats\n+                Type lhsType = tree.lhs.type;\n+                Type rhsType = tree.rhs.type;\n+\n+                Value lhs = toValue(tree.lhs, lhsType);\n+                Value rhs = toValue(tree.rhs, rhsType);\n+\n+                result = append(CoreOps.concat(lhs, rhs));\n+            }\n+            else {\n+                Type opType = tree.operator.type.getParameterTypes().getFirst();\n+                \/\/ @@@ potentially handle shift input conversion like other binary ops\n+                boolean isShift = tag == Tag.SL || tag == Tag.SR || tag == Tag.USR;\n+                Value lhs = toValue(tree.lhs, opType);\n+                Value rhs = toValue(tree.rhs, isShift ? tree.operator.type.getParameterTypes().getLast() : opType);\n+\n+                result = switch (tag) {\n+                    \/\/ Arithmetic operations\n+                    case PLUS -> append(CoreOps.add(lhs, rhs));\n+                    case MINUS -> append(CoreOps.sub(lhs, rhs));\n+                    case MUL -> append(CoreOps.mul(lhs, rhs));\n+                    case DIV -> append(CoreOps.div(lhs, rhs));\n+                    case MOD -> append(CoreOps.mod(lhs, rhs));\n+\n+                    \/\/ Test operations\n+                    case EQ -> append(CoreOps.eq(lhs, rhs));\n+                    case NE -> append(CoreOps.neq(lhs, rhs));\n+                    \/\/\n+                    case LT -> append(CoreOps.lt(lhs, rhs));\n+                    case LE -> append(CoreOps.le(lhs, rhs));\n+                    case GT -> append(CoreOps.gt(lhs, rhs));\n+                    case GE -> append(CoreOps.ge(lhs, rhs));\n+\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR -> append(CoreOps.or(lhs, rhs));\n+                    case BITAND -> append(CoreOps.and(lhs, rhs));\n+                    case BITXOR -> append(CoreOps.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL -> append(CoreOps.lshl(lhs, rhs));\n+                    case SR -> append(CoreOps.ashr(lhs, rhs));\n+                    case USR -> append(CoreOps.lshr(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void visitLiteral(JCLiteral tree) {\n+            Object value = switch (tree.type.getTag()) {\n+                case BOOLEAN -> tree.value instanceof Integer i && i == 1;\n+                case CHAR -> (char) (int) tree.value;\n+                default -> tree.value;\n+            };\n+            Type constantType = adaptBottom(tree.type);\n+            result = append(CoreOps.constant(typeToTypeElement(constantType), value));\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            Value retVal = toValue(tree.expr, bodyTarget);\n+            if (retVal == null) {\n+                result = append(CoreOps._return());\n+            } else {\n+                result = append(CoreOps._return(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitThrow(JCTree.JCThrow tree) {\n+            Value throwVal = toValue(tree.expr);\n+            result = append(CoreOps._throw(throwVal));\n+        }\n+\n+        @Override\n+        public void visitBreak(JCTree.JCBreak tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOps._break(label));\n+        }\n+\n+        @Override\n+        public void visitContinue(JCTree.JCContinue tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOps._continue(label));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ do nothing\n+        }\n+\n+\n+        UnsupportedASTException unsupported(JCTree tree) {\n+            return new UnsupportedASTException(tree);\n+        }\n+\n+        CoreOps.FuncOp scanMethod() {\n+            scan(body);\n+            \/\/ @@@ Check if unreachable\n+            appendTerminating(CoreOps::_return);\n+            CoreOps.FuncOp func = CoreOps.func(name.toString(), stack.body);\n+            func.setLocation(generateLocation(currentNode, true));\n+            return func;\n+        }\n+\n+        CoreOps.FuncOp scanLambda() {\n+            scan(body);\n+            append(CoreOps._return(result));\n+            return CoreOps.func(name.toString(), stack.body);\n+        }\n+\n+        JavaType symbolToErasedDesc(Symbol s) {\n+            return typeToTypeElement(s.erasure(types));\n+        }\n+\n+        JavaType typeToTypeElement(Type t) {\n+            t = normalizeType(t);\n+            return switch (t.getTag()) {\n+                case VOID -> JavaType.VOID;\n+                case CHAR -> JavaType.CHAR;\n+                case BOOLEAN -> JavaType.BOOLEAN;\n+                case BYTE -> JavaType.BYTE;\n+                case SHORT -> JavaType.SHORT;\n+                case INT -> JavaType.INT;\n+                case FLOAT -> JavaType.FLOAT;\n+                case LONG -> JavaType.LONG;\n+                case DOUBLE -> JavaType.DOUBLE;\n+                case ARRAY -> {\n+                    Type et = ((ArrayType)t).elemtype;\n+                    yield JavaType.array(typeToTypeElement(et));\n+                }\n+                case WILDCARD -> {\n+                    Type.WildcardType wt = (Type.WildcardType)t;\n+                    yield wt.isUnbound() ?\n+                            JavaType.wildcard() :\n+                            JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n+                }\n+                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound())) :\n+                        JavaType.typeVarRef(t.tsym.name.toString(),\n+                                (jdk.internal.java.lang.reflect.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound()));\n+                case CLASS -> {\n+                    Assert.check(!t.isIntersection() && !t.isUnion());\n+                    \/\/ @@@ Need to clean this up, probably does not work inner generic classes\n+                    \/\/ whose enclosing class is also generic\n+                    List<JavaType> typeArguments;\n+                    if (t.getTypeArguments().nonEmpty()) {\n+                        typeArguments = new ArrayList<>();\n+                        for (Type ta : t.getTypeArguments()) {\n+                            typeArguments.add(typeToTypeElement(ta));\n+                        }\n+                    } else {\n+                        typeArguments = List.of();\n+                    }\n+\n+                    \/\/ Use flat name to ensure demarcation of nested classes\n+                    yield JavaType.type(JavaType.ofNominalDescriptor(ClassDesc.of(t.tsym.flatName().toString())), typeArguments);\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n+                }\n+            };\n+        }\n+\n+        Type symbolSiteType(Symbol s) {\n+            boolean isMember = s.owner == syms.predefClass ||\n+                    s.isMemberOf(currentClassSym, types);\n+            return isMember ? currentClassSym.type : s.owner.type;\n+        }\n+\n+        FieldRef symbolToFieldRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        FieldRef symbolToErasedFieldRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return FieldRef.field(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedMethodRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return MethodRef.method(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType.getReturnType()),\n+                    erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        FunctionType symbolToFunctionType(Symbol s) {\n+            return typeToFunctionType(s.type);\n+        }\n+\n+        FunctionType typeToFunctionType(Type t) {\n+            return FunctionType.functionType(\n+                    typeToTypeElement(t.getReturnType()),\n+                    t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n+            TypeElement recordType = typeToTypeElement(s.type);\n+            List<RecordTypeRef.ComponentRef> components = s.getRecordComponents().stream()\n+                    .map(rc -> new RecordTypeRef.ComponentRef(typeToTypeElement(rc.type), rc.name.toString()))\n+                    .toList();\n+            return RecordTypeRef.recordType(recordType, components);\n+        }\n+\n+        Op defaultValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE -> CoreOps.constant(typeToTypeElement(t), (byte)0);\n+                case CHAR -> CoreOps.constant(typeToTypeElement(t), (char)0);\n+                case BOOLEAN -> CoreOps.constant(typeToTypeElement(t), false);\n+                case SHORT -> CoreOps.constant(typeToTypeElement(t), (short)0);\n+                case INT -> CoreOps.constant(typeToTypeElement(t), 0);\n+                case FLOAT -> CoreOps.constant(typeToTypeElement(t), 0f);\n+                case LONG -> CoreOps.constant(typeToTypeElement(t), 0L);\n+                case DOUBLE -> CoreOps.constant(typeToTypeElement(t), 0d);\n+                default -> CoreOps.constant(typeToTypeElement(t), null);\n+            };\n+        }\n+\n+        Op numericOneValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE -> CoreOps.constant(typeToTypeElement(t), (byte)1);\n+                case CHAR -> CoreOps.constant(typeToTypeElement(t), (char)1);\n+                case SHORT -> CoreOps.constant(typeToTypeElement(t), (short)1);\n+                case INT -> CoreOps.constant(typeToTypeElement(t), 1);\n+                case FLOAT -> CoreOps.constant(typeToTypeElement(t), 1f);\n+                case LONG -> CoreOps.constant(typeToTypeElement(t), 1L);\n+                case DOUBLE -> CoreOps.constant(typeToTypeElement(t), 1d);\n+                case CLASS -> numericOneValue(types.unboxedType(t));\n+                default -> throw new UnsupportedOperationException(t.toString());\n+            };\n+        }\n+\n+        Type normalizeType(Type t) {\n+            Assert.check(!t.hasTag(METHOD));\n+            return types.upward(t, false, types.captures(t));\n+        }\n+\n+        Type typeElementToType(TypeElement desc) {\n+            return primitiveAndBoxTypeMap().getOrDefault(desc, Type.noType);\n+        }\n+\n+        public boolean checkDenotableInTypeDesc(Type t) {\n+            return denotableChecker.visit(t, null);\n+        }\n+        \/\/ where\n+\n+        \/**\n+         * A type visitor that descends into the given type looking for types that are non-denotable\n+         * in code model types. Examples of such types are: type-variables (regular or captured),\n+         * wildcard type argument, intersection types, union types. The visit methods return false\n+         * as soon as a non-denotable type is encountered and true otherwise. (see {@link Check#checkDenotable(Type)}.\n+         *\/\n+        private static final Types.SimpleVisitor<Boolean, Void> denotableChecker = new Types.SimpleVisitor<>() {\n+            @Override\n+            public Boolean visitType(Type t, Void s) {\n+                return true;\n+            }\n+            @Override\n+            public Boolean visitClassType(ClassType t, Void s) {\n+                if (t.isUnion() || t.isIntersection()) {\n+                    \/\/ union and intersections cannot be denoted in code model types\n+                    return false;\n+                }\n+                \/\/ @@@ What about enclosing types?\n+                for (Type targ : t.getTypeArguments()) {\n+                    \/\/ propagate into type arguments\n+                    if (!visit(targ, s)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Void s) {\n+                \/\/ type variables cannot be denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Void s) {\n+                \/\/ wildcards cannot de denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Void s) {\n+                \/\/ propagate into element type\n+                return visit(t.elemtype, s);\n+            }\n+        };\n+\n+    }\n+\n+    \/**\n+     * An exception thrown when an unsupported AST node is found when building a method IR.\n+     *\/\n+    static class UnsupportedASTException extends RuntimeException {\n+\n+        private static final long serialVersionUID = 0;\n+        transient final JCTree tree;\n+\n+        public UnsupportedASTException(JCTree tree) {\n+            this.tree = tree;\n+        }\n+    }\n+\n+    enum FunctionalExpressionKind {\n+        QUOTED_STRUCTURAL(true), \/\/ this is transitional\n+        QUOTABLE(true),\n+        NOT_QUOTED(false);\n+\n+        final boolean isQuoted;\n+\n+        FunctionalExpressionKind(boolean isQuoted) {\n+            this.isQuoted = isQuoted;\n+        }\n+    }\n+\n+    FunctionalExpressionKind functionalKind(JCFunctionalExpression functionalExpression) {\n+        if (functionalExpression.target.hasTag(TypeTag.METHOD)) {\n+            return FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+        } else if (types.asSuper(functionalExpression.target, syms.quotableType.tsym) != null) {\n+            return FunctionalExpressionKind.QUOTABLE;\n+        } else {\n+            return FunctionalExpressionKind.NOT_QUOTED;\n+        }\n+    }\n+\n+    \/*\n+     * Converts a method reference which cannot be used directly into a lambda.\n+     * This code has been derived from LambdaToMethod::MemberReferenceToLambda. The main\n+     * difference is that, while that code concerns with translation strategy, boxing\n+     * conversion and type erasure, this version does not and, as such, can remain\n+     * at a higher level. Note that this code needs to create a synthetic variable\n+     * declaration in case of a bounded method reference whose receiver expression\n+     * is other than 'this'\/'super' (this is done to prevent the receiver expression\n+     * from being computed twice).\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final Symbol owner;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private JCVariableDecl receiverVar = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree, Symbol currentClass) {\n+            this.tree = tree;\n+            this.owner = new MethodSymbol(0, names.lambda, tree.target, currentClass);\n+            if (tree.kind == ReferenceKind.BOUND && !isThisOrSuper(tree.getQualifierExpression())) {\n+                \/\/ true bound method reference, hoist receiver expression out\n+                Type recvType = types.asSuper(tree.getQualifierExpression().type, tree.sym.owner);\n+                VarSymbol vsym = makeSyntheticVar(\"rec$\", recvType);\n+                receiverVar = make.VarDef(vsym, tree.getQualifierExpression());\n+            }\n+        }\n+\n+        JCVariableDecl receiverVar() {\n+            return receiverVar;\n+        }\n+\n+        JCLambda lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                return slam;\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            com.sun.tools.javac.util.List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+            VarSymbol receiverParam = null;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    if (receiverVar != null) {\n+                        receiverParam = receiverVar.sym;\n+                    }\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    receiverParam = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+            }\n+            for (int i = 0; descPTypes.nonEmpty(); ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                descPTypes = descPTypes.tail;\n+            }\n+\n+            return receiverParam;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol receiverParam) {\n+            JCExpression qualifier = receiverParam != null ?\n+                    make.at(tree.pos).Ident(receiverParam) :\n+                    tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCMethodInvocation apply = make.Apply(com.sun.tools.javac.util.List.nil(), select, args.toList()).\n+                    setType(tree.referentType.getReturnType());\n+\n+            apply.varargsElement = tree.varargsElement;\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            Type expectedType = tree.referentType.getReturnType().hasTag(TypeTag.VOID) ?\n+                    tree.expr.type : tree.referentType.getReturnType();\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(expectedType)),\n+                        com.sun.tools.javac.util.List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCExpression newType = make.Type(types.erasure(expectedType));\n+                if (expectedType.tsym.type.getTypeArguments().nonEmpty()) {\n+                    newType = make.TypeApply(newType, com.sun.tools.javac.util.List.nil());\n+                }\n+                JCNewClass newClass = make.NewClass(null,\n+                        com.sun.tools.javac.util.List.nil(),\n+                        newType,\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.referentType;\n+                newClass.type = expectedType;\n+                newClass.varargsElement = tree.varargsElement;\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol makeSyntheticVar(String name, Type type) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), type, owner);\n+            vsym.pos = tree.pos;\n+            return vsym;\n+        }\n+\n+        private VarSymbol addParameter(String name, Type type, boolean genArg) {\n+            VarSymbol vsym = makeSyntheticVar(name, type);\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+\n+        boolean isThisOrSuper(JCExpression expression) {\n+            return TreeInfo.isThisQualifier(expression) || TreeInfo.isSuperQualifier(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":2625,"deletions":0,"binary":false,"changes":2625,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1612,0 +1612,4 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                env.tree = ReflectMethods.instance(context).translateTopLevelClass(env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1401,0 +1401,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4087,0 +4095,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.code.Type.MethodType;\n@@ -756,1 +757,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -765,0 +767,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public CodeReflectionInfo codeReflectionInfo;\n@@ -767,1 +771,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -769,0 +780,2 @@\n+\n+        public record CodeReflectionInfo(Symbol quotedField, List<JCExpression> capturedArgs) { }\n@@ -1960,1 +1973,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2546,1 +2559,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -664,1 +664,6 @@\n-   -:jdk_security\n+   -:jdk_security\n+\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n+\n","filename":"test\/jdk\/TEST.groups","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.JavaType.DOUBLE;\n+\n+public final class ForwardDifferentiation {\n+    \/\/ The function to differentiate\n+    final FuncOp fcm;\n+    \/\/ The independent variable\n+    final Block.Parameter ind;\n+    \/\/ The active set for the independent variable\n+    final Set<Value> activeSet;\n+    \/\/ The map of input value to it's (output) differentiated value\n+    final Map<Value, Value> diffValueMapping;\n+\n+    \/\/ The constant value 0.0d\n+    \/\/ Declared in the (output) function's entry block\n+    Value zero;\n+\n+    private ForwardDifferentiation(FuncOp fcm, Block.Parameter ind) {\n+        int indI = fcm.body().entryBlock().parameters().indexOf(ind);\n+        if (indI == -1) {\n+            throw new IllegalArgumentException(\"Independent argument not defined by function\");\n+        }\n+        this.fcm = fcm;\n+        this.ind = ind;\n+\n+        \/\/ Calculate the active set of dependent values for the independent value\n+        this.activeSet = ActiveSet.activeSet(fcm, ind);\n+        \/\/ A mapping of input values to their (output) differentiated values\n+        this.diffValueMapping = new HashMap<>();\n+    }\n+\n+    public static FuncOp partialDiff(FuncOp fcm, Block.Parameter ind) {\n+        return new ForwardDifferentiation(fcm, ind).partialDiff();\n+    }\n+\n+    FuncOp partialDiff() {\n+        int indI = fcm.body().entryBlock().parameters().indexOf(ind);\n+\n+        AtomicBoolean first = new AtomicBoolean(true);\n+        FuncOp dfcm = fcm.transform(String.format(\"d%s_darg%d\", fcm.funcName(), indI),\n+                (block, op) -> {\n+                    if (first.getAndSet(false)) {\n+                        \/\/ Initialize\n+                        processBlocks(block);\n+                    }\n+\n+                    \/\/ If the result of the operation is in the active set,\n+                    \/\/ then differentiate it, otherwise copy it\n+                    if (activeSet.contains(op.result())) {\n+                        Value dor = diffOp(block, op);\n+                        \/\/ Map the input result to its (output) differentiated result\n+                        \/\/ so that it can be used when differentiating subsequent operations\n+                        diffValueMapping.put(op.result(), dor);\n+                    } else {\n+                        block.apply(op);\n+                    }\n+                    return block;\n+                });\n+\n+        return dfcm;\n+    }\n+\n+    void processBlocks(Block.Builder block) {\n+        \/\/ Declare constants at start\n+        zero = block.op(constant(ind.type(), 0.0d));\n+        \/\/ The differential of ind is 1\n+        Value one = block.op(constant(ind.type(), 1.0d));\n+        diffValueMapping.put(ind, one);\n+\n+        \/\/ Append differential block parameters to blocks\n+        for (Value v : activeSet) {\n+            if (v instanceof Block.Parameter ba) {\n+                if (ba != ind) {\n+                    \/\/ Get the output block builder for the input (declaring) block\n+                    Block.Builder b = block.context().getBlock(ba.declaringBlock());\n+                    \/\/ Add a new block parameter for differential parameter\n+                    Block.Parameter dba = b.parameter(ba.type());\n+                    \/\/ Place in mapping\n+                    diffValueMapping.put(ba, dba);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    static final JavaType J_L_MATH = JavaType.type(Math.class);\n+    static final FunctionType D_D = FunctionType.functionType(DOUBLE, DOUBLE);\n+    static final MethodRef J_L_MATH_SIN = MethodRef.method(J_L_MATH, \"sin\", D_D);\n+    static final MethodRef J_L_MATH_COS = MethodRef.method(J_L_MATH, \"cos\", D_D);\n+\n+    Value diffOp(Block.Builder block, Op op) {\n+        \/\/ Switch on the op, using pattern matching\n+        return switch (op) {\n+            case CoreOps.NegOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+\n+                \/\/ -diff(expr)\n+                Value a = op.operands().get(0);\n+                Value da = diffValueMapping.getOrDefault(a, zero);\n+                yield block.op(neg(da));\n+            }\n+            case CoreOps.AddOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+\n+                \/\/ diff(l) + diff(r)\n+                Value lhs = op.operands().get(0);\n+                Value rhs = op.operands().get(1);\n+                Value dlhs = diffValueMapping.getOrDefault(lhs, zero);\n+                Value drhs = diffValueMapping.getOrDefault(rhs, zero);\n+                yield block.op(add(dlhs, drhs));\n+            }\n+            case CoreOps.MulOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+\n+                \/\/ Product rule\n+                \/\/ diff(l) * r + l * diff(r)\n+                Value lhs = op.operands().get(0);\n+                Value rhs = op.operands().get(1);\n+                Value dlhs = diffValueMapping.getOrDefault(lhs, zero);\n+                Value drhs = diffValueMapping.getOrDefault(rhs, zero);\n+                Value outputLhs = block.context().getValue(lhs);\n+                Value outputRhs = block.context().getValue(rhs);\n+                yield block.op(add(\n+                        block.op(mul(dlhs, outputRhs)),\n+                        block.op(mul(outputLhs, drhs))));\n+            }\n+            case CoreOps.ConstantOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+                \/\/ Differential of constant is zero\n+                yield zero;\n+            }\n+            case CoreOps.InvokeOp c -> {\n+                MethodRef md = c.invokeDescriptor();\n+                String operationName = null;\n+                if (md.refType().equals(J_L_MATH)) {\n+                    operationName = md.name();\n+                }\n+                \/\/ Differentiate sin(x)\n+                if (\"sin\".equals(operationName)) {\n+                    \/\/ Copy input operation\n+                    block.op(op);\n+\n+                    \/\/ Chain rule\n+                    \/\/ cos(expr) * diff(expr)\n+                    Value a = op.operands().get(0);\n+                    Value da = diffValueMapping.getOrDefault(a, zero);\n+                    Value outputA = block.context().getValue(a);\n+                    Op.Result cosx = block.op(invoke(J_L_MATH_COS, outputA));\n+                    yield block.op(mul(cosx, da));\n+                } else {\n+                    throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+                }\n+            }\n+            case CoreOps.ReturnOp _ -> {\n+                \/\/ Replace with return of differentiated value\n+                Value a = op.operands().get(0);\n+                Value da = diffValueMapping.getOrDefault(a, zero);\n+                yield block.op(_return(da));\n+            }\n+            case Op.BlockTerminating _ -> {\n+                \/\/ Update with differentiated block arguments\n+                op.successors().forEach(s -> adaptSuccessor(block.context(), s));\n+                yield block.op(op);\n+            }\n+            default -> throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+        };\n+    }\n+\n+    void adaptSuccessor(CopyContext cc, Block.Reference from) {\n+        List<Value> as = from.arguments().stream()\n+                .filter(activeSet::contains)\n+                .toList();\n+        if (!as.isEmpty()) {\n+            \/\/ Get the successor arguments\n+            List<Value> outputArgs = cc.getValues(from.arguments());\n+            \/\/ Append the differential arguments, if any\n+            for (Value a : as) {\n+                Value da = diffValueMapping.get(a);\n+                outputArgs.add(da);\n+            }\n+\n+            \/\/ Map successor with appended arguments\n+            Block.Reference to = cc.getBlock(from.targetBlock()).successor(outputArgs);\n+            cc.mapSuccessor(from, to);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.Assert;\n+import org.testng.annotations.Ignore;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestSmallCorpus\n+ *\/\n+public class TestSmallCorpus {\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final ClassFile CF = ClassFile.of(ClassFile.DebugElementsOption.DROP_DEBUG,\n+                                                     ClassFile.LineNumbersOption.DROP_LINE_NUMBERS);\n+    private static final int COLUMN_WIDTH = 150;\n+\n+    private int passed, notMatching;\n+    private Map<String, Map<String, Integer>> errorStats;\n+\n+    @Ignore\n+    @Test\n+    public void testDoubleRoundtripStability() throws Exception {\n+        passed = 0;\n+        notMatching = 0;\n+        errorStats = new LinkedHashMap<>();\n+        for (Path p : Files.walk(JRT.getPath(\"modules\/java.base\/java\"))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+                .toList()) {\n+            testDoubleRoundtripStability(p);\n+        }\n+\n+        for (var stats : errorStats.entrySet()) {\n+            System.out.println(String.format(\"\"\"\n+\n+            %s errors:\n+            -----------------------------------------------------\n+            \"\"\", stats.getKey()));\n+            stats.getValue().entrySet().stream().sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue())).forEach(e -> System.out.println(e.getValue() +\"x \" + e.getKey() + \"\\n\"));\n+        }\n+\n+        \/\/ @@@ There is still several failing cases and a lot of errors\n+        Assert.assertTrue(notMatching < 31 && passed > 5400, String.format(\"\"\"\n+\n+                    passed: %d\n+                    not matching: %d\n+                    %s\n+                \"\"\",\n+                passed,\n+                notMatching,\n+                errorStats.entrySet().stream().map(e -> e.getKey() +\n+                        \" errors: \"\n+                        + e.getValue().values().stream().mapToInt(Integer::intValue).sum()).collect(Collectors.joining(\"\\n    \"))\n+                ));\n+    }\n+\n+    private void testDoubleRoundtripStability(Path path) throws Exception {\n+        var clm = CF.parse(path);\n+        for (var originalModel : clm.methods()) {\n+            if (originalModel.flags().has(AccessFlag.STATIC) && originalModel.code().isPresent()) try {\n+                CoreOps.FuncOp firstLift = lift(originalModel);\n+                try {\n+                    CoreOps.FuncOp firstTransform = transform(firstLift);\n+                    try {\n+                        MethodModel firstModel = lower(firstTransform);\n+                        try {\n+                            CoreOps.FuncOp secondLift = lift(firstModel);\n+                            try {\n+                                CoreOps.FuncOp secondTransform = transform(secondLift);\n+                                try {\n+                                    MethodModel secondModel = lower(secondTransform);\n+\n+                                    \/\/ testing only methods passing through\n+                                    var firstNormalized = normalize(firstModel);\n+                                    var secondNormalized = normalize(secondModel);\n+                                    if (!firstNormalized.equals(secondNormalized)) {\n+                                        notMatching++;\n+                                        System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+                                        printInColumns(firstLift, secondLift);\n+                                        printInColumns(firstTransform, secondTransform);\n+                                        printInColumns(firstNormalized, secondNormalized);\n+                                        System.out.println();\n+                                    } else {\n+                                        passed++;\n+                                    }\n+                                } catch (Exception e) {\n+                                    error(\"second lower\", e);\n+                                }\n+                            } catch (Exception e) {\n+                                error(\"second transform\", e);\n+                            }\n+                        } catch (Exception e) {\n+                            error(\"second lift\", e);\n+                        }\n+                    } catch (Exception e) {\n+                        error(\"first lower\", e);\n+                    }\n+                } catch (Exception e) {\n+                    error(\"first transform\", e);\n+                }\n+            } catch (Exception e) {\n+                error(\"first lift\", e);\n+            }\n+        }\n+    }\n+    private static void printInColumns(CoreOps.FuncOp first, CoreOps.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n+\n+    private static CoreOps.FuncOp lift(MethodModel mm) {\n+        return BytecodeLift.lift(mm);\n+    }\n+\n+    private static CoreOps.FuncOp transform(CoreOps.FuncOp func) {\n+        return SSA.transform(func.transform((block, op) -> {\n+                    if (op instanceof Op.Lowerable lop) {\n+                        return lop.lower(block);\n+                    } else {\n+                        block.op(op);\n+                        return block;\n+                    }\n+                }));\n+    }\n+\n+    private static MethodModel lower(CoreOps.FuncOp func) {\n+        return CF.parse(BytecodeGenerator.generateClassData(\n+                MethodHandles.lookup(),\n+                func)).methods().get(0);\n+    }\n+\n+\n+    public static List<String> normalize(MethodModel mm) {\n+        record El(int index, String format, Label... targets) {\n+            public El(int index, Instruction i, Object format, Label... targets) {\n+                this(index, trim(i.opcode()) + \" \" + format, targets);\n+            }\n+            public String toString(Map<Label, Integer> targetsMap) {\n+                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n+            }\n+        }\n+\n+        Map<Label, Integer> targetsMap = new HashMap<>();\n+        List<El> elements = new ArrayList<>();\n+        Label lastLabel = null;\n+        int i = 0;\n+        for (var e : mm.code().orElseThrow()) {\n+            var er = switch (e) {\n+                case LabelTarget lt -> {\n+                    lastLabel = lt.label();\n+                    yield null;\n+                }\n+                case ExceptionCatch ec ->\n+                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n+                case BranchInstruction ins ->\n+                    new El(i++, ins, \"@%d\", ins.target());\n+                case ConstantInstruction ins ->\n+                    new El(i++, \"LDC \" + ins.constantValue());\n+                case FieldInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n+                case InvokeDynamicInstruction ins ->\n+                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n+                case InvokeInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n+                case LoadInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case StoreInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case IncrementInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n+                case LookupSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case NewMultiArrayInstruction ins ->\n+                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n+                case NewObjectInstruction ins ->\n+                    new El(i++, ins, ins.className().asInternalName());\n+                case NewPrimitiveArrayInstruction ins ->\n+                    new El(i++, ins, ins.typeKind());\n+                case NewReferenceArrayInstruction ins ->\n+                    new El(i++, ins, ins.componentType().asInternalName());\n+                case TableSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case TypeCheckInstruction ins ->\n+                    new El(i++, ins, ins.type().asInternalName());\n+                case Instruction ins ->\n+                    new El(i++, ins, \"\");\n+                default -> null;\n+            };\n+            if (er != null) {\n+                if (lastLabel != null) {\n+                    targetsMap.put(lastLabel, elements.size());\n+                    lastLabel = null;\n+                }\n+                elements.add(er);\n+            }\n+        }\n+        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n+    }\n+\n+    private static String trim(Opcode opcode) {\n+        var name = opcode.toString();\n+        int i = name.indexOf('_');\n+        return i > 2 ? name.substring(0, i) : name;\n+    }\n+\n+    private void error(String category, Exception e) {\n+        StringWriter sw = new StringWriter();\n+        e.printStackTrace(new PrintWriter(sw));\n+        errorStats.computeIfAbsent(category, _ -> new HashMap<>())\n+                  .compute(sw.toString(), (_, i) -> i == null ? 1 : i + 1);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"}]}