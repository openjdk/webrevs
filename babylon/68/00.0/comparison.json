{"files":[{"patch":"@@ -18,1 +18,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.md|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.S|.*\\.md|.*\\.properties|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,47 @@\n+\n+NATIVE_ACCESS_MODULES= \\\n+    java.base \\\n+    java.datatransfer \\\n+    java.desktop \\\n+    java.instrument \\\n+    java.logging \\\n+    java.management \\\n+    java.management.rmi \\\n+    java.naming \\\n+    java.net.http \\\n+    java.prefs \\\n+    java.rmi \\\n+    java.scripting \\\n+    java.se \\\n+    java.security.jgss \\\n+    java.security.sasl \\\n+    java.smartcardio \\\n+    java.sql \\\n+    java.sql.rowset \\\n+    java.transaction.xa \\\n+    java.xml \\\n+    java.xml.crypto \\\n+    jdk.accessibility \\\n+    jdk.charsets \\\n+    jdk.crypto.cryptoki \\\n+    jdk.dynalink \\\n+    jdk.httpserver \\\n+    jdk.incubator.vector \\\n+    jdk.internal.vm.ci \\\n+    jdk.jfr \\\n+    jdk.jsobject \\\n+    jdk.localedata \\\n+    jdk.management \\\n+    jdk.management.agent \\\n+    jdk.management.jfr \\\n+    jdk.naming.dns \\\n+    jdk.naming.rmi \\\n+    jdk.net \\\n+    jdk.nio.mapmode \\\n+    jdk.sctp \\\n+    jdk.security.auth \\\n+    jdk.security.jgss \\\n+    jdk.unsupported \\\n+    jdk.xml.dom \\\n+    jdk.zipfs \\\n+    #\n","filename":"make\/conf\/module-loader-map.conf","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,1 +26,5 @@\n-DISABLED_WARNINGS_java += this-escape restricted\n+# The base module should be built with all warnings enabled. When a\n+# new warning is added to javac, it can be temporarily added to the\n+# disabled warnings list.\n+#\n+# DISABLED_WARNINGS_java +=\n@@ -42,1 +46,2 @@\n-    java\/lang\/classfile\/components\/snippet-files\n+    java\/lang\/classfile\/components\/snippet-files \\\n+    java\/lang\/foreign\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-        cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n+        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n@@ -291,1 +291,1 @@\n-            if (CDS.isSharingEnabled()) {\n+            if (CDS.isUsingArchive()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,0 +165,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2738,133 +2738,0 @@\n-    @OpDeclaration(StringTemplateOp.NAME)\n-    public static final class StringTemplateOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n-\n-        public static final String NAME = \"java.stringTemplate\";\n-\n-        private final TypeElement resultType;\n-        private final List<Body> expressions;\n-\n-        public StringTemplateOp(OpDefinition def) {\n-            super(def);\n-\n-            this.expressions = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n-            this.resultType = def.resultType();\n-        }\n-\n-        StringTemplateOp(StringTemplateOp that, CopyContext cc, OpTransformer ot) {\n-            super(that, cc);\n-\n-            this.expressions = that.expressions.stream()\n-                    .map(b -> b.transform(cc, ot).build(this)).toList();\n-            this.resultType = that.resultType;\n-        }\n-\n-        public StringTemplateOp(TypeElement resultType, Value processorValue, List<Value> literalsValues, List<Body.Builder> expressions) {\n-            \/\/ @@@ update to use statements before super when the compiler can depend on 22 features\n-            super(NAME, makeOperandsList(processorValue, literalsValues));\n-\n-            this.expressions = expressions.stream().map(b -> b.build(this)).toList();\n-            this.resultType = resultType;\n-        }\n-\n-        private static List<Value> makeOperandsList(Value processorValue, List<Value> literalsValues) {\n-            List<Value> operands = new ArrayList<>();\n-            operands.add(processorValue);\n-            operands.addAll(literalsValues);\n-            return operands;\n-        }\n-\n-        @Override\n-        public StringTemplateOp transform(CopyContext cc, OpTransformer ot) {\n-            return new StringTemplateOp(this, cc, ot);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return resultType;\n-        }\n-\n-        @Override\n-        public List<Body> bodies() {\n-            return expressions;\n-        }\n-\n-        public Value processor() {\n-            return operands().get(0);\n-        }\n-\n-        public List<Value> fragments() {\n-            return operands().subList(1, operands().size());\n-        }\n-\n-        public List<Body> expressions() {\n-            return expressions;\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            \/\/ Creates a block for each expression and a last block\n-            \/\/ to continue building from. An expression block branches\n-            \/\/ to the next expression block or the last block\n-            List<Block.Builder> builders = new ArrayList<>();\n-            for (int i = 0; i < expressions().size(); i++) {\n-                Block.Builder bb = b.block();\n-                if (i == 0) {\n-                    b.op(branch(bb.successor()));\n-                }\n-                builders.add(bb);\n-            }\n-            Block.Builder last = expressions().isEmpty() ? b : b.block();\n-            builders.add(last);\n-\n-            List<Value> expressions = new ArrayList<>();\n-            for (int i = 0; i < expressions().size(); i++) {\n-                Block.Builder current = builders.get(i);\n-                Block.Builder next = builders.get(i + 1);\n-                current.transformBody(expressions().get(i), List.of(), opT.andThen((block, op) -> {\n-                    if (op instanceof YieldOp yop) {\n-                        expressions.add(block.context().getValue(yop.yieldValue()));\n-                        block.op(branch(next.successor()));\n-                    } else if (op instanceof Lowerable lop) {\n-                        block = lop.lower(block, opT);\n-                    } else {\n-                        block.op(op);\n-                    }\n-                    return block;\n-                }));\n-            }\n-\n-            MethodRef listOfArray = MethodRef.method(J_U_LIST, \"of\", J_U_LIST, J_L_OBJECT_ARRAY);\n-\n-            Op.Result fragmentsList = last.op(invoke(listOfArray,\n-                    buildArrayObject(last, last.context().getValues(fragments()))));\n-\n-            Op.Result expressionsList = last.op(invoke(listOfArray, buildArrayObject(last, expressions)));\n-\n-            MethodRef stOf = MethodRef.method(J_L_STRING_TEMPLATE, \"of\", J_L_STRING_TEMPLATE,\n-                    J_U_LIST, J_U_LIST);\n-            Op.Result st = last.op(invoke(stOf, fragmentsList, expressionsList));\n-\n-            MethodRef stpProcess = MethodRef.method(J_L_STRING_TEMPLATE_PROCESSOR, \"process\",\n-                    J_L_OBJECT, J_L_STRING_TEMPLATE);\n-            Op.Result res = last.op(invoke(resultType(), stpProcess, last.context().getValue(processor()), st));\n-\n-            last.context().mapValue(result(), res);\n-\n-            return last;\n-        }\n-\n-        private static Value buildArrayObject(Block.Builder builder, List<Value> elements) {\n-            Value array = builder.op(newArray(J_L_OBJECT_ARRAY, builder.op(constant(INT, elements.size()))));\n-            for (int i = 0; i < elements.size(); i++) {\n-                Value ele = elements.get(i);\n-                if (ele.type() instanceof PrimitiveType pt && pt.box().isPresent()) {\n-                    ClassType wt = pt.box().get();\n-                    MethodRef valueOf = MethodRef.method(wt, \"valueOf\", wt, ele.type());\n-                    ele = builder.op(invoke(valueOf, ele));\n-                }\n-                builder.op(arrayStoreOp(array, builder.op(constant(INT, i)), ele));\n-            }\n-            return array;\n-        }\n-    }\n-\n@@ -3284,14 +3151,0 @@\n-    \/**\n-     * Creates a string template operation.\n-     * @param resultType the result type of the operation\n-     * @param processor the processor\n-     * @param fragments the fragments\n-     * @param expressions the expressions\n-     * @return the string template operation\n-     *\/\n-    public static StringTemplateOp stringTemplate(TypeElement resultType, Value processor,\n-                                                  List<Value> fragments,\n-                                                  List<Body.Builder> expressions) {\n-        return new StringTemplateOp(resultType, processor, fragments, expressions);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpWithDefinition.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -691,0 +691,18 @@\n+     * Consistent with the usage of the {@link Override @Override}\n+     * annotation, if an interface declares a method\n+     * override-equivalent to a {@code public} method of {@link Object\n+     * java.lang.Object}, such a method of the interface is regarded\n+     * as overriding the corresponding {@code Object} method; for\n+     * example:\n+     *\n+     * {@snippet lang=java :\n+     * interface I {\n+     *   @Override\n+     *   String toString();\n+     * }\n+     * ...\n+     * assert elements.overrides(elementForItoString,\n+     *                           elementForObjecttoString,\n+     *                           elements.getTypeElement(\"I\"));\n+     * }\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    \/** 1.0 had no inner classes, and so could not pass the JCK. *\/\n+    \/* 1.0 had no inner classes, and so could not pass the JCK. *\/\n@@ -53,1 +53,1 @@\n-    \/** 1.1 did not have strictfp, and so could not pass the JCK. *\/\n+    \/* 1.1 did not have strictfp, and so could not pass the JCK. *\/\n@@ -253,1 +253,0 @@\n-        STRING_TEMPLATES(JDK21, Fragments.FeatureStringTemplates, DiagKind.PLURAL),\n@@ -257,0 +256,1 @@\n+        PRIMITIVE_PATTERNS(JDK23, Fragments.FeaturePrimitivePatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+    public final Type exactConversionsSupportType;\n@@ -245,6 +246,0 @@\n-    \/\/ For string templates\n-    public final Type stringTemplateType;\n-    public final Type templateRuntimeType;\n-    public final Type processorType;\n-    public final Type linkageType;\n-\n@@ -561,0 +556,1 @@\n+        exactConversionsSupportType = enterClass(\"java.lang.runtime.ExactConversionsSupport\");\n@@ -676,6 +672,0 @@\n-        \/\/ For string templates\n-        stringTemplateType = enterClass(\"java.lang.StringTemplate\");\n-        templateRuntimeType = enterClass(\"java.lang.runtime.TemplateRuntime\");\n-        processorType = enterClass(\"java.lang.StringTemplate$Processor\");\n-        linkageType = enterClass(\"java.lang.StringTemplate$Processor$Linkage\");\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5103,0 +5103,46 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n+    \/** Check unconditionality between any combination of reference or primitive types.\n+     *\n+     *  Rules:\n+     *    an identity conversion\n+     *    a widening reference conversion\n+     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n+     *    a boxing conversion\n+     *    a boxing conversion followed by a widening reference conversion\n+     *\n+     *  @param source     Source primitive or reference type\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExact(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        return target.isPrimitive()\n+                ? isUnconditionallyExactPrimitives(source, target)\n+                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+    }\n+\n+    \/** Check unconditionality between primitive types.\n+     *\n+     *  - widening from one integral type to another,\n+     *  - widening from one floating point type to another,\n+     *  - widening from byte, short, or char to a floating point type,\n+     *  - widening from int to double.\n+     *\n+     *  @param selectorType     Type of selector\n+     *  @param targetType       Target type\n+     *\/\n+    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n+        if (isSameType(selectorType, targetType)) {\n+            return true;\n+        }\n+\n+        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n+                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n+                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n+                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n+                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n+    }\n+    \/\/ <\/editor-fold>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -337,7 +337,0 @@\n-    \/** The current `this' symbol.\n-     *  @param env    The current environment.\n-     *\/\n-    Symbol thisSym(DiagnosticPosition pos, Env<AttrContext> env) {\n-        return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);\n-    }\n-\n@@ -983,4 +976,4 @@\n-                \/\/ If this class appears as an anonymous class in a constructor\n-                \/\/ prologue, disable implicit outer instance from being passed.\n-                \/\/ (This would be an illegal access to \"this before super\").\n-                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n+                \/\/ If a class declaration appears in a constructor prologue,\n+                \/\/ that means it's either a local class or an anonymous class.\n+                \/\/ Either way, there is no immediately enclosing instance.\n+                if (ctorProloguePrev) {\n@@ -1008,1 +1001,1 @@\n-            deferredLintHandler.flush(tree.pos());\n+            deferredLintHandler.flush(tree.pos(), lint);\n@@ -1309,1 +1302,1 @@\n-            deferredLintHandler.flush(tree.pos());\n+            deferredLintHandler.flush(tree.pos(), lint);\n@@ -1632,0 +1625,2 @@\n+        boolean wrongContext = false;\n+\n@@ -1638,2 +1633,2 @@\n-            result = tree.type = types.createErrorType(resultInfo.pt);\n-            return;\n+            resultInfo = recoveryInfo;\n+            wrongContext = true;\n@@ -1677,1 +1672,1 @@\n-        result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);\n+        result = tree.type = wrongContext? types.createErrorType(pt()) : check(tree, owntype, KindSelector.VAL, resultInfo);\n@@ -1704,0 +1699,1 @@\n+            boolean booleanSwitch = types.isSameType(types.unboxedTypeOrType(seltype), syms.booleanType);\n@@ -1706,1 +1702,4 @@\n-            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n+            if (seltype.isPrimitive() && !intSwitch) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                patternSwitch = true;\n+            }\n@@ -1709,1 +1708,1 @@\n-                !intSwitch && !errorPrimitiveSwitch) {\n+                !intSwitch) {\n@@ -1713,3 +1712,0 @@\n-                if (errorPrimitiveSwitch) {\n-                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n-                }\n@@ -1731,0 +1727,1 @@\n+            JCCaseLabel unconditionalCaseLabel = null;\n@@ -1798,4 +1795,9 @@\n-                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n-                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                } else if (!constants.add(pattype.constValue())) {\n-                                    log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                }\n+                                else {\n+                                    if (!stringSwitch && !intSwitch &&\n+                                            !((pattype.getTag().isInSuperClassesOf(LONG) || pattype.getTag().equals(BOOLEAN)) &&\n+                                              types.isSameType(types.unboxedTypeOrType(seltype), pattype))) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!constants.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                    }\n@@ -1810,0 +1812,2 @@\n+                        }  else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                            log.error(label.pos(), Errors.DefaultAndBothBooleanValues);\n@@ -1818,1 +1822,4 @@\n-                        if (!primaryType.hasTag(TYPEVAR)) {\n+\n+                        if (primaryType.isPrimitive()) {\n+                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                        } else if (!primaryType.hasTag(TYPEVAR)) {\n@@ -1821,3 +1828,1 @@\n-                        if (!errorPrimitiveSwitch) {\n-                            checkCastablePattern(pat.pos(), seltype, primaryType);\n-                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n@@ -1846,2 +1851,1 @@\n-                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                patternType);\n+                                types.isUnconditionallyExact(seltype, patternType);\n@@ -1853,0 +1857,2 @@\n+                            } else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                                log.error(pat.pos(), Errors.UnconditionalPatternAndBothBooleanValues);\n@@ -1855,0 +1861,1 @@\n+                            unconditionalCaseLabel = label;\n@@ -1881,1 +1888,1 @@\n-                chk.checkSwitchCaseLabelDominated(cases);\n+                chk.checkSwitchCaseLabelDominated(unconditionalCaseLabel, cases);\n@@ -2481,0 +2488,3 @@\n+            if (tree.expr != null) {\n+                attribExpr(tree.expr, env, env.info.yieldResult.pt);\n+            }\n@@ -4220,2 +4230,7 @@\n-        Type exprtype = chk.checkNullOrRefType(\n-                tree.expr.pos(), attribExpr(tree.expr, env));\n+        Type exprtype = attribExpr(tree.expr, env);\n+        if (exprtype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            exprtype = chk.checkNullOrRefType(\n+                    tree.expr.pos(), exprtype);\n+        }\n@@ -4242,11 +4257,5 @@\n-        if (!clazztype.hasTag(TYPEVAR)) {\n-            clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n-        }\n-        if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n-            boolean valid = false;\n-            if (allowReifiableTypesInInstanceof) {\n-                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n-            } else {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n-                allowReifiableTypesInInstanceof = true;\n+        if (clazztype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            if (!clazztype.hasTag(TYPEVAR)) {\n+                clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n@@ -4254,2 +4263,12 @@\n-            if (!valid) {\n-                clazztype = types.createErrorType(clazztype);\n+            if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n+                boolean valid = false;\n+                if (allowReifiableTypesInInstanceof) {\n+                    valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n+                } else {\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    allowReifiableTypesInInstanceof = true;\n+                }\n+                if (!valid) {\n+                    clazztype = types.createErrorType(clazztype);\n+                }\n@@ -4275,6 +4294,3 @@\n-                   (!exprType.isPrimitive() ||\n-                    !pattType.isPrimitive() ||\n-                    !types.isSameType(exprType, pattType))) {\n-            chk.basicHandler.report(pos,\n-                    diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-            return false;\n+                (!exprType.isPrimitive() || !pattType.isPrimitive() || !types.isSameType(exprType, pattType))) {\n+            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            return true;\n@@ -5099,26 +5115,0 @@\n-    public void visitStringTemplate(JCStringTemplate tree) {\n-        JCExpression processor = tree.processor;\n-        Type processorType = attribTree(processor, env, new ResultInfo(KindSelector.VAL, Type.noType));\n-        chk.checkProcessorType(processor, processorType, env);\n-        Type processMethodType = getProcessMethodType(tree, processorType);\n-        tree.processMethodType = processMethodType;\n-        Type resultType = processMethodType.getReturnType();\n-\n-        Env<AttrContext> localEnv = env.dup(tree, env.info.dup());\n-\n-        for (JCExpression arg : tree.expressions) {\n-            chk.checkNonVoid(arg.pos(), attribExpr(arg, localEnv));\n-        }\n-\n-        tree.type = resultType;\n-        result = resultType;\n-        check(tree, resultType, KindSelector.VAL, resultInfo);\n-    }\n-\n-    private Type getProcessMethodType(JCStringTemplate tree, Type processorType) {\n-        MethodSymbol processSymbol = rs.resolveInternalMethod(tree.pos(),\n-                env, types.skipTypeVars(processorType, false),\n-                names.process, List.of(syms.stringTemplateType), List.nil());\n-        return types.memberType(processorType, processSymbol);\n-    }\n-\n@@ -5430,1 +5420,1 @@\n-            deferredLintHandler.flush(env.tree.pos());\n+            deferredLintHandler.flush(env.tree.pos(), lint);\n@@ -5605,1 +5595,1 @@\n-                deferredLintHandler.flush(env.tree);\n+                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5655,1 +5645,1 @@\n-            deferredLintHandler.flush(tree.pos());\n+            deferredLintHandler.flush(tree.pos(), lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":72,"deletions":82,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-        \/****\n+        \/* **\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,2 +458,1 @@\n-                        Tag.TYPEARRAY,\n-                        Tag.STRING_TEMPLATE);\n+                        Tag.TYPEARRAY);\n@@ -2207,15 +2206,0 @@\n-        @Override\n-        public void visitStringTemplate(JCTree.JCStringTemplate tree) {\n-            Value processor = toValue(tree.processor);\n-            List<Value> fragments = tree.fragments.map(f -> append(CoreOps.constant(JavaType.J_L_STRING, f)));\n-\n-            List<Body.Builder> expressions = new ArrayList<>();\n-            tree.expressions.forEach(e -> {\n-                pushBody(e, FunctionType.functionType(typeToTypeElement(e.type)));\n-                append(CoreOps._yield(toValue(e)));\n-                expressions.add(stack.body);\n-                popBody();\n-            });\n-            result = append(ExtendedOps.stringTemplate(typeToTypeElement(tree.type), processor, fragments, expressions));\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1077,0 +1077,5 @@\n+        \/* this method is heavily invoked, as expected, for deeply nested blocks, if blocks doesn't happen to have\n+         * patterns there will be an unnecessary tax on memory consumption every time this method is executed, for this\n+         * reason we have created helper methods and here at a higher level we just discriminate depending on the\n+         * presence, or not, of patterns in a given block\n+         *\/\n@@ -1078,16 +1083,1 @@\n-            Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n-            ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n-            State startState = code.state.dup();\n-            try {\n-                invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n-                patternMatchingInvocationRanges = new ListBuffer<>();\n-                doVisitBlock(tree);\n-            } finally {\n-                Chain skipCatch = code.branch(goto_);\n-                JCCatch handler = tree.patternMatchingCatch.handler();\n-                code.entryPoint(startState, handler.param.sym.type);\n-                genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n-                code.resolve(skipCatch);\n-                invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n-                patternMatchingInvocationRanges = prevRanges;\n-            }\n+            visitBlockWithPatterns(tree);\n@@ -1095,1 +1085,1 @@\n-            doVisitBlock(tree);\n+            internalVisitBlock(tree);\n@@ -1099,1 +1089,20 @@\n-    private void doVisitBlock(JCBlock tree) {\n+    private void visitBlockWithPatterns(JCBlock tree) {\n+        Set<JCMethodInvocation> prevInvocationsWithPatternMatchingCatch = invocationsWithPatternMatchingCatch;\n+        ListBuffer<int[]> prevRanges = patternMatchingInvocationRanges;\n+        State startState = code.state.dup();\n+        try {\n+            invocationsWithPatternMatchingCatch = tree.patternMatchingCatch.calls2Handle();\n+            patternMatchingInvocationRanges = new ListBuffer<>();\n+            internalVisitBlock(tree);\n+        } finally {\n+            Chain skipCatch = code.branch(goto_);\n+            JCCatch handler = tree.patternMatchingCatch.handler();\n+            code.entryPoint(startState, handler.param.sym.type);\n+            genPatternMatchingCatch(handler, env, patternMatchingInvocationRanges.toList());\n+            code.resolve(skipCatch);\n+            invocationsWithPatternMatchingCatch = prevInvocationsWithPatternMatchingCatch;\n+            patternMatchingInvocationRanges = prevRanges;\n+        }\n+    }\n+\n+    private void internalVisitBlock(JCBlock tree) {\n@@ -1431,0 +1440,5 @@\n+\n+            if (swtch instanceof JCSwitchExpression) {\n+                 \/\/ Emit line position for the end of a switch expression\n+                 code.statBegin(TreeInfo.endPos(swtch));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.Collections;\n+import java.util.Comparator;\n@@ -44,0 +44,1 @@\n+import java.util.function.ToIntFunction;\n@@ -989,4 +990,1 @@\n-            if (deferredDiagnosticHandler != null) {\n-                deferredDiagnosticHandler.reportDeferredDiagnostics();\n-                log.popDiagnosticHandler(deferredDiagnosticHandler);\n-            }\n+            reportDeferredDiagnosticAndClearHandler();\n@@ -1199,2 +1197,1 @@\n-                deferredDiagnosticHandler.reportDeferredDiagnostics();\n-                log.popDiagnosticHandler(deferredDiagnosticHandler);\n+                reportDeferredDiagnosticAndClearHandler();\n@@ -1236,2 +1233,1 @@\n-                    deferredDiagnosticHandler.reportDeferredDiagnostics();\n-                    log.popDiagnosticHandler(deferredDiagnosticHandler);\n+                    reportDeferredDiagnosticAndClearHandler();\n@@ -1271,2 +1267,1 @@\n-                        deferredDiagnosticHandler.reportDeferredDiagnostics();\n-                        log.popDiagnosticHandler(deferredDiagnosticHandler);\n+                        reportDeferredDiagnosticAndClearHandler();\n@@ -1289,4 +1284,1 @@\n-            if (deferredDiagnosticHandler != null) {\n-                deferredDiagnosticHandler.reportDeferredDiagnostics();\n-                log.popDiagnosticHandler(deferredDiagnosticHandler);\n-            }\n+            reportDeferredDiagnosticAndClearHandler();\n@@ -1627,6 +1619,0 @@\n-            if (shouldStop(CompileState.TRANSLITERALS))\n-                return;\n-\n-            env.tree = TransLiterals.instance(context).translateTopLevelClass(env, env.tree, localMake);\n-            compileStates.put(env, CompileState.TRANSLITERALS);\n-\n@@ -1866,0 +1852,12 @@\n+    public void reportDeferredDiagnosticAndClearHandler() {\n+        if (deferredDiagnosticHandler != null) {\n+            ToIntFunction<JCDiagnostic> diagValue =\n+                    d -> d.isFlagSet(RECOVERABLE) ? 1 : 0;\n+            Comparator<JCDiagnostic> compareDiags =\n+                    (d1, d2) -> diagValue.applyAsInt(d1) - diagValue.applyAsInt(d2);\n+            deferredDiagnosticHandler.reportDeferredDiagnostics(compareDiags);\n+            log.popDiagnosticHandler(deferredDiagnosticHandler);\n+            deferredDiagnosticHandler = null;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -552,0 +552,6 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=\\\n+    switch has both boolean values and an unconditional pattern\n+\n+compiler.err.default.and.both.boolean.values=\\\n+    switch has both boolean values and a default label\n+\n@@ -566,4 +572,0 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed=\\\n-    selector type {0} is not allowed\n-\n@@ -741,0 +743,6 @@\n+compiler.err.illegal.digit.in.binary.literal=\\\n+    illegal digit in a binary literal\n+\n+compiler.err.illegal.digit.in.octal.literal=\\\n+    illegal digit in an octal literal\n+\n@@ -1356,13 +1364,0 @@\n-compiler.err.string.template.is.not.well.formed=\\\n-    string template is not well formed\n-\n-compiler.err.text.block.template.is.not.well.formed=\\\n-    text block template is not well formed\n-\n-compiler.err.processor.missing.from.string.template.expression=\\\n-    processor missing from string template expression\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type=\\\n-    not a processor type: {0}\n-\n@@ -1885,0 +1880,3 @@\n+compiler.warn.dangling.doc.comment=\\\n+    documentation comment is not attached to any declaration\n+\n@@ -2676,4 +2674,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types=\\\n-    pattern of type {1} is not applicable at {0}\n-\n@@ -3211,0 +3205,3 @@\n+compiler.misc.feature.primitive.patterns=\\\n+    primitive patterns\n+\n@@ -3223,3 +3220,0 @@\n-compiler.misc.feature.string.templates=\\\n-    string templates\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -273,4 +273,0 @@\n-        \/** String template expression.\n-         *\/\n-        STRING_TEMPLATE,\n-\n@@ -2497,53 +2493,0 @@\n-    \/**\n-     * String template expression.\n-     *\/\n-    public static class JCStringTemplate extends JCExpression implements StringTemplateTree {\n-        public JCExpression processor;\n-        public List<String> fragments;\n-        public List<JCExpression> expressions;\n-        public Type processMethodType;\n-\n-        protected JCStringTemplate(JCExpression processor,\n-                                   List<String> fragments,\n-                                   List<JCExpression> expressions) {\n-            this.processor = processor;\n-            this.fragments = fragments;\n-            this.expressions = expressions;\n-        }\n-\n-        @Override\n-        public ExpressionTree getProcessor() {\n-            return processor;\n-        }\n-\n-        @Override\n-        public List<String> getFragments() {\n-            return fragments;\n-        }\n-\n-        @Override\n-        public List<? extends ExpressionTree> getExpressions() {\n-            return expressions;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Kind getKind() {\n-            return Kind.TEMPLATE;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Tag getTag() {\n-            return STRING_TEMPLATE;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public void accept(Visitor v) {\n-            v.visitStringTemplate(this);\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n-            return v.visitStringTemplate(this, d);\n-        }\n-    }\n-\n@@ -3529,3 +3472,0 @@\n-        JCStringTemplate StringTemplate(JCExpression processor,\n-                                        List<String> fragments,\n-                                        List<JCExpression> expressions);\n@@ -3603,1 +3543,0 @@\n-        public void visitStringTemplate(JCStringTemplate that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -198,0 +198,35 @@\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n+            case IDENT: {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this || ident.name == names._super;\n+            }\n+            case SELECT: {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(TypeTag.CLASS))\n+                    return false;\n+                Symbol.ClassSymbol currentClassSym = (Symbol.ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+                Symbol.ClassSymbol selectedClassSym = (Symbol.ClassSymbol)((Type.ClassType)selectedType).tsym;\n+                Names names = select.name.table.names;\n+                return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this &&\n+                            (currentClassSym == selectedClassSym ||\n+                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n@@ -387,1 +422,0 @@\n-            case STRING_TEMPLATE:\n@@ -603,4 +637,0 @@\n-            case STRING_TEMPLATE: {\n-                JCStringTemplate node = (JCStringTemplate) tree;\n-                return node.processor == null ? node.pos : getStartPos(node.processor);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -23,0 +23,11 @@\n+###############################################################################\n+#\n+# All tests\n+#\n+\n+all = \\\n+    :jdk_all\n+\n+jdk_all = \\\n+    \/\n+\n@@ -244,1 +255,1 @@\n-    security\/infra\/java\/security\/cert\/CertPathValidator\/certification\n+    security\/infra\n","filename":"test\/jdk\/TEST.groups","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        FuncOp dfcm = fcm.transform(STR.\"d\\{fcm.funcName()}_darg\\{indI}\",\n+        FuncOp dfcm = fcm.transform(String.format(\"d%s_darg%d\", fcm.funcName(), indI),\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-            System.out.println(STR.\"\"\"\n+            System.out.println(String.format(\"\"\"\n@@ -81,1 +81,1 @@\n-            \\{stats.getKey()} errors:\n+            %s errors:\n@@ -83,1 +83,1 @@\n-            \"\"\");\n+            \"\"\", stats.getKey()));\n@@ -87,1 +87,0 @@\n-\n@@ -89,1 +88,1 @@\n-        Assert.assertTrue(notMatching < 31 && passed > 5400, STR.\"\"\"\n+        Assert.assertTrue(notMatching < 31 && passed > 5400, String.format(\"\"\"\n@@ -91,5 +90,10 @@\n-                    passed: \\{passed}\n-                    not matching: \\{notMatching}\n-                    \\{errorStats.entrySet().stream().map(e -> e.getKey() + \" errors: \"\n-                            + e.getValue().values().stream().collect(Collectors.summingInt(Integer::intValue))).collect(Collectors.joining(\"\\n    \"))}\n-                \"\"\");\n+                    passed: %d\n+                    not matching: %d\n+                    %s\n+                \"\"\",\n+                passed,\n+                notMatching,\n+                errorStats.entrySet().stream().map(e -> e.getKey() +\n+                        \" errors: \"\n+                        + e.getValue().values().stream().mapToInt(Integer::intValue).sum()).collect(Collectors.joining(\"\\n    \"))\n+                ));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"}]}