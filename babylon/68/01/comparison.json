{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=babylon\n@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -13,0 +13,34 @@\n+\n+## Particulars related to Babylon\n+\n+The Babylon JDK builds like any other JDK, see the build instructions above.\n+\n+### Code shared between `java.base` and `jdk.compiler` modules\n+\n+A subset of code in `java.base` is copied with package renaming into\n+the `jdk.compiler` module. This is the set of code required to build\n+and serialize code models. Due to bootstrapping constraints, compiling\n+the compiler it cannot depend on all code in `java.base`. In the future\n+we may come up with a better solution. For now the build has been modified\n+to copy the code, which leverages the script `cr-util\/copy-to-compiler.sh`.\n+\n+### Testing\n+\n+Specific compiler tests can be executed using `jtreg`, for example:\n+\n+```\n+jtreg -jdk:.\/build\/macosx-x86_64-server-release\/jdk\/ -ea -esa -avm -va test\/langtools\/tools\/javac\/reflect\/\n+```\n+\n+Specific runtime tests can be executed using `jtreg`, for example:\n+\n+```\n+jtreg -jdk:.\/build\/macosx-x86_64-server-release\/jdk\/ -ea -esa -avm -va test\/jdk\/java\/lang\/reflect\/code\/\n+```\n+\n+In addition, the runtime tests can be executed using make with the test group\n+`jdk_lang_reflect_code` as follows:\n+\n+```\n+make test TEST=jdk_lang_reflect_code\n+```\n\\ No newline at end of file\n","filename":"README.md","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+Example code showing use of code reflection in translation from Java to\n+the SPIR-V intermediate language.  For more information on SPIR-V see:\n+https:\/\/www.khronos.org\/spir.\n+\n+\n+Dependencies:\n+\n+This code depends on the Beehive SPIR-V Toolkit (https:\/\/github.com\/beehive-lab\/beehive-spirv-toolkit)\n+which must be cloned and installed locally. For example:\n+\n+git clone https:\/\/github.com\/beehive-lab\/beehive-spirv-toolkit\n+cd beehive-spirv-toolkit\n+mvn clean install\n","filename":"cr-examples\/spirv\/README.md","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024 Intel Corporation. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>intel.code<\/groupId>\n+    <artifactId>spirv<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>23<\/maven.compiler.source>\n+        <maven.compiler.target>23<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+             <groupId>beehive-lab<\/groupId>\n+             <artifactId>beehive-spirv-lib<\/artifactId>\n+             <version>0.0.3<\/version>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                        <arg>--add-modules=jdk.incubator.vector<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+             <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-surefire-plugin<\/artifactId>\n+                <version>3.1.2<\/version>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                    <redirectTestOutputToFile>false<\/redirectTestOutputToFile>\n+                <\/configuration>\n+            <\/plugin>\n+            <plugin>\n+              <groupId>org.codehaus.mojo<\/groupId>\n+              <artifactId>exec-maven-plugin<\/artifactId>\n+              <version>1.4.0<\/version>\n+              <configuration>\n+                <mainClass>intel.code.spirv.ExampleUseTest<\/mainClass>\n+                <configuration>\n+                    <argLine>--enable-preview<\/argLine>\n+                    <argLine>--add-modules=jdk.incubator.vector<\/argLine>\n+                <\/configuration>\n+             <\/configuration>\n+            <\/plugin>\n+\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/spirv\/pom.xml","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.Objects;\n+import java.util.List;\n+\n+public final class PointerType extends SpirvType {\n+    static final String NAME = \"spirv.pointer\";\n+    private final TypeElement referentType;\n+    private final TypeElement storageType;\n+\n+    public PointerType(TypeElement referentType, TypeElement storageType)\n+    {\n+        this.referentType = referentType;\n+        this.storageType = storageType;\n+    }\n+\n+    public TypeElement referentType()\n+    {\n+        return referentType;\n+    }\n+\n+    public TypeElement storageType()\n+    {\n+        return storageType;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj)\n+    {\n+        if (obj == null || obj.getClass() != PointerType.class) return false;\n+        PointerType pt = (PointerType)obj;\n+        return pt.referentType().equals(referentType) && pt.storageType.equals(storageType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(referentType, storageType);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of(referentType.toTypeDefinition(), storageType.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/PointerType.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,1030 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.function.Function;\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.math.BigInteger;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.FloatVector;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.JavaType;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVHeader;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVModule;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVFunction;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.SPIRVBlock;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.instructions.operands.*;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.Disassembler;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPIRVDisassemblerOptions;\n+import uk.ac.manchester.beehivespirvtoolkit.lib.disassembler.SPVByteStreamReader;\n+\n+public class SpirvModuleGenerator {\n+    public static MemorySegment generateModule(String moduleName, CoreOps.FuncOp func) {\n+        SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(func);\n+        MemorySegment module = SpirvModuleGenerator.generateModule(moduleName, spirvFunc);\n+        return module;\n+    }\n+\n+    public static MemorySegment generateModule(String moduleName, SpirvOps.FuncOp func) {\n+        return new SpirvModuleGenerator().generateModuleInternal(moduleName, func);\n+    }\n+\n+    public static void writeModuleToFile(MemorySegment module, String filepath)  {\n+        ByteBuffer buffer = module.asByteBuffer();\n+        File out = new File(filepath);\n+        try (FileChannel channel = new FileOutputStream(out, false).getChannel()) {\n+            channel.write(buffer);\n+        }\n+        catch (IOException e)  {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static String disassembleModule(MemorySegment module) {\n+        SPVByteStreamReader input = new SPVByteStreamReader(new ByteArrayInputStream(module.toArray(ValueLayout.JAVA_BYTE)));\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (PrintStream ps = new PrintStream(out))  {\n+            SPIRVDisassemblerOptions options = new SPIRVDisassemblerOptions(false, false, false, false, true);\n+            Disassembler dis = new Disassembler(input, ps, options);\n+            dis.run();\n+        }\n+        catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return new String(out.toByteArray());\n+    }\n+\n+    private record SpirvResult(SPIRVId type, SPIRVId address, SPIRVId value) {}\n+\n+    private final SPIRVModule module;\n+    private final Symbols symbols;\n+\n+    private SpirvModuleGenerator() {\n+        this.module = new SPIRVModule(new SPIRVHeader(1, 2, 32, 0, 0));\n+        this.symbols = new Symbols();\n+    }\n+\n+    private MemorySegment generateModuleInternal(String moduleName, SpirvOps.FuncOp func) {\n+        initModule();\n+        generateFunction(moduleName, moduleName, func);\n+        ByteBuffer buffer = ByteBuffer.allocateDirect(module.getByteCount());\n+        buffer.order(ByteOrder.LITTLE_ENDIAN);\n+        module.close().write(buffer);\n+        buffer.flip();\n+        return MemorySegment.ofBuffer(buffer);\n+    }\n+\n+    private void generateFunction(String moduleName, String fnName, SpirvOps.FuncOp func) {\n+        TypeElement returnType = func.invokableType().returnType();\n+        SPIRVId functionID = nextId(fnName);\n+        String signature = func.invokableType().returnType().toString();\n+        List<TypeElement> paramTypes = func.invokableType().parameterTypes();\n+        \/\/ build signature string\n+        for (int i = 0; i < paramTypes.size(); i++) {\n+            signature += \"_\" + paramTypes.get(i).toString();\n+        }\n+        \/\/ declare function type if not already present\n+        SPIRVId functionSig = getIdOrNull(signature);\n+        if (functionSig == null) {\n+            SPIRVId[] typeIdsArray = new SPIRVId[paramTypes.size()];\n+            for (int i = 0; i < paramTypes.size(); i++) {\n+                typeIdsArray[i] = spirvType(paramTypes.get(i).toString());\n+            }\n+            functionSig = nextId(fnName + \"Signature\");\n+            module.add(new SPIRVOpTypeFunction(functionSig, spirvType(returnType.toString()), new SPIRVMultipleOperands<>(typeIdsArray)));\n+            addId(signature, functionSig);\n+        }\n+        \/\/ declare function as modeule entry point\n+        SPIRVId spirvReturnType = spirvType(returnType.toString());\n+        SPIRVFunction function = (SPIRVFunction)module.add(new SPIRVOpFunction(spirvReturnType, functionID, SPIRVFunctionControl.DontInline(), functionSig));\n+        SPIRVOpLabel entryPoint = new SPIRVOpLabel(nextId());\n+        SPIRVBlock entryBlock = (SPIRVBlock)function.add(entryPoint);\n+        SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(getId(\"globalInvocationId\"), getId(\"globalSize\"), getId(\"subgroupSize\"), getId(\"subgroupId\"));\n+        module.add(new SPIRVOpEntryPoint(SPIRVExecutionModel.Kernel(), functionID, new SPIRVLiteralString(fnName), operands));\n+\n+        translateBody(func.body(), function, entryBlock);\n+        function.add(new SPIRVOpFunctionEnd());\n+    }\n+\n+    private void translateBody(Body body, SPIRVFunction function, SPIRVBlock entryBlock) {\n+        int labelNumber = 0;\n+        SPIRVBlock spirvBlock = entryBlock;\n+        for (int bi = 1; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            String blockName = String.valueOf(block.hashCode());\n+            SPIRVOpLabel blockLabel = new SPIRVOpLabel(nextId());\n+            SPIRVBlock newBlock = (SPIRVBlock)function.add(blockLabel);\n+            symbols.putBlock(block, newBlock);\n+            symbols.putLabel(block, blockLabel);\n+        }\n+        for (Value param : body.entryBlock().parameters()) {\n+            SPIRVId paramId = nextId();\n+            addResult(param, new SpirvResult(spirvType(param.type().toString()), null, paramId));\n+        }\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            if (bi > 0) {\n+                spirvBlock = symbols.getBlock(block);\n+            }\n+            List<Op> ops = block.ops();\n+            for (Op op : block.ops()) {\n+                \/\/ debug(\"---------- spirv op = %s\", op.toText());\n+                switch (op)  {\n+                    case SpirvOps.VariableOp vop -> {\n+                        String typeName = vop.varType().toString();\n+                        SPIRVId type = spirvType(typeName);\n+                        SPIRVId varType = spirvVariableType(type);\n+                        SPIRVId var = nextId(vop.varName());\n+                        spirvBlock.add(new SPIRVOpVariable(varType, var, SPIRVStorageClass.Function(), new SPIRVOptionalOperand<>()));\n+                        addResult(vop.result(), new SpirvResult(varType, var, null));\n+                    }\n+                    case SpirvOps.FunctionParameterOp fpo -> {\n+                        SPIRVId result = nextId();\n+                        SPIRVId type = spirvType(fpo.resultType().toString());\n+                        function.add(new SPIRVOpFunctionParameter(type, result));\n+                        addResult(fpo.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.LoadOp lo -> {\n+                        if (((JavaType)lo.resultType()).equals(JavaType.type(VectorSpecies.class))) {\n+                            addResult(lo.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\")));\n+                        }\n+                        else {\n+                            SPIRVId type = spirvType(lo.resultType().toString());\n+                            SpirvResult toLoad = getResult(lo.operands().get(0));\n+                            SPIRVId varAddr = toLoad.address();\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(type, result, varAddr, align(type.getName())));\n+                            addResult(lo.result(), new SpirvResult(type, varAddr, result));\n+                        }\n+                    }\n+                    case SpirvOps.StoreOp so -> {\n+                        SpirvResult var = getResult(so.operands().get(0));\n+                        SPIRVId varAddr = var.address();\n+                        SPIRVId value = getResult(so.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpStore(varAddr, value, align(var.type().getName())));\n+                    }\n+                    case SpirvOps.IAddOp _, SpirvOps.FAddOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIAdd(intType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIAdd(longType, ans, lhs, rhs));\n+                        else if (lhsType == floatType) spirvBlock.add(new SPIRVOpFAdd(floatType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.IMulOp _, SpirvOps.FMulOp _, SpirvOps.IDivOp _, SpirvOps.FDivOp _ -> {\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId rhsType = getResult(op.operands().get(1)).type();\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) {\n+                            if (op instanceof SpirvOps.IMulOp) spirvBlock.add(new SPIRVOpIMul(intType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOps.IDivOp) spirvBlock.add(new SPIRVOpSDiv(intType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == longType) {\n+                            SPIRVId rhsId = rhsType == intType ? nextId() : rhs;\n+                            if (rhsType == intType) spirvBlock.add(new SPIRVOpSConvert(longType, rhsId, rhs));\n+                            if (op instanceof SpirvOps.IMulOp) spirvBlock.add(new SPIRVOpIMul(longType, ans, lhs, rhsId));\n+                            else if (op instanceof SpirvOps.IDivOp) spirvBlock.add(new SPIRVOpSDiv(longType, ans, lhs, rhs));\n+                        }\n+                        else if (lhsType == floatType) {\n+                            if (op instanceof SpirvOps.FMulOp) spirvBlock.add(new SPIRVOpFMul(floatType, ans, lhs, rhs));\n+                            else if (op instanceof SpirvOps.FDivOp) spirvBlock.add(new SPIRVOpFDiv(floatType, ans, lhs, rhs));\n+                        }\n+                        else unsupported(\"type\", lhsType);\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.ModOp mop -> {\n+                        SPIRVId type = getType(mop.operands().get(0).type().toString());\n+                        SPIRVId lhs = getResult(mop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(mop.operands().get(1)).value();\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpUMod(type, result, lhs, rhs));\n+                        addResult(mop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.IEqualOp eqop -> {\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId intType = getType(\"int\");\n+                        SPIRVId longType = getType(\"long\");\n+                        SPIRVId floatType = getType(\"float\");\n+                        SPIRVId lhs = getResult(op.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(op.operands().get(1)).value();\n+                        SPIRVId lhsType = spirvType(op.resultType().toString());\n+                        SPIRVId ans = nextId();\n+                        if (lhsType == intType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else if (lhsType == longType) spirvBlock.add(new SPIRVOpIEqual(boolType, ans, lhs, rhs));\n+                        else unsupported(\"type\", lhsType.getName());\n+                        addResult(op.result(), new SpirvResult(lhsType, null, ans));\n+                    }\n+                    case SpirvOps.CallOp call -> {\n+                        if (call.callDescriptor().equals(MethodRef.ofString(\"spirvdemo.IntArray::get(long)int\")) ||\n+                            call.callDescriptor().equals(MethodRef.ofString(\"spirvdemo.FloatArray::get(long)float\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 1;\n+                            SPIRVId index = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId resultAddr = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, resultAddr, array, index, new SPIRVMultipleOperands<>()));\n+                            SPIRVId result = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(elementType, result, resultAddr, align(elementType.getName())));\n+                            addResult(call.result(), new SpirvResult(elementType, resultAddr, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.ofString(\"spirvdemo.IntArray::set(long, int)void\")) ||\n+                                call.callDescriptor().equals(MethodRef.ofString(\"spirvdemo.FloatArray::set(long, float)void\"))) {\n+                            SPIRVId longType = getType(\"long\");\n+                            String arrayTypeName = call.operands().get(0).type().toString();\n+                            SpirvResult arrayResult = getResult(call.operands().get(0));\n+                            SPIRVId arrayAddr = arrayResult.address();\n+                            SPIRVId arrayType = spirvType(arrayTypeName);\n+                            SPIRVId elementType = spirvElementType(arrayTypeName);\n+                            int nIndexes = call.operands().size() - 2;\n+                            int valueIndex = nIndexes + 1;\n+                            SPIRVId index = getResult(call.operands().get(1)).value();\n+                            SPIRVId array = nextId();\n+                            spirvBlock.add(new SPIRVOpLoad(arrayType, array, arrayAddr, align(arrayType.getName())));\n+                            SPIRVId dest = nextId();\n+                            spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(arrayType, dest, array, index, new SPIRVMultipleOperands<>()));\n+                            SPIRVId value = getResult(call.operands().get(valueIndex)).value();\n+                            spirvBlock.add(new SPIRVOpStore(dest, value, align(elementType.getName())));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"fromArray\", IntVector.class, VectorSpecies.class, int[].class, int.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"fromArray\", FloatVector.class, VectorSpecies.class, float[].class, int.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult speciesResult = getResult(call.operands().get(0));\n+                            SpirvResult arrayResult = getResult(call.operands().get(1));\n+                            String arrayType = arrayResult.type().getName();\n+                            int laneCount = 8;  \/\/TODO: remove hard code, instruction below needs a literal\n+                            String vTypeName = ((ClassType)call.callDescriptor().refType()).toClassName();\n+                            SPIRVId vType = spirvVectorType(vTypeName, laneCount);\n+                            SPIRVId array = arrayResult.value();\n+                            SPIRVId index = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSDiv(getType(\"int\"), vectorIndex, index, speciesResult.value()));\n+                            SPIRVId longIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), longIndex, vectorIndex));\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(longIndex, array, new SPIRVId(laneCount)); \/\/ TODO: lanes must be a literal\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, vector, oclExtension, new SPIRVLiteralExtInstInteger(171, \"vloadn\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"fromMemorySegment\", IntVector.class, VectorSpecies.class, MemorySegment.class, long.class, ByteOrder.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"fromMemorySegment\", FloatVector.class, VectorSpecies.class, MemorySegment.class, long.class, ByteOrder.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SPIRVId species = getResult(call.operands().get(0)).value();\n+                            SPIRVId lanesLong = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), lanesLong, species));\n+                            int laneCount = 8; \/\/TODO: remove hard code, vloadn instruction below needs a literal lane count, get value from env\n+                            SPIRVId segment = getResult(call.operands().get(1)).value();\n+                            String vTypeName = ((ClassType)call.callDescriptor().refType()).toClassName();\n+                            SPIRVId vType = spirvVectorType(vTypeName, laneCount);\n+                            SPIRVId temp = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(getType(\"long\"), temp, segment));\n+                            SPIRVId typedSegment = nextId();\n+                            SPIRVId pointerType = (SPIRVId)map(x -> x.equals(vTypeName), \"jdk.incubator.vector.IntVector\", \"jdk.incubator.vector.FloatVector\", getType(\"ptrInt\"), getType(\"ptrFloat\"));\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(pointerType, typedSegment, temp));\n+                            SPIRVId offset = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSDiv(getType(\"long\"), vectorIndex, offset, lanesLong)); \/\/ divide by lane count\n+                            SPIRVId finalIndex = nextId();\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(vectorIndex, typedSegment, new SPIRVId(laneCount)); \/\/ TODO: lanes must be a literal\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, vector, oclExtension, new SPIRVLiteralExtInstInteger(171, \"vloadn\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"intoArray\", void.class, int[].class, int.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"intoArray\", void.class, float[].class, int.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vector = vectorResult.value();\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SpirvResult arrayResult = getResult(call.operands().get(1));\n+                            SPIRVId array = arrayResult.value();\n+                            SPIRVId index = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpShiftRightArithmetic(getType(\"int\"), vectorIndex, index, vectorExponent(vectorType.getName())));\n+                            SPIRVId longIndex = nextId();\n+                            spirvBlock.add(new SPIRVOpSConvert(getType(\"long\"), longIndex, vectorIndex));\n+                            SPIRVMultipleOperands<SPIRVId> operandsR = new SPIRVMultipleOperands<>(vector, longIndex, array);\n+                            spirvBlock.add(new SPIRVOpExtInst(getType(\"void\"), nextId(), oclExtension, new SPIRVLiteralExtInstInteger(172, \"vstoren\"), operandsR));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"intoMemorySegment\", void.class, MemorySegment.class, long.class, ByteOrder.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"intoMemorySegment\", void.class, MemorySegment.class, long.class, ByteOrder.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vector = vectorResult.value();\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SpirvResult segmentResult = getResult(call.operands().get(1));;\n+                            SPIRVId segment = segmentResult.value();\n+                            SPIRVId temp = nextId();\n+                            spirvBlock.add(new SPIRVOpConvertPtrToU(getType(\"long\"), temp, segment));\n+                            SPIRVId typedSegment = nextId();\n+                            String vectorElementType = vectorElementType(vectorType).getName();\n+                            SPIRVId pointerType = (SPIRVId)map(x -> x.equals(vectorElementType), \"int\", \"float\", getType(\"ptrInt\"), getType(\"ptrFloat\"));\n+                            spirvBlock.add(new SPIRVOpConvertUToPtr(pointerType, typedSegment, temp));\n+                            SPIRVId offset = getResult(call.operands().get(2)).value();\n+                            SPIRVId vectorIndex = nextId();\n+                            int laneCount = laneCount(vectorType.getName());\n+                            spirvBlock.add(new SPIRVOpShiftRightArithmetic(getType(\"long\"), vectorIndex, offset, vectorExponent(vectorType.getName())));\n+                            SPIRVMultipleOperands<SPIRVId> operandsR = new SPIRVMultipleOperands<>(vector, vectorIndex, typedSegment);\n+                            spirvBlock.add(new SPIRVOpExtInst(getId(\"void\"), nextId(), oclExtension, new SPIRVLiteralExtInstInteger(172, \"vstoren\"), operandsR));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"reduceLanes\", int.class, VectorOperators.Associative.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"reduceLanes\", float.class, VectorOperators.Associative.class))) {\n+                            SpirvResult vectorResult = getResult(call.operands().get(0));\n+                            SPIRVId vectorType = vectorResult.type();\n+                            SPIRVId vector = vectorResult.value();\n+                            String vTypeName = vectorType.getName();\n+                            SPIRVId elementType = vectorElementType(vectorType);\n+                            Op reduceOp = ((Op.Result)call.operands().get(1)).op();\n+                            if (reduceOp instanceof SpirvOps.FieldLoadOp flo) {\n+                                assert flo.fieldDescriptor().refType().equals(JavaType.type(VectorOperators.class));\n+                                assert flo.fieldDescriptor().name().equals(\"ADD\");\n+                                String operation = flo.fieldDescriptor().name();\n+                            }\n+                            else unsupported(\"operation expression\", reduceOp.toText());\n+                            String tempTag = nextTempTag();\n+                            SPIRVId temp_0 = nextId(tempTag + 0);\n+                            spirvBlock.add(new SPIRVOpCompositeExtract(elementType, temp_0, vector, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(0))));\n+                            for (int lane = 1; lane < laneCount(vectorType.getName()); lane++) {\n+                                SPIRVId temp = nextId(tempTag + lane);\n+                                SPIRVId element = nextId();\n+                                spirvBlock.add(new SPIRVOpCompositeExtract(elementType, element, vector, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(lane))));\n+                                if (elementType == getType(\"int\")) {\n+                                    spirvBlock.add(new SPIRVOpIAdd(elementType, temp, getId(tempTag + (lane - 1)), element));\n+                                }\n+                                else if (elementType == getType(\"float\")) {\n+                                    spirvBlock.add(new SPIRVOpFAdd(elementType, temp, getId(tempTag + (lane - 1)), element));\n+                                }\n+                                else unsupported(\"type\", elementType.getName());\n+                            }\n+                            addResult(call.result(), new SpirvResult(elementType, null, getId(tempTag + (laneCount(vectorType.getName()) - 1))));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"add\", IntVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodRef.method(IntVector.class, \"mul\", IntVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"add\", FloatVector.class, Vector.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"mul\", FloatVector.class, Vector.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult lhsResult = getResult(call.operands().get(0));\n+                            SPIRVId lhsType = lhsResult.type();\n+                            SPIRVId lhs = lhsResult.value();\n+                            SPIRVId rhs = getResult(call.operands().get(1)).value();\n+                            SPIRVId add = nextId();\n+                            if (call.callDescriptor().name().equals(\"add\")) {\n+                                spirvBlock.add(lhsType.getName().endsWith(\"int\") ? new SPIRVOpIAdd(lhsType, add, lhs, rhs) : new SPIRVOpFAdd(lhsType, add, lhs, rhs));\n+                            }\n+                            else if (call.callDescriptor().name().equals(\"mul\")) {\n+                                spirvBlock.add(lhsType.getName().endsWith(\"int\") ? new SPIRVOpIMul(lhsType, add, lhs, rhs) : new SPIRVOpFMul(lhsType, add, lhs, rhs));\n+                            }\n+                            addResult(call.result(), new SpirvResult(lhsType, null, add));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"fma\", FloatVector.class, Vector.class, Vector.class))) {\n+                            SPIRVId oclExtension = getId(\"oclExtension\");\n+                            SpirvResult aResult = getResult(call.operands().get(0));\n+                            SPIRVId vType = aResult.type();\n+                            SPIRVId a = aResult.value();\n+                            SPIRVId b = getResult(call.operands().get(1)).value();\n+                            SPIRVId c = getResult(call.operands().get(2)).value();\n+                            String vTypeStr = vType.getName();\n+                            assert vTypeStr.endsWith(\"float\");\n+                            SPIRVId result  = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = new SPIRVMultipleOperands<>(a, b, c);\n+                            spirvBlock.add(new SPIRVOpExtInst(vType, result, oclExtension, new SPIRVLiteralExtInstInteger(26, \"fma\"), operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"zero\", IntVector.class, VectorSpecies.class))\n+                             || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"zero\", FloatVector.class, VectorSpecies.class))) {\n+                            SpirvResult speciesResult = getResult(call.operands().get(0));\n+                            SPIRVId vType = spirvType(((ClassType)call.callDescriptor().refType()).toClassName());\n+                            String elementType = vectorElementType(vType).getName();\n+                            SPIRVId value = getId(elementType + \"_ZERO\");\n+                            int laneCount = laneCount(vType.getName());\n+                            assert laneCount == 8 || laneCount == 16;\n+                            SPIRVId vector = nextId();\n+                            SPIRVMultipleOperands<SPIRVId> operands = spirvOperands(value, laneCount);\n+                            spirvBlock.add(new SPIRVOpCompositeConstruct(vType, vector, operands));\n+                            addResult(call.result(), new SpirvResult(vType, null, vector));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(IntVector.class, \"lane\", int.class, int.class))\n+                              || call.callDescriptor().equals(MethodRef.method(FloatVector.class, \"lane\", float.class, int.class)))  {\n+                            SpirvResult lhsResult = getResult(call.operands().get(0));\n+                            SPIRVId lhsType = lhsResult.type();\n+                            SPIRVId lhs = lhsResult.value();\n+                            String vTypeStr = lhsType.getName();\n+                            SPIRVId vType = lhsResult.type();\n+                            SPIRVId elementType = vectorElementType(vType);\n+                            SPIRVId result = nextId();\n+                            Op laneOp = ((Op.Result)call.operands().get(1)).op();\n+                            assert laneOp instanceof SpirvOps.ConstantOp;\n+                            int lane = (int)((SpirvOps.ConstantOp)laneOp).value();\n+                            spirvBlock.add(new SPIRVOpCompositeExtract(elementType, result, lhsResult.value(), new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(lane))));\n+                            addResult(call.result(), new SpirvResult(elementType, null, result));\n+                        }\n+                        else if (call.callDescriptor().equals(MethodRef.method(VectorSpecies.class, \"length\", int.class))) {\n+                            addResult(call.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\"))); \/\/ TODO: remove hardcode\n+                        }\n+                        else unsupported(\"method\", call.callDescriptor());\n+                    }\n+                    case SpirvOps.ConstantOp cop -> {\n+                        SPIRVId type = spirvType(cop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        Object value = cop.value();\n+                        if (type == getType(\"int\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentInt(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"long\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentLong(new BigInteger(String.valueOf(value)))));\n+                        }\n+                        else if (type == getType(\"float\")) {\n+                            module.add(new SPIRVOpConstant(type, result, new SPIRVContextDependentFloat((float)value)));\n+                        }\n+                        else unsupported(\"type\", cop.resultType());\n+                        addResult(cop.result(), new SpirvResult(type, null, result));\n+                    }\n+                    case SpirvOps.ConvertOp scop -> {\n+                        SPIRVId toType = spirvType(scop.resultType().toString());\n+                        SPIRVId to = nextId();\n+                        SpirvResult valueResult = getResult(scop.operands().get(0));\n+                        SPIRVId from = valueResult.value();\n+                        SPIRVId fromType = valueResult.type();\n+                        if (isIntegerType(fromType)) {\n+                            if (isIntegerType(toType)) {\n+                                spirvBlock.add(new SPIRVOpSConvert(toType, to, from));\n+                            }\n+                            else if (isFloatType(toType)) {\n+                                spirvBlock.add(new SPIRVOpConvertSToF(toType, to, from));\n+                            }\n+                            else unsupported(\"conversion type\", scop.resultType());\n+                        }\n+                        else unsupported(\"conversion type\", scop.operands().get(0));\n+                        addResult(scop.result(), new SpirvResult(toType, null, to));\n+                    }\n+                    case SpirvOps.InBoundAccessChainOp iacop -> {\n+                        SPIRVId type = spirvType(iacop.resultType().toString());\n+                        SPIRVId result = nextId();\n+                        SPIRVId object = getResult(iacop.operands().get(0)).value();\n+                        SPIRVId index = getResult(iacop.operands().get(1)).value();\n+                        spirvBlock.add(new SPIRVOpInBoundsPtrAccessChain(type, result, object, index, new SPIRVMultipleOperands<>()));\n+                        addResult(iacop.result(), new SpirvResult(type, result, null));\n+                    }\n+                    case SpirvOps.FieldLoadOp flo -> {\n+                        if (flo.operands().size() > 0 && flo.operands().get(0).type().equals(JavaType.ofString(\"spirvdemo.GPU$Index\"))) {\n+                            SpirvResult result;\n+                            int group = -1;\n+                            int index = -1;\n+                            String fieldName = flo.fieldDescriptor().name();\n+                            switch(fieldName) {\n+                                case \"x\": group = 0; index = 0; break;\n+                                case \"y\": group = 0; index = 1; break;\n+                                case \"z\": group = 0; index = 2; break;\n+                                case \"w\": group = 1; index = 0; break;\n+                                case \"h\": group = 1; index = 1; break;\n+                                case \"d\": group = 1; index = 2; break;\n+                            }\n+                            switch (group) {\n+                                case 0: result = globalId(index, spirvBlock); break;\n+                                case 1: result = globalSize(index, spirvBlock); break;\n+                                default: throw new RuntimeException(\"Unknown Index field: \" + fieldName);\n+                            }\n+                            addResult(flo.result(), result);\n+                        }\n+                        else if (((JavaType)flo.resultType()).equals(JavaType.type(VectorSpecies.class))) {\n+                            addResult(flo.result(), new SpirvResult(getType(\"int\"), null, getConst(\"int_EIGHT\")));\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(VectorOperators.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else if (flo.fieldDescriptor().refType().equals(JavaType.type(ByteOrder.class))) {\n+                            \/\/ currently ignored\n+                        }\n+                        else unsupported(\"field load\", ((ClassType)flo.fieldDescriptor().refType()).toClassName() + \".\" + flo.fieldDescriptor().name());\n+                    }\n+                    case SpirvOps.BranchOp bop -> {\n+                        SPIRVId trueLabel = symbols.getLabel(bop.branch()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranch(trueLabel));\n+                    }\n+                    case SpirvOps.ConditionalBranchOp cbop -> {\n+                        SPIRVId test = getResult(cbop.operands().get(0)).value();\n+                        SPIRVId trueLabel = symbols.getLabel(cbop.trueBranch()).getResultId();\n+                        SPIRVId falseLabel = symbols.getLabel(cbop.falseBranch()).getResultId();\n+                        spirvBlock.add(new SPIRVOpBranchConditional(test, trueLabel, falseLabel, new SPIRVMultipleOperands<SPIRVLiteralInteger>()));\n+                    }\n+                    case SpirvOps.LtOp ltop -> {\n+                        SPIRVId lhs = getResult(ltop.operands().get(0)).value();\n+                        SPIRVId rhs = getResult(ltop.operands().get(1)).value();\n+                        SPIRVId boolType = getType(\"bool\");\n+                        SPIRVId result = nextId();\n+                        spirvBlock.add(new SPIRVOpSLessThan(boolType, result, lhs, rhs));\n+                        addResult(ltop.result(), new SpirvResult(boolType, null, result));\n+                    }\n+                    case SpirvOps.ReturnOp rop -> {\n+                        if (rop.operands().size() == 0) {\n+                            spirvBlock.add(new SPIRVOpReturn());\n+                        }\n+                        else {\n+                            SPIRVId returnValue = getResult(rop.operands().get(0)).value();\n+                            spirvBlock.add(new SPIRVOpReturnValue(returnValue));\n+                        }\n+                    }\n+                    default -> unsupported(\"op\", op.getClass());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void initModule() {\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Addresses()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Linkage()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Kernel()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int8()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int16()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Int64()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Vector16()));\n+        module.add(new SPIRVOpCapability(SPIRVCapability.Float16()));\n+        module.add(new SPIRVOpMemoryModel(SPIRVAddressingModel.Physical64(), SPIRVMemoryModel.OpenCL()));\n+\n+        \/\/ OpenCL extension provides built-in variables suitable for kernel programming\n+        \/\/ Import extention and declare fourn variables\n+        SPIRVId oclExtension = nextId(\"oclExtension\");\n+        module.add(new SPIRVOpExtInstImport(oclExtension, new SPIRVLiteralString(\"OpenCL.std\")));\n+\n+        SPIRVId globalInvocationId = nextId(\"globalInvocationId\");\n+        SPIRVId globalSize = nextId(\"globalSize\");\n+        SPIRVId subgroupSize = nextId(\"subgroupSize\");\n+        SPIRVId subgroupId = nextId(\"subgroupId\");\n+\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalInvocationId())));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalInvocationId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalInvocationId\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.GlobalSize())));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(globalSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInGlobalSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupSize())));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupSize, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupSize\"), SPIRVLinkageType.Import())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.BuiltIn(SPIRVBuiltIn.SubgroupId())));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.Constant()));\n+        module.add(new SPIRVOpDecorate(subgroupId, SPIRVDecoration.LinkageAttributes(new SPIRVLiteralString(\"spirv_BuiltInSubgroupId\"), SPIRVLinkageType.Import())));\n+\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalInvocationId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), globalSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupSize, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+        module.add(new SPIRVOpVariable(getType(\"ptrV3long\"), subgroupId, SPIRVStorageClass.Input(), new SPIRVOptionalOperand<>()));\n+    }\n+\n+    private SPIRVId spirvType(String javaType) {\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte\" -> getType(\"byte\");\n+            case \"short\" -> getType(\"short\");\n+            case \"int\" -> getType(\"int\");\n+            case \"long\" -> getType(\"long\");\n+            case \"float\" -> getType(\"float\");\n+            case \"double\" -> getType(\"double\");\n+            case \"int[]\" -> getType(\"int[]\");\n+            case \"float[]\" -> getType(\"float[]\");\n+            case \"double[]\" -> getType(\"double[]\");\n+            case \"long[]\" -> getType(\"long[]\");\n+            case \"bool\" -> getType(\"bool\");\n+            case \"spirvdemo.IntArray\" -> getType(\"int[]\");\n+            case \"spirvdemo.FloatArray\" -> getType(\"float[]\");\n+            case \"jdk.incubator.vector.IntVector\" -> spirvVectorType(\"IntVector\", 8);\n+            case \"jdk.incubator.vector.FloatVector\" -> spirvVectorType(\"FloatVector\", 8);\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Integer>\" -> getType(\"int\");\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Long>\" -> getType(\"long\");\n+            case \"jdk.incubator.vector.VectorSpecies<java.lang.Float>\" -> getType(\"int\");\n+            case \"VectorSpecies\" -> getType(\"int\");\n+            case \"void\" -> getType(\"void\");\n+            case \"spirvdemo.GPU$Index\" -> getType(\"ptrGPUIndex\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"ptrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvElementType(String javaType) {\n+        SPIRVId ans = switch(javaType) {\n+            case \"byte[]\" -> getType(\"byte\");\n+            case \"short[]\" -> getType(\"short\");\n+            case \"int[]\" -> getType(\"int\");\n+            case \"long[]\" -> getType(\"long\");\n+            case \"float[]\" -> getType(\"float\");\n+            case \"double[]\" -> getType(\"double\");\n+            case \"boolean[]\" -> getType(\"bool\");\n+            case \"spirvdemo.IntArray\" -> getType(\"int\");\n+            case \"spirvdemo.FloatArray\" -> getType(\"float\");\n+            case \"jdk.incubator.vector.LongVector\" -> getType(\"long\");\n+            case \"jdk.incubator.vector.FloatVector\" -> getType(\"float\");\n+            case \"IntVector\" -> getType(\"int\");\n+            case \"LongVector\" -> getType(\"long\");\n+            case \"FloatVector\" -> getType(\"float\");\n+            case \"java.lang.foreign.MemorySegment\" -> getType(\"byte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", javaType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorElementType(SPIRVId type) {\n+        SPIRVId ans = switch(type.getName()) {\n+            case \"v8int\" -> getType(\"int\");\n+            case \"v16int\" -> getType(\"int\");\n+            case \"v8long\" -> getType(\"long\");\n+            case \"v8float\" -> getType(\"float\");\n+            case \"v16float\" -> getType(\"float\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", type.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVariableType(SPIRVId spirvType) {\n+        SPIRVId ans = switch(spirvType.getName()) {\n+            case \"byte\" -> getType(\"ptrByte\");\n+            case \"short\" -> getType(\"ptrShort\");\n+            case \"int\" -> getType(\"ptrInt\");\n+            case \"long\" -> getType(\"ptrLong\");\n+            case \"float\" -> getType(\"ptrFloat\");\n+            case \"double\" -> getType(\"ptrDouble\");\n+            case \"boolean\" -> getType(\"ptrBool\");\n+            case \"int[]\" -> getType(\"ptrInt[]\");\n+            case \"long[]\" -> getType(\"ptrLong[]\");\n+            case \"float[]\" -> getType(\"ptrFloat[]\");\n+            case \"double[]\" -> getType(\"ptrDouble[]\");\n+            case \"v8int\" -> getType(\"ptrV8int\");\n+            case \"v16int\" -> getType(\"ptrV16int\");\n+            case \"v8long\" -> getType(\"ptrV8long\");\n+            case \"v8float\" -> getType(\"ptrV8float\");\n+            case \"v16float\" -> getType(\"ptrV16float\");\n+            case \"ptrGPUIndex\" -> getType(\"ptrPtrGPUIndex\");\n+            case \"ptrByte\" -> getType(\"ptrPtrByte\");\n+            default -> null;\n+        };\n+        if (ans == null) unsupported(\"type\", spirvType.getName());\n+        return ans;\n+    }\n+\n+    private SPIRVId spirvVectorType(String javaVectorType, int vectorLength) {\n+        String prefix = \"v\" + vectorLength;\n+        String elementType = spirvElementType(javaVectorType).getName();\n+        return getType(prefix + elementType);\n+    }\n+\n+    private int alignment(String spirvType) {\n+        int ans = switch(spirvType) {\n+            case \"byte\" -> 1;\n+            case \"short\" -> 2;\n+            case \"int\" -> 4;\n+            case \"long\" -> 8;\n+            case \"float\" -> 4;\n+            case \"double\" -> 8;\n+            case \"boolean\" -> 1;\n+            case \"v8int\" -> 32;\n+            case \"v16int\" -> 64;\n+            case \"v8long\" -> 64;\n+            case \"v8float\" -> 32;\n+            case \"v16float\" -> 64;\n+            case \"ptrGPUIndex\" -> 32;\n+            case \"int[]\" -> 8;\n+            case \"long[]\" -> 8;\n+            case \"float[]\" -> 8;\n+            case \"double[]\" -> 8;\n+            case \"ptrByte\" -> 8;\n+            case \"ptrInt\" -> 8;\n+            case \"ptrInt[]\" -> 8;\n+            case \"ptrLong\" -> 8;\n+            case \"ptrLong[]\" -> 8;\n+            case \"ptrFloat\" -> 8;\n+            case \"ptrFloat[]\" -> 8;\n+            case \"ptrV8int\" -> 8;\n+            case \"ptrV8float\" -> 8;\n+            case \"ptrPtrGPUIndex\" -> 8;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", spirvType);\n+        return ans;\n+    }\n+\n+    private int laneCount(String vectorType) {\n+        int ans = switch(vectorType) {\n+            case \"v8int\" -> 8;\n+            case \"v8long\" -> 8;\n+            case \"v8float\" -> 8;\n+            case \"v16int\" -> 16;\n+            case \"v16float\" -> 16;\n+            default -> 0;\n+        };\n+        if (ans == 0) unsupported(\"type\", vectorType);\n+        return ans;\n+    }\n+\n+    private SPIRVId vectorExponent(String vectorType) {\n+        SPIRVId ans = null;\n+        switch(vectorType) {\n+            case \"v8int\" -> ans = getId(\"int_THREE\");\n+            case \"v8long\" -> ans = getId(\"int_THREE\");\n+            case \"v8float\" -> ans = getId(\"int_THREE\");\n+            case \"v16int\" -> ans = getId(\"int_FOUR\");\n+            case \"v16float\" -> ans = getId(\"int_FOUR\");\n+            default -> unsupported(\"type\", vectorType);\n+        };\n+        return ans;\n+    }\n+\n+    private Set<String> moduleTypes = new HashSet<>();\n+\n+    private SPIRVId getType(String name) {\n+        if (!moduleTypes.contains(name)) {\n+            switch (name) {\n+                case \"void\" -> module.add(new SPIRVOpTypeVoid(nextId(name)));\n+                case \"bool\" -> module.add(new SPIRVOpTypeBool(nextId(name)));\n+                case \"byte\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(8), new SPIRVLiteralInteger(0)));\n+                case \"short\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(16), new SPIRVLiteralInteger(0)));\n+                case \"int\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(32), new SPIRVLiteralInteger(0)));\n+                case \"long\" -> module.add(new SPIRVOpTypeInt(nextId(name), new SPIRVLiteralInteger(64), new SPIRVLiteralInteger(0)));\n+                case \"float\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(32)));\n+                case \"double\" -> module.add(new SPIRVOpTypeFloat(nextId(name), new SPIRVLiteralInteger(64)));\n+                case \"ptrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrInt\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int\")));\n+                case \"ptrLong\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long\")));\n+                case \"ptrFloat\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float\")));\n+                case \"short[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"short\")));\n+                case \"int[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"int\")));\n+                case \"long[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"long\")));\n+                case \"float[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"float\")));\n+                case \"double[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"double\")));\n+                case \"boolean[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"boolean\")));\n+                case \"ptrInt[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"int[]\")));\n+                case \"ptrLong[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"long[]\")));\n+                case \"ptrFloat[]\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"float[]\")));\n+                case \"spirvdemo.GPUIndex\" -> module.add(new SPIRVOpTypeStruct(nextId(name), new SPIRVMultipleOperands<>(getType(\"long\"), getType(\"long\"), getType(\"long\"))));\n+                case \"ptrGPUIndex\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"spirvdemo.GPUIndex\")));\n+                case \"ptrCrossGroupByte\"-> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.CrossWorkgroup(), getType(\"byte\")));\n+                case \"ptrPtrGPUIndex\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrGPUIndex\")));\n+                case \"ptrPtrByte\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrByte\")));\n+                case \"v3long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(3)));\n+                case \"v8int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(8)));\n+                case \"v8long\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"long\"), new SPIRVLiteralInteger(8)));\n+                case \"v16int\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"int\"), new SPIRVLiteralInteger(16)));\n+                case \"v8float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(8)));\n+                case \"v16float\" -> module.add(new SPIRVOpTypeVector(nextId(name), getType(\"float\"), new SPIRVLiteralInteger(16)));\n+                case \"ptrV3long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Input(), getType(\"v3long\")));\n+                case \"ptrV8long\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8long\")));\n+                case \"ptrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8int\")));\n+                case \"ptrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16int\")));\n+                case \"ptrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v8float\")));\n+                case \"ptrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"v16float\")));\n+                case \"ptrPtrV8int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8int\")));\n+                case \"ptrPtrV16int\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16int\")));\n+                case \"ptrPtrV8float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV8float\")));\n+                case \"ptrPtrV16float\" -> module.add(new SPIRVOpTypePointer(nextId(name), SPIRVStorageClass.Function(), getType(\"ptrV16float\")));\n+                default -> unsupported(\"type\", name);\n+            }\n+            moduleTypes.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private Set<String> moduleConstants = new HashSet<>();\n+\n+    private SPIRVId getConst(String name) {\n+        if (!moduleConstants.contains(name)) {\n+            switch (name) {\n+                case \"int_ZERO\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_ZERO\"), new SPIRVContextDependentInt(new BigInteger(\"0\"))));\n+                case \"int_ONE\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_ONE\"), new SPIRVContextDependentInt(new BigInteger(\"1\"))));\n+                case \"int_TWO\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_TWO\"), new SPIRVContextDependentInt(new BigInteger(\"2\"))));\n+                case \"int_EIGHT\" -> module.add(new SPIRVOpConstant(getType(\"int\"), nextId(\"int_EIGHT\"), new SPIRVContextDependentInt(new BigInteger(\"8\"))));\n+                default -> unsupported(\"constant\", name);\n+            }\n+            moduleConstants.add(name);\n+        }\n+        return getId(name);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(int align) {\n+        return new SPIRVOptionalOperand<>(SPIRVMemoryAccess.Aligned(new SPIRVLiteralInteger(align)));\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> align(String type) {\n+        return align(alignment(type));\n+    }\n+\n+    private SPIRVMultipleOperands<SPIRVId> spirvOperands(SPIRVId value, int count) {\n+        SPIRVId[] values = new SPIRVId[count];\n+        Arrays.fill(values, value);\n+        return new SPIRVMultipleOperands<>(values);\n+    }\n+\n+    private SPIRVOptionalOperand<SPIRVMemoryAccess> none() {\n+        return new SPIRVOptionalOperand<>();\n+    }\n+\n+    private SpirvResult globalSize(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalSizeId = getId(\"globalSize\");\n+        SPIRVId globalSizes = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalSizes, globalSizeId, align(32)));\n+        SPIRVId globalSize = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, globalSize, globalSizes, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        return new SpirvResult(longType, null, globalSize);\n+    }\n+\n+    private SpirvResult globalId(int index, SPIRVBlock spirvBlock) {\n+        SPIRVId longType = getType(\"long\");\n+        SPIRVId v3long = getId(\"v3long\");\n+        SPIRVId globalInvocationId = getId(\"globalInvocationId\");\n+        SPIRVId globalIds = nextId();\n+        spirvBlock.add(new SPIRVOpLoad(v3long, globalIds, globalInvocationId, align(32)));\n+        SPIRVId globalIndex = nextId();\n+        spirvBlock.add(new SPIRVOpCompositeExtract(longType, globalIndex, globalIds, new SPIRVMultipleOperands<>(new SPIRVLiteralInteger(index))));\n+        return new SpirvResult(longType, null, globalIndex);\n+    }\n+\n+    private SPIRVId nextId() {\n+        return module.getNextId();\n+    }\n+\n+    private SPIRVId nextId(String name) {\n+        SPIRVId ans = nextId();\n+        ans.setName(name);\n+        symbols.putId(name, ans);\n+        module.add(new SPIRVOpName(ans, new SPIRVLiteralString(name)));\n+        return ans;\n+    }\n+\n+    private static int counter = 0;\n+\n+    private String nextTempTag() {\n+        counter++;\n+        return \"temp_\" + counter + \"_\";\n+    }\n+\n+    private boolean isIntegerType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"short\") || name.equals(\"int\") || name.equals(\"long\");\n+    }\n+\n+    private boolean isFloatType(SPIRVId type) {\n+        String name = type.getName();\n+        return name.equals(\"float\") || name.equals(\"double\");\n+    }\n+\n+    private boolean isVectorSpecies(String javaType) {\n+        return javaType.equals(\"VectorSpecies\");\n+    }\n+\n+    private boolean isVectorType(String javaType) {\n+        return javaType.equals(\"IntVector\") || javaType.equals(\"FloatVector\");\n+    }\n+\n+    private void addId(String name, SPIRVId id) {\n+        symbols.putId(name, id);\n+    }\n+\n+    private SPIRVId getId(String name) {\n+        SPIRVId ans = symbols.getId(name);\n+        assert ans != null : name + \" not found\";\n+        return ans;\n+    }\n+\n+    private SPIRVId getIdOrNull(String name) {\n+        return symbols.getId(name);\n+    }\n+\n+    private static Object map(Function<Object, Boolean> test, Object... args) {\n+        int len = args.length;\n+        assert len >= 2 && len % 2 == 0;\n+        int pairs = len \/ 2;\n+        for (int i = 0; i < pairs; i++) {\n+            if (test.apply(args[i])) return args[i + pairs];\n+        }\n+        throw new RuntimeException(\"No match: \" + args[0]);\n+    }\n+\n+    private void unsupported(String message, Object value) {\n+        throw new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private void addResult(Value value, SpirvResult result) {\n+        assert symbols.getResult(value) == null : \"result already present\";\n+        symbols.putResult(value, result);\n+    }\n+\n+    private SpirvResult getResult(Value value) {\n+        return symbols.getResult(value);\n+    }\n+\n+    private static class Symbols {\n+        private final HashMap<Value, SpirvResult> results;\n+        private final HashMap<String, SPIRVId> ids;\n+        private final HashMap<Block, SPIRVBlock> blocks;\n+        private final HashMap<Block, SPIRVOpLabel> labels;\n+\n+        public Symbols() {\n+            this.results = new HashMap<>();\n+            this.ids = new HashMap<>();\n+            this.blocks = new HashMap<>();\n+            this.labels = new HashMap<>();\n+        }\n+\n+        public void putId(String name, SPIRVId id) {\n+            ids.put(name, id);\n+        }\n+\n+        public SPIRVId getId(String name) {\n+            return ids.get(name);\n+        }\n+\n+        public void putBlock(Block block, SPIRVBlock spirvBlock) {\n+            blocks.put(block, spirvBlock);\n+        }\n+\n+        public SPIRVBlock getBlock(Block block) {\n+            return blocks.get(block);\n+        }\n+\n+        public void putLabel(Block block, SPIRVOpLabel spirvLabel) {\n+            labels.put(block, spirvLabel);\n+        }\n+\n+        public SPIRVOpLabel getLabel(Block block) {\n+            return labels.get(block);\n+        }\n+\n+        public void putResult(Value value, SpirvResult result) {\n+            results.put(value, result);\n+        }\n+\n+        public SpirvResult getResult(Value value) {\n+            return results.get(value);\n+        }\n+\n+        public String toString() {\n+            return String.format(\"results %s\\n\\nids %s\\n\\nblocks %s\\nlabels %s\\n\", results.keySet(), ids.keySet(), blocks.keySet(), labels.keySet());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvModuleGenerator.java","additions":1030,"deletions":0,"binary":false,"changes":1030,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public abstract class SpirvOp extends Op {\n+    private final TypeElement type;\n+\n+    SpirvOp(String opName) {\n+        super(opName, List.of());\n+        this.type = JavaType.VOID;\n+    }\n+\n+    SpirvOp(String opName, TypeElement type, List<Value> operands) {\n+        super(opName, operands);\n+        this.type = type;\n+    }\n+\n+    SpirvOp(String opName, TypeElement type, List<Value> operands, Map<String, Object> attributes) {\n+        super(opName, operands);\n+        this.type = type;\n+    }\n+\n+    SpirvOp(SpirvOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.type = that.type;\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return type;\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOp.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,664 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public class SpirvOps {\n+    private static final String NAME_PREFIX = \"spirv.\";\n+\n+    public static final class ModuleOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"module\";\n+\n+        private final String name;\n+\n+        public ModuleOp(String moduleName) {\n+            super(OPNAME);\n+            this.name = moduleName;\n+        }\n+\n+        public ModuleOp(ModuleOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.name = that.name;\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc);\n+        }\n+    }\n+\n+    public static final class LoadOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"load\";\n+\n+        public LoadOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public LoadOp(LoadOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LoadOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FieldLoadOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"fieldload\";\n+        private final FieldRef fieldDesc;\n+\n+        public FieldLoadOp(TypeElement resultType, FieldRef fieldRef, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+            this.fieldDesc = fieldRef;\n+        }\n+\n+        public FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.fieldDesc = that.fieldDesc;\n+        }\n+\n+        @Override\n+        public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FieldLoadOp(this, cc);\n+        }\n+\n+        public FieldRef fieldDescriptor() {\n+            return fieldDesc;\n+        }\n+    }\n+\n+    public static final class StoreOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"store\";\n+\n+        public StoreOp(Value dest, Value value) {\n+            super(NAME, JavaType.VOID, List.of(dest, value));\n+        }\n+\n+        public StoreOp(StoreOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StoreOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StoreOp(this, cc);\n+        }\n+    }\n+\n+    public static final class CallOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"call\";\n+        private MethodRef descriptor;\n+\n+        public CallOp(MethodRef descriptor, List<Value> operands) {\n+            super(nameString(descriptor), descriptor.type().returnType(), operands);\n+            this.descriptor = descriptor;\n+        }\n+\n+        public CallOp(CallOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CallOp(this, cc);\n+        }\n+\n+        public MethodRef callDescriptor() {\n+            return descriptor;\n+        }\n+\n+        private static String nameString(MethodRef descriptor) {\n+            return OPNAME + \" @\" + descriptor.refType() + \"::\" + descriptor.name();\n+        }\n+    }\n+\n+    public static final class ArrayLengthOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"arraylength\";\n+\n+        public ArrayLengthOp(TypeElement resultType, List<Value> operands) {\n+            super(NAME, resultType, operands);\n+        }\n+\n+        public ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ConstantOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"constant\";\n+        private final Object value;\n+\n+        public ConstantOp(TypeElement resultType, Object value) {\n+                super(OPNAME, resultType, List.of());\n+                this.value = value;\n+        }\n+\n+        public ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+    }\n+\n+    public static final class ConvertOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"sconvert\";\n+\n+        public ConvertOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public ConvertOp(ConvertOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConvertOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvertOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IAddOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"iadd\";\n+\n+        public IAddOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IAddOp(IAddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IAddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IAddOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FAddOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fadd\";\n+\n+        public FAddOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FAddOp(FAddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FAddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FAddOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ISubOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"isub\";\n+\n+        public ISubOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public ISubOp(ISubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ISubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ISubOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FSubOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fsub\";\n+\n+        public FSubOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FSubOp(FSubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FSubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FSubOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IMulOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"imul\";\n+\n+        public IMulOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IMulOp(IMulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IMulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IMulOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FMulOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fmul\";\n+\n+        public FMulOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FMulOp(FMulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FMulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FMulOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IDivOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"idiv\";\n+\n+        public IDivOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IDivOp(IDivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IDivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IDivOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FDivOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fdiv\";\n+\n+        public FDivOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FDivOp(FDivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FDivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FDivOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ModOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"mod\";\n+\n+        public ModOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public ModOp(ModOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ModOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModOp(this, cc);\n+        }\n+    }\n+\n+    public static final class IEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"iequal\";\n+\n+        public IEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public IEqualOp(IEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public IEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new IEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fequal\";\n+\n+        public FEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FEqualOp(FEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class INotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"inotequal\";\n+\n+        public INotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public INotEqualOp(INotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public INotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new INotEqualOp(this, cc);\n+        }\n+    }\n+\n+\n+    public static final class FNotEqualOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"fnotequal\";\n+\n+        public FNotEqualOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public FNotEqualOp(FNotEqualOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FNotEqualOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FNotEqualOp(this, cc);\n+        }\n+    }\n+\n+    public static final class LtOp extends SpirvOp {\n+        public static final String NAME = NAME_PREFIX + \"lt\";\n+\n+        public LtOp(TypeElement resultType, List<Value> operands) {\n+                super(NAME, resultType, operands);\n+        }\n+\n+        public LtOp(LtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LtOp(this, cc);\n+        }\n+    }\n+\n+    public static final class BranchOp extends SpirvOp implements Op.BlockTerminating {\n+        public static final String NAME = NAME_PREFIX + \"br\";\n+        private final Block.Reference successor;\n+\n+        public BranchOp(Block.Reference successor) {\n+            super(NAME, JavaType.VOID, List.of());\n+            this.successor = successor;\n+        }\n+\n+        public BranchOp(BranchOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.successor = that.successor;\n+        }\n+\n+        @Override\n+        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BranchOp(this, cc);\n+        }\n+\n+        public Block branch() {\n+            return successor.targetBlock();\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(successor);\n+        }\n+    }\n+\n+    public static final class ConditionalBranchOp extends SpirvOp implements Op.BlockTerminating {\n+        public static final String NAME = NAME_PREFIX + \"brcond\";\n+        private final Block.Reference trueBlock;\n+        private final Block.Reference falseBlock;\n+\n+        public ConditionalBranchOp(Block.Reference trueBlock, Block.Reference falseBlock, List<Value> operands) {\n+                super(NAME, JavaType.VOID, operands);\n+                this.trueBlock = trueBlock;\n+                this.falseBlock = falseBlock;\n+        }\n+\n+        public ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.trueBlock = that.trueBlock;\n+            this.falseBlock = that.falseBlock;\n+        }\n+\n+        @Override\n+        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConditionalBranchOp(this, cc);\n+        }\n+\n+        public Block trueBranch() {\n+            return trueBlock.targetBlock();\n+        }\n+\n+        public Block falseBranch() {\n+            return falseBlock.targetBlock();\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(trueBlock, falseBlock);\n+        }\n+    }\n+\n+    public static final class VariableOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"variable\";\n+        private final String varName;\n+        private final TypeElement varType;\n+\n+        public VariableOp(String varName, TypeElement type, TypeElement varType) {\n+            super(OPNAME + \" @\" + varName, type, List.of());\n+            this.varName = varName;\n+            this.varType = varType;\n+        }\n+\n+        public VariableOp(VariableOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.varName = that.varName;\n+            this.varType = that.varType;\n+        }\n+\n+        @Override\n+        public VariableOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VariableOp(this, cc);\n+        }\n+\n+        public TypeElement varType() {\n+            return varType;\n+        }\n+\n+        public String varName() {\n+            return varName;\n+        }\n+    }\n+\n+    public static final class CompositeExtractOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"compositeExtract\";\n+\n+        public CompositeExtractOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public CompositeExtractOp(CompositeExtractOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public CompositeExtractOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CompositeExtractOp(this, cc);\n+        }\n+    }\n+\n+    public static final class InBoundAccessChainOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"inBoundAccessChain\";\n+\n+        public InBoundAccessChainOp(TypeElement resultType, List<Value> operands) {\n+                super(OPNAME, resultType, operands);\n+        }\n+\n+        public InBoundAccessChainOp(InBoundAccessChainOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public InBoundAccessChainOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InBoundAccessChainOp(this, cc);\n+        }\n+    }\n+\n+    public static final class ReturnOp extends SpirvOp implements Op.Terminating {\n+        public static final String OPNAME = \"return\";\n+\n+        public ReturnOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FunctionParameterOp extends SpirvOp {\n+        public static final String OPNAME = NAME_PREFIX + \"function parameter\";\n+\n+        public FunctionParameterOp(TypeElement resultType, List<Value> operands) {\n+            super(OPNAME, resultType, operands);\n+        }\n+\n+        public FunctionParameterOp(FunctionParameterOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public FunctionParameterOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FunctionParameterOp(this, cc);\n+        }\n+    }\n+\n+    public static final class FuncOp extends SpirvOp implements Op.Invokable {\n+        public static enum Control {\n+            INLINE,\n+            DONTINLINE,\n+            PURE,\n+            CONST,\n+            NONE\n+        }\n+\n+        public static final String OPNAME = NAME_PREFIX + \"function\";\n+        private final String functionName;\n+        private final FunctionType functionType;\n+        private final Body body;\n+\n+\n+        public FuncOp(String name, FunctionType functionType, Body.Builder builder) {\n+            super(OPNAME + \"_\" + name);\n+            this.functionName = name;\n+            this.functionType = functionType;\n+            this.body = builder.build(this);\n+        }\n+\n+        public FuncOp(FuncOp that, CopyContext cc) {\n+            super(that, cc);\n+            this.functionName = that.functionName;\n+            this.functionType = that.functionType;\n+            this.body = that.body;\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, cc);\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public String functionName() {\n+            return functionName;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return functionType;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvOps.java","additions":664,"deletions":0,"binary":false,"changes":664,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.code.TypeElement;\n+\n+public abstract sealed class SpirvType implements TypeElement permits PointerType, StorageType {\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/SpirvType.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public sealed abstract class StorageType extends SpirvType\n+    permits StorageType.Input, StorageType.Workgroup, StorageType.CrossWorkgroup, StorageType.Private, StorageType.Function {\n+\n+    public static final Input INPUT = new Input();\n+    public static final Workgroup WORKGROUP = new Workgroup();\n+    public static final CrossWorkgroup CROSSWORKGROUP= new CrossWorkgroup();\n+    public static final Private PRIVATE = new Private();\n+    public static final Function FUNCTION = new Function();\n+\n+    protected final String NAME;\n+\n+    protected StorageType(String name) {\n+        this.NAME = name;\n+    }\n+\n+    static final class Input extends StorageType {\n+        protected Input(){\n+            super(\"Input\");\n+        }\n+    }\n+\n+    static final class Workgroup extends StorageType {\n+        protected Workgroup() {\n+            super(\"Workgroup\");\n+        }\n+    }\n+\n+    static final class CrossWorkgroup extends StorageType\n+    {\n+        protected CrossWorkgroup() {\n+            super(\"CrossWorkgroup\");\n+        }\n+    }\n+\n+    static final class Private extends StorageType\n+    {\n+        protected Private() {\n+            super(\"Private\");\n+        }\n+    }\n+\n+    static final class Function extends StorageType\n+    {\n+        protected Function() {\n+            super(\"Function\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj != null && obj.getClass() != this.getClass();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(NAME);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/StorageType.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public class TranslateToSpirvModel  {\n+    private Map<Block, Block.Builder> blockMap;    \/\/ Java block to spirv block builder\n+    private Map<Value, Value> valueMap;            \/\/ Java model Value to Spirv model Value\n+\n+    public static SpirvOps.FuncOp translateFunction(CoreOps.FuncOp func) {\n+        CoreOps.FuncOp lowFunc = lowerMethod(func);\n+        TranslateToSpirvModel instance = new TranslateToSpirvModel();\n+        Body.Builder bodyBuilder = instance.translateBody(lowFunc.body(), lowFunc, null);\n+        return new SpirvOps.FuncOp(lowFunc.funcName(), lowFunc.invokableType(), bodyBuilder);\n+    }\n+\n+    private TranslateToSpirvModel() {\n+        blockMap = new HashMap<>();\n+        valueMap = new HashMap<>();\n+    }\n+\n+    private Body.Builder translateBody(Body body, Op parentOp, Body.Builder parentBody) {\n+        Body.Builder bodyBuilder = Body.Builder.of(parentBody, body.bodyType());\n+        Block.Builder spirvBlock = bodyBuilder.entryBlock();\n+        blockMap.put(body.entryBlock(), spirvBlock);\n+        List<Block> blocks = body.blocks();\n+        \/\/ map Java blocks to spirv blocks\n+        for (Block b : blocks.subList(1, blocks.size()))  {\n+            Block.Builder loweredBlock = spirvBlock.block(b.parameterTypes());\n+            blockMap.put(b, loweredBlock);\n+            spirvBlock = loweredBlock;\n+        }\n+        \/\/ map entry block parameters to spirv function parameter\n+        spirvBlock = bodyBuilder.entryBlock();\n+        List<SpirvOp> paramOps = new ArrayList<>();\n+        List<SpirvOps.VariableOp> varOps = new ArrayList<>();\n+        Block entryBlock = body.entryBlock();\n+        int paramCount = entryBlock.parameters().size();\n+        for (int i = 0; i < paramCount; i++) {\n+            Block.Parameter bp = entryBlock.parameters().get(i);\n+            assert entryBlock.ops().get(i) instanceof CoreOps.VarOp;\n+            SpirvOp funcParam = new SpirvOps.FunctionParameterOp(bp.type(), List.of());\n+            spirvBlock.op(funcParam);\n+            valueMap.put(bp, funcParam.result());\n+            paramOps.add(funcParam);\n+        }\n+        \/\/ SPIR-V Variable ops must be the first ops in a function's entry block and do not include initialization.\n+        \/\/ Emit all SPIR-V Variable ops first and emit initializing stores afterward, at the CR model VarOp position.\n+        for (int i = 0; i < paramCount; i++) {\n+            CoreOps.VarOp jvop = (CoreOps.VarOp)entryBlock.ops().get(i);\n+            TypeElement resultType = new PointerType(jvop.varType(), StorageType.CROSSWORKGROUP);\n+            SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varType());\n+            spirvBlock.op(svop);\n+            valueMap.put(jvop.result(), svop.result());\n+            varOps.add(svop);\n+        }\n+        \/\/ add non-function-parameter variables\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            spirvBlock = blockMap.get(block);\n+            List<Op> ops = block.ops();\n+            for (int i = (bi == 0 ? paramCount : 0); i < ops.size(); i++) {\n+                if (bi > 0) spirvBlock = blockMap.get(block);\n+                Op op = ops.get(i);\n+                if (op instanceof CoreOps.VarOp jvop) {\n+                    TypeElement resultType = new PointerType(jvop.varType(), StorageType.CROSSWORKGROUP);\n+                    SpirvOps.VariableOp svop = new SpirvOps.VariableOp((String)jvop.attributes().get(\"\"), resultType, jvop.varType());\n+                    bodyBuilder.entryBlock().op(svop);\n+                    valueMap.put(jvop.result(), svop.result());\n+                    varOps.add(svop);\n+                }\n+            }\n+        }\n+        for (int bi = 0; bi < body.blocks().size(); bi++)  {\n+            Block block = body.blocks().get(bi);\n+            spirvBlock = blockMap.get(block);\n+            for (Op op : block.ops()) {\n+                switch (op) {\n+                    case CoreOps.ReturnOp rop -> {\n+                        spirvBlock.op(new SpirvOps.ReturnOp(rop.resultType(), mapOperands(rop)));\n+                    }\n+                    case CoreOps.VarOp vop -> {\n+                        Value dest = valueMap.get(vop.result());\n+                        Value value = valueMap.get(vop.operands().get(0));\n+                        \/\/ init variable here; declaration has been moved to top of function\n+                        spirvBlock.op(new SpirvOps.StoreOp(dest, value));\n+                    }\n+                    case CoreOps.VarAccessOp.VarLoadOp vlo -> {\n+                        List<Value> operands = mapOperands(vlo);\n+                        SpirvOps.LoadOp load = new SpirvOps.LoadOp(vlo.resultType(), operands);\n+                        spirvBlock.op(load);\n+                        valueMap.put(vlo.result(), load.result());\n+                    }\n+                    case CoreOps.VarAccessOp.VarStoreOp vso -> {\n+                        Value dest = valueMap.get(vso.varOp().result());\n+                        Value value = valueMap.get(vso.operands().get(1));\n+                        spirvBlock.op(new SpirvOps.StoreOp(dest, value));\n+                    }\n+                    case CoreOps.ArrayAccessOp.ArrayLoadOp alo -> {\n+                        Value array = valueMap.get(alo.operands().get(0));\n+                        Value index = valueMap.get(alo.operands().get(1));\n+                        TypeElement arrayType = array.type();\n+                        SpirvOps.ConvertOp convert = new SpirvOps.ConvertOp(JavaType.type(long.class), List.of(index));\n+                        spirvBlock.op(new SpirvOps.LoadOp(arrayType, List.of(array)));\n+                        spirvBlock.op(convert);\n+                        SpirvOp ibac = new SpirvOps.InBoundAccessChainOp(arrayType, List.of(array, convert.result()));\n+                        spirvBlock.op(ibac);\n+                        SpirvOp load = new SpirvOps.LoadOp(alo.resultType(), List.of(ibac.result()));\n+                        spirvBlock.op(load);\n+                        valueMap.put(alo.result(), load.result());\n+                    }\n+                    case CoreOps.ArrayAccessOp.ArrayStoreOp aso -> {\n+                        Value array = valueMap.get(aso.operands().get(0));\n+                        Value index = valueMap.get(aso.operands().get(1));\n+                        TypeElement arrayType = array.type();\n+                        SpirvOp ibac = new SpirvOps.InBoundAccessChainOp(arrayType, List.of(array, index));\n+                        spirvBlock.op(ibac);\n+                        spirvBlock.op(new SpirvOps.StoreOp(ibac.result(), valueMap.get(aso.operands().get(2))));\n+                    }\n+                    case CoreOps.ArrayLengthOp alo -> {\n+                        Op len = new SpirvOps.ArrayLengthOp(JavaType.INT, List.of(valueMap.get(alo.operands().get(0))));\n+                        spirvBlock.op(len);\n+                        valueMap.put(alo.result(), len.result());\n+                    }\n+                    case CoreOps.AddOp aop -> {\n+                        TypeElement type = aop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(aop);\n+                        SpirvOp addOp;\n+                        if (isIntegerType(type)) addOp = new SpirvOps.IAddOp(type, operands);\n+                        else if (isFloatType(type)) addOp = new SpirvOps.FAddOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(addOp);\n+                        valueMap.put(aop.result(), addOp.result());\n+                     }\n+                    case CoreOps.SubOp sop -> {\n+                        TypeElement  type = sop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(sop);\n+                        SpirvOp subOp;\n+                        if (isIntegerType(type)) subOp = new SpirvOps.ISubOp(type, operands);\n+                        else if (isFloatType(type)) subOp = new SpirvOps.FSubOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(subOp);\n+                        valueMap.put(sop.result(), subOp.result());\n+                     }\n+                    case CoreOps.MulOp mop -> {\n+                        TypeElement type = mop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(mop);\n+                        SpirvOp mulOp;\n+                        if (isIntegerType(type)) mulOp = new SpirvOps.IMulOp(type, operands);\n+                        else if (isFloatType(type)) mulOp = new SpirvOps.FMulOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(mulOp);\n+                        valueMap.put(mop.result(), mulOp.result());\n+                    }\n+                    case CoreOps.DivOp dop -> {\n+                        TypeElement type = dop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(dop);\n+                        SpirvOp divOp;\n+                        if (isIntegerType(type)) divOp = new SpirvOps.IDivOp(type, operands);\n+                        else if (isFloatType(type)) divOp = new SpirvOps.FDivOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(divOp);\n+                        valueMap.put(dop.result(), divOp.result());\n+                    }\n+                    case CoreOps.ModOp mop -> {\n+                        TypeElement type = mop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(mop);\n+                        SpirvOp modOp = new SpirvOps.ModOp(type, operands);\n+                        spirvBlock.op(modOp);\n+                        valueMap.put(mop.result(), modOp.result());\n+                    }\n+                    case CoreOps.EqOp eqop -> {\n+                        TypeElement type = eqop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(eqop);\n+                        SpirvOp seqop;\n+                        if (isIntegerType(type)) seqop = new SpirvOps.IEqualOp(type, operands);\n+                        else if (isFloatType(type)) seqop = new SpirvOps.FEqualOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(seqop);\n+                        valueMap.put(eqop.result(), seqop.result());\n+                    }\n+                    case CoreOps.NeqOp neqop -> {\n+                        TypeElement type = neqop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(neqop);\n+                        SpirvOp sneqop;\n+                        if (isIntegerType(type)) sneqop = new SpirvOps.INotEqualOp(type, operands);\n+                        else if (isFloatType(type)) sneqop = new SpirvOps.FNotEqualOp(type, operands);\n+                        else throw unsupported(\"type\", type);\n+                        spirvBlock.op(sneqop);\n+                        valueMap.put(neqop.result(), sneqop.result());\n+                    }\n+                    case CoreOps.LtOp ltop -> {\n+                        TypeElement type = ltop.operands().get(0).type();\n+                        List<Value> operands = mapOperands(ltop);\n+                        SpirvOp sltop = new SpirvOps.LtOp(type, operands);\n+                        spirvBlock.op(sltop);\n+                        valueMap.put(ltop.result(), sltop.result());\n+                    }\n+                    case CoreOps.InvokeOp inv -> {\n+                        List<Value> operands = mapOperands(inv);\n+                        SpirvOp spirvCall = new SpirvOps.CallOp(inv.invokeDescriptor(), operands);\n+                        spirvBlock.op(spirvCall);\n+                        valueMap.put(inv.result(), spirvCall.result());\n+                    }\n+                    case CoreOps.ConstantOp cop -> {\n+                        SpirvOp scop = new SpirvOps.ConstantOp(cop.resultType(), cop.value());\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n+                    case CoreOps.ConvOp cop -> {\n+                        List<Value> operands = mapOperands(cop);\n+                        SpirvOp scop = new SpirvOps.ConvertOp(cop.resultType(), operands);\n+                        spirvBlock.op(scop);\n+                        valueMap.put(cop.result(), scop.result());\n+                    }\n+                    case CoreOps.FieldAccessOp.FieldLoadOp flo -> {\n+                        SpirvOp load = new SpirvOps.FieldLoadOp(flo.resultType(), flo.fieldDescriptor(), mapOperands(flo));\n+                        spirvBlock.op(load);\n+                        valueMap.put(flo.result(), load.result());\n+                    }\n+                    case CoreOps.BranchOp bop -> {\n+                        Block.Reference successor = blockMap.get(bop.branch().targetBlock()).successor();\n+                        spirvBlock.op(new SpirvOps.BranchOp(successor));\n+                    }\n+                    case CoreOps.ConditionalBranchOp cbop -> {\n+                        Block trueBlock = cbop.trueBranch().targetBlock();\n+                        Block falseBlock = cbop.falseBranch().targetBlock();\n+                        Block.Reference spvTrueBlock = blockMap.get(trueBlock).successor();\n+                        Block.Reference spvFalseBlock = blockMap.get(falseBlock).successor();\n+                        spirvBlock.op(new SpirvOps.ConditionalBranchOp(spvTrueBlock, spvFalseBlock, mapOperands(cbop)));\n+                    }\n+                    default -> unsupported(\"op\", op.getClass());\n+                }\n+            } \/\/ops\n+        } \/\/ blocks\n+        return bodyBuilder;\n+    }\n+\n+    private RuntimeException unsupported(String message, Object value) {\n+        return new RuntimeException(\"Unsupported \" + message + \": \" + value);\n+    }\n+\n+    private static CoreOps.FuncOp lowerMethod(CoreOps.FuncOp fop) {\n+        CoreOps.FuncOp lfop = fop.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop)  {\n+                return lop.lower(block);\n+            }\n+            else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        return lfop;\n+    }\n+\n+    private List<Value> mapOperands(Op op) {\n+        List<Value> operands = new ArrayList<>();\n+        for (Value javaValue : op.operands()) {\n+            Value spirvValue = valueMap.get(javaValue);\n+            assert spirvValue != null : \"no value mapping from %s\" + javaValue;\n+            operands.add(spirvValue);\n+        }\n+        return operands;\n+    }\n+\n+    private boolean isIntegerType(TypeElement type) {\n+        return type.equals(JavaType.INT) || type.equals(JavaType.LONG);\n+    }\n+\n+    private boolean isFloatType(TypeElement type) {\n+        return type.equals(JavaType.FLOAT) || type.equals(JavaType.DOUBLE);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/main\/java\/intel\/code\/spirv\/TranslateToSpirvModel.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package intel.code.spirv;\n+\n+import java.lang.reflect.Method;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.runtime.CodeReflection;\n+import java.lang.reflect.code.op.CoreOps;\n+import org.junit.jupiter.api.Test;\n+\n+public class ExampleUseTest {\n+\n+    @CodeReflection\n+    public static void matrixMultiply(float[] a, float[] b, float[] c, int size) {\n+        for (int i = 0; i < size; i++) {\n+            for (int j = 0; j < size; j++) {\n+                float sum = 0f;\n+                for (int k = 0; k < size; k++) {\n+                    sum += a[i * size + k] * b[k * size + j];\n+                }\n+                c[i * size + j] = sum;\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        String methodName = \"matrixMultiply\";\n+        Method method = ExampleUseTest.class.getDeclaredMethod(methodName, float[].class, float[].class, float[].class, int.class);\n+\n+        CoreOps.FuncOp javaFunc = method.getCodeModel().get();\n+        SpirvOps.FuncOp spirvFunc = TranslateToSpirvModel.translateFunction(javaFunc);\n+        MemorySegment spirvBinary = SpirvModuleGenerator.generateModule(methodName, spirvFunc);\n+\n+        System.out.println(\"\\n------- Java Model -------\");\n+        System.out.println(javaFunc.toText());\n+        System.out.println(\"------- SPIR-V Model -------\");\n+        System.out.println(spirvFunc.toText());\n+        System.out.println(\"------- SPIR-V Module -------\");\n+        System.out.println(SpirvModuleGenerator.disassembleModule(spirvBinary));\n+   }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/spirv\/src\/test\/java\/intel\/code\/spirv\/ExampleUseTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+\/.idea\/\n+\/target\/\n","filename":"cr-examples\/triton\/.gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+Example using code reflection with a Java-based Triton programming model\n+inspired by Triton and its Python programming model, see\n+https:\/\/openai.com\/research\/triton.\n\\ No newline at end of file\n","filename":"cr-examples\/triton\/README.md","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+This code is free software; you can redistribute it and\/or modify it\n+under the terms of the GNU General Public License version 2 only, as\n+published by the Free Software Foundation.  Oracle designates this\n+particular file as subject to the \"Classpath\" exception as provided\n+by Oracle in the LICENSE file that accompanied this code.\n+\n+This code is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+version 2 for more details (a copy is included in the LICENSE file that\n+accompanied this code).\n+\n+You should have received a copy of the GNU General Public License version\n+2 along with this work; if not, write to the Free Software Foundation,\n+Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\n+Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+or visit www.oracle.com if you need additional information or have any\n+questions.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\"\n+         xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+\n+    <groupId>oracle.code<\/groupId>\n+    <artifactId>triton<\/artifactId>\n+    <version>1.0-SNAPSHOT<\/version>\n+\n+    <properties>\n+        <project.build.sourceEncoding>UTF-8<\/project.build.sourceEncoding>\n+        <maven.compiler.source>23<\/maven.compiler.source>\n+        <maven.compiler.target>23<\/maven.compiler.target>\n+    <\/properties>\n+\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.10.0<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+\n+    <build>\n+        <pluginManagement>\n+            <plugins>\n+                <plugin>\n+                    <groupId>org.apache.maven.plugins<\/groupId>\n+                    <artifactId>maven-surefire-plugin<\/artifactId>\n+                    <version>3.1.2<\/version>\n+                    <configuration>\n+                        <argLine>--enable-preview\n+                        <\/argLine>\n+                    <\/configuration>\n+                <\/plugin>\n+            <\/plugins>\n+        <\/pluginManagement>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-compiler-plugin<\/artifactId>\n+                <version>3.11.0<\/version>\n+                <configuration>\n+                    <compilerArgs>\n+                        <arg>--enable-preview<\/arg>\n+                    <\/compilerArgs>\n+                    <source>${maven.compiler.source}<\/source>\n+                    <target>${maven.compiler.target}<\/target>\n+                    <showDeprecation>true<\/showDeprecation>\n+                    <failOnError>true<\/failOnError>\n+                    <showWarnings>true<\/showWarnings>\n+                    <showDeprecation>true<\/showDeprecation>\n+                <\/configuration>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+<\/project>\n","filename":"cr-examples\/triton\/pom.xml","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,549 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.*;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ArithMathOps {\n+\n+    static abstract class ArithMathOp extends OpWithDefinition {\n+        final TypeElement resultType;\n+\n+        public ArithMathOp(OpDefinition def) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+        }\n+\n+        ArithMathOp(ArithMathOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.resultType = that.resultType;\n+        }\n+\n+        ArithMathOp(String name, TypeElement resultType, List<? extends Value> operands) {\n+            super(name, operands);\n+\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    @OpDeclaration(ConstantOp.NAME)\n+    public static class ConstantOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.constant\";\n+        public static final String ATTRIBUTE_CONSTANT_VALUE = NAME + \".value\";\n+\n+        final Object value;\n+\n+        public static ConstantOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have zero operands\");\n+            }\n+\n+            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE,true,\n+                    v -> processConstantValue(def.resultType(), v));\n+            return new ConstantOp(def, value);\n+        }\n+\n+        static Object processConstantValue(TypeElement t, Object value) {\n+            if (t.equals(JavaType.BOOLEAN)) {\n+                if (value instanceof String s) {\n+                    return Boolean.valueOf(s);\n+                } else if (value instanceof Boolean) {\n+                    return value;\n+                }\n+            } else if (t.equals(JavaType.BYTE)) {\n+                if (value instanceof String s) {\n+                    return Byte.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.byteValue();\n+                }\n+            } else if (t.equals(JavaType.SHORT)) {\n+                if (value instanceof String s) {\n+                    return Short.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.shortValue();\n+                }\n+            } else if (t.equals(JavaType.CHAR)) {\n+                if (value instanceof String s) {\n+                    return s.charAt(0);\n+                } else if (value instanceof Character) {\n+                    return value;\n+                }\n+            } else if (t.equals(JavaType.INT)) {\n+                if (value instanceof String s) {\n+                    return Integer.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.intValue();\n+                }\n+            } else if (t.equals(JavaType.LONG)) {\n+                if (value instanceof String s) {\n+                    return Long.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.longValue();\n+                }\n+            } else if (t.equals(JavaType.FLOAT)) {\n+                if (value instanceof String s) {\n+                    return Float.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.floatValue();\n+                }\n+            } else if (t.equals(JavaType.DOUBLE)) {\n+                if (value instanceof String s) {\n+                    return Double.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.doubleValue();\n+                }\n+            } else if (t instanceof TensorType tt) {\n+                return processConstantValue(tt.eType(), value);\n+            }\n+\n+            throw new UnsupportedOperationException(\"Unsupported constant type and value: \" + t + \" \" + value);\n+        }\n+\n+        ConstantOp(OpDefinition def, Object value) {\n+            super(def);\n+\n+            this.value = value;\n+        }\n+\n+        ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        ConstantOp(TypeElement type, Object value) {\n+            super(NAME, type, List.of());\n+\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", value);\n+            return attrs;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+    }\n+\n+    @OpDeclaration(AddOp.NAME)\n+    public static class AddOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.add\";\n+\n+        public AddOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        AddOp(AddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AddOp(this, cc);\n+        }\n+\n+        AddOp(Value a, Value b) {\n+            super(NAME + nameSuffixFromType(a.type(), false), a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(SubOp.NAME)\n+    public static class SubOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.sub\";\n+\n+        public SubOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        SubOp(SubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SubOp(this, cc);\n+        }\n+\n+        SubOp(Value a, Value b) {\n+            super(NAME + nameSuffixFromType(a.type(), false), a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(MulOp.NAME)\n+    public static class MulOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.mul\";\n+\n+        public MulOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        MulOp(MulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MulOp(this, cc);\n+        }\n+\n+        MulOp(Value a, Value b) {\n+            super(NAME + nameSuffixFromType(a.type(), false), a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(DivOp.NAME)\n+    public static class DivOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.div\";\n+\n+        public DivOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        DivOp(DivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DivOp(this, cc);\n+        }\n+\n+        DivOp(Value a, Value b) {\n+            super(NAME + nameSuffixFromType(a.type(), true), a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(RemOp.NAME)\n+    public static class RemOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.rem\";\n+\n+        public RemOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        RemOp(RemOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public RemOp transform(CopyContext cc, OpTransformer ot) {\n+            return new RemOp(this, cc);\n+        }\n+\n+        RemOp(Value a, Value b) {\n+            super(NAME + nameSuffixFromType(a.type(), true), a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(AndOp.NAME)\n+    public static class AndOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.andi\";\n+\n+        public AndOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        AndOp(AndOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AndOp(this, cc);\n+        }\n+\n+        AndOp(Value a, Value b) {\n+            super(NAME, a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(MaxOp.NAME)\n+    public static class MaxOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.max\";\n+\n+        public MaxOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        MaxOp(MaxOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MaxOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MaxOp(this, cc);\n+        }\n+\n+        MaxOp(Value a, Value b) {\n+            super(NAME + maxMinSuffixFromType(a.type()) + nameSuffixFromType(a.type(), true),\n+                    a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(MinOp.NAME)\n+    public static class MinOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.min\";\n+\n+        public MinOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        MinOp(MinOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MinOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MinOp(this, cc);\n+        }\n+\n+        MinOp(Value a, Value b) {\n+            super(NAME + maxMinSuffixFromType(a.type()) + nameSuffixFromType(a.type(), true),\n+                    a.type(), List.of(a, b));\n+        }\n+    }\n+\n+    @OpDeclaration(ExpOp.NAME)\n+    public static class TruncOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.trunc\";\n+\n+        public TruncOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        TruncOp(TruncOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public TruncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TruncOp(this, cc);\n+        }\n+\n+        TruncOp(TypeElement t, Value a) {\n+            super(NAME + nameSuffixFromType(a.type(), false),\n+                    t, List.of(a));\n+        }\n+    }\n+\n+    @OpDeclaration(ExpOp.NAME)\n+    public static class ExpOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"math.exp\";\n+\n+        public ExpOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ExpOp(ExpOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ExpOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ExpOp(this, cc);\n+        }\n+\n+        ExpOp(Value a) {\n+            super(NAME, a.type(), List.of(a));\n+        }\n+    }\n+\n+    @OpDeclaration(CompareOp.NAME)\n+    public static class CompareOp extends ArithMathOp implements Op.Pure {\n+        public static final String NAME = \"arith.cmp\";\n+        public static final String ATTRIBUTE_CONSTANT_VALUE = NAME + \".compare\";\n+\n+        public enum CompareKind {\n+            slt\n+        }\n+\n+        final CompareKind ck;\n+\n+        public static CompareOp create(OpDefinition def) {\n+            CompareKind ck = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE, true,\n+                    v -> switch (v) {\n+                        case String s -> CompareKind.valueOf(s);\n+                        case CompareKind k -> k;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported start value:\" + v);\n+                    });\n+            return new CompareOp(def, ck);\n+        }\n+\n+        CompareOp(OpDefinition def, CompareKind ck) {\n+            super(def);\n+\n+            this.ck = ck;\n+        }\n+\n+        CompareOp(CompareOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.ck = that.ck;\n+        }\n+\n+        @Override\n+        public CompareOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CompareOp(this, cc);\n+        }\n+\n+        CompareOp(CompareKind ck, Value a, Value b) {\n+            super(NAME + nameSuffixFromType(a.type(), false), a.type(), List.of(a, b));\n+\n+            this.ck = ck;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", ck);\n+            return attrs;\n+        }\n+\n+        public CompareKind kind() {\n+            return ck;\n+        }\n+    }\n+\n+    static String maxMinSuffixFromType(TypeElement t) {\n+        if (t instanceof TensorType tt) {\n+            return maxMinSuffixFromType(tt.eType());\n+        } else if (t instanceof PtrType pt) {\n+            return maxMinSuffixFromType(pt.rType());\n+        } else if (t.equals(JavaType.INT)) {\n+            return \"\";\n+        } else if (t.equals(JavaType.FLOAT)) {\n+            return \"imum\";\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + t);\n+        }\n+    }\n+\n+    static String nameSuffixFromType(TypeElement t, boolean signed) {\n+        if (t instanceof TensorType tt) {\n+            return nameSuffixFromType(tt.eType(), signed);\n+        } else if (t instanceof PtrType pt) {\n+            return nameSuffixFromType(pt.rType(), signed);\n+        } else if (t.equals(JavaType.INT) || t.equals(JavaType.LONG)) {\n+            return (signed ? \"s\" : \"\") + \"i\";\n+        } else if (t.equals(JavaType.FLOAT) || t.equals(JavaType.DOUBLE) ||\n+                Float16.FLOAT_16_TYPE.equals(t)) {\n+            return \"f\";\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported type: \" + t);\n+        }\n+    }\n+\n+    public static final OpFactory FACTORY = def -> {\n+        return switch (def.name()) {\n+            case ConstantOp.NAME -> ConstantOp.create(def);\n+            case ExpOp.NAME -> new ExpOp(def);\n+            case AddOp.NAME + \"i\", AddOp.NAME + \"f\" -> new AddOp(def);\n+            case SubOp.NAME + \"i\", SubOp.NAME + \"f\" -> new SubOp(def);\n+            case MulOp.NAME + \"i\", MulOp.NAME + \"f\" -> new MulOp(def);\n+            case DivOp.NAME + \"si\", DivOp.NAME + \"f\" -> new DivOp(def);\n+            case RemOp.NAME + \"si\", RemOp.NAME + \"f\" -> new DivOp(def);\n+            case AndOp.NAME -> new AndOp(def);\n+            case MaxOp.NAME + \"si\", MaxOp.NAME + \"imumf\" -> new MaxOp(def);\n+            case MinOp.NAME + \"si\", MinOp.NAME + \"imumf\" -> new MinOp(def);\n+            case TruncOp.NAME + \"i\", TruncOp.NAME + \"f\" -> new TruncOp(def);\n+            case CompareOp.NAME + \"i\", CompareOp.NAME + \"f\" -> CompareOp.create(def);\n+            default -> null;\n+        };\n+    };\n+\n+    \/\/ Arith\n+\n+    public static ConstantOp constant(TypeElement type, Object value) {\n+        return new ConstantOp(type, value);\n+    }\n+\n+    public static MulOp mul(Value a, Value b) {\n+        return new MulOp(a, b);\n+    }\n+\n+    public static AddOp add(Value a, Value b) {\n+        return new AddOp(a, b);\n+    }\n+\n+    public static SubOp sub(Value a, Value b) {\n+        return new SubOp(a, b);\n+    }\n+\n+    public static DivOp div(Value a, Value b) {\n+        return new DivOp(a, b);\n+    }\n+\n+    public static RemOp rem(Value a, Value b) {\n+        return new RemOp(a, b);\n+    }\n+\n+    public static AndOp and(Value a, Value b) {\n+        return new AndOp(a, b);\n+    }\n+\n+    public static MaxOp maximum(Value a, Value b) {\n+        return new MaxOp(a, b);\n+    }\n+\n+    public static MinOp minimum(Value a, Value b) {\n+        return new MinOp(a, b);\n+    }\n+\n+    public static CompareOp cmp(CompareOp.CompareKind ck, Value a, Value b) {\n+        return new CompareOp(ck, a, b);\n+    }\n+\n+    public static TruncOp trunc(TypeElement type, Value a) {\n+        return new TruncOp(type, a);\n+    }\n+\n+    \/\/ Math\n+\n+    public static ExpOp exp(Value a) {\n+        return new ExpOp(a);\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ArithMathOps.java","additions":549,"deletions":0,"binary":false,"changes":549,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.PARAMETER)\n+public @interface Constant {\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Constant.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class ConstantType extends TritonType {\n+    static final String NAME = \"constant\";\n+\n+    final TypeElement cType;\n+    final Object value;\n+\n+    public ConstantType(TypeElement cType, Object value) {\n+        this.cType = cType;\n+        this.value = value;\n+    }\n+\n+    public TypeElement cType() {\n+        return cType;\n+    }\n+\n+    public Object value() {\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        ConstantType that = (ConstantType) o;\n+        return Objects.equals(cType, that.cType) && Objects.equals(value, that.value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(cType, value);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME,\n+                List.of(cType.toTypeDefinition(),\n+                        new TypeDefinition(\"c\" + value, List.of())));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/ConstantType.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+\n+\/\/ Fake float 16 type\n+public final class Float16 extends TritonNumber {\n+    static final TypeElement FLOAT_16_TYPE = JavaType.type(Float16.class);\n+\n+    private Float16() {\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Float16.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+class Functions {\n+    private Functions() {\n+    }\n+\n+    @CodeReflection\n+    static int sum(int a, int b) {\n+        return a + b;\n+    }\n+\n+    @CodeReflection\n+    static int max(int a, int b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @CodeReflection\n+    static int cdiv(int x, int div) {\n+        return (x + div - 1) \/ div;\n+    }\n+\n+    static CoreOps.FuncOp getJavaCodeModel(String name) {\n+        Optional<Method> om = Stream.of(Functions.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .filter(m -> m.getAnnotation(CodeReflection.class) != null)\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Functions.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+public final class Ptr extends TritonNumber {\n+    private Ptr() {\n+    }\n+\n+    public PtrType type() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Ptr.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class PtrType extends TritonType {\n+    static final String NAME = \"ptr\";\n+    final TypeElement rType;\n+\n+    public PtrType(TypeElement rType) {\n+        this.rType = rType;\n+    }\n+\n+    public TypeElement rType() {\n+        return rType;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        PtrType ptrType = (PtrType) o;\n+        return Objects.equals(rType, ptrType.rType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(rType);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of(rType.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/PtrType.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.*;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.TupleType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class SCFOps {\n+\n+    @OpDeclaration(ForOp.NAME)\n+    public static final class ForOp extends OpWithDefinition implements Op.Loop {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Value> range;\n+            final FunctionType loopType;\n+\n+            Builder(Body.Builder ancestorBody, List<Value> range, FunctionType loopType) {\n+                this.ancestorBody = ancestorBody;\n+                this.range = range;\n+                this.loopType = loopType;\n+            }\n+\n+            public ForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, loopType);\n+                c.accept(body.entryBlock());\n+                return new ForOp(range, body);\n+            }\n+\n+            public ForOp body(CopyContext cc, Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, loopType, cc);\n+                c.accept(body.entryBlock());\n+                return new ForOp(range, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"scf.for\";\n+\n+        final Body body;\n+\n+        public ForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        ForOp(ForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public ForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ForOp(this, cc, ot);\n+        }\n+\n+        ForOp(List<Value> range, Body.Builder bodyBuilder) {\n+            super(NAME, range);\n+\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return body.yieldType();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+    }\n+\n+    @OpDeclaration(YieldOp.NAME)\n+    public static class YieldOp extends OpWithDefinition implements Op.Terminating {\n+        public static final String NAME = \"scf.yield\";\n+\n+        public YieldOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        YieldOp(YieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public YieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new YieldOp(this, cc);\n+        }\n+\n+        YieldOp(List<Value> values) {\n+            super(NAME, values);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        static TypeElement yieldType(List<Value> values) {\n+            if (values.size() == 1) {\n+                return values.get(0).type();\n+            } else {\n+                return TupleType.tupleTypeFromValues(values);\n+            }\n+        }\n+    }\n+\n+    static public ForOp.Builder for_(Body.Builder ancestorBody,\n+                                     Value start, Value end, Value step,\n+                                     List<Value> iterValues) {\n+        TypeElement yieldType = (iterValues.size() == 1)\n+                ? iterValues.get(0).type()\n+                : TupleType.tupleTypeFromValues(iterValues);\n+\n+        List<TypeElement> bodyParameterTypes = new ArrayList<>();\n+        bodyParameterTypes.add(start.type());\n+        bodyParameterTypes.addAll(iterValues.stream().map(Value::type).toList());\n+        FunctionType bodyType = FunctionType.functionType(yieldType, bodyParameterTypes);\n+\n+        List<Value> operands = new ArrayList<>();\n+        operands.addAll(List.of(start, end, step));\n+        operands.addAll(iterValues);\n+        return new ForOp.Builder(ancestorBody, operands, bodyType);\n+    }\n+\n+\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(SCFOps.class);\n+\n+    static public YieldOp yield_(Value... values) {\n+        return yield_(List.of(values));\n+    }\n+\n+    static public YieldOp yield_(List<Value> values) {\n+        return new YieldOp(values);\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SCFOps.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Patterns;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.CoreOps.VarAccessOp.VarLoadOp;\n+import java.lang.reflect.code.op.CoreOps.VarAccessOp.VarStoreOp;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.analysis.Patterns.*;\n+\n+\/\/ @@@ Very basic, limited, and partially correct\n+public class SimpleCountedForLoopInfo {\n+\n+    final ExtendedOps.JavaForOp fop;\n+\n+    SimpleCountedForLoopInfo(ExtendedOps.JavaForOp fop) {\n+        this.fop = fop;\n+\n+        if (fop.init().yieldType().equals(JavaType.VOID)) {\n+            throw new IllegalArgumentException(\"Loop variable externally initialized\");\n+        }\n+        if (fop.loopBody().entryBlock().parameters().size() > 1) {\n+            throw new IllegalArgumentException(\"Two or more loop variables\");\n+        }\n+    }\n+\n+    public List<Op> startExpression() {\n+        \/*\n+        ()Var<int> -> {\n+            %12 : int = constant @\"0\";\n+            %13 : Var<int> = var %12 @\"i\";\n+            yield %13;\n+        }\n+         *\/\n+\n+        Patterns.OpPattern p = opP(CoreOps.YieldOp.class,\n+                opP(CoreOps.VarOp.class,\n+                        opResultP()));\n+\n+        \/\/ match against yieldOp\n+        Op yieldOp = fop.init().entryBlock().ops().getLast();\n+        List<Value> matches = Patterns.match(null, yieldOp, p, (matchState, o) -> {\n+            return matchState.matchedOperands();\n+        });\n+        if (matches == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        Op.Result initValue = (Op.Result) matches.get(0);\n+\n+        return traverseOperands(initValue.op());\n+    }\n+\n+    public List<Op> endExpression() {\n+        \/*\n+        (%14 : Var<int>)boolean -> {\n+            %15 : int = var.load %14;\n+            %16 : int = var.load %2;\n+            %17 : boolean = lt %15 %16;\n+            yield %17;\n+        }\n+         *\/\n+\n+        Patterns.OpPattern p = opP(CoreOps.YieldOp.class,\n+                opP(CoreOps.LtOp.class,\n+                        opP(VarLoadOp.class,\n+                                blockParameterP()),\n+                        opResultP()));\n+\n+        \/\/ match against yieldOp\n+        Op yieldOp = fop.cond().entryBlock().ops().getLast();\n+        List<Value> matches = Patterns.match(null, yieldOp, p, (matchState, o) -> {\n+            return matchState.matchedOperands();\n+        });\n+        if (matches == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        Op.Result endValue = (Op.Result) matches.get(1);\n+\n+        return traverseOperands(endValue.op());\n+    }\n+\n+    public List<Op> stepExpression() {\n+        \/*\n+        (%18 : Var<int>)void -> {\n+            %19 : int = var.load %18;\n+            %20 : int = constant @\"1\";\n+            %21 : int = add %19 %20;\n+            var.store %18 %21;\n+            yield;\n+        }\n+         *\/\n+\n+        Patterns.OpPattern p = opP(VarStoreOp.class,\n+                blockParameterP(),\n+                opP(CoreOps.AddOp.class,\n+                        opP(VarLoadOp.class, blockParameterP()),\n+                        opResultP()));\n+\n+        \/\/ Match against last store op\n+        \/\/ @@@ Add Block.prevOp()\n+        Op storeOp = fop.update().entryBlock().ops().get(fop.update().entryBlock().ops().size() - 2);\n+        List<Value> matches = Patterns.match(null, storeOp, p, (matchState, r) -> {\n+            return matchState.matchedOperands();\n+        });\n+        if (matches == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        Op.Result stepValue = (Op.Result) matches.get(2);\n+\n+        return traverseOperands(stepValue.op());\n+    }\n+\n+    static List<Op> traverseOperands(Op op) {\n+        List<Op> ops = new ArrayList<>();\n+        traverseOperands(ops, op);\n+        return ops;\n+    }\n+\n+    \/\/ Hoist the expression\n+    \/\/ @@@ should be pure and independent of the loop variable\n+    static void traverseOperands(List<Op> ops, Op op) {\n+        for (Value operand : op.operands()) {\n+            if (operand.declaringBlock().parentBody() == op.ancestorBody()) {\n+                if (operand instanceof Op.Result r) {\n+                    traverseOperands(ops, r.op());\n+                }\n+            }\n+        }\n+\n+        ops.add(op);\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/SimpleCountedForLoopInfo.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+public final class Tensor extends TritonNumber {\n+    private Tensor() {\n+    }\n+\n+    public TensorType type() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Tensor.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class TensorType extends TritonType {\n+    static final String NAME = \"tensor\";\n+\n+    final TypeElement eType;\n+    final List<Integer> shape;\n+    final int size;\n+\n+    public TensorType(TypeElement eType, List<Integer> shape) {\n+        this.eType = eType;\n+        this.shape = List.copyOf(shape);\n+        int s = 1;\n+        for (Integer i : shape) {\n+            s *= i;\n+        }\n+        this.size = s;\n+    }\n+\n+    public TypeElement eType() {\n+        return eType;\n+    }\n+\n+    public List<Integer> shape() {\n+        return shape;\n+    }\n+\n+    public int size() {\n+        return size;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        TensorType that = (TensorType) o;\n+        return Objects.equals(eType, that.eType) && Objects.equals(shape, that.shape);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(eType, shape);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        List<TypeDefinition> args = new ArrayList<>();\n+        for (int i : shape) {\n+            args.add(new TypeDefinition(\"x\" + i, List.of()));\n+        }\n+        args.add(eType.toTypeDefinition());\n+        return new TypeDefinition(NAME, args);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TensorType.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.Type;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+public class Triton {\n+    private Triton() {\n+    }\n+\n+    public static int programId(@Constant int axis) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor arange(@Constant int start, @Constant int end) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor load(Tensor ptr, Tensor mask) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static void store(Tensor ptr, Tensor value, Tensor mask) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor broadcast(Object o, TensorType type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor expand(Tensor a, int axis) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor zeros(Class<?> eType, int... shape)  {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static TensorType joinShape(TensorType a, TensorType b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor dot(Tensor a, Tensor b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ Arithmetic\n+\n+    public static Tensor add(Number a, Number b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor sub(Number a, Number b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor mul(Number a, Number b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor div(Number a, Number b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor mod(Number a, Number b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor and(Number a, Number b) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public enum CompareKind {\n+        Equal,\n+        LessThan,\n+        LessThanOrEqual,\n+        GreaterThan,\n+        GreaterThanOrEqual\n+    }\n+\n+    public static Tensor compare(Number a, Number b, @Constant CompareKind ck) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor exp(Tensor a) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static int cdiv(Number x, Number div) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ Conversions\n+\n+    public static <T extends Number> T conv(Type t, T a) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ Reductions\n+\n+    public static Tensor max(Tensor a, @Constant int axis) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public static Tensor sum(Tensor a, @Constant int axis) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/Triton.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+abstract class TritonNumber extends Number {\n+    TritonNumber() {\n+    }\n+\n+    @Override\n+    public int intValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public long longValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public float floatValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public double doubleValue() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonNumber.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,888 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.*;\n+import java.lang.reflect.code.type.*;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class TritonOps {\n+\n+    static abstract class TritonOp extends OpWithDefinition {\n+        final TypeElement resultType;\n+\n+        public TritonOp(OpDefinition def) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+        }\n+\n+        TritonOp(TritonOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.resultType = that.resultType;\n+        }\n+\n+        TritonOp(String name, TypeElement resultType, List<? extends Value> operands) {\n+            super(name, operands);\n+\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    @OpDeclaration(ModuleOp.NAME)\n+    public static final class ModuleOp extends TritonOp implements Op.Isolated {\n+        public static final String NAME = \"module\";\n+\n+        final Map<String, FuncOp> table;\n+        final Body body;\n+\n+        public ModuleOp(OpDefinition def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        ModuleOp(ModuleOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        static Map<String, FuncOp> createTable(Body body) {\n+            Map<String, FuncOp> table = new HashMap<>();\n+            for (var op : body.entryBlock().ops()) {\n+                if (op instanceof FuncOp fop) {\n+                    table.put(fop.funcName(), fop);\n+                } else if (op instanceof CoreOps.UnreachableOp _) {\n+                    \/\/ no operation\n+                } else {\n+                    throw new IllegalArgumentException(\"Bad operation in module: \" + op);\n+                }\n+            }\n+            return Collections.unmodifiableMap(table);\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc, ot);\n+        }\n+\n+        public ModuleOp transform(OpTransformer ot) {\n+            return new ModuleOp(this, CopyContext.create(), ot);\n+        }\n+\n+        ModuleOp(List<FuncOp> functions) {\n+            super(NAME, JavaType.VOID,\n+                    List.of());\n+\n+            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n+            Block.Builder entryBlock = bodyC.entryBlock();\n+            Map<String, FuncOp> table = new HashMap<>();\n+            for (FuncOp f : functions) {\n+                entryBlock.op(f);\n+                table.put(f.funcName(), f);\n+            }\n+            entryBlock.op(CoreOps.unreachable());\n+            this.table = Collections.unmodifiableMap(table);\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Map<String, FuncOp> functionTable() {\n+            return table;\n+        }\n+    }\n+\n+    @OpDeclaration(FuncOp.NAME)\n+    public static final class FuncOp extends TritonOp implements Op.Invokable, Op.Isolated, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final String funcName;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcName = funcName;\n+                this.funcType = funcType;\n+            }\n+\n+            public FuncOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new FuncOp(funcName, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"tt.func\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final Body body;\n+\n+        public static FuncOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new FuncOp(def, funcName);\n+        }\n+\n+        FuncOp(OpDefinition def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        FuncOp(FuncOp that, CopyContext cc, OpTransformer oa) {\n+            this(that, that.funcName, cc, oa);\n+        }\n+\n+        FuncOp(FuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.funcName = funcName;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, cc, ot);\n+        }\n+\n+        public FuncOp transform(OpTransformer ot) {\n+            return new FuncOp(this, CopyContext.create(), ot);\n+        }\n+\n+        public FuncOp transform(String funcName, OpTransformer ot) {\n+            return new FuncOp(this, funcName, CopyContext.create(), ot);\n+        }\n+\n+        FuncOp(String funcName, Body.Builder bodyBuilder) {\n+            super(NAME, JavaType.VOID,\n+                    List.of());\n+\n+            this.funcName = funcName;\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            \/\/ and copy directly without lowering descendant operations\n+            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n+            return b;\n+        }\n+    }\n+\n+    @OpDeclaration(CallOp.NAME)\n+    public static final class CallOp extends TritonOp {\n+        public static final String NAME = \"tt.call\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+\n+        public static CallOp create(OpDefinition def) {\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+\n+            return new CallOp(def, funcName);\n+        }\n+\n+        CallOp(OpDefinition def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+        }\n+\n+        CallOp(CallOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.funcName = that.funcName;\n+        }\n+\n+        @Override\n+        public CallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CallOp(this, cc);\n+        }\n+\n+        CallOp(String funcName, TypeElement resultType, List<Value> args) {\n+            super(NAME, resultType, args);\n+\n+            this.funcName = funcName;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+    }\n+\n+    @OpDeclaration(ReduceOp.NAME)\n+    public static final class ReduceOp extends TritonOp {\n+        \/\/ @@@ SSA transformation does not work with nested ops\n+        \/\/ implements Op.Nested {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final int axis;\n+            final Value v;\n+            final FunctionType reduceType;\n+\n+            Builder(Body.Builder ancestorBody, int axis, Value v, FunctionType reduceType) {\n+                this.ancestorBody = ancestorBody;\n+                this.axis = axis;\n+                this.v = v;\n+                this.reduceType = reduceType;\n+            }\n+\n+            public ReduceOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, reduceType);\n+                c.accept(body.entryBlock());\n+                return new ReduceOp(axis, v, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"tt.reduce\";\n+        public static final String ATTRIBUTE_AXIS = \"axis\";\n+\n+        final int axis;\n+        final Body reducer;\n+\n+        public static ReduceOp create(OpDefinition def) {\n+            int axis = def.extractAttributeValue(ATTRIBUTE_AXIS, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported axis value:\" + v);\n+                    });\n+            return new ReduceOp(def, axis);\n+        }\n+\n+        ReduceOp(OpDefinition def, int axis) {\n+            super(def);\n+\n+            this.axis = axis;\n+            this.reducer = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        ReduceOp(ReduceOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.axis = that.axis;\n+            this.reducer = that.reducer.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public ReduceOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceOp(this, cc, ot);\n+        }\n+\n+        ReduceOp(int axis, Value tensor, Body.Builder reducerBuilder) {\n+            super(NAME, reducerBuilder.bodyType().returnType(), List.of(tensor));\n+\n+            this.axis = axis;\n+            this.reducer = reducerBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(reducer);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(ATTRIBUTE_AXIS, axis);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int axis() {\n+            return axis;\n+        }\n+\n+        public Body reducer() {\n+            return reducer;\n+        }\n+    }\n+\n+    @OpDeclaration(ReduceReturnOp.NAME)\n+    public static class ReduceReturnOp extends TritonOp implements Op.Terminating {\n+        public static final String NAME = \"tt.reduce.return\";\n+\n+        public ReduceReturnOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ReduceReturnOp(ReduceReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReduceReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReduceReturnOp(this, cc);\n+        }\n+\n+        ReduceReturnOp(Value r) {\n+            super(NAME, JavaType.VOID, List.of(r));\n+        }\n+    }\n+\n+    @OpDeclaration(GetProgramIdOp.NAME)\n+    public static class GetProgramIdOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.get_program_id\";\n+        public static final String ATTRIBUTE_AXIS = \"axis\";\n+\n+        final int axis;\n+\n+        public static GetProgramIdOp create(OpDefinition def) {\n+            int axis = def.extractAttributeValue(ATTRIBUTE_AXIS, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported axis value:\" + v);\n+                    });\n+            return new GetProgramIdOp(def, axis);\n+        }\n+\n+        GetProgramIdOp(OpDefinition def, int axis) {\n+            super(def);\n+\n+            this.axis = axis;\n+        }\n+\n+        GetProgramIdOp(GetProgramIdOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.axis = that.axis;\n+        }\n+\n+        @Override\n+        public GetProgramIdOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GetProgramIdOp(this, cc);\n+        }\n+\n+        GetProgramIdOp(int axis) {\n+            super(NAME, JavaType.INT, List.of());\n+\n+            this.axis = axis;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", axis);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int axis() {\n+            return axis;\n+        }\n+    }\n+\n+    @OpDeclaration(MakeRangeOp.NAME)\n+    public static class MakeRangeOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.make_range\";\n+        public static final String ATTRIBUTE_START = \"start\";\n+        public static final String ATTRIBUTE_END = \"end\";\n+\n+        final int start;\n+        final int end;\n+\n+        public static MakeRangeOp create(OpDefinition def) {\n+            int start = def.extractAttributeValue(ATTRIBUTE_START, false,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported start value:\" + v);\n+                    });\n+            int end = def.extractAttributeValue(ATTRIBUTE_END, false,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported end value:\" + v);\n+                    });\n+            return new MakeRangeOp(def, start, end);\n+        }\n+\n+        MakeRangeOp(OpDefinition def, int start, int end) {\n+            super(def);\n+\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        MakeRangeOp(MakeRangeOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.start = that.start;\n+            this.end = that.end;\n+        }\n+\n+        @Override\n+        public MakeRangeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MakeRangeOp(this, cc);\n+        }\n+\n+        MakeRangeOp(int start, int end) {\n+            super(NAME, tensorType(start, end), List.of());\n+\n+            this.start = start;\n+            this.end = end;\n+        }\n+\n+        static TensorType tensorType(int start, int end) {\n+            return new TensorType(JavaType.INT, List.of(end - start));\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(ATTRIBUTE_START, start);\n+            m.put(ATTRIBUTE_END, end);\n+            return Collections.unmodifiableMap(m);\n+        }\n+    }\n+\n+    @OpDeclaration(ExpandOp.NAME)\n+    public static class ExpandOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.expand_dims\";\n+        public static final String ATTRIBUTE_AXIS = \"axis\";\n+\n+        final int axis;\n+\n+        public static ExpandOp create(OpDefinition def) {\n+            int axis = def.extractAttributeValue(ATTRIBUTE_AXIS, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported axis value:\" + v);\n+                    });\n+            return new ExpandOp(def, axis);\n+        }\n+\n+        ExpandOp(OpDefinition def, int axis) {\n+            super(def);\n+\n+            this.axis = axis;\n+        }\n+\n+        ExpandOp(ExpandOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.axis = that.axis;\n+        }\n+\n+        @Override\n+        public ExpandOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ExpandOp(this, cc);\n+        }\n+\n+        ExpandOp(int axis, TypeElement tensorType, Value v) {\n+            super(NAME, tensorType, List.of(v));\n+\n+            this.axis = axis;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", axis);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int axis() {\n+            return axis;\n+        }\n+    }\n+\n+    @OpDeclaration(SplatOp.NAME)\n+    public static class SplatOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.splat\";\n+\n+        public SplatOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        SplatOp(SplatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SplatOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SplatOp(this, cc);\n+        }\n+\n+        SplatOp(TypeElement tensorType, Value v) {\n+            super(NAME, tensorType, List.of(v));\n+        }\n+    }\n+\n+    @OpDeclaration(BroadcastOp.NAME)\n+    public static class BroadcastOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.broadcast\";\n+\n+        public BroadcastOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        BroadcastOp(BroadcastOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public BroadcastOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BroadcastOp(this, cc);\n+        }\n+\n+        BroadcastOp(TypeElement tensorType, Value v) {\n+            super(NAME, tensorType, List.of(v));\n+        }\n+    }\n+\n+    @OpDeclaration(AddPtrOp.NAME)\n+    public static class AddPtrOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.addptr\";\n+\n+        public AddPtrOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        AddPtrOp(AddPtrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AddPtrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AddPtrOp(this, cc);\n+        }\n+\n+        AddPtrOp(Value ptr, Value offset) {\n+            super(NAME, ptr.type(), List.of(ptr, offset));\n+        }\n+    }\n+\n+    @OpDeclaration(LoadOp.NAME)\n+    public static class LoadOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.load\";\n+\n+        public LoadOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        LoadOp(LoadOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LoadOp(this, cc);\n+        }\n+\n+        LoadOp(TypeElement tensorType, Value ptr, Value mask) {\n+            super(NAME, tensorType, List.of(ptr, mask));\n+        }\n+    }\n+\n+    @OpDeclaration(StoreOp.NAME)\n+    public static class StoreOp extends TritonOp {\n+        public static final String NAME = \"tt.store\";\n+\n+        public StoreOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        StoreOp(StoreOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public StoreOp transform(CopyContext cc, OpTransformer ot) {\n+            return new StoreOp(this, cc);\n+        }\n+\n+        StoreOp(Value ptr, Value v, Value mask) {\n+            super(NAME, JavaType.VOID, List.of(ptr, v, mask));\n+        }\n+    }\n+\n+    @OpDeclaration(ReturnOp.NAME)\n+    public static class ReturnOp extends TritonOp implements Op.Terminating {\n+        public static final String NAME = \"tt.return\";\n+\n+        public ReturnOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+\n+        ReturnOp() {\n+            super(NAME, JavaType.VOID, List.of());\n+        }\n+\n+        ReturnOp(Value v) {\n+            super(NAME, JavaType.VOID, List.of(v));\n+        }\n+    }\n+\n+    @OpDeclaration(DotOp.NAME)\n+    public static class DotOp extends TritonOp implements Op.Pure {\n+        public static final String NAME = \"tt.dot\";\n+\n+        public DotOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        DotOp(DotOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DotOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DotOp(this, cc);\n+        }\n+\n+        DotOp(TypeElement tensorType, Value a, Value b) {\n+            super(NAME, tensorType, List.of(a, b));\n+        }\n+    }\n+\n+\n+    public static ModuleOp module(FuncOp... functions) {\n+        return module(List.of(functions));\n+    }\n+\n+    public static ModuleOp module(List<FuncOp> functions) {\n+        return new ModuleOp(List.copyOf(functions));\n+    }\n+\n+    public static FuncOp.Builder func(String funcName, FunctionType funcType) {\n+        return new FuncOp.Builder(null, funcName, funcType);\n+    }\n+\n+    public static FuncOp func(String funcName, Body.Builder body) {\n+        return new FuncOp(funcName, body);\n+    }\n+\n+    public static CallOp call(FuncOp func, Value... args) {\n+        return call(func, List.of(args));\n+    }\n+\n+    public static CallOp call(FuncOp func, List<Value> args) {\n+        return new CallOp(func.funcName(), func.invokableType().returnType(), args);\n+    }\n+\n+    public static ReduceOp.Builder reduce(Body.Builder ancestorBody, int axis, Value tensor,\n+                                          FunctionType reduceType) {\n+        return new ReduceOp.Builder(ancestorBody, axis, tensor, reduceType);\n+    }\n+\n+    public static ReduceOp reduce(int axis, Value tensor, Body.Builder reducerBuilder) {\n+        return new ReduceOp(axis, tensor, reducerBuilder);\n+    }\n+\n+    public static ReduceReturnOp reduceReturn(Value r) {\n+        return new ReduceReturnOp(r);\n+    }\n+\n+    public static GetProgramIdOp getProgramId(int axis) {\n+        \/\/ @@@ 1 <= axis <= 3\n+        return new GetProgramIdOp(axis);\n+    }\n+\n+    public static MakeRangeOp makeRange(int start, int end) {\n+        \/\/ @@@ 0 <= start < end\n+        return new MakeRangeOp(start, end);\n+    }\n+\n+    public static ExpandOp expand(int axis, TypeElement tensorType, Value v) {\n+        return new ExpandOp(axis, tensorType, v);\n+    }\n+\n+    \/\/ v is scalar\n+    public static SplatOp splat(TypeElement tensorType, Value v) {\n+        return new SplatOp(tensorType, v);\n+    }\n+\n+    \/\/ v is tensor\n+    public static BroadcastOp broadcast(TypeElement tensorType, Value v) {\n+        return new BroadcastOp(tensorType, v);\n+    }\n+\n+    public static AddPtrOp addptr(Value ptr, Value offset) {\n+        return new AddPtrOp(ptr, offset);\n+    }\n+\n+    public static LoadOp load(TypeElement tensorType, Value ptr, Value mask) {\n+        return new LoadOp(tensorType, ptr, mask);\n+    }\n+\n+    public static StoreOp store(Value ptr, Value v, Value mask) {\n+        return new StoreOp(ptr, v, mask);\n+    }\n+\n+    public static ReturnOp return_() {\n+        return new ReturnOp();\n+    }\n+\n+    public static ReturnOp return_(Value v) {\n+        return new ReturnOp(v);\n+    }\n+\n+    public static DotOp dot(TypeElement tensorType, Value a, Value b) {\n+        return new DotOp(tensorType, a, b);\n+    }\n+\n+\n+    \/\/ Operation and type factories\n+\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonOps.class);\n+\n+    static final TypeElementFactory TRITON_TYPE_FACTORY = new TypeElementFactory() {\n+        @Override\n+        public TypeElement constructType(TypeDefinition tree) {\n+            return switch (tree.identifier()) {\n+                case PtrType.NAME -> {\n+                    if (tree.arguments().size() != 1) {\n+                        throw new IllegalArgumentException();\n+                    }\n+\n+                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.arguments().getFirst());\n+                    if (v == null) {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                    if (v instanceof JavaType || v instanceof TritonType) {\n+                        yield new PtrType(v);\n+                    } else {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                }\n+                case TensorType.NAME -> {\n+                    if (tree.arguments().size() < 2) {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+\n+                    List<Integer> shape = new ArrayList<>();\n+                    for (int i = 0; i < tree.arguments().size() - 1; i++) {\n+                        TypeDefinition a = tree.arguments().get(i);\n+                        if (!a.identifier().startsWith(\"x\")) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        int d;\n+                        try {\n+                            d = Integer.parseInt(a.identifier().substring(1));\n+                        } catch (NumberFormatException e) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree, e);\n+                        }\n+                        shape.add(d);\n+                    }\n+\n+                    TypeElement v = TRITON_JAVA_TYPE_FACTORY.constructType(tree.arguments().getLast());\n+                    if (v == null) {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                    if (v instanceof JavaType || v instanceof TritonType) {\n+                        yield new TensorType(v, shape);\n+                    } else {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                }\n+                default -> null;\n+            };\n+        }\n+    };\n+\n+    \/\/ Triton types then Java types\n+    static final TypeElementFactory TRITON_JAVA_TYPE_FACTORY =\n+            TRITON_TYPE_FACTORY.andThen(CoreTypeFactory.JAVA_TYPE_FACTORY);\n+\n+    \/\/ Triton types then Java types, combined with code model types\n+    public static final TypeElementFactory TYPE_FACTORY =\n+            CoreTypeFactory.codeModelTypeFactory(TRITON_JAVA_TYPE_FACTORY);\n+\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonOps.java","additions":888,"deletions":0,"binary":false,"changes":888,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.OpDeclaration;\n+import java.lang.reflect.code.op.OpDefinition;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.op.OpWithDefinition;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.List;\n+\n+public class TritonTestOps {\n+\n+    @OpDeclaration(ConsumeOp.NAME)\n+    public static class ConsumeOp extends OpWithDefinition {\n+        public static final String NAME = \"tt.consume\";\n+\n+        public ConsumeOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ConsumeOp(ConsumeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ConsumeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConsumeOp(this, cc);\n+        }\n+\n+        ConsumeOp(List<Value> values) {\n+            super(NAME, values);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(TritonTestOps.class);\n+\n+    public static ConsumeOp consume(Value... operands) {\n+        return consume(List.of(operands));\n+    }\n+\n+    public static ConsumeOp consume(List<Value> operands) {\n+        return new ConsumeOp(operands);\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTestOps.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,1239 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+\n+public final class TritonTransformer {\n+    private TritonTransformer() {}\n+\n+    static final JavaType TYPE_Triton = JavaType.type(Triton.class);\n+\n+    static final JavaType TYPE_Triton_Test = JavaType.ofString(\"oracle.code.triton.TritonTest\");\n+\n+    static final JavaType TYPE_Tensor = JavaType.type(Tensor.class);\n+\n+    static final JavaType TYPE_J_L_MATH = JavaType.type(Math.class);\n+\n+    public static <O extends Op & Op.Invokable>\n+    TritonOps.ModuleOp tritonModule(O kernel,\n+                                    TypeElement rType,\n+                                    List<? extends TypeElement> argTypes) {\n+        Map<String, TritonOps.FuncOp> fsymTable = new LinkedHashMap<>();\n+        tritonFunction(kernel, rType, argTypes, fsymTable);\n+        return TritonOps.module(fsymTable.values().stream().toList());\n+    }\n+\n+    public static <O extends Op & Op.Invokable>\n+    TritonOps.FuncOp tritonFunction(O javaKernel,\n+                                    TypeElement rType,\n+                                    List<? extends TypeElement> argTypes,\n+                                    Map<String, TritonOps.FuncOp> fsymTable) {\n+        String name = (javaKernel instanceof FuncOp f) ? f.funcName() : \"kernel\";\n+        String signature = signature(name, rType, argTypes);\n+        if (fsymTable.containsKey(signature)) {\n+            return fsymTable.get(signature);\n+        }\n+\n+        System.out.println(javaKernel.toText());\n+\n+        Map<Value, TypeElement> valueTypeMap = new HashMap<>();\n+        Map<Op, Object> opData = new HashMap<>();\n+        TritonTransformer.typeCheckKernel(javaKernel, argTypes, valueTypeMap, opData);\n+        TritonTransformer.printTypeMap(javaKernel, valueTypeMap);\n+\n+        return TritonTransformer.transformToTritonFunction(javaKernel, signature,\n+                rType, valueTypeMap, opData,\n+                fsymTable);\n+    }\n+\n+    static String signature(String name, TypeElement rType, List<? extends TypeElement> argTypes) {\n+        StringBuilder sb = new StringBuilder(name);\n+\n+        for (TypeElement argType : argTypes) {\n+            sb.append(\"_\");\n+            if (argType instanceof ConstantType ct) {\n+                sb.append(ct.value());\n+            } else {\n+                sb.append(argType);\n+            }\n+        }\n+        sb.append(\"_\");\n+        sb.append(rType);\n+        return sb.toString();\n+    }\n+\n+    public static <O extends Op & Op.Invokable> void typeCheckKernel(\n+            O kernel, List<? extends TypeElement> argTypes,\n+            Map<Value, TypeElement> valueTypeMap, Map<Op, Object> opData) {\n+        kernel.traverse(null, CodeElement.opVisitor((o, op) -> {\n+            switch (op) {\n+                case Op.Invokable fop -> {\n+                    List<Block.Parameter> parameters = fop.body().entryBlock().parameters();\n+                    for (int i = 0; i < parameters.size(); i++) {\n+                        valueTypeMap.put(parameters.get(i), argTypes.get(i));\n+                    }\n+                }\n+                case VarOp _, VarAccessOp.VarLoadOp _ -> {\n+                    Value init = op.operands().get(0);\n+                    valueTypeMap.put(op.result(), valueTypeMap.get(init));\n+                }\n+                case VarAccessOp.VarStoreOp _ -> {\n+                    Value var = op.operands().get(0);\n+                    TypeElement varType = valueTypeMap.get(var);\n+                    Value v = op.operands().get(1);\n+                    TypeElement vType = valueTypeMap.get(v);\n+                    if (!varType.equals(vType)) {\n+                        throw new IllegalStateException(\"Storing to variable with different type: \"\n+                                + varType + \" <- \" + vType);\n+                    }\n+\n+                    valueTypeMap.put(op.result(), valueTypeMap.get(var));\n+                }\n+                case ConstantOp cop -> {\n+                    valueTypeMap.put(op.result(), new ConstantType(op.result().type(), cop.value()));\n+                }\n+                case ArithmeticOperation _ -> {\n+                    TypeElement t = checkWithTypeInterpreter(op, op.opName(), valueTypeMap);\n+                    valueTypeMap.put(op.result(), t);\n+                }\n+                case FieldAccessOp.FieldLoadOp flop -> {\n+                    if (!flop.operands().isEmpty()) {\n+                        throw new IllegalStateException(\"Unsupported field load: \" + flop.fieldDescriptor());\n+                    }\n+\n+                    Field f;\n+                    try {\n+                        f = flop.fieldDescriptor().resolveToMember(MethodHandles.lookup());\n+                    } catch (ReflectiveOperationException e) {\n+                        throw new IllegalStateException(\"Unsupported field load: \" + flop.fieldDescriptor(), e);\n+                    }\n+                    Object value;\n+                    try {\n+                        value = f.get(null);\n+                    } catch (IllegalAccessException e) {\n+                        throw new IllegalStateException(\"Unsupported field load: \" + f, e);\n+                    }\n+                    valueTypeMap.put(op.result(), new ConstantType(JavaType.type(f.getType()), value));\n+                }\n+                case InvokeOp iop when iop.invokeDescriptor().refType().equals(JavaType.J_L_INTEGER) -> {\n+                    \/\/ Box\n+                    if (iop.invokeDescriptor().name().equals(\"valueOf\")) {\n+                        Value a = op.operands().get(0);\n+                        valueTypeMap.put(op.result(), valueTypeMap.get(a));\n+                    } else {\n+                        throw new UnsupportedOperationException(\"Unsupported invocation on Integer: \" + iop.invokeDescriptor());\n+                    }\n+                }\n+                case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_J_L_MATH) -> {\n+                    String name = iop.invokeDescriptor().name();\n+                    if (name.equals(\"max\") || name.equals(\"min\")) {\n+                        Value a = op.operands().get(0);\n+                        valueTypeMap.put(op.result(), valueTypeMap.get(a));\n+                    } else {\n+                        throw new UnsupportedOperationException(\"Unsupported invocation on Math: \" + iop.invokeDescriptor());\n+                    }\n+                }\n+                case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_Tensor) -> {\n+                    if (iop.invokeDescriptor().name().equals(\"type\")) {\n+                        Value a = op.operands().get(0);\n+                        valueTypeMap.put(op.result(), valueTypeMap.get(a));\n+                    } else {\n+                        throw new UnsupportedOperationException(\"Unsupported invocation on Tensor: \" + iop.invokeDescriptor());\n+                    }\n+                }\n+                case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_Triton) -> {\n+                    TypeElement t = checkWithTypeInterpreter(op, iop.invokeDescriptor().name(), valueTypeMap);\n+                    valueTypeMap.put(op.result(), t);\n+                }\n+                case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_Triton_Test) -> {\n+                    TypeElement t = checkWithTypeInterpreter(op, iop.invokeDescriptor().name(), valueTypeMap);\n+                    valueTypeMap.put(op.result(), t);\n+                }\n+                case ExtendedOps.JavaForOp fop -> {\n+                    SimpleCountedForLoopInfo li = new SimpleCountedForLoopInfo(fop);\n+                    opData.put(fop, li);\n+\n+                    TypeElement type = fop.init().yieldType();\n+                    if (type instanceof VarType vt && vt.valueType().equals(JavaType.INT)) {\n+                        for (Body b : List.of(fop.cond(), fop.update(), fop.loopBody())) {\n+                            valueTypeMap.put(b.entryBlock().parameters().get(0), JavaType.INT);\n+                        }\n+                    } else {\n+                        throw new IllegalStateException();\n+                    }\n+                }\n+                case TestOperation _ -> {\n+                }\n+                case ExtendedOps.JavaContinueOp _ -> {\n+                }\n+                case YieldOp _ -> {\n+                }\n+                case ReturnOp _ -> {\n+                }\n+                default -> throw new UnsupportedOperationException(\"Unsupported operation: \" + op);\n+            }\n+\n+            return null;\n+        }));\n+    }\n+\n+    static TypeElement checkWithTypeInterpreter(Op op, String name, Map<Value, TypeElement> valueTypeMap) {\n+        \/\/ Obtain associated type-based method\n+        MethodHandle mh;\n+        try {\n+            Optional<Method> om = Stream.of(TritonTypeInterpreter.class.getDeclaredMethods())\n+                    .filter(m -> m.getName().equals(name))\n+                    .findFirst();\n+            mh = MethodHandles.lookup().unreflect(\n+                    om.orElseThrow(() -> new NoSuchMethodException(name)));\n+        } catch (ReflectiveOperationException e) {\n+            throw new IllegalStateException(name, e);\n+        }\n+\n+        \/\/ Invoke with the values' types\n+        List<TypeElement> operandTypes = op.operands().stream().map(valueTypeMap::get).toList();\n+        try {\n+            return (TypeElement) mh.invokeWithArguments(operandTypes.toArray(Object[]::new));\n+        } catch (Throwable e) {\n+            throw new IllegalStateException(mh.toString(), e);\n+        }\n+    }\n+\n+    \/\/ @@@ type check tensor shapes\n+    static class TritonTypeInterpreter {\n+        private TritonTypeInterpreter() {\n+        }\n+\n+        \/\/                 int programId(@Constant int axis) {\n+        public static JavaType programId(ConstantType axis) {\n+            assert axis.cType().equals(JavaType.INT);\n+            int axisValue = (int) axis.value();\n+            if (axisValue < 0 || axisValue > 3) {\n+                throw new IllegalStateException();\n+            }\n+\n+            return JavaType.INT;\n+        }\n+\n+        \/\/                Tensor arange(@Constant int start, @Constant int end)\n+        public static TensorType arange(ConstantType start, ConstantType end) {\n+            assert start.cType().equals(JavaType.INT);\n+            assert end.cType().equals(JavaType.INT);\n+\n+            int startValue = (int) start.value();\n+            int endValue = (int) end.value();\n+\n+            return new TensorType(JavaType.INT, List.of(endValue - startValue));\n+        }\n+\n+        \/\/                Tensor expand(Tensor a, int axis) {\n+        public static TensorType expand(TensorType a, ConstantType axis) {\n+            assert axis.cType().equals(JavaType.INT);\n+            int axisValue = (int) axis.value();\n+\n+            List<Integer> s = new ArrayList<>(a.shape());\n+            if (axisValue < s.size()) {\n+                s.add(axisValue, 1);\n+            } else {\n+                for (int i = 0; i <= (axisValue - s.size()); i++) {\n+                    s.add(1);\n+                }\n+            }\n+            return new TensorType(a.eType(), s);\n+        }\n+\n+        \/\/                Tensor load(Tensor ptr, Tensor mask)\n+        public static TensorType load(TensorType ptr, TensorType mask) {\n+            checkTensorShape(ptr, mask);\n+            if (ptr.eType() instanceof PtrType eptr) {\n+                return new TensorType(eptr.rType(), ptr.shape());\n+            }\n+\n+            throw new IllegalStateException();\n+        }\n+\n+        \/\/            void store(Tensor ptr, Tensor value, Tensor mask)\n+        public static void store(TensorType ptr, TensorType value, TensorType mask) {\n+            if (!(ptr.eType() instanceof PtrType)) {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        \/\/                Tensor zeros(TensorType type)\n+        public static TensorType zeros(ConstantType eType, ConstantType... cShape) {\n+            List<Integer> shape = Stream.of(cShape).map(s -> (int) s.value()).toList();\n+            return new TensorType((TypeElement) eType.value(), shape);\n+        }\n+\n+        \/\/                Tensor broadcast(Object o, TensorType type)\n+        public static TensorType broadcast(TypeElement o, TensorType type) {\n+            if (o instanceof TensorType ot) {\n+                \/\/ @@@\n+                if (ot.shape().size() != type.shape().size()) {\n+                    throw new IllegalStateException();\n+                }\n+                o = ot.eType();\n+            } if (o instanceof ConstantType oc) {\n+                o = oc.cType();\n+            }\n+            return new TensorType(o, type.shape());\n+        }\n+\n+        public static TensorType joinShape(TensorType a, TensorType b) {\n+            return checkTensorTypes(a, b);\n+        }\n+\n+        \/\/          Tensor add(Number a, Number b)\n+        \/\/             Ptr add(Ptr a, int offset)\n+        public static TypeElement add(TypeElement a, TypeElement b) {\n+            \/\/ @@@ Pass additional argument for checking ptr\n+            return binary(a, b);\n+        }\n+\n+        public static TypeElement sub(TypeElement a, TypeElement b) {\n+            return binary(a, b);\n+        }\n+\n+        public static TypeElement mul(TypeElement a, TypeElement b) {\n+            return binary(a, b);\n+        }\n+\n+        public static TypeElement div(TypeElement a, TypeElement b) {\n+            return binary(a, b);\n+        }\n+\n+        public static TypeElement mod(TypeElement a, TypeElement b) {\n+            return binary(a, b);\n+        }\n+\n+        public static TypeElement and(TypeElement a, TypeElement b) {\n+            return binary(a, b);\n+        }\n+\n+        public static TypeElement cdiv(TypeElement a, TypeElement b) {\n+            a = reduceScalarType(a);\n+            b = reduceScalarType(b);\n+            if (!a.equals(JavaType.INT) && !b.equals(JavaType.INT)) {\n+                throw new IllegalStateException();\n+            }\n+            return a;\n+        }\n+\n+        \/\/          Number conv(Type t, Number a) {\n+        public static TypeElement conv(ConstantType eType, TypeElement a) {\n+            return convTypes(eType, a);\n+        }\n+\n+        public static TypeElement convTypes(ConstantType eType, TypeElement a) {\n+            if (a instanceof TensorType tb) {\n+                TypeElement e = convScalarTypes(eType, tb.eType());\n+                return new TensorType(e, tb.shape());\n+            } else {\n+                return convScalarTypes(eType, a);\n+            }\n+        }\n+\n+        public static TypeElement convScalarTypes(ConstantType eType, TypeElement a) {\n+            TypeElement t = (TypeElement) eType.value();\n+            if (t.equals(Float16.FLOAT_16_TYPE) && a.equals(JavaType.FLOAT)) {\n+                return Float16.FLOAT_16_TYPE;\n+            } else if (t.equals(a)) {\n+                return t;\n+            } else {\n+                \/\/ @@@ Conversions;\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        \/\/          Tensor exp(Tensor a)\n+        public static TypeElement exp(TypeElement a) {\n+            return unary(a);\n+        }\n+\n+        static TypeElement unary(TypeElement a) {\n+            return a;\n+        }\n+\n+        \/\/                Tensor compare(Number a, Number b, @Constant CompareKind ck) {\n+        public static TypeElement compare(TypeElement a, TypeElement b, ConstantType kind) {\n+            assert kind.cType().equals(JavaType.type(Triton.CompareKind.class));\n+\n+            return binary(a, b);\n+        }\n+\n+        \/\/                Tensor dot(Tensor a, Tensor b)\n+        public static TensorType dot(TensorType a, TensorType b) {\n+            if (a.shape().size() != 2 || b.shape().size() != 2) {\n+                throw new IllegalStateException();\n+            }\n+\n+            if (!a.shape().get(1).equals(b.shape().get(0))) {\n+                throw new IllegalStateException();\n+            }\n+\n+            if (a.eType() != b.eType()) {\n+                \/\/ @@@ Conversion, type checking\n+                throw new IllegalStateException();\n+            }\n+\n+            \/\/ Computed result is tensor of floats, regardless of inputs\n+            return new TensorType(JavaType.FLOAT, List.of(a.shape().get(0), b.shape().get(1)));\n+        }\n+\n+\n+        \/\/                Tensor max(Tensor a, @Constant int axis) {\n+        public static TypeElement max(TensorType a, ConstantType axis) {\n+            return reduce(a, axis);\n+        }\n+\n+        \/\/                Tensor sum(Tensor a, @Constant int axis) {\n+        public static TypeElement sum(TensorType a, ConstantType axis) {\n+            return reduce(a, axis);\n+        }\n+\n+        static TypeElement reduce(TensorType a, ConstantType axis) {\n+            assert axis.cType().equals(JavaType.INT);\n+            int axisValue = (int) axis.value();\n+            if (axisValue < 0 || axisValue > 3) {\n+                throw new IllegalStateException();\n+            }\n+\n+            List<Integer> reduceShape = new ArrayList<>();\n+            for (int i = 0; i < a.shape().size(); i++) {\n+                if (i != axisValue) {\n+                    reduceShape.add(a.shape().get(i));\n+                } else {\n+                    reduceShape.add(1);\n+                }\n+            }\n+\n+            if (reduceShape.size() == 1 && reduceShape.getFirst() == 1) {\n+                return a.eType();\n+            } else {\n+                return new TensorType(a.eType(), reduceShape);\n+            }\n+        }\n+\n+        \/\/ @@@ Test\n+        public static void consume(TypeElement a) {\n+        }\n+\n+\n+        static TypeElement binary(TypeElement a, TypeElement b) {\n+            if (a instanceof TensorType ta && b instanceof TensorType tb) {\n+                return checkTensorTypes(ta, tb);\n+            } else if (a instanceof TensorType ta) {\n+                return new TensorType(checkScalarTypes(ta.eType(), b), ta.shape());\n+            } else if (b instanceof TensorType tb) {\n+                return new TensorType(checkScalarTypes(a, tb.eType()), tb.shape());\n+            } else {\n+                return checkScalarTypes(a, b);\n+            }\n+        }\n+\n+        static TensorType checkTensorTypes(TensorType a, TensorType b) {\n+            List<Integer> s = checkTensorShape(a, b);\n+            TypeElement e = checkScalarTypes(a.eType(), b.eType());\n+            return new TensorType(e, s);\n+        }\n+\n+        static List<Integer> checkTensorShape(TensorType a, TensorType b) {\n+            if (a.shape().size() != b.shape().size()) {\n+                \/\/ Shape mismatch\n+                throw new IllegalStateException();\n+            }\n+\n+            List<Integer> s = new ArrayList<>();\n+            for (int i = 0; i < a.shape().size(); i++) {\n+                int ad = a.shape().get(i);\n+                int bd = b.shape().get(i);\n+\n+                \/\/ Expand dimensions\n+                int d;\n+                if (ad == bd) {\n+                    d = ad;\n+                } else {\n+                    if (ad != 1 && bd == 1) {\n+                        d = ad;\n+                    } else if (ad == 1) {\n+                        d = bd;\n+                    } else {\n+                        \/\/ Shape mismatch\n+                        throw new IllegalStateException();\n+                    }\n+                }\n+\n+                s.add(d);\n+            }\n+\n+            return s;\n+        }\n+\n+        static TypeElement checkScalarTypes(TypeElement a, TypeElement b) {\n+            \/\/ @@@ Optional ptr checking\n+            if (a instanceof PtrType) {\n+                if (!b.equals(JavaType.INT)) {\n+                    throw new IllegalStateException();\n+                }\n+            } else if (b instanceof PtrType) {\n+                \/\/ Pointer must be first argument\n+                throw new IllegalStateException();\n+            } else if (a instanceof ConstantType || b instanceof ConstantType) {\n+                return checkScalarTypes(reduceScalarType(a), reduceScalarType(b));\n+            } else if (!a.equals(b)) {\n+                \/\/ @@@ Conversion\n+                throw new IllegalStateException();\n+            }\n+            return a;\n+        }\n+\n+        static TypeElement reduceScalarType(TypeElement a) {\n+            return a instanceof ConstantType ct ? ct.cType() : a;\n+        }\n+    }\n+\n+    public static <O extends Op & Op.Invokable> TritonOps.FuncOp transformToTritonFunction(\n+            O kernel,\n+            String signature,\n+            TypeElement rType,\n+            Map<Value, TypeElement> valueTypeMap, Map<Op, Object> opData,\n+            Map<String, TritonOps.FuncOp> fsymTable) {\n+        TritonOps.FuncOp ttKernel = TritonOps.func(signature, functionType(rType))\n+                .body(fblock -> {\n+                    \/\/ Process kernel parameters\n+                    List<Value> args = new ArrayList<>();\n+                    for (Block.Parameter kp : kernel.body().entryBlock().parameters()) {\n+                        TypeElement type = valueTypeMap.get(kp);\n+                        if (type instanceof ConstantType ct) {\n+                            \/\/ Constant\n+                            Op.Result cr = fblock.op(ArithMathOps.constant(\n+                                    ct.cType(), ct.value()));\n+                            args.add(cr);\n+                        } else {\n+                            args.add(fblock.parameter(type));\n+                        }\n+                    }\n+\n+                    \/\/ Transform kernel body\n+                    fblock.transformBody(kernel.body(), args, (kblock, op) -> {\n+                        return transformToTritonOperation(kblock, op, valueTypeMap, opData, fsymTable);\n+                    });\n+                });\n+\n+        ttKernel = cleanup(ttKernel);\n+        fsymTable.put(ttKernel.funcName(), ttKernel);\n+        return ttKernel;\n+    }\n+\n+    static Block.Builder transformToTritonOperation(Block.Builder kblock, Op op,\n+                                                    Map<Value, TypeElement> valueTypeMap, Map<Op, Object> opData,\n+                                                    Map<String, TritonOps.FuncOp> fsymTable) {\n+        \/\/ @@@ Avoid constructing for each operation -- block builder passed as argument or a scoped value\n+        TritonBuilderInterpreter tbi = new TritonBuilderInterpreter(fsymTable, kblock);\n+        CopyContext cc = kblock.context();\n+        switch (op) {\n+            case VarOp varOp -> {\n+                \/\/ @@@ Cannot copy op because the result type\n+                \/\/     is derived from init type\n+                Value init = cc.getValue(op.operands().get(0));\n+                Op.Result r = kblock.op(var(varOp.varName(), init));\n+                cc.mapValue(op.result(), r);\n+            }\n+            case ConstantOp cop -> {\n+                TypeElement t = valueTypeMap.get(cop.result());\n+                if (t instanceof ConstantType ct) {\n+                    Op.Result r = kblock.op(ArithMathOps.constant(\n+                            ct.cType(), ct.value()));\n+                    cc.mapValue(op.result(), r);\n+                } else {\n+                    kblock.op(op);\n+                }\n+            }\n+            case ArithmeticOperation _ -> {\n+                Value result = tbi.build(op, op.opName(), valueTypeMap);\n+                if (result != null) {\n+                    cc.mapValue(op.result(), result);\n+                }\n+            }\n+            case InvokeOp iop when iop.invokeDescriptor().refType().equals(JavaType.J_L_INTEGER) -> {\n+                \/\/ Replace box with its value\n+                Value a = cc.getValue(op.operands().get(0));\n+                cc.mapValue(op.result(), a);\n+            }\n+            case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_J_L_MATH) -> {\n+                String name = iop.invokeDescriptor().name();\n+                if (name.equals(\"max\")) {\n+                    Value a = cc.getValue(op.operands().get(0));\n+                    Value b = cc.getValue(op.operands().get(1));\n+\n+                    Op.Result result = kblock.op(ArithMathOps.maximum(a, b));\n+                    cc.mapValue(op.result(), result);\n+                } else if (name.equals(\"min\")) {\n+                    Value a = cc.getValue(op.operands().get(0));\n+                    Value b = cc.getValue(op.operands().get(1));\n+\n+                    Op.Result result = kblock.op(ArithMathOps.minimum(a, b));\n+                    cc.mapValue(op.result(), result);\n+                }\n+            }\n+            case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_Tensor) -> {\n+                if (iop.invokeDescriptor().name().equals(\"type\")) {\n+                    \/\/ Replace with constant operation to produce tensor type.\n+                    \/\/ Result may be used, but transitively it will be removed due to no uses\n+                    \/\/ contributing to the computation\n+                    Value a = op.operands().get(0);\n+                    TensorType aType = (TensorType) valueTypeMap.get(a);\n+                    Op.Result result = kblock.op(CoreOps.constant(iop.resultType(), aType));\n+                    cc.mapValue(op.result(), result);\n+                    valueTypeMap.put(result, aType);\n+                }\n+                \/\/ Remove\n+            }\n+            case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_Triton) -> {\n+                Value result = tbi.build(op, iop.invokeDescriptor().name(), valueTypeMap);\n+                if (result != null) {\n+                    cc.mapValue(op.result(), result);\n+                }\n+            }\n+            case InvokeOp iop when iop.invokeDescriptor().refType().equals(TYPE_Triton_Test) -> {\n+                Value result = tbi.build(op, iop.invokeDescriptor().name(), valueTypeMap);\n+                if (result != null) {\n+                    cc.mapValue(op.result(), result);\n+                }\n+            }\n+            case ExtendedOps.JavaForOp fop -> {\n+                transformToSCFFor(cc, kblock, fop, valueTypeMap, opData, fsymTable);\n+            }\n+            case ReturnOp rop -> {\n+                if (rop.operands().isEmpty()) {\n+                    kblock.op(TritonOps.return_());\n+                } else {\n+                    kblock.op(TritonOps.return_(\n+                            cc.getValue(rop.returnValue())));\n+                }\n+            }\n+            default -> kblock.op(op);\n+        }\n+        return kblock;\n+    }\n+\n+    static void transformToSCFFor(CopyContext cc, Block.Builder kblock, ExtendedOps.JavaForOp fop,\n+                                  Map<Value, TypeElement> valueTypeMap, Map<Op, Object> opData,\n+                                  Map<String, TritonOps.FuncOp> fsymTable) {\n+        Body body = fop.loopBody();\n+\n+        \/\/ Hoist expressions for start, end, and step\n+        SimpleCountedForLoopInfo li = (SimpleCountedForLoopInfo) opData.get(fop);\n+        Value start = null;\n+        for (Op o : li.startExpression()) {\n+            transformToTritonOperation(kblock, o, valueTypeMap, opData, fsymTable);\n+            start = cc.getValue(o.result());\n+        }\n+        Value end = null;\n+        for (Op o : li.endExpression()) {\n+            transformToTritonOperation(kblock, o, valueTypeMap, opData, fsymTable);\n+            end = cc.getValue(o.result());\n+        }\n+        Value step = null;\n+        for (Op o : li.stepExpression()) {\n+            transformToTritonOperation(kblock, o, valueTypeMap, opData, fsymTable);\n+            step = cc.getValue(o.result());\n+        }\n+\n+        \/\/ Obtain captured vars\n+        \/\/ true == stores\n+        \/\/ false == loads only\n+        Map<Boolean, Set<Value>> capturedVars = capturedVars(body);\n+        Set<Value> capturedAndStoredVars = capturedVars.get(true);\n+\n+        \/\/ Get load values\n+        \/\/ Loaded values are hoisted out of the loop body\n+        Map<Value, Value> loadValues = new HashMap<>();\n+        for (Value v : capturedVars.get(false)) {\n+            Value load = kblock.op(varLoad(cc.getValue(v)));\n+            valueTypeMap.put(load, valueTypeMap.get(v));\n+            loadValues.put(v, load);\n+        }\n+\n+        \/\/ Get iteration values -- represented by captured vars that are stored to in the loop\n+        \/\/ The SCF for operation returns the iteration values of the last loop iteration, which\n+        \/\/ are then to be stored to the iteration variables\n+        List<Value> iterValues = new ArrayList<>();\n+        for (Value v : capturedAndStoredVars) {\n+            iterValues.add(kblock.op(varLoad(cc.getValue(v))));\n+        }\n+\n+        \/\/ @@@ Build in java code model, then transform?\n+        SCFOps.ForOp scffor = SCFOps.for_(kblock.parentBody(), start, end, step, iterValues)\n+                \/\/ Ensure existing context is used\n+                .body(CopyContext.create(cc), builder -> {\n+                    \/\/ Create index var initialized from entry block parameter\n+                    Value index = builder.parameters().get(0);\n+                    valueTypeMap.put(index, JavaType.INT);\n+                    Value varIndex = builder.op(var(\"index\", index));\n+                    valueTypeMap.put(varIndex, JavaType.INT);\n+                    builder.context().mapValue(body.entryBlock().parameters().get(0), varIndex);\n+\n+                    \/\/ Create iter vars initialized from entry block parameters\n+                    int pi = 1;\n+                    for (Value v : capturedAndStoredVars) {\n+                        TypeElement type = valueTypeMap.get(v);\n+                        Value iter = builder.parameters().get(pi++);\n+                        valueTypeMap.put(iter, type);\n+                        Value varIter = builder.op(var(Integer.toString(pi), iter));\n+                        valueTypeMap.put(varIter, type);\n+                        builder.context().mapValue(v, varIter);\n+                    }\n+\n+                    \/\/ Transform the Java for body into the SCF for body\n+                    builder.transformBody(body, List.of(), (block, op) -> {\n+                        \/\/ Yield iter values\n+                        if (op instanceof ExtendedOps.JavaContinueOp) {\n+                            \/\/ Replace with yield of loaded vars\n+                            List<Value> yieldValues = new ArrayList<>();\n+                            for (Value value : capturedAndStoredVars) {\n+                                Value varIter = block.context().getValue(value);\n+                                Value v = block.op(varLoad(varIter));\n+                                yieldValues.add(v);\n+                            }\n+                            block.op(SCFOps.yield_(yieldValues));\n+                        } else if (op instanceof VarAccessOp.VarLoadOp) {\n+                            \/\/ Replace with value loaded immediately before loop\n+                            Value v = op.operands().get(0);\n+                            if (capturedVars.get(false).contains(v)) {\n+                                block.context().mapValue(op.result(), loadValues.get(v));\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        } else {\n+                            block = transformToTritonOperation(block, op, valueTypeMap, opData, fsymTable);\n+                        }\n+                        return block;\n+                    });\n+                });\n+        Op.Result forResult = kblock.op(scffor);\n+\n+        \/\/ Assign back result to iter vars\n+        if (capturedAndStoredVars.size() == 1) {\n+            for (Value v : capturedAndStoredVars) {\n+                kblock.op(varStore(cc.getValue(v), forResult));\n+            }\n+        } else {\n+            int i = 0;\n+            for (Value v : capturedAndStoredVars) {\n+                kblock.op(varStore(cc.getValue(v),\n+                        kblock.op(tupleLoad(forResult, i++))));\n+            }\n+        }\n+    }\n+\n+    static Map<Boolean, Set<Value>> capturedVars(Body body) {\n+        Map<Boolean, Set<Value>> capturedValues = new HashMap<>();\n+        capturedValues.put(false, new LinkedHashSet<>());\n+        capturedValues.put(true, new LinkedHashSet<>());\n+\n+        capturedVars(capturedValues, new ArrayDeque<>(), body);\n+        return capturedValues;\n+    }\n+\n+    static void capturedVars(Map<Boolean, Set<Value>> capturedVars, Deque<Body> bodyStack, Body body) {\n+        bodyStack.push(body);\n+\n+        for (Block b : body.blocks()) {\n+            for (Op op : b.ops()) {\n+                \/\/ @@@ Nested bodies\n+                if (!op.bodies().isEmpty()) {\n+                    throw new IllegalStateException();\n+                }\n+\/\/                for (Body childBody : op.bodies()) {\n+\/\/                    capturedAndUpdatedVars(capturedValues, bodyStack, childBody);\n+\/\/                }\n+\n+                if (op instanceof VarAccessOp) {\n+                    Value v = op.operands().get(0);\n+                    if (!bodyStack.contains(v.declaringBlock().parentBody())) {\n+                        if (op instanceof VarAccessOp.VarStoreOp) {\n+                            capturedVars.get(true).add(v);\n+                            capturedVars.get(false).remove(v);\n+                        } else if (!capturedVars.get(true).contains(v)) {\n+                            capturedVars.get(false).add(v);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        bodyStack.pop();\n+    }\n+\n+    public static final ScopedValue<Boolean> SV_SSA = ScopedValue.newInstance();\n+\n+    static TritonOps.FuncOp cleanup(TritonOps.FuncOp f) {\n+        \/\/ Remove var ops\n+        boolean doSSA = SV_SSA.isBound() ? SV_SSA.get() : true;\n+        if (doSSA) {\n+            f = SSA.transform(f);\n+        }\n+        \/\/ Remove unused ops\n+        f = f.transform((fblock, op) -> {\n+            if (op instanceof Op.Pure && op.result().uses().isEmpty()) {\n+                return fblock;\n+            } else if (op instanceof VarAccessOp.VarLoadOp && op.result().uses().isEmpty()) {\n+                return fblock;\n+            }\n+\n+            fblock.op(op);\n+            return fblock;\n+        });\n+        return f;\n+    }\n+\n+    static class TritonBuilderInterpreter {\n+        final Map<String, TritonOps.FuncOp> fsymTable;\n+        final Block.Builder block;\n+\n+        TritonBuilderInterpreter(Map<String, TritonOps.FuncOp> fsymTable, Block.Builder block) {\n+            this.fsymTable = fsymTable;\n+            this.block = block;\n+        }\n+\n+        Value build(Op op, String name, Map<Value, TypeElement> valueTypeMap) {\n+            \/\/ Obtain associated type-based method\n+            MethodHandle mh;\n+            try {\n+                Optional<Method> om = Stream.of(TritonBuilderInterpreter.class.getDeclaredMethods())\n+                        .filter(m -> m.getName().equals(name))\n+                        .findFirst();\n+                mh = MethodHandles.lookup().unreflect(\n+                        om.orElseThrow(() -> new NoSuchMethodException(name)));\n+            } catch (ReflectiveOperationException e) {\n+                throw new IllegalStateException(e);\n+            }\n+\n+            List<Object> iArgs = new ArrayList<>();\n+            iArgs.add(this);\n+            iArgs.add(valueTypeMap.get(op.result()));\n+            iArgs.add(op.result());\n+            for (Value o : op.operands()) {\n+                iArgs.add(valueTypeMap.get(o));\n+                iArgs.add(o);\n+            }\n+            try {\n+                return (Value) mh.invokeWithArguments(iArgs.toArray(Object[]::new));\n+            } catch (Throwable e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+\n+        public Value programId(TypeElement rType, Op.Result r,\n+                               ConstantType axisType, Value axis) {\n+            return block.op(TritonOps.getProgramId(\n+                    (int) axisType.value()));\n+        }\n+\n+        public Value arange(TensorType rType, Op.Result r,\n+                            ConstantType startType, Value start,\n+                            ConstantType endType, Value end) {\n+            return block.op(TritonOps.makeRange(\n+                    (int) startType.value(),\n+                    (int) endType.value()));\n+        }\n+\n+        public Value expand(TensorType rType, Op.Result r,\n+                            TensorType aType, Value a,\n+                            ConstantType axisType, Value axis) {\n+            return block.op(TritonOps.expand(\n+                    (int) axisType.value(),\n+                    rType,\n+                    block.context().getValue(a)));\n+        }\n+\n+        public Value zeros(TensorType rType, Op.Result r,\n+                           ConstantType aType, Value a,\n+                           Object... constantsAndValues) {\n+            Object zero;\n+            try {\n+                JavaType zeroType = (JavaType) aType.value();\n+                zero = MethodHandles.zero(zeroType.resolve(MethodHandles.lookup())).invoke();\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+            return block.op(ArithMathOps.constant(rType, zero));\n+        }\n+\n+        public Value load(TensorType rType, Op.Result r,\n+                          TensorType ptrType, Value ptr,\n+                          TensorType maskType, Value mask) {\n+            broadcastConversionRight(ptrType, maskType, mask);\n+            return block.op(TritonOps.load(\n+                    rType,\n+                    block.context().getValue(ptr),\n+                    block.context().getValue(mask)));\n+        }\n+\n+        public Value store(TensorType rType, Op.Result r,\n+                           TensorType ptrType, Value ptr,\n+                           TensorType valueType, Value value,\n+                           TensorType maskType, Value mask) {\n+            broadcastConversionRight(ptrType, valueType, value);\n+            broadcastConversionRight(ptrType, maskType, mask);\n+            return block.op(TritonOps.store(\n+                    block.context().getValue(ptr),\n+                    block.context().getValue(value),\n+                    block.context().getValue(mask)));\n+        }\n+\n+        public Value broadcast(TensorType rType, Op.Result r,\n+                               TypeElement oType, Value o,\n+                               TensorType tensorTypeType, Value tensorType) {\n+            \/\/ @@@ tt.splat with scalar operand, tt.broadcast with tensor operand\n+            if (oType instanceof TensorType) {\n+                return block.op(TritonOps.broadcast(\n+                        rType,\n+                        block.context().getValue(o)));\n+            } else {\n+                return block.op(TritonOps.splat(\n+                        rType,\n+                        block.context().getValue(o)));\n+            }\n+        }\n+\n+        public Value joinShape(TensorType rType, Op.Result r,\n+                               TensorType aType, Value a,\n+                               TensorType bType, Value b) {\n+            \/\/ Replace with constant operation to produce tensor type.\n+            \/\/ Result may be used, but transitively it will be removed due to no uses\n+            \/\/ contributing to the computation\n+            return block.op(CoreOps.constant(JavaType.type(TensorType.class), r.type()));\n+        }\n+\n+\n+        public Value add(TypeElement rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            if (rType instanceof PtrType ||\n+                    rType instanceof TensorType t && t.eType() instanceof PtrType) {\n+                return block.op(TritonOps.addptr(a, b));\n+            } else {\n+                return block.op(ArithMathOps.add(a, b));\n+            }\n+        }\n+\n+        public Value sub(TypeElement rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(ArithMathOps.sub(a, b));\n+        }\n+\n+        public Value mul(TypeElement rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(ArithMathOps.mul(a, b));\n+        }\n+\n+        public Value div(TypeElement rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(ArithMathOps.div(a, b));\n+        }\n+\n+        public Value mod(TypeElement rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(ArithMathOps.rem(a, b));\n+        }\n+\n+        public Value and(TypeElement rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(ArithMathOps.and(a, b));\n+        }\n+\n+        public Value dot(TensorType rType, Op.Result r,\n+                         TypeElement aType, Value a,\n+                         TypeElement bType, Value b) {\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(TritonOps.dot(rType, a, b));\n+        }\n+\n+        public Value cdiv(TypeElement rType, Op.Result r,\n+                          TypeElement aType, Value a,\n+                          TypeElement bType, Value b) {\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            TritonOps.FuncOp cdiv = tritonFunction(Functions.getJavaCodeModel(\"cdiv\"),\n+                    rType, List.of(aType, bType),\n+                    fsymTable);\n+            \/\/ @@@ Generalize\n+            List<Value> args = new ArrayList<>();\n+            if (!(aType instanceof ConstantType)) {\n+                args.add(a);\n+            }\n+            if (!(bType instanceof ConstantType)) {\n+                args.add(b);\n+            }\n+            return block.op(TritonOps.call(cdiv, args));\n+        }\n+\n+        public Value conv(TypeElement rType, Op.Result r,\n+                          ConstantType tType, Value t,\n+                          TypeElement aType, Value a) {\n+            a = block.context().getValue(a);\n+\n+            TypeElement rScalarType;\n+            TypeElement aScalarType;\n+            if (rType instanceof TensorType rTensorType && aType instanceof TensorType aTensorType) {\n+                rScalarType = rTensorType.eType();\n+                aScalarType = aTensorType.eType();\n+            } else {\n+                rScalarType = rType;\n+                aScalarType = aType;\n+            }\n+\n+            if (rScalarType.equals(Float16.FLOAT_16_TYPE) && aScalarType.equals(JavaType.FLOAT)) {\n+                return block.op(ArithMathOps.trunc(rType, a));\n+            } else if (rType.equals(aType)) {\n+                return a;\n+            } else {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        public Value exp(TritonType rType, Op.Result r,\n+                         TritonType aType, Value a) {\n+            return block.op(ArithMathOps.exp(\n+                    block.context().getValue(a)));\n+        }\n+\n+        public Value compare(TensorType rType, Op.Result r,\n+                             TypeElement aType, Value a,\n+                             TypeElement bType, Value b,\n+                             ConstantType compareType, Value compare) {\n+            Triton.CompareKind ck = (Triton.CompareKind) compareType.value();\n+\n+            ArithMathOps.CompareOp.CompareKind ack = switch (ck) {\n+                case LessThan -> ArithMathOps.CompareOp.CompareKind.slt;\n+                default -> throw new UnsupportedOperationException(\"Unsupported comparison: \" + ck);\n+            };\n+\n+            broadcastConversion(rType, aType, a, bType, b);\n+            a = block.context().getValue(a);\n+            b = block.context().getValue(b);\n+\n+            return block.op(ArithMathOps.cmp(ack, a, b));\n+        }\n+\n+\n+        public Value max(TypeElement rType, Op.Result r,\n+                         TensorType xType, Value x,\n+                         ConstantType axisType, Value axis) {\n+            TritonOps.FuncOp f = tritonFunction(Functions.getJavaCodeModel(\"max\"),\n+                    rType, List.of(rType, rType), fsymTable);\n+            return reduce(rType, r, xType, x, axisType, axis, f);\n+        }\n+\n+        public Value sum(TypeElement rType, Op.Result r,\n+                         TensorType xType, Value x,\n+                         ConstantType axisType, Value axis) {\n+            TritonOps.FuncOp f = tritonFunction(Functions.getJavaCodeModel(\"sum\"),\n+                    rType, List.of(rType, rType), fsymTable);\n+            return reduce(rType, r, xType, x, axisType, axis, f);\n+        }\n+\n+        Value reduce(TypeElement rType, Op.Result r,\n+                     TensorType xType, Value x,\n+                     ConstantType axisType, Value axis,\n+                     TritonOps.FuncOp f) {\n+            int axisConstant = (int) axisType.value();\n+\n+            String signature = \"reduce_\" + f.funcName() + \"_\" + axisConstant;\n+            TritonOps.FuncOp rf = fsymTable.computeIfAbsent(signature,\n+                    s -> reduce(rType, xType, axisConstant, s, f));\n+\n+            return block.op(TritonOps.call(rf, block.context().getValue(x)));\n+        }\n+\n+        static TritonOps.FuncOp reduce(TypeElement elementType,\n+                                       TensorType tensorType,\n+                                       int axisConstant,\n+                                       String name, TritonOps.FuncOp scalarFunc) {\n+            return TritonOps.func(name,\n+                            functionType(elementType, tensorType))\n+                    .body(fblock -> {\n+                        TritonOps.ReduceOp reduceOp = TritonOps.reduce(fblock.parentBody(),\n+                                        axisConstant, fblock.parameters().get(0),\n+                                        functionType(elementType, elementType, elementType))\n+                                .body(rblock -> {\n+                                    Block.Parameter a = rblock.parameters().get(0);\n+                                    Block.Parameter b = rblock.parameters().get(1);\n+                                    Op.Result _r = rblock.op(TritonOps.call(scalarFunc, a, b));\n+                                    rblock.op(TritonOps.reduceReturn(_r));\n+                                });\n+\n+                        Op.Result opr = fblock.op(reduceOp);\n+                        fblock.op(TritonOps.return_(opr));\n+                    });\n+        }\n+\n+        \/\/ @@@ Test\n+        public Value consume(TypeElement rType, Op.Result r,\n+                             TypeElement aType, Value a) {\n+            return block.op(TritonTestOps.consume(block.context().getValue(a)));\n+        }\n+\n+        void broadcastConversion(TypeElement rType,\n+                                 TypeElement aType, Value a,\n+                                 TypeElement bType, Value b) {\n+            Value ma = block.context().getValue(a);\n+            Value mb = block.context().getValue(b);\n+            if (aType instanceof TensorType at && bType instanceof TensorType bTensorType) {\n+                TensorType rTensorType = (TensorType) rType;\n+                if (!at.shape().equals(rTensorType.shape())) {\n+                    ma = block.op(TritonOps.broadcast(rTensorType, ma));\n+                }\n+                if (!bTensorType.shape().equals(rTensorType.shape())) {\n+                    if (rTensorType.eType() instanceof PtrType) {\n+                        bTensorType = new TensorType(bType, rTensorType.shape());\n+                        mb = block.op(TritonOps.broadcast(bTensorType, mb));\n+                    } else {\n+                        mb = block.op(TritonOps.broadcast(rTensorType, mb));\n+                    }\n+                }\n+            } else if (aType instanceof TensorType) {\n+                TensorType rTensorType = (TensorType) rType;\n+                if (rTensorType.eType() instanceof PtrType) {\n+                    TensorType bTensorType = new TensorType(bType, rTensorType.shape());\n+                    mb = block.op(TritonOps.splat(bTensorType, mb));\n+                } else {\n+                    mb = block.op(TritonOps.splat(rTensorType, mb));\n+                }\n+            } else if (bType instanceof TensorType) {\n+                TensorType rTensorType = (TensorType) rType;\n+                ma = block.op(TritonOps.splat(rTensorType, ma));\n+            }\n+            block.context().mapValue(a, ma);\n+            block.context().mapValue(b, mb);\n+        }\n+\n+        void broadcastConversionRight(TypeElement aType,\n+                                      TypeElement bType, Value b) {\n+            Value mb = block.context().getValue(b);\n+            if (aType instanceof TensorType aTensorType && bType instanceof TensorType bTensorType) {\n+                if (!bTensorType.shape().equals(aTensorType.shape())) {\n+                    if (aTensorType.eType() instanceof PtrType) {\n+                        bTensorType = new TensorType(bTensorType.eType(), aTensorType.shape());\n+                        mb = block.op(TritonOps.broadcast(bTensorType, mb));\n+                    } else {\n+                        mb = block.op(TritonOps.broadcast(aTensorType, mb));\n+                    }\n+                }\n+            } else if (aType instanceof TensorType rTensorType) {\n+                if (rTensorType.eType() instanceof PtrType) {\n+                    TensorType bTensorType = new TensorType(bType, rTensorType.shape());\n+                    mb = block.op(TritonOps.splat(bTensorType, mb));\n+                } else {\n+                    mb = block.op(TritonOps.splat(rTensorType, mb));\n+                }\n+            }\n+            block.context().mapValue(b, mb);\n+        }\n+    }\n+\n+    public static <O extends Op & Op.Invokable> void printTypeMap(\n+            O kernel, Map<Value, TypeElement> valueTypeMap) {\n+        AtomicInteger valueId = new AtomicInteger();\n+        Map<Value, Integer> valueIdMap = new LinkedHashMap<>();\n+        kernel.traverse(null, (o, codeElement) -> {\n+            switch (codeElement) {\n+                case FuncOp _ -> {\n+                    \/\/ Ignore\n+                }\n+                case Op op when !op.result().type().equals(JavaType.VOID) -> {\n+                    valueIdMap.put(op.result(), valueId.getAndIncrement());\n+                }\n+                case Block block -> {\n+                    for (Block.Parameter parameter : block.parameters()) {\n+                        valueIdMap.put(parameter, valueId.getAndIncrement());\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return null;\n+        });\n+\n+        valueIdMap.forEach((value, id) -> {\n+            TypeElement type = valueTypeMap.get(value);\n+            if (type != null) {\n+                System.out.println(\"%\" + id + \" : \" + value.type() + \" -> \" + type);\n+            }\n+        });\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":1239,"deletions":0,"binary":false,"changes":1239,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.reflect.code.TypeElement;\n+\n+public abstract sealed class TritonType implements TypeElement\n+        permits ConstantType, PtrType, TensorType {\n+}\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonType.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import oracle.code.triton.TritonTestExtension.TritonTestData;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestAddKernel {\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"add_kernel_ptr<float>_ptr<float>_ptr<float>_int_64_void\" (%0 : ptr<float>, %1 : ptr<float>, %2 : ptr<float>, %3 : int)void -> {\n+                    %4 : int = arith.constant @\"64\";\n+                    %5 : int = tt.get_program_id @\"0\";\n+                    %6 : int = arith.muli %5 %4;\n+                    %7 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %8 : tensor<x64, int> = tt.splat %6;\n+                    %9 : tensor<x64, int> = arith.addi %8 %7;\n+                    %10 : tensor<x64, int> = tt.splat %3;\n+                    %11 : tensor<x64, int> = arith.cmpi %9 %10 @\"slt\";\n+                    %12 : tensor<x64, ptr<float>> = tt.splat %0;\n+                    %13 : tensor<x64, ptr<float>> = tt.addptr %12 %9;\n+                    %14 : tensor<x64, float> = tt.load %13 %11;\n+                    %15 : tensor<x64, ptr<float>> = tt.splat %1;\n+                    %16 : tensor<x64, ptr<float>> = tt.addptr %15 %9;\n+                    %17 : tensor<x64, float> = tt.load %16 %11;\n+                    %18 : tensor<x64, float> = arith.addf %14 %17;\n+                    %19 : tensor<x64, ptr<float>> = tt.splat %2;\n+                    %20 : tensor<x64, ptr<float>> = tt.addptr %19 %9;\n+                    tt.store %20 %18 %11;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void add_kernel(Ptr x_ptr,  \/\/ *Pointer* to first input vector.\n+                           Ptr y_ptr,  \/\/ *Pointer* to second input vector.\n+                           Ptr output_ptr,  \/\/ *Pointer* to output vector.\n+                           int n_elements,  \/\/ Size of the vector.\n+                           @Constant int BLOCK_SIZE)  \/\/ Number of elements each program should process.\n+    \/\/ NOTE: @Constant so it can be used as a shape value\n+    {\n+        \/\/ There are multiple 'programs' processing different data. We identify which program\n+        \/\/ we are here:\n+        var pid = Triton.programId(0); \/\/ We use a 1D launch grid so axis is 0.\n+        \/\/ This program will process inputs that are offset from the initial data.\n+        \/\/ For instance, if you had a vector of length 256 and block_size of 64, the programs\n+        \/\/ would each access the elements [0:64, 64:128, 128:192, 192:256].\n+        \/\/ Note that offsets is a list of pointers:\n+        var block_start = pid * BLOCK_SIZE;\n+        var range = Triton.arange(0, BLOCK_SIZE);\n+        var offsets = Triton.add(Triton.broadcast(block_start, range.type()), range);\n+        \/\/ Create a mask to guard memory operations against out-of-bounds accesses.\n+        var mask = Triton.compare(offsets, Triton.broadcast(n_elements, offsets.type()), Triton.CompareKind.LessThan);\n+        \/\/ Load x and y from DRAM, masking out any extra elements in case the input is not a\n+        \/\/ multiple of the block size.\n+        var x = Triton.load(Triton.add(Triton.broadcast(x_ptr, offsets.type()), offsets), mask);\n+        var y = Triton.load(Triton.add(Triton.broadcast(y_ptr, offsets.type()), offsets), mask);\n+        var output = Triton.add(x, y);\n+        \/\/ Write x + y back to DRAM.\n+        Triton.store(Triton.add(Triton.broadcast(output_ptr, offsets.type()), offsets), output, mask);\n+    }\n+\n+    @TritonTestExtension.Kernel(\"add_kernel\")\n+    @Test\n+    public void test(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"add_kernel2_ptr<float>_ptr<float>_ptr<float>_int_64_void\" (%0 : ptr<float>, %1 : ptr<float>, %2 : ptr<float>, %3 : int)void -> {\n+                    %4 : int = arith.constant @\"64\";\n+                    %5 : int = tt.get_program_id @\"0\";\n+                    %6 : int = arith.muli %5 %4;\n+                    %7 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %8 : tensor<x64, int> = tt.splat %6;\n+                    %9 : tensor<x64, int> = arith.addi %8 %7;\n+                    %10 : tensor<x64, int> = tt.splat %3;\n+                    %11 : tensor<x64, int> = arith.cmpi %9 %10 @\"slt\";\n+                    %12 : tensor<x64, ptr<float>> = tt.splat %0;\n+                    %13 : tensor<x64, ptr<float>> = tt.addptr %12 %9;\n+                    %14 : tensor<x64, float> = tt.load %13 %11;\n+                    %15 : tensor<x64, ptr<float>> = tt.splat %1;\n+                    %16 : tensor<x64, ptr<float>> = tt.addptr %15 %9;\n+                    %17 : tensor<x64, float> = tt.load %16 %11;\n+                    %18 : tensor<x64, float> = arith.addf %14 %17;\n+                    %19 : tensor<x64, ptr<float>> = tt.splat %2;\n+                    %20 : tensor<x64, ptr<float>> = tt.addptr %19 %9;\n+                    tt.store %20 %18 %11;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void add_kernel2(Ptr x_ptr,  \/\/ *Pointer* to first input vector.\n+                            Ptr y_ptr,  \/\/ *Pointer* to second input vector.\n+                            Ptr output_ptr,  \/\/ *Pointer* to output vector.\n+                            int n_elements,  \/\/ Size of the vector.\n+                            @Constant int BLOCK_SIZE)  \/\/ Number of elements each program should process.\n+    \/\/ NOTE: @Constant so it can be used as a shape value\n+    {\n+        \/\/ There are multiple 'programs' processing different data. We identify which program\n+        \/\/ we are here:\n+        var pid = Triton.programId(0); \/\/ We use a 1D launch grid so axis is 0.\n+        \/\/ This program will process inputs that are offset from the initial data.\n+        \/\/ For instance, if you had a vector of length 256 and block_size of 64, the programs\n+        \/\/ would each access the elements [0:64, 64:128, 128:192, 192:256].\n+        \/\/ Note that offsets is a list of pointers:\n+        var block_start = pid * BLOCK_SIZE;\n+        var range = Triton.arange(0, BLOCK_SIZE);\n+        var offsets = Triton.add(block_start, range);\n+        \/\/ Create a mask to guard memory operations against out-of-bounds accesses.\n+        var mask = Triton.compare(offsets, n_elements, Triton.CompareKind.LessThan);\n+        \/\/ Load x and y from DRAM, masking out any extra elements in case the input is not a\n+        \/\/ multiple of the block size.\n+        var x = Triton.load(Triton.add(x_ptr, offsets), mask);\n+        var y = Triton.load(Triton.add(y_ptr, offsets), mask);\n+        var output = Triton.add(x, y);\n+        \/\/ Write x + y back to DRAM.\n+        Triton.store(Triton.add(output_ptr, offsets), output, mask);\n+    }\n+\n+    @TritonTestExtension.Kernel(\"add_kernel2\")\n+    @Test\n+    public void test2(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+}\n+\n+\/*\n+@triton.jit\n+def add_kernel(x_ptr,  # *Pointer* to first input vector.\n+               y_ptr,  # *Pointer* to second input vector.\n+               output_ptr,  # *Pointer* to output vector.\n+               n_elements,  # Size of the vector.\n+               BLOCK_SIZE: tl.constexpr,  # Number of elements each program should process.\n+               # NOTE: `constexpr` so it can be used as a shape value.\n+               ):\n+    # There are multiple 'programs' processing different data. We identify which program\n+    # we are here:\n+    pid = tl.program_id(axis=0)  # We use a 1D launch grid so axis is 0.\n+    # This program will process inputs that are offset from the initial data.\n+    # For instance, if you had a vector of length 256 and block_size of 64, the programs\n+    # would each access the elements [0:64, 64:128, 128:192, 192:256].\n+    # Note that offsets is a list of pointers:\n+    block_start = pid * BLOCK_SIZE\n+    offsets = block_start + tl.arange(0, BLOCK_SIZE)\n+    # Create a mask to guard memory operations against out-of-bounds accesses.\n+    mask = offsets < n_elements\n+    # Load x and y from DRAM, masking out any extra elements in case the input is not a\n+    # multiple of the block size.\n+    x = tl.load(x_ptr + offsets, mask=mask)\n+    y = tl.load(y_ptr + offsets, mask=mask)\n+    output = x + y\n+    # Write x + y back to DRAM.\n+    tl.store(output_ptr + offsets, output, mask=mask)\n+*\/\n+\n+\/*\n+module {\n+  tt.func public @add_kernel_0123(%arg0: !tt.ptr<f32, 1> , %arg1: !tt.ptr<f32, 1> , %arg2: !tt.ptr<f32, 1> , %arg3: i32 ) attributes {noinline = false} {\n+    %0 = tt.get_program_id x : i32\n+    %c64_i32 = arith.constant 64 : i32\n+    %1 = arith.muli %0, %c64_i32 : i32\n+    %2 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32>\n+    %3 = tt.splat %1 : (i32) -> tensor<64xi32>\n+    %4 = arith.addi %3, %2 : tensor<64xi32>\n+    %5 = tt.splat %arg3 : (i32) -> tensor<64xi32>\n+    %6 = arith.cmpi slt, %4, %5 : tensor<64xi32>\n+    %7 = tt.splat %arg0 : (!tt.ptr<f32, 1>) -> tensor<64x!tt.ptr<f32, 1>>\n+    %8 = tt.addptr %7, %4 : tensor<64x!tt.ptr<f32, 1>>, tensor<64xi32>\n+    %9 = tt.load %8, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n+    %10 = tt.splat %arg1 : (!tt.ptr<f32, 1>) -> tensor<64x!tt.ptr<f32, 1>>\n+    %11 = tt.addptr %10, %4 : tensor<64x!tt.ptr<f32, 1>>, tensor<64xi32>\n+    %12 = tt.load %11, %6 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n+    %13 = arith.addf %9, %12 : tensor<64xf32>\n+    %14 = tt.splat %arg2 : (!tt.ptr<f32, 1>) -> tensor<64x!tt.ptr<f32, 1>>\n+    %15 = tt.addptr %14, %4 : tensor<64x!tt.ptr<f32, 1>>, tensor<64xi32>\n+    tt.store %15, %13, %6 {cache = 1 : i32, evict = 1 : i32} : tensor<64xf32>\n+    tt.return\n+  }\n+}\n+*\/\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestAddKernel.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import oracle.code.triton.TritonTestExtension.TritonTestData;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+import static oracle.code.triton.Triton.*;\n+import static oracle.code.triton.TritonTest.consume;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestBroadcast {\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"test1_ptr<int>_int_64_void\" (%0 : ptr<int>, %1 : int)void -> {\n+                    %2 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %3 : tensor<x64, ptr<int>> = tt.splat %0;\n+                    %4 : tensor<x64, ptr<int>> = tt.addptr %3 %2;\n+                    tt.consume %4;\n+                    %5 : tensor<x64, int> = tt.splat %1;\n+                    %6 : tensor<x64, int> = arith.addi %5 %2;\n+                    tt.consume %6;\n+                    %7 : tensor<x64, int> = tt.splat %1;\n+                    %8 : tensor<x64, int> = arith.addi %2 %7;\n+                    tt.consume %8;\n+                    %9 : tensor<x64, int> = tt.splat %1;\n+                    %10 : tensor<x64, int> = arith.addi %9 %2;\n+                    tt.consume %10;\n+                    %11 : tensor<x64, int> = tt.splat %1;\n+                    %12 : tensor<x64, int> = arith.addi %2 %11;\n+                    tt.consume %12;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void test1(Ptr ptr, int a, @Constant int s) {\n+        var t = arange(0, s);\n+        consume(add(ptr, t));\n+        consume(add(a, t));\n+        consume(add(t, a));\n+        consume(add(broadcast(a, t.type()), t));\n+        consume(add(t, broadcast(a, t.type())));\n+    }\n+\n+    @Test\n+    public void test1(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(JavaType.INT),\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"test2_int_64_32_void\" (%1 : int)void -> {\n+                    %2 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %3 : tensor<x1, x64, int> = tt.expand_dims %2 @\"0\";\n+                    %4 : tensor<x32, int> = tt.make_range @start=\"0\" @end=\"32\";\n+                    %5 : tensor<x32, x1, int> = tt.expand_dims %4 @\"1\";\n+                    %6 : tensor<x1, x64, int> = tt.splat %1;\n+                    %7 : tensor<x1, x64, int> = arith.addi %3 %6;\n+                    tt.consume %7;\n+                    %8 : tensor<x32, x64, int> = tt.broadcast %3;\n+                    %9 : tensor<x32, x64, int> = tt.broadcast %5;\n+                    %10 : tensor<x32, x64, int> = arith.addi %8 %9;\n+                    tt.consume %10;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void test2(int a, @Constant int M, @Constant int N) {\n+        var m = arange(0, M);\n+        var me = expand(m, 0);\n+\n+        var n = arange(0, N);\n+        var ne = expand(n, 1);\n+\n+        var t4 = add(me, a);\n+        consume(t4);\n+\n+        var t3 = add(me, ne);\n+        consume(t3);\n+    }\n+\n+    @Test\n+    public void test2(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 64),\n+                new ConstantType(JavaType.INT, 32)\n+        );\n+\n+        t.test(argTypes);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestBroadcast.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import oracle.code.triton.TritonTestExtension.TritonTestData;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+import static oracle.code.triton.Triton.*;\n+import static oracle.code.triton.TritonTest.consume;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestCdiv {\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"cdiv_int_int_int\" (%0 : int, %1 : int)int -> {\n+                    %2 : int = arith.addi %0 %1;\n+                    %3 : int = arith.constant @\"1\";\n+                    %4 : int = arith.subi %2 %3;\n+                    %5 : int = arith.divsi %4 %1;\n+                    tt.return %5;\n+                };\n+                tt.func @\"testScalar_int_int_void\" (%6 : int, %7 : int)void -> {\n+                    %8 : int = tt.call %6 %7 @\"cdiv_int_int_int\";\n+                    tt.consume %8;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void testScalar(int a, int b) {\n+        var r1 = cdiv(a, b);\n+        consume(r1);\n+    }\n+\n+    @Test\n+    public void testScalar(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                JavaType.INT,\n+                JavaType.INT);\n+\n+        t.test(argTypes);\n+    }\n+\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"cdiv_int_10_int\" (%0 : int)int -> {\n+                    %1 : int = arith.constant @\"10\";\n+                    %2 : int = arith.addi %0 %1;\n+                    %3 : int = arith.constant @\"1\";\n+                    %4 : int = arith.subi %2 %3;\n+                    %5 : int = arith.divsi %4 %1;\n+                    tt.return %5;\n+                };\n+                tt.func @\"testConstant_int_10_void\" (%6 : int)void -> {\n+                    %7 : int = tt.call %6 @\"cdiv_int_10_int\";\n+                    tt.consume %7;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void testConstant(int a, int b) {\n+        var r1 = cdiv(a, b);\n+        consume(r1);\n+    }\n+\n+    @Test\n+    public void testConstant(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 10));\n+\n+        t.test(argTypes);\n+    }\n+\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"cdiv_int_int_int\" (%0 : int, %1 : int)int -> {\n+                    %2 : int = arith.addi %0 %1;\n+                    %3 : int = arith.constant @\"1\";\n+                    %4 : int = arith.subi %2 %3;\n+                    %5 : int = arith.divsi %4 %1;\n+                    tt.return %5;\n+                };\n+                tt.func @\"cdiv_int_10_int\" (%6 : int)int -> {\n+                    %7 : int = arith.constant @\"10\";\n+                    %8 : int = arith.addi %6 %7;\n+                    %9 : int = arith.constant @\"1\";\n+                    %10 : int = arith.subi %8 %9;\n+                    %11 : int = arith.divsi %10 %7;\n+                    tt.return %11;\n+                };\n+                tt.func @\"cdiv_10_int_int\" (%12 : int)int -> {\n+                    %13 : int = arith.constant @\"10\";\n+                    %14 : int = arith.addi %13 %12;\n+                    %15 : int = arith.constant @\"1\";\n+                    %16 : int = arith.subi %14 %15;\n+                    %17 : int = arith.divsi %16 %12;\n+                    tt.return %17;\n+                };\n+                tt.func @\"testCalls_int_int_10_void\" (%18 : int, %19 : int)void -> {\n+                    %20 : int = tt.call %18 %19 @\"cdiv_int_int_int\";\n+                    tt.consume %20;\n+                    %21 : int = tt.call %19 %18 @\"cdiv_int_int_int\";\n+                    tt.consume %21;\n+                    %22 : int = tt.call %18 @\"cdiv_int_10_int\";\n+                    tt.consume %22;\n+                    %23 : int = tt.call %18 @\"cdiv_10_int_int\";\n+                    tt.consume %23;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void testCalls(int a, int b, int c) {\n+        consume(cdiv(a, b));\n+        consume(cdiv(b, a));\n+        consume(cdiv(a, c));\n+        consume(cdiv(c, a));\n+    }\n+\n+    @Test\n+    public void testCalls(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                JavaType.INT,\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 10));\n+\n+        t.test(argTypes);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCdiv.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import oracle.code.triton.TritonTestExtension.TritonTestData;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+import static oracle.code.triton.Triton.*;\n+import static oracle.code.triton.TritonTest.consume;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestCountedLoop {\n+\n+    @TritonCodeModel(value = \"\"\"\n+            module ()void -> {\n+                tt.func @\"test1_int_64_void\" (%0 : int)void -> {\n+                    %1 : int = arith.constant @\"64\";\n+                    %2 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %3 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %4 : int = arith.constant @\"0\";\n+                    %5 : int = arith.constant @\"1\";\n+                    %6 : Tuple<tensor<x64, int>, tensor<x64,int>> = scf.for %4 %0 %5 %2 %3 (%7 : int, %8 : tensor<x64, int>, %9 : tensor<x64, int>)Tuple<tensor<x64, int>, tensor<x64, int>> -> {\n+                        %10 : tensor<x64, int> = tt.splat %7;\n+                        %11 : tensor<x64, int> = arith.addi %8 %10;\n+                        %12 : tensor<x64, int> = tt.splat %1;\n+                        %13 : tensor<x64, int> = arith.addi %9 %12;\n+                        scf.yield %11 %13;\n+                    };\n+                    %14 : tensor<x64, int> = tuple.load %6 @\"0\";\n+                    %15 : tensor<x64, int> = tuple.load %6 @\"1\";\n+                    tt.consume %14;\n+                    tt.consume %15;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void test1(int n, @Constant int s) {\n+        var a = arange(0, s);\n+        var b = arange(0, s);\n+        for (int i = 0; i < n; i++) {\n+            a = Triton.add(a, i);\n+            b = Triton.add(b, s);\n+        }\n+        consume(a);\n+        consume(b);\n+    }\n+\n+    @Test\n+    public void test1(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                JavaType.INT,\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+}\n\\ No newline at end of file\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestCountedLoop.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,832 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+import static oracle.code.triton.Triton.*;\n+import static oracle.code.triton.Triton.CompareKind.*;\n+import static oracle.code.triton.Triton.compare;\n+import static oracle.code.triton.Triton.load;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestMatrix {\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"cdiv_int_32_int\" (%0 : int)int -> {\n+                    %1 : int = arith.constant @\"32\";\n+                    %2 : int = arith.addi %0 %1;\n+                    %3 : int = arith.constant @\"1\";\n+                    %4 : int = arith.subi %2 %3;\n+                    %5 : int = arith.divsi %4 %1;\n+                    tt.return %5;\n+                };\n+                tt.func @\"cdiv_int_64_int\" (%6 : int)int -> {\n+                    %7 : int = arith.constant @\"64\";\n+                    %8 : int = arith.addi %6 %7;\n+                    %9 : int = arith.constant @\"1\";\n+                    %10 : int = arith.subi %8 %9;\n+                    %11 : int = arith.divsi %10 %7;\n+                    tt.return %11;\n+                };\n+                tt.func @\"matmul_kernel_broadcast_ptr<float>_ptr<float>_ptr<float>_int_int_int_int_int_int_int_int_int_32_64_32_8_false_void\" (%12 : ptr<float>, %13 : ptr<float>, %14 : ptr<float>, %15 : int, %16 : int, %17 : int, %18 : int, %19 : int, %20 : int, %21 : int, %22 : int, %23 : int)void -> {\n+                    %24 : int = arith.constant @\"32\";\n+                    %25 : int = arith.constant @\"64\";\n+                    %26 : int = arith.constant @\"32\";\n+                    %27 : int = arith.constant @\"8\";\n+                    %28 : int = tt.get_program_id @\"0\";\n+                    %29 : int = tt.call %15 @\"cdiv_int_32_int\";\n+                    %30 : int = tt.call %16 @\"cdiv_int_64_int\";\n+                    %31 : int = arith.muli %27 %30;\n+                    %32 : int = arith.divsi %28 %31;\n+                    %33 : int = arith.muli %32 %27;\n+                    %34 : int = arith.subi %29 %33;\n+                    %35 : int = arith.minsi %34 %27;\n+                    %36 : int = arith.remsi %28 %35;\n+                    %37 : int = arith.addi %33 %36;\n+                    %38 : int = arith.remsi %28 %31;\n+                    %39 : int = arith.divsi %38 %35;\n+                    %40 : tensor<x32, int> = tt.make_range @start=\"0\" @end=\"32\";\n+                    %41 : int = arith.muli %37 %24;\n+                    %42 : tensor<x32, int> = tt.splat %41;\n+                    %43 : tensor<x32, int> = arith.addi %42 %40;\n+                    %44 : tensor<x32, int> = tt.splat %15;\n+                    %45 : tensor<x32, int> = arith.remsi %43 %44;\n+                    %46 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %47 : int = arith.muli %39 %25;\n+                    %48 : tensor<x64, int> = tt.splat %47;\n+                    %49 : tensor<x64, int> = arith.addi %48 %46;\n+                    %50 : tensor<x64, int> = tt.splat %16;\n+                    %51 : tensor<x64, int> = arith.remsi %49 %50;\n+                    %52 : tensor<x32, int> = tt.make_range @start=\"0\" @end=\"32\";\n+                    %53 : tensor<x32, x1, int> = tt.expand_dims %45 @\"1\";\n+                    %54 : tensor<x32, x1, int> = tt.splat %18;\n+                    %55 : tensor<x32, x1, int> = arith.muli %53 %54;\n+                    %56 : tensor<x1, x32, int> = tt.expand_dims %52 @\"0\";\n+                    %57 : tensor<x1, x32, int> = tt.splat %19;\n+                    %58 : tensor<x1, x32, int> = arith.muli %56 %57;\n+                    %59 : tensor<x32, x32, ptr<float>> = tt.splat %12;\n+                    %60 : tensor<x32, x32, int> = tt.broadcast %55;\n+                    %61 : tensor<x32, x32, int> = tt.broadcast %58;\n+                    %62 : tensor<x32, x32, int> = arith.addi %60 %61;\n+                    %63 : tensor<x32, x32, ptr<float>> = tt.addptr %59 %62;\n+                    %64 : tensor<x32, x1, int> = tt.expand_dims %52 @\"1\";\n+                    %65 : tensor<x32, x1, int> = tt.splat %20;\n+                    %66 : tensor<x32, x1, int> = arith.muli %64 %65;\n+                    %67 : tensor<x1, x64, int> = tt.expand_dims %51 @\"0\";\n+                    %68 : tensor<x1, x64, int> = tt.splat %21;\n+                    %69 : tensor<x1, x64, int> = arith.muli %67 %68;\n+                    %70 : tensor<x32, x64, ptr<float>> = tt.splat %13;\n+                    %71 : tensor<x32, x64, int> = tt.broadcast %66;\n+                    %72 : tensor<x32, x64, int> = tt.broadcast %69;\n+                    %73 : tensor<x32, x64, int> = arith.addi %71 %72;\n+                    %74 : tensor<x32, x64, ptr<float>> = tt.addptr %70 %73;\n+                    %75 : tensor<x32, x64, float> = arith.constant @\"0.0\";\n+                    %76 : int = arith.constant @\"0\";\n+                    %77 : int = tt.call %17 @\"cdiv_int_32_int\";\n+                    %78 : int = arith.constant @\"1\";\n+                    %79 : Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<float>>, tensor<x32, x64, ptr<float>>> = scf.for %76 %77 %78 %75 %63 %74 (%80 : int, %81 : tensor<x32, x64, float>, %82 : tensor<x32, x32, ptr<float>>, %83 : tensor<x32, x64, ptr<float>>)Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<float>>, tensor<x32, x64, ptr<float>>> -> {\n+                        %84 : tensor<x1, x32, int> = tt.expand_dims %52 @\"0\";\n+                        %85 : int = arith.muli %80 %26;\n+                        %86 : int = arith.subi %17 %85;\n+                        %87 : tensor<x1, x32, int> = tt.splat %86;\n+                        %88 : tensor<x1, x32, int> = arith.cmpi %84 %87 @\"slt\";\n+                        %89 : tensor<x32, x32, int> = tt.broadcast %88;\n+                        %90 : tensor<x32, x32, float> = tt.load %82 %89;\n+                        %91 : tensor<x32, x1, int> = tt.expand_dims %52 @\"1\";\n+                        %92 : int = arith.muli %80 %26;\n+                        %93 : int = arith.subi %17 %92;\n+                        %94 : tensor<x32, x1, int> = tt.splat %93;\n+                        %95 : tensor<x32, x1, int> = arith.cmpi %91 %94 @\"slt\";\n+                        %96 : tensor<x32, x64, int> = tt.broadcast %95;\n+                        %97 : tensor<x32, x64, float> = tt.load %83 %96;\n+                        %98 : tensor<x32, x64, float> = tt.dot %90 %97;\n+                        %99 : tensor<x32, x64, float> = arith.addf %81 %98;\n+                        %100 : int = arith.muli %26 %19;\n+                        %101 : tensor<x32, x32, int> = tt.splat %100;\n+                        %102 : tensor<x32, x32, ptr<float>> = tt.addptr %82 %101;\n+                        %103 : int = arith.muli %26 %20;\n+                        %104 : tensor<x32, x64, int> = tt.splat %103;\n+                        %105 : tensor<x32, x64, ptr<float>> = tt.addptr %83 %104;\n+                        scf.yield %99 %102 %105;\n+                    };\n+                    %106 : tensor<x32, x64, float> = tuple.load %79 @\"0\";\n+                    %107 : tensor<x32, x32, ptr<float>> = tuple.load %79 @\"1\";\n+                    %108 : tensor<x32, x64, ptr<float>> = tuple.load %79 @\"2\";\n+                    %109 : int = arith.muli %37 %24;\n+                    %110 : tensor<x32, int> = tt.splat %109;\n+                    %111 : tensor<x32, int> = arith.addi %110 %40;\n+                    %112 : int = arith.muli %39 %25;\n+                    %113 : tensor<x64, int> = tt.splat %112;\n+                    %114 : tensor<x64, int> = arith.addi %113 %46;\n+                    %115 : tensor<x32, x1, int> = tt.expand_dims %111 @\"1\";\n+                    %116 : tensor<x32, x1, int> = tt.splat %22;\n+                    %117 : tensor<x32, x1, int> = arith.muli %115 %116;\n+                    %118 : tensor<x1, x64, int> = tt.expand_dims %114 @\"0\";\n+                    %119 : tensor<x1, x64, int> = tt.splat %23;\n+                    %120 : tensor<x1, x64, int> = arith.muli %118 %119;\n+                    %121 : tensor<x32, x64, ptr<float>> = tt.splat %14;\n+                    %122 : tensor<x32, x64, int> = tt.broadcast %117;\n+                    %123 : tensor<x32, x64, int> = tt.broadcast %120;\n+                    %124 : tensor<x32, x64, int> = arith.addi %122 %123;\n+                    %125 : tensor<x32, x64, ptr<float>> = tt.addptr %121 %124;\n+                    %126 : tensor<x32, x1, int> = tt.expand_dims %111 @\"1\";\n+                    %127 : tensor<x32, x1, int> = tt.splat %15;\n+                    %128 : tensor<x32, x1, int> = arith.cmpi %126 %127 @\"slt\";\n+                    %129 : tensor<x1, x64, int> = tt.expand_dims %114 @\"0\";\n+                    %130 : tensor<x1, x64, int> = tt.splat %16;\n+                    %131 : tensor<x1, x64, int> = arith.cmpi %129 %130 @\"slt\";\n+                    %132 : tensor<x32, x64, int> = tt.broadcast %128;\n+                    %133 : tensor<x32, x64, int> = tt.broadcast %131;\n+                    %134 : tensor<x32, x64, int> = arith.andi %132 %133;\n+                    tt.store %125 %106 %134;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void matmul_kernel_broadcast(\n+            \/\/ Pointers to matrices\n+            Ptr a_ptr, Ptr b_ptr, Ptr c_ptr,\n+            \/\/ Matrix dimensions\n+            int M, int N, int K,\n+            \/\/ The stride variables represent how much to increase the ptr by when moving by 1\n+            \/\/ element in a particular dimension. E.g. `stride_am` is how much to increase `a_ptr`\n+            \/\/ by to get the element one row down (A has M rows).\n+            int stride_am, int stride_ak,\n+            int stride_bk, int stride_bn,\n+            int stride_cm, int stride_cn,\n+            \/\/ Meta-parameters\n+            @Constant int BLOCK_SIZE_M, @Constant int BLOCK_SIZE_N, @Constant int BLOCK_SIZE_K,\n+            @Constant int GROUP_SIZE_M,\n+            @Constant boolean ACTIVATION) {\n+\n+        \/\/ \"\"\"Kernel for computing the matmul C = A x B.\n+        \/\/ A has shape (M, K), B has shape (K, N) and C has shape (M, N)\n+        \/\/ \"\"\"\n+        \/\/ -----------------------------------------------------------\n+        \/\/ Map program ids `pid` to the block of C it should compute.\n+        \/\/ This is done in a grouped ordering to promote L2 data reuse.\n+        \/\/ See above `L2 Cache Optimizations` section for details.\n+        var pid = programId(0);\n+\n+        var num_pid_m = cdiv(M, BLOCK_SIZE_M);\n+        var num_pid_n = cdiv(N, BLOCK_SIZE_N);\n+        var num_pid_in_group = GROUP_SIZE_M * num_pid_n;\n+        var group_id = pid \/ num_pid_in_group;\n+        var first_pid_m = group_id * GROUP_SIZE_M;\n+        var group_size_m = Math.min(num_pid_m - first_pid_m, GROUP_SIZE_M);\n+        var pid_m = first_pid_m + (pid % group_size_m);\n+        var pid_n = (pid % num_pid_in_group) \/ group_size_m;\n+\n+        \/\/ ----------------------------------------------------------\n+        \/\/ Create pointers for the first blocks of A and B.\n+        \/\/ We will advance this pointer as we move in the K direction\n+        \/\/ and accumulate\n+        \/\/ `a_ptrs` is a block of [BLOCK_SIZE_M, BLOCK_SIZE_K] pointers\n+        \/\/ `b_ptrs` is a block of [BLOCK_SIZE_K, BLOCK_SIZE_N] pointers\n+        \/\/ See above `Pointer Arithmetics` section for details\n+        var offs_m = arange(0, BLOCK_SIZE_M);\n+        var offs_am = mod(\n+                add(broadcast(pid_m * BLOCK_SIZE_M, offs_m.type()), offs_m),\n+                broadcast(M, offs_m.type()));\n+        var offs_n = arange(0, BLOCK_SIZE_N);\n+        var offs_bn = mod(\n+                add(broadcast(pid_n * BLOCK_SIZE_N, offs_n.type()), offs_n),\n+                broadcast(N, offs_n.type()));\n+        var offs_k = arange(0, BLOCK_SIZE_K);\n+\n+        var offs_am_e = expand(offs_am, 1);\n+        offs_am_e = mul(offs_am_e, broadcast(stride_am, offs_am_e.type()));\n+        var offs_k_e_0 = expand(offs_k, 0);\n+        offs_k_e_0 = mul(offs_k_e_0, broadcast(stride_ak, offs_k_e_0.type()));\n+        TensorType a_ptrs_t = joinShape(offs_am_e.type(), offs_k_e_0.type());\n+        var a_ptrs = add(broadcast(a_ptr, a_ptrs_t),\n+                add(broadcast(offs_am_e, a_ptrs_t), broadcast(offs_k_e_0, a_ptrs_t)));\n+\n+        var offs_k_e_1 = expand(offs_k, 1);\n+        offs_k_e_1 = mul(offs_k_e_1, broadcast(stride_bk, offs_k_e_1.type()));\n+        var offs_bn_e = expand(offs_bn, 0);\n+        offs_bn_e = mul(offs_bn_e, broadcast(stride_bn, offs_bn_e.type()));\n+        TensorType b_ptrs_t = joinShape(offs_k_e_1.type(), offs_bn_e.type());\n+        var b_ptrs = add(broadcast(b_ptr, b_ptrs_t),\n+                add(broadcast(offs_k_e_1, b_ptrs_t), broadcast(offs_bn_e, b_ptrs_t)));\n+\n+        \/\/ -----------------------------------------------------------\n+        \/\/ Iterate to compute a block of the C matrix.\n+        \/\/ We accumulate into a `[BLOCK_SIZE_M, BLOCK_SIZE_N]` block\n+        \/\/ of fp32 values for higher accuracy.\n+        \/\/ `accumulator` will be converted back to fp16 after the loop.\n+        var accumulator = zeros(float.class, BLOCK_SIZE_M, BLOCK_SIZE_N);\n+        for (int k = 0; k < cdiv(K, BLOCK_SIZE_K); k++) {\n+            \/\/ Load the next block of A and B, generate a mask by checking the K dimension.\n+            \/\/ If it is out of bounds, set it to 0.\n+            var offs_k_m_0 = expand(offs_k, 0);\n+            offs_k_m_0 = compare(offs_k_m_0,\n+                    broadcast(K - k * BLOCK_SIZE_K, offs_k_m_0.type()),\n+                    LessThan);\n+            var a = load(a_ptrs, broadcast(offs_k_m_0, a_ptrs.type()));\n+            var offs_k_m_1 = expand(offs_k, 1);\n+            offs_k_m_1 = compare(offs_k_m_1,\n+                    broadcast(K - k * BLOCK_SIZE_K, offs_k_m_1.type()),\n+                    LessThan);\n+            var b = load(b_ptrs, broadcast(offs_k_m_1, b_ptrs.type()));\n+            \/\/ We accumulate along the K dimension.\n+            accumulator = add(accumulator, dot(a, b));\n+            \/\/ Advance the ptrs to the next K block.\n+            a_ptrs = add(a_ptrs, broadcast(BLOCK_SIZE_K * stride_ak, a_ptrs.type()));\n+            b_ptrs = add(b_ptrs, broadcast(BLOCK_SIZE_K * stride_bk, b_ptrs.type()));\n+        }\n+\n+        \/\/ You can fuse arbitrary activation functions here\n+        \/\/ while the accumulator is still in FP32!\n+\/\/        if (ACTIVATION) {\n+\/\/            \/\/ ...\n+\/\/        }\n+        \/\/ c = Triton.to(activation, tl.float16)\n+        var c = accumulator;\n+\n+        \/\/ -----------------------------------------------------------\n+        \/\/ Write back the block of the output matrix C with masks.\n+        var offs_cm = add(broadcast(pid_m * BLOCK_SIZE_M, offs_m.type()), offs_m);\n+        var offs_cn = add(broadcast(pid_n * BLOCK_SIZE_N, offs_n.type()), offs_n);\n+\n+        var offs_cm_e = expand(offs_cm, 1);\n+        offs_cm_e = mul(offs_cm_e, broadcast(stride_cm, offs_cm_e.type()));\n+        var offs_cn_e = expand(offs_cn, 0);\n+        offs_cn_e = mul(offs_cn_e, broadcast(stride_cn, offs_cn_e.type()));\n+        TensorType c_ptrs_t = joinShape(offs_cm_e.type(), offs_cn_e.type());\n+        var c_ptrs = add(broadcast(c_ptr, c_ptrs_t),\n+                add(broadcast(offs_cm_e, c_ptrs_t), broadcast(offs_cn_e, c_ptrs_t)));\n+\n+        offs_cm_e = expand(offs_cm, 1);\n+        var c_mask_l = compare(offs_cm_e, broadcast(M, offs_cm_e.type()), LessThan);\n+        offs_cn_e = expand(offs_cn, 0);\n+        var c_mask_r = compare(offs_cn_e, broadcast(N, offs_cn_e.type()), LessThan);\n+        var c_mask = and(broadcast(c_mask_l, c_ptrs_t), broadcast(c_mask_r, c_ptrs_t));\n+\n+        store(c_ptrs, c, c_mask);\n+    }\n+\n+    @TritonTestExtension.Kernel(\"matmul_kernel_broadcast\")\n+    @Test\n+    public void testWithBroadcast(TritonTestExtension.TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                JavaType.INT, JavaType.INT, JavaType.INT,\n+                JavaType.INT, JavaType.INT,\n+                JavaType.INT, JavaType.INT,\n+                JavaType.INT, JavaType.INT,\n+                new ConstantType(JavaType.INT, 32), new ConstantType(JavaType.INT, 64), new ConstantType(JavaType.INT, 32),\n+                new ConstantType(JavaType.INT, 8),\n+                new ConstantType(JavaType.INT, false));\n+\n+        t.test(argTypes);\n+    }\n+\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"cdiv_int_32_int\" (%0 : int)int -> {\n+                    %1 : int = arith.constant @\"32\";\n+                    %2 : int = arith.addi %0 %1;\n+                    %3 : int = arith.constant @\"1\";\n+                    %4 : int = arith.subi %2 %3;\n+                    %5 : int = arith.divsi %4 %1;\n+                    tt.return %5;\n+                };\n+                tt.func @\"cdiv_int_64_int\" (%6 : int)int -> {\n+                    %7 : int = arith.constant @\"64\";\n+                    %8 : int = arith.addi %6 %7;\n+                    %9 : int = arith.constant @\"1\";\n+                    %10 : int = arith.subi %8 %9;\n+                    %11 : int = arith.divsi %10 %7;\n+                    tt.return %11;\n+                };\n+                tt.func @\"matmul_kernel_ptr<oracle.code.triton.Float16>_ptr<oracle.code.triton.Float16>_ptr<oracle.code.triton.Float16>_int_int_int_int_int_int_int_int_int_32_64_32_8_false_void\" (%12 : ptr<oracle.code.triton.Float16>, %13 : ptr<oracle.code.triton.Float16>, %14 : ptr<oracle.code.triton.Float16>, %15 : int, %16 : int, %17 : int, %18 : int, %19 : int, %20 : int, %21 : int, %22 : int, %23 : int)void -> {\n+                    %24 : int = arith.constant @\"32\";\n+                    %25 : int = arith.constant @\"64\";\n+                    %26 : int = arith.constant @\"32\";\n+                    %27 : int = arith.constant @\"8\";\n+                    %28 : int = tt.get_program_id @\"0\";\n+                    %29 : int = tt.call %15 @\"cdiv_int_32_int\";\n+                    %30 : int = tt.call %16 @\"cdiv_int_64_int\";\n+                    %31 : int = arith.muli %27 %30;\n+                    %32 : int = arith.divsi %28 %31;\n+                    %33 : int = arith.muli %32 %27;\n+                    %34 : int = arith.subi %29 %33;\n+                    %35 : int = arith.minsi %34 %27;\n+                    %36 : int = arith.remsi %28 %35;\n+                    %37 : int = arith.addi %33 %36;\n+                    %38 : int = arith.remsi %28 %31;\n+                    %39 : int = arith.divsi %38 %35;\n+                    %40 : tensor<x32, int> = tt.make_range @start=\"0\" @end=\"32\";\n+                    %41 : int = arith.muli %37 %24;\n+                    %42 : tensor<x32, int> = tt.splat %41;\n+                    %43 : tensor<x32, int> = arith.addi %42 %40;\n+                    %44 : tensor<x32, int> = tt.splat %15;\n+                    %45 : tensor<x32, int> = arith.remsi %43 %44;\n+                    %46 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %47 : int = arith.muli %39 %25;\n+                    %48 : tensor<x64, int> = tt.splat %47;\n+                    %49 : tensor<x64, int> = arith.addi %48 %46;\n+                    %50 : tensor<x64, int> = tt.splat %16;\n+                    %51 : tensor<x64, int> = arith.remsi %49 %50;\n+                    %52 : tensor<x32, int> = tt.make_range @start=\"0\" @end=\"32\";\n+                    %53 : tensor<x32, x1, int> = tt.expand_dims %45 @\"1\";\n+                    %54 : tensor<x32, x1, int> = tt.splat %18;\n+                    %55 : tensor<x32, x1, int> = arith.muli %53 %54;\n+                    %56 : tensor<x1, x32, int> = tt.expand_dims %52 @\"0\";\n+                    %57 : tensor<x1, x32, int> = tt.splat %19;\n+                    %58 : tensor<x1, x32, int> = arith.muli %56 %57;\n+                    %59 : tensor<x32, x32, int> = tt.broadcast %55;\n+                    %60 : tensor<x32, x32, int> = tt.broadcast %58;\n+                    %61 : tensor<x32, x32, int> = arith.addi %59 %60;\n+                    %62 : tensor<x32, x32, ptr<oracle.code.triton.Float16>> = tt.splat %12;\n+                    %63 : tensor<x32, x32, ptr<oracle.code.triton.Float16>> = tt.addptr %62 %61;\n+                    %64 : tensor<x32, x1, int> = tt.expand_dims %52 @\"1\";\n+                    %65 : tensor<x32, x1, int> = tt.splat %20;\n+                    %66 : tensor<x32, x1, int> = arith.muli %64 %65;\n+                    %67 : tensor<x1, x64, int> = tt.expand_dims %51 @\"0\";\n+                    %68 : tensor<x1, x64, int> = tt.splat %21;\n+                    %69 : tensor<x1, x64, int> = arith.muli %67 %68;\n+                    %70 : tensor<x32, x64, int> = tt.broadcast %66;\n+                    %71 : tensor<x32, x64, int> = tt.broadcast %69;\n+                    %72 : tensor<x32, x64, int> = arith.addi %70 %71;\n+                    %73 : tensor<x32, x64, ptr<oracle.code.triton.Float16>> = tt.splat %13;\n+                    %74 : tensor<x32, x64, ptr<oracle.code.triton.Float16>> = tt.addptr %73 %72;\n+                    %75 : tensor<x32, x64, float> = arith.constant @\"0.0\";\n+                    %76 : int = arith.constant @\"0\";\n+                    %77 : int = tt.call %17 @\"cdiv_int_32_int\";\n+                    %78 : int = arith.constant @\"1\";\n+                    %79 : Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<oracle.code.triton.Float16>>, tensor<x32, x64, ptr<oracle.code.triton.Float16>>> = scf.for %76 %77 %78 %75 %63 %74 (%80 : int, %81 : tensor<x32, x64, float>, %82 : tensor<x32, x32, ptr<oracle.code.triton.Float16>>, %83 : tensor<x32, x64, ptr<oracle.code.triton.Float16>>)Tuple<tensor<x32, x64, float>, tensor<x32, x32, ptr<oracle.code.triton.Float16>>, tensor<x32, x64, ptr<oracle.code.triton.Float16>>> -> {\n+                        %84 : tensor<x1, x32, int> = tt.expand_dims %52 @\"0\";\n+                        %85 : int = arith.muli %80 %26;\n+                        %86 : int = arith.subi %17 %85;\n+                        %87 : tensor<x1, x32, int> = tt.splat %86;\n+                        %88 : tensor<x1, x32, int> = arith.cmpi %84 %87 @\"slt\";\n+                        %89 : tensor<x32, x32, int> = tt.broadcast %88;\n+                        %90 : tensor<x32, x32, oracle.code.triton.Float16> = tt.load %82 %89;\n+                        %91 : tensor<x32, x1, int> = tt.expand_dims %52 @\"1\";\n+                        %92 : int = arith.muli %80 %26;\n+                        %93 : int = arith.subi %17 %92;\n+                        %94 : tensor<x32, x1, int> = tt.splat %93;\n+                        %95 : tensor<x32, x1, int> = arith.cmpi %91 %94 @\"slt\";\n+                        %96 : tensor<x32, x64, int> = tt.broadcast %95;\n+                        %97 : tensor<x32, x64, oracle.code.triton.Float16> = tt.load %83 %96;\n+                        %98 : tensor<x32, x64, float> = tt.dot %90 %97;\n+                        %99 : tensor<x32, x64, float> = arith.addf %81 %98;\n+                        %100 : int = arith.muli %26 %19;\n+                        %101 : tensor<x32, x32, int> = tt.splat %100;\n+                        %102 : tensor<x32, x32, ptr<oracle.code.triton.Float16>> = tt.addptr %82 %101;\n+                        %103 : int = arith.muli %26 %20;\n+                        %104 : tensor<x32, x64, int> = tt.splat %103;\n+                        %105 : tensor<x32, x64, ptr<oracle.code.triton.Float16>> = tt.addptr %83 %104;\n+                        scf.yield %99 %102 %105;\n+                    };\n+                    %106 : tensor<x32, x64, float> = tuple.load %79 @\"0\";\n+                    %107 : tensor<x32, x32, ptr<oracle.code.triton.Float16>> = tuple.load %79 @\"1\";\n+                    %108 : tensor<x32, x64, ptr<oracle.code.triton.Float16>> = tuple.load %79 @\"2\";\n+                    %109 : tensor<x32, x64, oracle.code.triton.Float16> = arith.truncf %106;\n+                    %110 : int = arith.muli %37 %24;\n+                    %111 : tensor<x32, int> = tt.splat %110;\n+                    %112 : tensor<x32, int> = arith.addi %111 %40;\n+                    %113 : int = arith.muli %39 %25;\n+                    %114 : tensor<x64, int> = tt.splat %113;\n+                    %115 : tensor<x64, int> = arith.addi %114 %46;\n+                    %116 : tensor<x32, x1, int> = tt.expand_dims %112 @\"1\";\n+                    %117 : tensor<x32, x1, int> = tt.splat %22;\n+                    %118 : tensor<x32, x1, int> = arith.muli %117 %116;\n+                    %119 : tensor<x1, x64, int> = tt.expand_dims %115 @\"0\";\n+                    %120 : tensor<x1, x64, int> = tt.splat %23;\n+                    %121 : tensor<x1, x64, int> = arith.muli %120 %119;\n+                    %122 : tensor<x32, x64, int> = tt.broadcast %118;\n+                    %123 : tensor<x32, x64, int> = tt.broadcast %121;\n+                    %124 : tensor<x32, x64, int> = arith.addi %122 %123;\n+                    %125 : tensor<x32, x64, ptr<oracle.code.triton.Float16>> = tt.splat %14;\n+                    %126 : tensor<x32, x64, ptr<oracle.code.triton.Float16>> = tt.addptr %125 %124;\n+                    %127 : tensor<x32, x1, int> = tt.expand_dims %112 @\"1\";\n+                    %128 : tensor<x32, x1, int> = tt.splat %15;\n+                    %129 : tensor<x32, x1, int> = arith.cmpi %127 %128 @\"slt\";\n+                    %130 : tensor<x1, x64, int> = tt.expand_dims %115 @\"0\";\n+                    %131 : tensor<x1, x64, int> = tt.splat %16;\n+                    %132 : tensor<x1, x64, int> = arith.cmpi %130 %131 @\"slt\";\n+                    %133 : tensor<x32, x64, int> = tt.broadcast %129;\n+                    %134 : tensor<x32, x64, int> = tt.broadcast %132;\n+                    %135 : tensor<x32, x64, int> = arith.andi %133 %134;\n+                    tt.store %126 %109 %135;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void matmul_kernel(\n+            \/\/ Pointers to matrices\n+            Ptr a_ptr, Ptr b_ptr, Ptr c_ptr,\n+            \/\/ Matrix dimensions\n+            int M, int N, int K,\n+            \/\/ The stride variables represent how much to increase the ptr by when moving by 1\n+            \/\/ element in a particular dimension. E.g. `stride_am` is how much to increase `a_ptr`\n+            \/\/ by to get the element one row down (A has M rows).\n+            int stride_am, int stride_ak,\n+            int stride_bk, int stride_bn,\n+            int stride_cm, int stride_cn,\n+            \/\/ Meta-parameters\n+            @Constant int BLOCK_SIZE_M, @Constant int BLOCK_SIZE_N, @Constant int BLOCK_SIZE_K,\n+            @Constant int GROUP_SIZE_M,\n+            @Constant boolean ACTIVATION) {\n+\n+        \/\/ \"\"\"Kernel for computing the matmul C = A x B.\n+        \/\/ A has shape (M, K), B has shape (K, N) and C has shape (M, N)\n+        \/\/ \"\"\"\n+        \/\/ -----------------------------------------------------------\n+        \/\/ Map program ids `pid` to the block of C it should compute.\n+        \/\/ This is done in a grouped ordering to promote L2 data reuse.\n+        \/\/ See above `L2 Cache Optimizations` section for details.\n+        var pid = programId(0);\n+        var num_pid_m = cdiv(M, BLOCK_SIZE_M);\n+        var num_pid_n = cdiv(N, BLOCK_SIZE_N);\n+        var num_pid_in_group = GROUP_SIZE_M * num_pid_n;\n+        var group_id = pid \/ num_pid_in_group;\n+        var first_pid_m = group_id * GROUP_SIZE_M;\n+        var group_size_m = Math.min(num_pid_m - first_pid_m, GROUP_SIZE_M);\n+        var pid_m = first_pid_m + (pid % group_size_m);\n+        var pid_n = (pid % num_pid_in_group) \/ group_size_m;\n+\n+        \/\/ ----------------------------------------------------------\n+        \/\/ Create pointers for the first blocks of A and B.\n+        \/\/ We will advance this pointer as we move in the K direction\n+        \/\/ and accumulate\n+        \/\/ `a_ptrs` is a block of [BLOCK_SIZE_M, BLOCK_SIZE_K] pointers\n+        \/\/ `b_ptrs` is a block of [BLOCK_SIZE_K, BLOCK_SIZE_N] pointers\n+        \/\/ See above `Pointer Arithmetics` section for details\n+        var offs_m = arange(0, BLOCK_SIZE_M);\n+        var offs_am = mod(add(pid_m * BLOCK_SIZE_M, offs_m), M);\n+        var offs_n = arange(0, BLOCK_SIZE_N);\n+        var offs_bn = mod(add(pid_n * BLOCK_SIZE_N, offs_n), N);\n+        var offs_k = arange(0, BLOCK_SIZE_K);\n+        var a_ptrs = add(a_ptr, add(\n+                mul(expand(offs_am, 1), stride_am),\n+                mul(expand(offs_k, 0), stride_ak)));\n+        var b_ptrs = add(b_ptr, add(\n+                        mul(expand(offs_k, 1), stride_bk),\n+                        mul(expand(offs_bn, 0), stride_bn)));\n+\n+        \/\/ -----------------------------------------------------------\n+        \/\/ Iterate to compute a block of the C matrix.\n+        \/\/ We accumulate into a `[BLOCK_SIZE_M, BLOCK_SIZE_N]` block\n+        \/\/ of fp32 values for higher accuracy.\n+        \/\/ `accumulator` will be converted back to fp16 after the loop.\n+        var accumulator = zeros(float.class, BLOCK_SIZE_M, BLOCK_SIZE_N);\n+        for (int k = 0; k < cdiv(K, BLOCK_SIZE_K); k++) {\n+            \/\/ Load the next block of A and B, generate a mask by checking the K dimension.\n+            \/\/ If it is out of bounds, set it to 0.\n+            var a = load(a_ptrs,\n+                    compare(expand(offs_k, 0), K - k * BLOCK_SIZE_K, LessThan));\n+            var b = load(b_ptrs,\n+                    compare(expand(offs_k, 1), K - k * BLOCK_SIZE_K, LessThan));\n+            \/\/ We accumulate along the K dimension.\n+            accumulator = add(accumulator, dot(a, b));\n+            \/\/ Advance the ptrs to the next K block.\n+            a_ptrs = add(a_ptrs, BLOCK_SIZE_K * stride_ak);\n+            b_ptrs = add(b_ptrs, BLOCK_SIZE_K * stride_bk);\n+        }\n+\n+        \/\/ You can fuse arbitrary activation functions here\n+        \/\/ while the accumulator is still in FP32!\n+\/\/        if (ACTIVATION) {\n+\/\/            \/\/ ...\n+\/\/        }\n+        var c = Triton.conv(Float16.class, accumulator);\n+\n+        \/\/ -----------------------------------------------------------\n+        \/\/ Write back the block of the output matrix C with masks.\n+        var offs_cm = add(pid_m * BLOCK_SIZE_M, offs_m);\n+        var offs_cn = add(pid_n * BLOCK_SIZE_N, offs_n);\n+        var c_ptrs = add(c_ptr, add(\n+                        mul(stride_cm, expand(offs_cm, 1)),\n+                        mul(stride_cn, expand(offs_cn, 0))));\n+        var c_mask = and(\n+                compare(expand(offs_cm, 1), M, LessThan),\n+                compare(expand(offs_cn, 0), N, LessThan));\n+        store(c_ptrs, c, c_mask);\n+    }\n+\n+    @TritonTestExtension.Kernel(\"matmul_kernel\")\n+    @Test\n+    public void test(TritonTestExtension.TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(Float16.FLOAT_16_TYPE),\n+                new PtrType(Float16.FLOAT_16_TYPE),\n+                new PtrType(Float16.FLOAT_16_TYPE),\n+                JavaType.INT, JavaType.INT, JavaType.INT,\n+                JavaType.INT, JavaType.INT,\n+                JavaType.INT, JavaType.INT,\n+                JavaType.INT, JavaType.INT,\n+                new ConstantType(JavaType.INT, 32), new ConstantType(JavaType.INT, 64), new ConstantType(JavaType.INT, 32),\n+                new ConstantType(JavaType.INT, 8),\n+                new ConstantType(JavaType.INT, false));\n+\n+        t.test(argTypes);\n+    }\n+\n+}\n+\n+\/*\n+@triton.jit\n+def matmul_kernel(\n+        # Pointers to matrices\n+        a_ptr, b_ptr, c_ptr,\n+        # Matrix dimensions\n+        M, N, K,\n+        # The stride variables represent how much to increase the ptr by when moving by 1\n+        # element in a particular dimension. E.g. `stride_am` is how much to increase `a_ptr`\n+        # by to get the element one row down (A has M rows).\n+        stride_am, stride_ak,  #\n+        stride_bk, stride_bn,  #\n+        stride_cm, stride_cn,\n+        # Meta-parameters\n+        BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr, BLOCK_SIZE_K: tl.constexpr,  #\n+        GROUP_SIZE_M: tl.constexpr,  #\n+        ACTIVATION: tl.constexpr  #\n+):\n+    \"\"\"Kernel for computing the matmul C = A x B.\n+    A has shape (M, K), B has shape (K, N) and C has shape (M, N)\n+    \"\"\"\n+    # -----------------------------------------------------------\n+    # Map program ids `pid` to the block of C it should compute.\n+    # This is done in a grouped ordering to promote L2 data reuse.\n+    # See above `L2 Cache Optimizations` section for details.\n+    pid = tl.program_id(axis=0)\n+    num_pid_m = tl.cdiv(M, BLOCK_SIZE_M)\n+    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n+    num_pid_in_group = GROUP_SIZE_M * num_pid_n\n+    group_id = pid \/\/ num_pid_in_group\n+    first_pid_m = group_id * GROUP_SIZE_M\n+    group_size_m = min(num_pid_m - first_pid_m, GROUP_SIZE_M)\n+    pid_m = first_pid_m + (pid % group_size_m)\n+    pid_n = (pid % num_pid_in_group) \/\/ group_size_m\n+\n+    # ----------------------------------------------------------\n+    # Create pointers for the first blocks of A and B.\n+    # We will advance this pointer as we move in the K direction\n+    # and accumulate\n+    # `a_ptrs` is a block of [BLOCK_SIZE_M, BLOCK_SIZE_K] pointers\n+    # `b_ptrs` is a block of [BLOCK_SIZE_K, BLOCK_SIZE_N] pointers\n+    # See above `Pointer Arithmetics` section for details\n+    offs_am = (pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)) % M\n+    offs_bn = (pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)) % N\n+    offs_k = tl.arange(0, BLOCK_SIZE_K)\n+    a_ptrs = a_ptr + (offs_am[:, None] * stride_am + offs_k[None, :] * stride_ak)\n+    b_ptrs = b_ptr + (offs_k[:, None] * stride_bk + offs_bn[None, :] * stride_bn)\n+\n+    # -----------------------------------------------------------\n+    # Iterate to compute a block of the C matrix.\n+    # We accumulate into a `[BLOCK_SIZE_M, BLOCK_SIZE_N]` block\n+    # of fp32 values for higher accuracy.\n+    # `accumulator` will be converted back to fp16 after the loop.\n+    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N), dtype=tl.float32)\n+    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n+        # Load the next block of A and B, generate a mask by checking the K dimension.\n+        # If it is out of bounds, set it to 0.\n+        a = tl.load(a_ptrs, mask=offs_k[None, :] < K - k * BLOCK_SIZE_K, other=0.0)\n+        b = tl.load(b_ptrs, mask=offs_k[:, None] < K - k * BLOCK_SIZE_K, other=0.0)\n+        # We accumulate along the K dimension.\n+        accumulator += tl.dot(a, b)\n+        # Advance the ptrs to the next K block.\n+        a_ptrs += BLOCK_SIZE_K * stride_ak\n+        b_ptrs += BLOCK_SIZE_K * stride_bk\n+    # You can fuse arbitrary activation functions here\n+    # while the accumulator is still in FP32!\n+    if ACTIVATION == \"leaky_relu\":\n+        accumulator = leaky_relu(accumulator)\n+    c = accumulator.to(tl.float16)\n+\n+    # -----------------------------------------------------------\n+    # Write back the block of the output matrix C with masks.\n+    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M)\n+    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N)\n+    c_ptrs = c_ptr + stride_cm * offs_cm[:, None] + stride_cn * offs_cn[None, :]\n+    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n+    tl.store(c_ptrs, c, mask=c_mask)\n+\n+\n+# We can fuse `leaky_relu` by providing it as an `ACTIVATION` meta-parameter in `_matmul`.\n+@triton.jit\n+def leaky_relu(x):\n+    x = x + 1\n+    return tl.where(x >= 0, x, 0.01 * x)\n+*\/\n+\n+\/*\n+\n+ triton\/python\/triton\/tools\/compile.py \\\n+    --kernel-name matmul_kernel \\\n+    --signature \"*fp16,*fp16,*fp16,i32,i32,i32,i32,i32,i32,i32,i32,i32,32,64,32,8,0\" \\\n+    --grid=1024,1024,1024 \\\n+    03-matrix-multiplication.py\n+\n+BLOCK_SIZE_M = 32\n+BLOCK_SIZE_N = 64\n+BLOCK_SIZE_K = 32\n+GROUP_SIZE_M = 8\n+ACTIVATION = 0\n+\n+module {\n+  tt.func public @matmul_kernel_01234567891011(\n+            %arg0: !tt.ptr<f16, 1>, %arg1: !tt.ptr<f16, 1>, %arg2: !tt.ptr<f16, 1> ,\n+            %arg3: i32, %arg4: i32, %arg5: i32 ,\n+            %arg6: i32, %arg7: i32, %arg8: i32 ,\n+            %%arg9: i32, %arg10: i32, %arg11: i32 ) attributes {noinline = false} {\n+    %0 = tt.get_program_id x : i32\n+    %1 = tt.call @cdiv__i32__1cconstexpr_32_(%arg3) : (i32) -> i32\n+    %2 = tt.call @cdiv__i32__1cconstexpr_64_(%arg4) : (i32) -> i32\n+    %c8_i32 = arith.constant 8 : i32\n+    %3 = arith.muli %2, %c8_i32 : i32\n+    %4 = arith.divsi %0, %3 : i32\n+    %c8_i32_0 = arith.constant 8 : i32\n+    %5 = arith.muli %4, %c8_i32_0 : i32\n+    %6 = arith.subi %1, %5 : i32\n+    %7 = tt.call @minimum__i32__1cconstexpr_8_(%6) : (i32) -> i32\n+    %8 = arith.remsi %0, %7 : i32\n+    %9 = arith.addi %5, %8 : i32\n+    %10 = arith.remsi %0, %3 : i32\n+    %11 = arith.divsi %10, %7 : i32\n+    %c32_i32 = arith.constant 32 : i32\n+    %12 = arith.muli %9, %c32_i32 : i32\n+    %13 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32>\n+    %14 = tt.splat %12 : (i32) -> tensor<32xi32>\n+    %15 = arith.addi %14, %13 : tensor<32xi32>\n+    %16 = tt.splat %arg3 : (i32) -> tensor<32xi32>\n+    %17 = arith.remsi %15, %16 : tensor<32xi32>\n+    %c64_i32 = arith.constant 64 : i32\n+    %18 = arith.muli %11, %c64_i32 : i32\n+    %19 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32>\n+    %20 = tt.splat %18 : (i32) -> tensor<64xi32>\n+    %21 = arith.addi %20, %19 : tensor<64xi32>\n+    %22 = tt.splat %arg4 : (i32) -> tensor<64xi32>\n+    %23 = arith.remsi %21, %22 : tensor<64xi32>\n+    %24 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32>\n+    %25 = tt.expand_dims %17 {axis = 1 : i32} : (tensor<32xi32>) -> tensor<32x1xi32>\n+    %26 = tt.splat %arg6 : (i32) -> tensor<32x1xi32>\n+    %27 = arith.muli %25, %26 : tensor<32x1xi32>\n+    %28 = tt.expand_dims %24 {axis = 0 : i32} : (tensor<32xi32>) -> tensor<1x32xi32>\n+    %29 = tt.splat %arg7 : (i32) -> tensor<1x32xi32>\n+    %30 = arith.muli %28, %29 : tensor<1x32xi32>\n+    %31 = tt.broadcast %27 : (tensor<32x1xi32>) -> tensor<32x32xi32>\n+    %32 = tt.broadcast %30 : (tensor<1x32xi32>) -> tensor<32x32xi32>\n+    %33 = arith.addi %31, %32 : tensor<32x32xi32>\n+    %34 = tt.splat %arg0 : (!tt.ptr<f16, 1>) -> tensor<32x32x!tt.ptr<f16, 1>>\n+    %35 = tt.addptr %34, %33 : tensor<32x32x!tt.ptr<f16, 1>>, tensor<32x32xi32>\n+    %36 = tt.expand_dims %24 {axis = 1 : i32} : (tensor<32xi32>) -> tensor<32x1xi32>\n+    %37 = tt.splat %arg8 : (i32) -> tensor<32x1xi32>\n+    %38 = arith.muli %36, %37 : tensor<32x1xi32>\n+    %39 = tt.expand_dims %23 {axis = 0 : i32} : (tensor<64xi32>) -> tensor<1x64xi32>\n+    %40 = tt.splat %arg9 : (i32) -> tensor<1x64xi32>\n+    %41 = arith.muli %39, %40 : tensor<1x64xi32>\n+    %42 = tt.broadcast %38 : (tensor<32x1xi32>) -> tensor<32x64xi32>\n+    %43 = tt.broadcast %41 : (tensor<1x64xi32>) -> tensor<32x64xi32>\n+    %44 = arith.addi %42, %43 : tensor<32x64xi32>\n+    %45 = tt.splat %arg1 : (!tt.ptr<f16, 1>) -> tensor<32x64x!tt.ptr<f16, 1>>\n+    %46 = tt.addptr %45, %44 : tensor<32x64x!tt.ptr<f16, 1>>, tensor<32x64xi32>\n+    %47 = tt.call @\"zeros____0cconstexpr_(constexpr_32_, constexpr_64_)__1cconstexpr_fp32_\"() : () -> tensor<32x64xf32>\n+    %48 = tt.call @cdiv__i32__1cconstexpr_32_(%arg5) : (i32) -> i32\n+    %c0_i32 = arith.constant 0 : i32\n+    %c1_i32 = arith.constant 1 : i32\n+    %49 = arith.bitcast %c0_i32 : i32 to i32\n+    %50 = arith.bitcast %48 : i32 to i32\n+    %51 = arith.bitcast %c1_i32 : i32 to i32\n+    %52 = llvm.mlir.undef : i32\n+    %53:3 = scf.for %arg12 = %49 to %50 step %51 iter_args(%arg13 = %47, %arg14 = %35, %arg15 = %46) -> (tensor<32x64xf32>, tensor<32x32x!tt.ptr<f16, 1>>, tensor<32x64x!tt.ptr<f16, 1>>)  : i32 {\n+      %83 = tt.expand_dims %24 {axis = 0 : i32} : (tensor<32xi32>) -> tensor<1x32xi32>\n+      %c32_i32_3 = arith.constant 32 : i32\n+      %84 = arith.muli %arg12, %c32_i32_3 : i32\n+      %85 = arith.subi %arg5, %84 : i32\n+      %86 = tt.splat %85 : (i32) -> tensor<1x32xi32>\n+      %87 = arith.cmpi slt, %83, %86 : tensor<1x32xi32>\n+      %cst = arith.constant 0.000000e+00 : f32\n+      %88 = tt.broadcast %87 : (tensor<1x32xi1>) -> tensor<32x32xi1>\n+      %cst_4 = arith.constant dense<0.000000e+00> : tensor<32x32xf32>\n+      %89 = arith.truncf %cst_4 : tensor<32x32xf32> to tensor<32x32xf16>\n+      %90 = tt.load %arg14, %88, %89 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<32x32xf16>\n+      %91 = tt.expand_dims %24 {axis = 1 : i32} : (tensor<32xi32>) -> tensor<32x1xi32>\n+      %c32_i32_5 = arith.constant 32 : i32\n+      %92 = arith.muli %arg12, %c32_i32_5 : i32\n+      %93 = arith.subi %arg5, %92 : i32\n+      %94 = tt.splat %93 : (i32) -> tensor<32x1xi32>\n+      %95 = arith.cmpi slt, %91, %94 : tensor<32x1xi32>\n+      %cst_6 = arith.constant 0.000000e+00 : f32\n+      %96 = tt.broadcast %95 : (tensor<32x1xi1>) -> tensor<32x64xi1>\n+      %cst_7 = arith.constant dense<0.000000e+00> : tensor<32x64xf32>\n+      %97 = arith.truncf %cst_7 : tensor<32x64xf32> to tensor<32x64xf16>\n+      %98 = tt.load %arg15, %96, %97 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<32x64xf16>\n+      %cst_8 = arith.constant 0.000000e+00 : f32\n+      %cst_9 = arith.constant dense<0.000000e+00> : tensor<32x64xf32>\n+      %99 = tt.dot %90, %98, %cst_9 {allowTF32 = true, maxNumImpreciseAcc = 0 : i32} : tensor<32x32xf16> * tensor<32x64xf16> -> tensor<32x64xf32>\n+      %100 = arith.addf %arg13, %99 : tensor<32x64xf32>\n+      %c32_i32_10 = arith.constant 32 : i32\n+      %101 = arith.muli %arg7, %c32_i32_10 : i32\n+      %102 = tt.splat %101 : (i32) -> tensor<32x32xi32>\n+      %103 = tt.addptr %arg14, %102 : tensor<32x32x!tt.ptr<f16, 1>>, tensor<32x32xi32>\n+      %c32_i32_11 = arith.constant 32 : i32\n+      %104 = arith.muli %arg8, %c32_i32_11 : i32\n+      %105 = tt.splat %104 : (i32) -> tensor<32x64xi32>\n+      %106 = tt.addptr %arg15, %105 : tensor<32x64x!tt.ptr<f16, 1>>, tensor<32x64xi32>\n+      scf.yield %100, %103, %106 : tensor<32x64xf32>, tensor<32x32x!tt.ptr<f16, 1>>, tensor<32x64x!tt.ptr<f16, 1>>\n+    }\n+    %54 = arith.truncf %53#0 : tensor<32x64xf32> to tensor<32x64xf16>\n+    %c32_i32_1 = arith.constant 32 : i32\n+    %55 = arith.muli %9, %c32_i32_1 : i32\n+    %56 = tt.make_range {end = 32 : i32, start = 0 : i32} : tensor<32xi32>\n+    %57 = tt.splat %55 : (i32) -> tensor<32xi32>\n+    %58 = arith.addi %57, %56 : tensor<32xi32>\n+    %c64_i32_2 = arith.constant 64 : i32\n+    %59 = arith.muli %11, %c64_i32_2 : i32\n+    %60 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32>\n+    %61 = tt.splat %59 : (i32) -> tensor<64xi32>\n+    %62 = arith.addi %61, %60 : tensor<64xi32>\n+    %63 = tt.expand_dims %58 {axis = 1 : i32} : (tensor<32xi32>) -> tensor<32x1xi32>\n+    %64 = tt.splat %arg10 : (i32) -> tensor<32x1xi32>\n+    %65 = arith.muli %64, %63 : tensor<32x1xi32>\n+    %66 = tt.splat %arg2 : (!tt.ptr<f16, 1>) -> tensor<32x1x!tt.ptr<f16, 1>>\n+    %67 = tt.addptr %66, %65 : tensor<32x1x!tt.ptr<f16, 1>>, tensor<32x1xi32>\n+    %68 = tt.expand_dims %62 {axis = 0 : i32} : (tensor<64xi32>) -> tensor<1x64xi32>\n+    %69 = tt.splat %arg11 : (i32) -> tensor<1x64xi32>\n+    %70 = arith.muli %69, %68 : tensor<1x64xi32>\n+    %71 = tt.broadcast %67 : (tensor<32x1x!tt.ptr<f16, 1>>) -> tensor<32x64x!tt.ptr<f16, 1>>\n+    %72 = tt.broadcast %70 : (tensor<1x64xi32>) -> tensor<32x64xi32>\n+    %73 = tt.addptr %71, %72 : tensor<32x64x!tt.ptr<f16, 1>>, tensor<32x64xi32>\n+    %74 = tt.expand_dims %58 {axis = 1 : i32} : (tensor<32xi32>) -> tensor<32x1xi32>\n+    %75 = tt.splat %arg3 : (i32) -> tensor<32x1xi32>\n+    %76 = arith.cmpi slt, %74, %75 : tensor<32x1xi32>\n+    %77 = tt.expand_dims %62 {axis = 0 : i32} : (tensor<64xi32>) -> tensor<1x64xi32>\n+    %78 = tt.splat %arg4 : (i32) -> tensor<1x64xi32>\n+    %79 = arith.cmpi slt, %77, %78 : tensor<1x64xi32>\n+    %80 = tt.broadcast %76 : (tensor<32x1xi1>) -> tensor<32x64xi1>\n+    %81 = tt.broadcast %79 : (tensor<1x64xi1>) -> tensor<32x64xi1>\n+    %82 = arith.andi %80, %81 : tensor<32x64xi1>\n+    tt.store %73, %54, %82 {cache = 1 : i32, evict = 1 : i32} : tensor<32x64xf16>\n+    tt.return\n+  }\n+  tt.func private @cdiv__i32__1cconstexpr_32_(%arg0: i32 ) -> i32 attributes {noinline = false} {\n+    %c32_i32 = arith.constant 32 : i32\n+    %0 = arith.addi %arg0, %c32_i32 : i32\n+    %c1_i32 = arith.constant 1 : i32\n+    %1 = arith.subi %0, %c1_i32 : i32\n+    %c32_i32_0 = arith.constant 32 : i32\n+    %2 = arith.divsi %1, %c32_i32_0 : i32\n+    tt.return %2 : i32\n+  }\n+  tt.func private @cdiv__i32__1cconstexpr_64_(%arg0: i32 ) -> i32 attributes {noinline = false} {\n+    %c64_i32 = arith.constant 64 : i32\n+    %0 = arith.addi %arg0, %c64_i32 : i32\n+    %c1_i32 = arith.constant 1 : i32\n+    %1 = arith.subi %0, %c1_i32 : i32\n+    %c64_i32_0 = arith.constant 64 : i32\n+    %2 = arith.divsi %1, %c64_i32_0 : i32\n+    tt.return %2 : i32\n+  }\n+  tt.func private @minimum__i32__1cconstexpr_8_(%arg0: i32 ) -> i32 attributes {noinline = false} {\n+    %c8_i32 = arith.constant 8 : i32\n+    %0 = arith.minsi %arg0, %c8_i32 : i32\n+    tt.return %0 : i32\n+  }\n+  tt.func private @\"zeros____0cconstexpr_(constexpr_32_, constexpr_64_)__1cconstexpr_fp32_\"() -> tensor<32x64xf32> attributes {noinline = false} {\n+    %cst = arith.constant 0.000000e+00 : f32\n+    %cst_0 = arith.constant dense<0.000000e+00> : tensor<32x64xf32>\n+    tt.return %cst_0 : tensor<32x64xf32>\n+  }\n+}\n+ *\/\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestMatrix.java","additions":832,"deletions":0,"binary":false,"changes":832,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import oracle.code.triton.TritonTestExtension.Kernel;\n+import oracle.code.triton.TritonTestExtension.TritonTestData;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestSoftMax {\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"max_float_float_float\" (%0 : float, %1 : float)float -> {\n+                    %2 : float = arith.maximumf %0 %1;\n+                    tt.return %2;\n+                };\n+                tt.func @\"reduce_max_float_float_float_0\" (%3 : tensor<x64, float>)float -> {\n+                    %4 : float = tt.reduce %3 @axis=\"0\" (%5 : float, %6 : float)float -> {\n+                        %7 : float = tt.call %5 %6 @\"max_float_float_float\";\n+                        tt.reduce.return %7;\n+                    };\n+                    tt.return %4;\n+                };\n+                tt.func @\"sum_float_float_float\" (%8 : float, %9 : float)float -> {\n+                    %10 : float = arith.addf %8 %9;\n+                    tt.return %10;\n+                };\n+                tt.func @\"reduce_sum_float_float_float_0\" (%11 : tensor<x64, float>)float -> {\n+                    %12 : float = tt.reduce %11 @axis=\"0\" (%13 : float, %14 : float)float -> {\n+                        %15 : float = tt.call %13 %14 @\"sum_float_float_float\";\n+                        tt.reduce.return %15;\n+                    };\n+                    tt.return %12;\n+                };\n+                tt.func @\"softmax_kernel_ptr<float>_ptr<float>_1_1_10_64_void\" (%16 : ptr<float>, %17 : ptr<float>)void -> {\n+                    %18 : int = arith.constant @\"1\";\n+                    %19 : int = arith.constant @\"1\";\n+                    %20 : int = arith.constant @\"10\";\n+                    %21 : int = tt.get_program_id @\"0\";\n+                    %22 : int = arith.muli %21 %18;\n+                    %23 : ptr<float> = tt.addptr %17 %22;\n+                    %24 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %25 : tensor<x64, ptr<float>> = tt.splat %23;\n+                    %26 : tensor<x64, ptr<float>> = tt.addptr %25 %24;\n+                    %27 : tensor<x64, int> = tt.splat %20;\n+                    %28 : tensor<x64, int> = arith.cmpi %24 %27 @\"slt\";\n+                    %29 : tensor<x64, float> = tt.load %26 %28;\n+                    %30 : float = tt.call %29 @\"reduce_max_float_float_float_0\";\n+                    %31 : tensor<x64, float> = tt.splat %30;\n+                    %32 : tensor<x64, float> = arith.subf %29 %31;\n+                    %33 : tensor<x64, float> = math.exp %32;\n+                    %34 : float = tt.call %33 @\"reduce_sum_float_float_float_0\";\n+                    %35 : tensor<x64, float> = tt.splat %34;\n+                    %36 : tensor<x64, float> = arith.divf %33 %35;\n+                    %37 : int = arith.muli %21 %19;\n+                    %38 : ptr<float> = tt.addptr %16 %37;\n+                    %39 : tensor<x64, ptr<float>> = tt.splat %38;\n+                    %40 : tensor<x64, ptr<float>> = tt.addptr %39 %24;\n+                    tt.store %40 %36 %28;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void softmax_kernel(Ptr output_ptr,\n+                               Ptr input_ptr,\n+                               int input_row_stride,\n+                               int output_row_stride,\n+                               int n_cols,\n+                               @Constant int BLOCK_SIZE) {\n+        \/\/ The rows of the softmax are independent, so we parallelize across those\n+        var row_idx = Triton.programId(0);\n+        var row_start_ptr = Triton.add(input_ptr, row_idx * input_row_stride);\n+        \/\/ The block size is the next power of two greater than n_cols, so we can fit each\n+        \/\/ row in a single block\n+        var col_offsets = Triton.arange(0, BLOCK_SIZE);\n+        var input_ptrs = Triton.add(Triton.broadcast(row_start_ptr, col_offsets.type()), col_offsets);\n+        \/\/ Load the row into SRAM, using a mask since BLOCK_SIZE may be > than n_cols\n+        var mask = Triton.compare(col_offsets,\n+                Triton.broadcast(n_cols, col_offsets.type()),\n+                Triton.CompareKind.LessThan);\n+        var row = Triton.load(input_ptrs, mask);\n+        \/\/ Subtract maximum for numerical stability\n+        var row_minus_max = Triton.sub(row, Triton.broadcast(Triton.max(row, 0), row.type()));\n+        \/\/ Note that exponentiation in Triton is fast but approximate (i.e., think __expf in CUDA)\n+        var numerator = Triton.exp(row_minus_max);\n+        var denominator = Triton.sum(numerator, 0);\n+        var softmax_output = Triton.div(numerator, Triton.broadcast(denominator, numerator.type()));\n+        \/\/ Write back output to DRAM\n+        var output_row_start_ptr = Triton.add(output_ptr, row_idx * output_row_stride);\n+        var output_ptrs = Triton.add(Triton.broadcast(output_row_start_ptr, col_offsets.type()), col_offsets);\n+        Triton.store(output_ptrs, softmax_output, mask);\n+    }\n+\n+    @Kernel(\"softmax_kernel\")\n+    @Test\n+    public void test(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                new ConstantType(JavaType.INT, 1),\n+                new ConstantType(JavaType.INT, 1),\n+                new ConstantType(JavaType.INT, 10),\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"max_float_float_float\" (%0 : float, %1 : float)float -> {\n+                    %2 : float = arith.maximumf %0 %1;\n+                    tt.return %2;\n+                };\n+                tt.func @\"reduce_max_float_float_float_0\" (%3 : tensor<x64, float>)float -> {\n+                    %4 : float = tt.reduce %3 @axis=\"0\" (%5 : float, %6 : float)float -> {\n+                        %7 : float = tt.call %5 %6 @\"max_float_float_float\";\n+                        tt.reduce.return %7;\n+                    };\n+                    tt.return %4;\n+                };\n+                tt.func @\"sum_float_float_float\" (%8 : float, %9 : float)float -> {\n+                    %10 : float = arith.addf %8 %9;\n+                    tt.return %10;\n+                };\n+                tt.func @\"reduce_sum_float_float_float_0\" (%11 : tensor<x64, float>)float -> {\n+                    %12 : float = tt.reduce %11 @axis=\"0\" (%13 : float, %14 : float)float -> {\n+                        %15 : float = tt.call %13 %14 @\"sum_float_float_float\";\n+                        tt.reduce.return %15;\n+                    };\n+                    tt.return %12;\n+                };\n+                tt.func @\"softmax_kernel2_ptr<float>_ptr<float>_1_1_10_64_void\" (%16 : ptr<float>, %17 : ptr<float>)void -> {\n+                    %18 : int = arith.constant @\"1\";\n+                    %19 : int = arith.constant @\"1\";\n+                    %20 : int = arith.constant @\"10\";\n+                    %21 : int = tt.get_program_id @\"0\";\n+                    %22 : int = arith.muli %21 %18;\n+                    %23 : ptr<float> = tt.addptr %17 %22;\n+                    %24 : tensor<x64, int> = tt.make_range @start=\"0\" @end=\"64\";\n+                    %25 : tensor<x64, ptr<float>> = tt.splat %23;\n+                    %26 : tensor<x64, ptr<float>> = tt.addptr %25 %24;\n+                    %27 : tensor<x64, int> = tt.splat %20;\n+                    %28 : tensor<x64, int> = arith.cmpi %24 %27 @\"slt\";\n+                    %29 : tensor<x64, float> = tt.load %26 %28;\n+                    %30 : float = tt.call %29 @\"reduce_max_float_float_float_0\";\n+                    %31 : tensor<x64, float> = tt.splat %30;\n+                    %32 : tensor<x64, float> = arith.subf %29 %31;\n+                    %33 : tensor<x64, float> = math.exp %32;\n+                    %34 : float = tt.call %33 @\"reduce_sum_float_float_float_0\";\n+                    %35 : tensor<x64, float> = tt.splat %34;\n+                    %36 : tensor<x64, float> = arith.divf %33 %35;\n+                    %37 : int = arith.muli %21 %19;\n+                    %38 : ptr<float> = tt.addptr %16 %37;\n+                    %39 : tensor<x64, ptr<float>> = tt.splat %38;\n+                    %40 : tensor<x64, ptr<float>> = tt.addptr %39 %24;\n+                    tt.store %40 %36 %28;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void softmax_kernel2(Ptr output_ptr,\n+                                Ptr input_ptr,\n+                                int input_row_stride,\n+                                int output_row_stride,\n+                                int n_cols,\n+                                @Constant int BLOCK_SIZE) {\n+        \/\/ The rows of the softmax are independent, so we parallelize across those\n+        var row_idx = Triton.programId(0);\n+        var row_start_ptr = Triton.add(input_ptr, row_idx * input_row_stride);\n+        \/\/ The block size is the next power of two greater than n_cols, so we can fit each\n+        \/\/ row in a single block\n+        var col_offsets = Triton.arange(0, BLOCK_SIZE);\n+        var input_ptrs = Triton.add(row_start_ptr, col_offsets);\n+        \/\/ Load the row into SRAM, using a mask since BLOCK_SIZE may be > than n_cols\n+        var mask = Triton.compare(col_offsets, n_cols, Triton.CompareKind.LessThan);\n+        var row = Triton.load(input_ptrs, mask);\n+        \/\/ Subtract maximum for numerical stability\n+        var row_minus_max = Triton.sub(row, Triton.max(row, 0));\n+        \/\/ Note that exponentiation in Triton is fast but approximate (i.e., think __expf in CUDA)\n+        var numerator = Triton.exp(row_minus_max);\n+        var denominator = Triton.sum(numerator, 0);\n+        var softmax_output = Triton.div(numerator, denominator);\n+        \/\/ Write back output to DRAM\n+        var output_row_start_ptr = Triton.add(output_ptr, row_idx * output_row_stride);\n+        var output_ptrs = Triton.add(output_row_start_ptr, col_offsets);\n+        Triton.store(output_ptrs, softmax_output, mask);\n+    }\n+\n+    @Kernel(\"softmax_kernel2\")\n+    @Test\n+    public void test2(TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new PtrType(JavaType.FLOAT),\n+                new PtrType(JavaType.FLOAT),\n+                new ConstantType(JavaType.INT, 1),\n+                new ConstantType(JavaType.INT, 1),\n+                new ConstantType(JavaType.INT, 10),\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+}\n+\n+\/*\n+def softmax_kernel(output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, BLOCK_SIZE: tl.constexpr):\n+    # The rows of the softmax are independent, so we parallelize across those\n+    row_idx = tl.program_id(0)\n+    # The stride represents how much we need to increase the pointer to advance 1 row\n+    row_start_ptr = input_ptr + row_idx * input_row_stride\n+    # The block size is the next power of two greater than n_cols, so we can fit each\n+    # row in a single block\n+    col_offsets = tl.arange(0, BLOCK_SIZE)\n+    input_ptrs = row_start_ptr + col_offsets\n+    # Load the row into SRAM, using a mask since BLOCK_SIZE may be > than n_cols\n+    row = tl.load(input_ptrs, mask=col_offsets < n_cols, other=-float('inf'))\n+    # Subtract maximum for numerical stability\n+    row_minus_max = row - tl.max(row, axis=0)\n+    # Note that exponentiation in Triton is fast but approximate (i.e., think __expf in CUDA)\n+    numerator = tl.exp(row_minus_max)\n+    denominator = tl.sum(numerator, axis=0)\n+    softmax_output = numerator \/ denominator\n+    # Write back output to DRAM\n+    output_row_start_ptr = output_ptr + row_idx * output_row_stride\n+    output_ptrs = output_row_start_ptr + col_offsets\n+    tl.store(output_ptrs, softmax_output, mask=col_offsets < n_cols)\n+*\/\n+\n+\/*\n+input_row_stride = 1\n+output_row_stride = 1\n+n_cols=10\n+BLOCK_SIZE=64\n+\n+module {\n+  tt.func public @softmax_kernel_01(%arg0: !tt.ptr<f32, 1> , %arg1: !tt.ptr<f32, 1> ) attributes {noinline = false} {\n+    %0 = tt.get_program_id x : i32\n+    %c1_i32 = arith.constant 1 : i32\n+    %1 = arith.muli %0, %c1_i32 : i32\n+    %2 = tt.addptr %arg1, %1 : !tt.ptr<f32, 1>, i32\n+    %3 = tt.make_range {end = 64 : i32, start = 0 : i32} : tensor<64xi32>\n+    %4 = tt.splat %2 : (!tt.ptr<f32, 1>) -> tensor<64x!tt.ptr<f32, 1>>\n+    %5 = tt.addptr %4, %3 : tensor<64x!tt.ptr<f32, 1>>, tensor<64xi32>\n+    %c10_i32 = arith.constant 10 : i32\n+    %cst = arith.constant dense<10> : tensor<64xi32>\n+    %6 = arith.cmpi slt, %3, %cst : tensor<64xi32>\n+    %cst_0 = arith.constant 0xFF800000 : f32\n+    %cst_1 = arith.constant dense<0xFF800000> : tensor<64xf32>\n+    %7 = tt.load %5, %6, %cst_1 {cache = 1 : i32, evict = 1 : i32, isVolatile = false} : tensor<64xf32>\n+    %8 = tt.call @max__fp32S64S__1cconstexpr_0__2cconstexpr_False__3cconstexpr_True_(%7) : (tensor<64xf32>) -> f32\n+    %9 = tt.splat %8 : (f32) -> tensor<64xf32>\n+    %10 = arith.subf %7, %9 : tensor<64xf32>\n+    %11 = math.exp %10 : tensor<64xf32>\n+    %12 = tt.call @sum__fp32S64S__1cconstexpr_0_(%11) : (tensor<64xf32>) -> f32\n+    %13 = tt.splat %12 : (f32) -> tensor<64xf32>\n+    %14 = arith.divf %11, %13 : tensor<64xf32>\n+    %c1_i32_2 = arith.constant 1 : i32\n+    %15 = arith.muli %0, %c1_i32_2 : i32\n+    %16 = tt.addptr %arg0, %15 : !tt.ptr<f32, 1>, i32\n+    %17 = tt.splat %16 : (!tt.ptr<f32, 1>) -> tensor<64x!tt.ptr<f32, 1>>\n+    %18 = tt.addptr %17, %3 : tensor<64x!tt.ptr<f32, 1>>, tensor<64xi32>\n+    %c10_i32_3 = arith.constant 10 : i32\n+    %cst_4 = arith.constant dense<10> : tensor<64xi32>\n+    %19 = arith.cmpi slt, %3, %cst_4 : tensor<64xi32>\n+    tt.store %18, %14, %19 {cache = 1 : i32, evict = 1 : i32} : tensor<64xf32>\n+    tt.return\n+  }\n+  tt.func private @max__fp32S64S__1cconstexpr_0__2cconstexpr_False__3cconstexpr_True_(%arg0: tensor<64xf32> ) -> f32 attributes {noinline = false} {\n+    %0 = \"tt.reduce\"(%arg0) <{axis = 0 : i32}> ({\n+    ^bb0(%arg1: f32 , %arg2: f32 ):\n+      %1 = tt.call @maximum__fp32_fp32__(%arg1, %arg2) : (f32, f32) -> f32\n+      tt.reduce.return %1 : f32\n+    }) : (tensor<64xf32>) -> f32\n+    tt.return %0 : f32\n+  }\n+  tt.func private @maximum__fp32_fp32__(%arg0: f32 , %arg1: f32 ) -> f32 attributes {noinline = false} {\n+    %0 = arith.maximumf %arg0, %arg1 : f32\n+    tt.return %0 : f32\n+  }\n+  tt.func private @sum__fp32S64S__1cconstexpr_0_(%arg0: tensor<64xf32> ) -> f32 attributes {noinline = false} {\n+    %0 = \"tt.reduce\"(%arg0) <{axis = 0 : i32}> ({\n+    ^bb0(%arg1: f32 , %arg2: f32 ):\n+      %1 = tt.call @_sum_combine__fp32_fp32__(%arg1, %arg2) : (f32, f32) -> f32\n+      tt.reduce.return %1 : f32\n+    }) : (tensor<64xf32>) -> f32\n+    tt.return %0 : f32\n+  }\n+  tt.func private @_sum_combine__fp32_fp32__(%arg0: f32 , %arg1: f32 ) -> f32 attributes {noinline = false} {\n+    %0 = arith.addf %arg0, %arg1 : f32\n+    tt.return %0 : f32\n+  }\n+}\n+*\/\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestSoftMax.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+import static oracle.code.triton.Triton.zeros;\n+import static oracle.code.triton.TritonTest.consume;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestVariables {\n+\n+    @CodeReflection\n+    static void test1(@Constant int M) {\n+        var m = Triton.arange(0, M);\n+        var e = Triton.expand(m, 0);\n+        consume(e);\n+        \/\/ Store to variable fails since tensor is of different shape\n+        e = Triton.expand(m, 1);\n+        consume(e);\n+    }\n+\n+    @Test\n+    public void test1(TritonTestExtension.TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new ConstantType(JavaType.INT, 32));\n+\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            t.test(argTypes);\n+        });\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestVariables.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+import static oracle.code.triton.Triton.*;\n+import static oracle.code.triton.TritonTest.consume;\n+\n+@ExtendWith(TritonTestExtension.class)\n+public class TestZeros {\n+\n+    @TritonCodeModel(\"\"\"\n+            module ()void -> {\n+                tt.func @\"test1_32_64_void\" ()void -> {\n+                    %0 : tensor<x32, x64, float> = arith.constant @\"0.0\";\n+                    tt.consume %0;\n+                    tt.return;\n+                };\n+                unreachable;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    static void test1(@Constant int M, @Constant int N) {\n+        var t = zeros(float.class, M, N);\n+        consume(t);\n+    }\n+\n+    @Test\n+    public void test1(TritonTestExtension.TritonTestData t) {\n+        List<TypeElement> argTypes = List.of(\n+                new ConstantType(JavaType.INT, 32),\n+                new ConstantType(JavaType.INT, 64));\n+\n+        t.test(argTypes);\n+    }\n+\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TestZeros.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.METHOD, ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface TritonCodeModel {\n+    String value();\n+\n+    boolean SSA() default true;\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonCodeModel.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+public class TritonTest {\n+    public static void consume(Object o) {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.triton;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.ParameterContext;\n+import org.junit.jupiter.api.extension.ParameterResolver;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TritonTestExtension implements ParameterResolver {\n+\n+    @Target({ElementType.METHOD, ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Kernel {\n+        String value();\n+    }\n+\n+    @Override\n+    public boolean supportsParameter(ParameterContext pc, ExtensionContext ec) {\n+        return pc.getParameter().getType() == TritonTestData.class;\n+    }\n+\n+    @Override\n+    public Object resolveParameter(ParameterContext pc, ExtensionContext ec) {\n+        Kernel k = ec.getRequiredTestMethod().getAnnotation(Kernel.class);\n+        String kernelName = (k != null)\n+            ? k.value()\n+            : ec.getRequiredTestMethod().getName();\n+\n+        return new TritonTestData(ec.getRequiredTestClass(), kernelName);\n+    }\n+\n+    public static class TritonTestData {\n+        final Class<?> testClass;\n+        final String javaKernelName;\n+\n+        public TritonTestData(Class<?> testClass, String javaKernelName) {\n+            this.testClass = testClass;\n+            this.javaKernelName = javaKernelName;\n+        }\n+\n+        public void test(List<? extends TypeElement> argTypes) {\n+            Optional<Method> om = Stream.of(testClass.getDeclaredMethods())\n+                    .filter(m -> m.getName().equals(javaKernelName))\n+                    .filter(m -> m.getAnnotation(CodeReflection.class) != null)\n+                    .findFirst();\n+            Method m = om.get();\n+            TritonCodeModel tcm = m.getAnnotation(TritonCodeModel.class);\n+            boolean doSSA = tcm != null ? tcm.SSA() : true;\n+            test(m.getCodeModel().get(), argTypes, expectedTritonKernel(tcm), doSSA);\n+        }\n+\n+        public TritonOps.ModuleOp expectedTritonKernel(TritonCodeModel tcm) {\n+            if (tcm == null || tcm.value().isEmpty()) {\n+                return null;\n+            }\n+\n+            return (TritonOps.ModuleOp) OpParser.fromString(\n+                    TritonOps.FACTORY.andThen(ArithMathOps.FACTORY)\n+                            .andThen(TritonTestOps.FACTORY)\n+                            .andThen(SCFOps.FACTORY)\n+                            .andThen(CoreOps.FACTORY),\n+                    TritonOps.TYPE_FACTORY,\n+                    tcm.value()).get(0);\n+        }\n+\n+        void test(CoreOps.FuncOp javaKernel,\n+                  List<? extends TypeElement> argTypes,\n+                  TritonOps.ModuleOp expectedTritonKernel,\n+                  boolean doSSA) {\n+            TritonOps.ModuleOp actualTritonKernel = ScopedValue.getWhere(TritonTransformer.SV_SSA, doSSA,() -> {\n+                return TritonTransformer.tritonModule(javaKernel, JavaType.VOID, argTypes);\n+            });\n+\n+            Assertions.assertEquals(\n+                    expectedTritonKernel == null ? \"NO @TritonCodeModel\" : expectedTritonKernel.toText(),\n+                    actualTritonKernel.toText());\n+        }\n+    }\n+\n+}\n","filename":"cr-examples\/triton\/src\/test\/java\/oracle\/code\/triton\/TritonTestExtension.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# copy selected cr packages into jdk.compiler\n+\n+base=java\/lang\/reflect\/code\n+packages=\"\n+  $base \\\n+  $base\/writer \\\n+  $base\/op \\\n+  $base\/type \\\n+  $base\/type\/impl \\\n+  \"\n+\n+removeclasses=\"\"\n+\n+java_base_dir=$1\n+jdk_compiler_dir=$2\n+\n+for p in $packages; do\n+  mkdir -p $jdk_compiler_dir\/jdk\/internal\/$p\n+  cp -r $java_base_dir\/$p\/*.java $jdk_compiler_dir\/jdk\/internal\/$p\/.\n+done\n+\n+for f in $removeclasses; do\n+  rm $jdk_compiler_dir\/jdk\/internal\/$f\n+done\n+\n+find $jdk_compiler_dir\/jdk\/internal\/$base -name \"*.java\" -print \\\n+  | xargs sed -i'.bck' \\\n+  -e 's\/java\\.lang\\.reflect\\.code\/jdk\\.internal\\.java\\.lang\\.reflect\\.code\/g' \\\n+  -e 's\/^\\\/\\*__\\(.*\\)__\\*\\\/.*$\/\\1\/'\n+\n+find $jdk_compiler_dir\/jdk\/internal\/$base -name \"*.bck\" -exec rm {} \\;\n+\n","filename":"cr-util\/copy-to-compiler.sh","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -78,0 +78,1 @@\n+    jdk.code.tools \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  ~ Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+  ~ Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,9 @@\n-    <target name=\"generate-sources\"  depends=\"-prepare-build,-def-pparse,-def-pcompile\">\n+    <target name=\"copy-cr-sources\">\n+        <exec executable=\"\/bin\/bash\">\n+            <arg value=\"cr-util\/copy-to-compiler.sh\"\/>\n+            <arg value=\"src\/java.base\/share\/classes\"\/>\n+            <arg value=\"${build.gensrc}\/jdk.compiler\"\/>\n+        <\/exec>\n+    <\/target>\n+\n+    <target name=\"generate-sources\"  depends=\"copy-cr-sources,-prepare-build,-def-pparse,-def-pcompile\">\n","filename":"make\/langtools\/build.xml","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+DISABLED_WARNINGS_java += preview\n@@ -32,3 +33,4 @@\n-DOCLINT += -Xdoclint:all\/protected \\\n-    '-Xdoclint\/package:java.*,javax.*'\n-JAVAC_FLAGS += -XDstringConcat=inline\n+# DOCLINT += -Xdoclint:all\/protected \\\n+#     '-Xdoclint\/package:java.*,javax.*'\n+JAVAC_FLAGS += -XDstringConcat=inline \\\n+    --enable-preview\n","filename":"make\/modules\/java.base\/Java.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,23 @@\n+\n+################################################################################\n+#\n+# Copy stubs of code reflection API in langtools\n+\n+GENSTUBS_DEST_ROOT := $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\n+\n+GENSTUBS_SRC := $(TOPDIR)\/src\/java.base\/share\/classes\/java\/lang\/reflect\/code\n+\n+GENSTUBS_DEST := $(GENSTUBS_DEST_ROOT)\/jdk\/internal\/java\/lang\/reflect\/code\n+\n+GENSTUBS_SCRIPT := $(TOPDIR)\/cr-util\/copy-to-compiler.sh\n+\n+GENSTUBS_CMD := $(BASH) $(GENSTUBS_SCRIPT) $(TOPDIR)\/src\/java.base\/share\/classes $(GENSTUBS_DEST_ROOT)\n+\n+$(eval $(call SetupExecute, GENSTUBS, \\\n+    WARN := Generating compiler stubs for code reflection, \\\n+    DEPS := $(call FindFiles, $(GENSTUBS_SRC), *.java), \\\n+    OUTPUT_DIR := $(GENSTUBS_DEST), \\\n+    COMMAND := $(GENSTUBS_CMD), \\\n+))\n+\n+TARGETS += $(GENSTUBS)\n","filename":"make\/modules\/jdk.compiler\/Gensrc.gmk","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,7 @@\n+    final MethodHandle quotableOpField;       \/\/ A getter method handle that is used to retrieve the\n+                                              \/\/ string representation of the quotable lambda's associated\n+                                              \/\/ intermediate representation (can be null).\n+    final MethodHandleInfo quotableOpFieldInfo;  \/\/ Info about the quotable getter method handle (can be null).\n+\n+    final MethodType quotableOpType;          \/\/ The type of the quotable lambda's associated\n+                                              \/\/ intermediate representation (can be null).\n@@ -108,0 +115,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -122,1 +132,2 @@\n-                                        MethodType[] altMethods)\n+                                        MethodType[] altMethods,\n+                                        MethodHandle reflectiveField)\n@@ -183,0 +194,13 @@\n+        this.quotableOpField = reflectiveField;\n+        if (reflectiveField != null) {\n+            \/\/ infer the method type associated with the intermediate representation of the\n+            \/\/ quotable lambda. Since {@code factoryType} contains all the captured args\n+            \/\/ we need to subtract the captured args that are required to invoke the lambda's\n+            \/\/ bytecode. The type of {@code implementation} is useful here, as it corresponds to\n+            \/\/ the signature of the emitted javac lambda implementation. From there, we need to\n+            \/\/ drop all the dynamic arguments, which are obtained from {@code interfaceMethodType}.\n+            this.quotableOpType = factoryType.dropParameterTypes(0,\n+                    implementation.type().parameterCount() - interfaceMethodType.parameterCount());\n+        } else {\n+            quotableOpType = null;\n+        }\n@@ -209,0 +233,14 @@\n+\n+        if (reflectiveField != null) {\n+            try {\n+                quotableOpFieldInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+            } catch (IllegalArgumentException e) {\n+                throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+            }\n+            if (quotableOpFieldInfo.getReferenceKind() != REF_getField &&\n+                    quotableOpFieldInfo.getReferenceKind() != REF_getStatic) {\n+                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpFieldInfo));\n+            }\n+        } else {\n+            quotableOpFieldInfo = null;\n+        }\n@@ -228,1 +266,1 @@\n-        final int capturedArity = factoryType.parameterCount();\n+        final int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -319,0 +357,4 @@\n+    int reflectiveCaptureCount() {\n+        return quotableOpType == null ? 0 : quotableOpType.parameterCount();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":45,"deletions":3,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -38,2 +43,1 @@\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n+import java.util.*;\n@@ -65,0 +69,1 @@\n+    private static final String DESCR_METHOD_QUOTED = \"()Ljava\/lang\/reflect\/code\/Quoted;\";\n@@ -69,0 +74,1 @@\n+    private static final String NAME_METHOD_QUOTED = \"quoted\";\n@@ -90,0 +96,11 @@\n+    \/\/ condy to load reflective field from class data\n+    private static final ConstantDynamic reflectiveFieldCondy;\n+\n+    private static final ConstantDynamic makeQuotedMethodCondy;\n+\n+    private static final MethodHandle HANDLE_MAKE_QUOTED;\n+\n+    private static final String quotedInstanceFieldName = \"quoted\";\n+    private static final String quotedInstanceFieldDesc = Quoted.class.descriptorString();\n+\n+\n@@ -101,4 +118,14 @@\n-        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n-        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classData\",\n-                                         classDataMType.descriptorString(), false);\n-        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm);\n+        MethodType classDataAtMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class, int.class);\n+        Handle classDataBsm = new Handle(H_INVOKESTATIC, Type.getInternalName(MethodHandles.class), \"classDataAt\",\n+                                         classDataAtMType.descriptorString(), false);\n+        implMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 0);\n+        reflectiveFieldCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 1);\n+        makeQuotedMethodCondy = new ConstantDynamic(ConstantDescs.DEFAULT_NAME, MethodHandle.class.descriptorString(), classDataBsm, 2);\n+\n+        try {\n+            HANDLE_MAKE_QUOTED = MethodHandles.lookup().findStatic(\n+                    InnerClassLambdaMetafactory.class, \"makeQuoted\",\n+                    MethodType.methodType(Quoted.class, String.class, Object[].class));\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n@@ -152,0 +179,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -166,1 +196,2 @@\n-                                       MethodType[] altMethods)\n+                                       MethodType[] altMethods,\n+                                       MethodHandle reflectiveField)\n@@ -170,1 +201,1 @@\n-              isSerializable, altInterfaces, altMethods);\n+              isSerializable, altInterfaces, altMethods, reflectiveField);\n@@ -332,0 +363,8 @@\n+        \/\/ if quotable, generate the field that will hold the value of quoted\n+        if (quotableOpField != null) {\n+            cw.visitField(ACC_PRIVATE + ACC_FINAL,\n+                          quotedInstanceFieldName,\n+                          quotedInstanceFieldDesc,\n+                          null, null);\n+        }\n+\n@@ -357,0 +396,4 @@\n+        if (quotableOpField != null) {\n+            generateQuotableMethod();\n+        }\n+\n@@ -364,1 +407,8 @@\n-            var classdata = useImplMethodHandle? implementation : null;\n+            List<?> classdata;\n+            if (useImplMethodHandle || quotableOpField != null) {\n+                classdata = quotableOpField == null ?\n+                        List.of(implementation) :\n+                        List.of(implementation, quotableOpField, HANDLE_MAKE_QUOTED);\n+            } else {\n+                classdata = null;\n+            }\n@@ -418,0 +468,5 @@\n+\n+        if (quotableOpField != null) {\n+            generateQuotedFieldInitializer(ctor);\n+        }\n+\n@@ -424,0 +479,41 @@\n+    private void generateQuotedFieldInitializer(MethodVisitor ctor) {\n+        ctor.visitCode();\n+\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        ctor.visitVarInsn(ALOAD, 0);\n+\n+        ctor.visitLdcInsn(makeQuotedMethodCondy);\n+\n+        \/\/ load op string from field\n+\n+        ctor.visitLdcInsn(reflectiveFieldCondy);\n+        MethodType mtype = quotableOpFieldInfo.getMethodType();\n+        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+            mtype = mtype.insertParameterTypes(0, implClass);\n+        }\n+        ctor.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n+                \"invokeExact\", mtype.descriptorString(), false);\n+\n+        \/\/ load captured args in array\n+\n+        ctor.visitLdcInsn(quotableOpType.parameterCount());\n+        ctor.visitTypeInsn(ANEWARRAY, JAVA_LANG_OBJECT);\n+        int capturedArity = factoryType.parameterCount() - reflectiveCaptureCount();\n+        \/\/ initialize quoted captures\n+        TypeConvertingMethodAdapter tcmv = new TypeConvertingMethodAdapter(ctor);\n+        for (int i = 0; i < reflectiveCaptureCount(); i++) {\n+            ctor.visitInsn(DUP);\n+            ctor.visitIntInsn(BIPUSH, i); \/\/ is it possible that i can be greater than Byte.MAX_VALUE ?\n+            ctor.visitVarInsn(ALOAD, 0);\n+            ctor.visitFieldInsn(GETFIELD, lambdaClassName, argNames[capturedArity + i], argDescs[capturedArity + i]);\n+            tcmv.boxIfTypePrimitive(Type.getType(argDescs[capturedArity + i]));\n+            ctor.visitInsn(AASTORE);\n+        }\n+\n+        \/\/ now create a Quoted from String and captured args Object[]\n+\n+        ctor.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\",\n+                \"invokeExact\", HANDLE_MAKE_QUOTED.type().toMethodDescriptorString(), false);\n+        ctor.visitFieldInsn(PUTFIELD, lambdaClassName, quotedInstanceFieldName, quotedInstanceFieldDesc);\n+    }\n+\n@@ -464,0 +560,17 @@\n+    \/**\n+     * Generate a writeReplace method that supports serialization\n+     *\/\n+    private void generateQuotableMethod() {\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL,\n+                                          NAME_METHOD_QUOTED, DESCR_METHOD_QUOTED,\n+                                          null, null);\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitFieldInsn(GETFIELD, lambdaClassName, quotedInstanceFieldName, quotedInstanceFieldDesc);\n+        mv.visitInsn(ARETURN);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n@@ -515,1 +628,1 @@\n-            for (int i = 0; i < argNames.length; i++) {\n+            for (int i = 0; i < argNames.length - reflectiveCaptureCount(); i++) {\n@@ -550,1 +663,1 @@\n-            int captureArity = factoryType.parameterCount();\n+            int captureArity = factoryType.parameterCount() - reflectiveCaptureCount();\n@@ -609,0 +722,4 @@\n+    private static Quoted makeQuoted(String opText, Object[] args) {\n+        FuncOp op = (FuncOp)OpParser.fromStringOfFuncOp(opText);\n+        return (Quoted)Interpreter.invoke(Lookup.IMPL_LOOKUP, op, args);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":128,"deletions":11,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.reflect.code.Quotable;\n+\n@@ -254,0 +256,4 @@\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n+     * must be a {@code Quotable} object, inspectable using code reflection. *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -339,1 +345,2 @@\n-                                             EMPTY_MT_ARRAY);\n+                                             EMPTY_MT_ARRAY,\n+                                 null);\n@@ -385,0 +392,2 @@\n+     *                          MethodType reflectType        \/\/ IF flags has QUOTABLE set\n+     *                          MethodHandle reflectField     \/\/ IF flags has QUOTABLE set\n@@ -408,0 +417,4 @@\n+     *     <li>{@code quotableField} is a\n+     *     {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter} method handle\n+     *     that is used to retrieve the string representation of the quotable lambda's associated\n+     *     intermediate representation.<\/li>\n@@ -422,0 +435,3 @@\n+     * <p>When FLAG_QUOTABLE is set in {@code flags}, the function objects\n+     * will implement {@code Quotable}.\n+     *\n@@ -490,0 +506,1 @@\n+        MethodHandle quotableField = null;\n@@ -510,0 +527,5 @@\n+        if ((flags & FLAG_QUOTABLE) != 0) {\n+            quotableField = extractArg(args, argIndex++, MethodHandle.class);\n+            altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+            altInterfaces[altInterfaces.length-1] = Quotable.class;\n+        }\n@@ -534,1 +556,2 @@\n-                                                  altMethods);\n+                                                  altMethods,\n+                                                  quotableField);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,4 @@\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.parser.OpParser;\n@@ -49,0 +53,2 @@\n+import java.util.List;\n+import java.util.Optional;\n@@ -51,0 +57,2 @@\n+import static java.lang.reflect.code.op.CoreOps.*;\n+\n@@ -98,0 +106,1 @@\n+    private volatile Optional<FuncOp>     codeModel;\n@@ -248,0 +257,52 @@\n+    \/**\n+     * Returns the code model of the method body, if present.\n+     * @return the code model of the method body.\n+     * @since 99\n+     *\/\n+    \/\/ @@@ Make caller sensitive with the same access control as invoke\n+    \/\/ and throwing IllegalAccessException\n+\/\/    @CallerSensitive\n+    public Optional<FuncOp> getCodeModel() {\n+        Optional<FuncOp> localRef = codeModel;\n+        if (localRef == null) {\n+            synchronized (this) {\n+                localRef = codeModel;\n+                if (localRef == null) {\n+                    Optional<FuncOp> op = createCodeModel();\n+                    codeModel = localRef = op;\n+                }\n+            }\n+        }\n+        return localRef;\n+    }\n+\n+    private Optional<FuncOp> createCodeModel() {\n+        Class<?> dc = getDeclaringClass();\n+        String fieldName = getName() + \"$\" + \"op\";\n+        Field f;\n+        try {\n+            f = dc.getDeclaredField(fieldName);\n+        } catch (NoSuchFieldException e) {\n+            return Optional.empty();\n+        }\n+\n+        String modelText;\n+        try {\n+            \/\/ @@@ Use method handle with full power mode\n+            f.setAccessible(true);\n+            modelText = (String) f.get(null);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        FuncOp op;\n+        try {\n+            List<Op> ops = OpParser.fromString(ExtendedOps.FACTORY, modelText);\n+            op = (FuncOp) ops.get(0);\n+        } catch (RuntimeException e) {\n+            \/\/ @@@ Error or Exception?\n+            throw e;\n+        }\n+        return Optional.of(op);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":62,"deletions":1,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,957 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+\n+\/**\n+ * A (basic) block containing an ordered sequence of operations, where the last operation is\n+ * a {@link Op.Terminating terminating} operation.\n+ * <p>\n+ * The terminating operation, according to its specification, may branch to other blocks contained in the\n+ * same parent body, by way of its {@link Op#successors() successors}, or exit the parent body and optionally\n+ * yield a result.\n+ * <p>\n+ * Blocks may declare one or more block parameters.\n+ *\/\n+public final class Block implements CodeElement<Block, Op> {\n+\n+    \/**\n+     * A value that is a block parameter\n+     *\/\n+    public static final class Parameter extends Value {\n+        Parameter(Block block, TypeElement type) {\n+            super(block, type);\n+        }\n+\n+        @Override\n+        public Set<Value> dependsOn() {\n+            return Set.of();\n+        }\n+\n+        \/**\n+         * Returns the invokable operation associated with this block parameter.\n+         * <p>\n+         * If this block parameter is declared in an entry block and that\n+         * block's ancestor operation (the parent of the entry block's parent body)\n+         * is an instance of {@link Op.Invokable}, then that instance is returned,\n+         * otherwise {@code null} is returned.\n+         * <p>\n+         * A non-{@code null} result implies this parameter is an invokable parameter.\n+         *\n+         * @apiNote\n+         * This method may be used to pattern match on the returned result:\n+         * {@snippet lang = \"java\" :\n+         *     if (p.invokableOperation() instanceof CoreOps.FuncOp f) {\n+         *         assert f.parameters().indexOf(p) == p.index(); \/\/ @link substring=\"parameters()\" target=\"Op.Invokable#parameters()\"\n+         *     }\n+         * }\n+         *\n+         * @return the invokable operation, otherwise {@code null} if the operation\n+         * is not an instance of {@link Op.Invokable}.\n+         * @see Op.Invokable#parameters()\n+         *\/\n+        public Op.Invokable invokableOperation() {\n+            if (declaringBlock().isEntryBlock() &&\n+                    declaringBlock().parentBody().parentOp() instanceof Op.Invokable o) {\n+                return o;\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        \/**\n+         * {@return the index of this block parameter in the parameters of its declaring block.}\n+         * @see Value#declaringBlock()\n+         * @see Block#parameters()\n+         *\/\n+        public int index() {\n+            return declaringBlock().parameters().indexOf(this);\n+        }\n+    }\n+\n+    \/**\n+     * A block reference that refers to a block with arguments.\n+     * <p>\n+     * A terminating operation may refer, via a block reference, to one or more blocks as its successors.\n+     * When control is passed from a block to a successor block the values of the block reference's arguments are\n+     * assigned, in order, to the successor block's parameters.\n+     *\/\n+    public static final class Reference {\n+        final Block target;\n+        final List<Value> arguments;\n+\n+        \/**\n+         * Constructs a block reference for a given target block and arguments.\n+         *\n+         * @param target    the target block.\n+         * @param arguments the target block arguments, a copy will be made as needed.\n+         *\/\n+        Reference(Block target, List<? extends Value> arguments) {\n+            this.target = target;\n+            this.arguments = List.copyOf(arguments);\n+        }\n+\n+        \/**\n+         * {@return the target block.}\n+         * @throws IllegalStateException if the target block is partially built\n+         *\/\n+        public Block targetBlock() {\n+            if (!isBound()) {\n+                throw new IllegalStateException(\"Target block is partially built\");\n+            }\n+\n+            return target;\n+        }\n+\n+        \/**\n+         * {@return the block arguments.}\n+         *\/\n+        public List<Value> arguments() {\n+            return arguments;\n+        }\n+\n+        boolean isBound() {\n+            return target.isBound();\n+        }\n+    }\n+\n+    final Body parentBody;\n+\n+    final List<Parameter> parameters;\n+\n+    final List<Op> ops;\n+\n+    \/\/ @@@ In topological order\n+    \/\/ @@@ Create lazily\n+    \/\/     Can the representation be more efficient e.g. an array?\n+    final Set<Block> predecessors;\n+\n+    \/\/ Reverse postorder index\n+    \/\/ Set when block's body has sorted its blocks and therefore set when built\n+    \/\/ Block is inoperable when < 0 i.e., when partially built\n+    int index = -1;\n+\n+    Block(Body parentBody) {\n+        this(parentBody, List.of());\n+    }\n+\n+    Block(Body parentBody, List<TypeElement> parameterTypes) {\n+        this.parentBody = parentBody;\n+        this.parameters = new ArrayList<>();\n+        for (TypeElement param : parameterTypes) {\n+            parameters.add(new Parameter(this, param));\n+        }\n+        this.ops = new ArrayList<>();\n+        this.predecessors = new LinkedHashSet<>();\n+    }\n+\n+\n+    \/**\n+     * Returns this block's parent body.\n+     *\n+     * @return this block's parent body.\n+     *\/\n+    @Override\n+    public Body parent() {\n+        return parentBody;\n+    }\n+\n+    \/**\n+     * Returns this block's parent body.\n+     *\n+     * @return this block's parent body.\n+     *\/\n+    public Body parentBody() {\n+        return parentBody;\n+    }\n+\n+    @Override\n+    public List<Op> children() {\n+        return ops();\n+    }\n+\n+    \/**\n+     * Returns the sequence of operations contained in this block.\n+     *\n+     * @return returns the sequence operations, as an unmodifiable list.\n+     *\/\n+    public List<Op> ops() {\n+        return Collections.unmodifiableList(ops);\n+    }\n+\n+    \/**\n+     * Returns this block's index within the parent body's blocks.\n+     * <p>\n+     * The following identity holds true:\n+     * {@snippet lang = \"java\" :\n+     *     this.parentBody().blocks().indexOf(this) == this.index();\n+     * }\n+     *\n+     * @apiNote\n+     * The block's index may be used to efficiently track blocks using\n+     * bits sets or boolean arrays.\n+     *\n+     * @return the block index.\n+     *\/\n+    public int index() {\n+        return index;\n+    }\n+\n+    \/**\n+     * Returns the block parameters.\n+     *\n+     * @return the block parameters, as an unmodifiable list.\n+     *\/\n+    public List<Parameter> parameters() {\n+        return Collections.unmodifiableList(parameters);\n+    }\n+\n+    \/**\n+     * Returns the block parameter types.\n+     *\n+     * @return the block parameter types, as am unmodifiable list.\n+     *\/\n+    public List<TypeElement> parameterTypes() {\n+        return parameters.stream().map(Value::type).toList();\n+    }\n+\n+    \/**\n+     * Finds the operation in this block that is the ancestor of the given operation.\n+     *\n+     * @param op the given operation.\n+     * @return the operation in this block that is the ancestor of the given operation,\n+     * otherwise {@code null}\n+     *\/\n+    public Op findAncestorOpInBlock(Op op) {\n+        Objects.requireNonNull(op);\n+\n+        while (op != null && op.parentBlock() != this) {\n+            Body encBody = op.ancestorBody();\n+            if (encBody == null) {\n+                return null;\n+            }\n+\n+            op = encBody.parentOp();\n+        }\n+\n+        return op;\n+    }\n+\n+    \/**\n+     * Returns the first operation in this block.\n+     *\n+     * @return the first operation in this block.\n+     *\/\n+    public Op firstOp() {\n+        return ops.getFirst();\n+    }\n+\n+    \/**\n+     * Returns the last, terminating, operation in this block.\n+     * <p>\n+     * The terminating operation implements {@link Op.Terminating}.\n+     *\n+     * @return the last, terminating, operation in this block.\n+     *\/\n+    public Op terminatingOp() {\n+        Op lop = ops.getLast();\n+        assert lop instanceof Op.Terminating;\n+        return lop;\n+    }\n+\n+    \/**\n+     * Returns the next operation after the given operation, otherwise {@code null}\n+     * if this operation is the last operation.\n+     *\n+     * @param op the operation\n+     * @return the next operation after the given operation.\n+     *\/\n+    public Op nextOp(Op op) {\n+        int i = ops.indexOf(op);\n+        if (i == -1) {\n+            throw new IllegalArgumentException();\n+        }\n+        return i < ops().size() - 1 ? ops.get(i + 1) : null;\n+    }\n+\n+    \/**\n+     * Returns the list of predecessors, namely each block in the parent body that refers\n+     * to this block as a successor.\n+     *\n+     * @return the set of predecessors, as an unmodifiable list.\n+     * @apiNote A block may refer to itself as a successor and therefore also be its predecessor.\n+     *\/\n+    public Set<Block> predecessors() {\n+        return Collections.unmodifiableSet(predecessors);\n+    }\n+\n+    \/**\n+     * Returns the list of successors referring to other blocks in the parent body.\n+     * <p>\n+     * The successors are declared by the terminating operation contained in this block.\n+     *\n+     * @return the list of successors, as an unmodifiable list.\n+     *\/\n+    public List<Reference> successors() {\n+        Op lopr = ops.get(ops.size() - 1);\n+        return lopr.successors();\n+    }\n+\n+    \/**\n+     * Returns true if this block is an entry block.\n+     *\n+     * @return true if this block is an entry block.\n+     *\/\n+    public boolean isEntryBlock() {\n+        return parentBody.entryBlock() == this;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this block is\n+     * <a href=\"https:\/\/en.wikipedia.org\/wiki\/Dominator_(graph_theory)\">dominated by<\/a> the given block {@code dom}.\n+     * This block is dominated by {@code dom}, if every path from the root entry block to this block passes through\n+     * {@code dom}.\n+     * <p>\n+     * If this block, {@code b} say, and {@code dom} are not in the same parent body,\n+     * then {@code b} becomes the nearest ancestor block, result of {@code b.parentBody().parentOp().parentBlock()},\n+     * and so on until either:\n+     * {@code b} is {@code null}, therefore {@code b} is <b>not<\/b> dominated by {@code dom} and this method\n+     * returns {@code false}; or\n+     * {@code b.parentBody() == dom.parentBody()}, therefore this method returns the result\n+     * of {@code b.isDominatedBy(dom)}.\n+     * <p>\n+     * If this method returns {@code true} then {@code dom.isDominatedBy(this)}\n+     * will return {@code false}. However, if this method returns {@code false} then it\n+     * does not imply {@code dom.isDominatedBy(this)} returns {@code true}, as neither\n+     * block may dominate the other.\n+     *\n+     * @param dom the dominating block\n+     * @return {@code true} if this block is dominated by the given block.\n+     *\/\n+    \/\/ @@@ Should this be reversed and named dominates(Block b)\n+    public boolean isDominatedBy(Block dom) {\n+        Block b = findBlockForDomBody(this, dom.parentBody());\n+        if (b == null) {\n+            return false;\n+        }\n+\n+        \/\/ A block non-strictly dominates itself\n+        if (b == dom) {\n+            return true;\n+        }\n+\n+        \/\/ The entry block in b's body dominates all other blocks in the body\n+        Block entry = b.parentBody().entryBlock();\n+        if (dom == entry) {\n+            return true;\n+        }\n+\n+        \/\/ Traverse the immediate dominators until dom is reached or the entry block\n+        Map<Block, Block> idoms = b.parentBody().immediateDominators();\n+        Block idom = idoms.get(b);\n+        while (idom != entry) {\n+            if (idom == dom) {\n+                return true;\n+            }\n+\n+            idom = idoms.get(idom);\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the immediate dominator of this block, otherwise {@code null} if this block is the entry block.\n+     * Both this block and the immediate dominator (if defined) have the same parent body.\n+     * <p>\n+     * The immediate dominator is the unique block that strictly dominates this block, but does not strictly dominate\n+     * any other block that strictly dominates this block.\n+     *\n+     * @return the immediate dominator of this block, otherwise {@code null} if this block is the entry block.\n+     *\/\n+    public Block immediateDominator() {\n+        if (this == parentBody().entryBlock()) {\n+            return null;\n+        }\n+\n+        Map<Block, Block> idoms = parentBody().immediateDominators();\n+        return idoms.get(this);\n+    }\n+\n+    \/\/ @@@ isPostDominatedBy and immediatePostDominator\n+\n+    private static Block findBlockForDomBody(Block b, final Body domr) {\n+        Body rb = b.parentBody();\n+        while (domr != rb) {\n+            \/\/ @@@ What if body is isolated\n+\n+            b = rb.parentOp().parentBlock();\n+            \/\/ null when op is top-level (and its body is isolated), or not yet assigned to block\n+            if (b == null) {\n+                return null;\n+            }\n+            rb = b.parentBody();\n+        }\n+        return b;\n+    }\n+\n+    \/**\n+     * A builder of a block.\n+     * <p>\n+     * When the parent body builder is built this block builder is also built. If a built builder\n+     * is operated on to append a block parameter, append an operation, or add a block, then\n+     * an {@code IllegalStateException} is thrown.\n+     *\/\n+    public final class Builder implements Function<Op, Op.Result> {\n+        final Body.Builder parentBody;\n+        final CopyContext cc;\n+        final OpTransformer ot;\n+\n+        Builder(Body.Builder parentBody, CopyContext cc, OpTransformer ot) {\n+            this.parentBody = parentBody;\n+            this.cc = cc;\n+            this.ot = ot;\n+        }\n+\n+        void check() {\n+            parentBody.check();\n+        }\n+\n+        Block target() {\n+            return Block.this;\n+        }\n+\n+        \/**\n+         * {@return the block builder's operation transformer}\n+         *\/\n+        public OpTransformer transformer() {\n+            return ot;\n+        }\n+\n+        \/**\n+         * {@return the block builder's context}\n+         *\/\n+        public CopyContext context() {\n+            return cc;\n+        }\n+\n+        \/**\n+         * {@return the parent body builder}\n+         *\/\n+        public Body.Builder parentBody() {\n+            return parentBody;\n+        }\n+\n+        \/**\n+         * Returns the entry block builder for parent body.\n+         *\n+         * <p>The returned block is rebound if necessary to this block builder's\n+         * context and transformer.\n+         *\n+         * @return the entry block builder for parent body builder\n+         *\/\n+        public Block.Builder entryBlock() {\n+            return parentBody.entryBlock.rebind(cc, ot);\n+        }\n+\n+        \/**\n+         * {@return true if this block builder is a builder of the entry block}\n+         *\/\n+        public boolean isEntryBlock() {\n+            return Block.this == parentBody.target().entryBlock();\n+        }\n+\n+        \/**\n+         * Rebinds this block builder with the given context and operation transformer.\n+         *\n+         * <p>Either this block builder and the returned block builder may be operated on to build\n+         * the same block.\n+         * Both are equal to each other, and both are closed when the parent body builder is closed.\n+         *\n+         * @param cc the context\n+         * @param ot the operation transformer\n+         * @return the rebound block builder\n+         *\/\n+        public Block.Builder rebind(CopyContext cc, OpTransformer ot) {\n+            return this.cc == cc && this.ot == ot\n+                    ? this\n+                    : this.target().new Builder(parentBody(), cc, ot);\n+        }\n+\n+        \/**\n+         * Adds a new block to the parent body.\n+         *\n+         * @param params the block's parameter types\n+         * @return the new block builder\n+         *\/\n+        public Block.Builder block(TypeElement... params) {\n+            return block(List.of(params));\n+        }\n+\n+        \/**\n+         * Adds a new block to the parent body.\n+         *\n+         * @param params the block's parameter types\n+         * @return the new block builder\n+         *\/\n+        public Block.Builder block(List<TypeElement> params) {\n+            return parentBody.block(params, cc, ot);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable list of the block's parameters.\n+         *\n+         * @return the unmodifiable list of the block's parameters\n+         *\/\n+        public List<Parameter> parameters() {\n+            return Collections.unmodifiableList(parameters);\n+        }\n+\n+        \/**\n+         * Appends a block parameter to the block's parameters.\n+         *\n+         * @param p the parameter type\n+         * @return the appended block parameter\n+         *\/\n+        public Parameter parameter(TypeElement p) {\n+            check();\n+            return appendBlockParameter(p);\n+        }\n+\n+        \/**\n+         * Creates a reference to this block that can be used as a successor of a terminating operation.\n+         *\n+         * @param args the block arguments\n+         * @return the reference to this block\n+         * @throws IllegalStateException if this block builder is associated with the entry block.\n+         *\/\n+        public Reference successor(Value... args) {\n+            return successor(List.of(args));\n+        }\n+\n+        \/**\n+         * Creates a reference to this block that can be used as a successor of a terminating operation.\n+         *\n+         * @param args the block arguments\n+         * @return the reference to this block\n+         * @throws IllegalStateException if this block builder is associated with the entry block.\n+         *\/\n+        public Reference successor(List<? extends Value> args) {\n+            if (isEntryBlock()) {\n+                throw new IllegalStateException(\"Entry block cannot be referred to as a successor\");\n+            }\n+\n+            return new Reference(Block.this, List.copyOf(args));\n+        }\n+\n+        \/**\n+         * An inline consumer that inserts a return operation with a value, if non-null.\n+         *\/\n+        public static final BiConsumer<Block.Builder, Value> INLINE_RETURN = (block, value) -> {\n+            block.op(value != null ? _return(value) : _return());\n+        };\n+\n+        \/**\n+         * Inlines the invokable operation into this block and returns the block builder from which to\n+         * continue building.\n+         * <p>\n+         * This method {@link #transformBody(Body, List, CopyContext, OpTransformer) transforms} the body of the\n+         * invokable operation with the given arguments, a new context, and an operation transformer that\n+         * replaces return operations by applying the given consumer to a block builder and a return value.\n+         * <p>\n+         * The operation transformer copies all operations except return operations whose nearest invokable operation\n+         * ancestor is the given the invokable operation. When such a return operation is encountered, then on\n+         * first encounter of its grandparent body a return block builder is computed and used for this return operation\n+         * and encounters of subsequent return operations with the same grandparent body.\n+         * <p>\n+         * If the grandparent body has only one block then operation transformer's block builder is the return\n+         * block builder. Otherwise, if the grandparent body has one or more blocks then the return block builder is\n+         * created from the operation transformer's block builder. The created return block builder will have a block\n+         * parameter whose type corresponds to the return type, or will have no parameter for void return.\n+         * The computation finishes by applying the return block builder and a return value to the inlining consumer.\n+         * If the grandparent body has only one block then the return value is the value mapped from the return\n+         * operation's operand, or is null for void return. Otherwise, if the grandparent body has one or more blocks\n+         * then the value is the block parameter of the created return block builder, or is null for void return.\n+         * <p>\n+         * For every encounter of a return operation the associated return block builder is compared against the\n+         * operation transformer's block builder. If they are not equal then a branch operation is added to the\n+         * operation transformer's block builder whose successor is the return block builder with a block argument\n+         * that is the value mapped from the return operation's operand, or with no block argument for void return.\n+         * @apiNote\n+         * It is easier to inline an invokable op if its body is in lowered form (there are no operations in the blocks\n+         * of the body that are lowerable). This ensures a single exit point can be created (paired with the single\n+         * entry point). If there are one or more nested return operations, then there is unlikely to be a single exit.\n+         * Transforming the model to create a single exit point while preserving nested structure is in general\n+         * non-trivial and outside the scope of this method. In such cases the invokable operation can be transformed\n+         * with a lowering transformation after which it can then be inlined.\n+         *\n+         * @param invokableOp the invokable operation\n+         * @param args the arguments to map to the invokable operation's parameters\n+         * @param inlineConsumer the consumer applied to process the return from the invokable operation.\n+         *                       This is called once for each grandparent body of a return operation, with a block to\n+         *                       build replacement operations and the return value, or null for void return.\n+         * @return the block builder to continue building from\n+         * @param <O> The invokable type\n+         *\/\n+        public <O extends Op & Op.Invokable> Block.Builder inline(O invokableOp, List<? extends Value> args,\n+                                                                  BiConsumer<Block.Builder, Value> inlineConsumer) {\n+            Map<Body, Block.Builder> returnBlocks = new HashMap<>();\n+            \/\/ Create new context, ensuring inlining is isolated\n+            transformBody(invokableOp.body(), args, CopyContext.create(), (block, op) -> {\n+                \/\/ If the return operation is associated with the invokable operation\n+                if (op instanceof CoreOps.ReturnOp rop && getNearestInvokeableAncestorOp(op) == invokableOp) {\n+                    \/\/ Compute the return block\n+                    Block.Builder returnBlock = returnBlocks.computeIfAbsent(rop.ancestorBody(), _body -> {\n+                        Block.Builder rb;\n+                        \/\/ If the body has one block we know there is just one return op declared, otherwise there may\n+                        \/\/ one or more. If so, create a new block that joins all the returns.\n+                        \/\/ Note: we could count all return op in a body to avoid creating a new block for a body\n+                        \/\/ with two or more blocks with only one returnOp is declared.\n+                        Value r;\n+                        if (rop.ancestorBody().blocks().size() != 1) {\n+                            List<TypeElement> param = rop.returnValue() != null\n+                                    ? List.of(invokableOp.invokableType().returnType())\n+                                    : List.of();\n+                            rb = block.block(param);\n+                            r = !param.isEmpty()\n+                                    ? rb.parameters().get(0)\n+                                    : null;\n+                        } else {\n+                            r = rop.returnValue() != null\n+                                    ? block.context().getValue(rop.returnValue())\n+                                    : null;\n+                            rb = block;\n+                        }\n+\n+                        \/\/ Inline the return\n+                        inlineConsumer.accept(rb, r);\n+\n+                        return rb;\n+                    });\n+\n+                    \/\/ Replace the return op with a branch to the return block, if needed\n+                    if (!returnBlock.equals(block)) {\n+                        \/\/ Replace return op with branch to return block, with given return value\n+                        List<Value> arg = rop.returnValue() != null\n+                                ? List.of(block.context().getValue(rop.returnValue()))\n+                                : List.of();\n+                        block.apply(branch(returnBlock.successor(arg)));\n+                    }\n+\n+                    return block;\n+                }\n+\n+                block.apply(op);\n+                return block;\n+            });\n+\n+\n+            Builder builder = returnBlocks.get(invokableOp.body());\n+            return builder != null ? builder : this;\n+        }\n+\n+        private static Op getNearestInvokeableAncestorOp(Op op) {\n+            do {\n+                op = op.ancestorBody().parentOp();\n+            } while (!(op instanceof Op.Invokable));\n+            return op;\n+        }\n+\n+        \/**\n+         * Transforms a body into this block, with this block builder's context.\n+         *\n+         * @param bodyToTransform the body to transform\n+         * @param args        the list of values to map to the parameters of the body's entry block\n+         * @param ot          the operation transformer\n+         * @see #transformBody(Body, List, CopyContext, OpTransformer)\n+         *\/\n+        public void transformBody(Body bodyToTransform, List<? extends Value> args,\n+                                  OpTransformer ot) {\n+            transformBody(bodyToTransform, args, cc, ot);\n+        }\n+\n+        \/**\n+         * Transforms a body into this block.\n+         * <p>\n+         * First, a new context is created from the given context and that new context is used to map values and\n+         * blocks.\n+         * <p>\n+         * Second, the entry block is mapped to this block builder rebound with the given operation transformer and\n+         * copy context, the input block parameters of the body's entry block are mapped to the given arguments.\n+         * <p>\n+         * Third, for each input block in the body (except the entry block) an output block builder is created with\n+         * equivalent parameters as the input block and with the given operation transformer and copy context.\n+         * The input block parameters are mapped to the output block parameters, and the input block is mapped to the\n+         * output block builder.\n+         * <p>\n+         * Fourth, for each input block in the body (in order) the input block's operations are transformed\n+         * by applying the output block builder and input block to the given operation transformer.\n+         * <p>\n+         * When the parent body is built any empty non-entry blocks that have no successors will be removed.\n+         *\n+         * @param bodyToTransform the body to transform\n+         * @param args            the list of values to map to the parameters of the body's entry block\n+         * @param cc              the copy context, for values captured in the body\n+         * @param ot              the operation transformer\n+         *\/\n+        public void transformBody(Body bodyToTransform, List<? extends Value> args,\n+                                  CopyContext cc, OpTransformer ot) {\n+            check();\n+\n+            \/\/ @@@ This might be a new context e.g., when transforming a body\n+            cc = CopyContext.create(cc);\n+\n+            Block entryBlockToTransform  = bodyToTransform.entryBlock();\n+            List<Block> blocksToTransform = bodyToTransform.blocks();\n+\n+            \/\/ Map entry block\n+            \/\/ Rebind this block builder to the created context and transformer\n+            Block.Builder startingBlock = rebind(cc, ot);\n+            cc.mapBlock(entryBlockToTransform, startingBlock);\n+            cc.mapValues(entryBlockToTransform.parameters(), args);\n+\n+            \/\/ Map subsequent blocks up front, for forward referencing successors\n+            for (int i = 1; i < blocksToTransform.size(); i++) {\n+                Block blockToTransform = blocksToTransform.get(i);\n+                if (cc.getBlock(blockToTransform) != null) {\n+                    throw new IllegalStateException(\"Block is already transformed\");\n+                }\n+\n+                \/\/ Create block and map block\n+                Block.Builder transformedBlock = startingBlock.block(List.of());\n+                for (Block.Parameter ba : blockToTransform.parameters()) {\n+                    transformedBlock.parameter(ba.type());\n+                }\n+                cc.mapBlock(blockToTransform, transformedBlock);\n+                cc.mapValues(blockToTransform.parameters(), transformedBlock.parameters());\n+            }\n+\n+            for (Block blockToTransform : blocksToTransform) {\n+                ot.apply(cc.getBlock(blockToTransform), blockToTransform);\n+            }\n+        }\n+\n+        \/**\n+         * Appends operations into the block builder in the scope of the builder as an argument\n+         * to the given consumer.\n+         *\n+         * @param c the consumer.\n+         *\/\n+        \/\/ @@@ Is this needed?\n+        public void ops(Consumer<Builder> c) {\n+            c.accept(this);\n+        }\n+\n+        \/**\n+         * Appends an operation to this block, with no operation result name, and this builder's transformer.\n+         *\n+         * @param op the operation to append\n+         * @return the operation result of the appended operation\n+         * @throws IllegalStateException if the operation is structurally invalid\n+         * @see #op(Op, OpTransformer)\n+         *\/\n+        @Override\n+        public Op.Result apply(Op op) {\n+            return op(op, ot);\n+        }\n+\n+        \/**\n+         * Appends an operation to this block, with no operation result name, and this builder's transformer.\n+         *\n+         * @param op the operation to append\n+         * @return the operation result of the appended operation\n+         * @throws IllegalStateException if the operation is structurally invalid\n+         * @see #op(Op, OpTransformer)\n+         *\/\n+        public Op.Result op(Op op) {\n+            return op(op, ot);\n+        }\n+\n+        \/**\n+         * Appends an operation to this block.\n+         * <p>\n+         * If the operation is not bound to a block, then the operation is appended and bound to this block.\n+         * Otherwise, if the operation is bound, the operation is first\n+         * {@link Op#transform(CopyContext, OpTransformer) transformed} with this builder's context and the given\n+         * operation transformer, the unbound transformed operation is appended, and the operation's result is mapped\n+         * to the transformed operation's result (using the builder's context).\n+         * <p>\n+         * If the unbound operation (transformed, or otherwise) is structurally invalid then an\n+         * {@code IllegalStateException} is thrown. An unbound operation is structurally invalid if:\n+         * <ul>\n+         * <li>any of its bodies does not have the same ancestor body as this block's parent body.\n+         * <li>any of its operands (values) is not reachable from this block.\n+         * <li>any of its successors is not a sibling of this block.\n+         * <li>any of its successors arguments (values) is not reachable from this block.\n+         * <\/ul>\n+         * A value is reachable from this block if there is a path from this block's parent body,\n+         * via its ancestor bodies, to the value's block's parent body. (Note this structural check\n+         * ensures values are only used from the same tree being built, but it is weaker than a\n+         * dominance check that may be performed when the parent body is built.)\n+         *\n+         * @param op the operation to append\n+         * @param transformer the transformer to use when appending a bound operation\n+         * @return the operation result of the appended operation\n+         * @throws IllegalStateException if the operation is structurally invalid\n+         *\/\n+        public Op.Result op(Op op, OpTransformer transformer) {\n+            check();\n+            final Op.Result oprToTransform = op.result();\n+\n+            Op transformedOp = op;\n+            if (oprToTransform != null) {\n+                \/\/ If operation is assigned to block, then copy it and transform its contents\n+                transformedOp = op.transform(cc, transformer);\n+                assert transformedOp.result == null;\n+            }\n+\n+            Op.Result transformedOpr = insertOp(transformedOp);\n+\n+            if (oprToTransform != null) {\n+                \/\/ Map the result of the first transformation\n+                \/\/ @@@ If the same operation is transformed more than once then subsequent\n+                \/\/  transformed ops will not get implicitly mapped\n+                \/\/  Should this be an error?\n+                cc.mapValueIfAbsent(oprToTransform, transformedOpr);\n+            }\n+\n+            return transformedOpr;\n+        }\n+\n+        \/**\n+         * Returns true if this block builder is equal to the other object.\n+         * <p>This block builder is equal if the other object is an instance of a block builder, and they are\n+         * associated with the same block (but perhaps bound to different contexts and transformers).\n+         *\n+         * @param o the other object\n+         * @return true if this builder is equal to the other object.\n+         *\/\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            return o instanceof Builder that && Block.this == that.target();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Block.this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Modifying methods\n+\n+    \/\/ Create block parameter associated with this block\n+    private Parameter appendBlockParameter(TypeElement type) {\n+        Parameter blockParameter = new Parameter(this, type);\n+        parameters.add(blockParameter);\n+\n+        return blockParameter;\n+    }\n+\n+    \/\/ Create an operation, adding to the end of the list of existing operations\n+    private Op.Result insertOp(Op op) {\n+        Op.Result opResult = new Op.Result(this, op);\n+        bindOp(opResult, op);\n+\n+        ops.add(op);\n+        return opResult;\n+    }\n+\n+    private void bindOp(Op.Result opr, Op op) {\n+        \/\/ Structural checks\n+        if (!ops.isEmpty() && ops.getLast() instanceof Op.Terminating) {\n+            throw new IllegalStateException(\"Operation cannot be appended, the block has a terminal operation\");\n+        }\n+\n+        for (Body b : op.bodies()) {\n+            if (b.ancestorBody != null && b.ancestorBody != this.parentBody) {\n+                throw new IllegalStateException(\"Body of operation is bound to a different ancestor body: \");\n+            }\n+        }\n+\n+        for (Value v : op.operands()) {\n+            if (!isReachable(v)) {\n+                throw new IllegalStateException(\n+                        String.format(\"Operand of operation %s is not defined in tree: %s\", op, v));\n+            }\n+            assert !v.isBound();\n+        }\n+\n+        for (Reference s : op.successors()) {\n+            if (s.target.parentBody != this.parentBody) {\n+                throw new IllegalStateException(\"Target of block reference is not a sibling of this block\");\n+            }\n+\n+            for (Value v : s.arguments()) {\n+                if (!isReachable(v)) {\n+                    throw new IllegalStateException(\n+                            String.format(\"Argument of block reference %s of terminating operation %s is not defined in tree: %s\", s, op, v));\n+                }\n+                assert !v.isBound();\n+            }\n+        }\n+\n+        \/\/ State updates after structural checks\n+        \/\/ @@@ The alternative is to close the body builder on failure, rendering it inoperable,\n+        \/\/ so checks and updates can be merged\n+        for (Value v : op.operands()) {\n+            v.uses.add(opr);\n+        }\n+\n+        for (Reference s : op.successors()) {\n+            for (Value v : s.arguments()) {\n+                v.uses.add(opr);\n+            }\n+\n+            s.target.predecessors.add(Block.this);\n+        }\n+\n+        op.result = opr;\n+    }\n+\n+    \/\/ Determine if the parent body of value's block is an ancestor of this block\n+    private boolean isReachable(Value v) {\n+        Body b = parentBody;\n+        while (b != null && b != v.block.parentBody) {\n+            b = b.ancestorBody;\n+        }\n+        return b != null;\n+    }\n+\n+    \/\/\n+\n+    boolean isBound() {\n+        return index >= 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Block.java","additions":957,"deletions":0,"binary":false,"changes":957,"status":"added"},{"patch":"@@ -0,0 +1,655 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.type.FunctionType;\n+import java.util.*;\n+\n+\/**\n+ * A body containing a sequence of (basic) blocks.\n+ * <p>\n+ * The sequence of blocks form a graph. The last operation in a block, a terminating operation,\n+ * may refer to other blocks in the sequence as successors, thus forming the graph. Otherwise, the last\n+ * operation defines how the body passes control flow back to the parent operation, and in doing so may optionally\n+ * yield a value.\n+ * <p>\n+ * The first block in the sequence is the entry block, and no other blocks refer to it as a successor.\n+ * <p>\n+ * A body has a function type whose return type is the body's yield type and whose parameter types are the entry\n+ * block's parameters types, in order.\n+ * The function type describes the sequence of input parameters types for arguments that are passed to the\n+ * body when control flow is passed to it, and describes the return type of values that are returned when body passes\n+ * control back to its parent operation.\n+ *\/\n+public final class Body implements CodeElement<Body, Block> {\n+    \/\/ Parent operation\n+    \/\/ Non-null when body is built, and therefore bound to operation\n+    Op parentOp;\n+\n+    \/\/ The ancestor body, when null the body is isolated and cannot refer to values defined outside\n+    \/\/ When non-null and body is built, ancestorBody == parentOp.result.block.parentBody\n+    final Body ancestorBody;\n+\n+    final TypeElement yieldType;\n+\n+    \/\/ Sorted in reverse postorder\n+    final List<Block> blocks;\n+\n+    \/\/ Map of a block to its immediate dominator\n+    \/\/ Computed lazily, null if not computed\n+    Map<Block, Block> idoms;\n+\n+    \/**\n+     * Constructs a body, whose ancestor is the given ancestor body.\n+     *\/\n+    Body(Body ancestorBody, TypeElement yieldType) {\n+        this.ancestorBody = ancestorBody;\n+        this.yieldType = yieldType;\n+        this.blocks = new ArrayList<>();\n+    }\n+\n+    \/**\n+     * Returns this body's parent operation.\n+     *\n+     * @return the body's parent operation.\n+     *\/\n+    @Override\n+    public Op parent() {\n+        return parentOp;\n+    }\n+\n+    \/**\n+     * Returns this body's parent operation.\n+     *\n+     * @return the body's parent operation.\n+     *\/\n+    public Op parentOp() {\n+        return parentOp;\n+    }\n+\n+    @Override\n+    public List<Block> children() {\n+        return blocks();\n+    }\n+\n+    \/**\n+     * Returns body's blocks in reverse-postorder as an unmodifiable list.\n+     *\n+     * @return the body's blocks in reverse-postorder.\n+     *\/\n+    public List<Block> blocks() {\n+        return Collections.unmodifiableList(blocks);\n+    }\n+\n+    \/**\n+     * {@return the yield type of this body}\n+     *\/\n+    public TypeElement yieldType() {\n+        return yieldType;\n+    }\n+\n+    \/**\n+     * Returns the body's function type.\n+     * <p>The function type is composed of the body's entry block parameter types and\n+     * the body's yield type.\n+     *\n+     * @return the body type.\n+     *\/\n+    public FunctionType bodyType() {\n+        Block entryBlock = entryBlock();\n+        return FunctionType.functionType(yieldType, entryBlock.parameterTypes());\n+    }\n+\n+    \/**\n+     * Finds the block in this body that is the ancestor of the given block.\n+     *\n+     * @param b the given block.\n+     * @return the block in this body that is the ancestor of the given block,\n+     * otherwise {@code null}\n+     *\/\n+    public Block findAncestorBlockInBody(Block b) {\n+        Objects.requireNonNull(b);\n+\n+        while (b != null && b.parentBody() != this) {\n+            b = b.parentBody().parentOp().parentBlock();\n+        }\n+\n+        return b;\n+    }\n+\n+    \/**\n+     * Returns this body's entry block.\n+     * <p>\n+     * The entry block is the first block in the sequence. No other blocks refer to it as a successor.\n+     *\n+     * @return the body's entry block\n+     *\/\n+    public Block entryBlock() {\n+        return blocks.getFirst();\n+    }\n+\n+    \/**\n+     * Returns a map of block to its immediate dominator.\n+     *\n+     * @return a map of block to its immediate dominator\n+     *\/\n+    public Map<Block, Block> immediateDominators() {\n+        \/*\n+         * Compute dominators of blocks in a body.\n+         * <p>\n+         * https:\/\/www.cs.rice.edu\/~keith\/EMBED\/dom.pdf\n+         * A Simple, Fast Dominance Algorithm\n+         * Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy\n+         *\/\n+\n+        if (idoms != null) {\n+            return idoms;\n+        }\n+\n+        Map<Block, Block> doms = idoms = new HashMap<>();\n+        doms.put(entryBlock(), entryBlock());\n+\n+        \/\/ Blocks are sorted in reverse postorder\n+        boolean changed;\n+        do {\n+            changed = false;\n+            \/\/ Iterate through blocks in reverse postorder, except for entry block\n+            for (int i = 1; i < blocks.size(); i++) {\n+                Block b = blocks.get(i);\n+\n+                \/\/ Find first processed predecessor of b\n+                Block newIdom = null;\n+                for (Block p : b.predecessors()) {\n+                    if (doms.containsKey(p)) {\n+                        newIdom = p;\n+                        break;\n+                    }\n+                }\n+                assert b.predecessors().isEmpty() || newIdom != null : b;\n+\n+                \/\/ For all other predecessors, p, of b\n+                for (Block p : b.predecessors()) {\n+                    if (p == newIdom) {\n+                        continue;\n+                    }\n+\n+                    if (doms.containsKey(p)) {\n+                        \/\/ If already calculated\n+                        newIdom = intersect(doms, p, newIdom);\n+                    }\n+                }\n+\n+                if (doms.get(b) != newIdom) {\n+                    doms.put(b, newIdom);\n+                    changed = true;\n+                }\n+            }\n+        } while (changed);\n+\n+        return doms;\n+    }\n+\n+    static Block intersect(Map<Block, Block> doms, Block b1, Block b2) {\n+        while (b1 != b2) {\n+            while (b1.index > b2.index) {\n+                b1 = doms.get(b1);\n+            }\n+\n+            while (b2.index > b1.index) {\n+                b2 = doms.get(b2);\n+            }\n+        }\n+\n+        return b1;\n+    }\n+\n+    \/**\n+     * Returns the dominance frontier of each block in the body.\n+     * <p>\n+     * The dominance frontier of block, {@code B} say, is the set of all blocks, {@code C} say,\n+     * such that {@code B} dominates a predecessor of {@code C} but does not strictly dominate\n+     * {@code C}.\n+     *\n+     * @return the dominance frontier of each block in the body\n+     *\/\n+    public Map<Block, Set<Block>> dominanceFrontier() {\n+        \/\/ @@@ cache result?\n+        Map<Block, Block> idoms = immediateDominators();\n+        Map<Block, Set<Block>> df = new HashMap<>();\n+\n+        for (Block b : blocks) {\n+            Set<Block> preds = b.predecessors();\n+\n+            if (preds.size() > 1) {\n+                for (Block p : preds) {\n+                    Block runner = p;\n+                    while (runner != idoms.get(b)) {\n+                        df.computeIfAbsent(runner, k -> new LinkedHashSet<>()).add(b);\n+                        runner = idoms.get(runner);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return df;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this body is dominated by the given body {@code dom}.\n+     * <p>\n+     * A body, {@code b} say, is dominated by {@code dom} if {@code b} is the same as {@code dom} or a descendant of\n+     * {@code dom}. Specifically, if {@code b} and {@code dom} are not equal then {@code b} becomes the nearest ancestor\n+     * body, the result of {@code b.parentOp().parentBlock().parentBody()}, and so on until either:\n+     * {@code b == dom}, therefore {@code b} is dominated by {@code dom} and this method returns {@code true};\n+     * or {@code b.parentOp().parentBlock() == null}, therefore {@code b} is <b>not<\/b> dominated\n+     * by {@code dom} and this method returns {@code false}.\n+     *\n+     * @param dom the dominating body\n+     * @return {@code true} if this body is dominated by the given body {@code dom}.\n+     *\/\n+    public boolean isDominatedBy(Body dom) {\n+        return isDominatedBy(this, dom);\n+    }\n+\n+    static boolean isDominatedBy(Body r, Body dom) {\n+        while (r != dom) {\n+            Block eb = r.parentOp().parentBlock();\n+            if (eb == null) {\n+                return false;\n+            }\n+\n+            r = eb.parentBody();\n+        }\n+\n+        return true;\n+    }\n+\n+    \/**\n+     * Computes values captured by this body. A captured value is a value that dominates\n+     * this body and is used by a descendant operation of this body.\n+     * <p>\n+     * The order of the captured values is first use encountered in depth\n+     * first search of this body's descendant operations.\n+     *\n+     * @return the list of captured values, modifiable\n+     *\/\n+    public List<Value> capturedValues() {\n+        Set<Value> cvs = new LinkedHashSet<>();\n+\n+        capturedValues(cvs, new ArrayDeque<>(), this);\n+        return new ArrayList<>(cvs);\n+    }\n+\n+    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Body body) {\n+        bodyStack.push(body);\n+\n+        for (Block b : body.blocks()) {\n+            for (Op op : b.ops()) {\n+                for (Body childBody : op.bodies()) {\n+                    capturedValues(capturedValues, bodyStack, childBody);\n+                }\n+\n+                for (Value a : op.operands()) {\n+                    if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                        capturedValues.add(a);\n+                    }\n+                }\n+\n+                for (Block.Reference s : op.successors()) {\n+                    for (Value a : s.arguments()) {\n+                        if (!bodyStack.contains(a.declaringBlock().parentBody())) {\n+                            capturedValues.add(a);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        bodyStack.pop();\n+    }\n+\n+    \/**\n+     * A builder of a body.\n+     * <p>\n+     * When the body builder is built any associated block builders are also considered built.\n+     *\/\n+    public final class Builder {\n+        \/**\n+         * Creates a body build with a new context, and a copying transformer.\n+         *\n+         * @param ancestorBody the nearest ancestor body builder\n+         * @param bodyType     the body's function type\n+         * @return the body builder\n+         * @throws IllegalStateException if the ancestor body builder is built\n+         * @see #of(Builder, FunctionType, CopyContext, OpTransformer)\n+         *\/\n+        public static Builder of(Builder ancestorBody, FunctionType bodyType) {\n+            \/\/ @@@ Creation of CopyContext\n+            return of(ancestorBody, bodyType, CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n+        }\n+\n+        \/**\n+         * Creates a body build with a copying transformer.\n+         *\n+         * @param ancestorBody the nearest ancestor body builder\n+         * @param bodyType     the body's function type\n+         * @param cc           the context\n+         * @return the body builder\n+         * @throws IllegalStateException if the ancestor body builder is built\n+         * @see #of(Builder, FunctionType, CopyContext, OpTransformer)\n+         *\/\n+        public static Builder of(Builder ancestorBody, FunctionType bodyType, CopyContext cc) {\n+            return of(ancestorBody, bodyType, cc, OpTransformer.COPYING_TRANSFORMER);\n+        }\n+\n+        \/**\n+         * Creates a body builder.\n+         * <p>\n+         * Structurally, the created body builder must be built before its ancestor body builder (if non-null) is built,\n+         * otherwise an {@code IllegalStateException} will occur.\n+         * <p>\n+         * A function type, referred to as the body type, defines the body's yield type and the initial sequence of\n+         * entry block parameters.\n+         * The body's yield type is the function type's return type.\n+         * An entry block builder is created with appended block parameters corresponding, in order, to\n+         * the function type's parameter types.\n+         * <p>\n+         * If the ancestor body is null then the created body builder is isolated and descendant operations may only\n+         * refer to values declared within the created body builder. Otherwise, operations\n+         * may refer to values declared in the ancestor body builders (outside the created body builder).\n+         *\n+         * @param ancestorBody the nearest ancestor body builder, may be null if isolated\n+         * @param bodyType     the body's function type\n+         * @param cc           the context\n+         * @param ot           the transformer\n+         * @return the body builder\n+         * @throws IllegalStateException if the ancestor body builder is built\n+         * @see #of(Builder, FunctionType, CopyContext, OpTransformer)\n+         *\/\n+        public static Builder of(Builder ancestorBody, FunctionType bodyType,\n+                                 CopyContext cc, OpTransformer ot) {\n+            Body body = new Body(ancestorBody != null ? ancestorBody.target() : null, bodyType.returnType());\n+            return body.new Builder(ancestorBody, bodyType, cc, ot);\n+        }\n+\n+        \/\/ The ancestor body, may be null\n+        final Builder ancestorBody;\n+\n+        \/\/ The entry block of this body, whose parameters are given by the body's function type\n+        final Block.Builder entryBlock;\n+\n+        \/\/ When non-null contains one or more great-grandchildren\n+        List<Builder> greatgrandchildren;\n+\n+        \/\/ True when built\n+        boolean closed;\n+\n+        Builder(Builder ancestorBody, FunctionType bodyType,\n+                CopyContext cc, OpTransformer ot) {\n+            \/\/ Structural check\n+            \/\/ The ancestor body should not be built before this body is created\n+            if (ancestorBody != null) {\n+                ancestorBody.check();\n+                ancestorBody.addGreatgrandchild(this);\n+            }\n+\n+            this.ancestorBody = ancestorBody;\n+            \/\/ Create entry block from the body's function type\n+            Block eb = Body.this.createBlock(bodyType.parameterTypes());\n+            this.entryBlock = eb.new Builder(this, cc, ot);\n+        }\n+\n+        void addGreatgrandchild(Builder greatgrandchild) {\n+            var l = greatgrandchildren == null\n+                    ? (greatgrandchildren = new ArrayList<>()) : greatgrandchildren;\n+            l.add(greatgrandchild);\n+        }\n+\n+        \/**\n+         * Builds the body and its blocks, associating the body with a parent operation.\n+         * <p>\n+         * Structurally, any descendant body builders must be built before this body builder is built,\n+         * otherwise an {@code IllegalStateException} will occur.\n+         * <p>\n+         * Blocks are sorted in reserve postorder.\n+         * <p>\n+         * Any unreferenced empty blocks are removed. An unreferenced block is a non-entry block with no predecessors.\n+         *\n+         * @param op the parent operation\n+         * @return the build body\n+         * @throws IllegalStateException if this body builder is built\n+         * @throws IllegalStateException if any descendant body builders are not built\n+         * @throws IllegalStateException if a block has no terminal operation, unless unreferenced and empty\n+         *\/\n+        \/\/ @@@ Validation\n+        \/\/ e.g., every operand dominates the operation result (potentially expensive)\n+        public Body build(Op op) {\n+            \/\/ Structural check\n+            \/\/ This body should not be closed\n+            check();\n+            closed = true;\n+\n+            \/\/ Structural check\n+            \/\/ All great-grandchildren bodies should be built\n+            if (greatgrandchildren != null) {\n+                for (Builder greatgrandchild : greatgrandchildren) {\n+                    if (!greatgrandchild.closed) {\n+                        throw new IllegalStateException(\"Descendant body builder is not built\");\n+                    }\n+                }\n+            }\n+\n+            Iterator<Block> i = blocks.iterator();\n+            while (i.hasNext()) {\n+                Block block = i.next();\n+\n+                \/\/ Structural check\n+                \/\/ All referenced blocks should have a terminating operation as the last operation\n+                if (block.ops.isEmpty()) {\n+                    if (block.isEntryBlock() || !block.predecessors.isEmpty()) {\n+                        throw noTerminatingOperation();\n+                    }\n+\n+                    \/\/ Remove unreferenced empty block\n+                    assert !block.isEntryBlock() && block.predecessors.isEmpty();\n+                    i.remove();\n+                } else if (!(block.ops.getLast() instanceof Op.Terminating)) {\n+                    throw noTerminatingOperation();\n+                }\n+            }\n+\n+            sortReversePostorder();\n+\n+            Body.this.parentOp = op;\n+            return Body.this;\n+        }\n+\n+        static IllegalStateException noTerminatingOperation() {\n+            return new IllegalStateException(\"Block has no terminating operation as the last operation\");\n+        }\n+\n+        \/**\n+         * Returns the body builder's function type.\n+         * <p>\n+         * The function type is composed of the body builder's yield type, as the function type's return type, and the\n+         * currently built entry block's parameter types, in order, as the function type's parameter types.\n+         *\n+         * @return the body builder's function type\n+         *\/\n+        public FunctionType bodyType() {\n+            TypeElement returnType = Body.this.yieldType();\n+            Block eb = Body.this.entryBlock();\n+            return FunctionType.functionType(returnType, eb.parameterTypes());\n+        }\n+\n+        \/**\n+         * {@return the body builder's nearest ancestor body builder}\n+         *\/\n+        public Builder ancestorBody() {\n+            return ancestorBody;\n+        }\n+\n+        \/**\n+         * {@return the body's entry block builder}\n+         *\/\n+        public Block.Builder entryBlock() {\n+            return entryBlock;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            return o instanceof Builder that && Body.this == that.target();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Body.this.hashCode();\n+        }\n+\n+        void check() {\n+            if (closed) {\n+                throw new IllegalStateException(\"Builder is closed\");\n+            }\n+        }\n+\n+        Body target() {\n+            return Body.this;\n+        }\n+\n+        \/\/ Build new block in body\n+        Block.Builder block(List<TypeElement> params, CopyContext cc, OpTransformer ot) {\n+            check();\n+            Block block = Body.this.createBlock(params);\n+\n+            return block.new Builder(this, cc, ot);\n+        }\n+    }\n+\n+    \/**\n+     * Copies the contents of this body.\n+     *\n+     * @param cc the copy context\n+     * @return the builder of a body containing the copied body\n+     * @see #transform(CopyContext, OpTransformer)\n+     *\/\n+    public Builder copy(CopyContext cc) {\n+        return transform(cc, OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Transforms this body.\n+     * <p>\n+     * A new body builder is created with the same function type as this body.\n+     * Then, this body is {@link Block.Builder#transformBody(Body, java.util.List, CopyContext, OpTransformer) transformed}\n+     * into the body builder's entry block builder with the given copy context, operation transformer, and values\n+     * that are the entry block's parameters.\n+     *\n+     * @param cc the copy context\n+     * @param ot the operation transformer\n+     * @return a body builder containing the transformed body\n+     *\/\n+    public Builder transform(CopyContext cc, OpTransformer ot) {\n+        Block.Builder ancestorBlockBuilder = ancestorBody != null\n+                ? cc.getBlock(ancestorBody.entryBlock()) : null;\n+        Builder ancestorBodyBuilder = ancestorBlockBuilder != null\n+                ? ancestorBlockBuilder.parentBody() : null;\n+        Builder body = Builder.of(ancestorBodyBuilder,\n+                \/\/ Create function type with just the return type and add parameters afterward\n+                FunctionType.functionType(yieldType),\n+                cc, ot);\n+\n+        for (Block.Parameter p : entryBlock().parameters()) {\n+            body.entryBlock.parameter(p.type());\n+        }\n+\n+        body.entryBlock.transformBody(this, body.entryBlock.parameters(), cc, ot);\n+        return body;\n+    }\n+\n+    \/\/ Sort blocks in reverse post order\n+    \/\/ After sorting the following holds for a block\n+    \/\/   block.parentBody().blocks().indexOf(block) == block.index()\n+    private void sortReversePostorder() {\n+        if (blocks.size() < 2) {\n+            for (int i = 0; i < blocks.size(); i++) {\n+                blocks.get(i).index = i;\n+            }\n+            return;\n+        }\n+\n+        \/\/ Reset block indexes\n+        \/\/ Also ensuring blocks with no predecessors occur last\n+        for (Block b : blocks) {\n+            b.index = Integer.MAX_VALUE;\n+        }\n+\n+        Deque<Block> stack = new ArrayDeque<>();\n+        stack.push(blocks.get(0));\n+\n+        \/\/ Postorder iteration\n+        int index = blocks.size();\n+        while (!stack.isEmpty()) {\n+            Block n = stack.peek();\n+            if (n.index == Integer.MIN_VALUE) {\n+                \/\/ If n's successor has been processed then add n\n+                stack.pop();\n+                n.index = --index;\n+            } else if (n.index < Integer.MAX_VALUE) {\n+                \/\/ If n has already been processed then ignore\n+                stack.pop();\n+            } else {\n+                \/\/ Mark before processing successors, a successor may refer back to n\n+                n.index = Integer.MIN_VALUE;\n+                for (Block.Reference s : n.successors()) {\n+                    if (s.target.index < Integer.MAX_VALUE) {\n+                        continue;\n+                    }\n+\n+                    stack.push(s.target);\n+                }\n+            }\n+        }\n+\n+        blocks.sort(Comparator.comparingInt(b -> b.index));\n+        if (blocks.get(0).index > 0) {\n+            \/\/ There are blocks with no predecessors\n+            \/\/ Reassign indexes to their natural indexes, sort order is preserved\n+            for (int i = 0; i < blocks.size(); i++) {\n+                blocks.get(i).index = i;\n+            }\n+        }\n+    }\n+\n+    \/\/ Modifying methods\n+\n+    \/\/ Create block\n+    private Block createBlock(List<TypeElement> params) {\n+        Block b = new Block(this, params);\n+        blocks.add(b);\n+        return b;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","additions":655,"deletions":0,"binary":false,"changes":655,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A code element, one of {@link Body body}, {@link Block block}, or {@link Op operation}.\n+ * <p>\n+ * A code element may have child code elements, and so on, to form a tree. A (root) code element and all its descendants\n+ * can be traversed.\n+ *\n+ * @param <E> the code element type\n+ * @param <C> the child code element type.\n+ *\/\n+\/\/ @@@ E may not be needed\n+public sealed interface CodeElement<\n+        E extends CodeElement<E, C>,\n+        C extends CodeElement<C, ?>>\n+        extends CodeItem\n+        permits Body, Block, Op {\n+\n+    \/**\n+     * {@return a stream of code elements sorted topologically in pre-order traversal.}\n+     *\/\n+    \/\/ Code copied into the compiler cannot depend on new gatherer API\n+    default Stream<CodeElement<?, ?>> elements() {\n+\/*__throw new UnsupportedOperationException();__*\/        return Stream.of(Void.class).gather(() -> (_, _, downstream) -> traversePreOrder(downstream::push));\n+    }\n+\n+\/\/    private boolean traversePreOrder(Gatherer.Downstream<? super CodeElement<?, ?>> v) {\n+    private boolean traversePreOrder(Predicate<? super CodeElement<?, ?>> v) {\n+        if (!v.test(this)) {\n+            return false;\n+        }\n+        for (C c : children()) {\n+            if (!((CodeElement<?, ?>) c).traversePreOrder(v)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Traverses this code element and any descendant code elements.\n+     * <p>\n+     * Traversal is performed in pre-order, reporting each code element to the visitor.\n+     *\n+     * @param t   the traversing accumulator\n+     * @param v   the code element visitor\n+     * @param <T> accumulator type\n+     * @return the traversing accumulator\n+     *\/\n+    default <T> T traverse(T t, BiFunction<T, CodeElement<?, ?>, T> v) {\n+        t = v.apply(t, this);\n+        for (C r : children()) {\n+            t = r.traverse(t, v);\n+        }\n+\n+        return t;\n+    }\n+\n+    \/**\n+     * Creates a visiting function for bodies.\n+     *\n+     * @param v   the body visitor\n+     * @param <T> accumulator type\n+     * @return the visiting function for bodies\n+     *\/\n+    static <T> BiFunction<T, CodeElement<?, ?>, T> bodyVisitor(BiFunction<T, Body, T> v) {\n+        return (t, e) -> e instanceof Body f\n+                ? v.apply(t, f)\n+                : t;\n+    }\n+\n+    \/**\n+     * Creates a visiting function for blocks.\n+     *\n+     * @param v   the block visitor\n+     * @param <T> accumulator type\n+     * @return the visiting function for blocks\n+     *\/\n+    static <T> BiFunction<T, CodeElement<?, ?>, T> blockVisitor(BiFunction<T, Block, T> v) {\n+        return (t, e) -> e instanceof Block f\n+                ? v.apply(t, f)\n+                : t;\n+    }\n+\n+    \/**\n+     * Creates a visiting function for operations.\n+     *\n+     * @param v   the operation visitor\n+     * @param <T> accumulator type\n+     * @return the visiting function for operations\n+     *\/\n+    static <T> BiFunction<T, CodeElement<?, ?>, T> opVisitor(BiFunction<T, Op, T> v) {\n+        return (t, e) -> e instanceof Op f\n+                ? v.apply(t, f)\n+                : t;\n+    }\n+\n+    \/**\n+     * Returns the parent code element.\n+     * <p>\n+     * If this element is an instance of {@code Op} then the parent may be {@code null}\n+     * if operation is not assigned to a block.\n+     *\n+     * @return the parent code element\n+     *\/\n+    CodeElement<?, E> parent();\n+\n+    \/**\n+     * Returns the child code elements, as an unmodifiable list.\n+     *\n+     * @return the child code elements\n+     *\/\n+    List<C> children();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeElement.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+package java.lang.reflect.code;\n+\n+\/**\n+ * A code item, one of {@link CodeElement}, {@link Value}, or {@link TypeElement}.\n+ *\/\n+public sealed interface CodeItem\n+        permits CodeElement, Value, TypeElement {\n+    \/\/ @@@ Common functionality between elements and values?\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CodeItem.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+\/**\n+ * A context utilized when transforming code models.\n+ * <p>\n+ * The context holds a mapping of input values to output values, input blocks to output block builders,\n+ * and input block references to output block references.\n+ * These mappings are built as an input model is transformed to produce an output model. Mappings are built implicitly\n+ * when an operation is transformed by copying, and can be explicitly added by the transformation when removing or\n+ * adding new operations.\n+ * <p>\n+ * Unless otherwise specified the passing of a {@code null} argument to the methods of this interface results in a\n+ * {@code NullPointerException}.\n+ *\/\n+public sealed interface CopyContext permits CopyContextImpl {\n+\n+    \/\/ @@@ ?\n+    \/\/ CopyContext parent();\n+\n+\n+    \/\/ Value mappings\n+\n+    \/**\n+     * {@return the output value mapped to the input value}\n+     * <p>\n+     * If this context is not isolated and there is no value mapping in this context then this method will return\n+     * the result of calling {@code getValue} on the parent context, if present. Otherwise if this context is isolated\n+     * or there is no parent context, then there is no mapping.\n+     *\n+     * @param input the input value\n+     * @throws IllegalArgumentException if there is no mapping\n+     *\/\n+    Value getValue(Value input);\n+\n+    \/**\n+     * {@return the output value mapped to the input value or a default value if no mapping}\n+     *\n+     * @param input the input value\n+     * @param defaultValue the default value to return if no mapping\n+     *\/\n+    Value getValueOrDefault(Value input, Value defaultValue);\n+\n+    \/**\n+     * Maps an input value to an output value.\n+     * <p>\n+     * Uses of the input value will be mapped to the output value when transforming.\n+     *\n+     * @param input the input value\n+     * @param output the output value\n+     * @throws IllegalArgumentException if the output value is already bound\n+     *\/\n+    void mapValue(Value input, Value output);\n+\n+    \/**\n+     * Maps an input value to an output value, if no such mapping exists.\n+     * <p>\n+     * Uses of the input value will be mapped to the output value when transforming.\n+     *\n+     * @param input the input value\n+     * @param output the output value\n+     * @return the previous mapped value, or null of there was no mapping.\n+     * @throws IllegalArgumentException if the output value is already bound\n+     *\/\n+    \/\/ @@@ Is this needed?\n+    Value mapValueIfAbsent(Value input, Value output);\n+\n+    \/**\n+     * Returns a list of mapped output values by obtaining, in order, the output value for each element in the list\n+     * of input values.\n+     *\n+     * @param inputs the list of input values\n+     * @return a modifiable list of output values\n+     * @throws IllegalArgumentException if an input value has no mapping\n+     *\/\n+    \/\/ @@@ If getValue is modified to return null then this method should fail on null\n+    default List<Value> getValues(List<? extends Value> inputs) {\n+        return inputs.stream().map(this::getValue).collect(toList());\n+    }\n+\n+    \/**\n+     * Maps the list of input values, in order, to the corresponding list of output values, up to the number of\n+     * elements that is the minimum of the size of both lists.\n+     * <p>\n+     * Uses of an input value will be mapped to the corresponding output value when transforming.\n+     *\n+     * @param inputs the input values\n+     * @param outputs the output values.\n+     * @throws IllegalArgumentException if an output value is already bound\n+     *\/\n+    default void mapValues(List<? extends Value> inputs, List<? extends Value> outputs) {\n+        \/\/ @@@ sizes should be the same?\n+        for (int i = 0; i < Math.min(inputs.size(), outputs.size()); i++) {\n+            mapValue(inputs.get(i), outputs.get(i));\n+        }\n+    }\n+\n+\n+    \/\/ Block mappings\n+\n+    \/**\n+     * {@return the output block builder mapped to the input block, otherwise null if no mapping}\n+     *\n+     * @param input the input block\n+     *\/\n+    Block.Builder getBlock(Block input);\n+\n+    \/**\n+     * Maps an input block to an output block builder.\n+     * <p>\n+     * Uses of the input block will be mapped to the output block builder when transforming.\n+     *\n+     * @param input the input block\n+     * @param output the output block builder\n+     * @throws IllegalArgumentException if the output block is already bound\n+     *\/\n+    void mapBlock(Block input, Block.Builder output);\n+\n+\n+    \/\/ Successor mappings\n+\n+    \/**\n+     * {@return the output block reference mapped to the input block reference,\n+     * otherwise null if no mapping}\n+     *\n+     * @param input the input reference\n+     *\/\n+    Block.Reference getSuccessor(Block.Reference input);\n+\n+    \/**\n+     * Maps an input block reference to an output block reference.\n+     * <p>\n+     * Uses of the input block reference will be mapped to the output block reference when transforming.\n+     *\n+     * @param input the input block reference\n+     * @param output the output block reference\n+     * @throws IllegalArgumentException if the output block builder associated with the block reference or any of its\n+     * argument values are already bound\n+     *\/\n+    void mapSuccessor(Block.Reference input, Block.Reference output);\n+\n+    \/**\n+     * Returns a mapped output block reference, if present, otherwise creates a new, unmapped, reference from the input\n+     * block reference.\n+     * <p>\n+     * A new, unmapped reference, is created by obtaining the mapped output block builder from the input reference's\n+     * target block, and creating a successor from the output block builder with arguments that is the result of\n+     * obtaining the mapped values from the input reference's arguments.\n+     *\n+     * @param input the input block reference\n+     * @return the output block reference, if present, otherwise a created block reference\n+     * @throws IllegalArgumentException if a new reference is to be created and there is no mapped output block builder\n+     *\/\n+    default Block.Reference getSuccessorOrCreate(Block.Reference input) {\n+        Block.Reference successor = getSuccessor(input);\n+        if (successor != null) {\n+            return successor;\n+        }\n+\n+        \/\/ Create successor\n+        Block.Builder outputBlock = getBlock(input.targetBlock());\n+        if (outputBlock == null) {\n+            throw new IllegalArgumentException(\"No mapping for input reference target block\" + input.targetBlock());\n+        }\n+        return outputBlock.successor(getValues(input.arguments()));\n+    }\n+\n+\n+    \/\/ Properties mappings\n+\n+    \/**\n+     * {@return an object associated with a property key}\n+     *\n+     * @param key the property key\n+     *\/\n+    Object getProperty(Object key);\n+\n+    \/**\n+     * Associates an object with a property key.\n+     *\n+     * @param key the property key\n+     * @param value the associated object\n+     * @return the current associated object, or null if not associated\n+     *\/\n+    Object putProperty(Object key, Object value);\n+\n+    \/**\n+     * If the property key is not already associated with an object, attempts to compute the object using the\n+     * mapping function and associates it unless {@code null}.\n+     *\n+     * @param key the property key\n+     * @param mappingFunction the mapping function\n+     * @return the current (existing or computed) object associated with the property key,\n+     * or null if the computed object is null\n+     *\/\n+    Object computePropertyIfAbsent(Object key, Function<Object, Object> mappingFunction);\n+\n+\n+    \/\/ Factories\n+\n+    \/**\n+     * {@return a new isolated context initialized with no mappings and no parent }\n+     *\/\n+    static CopyContext create() {\n+        return new CopyContextImpl(null);\n+    }\n+\n+    \/**\n+     * {@return a new non-isolated context initialized with no mappings and a parent }\n+     * The returned context will query value and property mappings in the parent context\n+     * if a query of its value and property mappings yields no result.\n+     *\/\n+    static CopyContext create(CopyContext parent) {\n+        return new CopyContextImpl((CopyContextImpl) parent);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CopyContext.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+final class CopyContextImpl implements CopyContext {\n+\n+    private static final Map<?, ?> EMPTY_MAP = Map.of();\n+\n+    final CopyContextImpl parent;\n+\n+    Map<Value, Value> valueMap;\n+    Map<Block, Block.Builder> blockMap;\n+    Map<Block.Reference, Block.Reference> successorMap;\n+    Map<Object, Object> propertiesMap;\n+\n+    CopyContextImpl(CopyContextImpl that) {\n+        this.parent = that;\n+        this.blockMap = emptyMap();\n+        this.valueMap = emptyMap();\n+        this.successorMap = emptyMap();\n+        this.propertiesMap = emptyMap();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <K, V> Map<K, V> emptyMap() {\n+        return (Map<K, V>) EMPTY_MAP;\n+    }\n+\n+\n+    \/\/ Values\n+\n+    @Override\n+    public Value getValue(Value input) {\n+        Value output = getValueOrNull(input);\n+        if (output != null) {\n+            return output;\n+        }\n+        throw new IllegalArgumentException(\"No mapping for input value: \" + input);\n+    }\n+\n+    @Override\n+    public Value getValueOrDefault(Value input, Value defaultValue) {\n+        Value output = getValueOrNull(input);\n+        if (output != null) {\n+            return output;\n+        }\n+        return defaultValue;\n+    }\n+\n+    private Value getValueOrNull(Value input) {\n+        Objects.requireNonNull(input);\n+\n+        CopyContextImpl p = this;\n+        do {\n+            Value output = p.valueMap.get(input);\n+            if (output != null) {\n+                return output;\n+            }\n+            p = p.parent;\n+        } while (p != null);\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public void mapValue(Value input, Value output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.isBound()) {\n+            throw new IllegalArgumentException(\"Output value bound: \" + output);\n+        }\n+\n+        if (valueMap == EMPTY_MAP) {\n+            valueMap = new HashMap<>();\n+        }\n+        valueMap.put(input, output);\n+    }\n+\n+    @Override\n+    public Value mapValueIfAbsent(Value input, Value output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.isBound()) {\n+            throw new IllegalArgumentException(\"Output value is bound: \" + output);\n+        }\n+\n+        if (valueMap == EMPTY_MAP) {\n+            valueMap = new HashMap<>();\n+        }\n+        return valueMap.putIfAbsent(input, output);\n+    }\n+\n+\n+    \/\/ Blocks\n+\n+    @Override\n+    public Block.Builder getBlock(Block input) {\n+        Objects.requireNonNull(input);\n+\n+        return blockMap.get(input);\n+    }\n+\n+    @Override\n+    public void mapBlock(Block input, Block.Builder output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.target().isBound()) {\n+            throw new IllegalArgumentException(\"Output block builder is built: \" + output);\n+        }\n+\n+        if (blockMap == EMPTY_MAP) {\n+            blockMap = new HashMap<>();\n+        }\n+        blockMap.put(input, output);\n+    }\n+\n+\n+    \/\/ Successors\n+\n+    @Override\n+    public Block.Reference getSuccessor(Block.Reference input) {\n+        Objects.requireNonNull(input);\n+\n+        return successorMap.get(input);\n+    }\n+\n+    @Override\n+    public void mapSuccessor(Block.Reference input, Block.Reference output) {\n+        Objects.requireNonNull(input);\n+        Objects.requireNonNull(output);\n+\n+        if (output.target.isBound()) {\n+            throw new IllegalArgumentException(\"Output block reference target is built: \" + output);\n+        }\n+\n+        for (Value outputArgument : output.arguments()) {\n+            if (outputArgument.isBound()) {\n+                throw new IllegalArgumentException(\"Output block reference argument is bound: \" + outputArgument);\n+            }\n+        }\n+\n+        if (successorMap == EMPTY_MAP) {\n+            successorMap = new HashMap<>();\n+        }\n+        successorMap.put(input, output);\n+    }\n+\n+\n+    \/\/ Properties\n+\n+    @Override\n+    public Object getProperty(Object key) {\n+        CopyContextImpl p = this;\n+        do {\n+            Object value = p.propertiesMap.get(key);\n+            if (value != null) {\n+                return value;\n+            }\n+            p = p.parent;\n+        } while (p != null);\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Object putProperty(Object key, Object value) {\n+        if (propertiesMap == EMPTY_MAP) {\n+            propertiesMap = new HashMap<>();\n+        }\n+        return propertiesMap.put(key, value);\n+    }\n+\n+    @Override\n+    public Object computePropertyIfAbsent(Object key, Function<Object, Object> mappingFunction) {\n+        if (propertiesMap == EMPTY_MAP) {\n+            propertiesMap = new HashMap<>();\n+        }\n+        Object value = getProperty(key);\n+        if (value != null) {\n+            return value;\n+        }\n+        propertiesMap.put(key, value = mappingFunction.apply(key));\n+        return value;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/CopyContextImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+package java.lang.reflect.code;\n+\n+\/**\n+ * Source location information.\n+ *\n+ * @param sourceRef the reference to the source\n+ * @param line the line in the source\n+ * @param column the column in the source\n+ *\/\n+public record Location(String sourceRef, int line, int column) {\n+\n+    \/**\n+     * The location value, {@code null}, indicating no location information.\n+     *\/\n+    public static final Location NO_LOCATION = null;\n+\n+    public Location(int line, int column) {\n+        this(null, line, column);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder s = new StringBuilder();\n+        s.append(line).append(\":\").append(column);\n+        if (sourceRef != null) {\n+            s.append(\":\").append(sourceRef);\n+        }\n+        return s.toString();\n+    }\n+\n+    public static Location fromString(String s) {\n+        String[] split = s.split(\":\", 3);\n+        if (split.length < 2) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        int line = Integer.parseInt(split[0]);\n+        int column = Integer.parseInt(split[1]);\n+        String sourceRef;\n+        if (split.length == 3) {\n+            sourceRef = split[2];\n+        } else {\n+            sourceRef = null;\n+        }\n+        return new Location(sourceRef, line, column);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Location.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,473 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * An operation modelling a unit of functionality.\n+ * <p>\n+ * An operation might model the addition of two 32-bit integers, or a Java method call.\n+ * Alternatively an operation may model something more complex like method bodies, lambda bodies, or\n+ * try\/catch\/finally statements. In this case such an operation will contain one or more bodies modelling\n+ * the nested structure.\n+ *\/\n+public non-sealed abstract class Op implements CodeElement<Op, Body> {\n+\n+    \/**\n+     * An operation characteristic indicating the operation is pure and has no side effects.\n+     *\/\n+    public interface Pure {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation has one or more bodies.\n+     *\/\n+    public interface Nested {\n+        List<Body> bodies();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation represents a loop\n+     *\/\n+    public interface Loop extends Nested {\n+        Body loopBody();\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation has one or more bodies,\n+     * all of which are isolated.\n+     *\/\n+    public interface Isolated extends Nested {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is invokable, so the operation may be interpreted\n+     * or compiled.\n+     *\/\n+    public interface Invokable extends Nested {\n+        \/**\n+         * {@return the body of the invokable operation.}\n+         *\/\n+        Body body();\n+\n+        \/**\n+         * {@return the function type describing the invokable operation's parameter types and return type.}\n+         *\/\n+        FunctionType invokableType();\n+\n+        \/**\n+         * {@return the entry block parameters of this operation's body}\n+         *\/\n+        default List<Block.Parameter> parameters() {\n+            return body().entryBlock().parameters();\n+        }\n+\n+        \/**\n+         * Computes values captured by this invokable operation's body.\n+         *\n+         * @return the captured values.\n+         * @see Body#capturedValues()\n+         *\/\n+        default List<Value> capturedValues() {\n+            return List.of();\n+        }\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation can replace itself with a lowered form,\n+     * consisting only of operations in the core dialect.\n+     *\/\n+    public interface Lowerable {\n+        default Block.Builder lower(Block.Builder b) {\n+            return lower(b, OpTransformer.NOOP_TRANSFORMER);\n+        }\n+\n+        Block.Builder lower(Block.Builder b, OpTransformer opT);\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * A terminating operation passes control to either another block within the same parent body\n+     * or to that parent body.\n+     *\/\n+    public interface Terminating {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a body terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * A body terminating operation passes control back to its nearest ancestor body.\n+     *\/\n+    public interface BodyTerminating extends Terminating {\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation is a block terminating operation\n+     * occurring as the last operation in a block.\n+     * <p>\n+     * The operation has one or more successors to other blocks within the same parent body, and passes\n+     * control to one of those blocks.\n+     *\/\n+    public interface BlockTerminating extends Terminating {\n+        List<Block.Reference> successors();\n+    }\n+\n+    \/**\n+     * A value that is the result of an operation.\n+     *\/\n+    public static final class Result extends Value {\n+        final Op op;\n+\n+        Result(Block block, Op op) {\n+            super(block, op.resultType());\n+\n+            this.op = op;\n+        }\n+\n+        @Override\n+        public Set<Value> dependsOn() {\n+            Set<Value> depends = new LinkedHashSet<>(op.operands());\n+            if (op instanceof Terminating) {\n+                op.successors().stream().flatMap(h -> h.arguments().stream()).forEach(depends::add);\n+            }\n+\n+            return Collections.unmodifiableSet(depends);\n+        }\n+\n+        \/**\n+         * Returns the result's operation.\n+         *\n+         * @return the result's operation.\n+         *\/\n+        public Op op() {\n+            return op;\n+        }\n+    }\n+\n+    \/\/ Set when op is bound to block, otherwise null when unbound\n+    Result result;\n+\n+    \/\/ null if not specified\n+    Location location;\n+\n+    final String name;\n+\n+    final List<Value> operands;\n+\n+    \/**\n+     * Constructs an operation by copying given operation.\n+     *\n+     * @param that the operation to copy.\n+     * @param cc   the copy context.\n+     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n+     * values computed, in order, by mapping the operation's operands using the copy context.\n+     *\/\n+    protected Op(Op that, CopyContext cc) {\n+        this(that.name, cc.getValues(that.operands));\n+        this.location = that.location;\n+    }\n+\n+    \/**\n+     * Copies this operation and its bodies, if any.\n+     * <p>\n+     * The returned operation is structurally identical to this operation and is otherwise independent\n+     * of the values declared and used.\n+     *\n+     * @return the copied operation.\n+     *\/\n+    public Op copy() {\n+        return transform(CopyContext.create(), OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Copies this operation and its bodies, if any.\n+     * <p>\n+     * The returned operation is structurally identical to this operation and is otherwise independent\n+     * of the values declared and used.\n+     *\n+     * @param cc the copy context.\n+     * @return the copied operation.\n+     *\/\n+    public Op copy(CopyContext cc) {\n+        return transform(cc, OpTransformer.COPYING_TRANSFORMER);\n+    }\n+\n+    \/**\n+     * Copies this operation and transforms its bodies, if any.\n+     * <p>\n+     * Bodies are {@link Body#transform(CopyContext, OpTransformer) transformed} with the given copy context and\n+     * operation transformer.\n+     *\n+     * @param cc the copy context.\n+     * @param ot the operation transformer.\n+     * @return the transformed operation.\n+     *\/\n+    public abstract Op transform(CopyContext cc, OpTransformer ot);\n+\n+    \/**\n+     * Constructs an operation with a name and list of operands.\n+     *\n+     * @param name       the operation name.\n+     * @param operands   the list of operands, a copy of the list is performed if required.\n+     *\/\n+    protected Op(String name, List<? extends Value> operands) {\n+        this.name = name;\n+        this.operands = List.copyOf(operands);\n+    }\n+\n+    \/**\n+     * Sets the originating source location of this operation, if unbound.\n+     *\n+     * @param l the location, the {@link Location#NO_LOCATION} value indicates the location is not specified.\n+     * @throws IllegalStateException if this operation is bound\n+     *\/\n+    public final void setLocation(Location l) {\n+        \/\/ @@@ Fail if location != null?\n+        if (result != null && result.block.isBound()) {\n+            throw new IllegalStateException();\n+        }\n+\n+        location = l;\n+    }\n+\n+    \/**\n+     * {@return the originating source location of this operation, otherwise {@code null} if not specified}\n+     *\/\n+    public final Location location() {\n+        return location;\n+    }\n+\n+    \/**\n+     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    @Override\n+    public final Block parent() {\n+        return parentBlock();\n+    }\n+\n+    \/**\n+     * Returns this operation's parent block, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's parent block, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    public final Block parentBlock() {\n+        if (result == null) {\n+            return null;\n+        }\n+\n+        if (!result.block.isBound()) {\n+            throw new IllegalStateException(\"Parent block is partially constructed\");\n+        }\n+\n+        return result.block;\n+    }\n+\n+    @Override\n+    public final List<Body> children() {\n+        return bodies();\n+    }\n+\n+    \/**\n+     * {@return the operation's bodies, as an unmodifiable list}\n+     * @implSpec this implementation returns an unmodifiable empty list.\n+     *\/\n+    public List<Body> bodies() {\n+        return List.of();\n+    }\n+\n+    \/**\n+     * Returns the operation's result, otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return the operation's result, or {@code null} if not assigned to a block.\n+     *\/\n+    public final Result result() {\n+        return result;\n+    }\n+\n+\n+    \/**\n+     * Returns this operation's nearest ancestor body (the parent body of this operation's parent block),\n+     * otherwise {@code null} if the operation is not assigned to a block.\n+     *\n+     * @return operation's nearest ancestor body, or {@code null} if the operation is not assigned to a block.\n+     *\/\n+    public final Body ancestorBody() {\n+        if (result == null) {\n+            return null;\n+        }\n+\n+        if (!result.block.isBound()) {\n+            throw new IllegalStateException(\"Parent body is partially constructed\");\n+        }\n+\n+        return result.block.parentBody;\n+    }\n+\n+    \/**\n+     * {@return the operation name}\n+     *\/\n+    public String opName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * {@return the operation's operands, as an unmodifiable list}\n+     *\/\n+    public List<Value> operands() {\n+        return operands;\n+    }\n+\n+    \/**\n+     * {@return the operation's successors, as an unmodifiable list}\n+     *\/\n+    public List<Block.Reference> successors() {\n+        return List.of();\n+    }\n+\n+    \/**\n+     * The attribute value that represents null.\n+     *\/\n+    public static final Object NULL_ATTRIBUTE_VALUE = new Object();\n+\n+    \/**\n+     * Returns the operation's attributes.\n+     *\n+     * <p>A null attribute value is represented by the constant value {@link #NULL_ATTRIBUTE_VALUE}.\n+     *\n+     * @return the operation's attributes, as an unmodifiable map\n+     *\/\n+    public Map<String, Object> attributes() {\n+        return Map.of();\n+    }\n+\n+    \/**\n+     * {@return the operation's result type}\n+     *\/\n+    public abstract TypeElement resultType();\n+\n+    \/**\n+     * Returns the operation's function type.\n+     * <p>\n+     * The function type's result type is the operation's result type and the function type's parameter types are the\n+     * operation's operand types, in order.\n+     *\n+     * @return the function type\n+     *\/\n+    public FunctionType opType() {\n+        List<TypeElement> operandTypes = operands.stream().map(Value::type).toList();\n+        return FunctionType.functionType(resultType(), operandTypes);\n+    }\n+\n+    \/**\n+     * Traverse the operands of this operation that are the results of prior operations, recursively.\n+     * <p>\n+     * Traversal is performed in pre-order, reporting the operation of each operand to the visitor.\n+     *\n+     * @param t   the traversing accumulator\n+     * @param v   the visitor\n+     * @param <T> accumulator type\n+     * @return the traversing accumulator\n+     * @apiNote A visitor that implements the abstract method of {@code OpVisitor} and does not override any\n+     * other default method will only visit operations. As such a lambda expression or method reference\n+     * may be used to visit operations.\n+     *\/\n+    public final <T> T traverseOperands(T t, BiFunction<T, Op, T> v) {\n+        for (Value arg : operands()) {\n+            if (arg instanceof Result or) {\n+                t = v.apply(t, or.op);\n+                t = or.op.traverseOperands(t, v);\n+            }\n+        }\n+\n+        return t;\n+    }\n+\n+    \/**\n+     * Computes values captured by this operation. A captured value is a value that dominates\n+     * this operation and is used by a descendant operation.\n+     * <p>\n+     * The order of the captured values is first use encountered in depth\n+     * first search of this operation's descendant operations.\n+     *\n+     * @return the list of captured values, modifiable\n+     * @see Body#capturedValues()\n+     *\/\n+    public List<Value> capturedValues() {\n+        Set<Value> cvs = new LinkedHashSet<>();\n+\n+        capturedValues(cvs, new ArrayDeque<>(), this);\n+        return new ArrayList<>(cvs);\n+    }\n+\n+    static void capturedValues(Set<Value> capturedValues, Deque<Body> bodyStack, Op op) {\n+        for (Body childBody : op.bodies()) {\n+            Body.capturedValues(capturedValues, bodyStack, childBody);\n+        }\n+    }\n+\n+    \/**\n+     * Writes the textual form of this operation to the given output stream, using the UTF-8 character set.\n+     *\n+     * @param out the stream to write to.\n+     *\/\n+    public void writeTo(OutputStream out) {\n+        writeTo(new OutputStreamWriter(out, StandardCharsets.UTF_8));\n+    }\n+\n+    \/**\n+     * Writes the textual form of this operation to the given writer.\n+     *\n+     * @param w the writer to write to.\n+     *\/\n+    public void writeTo(Writer w) {\n+        OpWriter.writeTo(w, this);\n+    }\n+\n+    \/**\n+     * Returns the textual form of this operation.\n+     *\n+     * @return the textual form of this operation.\n+     *\/\n+    public String toText() {\n+        StringWriter w = new StringWriter();\n+        writeTo(w);\n+        return w.toString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Op.java","additions":473,"deletions":0,"binary":false,"changes":473,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.Objects;\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * An operation transformer.\n+ *\/\n+@FunctionalInterface\n+public interface OpTransformer extends BiFunction<Block.Builder, Op, Block.Builder> {\n+    \/**\n+     * A copying transformer that applies the operation to the block builder, and returning the block builder.\n+     *\/\n+    OpTransformer COPYING_TRANSFORMER = (block, op) -> {\n+        block.op(op);\n+        return block;\n+    };\n+\n+    \/**\n+     * A transformer that performs no action on the block builder.\n+     *\/\n+    OpTransformer NOOP_TRANSFORMER = (block, op) -> block;\n+\n+    \/**\n+     * A transformer that drops location information from operations.\n+     *\/\n+    OpTransformer DROP_LOCATION_TRANSFORMER = (block, op) -> {\n+        Op.Result r = block.op(op);\n+        r.op().setLocation(Location.NO_LOCATION);\n+        return block;\n+    };\n+\n+    \/**\n+     * Transforms a given operation to zero or more other operations appended to the\n+     * given block builder. Returns a block builder to be used for appending further operations, such\n+     * as subsequent operations from the same block as the given operation.\n+     *\n+     * @param block the block builder.\n+     * @param op    the operation to transform.\n+     * @return      the block builder to append to for subsequent operations to transform that have same parent block.\n+     *\/\n+    Block.Builder apply(Block.Builder block, Op op);\n+\n+    \/**\n+     * Transforms a given block to zero or more operations appended to the given block builder.\n+     *\n+     * @implSpec\n+     * The default implementation iterates through each operation of the block to transform\n+     * and {@link #apply(Block.Builder, Op) applies} a block builder and the operation to this\n+     * transformer.\n+     * On first iteration the block builder that is applied is block builder passed as an argument\n+     * to this method.\n+     * On second and subsequent iterations the block builder that is applied is the resulting\n+     * block builder of the prior iteration.\n+     *\n+     * @param block the block builder\n+     * @param b     the block to transform\n+     * @throws NullPointerException if a resulting block builder is null\n+     *\/\n+    default void apply(Block.Builder block, Block b) {\n+        for (Op op : b.ops()) {\n+            block = apply(block, op);\n+            \/\/ @@@ See andThen composition\n+            Objects.requireNonNull(block);\n+        }\n+    }\n+\n+    default OpTransformer compose(OpTransformer before) {\n+        return before.andThen(this);\n+    }\n+\n+    default OpTransformer andThen(OpTransformer after) {\n+        if (after == NOOP_TRANSFORMER) {\n+            return this;\n+        } else if (this == NOOP_TRANSFORMER) {\n+            return after;\n+        } else {\n+            return (bb, o) -> {\n+                Block.Builder nbb = apply(bb, o);\n+                if (nbb != null) {\n+                    return after.apply(nbb, o);\n+                } else {\n+                    \/\/ @@@ This does not currently occur\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/OpTransformer.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+\/**\n+ * Classes implementing this interface support code reflection. That is, they can obtain\n+ * a {@link Quoted} object using {@link #quoted()}, which returns the intermediate\n+ * representation associated with a lambda expression or method reference.\n+ *\/\n+public interface Quotable {\n+    default Quoted quoted() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quotable.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+\/**\n+ * The quoted form of an operation.\n+ * <p>\n+ * The quoted form is utilized when the code model of some code is to be obtained rather than obtaining the result of\n+ * executing that code. For example passing the of a lambda expression in quoted form rather than the expression being\n+ * targeted to a functional interface from which it can be invoked.\n+ *\/\n+public final class Quoted {\n+    private final Op op;\n+    private final Map<Value, Object> capturedValues;\n+\n+    \/**\n+     * Constructs the quoted form of a given operation.\n+     *\n+     * @param op the invokable operation.\n+     *\/\n+    public Quoted(Op op) {\n+        this(op, Map.of());\n+    }\n+\n+    \/**\n+     * Constructs the quoted form of a given operation.\n+     * <p>\n+     * The captured values key set must have the same elements and same encounter order as\n+     * operation's captured values, specifically the following expression should evaluate to true:\n+     * {@snippet lang=java :\n+     * op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n+     * }\n+     *\n+     * @param op             the operation.\n+     * @param capturedValues the captured values referred to by the operation\n+     * @see Op#capturedValues()\n+     *\/\n+    public Quoted(Op op, Map<Value, Object> capturedValues) {\n+        \/\/ @@@ This check is potentially expensive, remove or keep as assert?\n+        \/\/ @@@ Or make Quoted an interface, with a module private implementation?\n+        assert op.capturedValues().equals(new ArrayList<>(capturedValues.keySet()));\n+        this.op = op;\n+        this.capturedValues = Collections.unmodifiableMap(new LinkedHashMap<>(capturedValues));\n+    }\n+\n+    \/**\n+     * Returns the operation.\n+     *\n+     * @return the operation.\n+     *\/\n+    public Op op() {\n+        return op;\n+    }\n+\n+    \/**\n+     * Returns the captured values.\n+     * <p>\n+     * The captured values key set has the same elements and same encounter order as\n+     * operation's captured values, specifically the following expression evaluates to true:\n+     * {@snippet lang=java :\n+     * op().capturedValues().equals(new ArrayList<>(capturedValues().keySet()));\n+     * }\n+     *\n+     * @return the captured values, as an unmodifiable map.\n+     *\/\n+    public Map<Value, Object> capturedValues() {\n+        return capturedValues;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Quoted.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+package java.lang.reflect.code;\n+\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.util.Optional;\n+\n+\/**\n+ * A type, that defines a set of values.\n+ * <p>\n+ * A type can be assigned to a {@link Value value} in a code model,\n+ * and implies the value is a member of the type's set.\n+ * <p>\n+ * The {@code equals} method should be used to check if two type elements\n+ * are equal to each other.\n+ * @apiNote\n+ * Code model types enable reasoning statically about a code model,\n+ * approximating run time behaviour.\n+ *\/\n+public non-sealed interface TypeElement extends CodeItem {\n+    \/\/ @@@ Common useful methods generally associated with properties of a type\n+    \/\/ e.g., arguments, is an array etc. (dimensions)\n+\n+    \/**\n+     * Converts this type element to a type definition.\n+     *\n+     * @return the type definition\n+     * @throws UnsupportedOperationException if the type element is not convertible\n+     *\/\n+    TypeDefinition toTypeDefinition();\n+\n+    @Override\n+    String toString();\n+\n+    @Override\n+    boolean equals(Object o);\n+\n+    @Override\n+    int hashCode();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeElement.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+\/**\n+ * A value, that is the result of an operation or a block parameter.\n+ *\/\n+public abstract sealed class Value implements Comparable<Value>, CodeItem\n+        permits Block.Parameter, Op.Result {\n+    final Block block;\n+    final TypeElement type;\n+    \/\/ @@@ In topological order?\n+    \/\/     Can the representation be more efficient e.g. an array?\n+    final Set<Op.Result> uses;\n+\n+    Value(Block block, TypeElement type) {\n+        this.block = block;\n+        this.type = type;\n+        this.uses = new LinkedHashSet<>();\n+    }\n+\n+    \/**\n+     * Returns this value's declaring block.\n+     * <p>If the value is an operation result, then the declaring block is the operation's parent block.\n+     * If the value is a block parameter then the declaring block is the block declaring the parameter.\n+     *\n+     * @return the value's declaring block.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public Block declaringBlock() {\n+        if (!isBound()) {\n+            throw new IllegalStateException(\"Declaring block is partially constructed\");\n+        }\n+        return block;\n+    }\n+\n+    \/**\n+     * Returns the type of the value.\n+     *\n+     * @return the type of the value.\n+     *\/\n+    public TypeElement type() {\n+        return type;\n+    }\n+\n+    \/**\n+     * Returns the values this value directly depends on.\n+     * <p>\n+     * An operation result depends on the set of values whose members are the operation's operands and block arguments\n+     * of the operation's successors.\n+     * A block parameter does not depend on any values.\n+     *\n+     * @return the values this value directly depends on, as an unmodifiable set.\n+     *\/\n+    public abstract Set<Value> dependsOn();\n+\n+    \/**\n+     * Returns the uses of this value, specifically each operation result of an operation where this value is used as\n+     * an operand or as an argument of a block reference that is a successor.\n+     *\n+     * @return the uses of this value, as an unmodifiable set.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public Set<Op.Result> uses() {\n+        if (!isBound()) {\n+            throw new IllegalStateException(\"Users are partially constructed\");\n+        }\n+\n+        return Collections.unmodifiableSet(uses);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this value is dominated by the given value {@code dom}.\n+     * <p>\n+     * If {@code v} and {@code dom} are in not declared in the same block then, domination is the result of\n+     * if the declaring block of {@code v} is dominated by the declaring block of {@code dom}.\n+     * <p>\n+     * Otherwise, if {@code v} and {@code dom} are declared in the same block then (in order):\n+     * <ul>\n+     * <li>if {@code dom} is a block parameter, then {@code v} is dominated by {@code dom}.\n+     * <li>if {@code v} is a block parameter, then {@code v} is <b>not<\/b> dominated by {@code dom}.\n+     * <li>otherwise, both {@code v} and {@code dom} are operation results, then {@code v} is dominated by {@code dom}\n+     * if {@code v} is the same as {@code dom} or {@code v} occurs after {@code dom} in the declaring block.\n+     * <\/ul>\n+     *\n+     * @param dom the dominating value\n+     * @return {@code true} if this value is dominated by the given value {@code dom}.\n+     * @throws IllegalStateException if the declaring block is partially built\n+     *\/\n+    public boolean isDominatedBy(Value dom) {\n+        if (this == dom) {\n+            return true;\n+        }\n+\n+        if (declaringBlock() != dom.declaringBlock()) {\n+            return declaringBlock().isDominatedBy(dom.declaringBlock());\n+        }\n+\n+        \/\/ Any value is dominated by a block parameter\n+        if (dom instanceof Block.Parameter) {\n+            return true;\n+        } else if (this instanceof Block.Parameter) {\n+            return false;\n+        } else {\n+            assert this instanceof Op.Result &&\n+                    dom instanceof Op.Result;\n+            List<Op> ops = declaringBlock().ops();\n+            return ops.indexOf(((Op.Result) this).op()) >= ops.indexOf(((Op.Result) dom).op());\n+        }\n+    }\n+\n+\n+    @Override\n+    public int compareTo(Value o) {\n+        return compare(this, o);\n+    }\n+\n+    \/\/ @@@\n+    public static int compare(Value v1, Value v2) {\n+        if (v1 == v2) return 0;\n+\n+        Block b1 = v1.declaringBlock();\n+        Block b2 = v2.declaringBlock();\n+        if (b1 == b2) {\n+            if (v1 instanceof Op.Result or1 && v2 instanceof Op.Result or2) {\n+                List<Op> ops = b1.ops();\n+                return Integer.compare(ops.indexOf(or1.op()), ops.indexOf(or2.op()));\n+            } else if (v1 instanceof Op.Result) {\n+                \/\/ v2 instanceof BlockParameter\n+                return 1;\n+            } else if (v2 instanceof Op.Result) {\n+                \/\/ v1 instanceof BlockParameter\n+                return -1;\n+            } else { \/\/ v1 && v2 instanceof BlockParameter\n+                assert v1 instanceof Block.Parameter && v2 instanceof Block.Parameter;\n+                List<Block.Parameter> args = b1.parameters();\n+                return Integer.compare(args.indexOf(v1), args.indexOf(v2));\n+            }\n+        }\n+\n+        Body r1 = b1.parentBody();\n+        Body r2 = b2.parentBody();\n+        if (r1 == r2) {\n+            \/\/ @@@ order should be defined by CFG and dominator relations\n+            List<Block> bs = r1.blocks();\n+            return Integer.compare(bs.indexOf(b1), bs.indexOf(b2));\n+        }\n+\n+        Op o1 = r1.parentOp();\n+        Op o2 = r2.parentOp();\n+        if (o1 == o2) {\n+            List<Body> rs = o1.bodies();\n+            return Integer.compare(rs.indexOf(r1), rs.indexOf(r2));\n+        }\n+\n+        return compare(o1.result(), o2.result());\n+    }\n+\n+    boolean isBound() {\n+        return block.isBound();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Value.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,329 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.analysis;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Provides liveness information for values declared in the bodies of an operation.\n+ *\/\n+public class Liveness {\n+\n+    \/**\n+     * Liveness information associated with a block.\n+     * Each block has two sets of values, live-in values and live-out values.\n+     *\/\n+    public static final class BlockInfo {\n+        final Block block;\n+        final Deque<Value> inValues;\n+        final Deque<Value> outValues;\n+\n+        BlockInfo(Block block) {\n+            this.block = block;\n+            this.inValues = new ArrayDeque<>();\n+            this.outValues = new ArrayDeque<>();\n+        }\n+\n+        \/**\n+         * {@return the block associated with the liveness information}\n+         *\/\n+        public Block getBlock() {\n+            return block;\n+        }\n+\n+        \/**\n+         * Returns true if a value is live-in for the associated block.\n+         * <p>\n+         * A value is live-in for a block if it is not declared in the block\n+         * and is used in the block or (transitively) by some successor.\n+         *\n+         * @param value the value\n+         * @return true if the value is live-in\n+         *\/\n+        public boolean isLiveIn(Value value) {\n+            return inValues.contains(value);\n+        }\n+\n+        \/**\n+         * {@return the set of live-in values}\n+         *\/\n+        public Set<Value> liveIn() {\n+            return new HashSet<>(inValues);\n+        }\n+\n+        \/**\n+         * Returns true if a value is live-out for the associated block.\n+         * <p>\n+         * A value is live-out for a block if it is used (transitively) by some successor.\n+         *\n+         * @param value the value\n+         * @return true if the value is live-out\n+         *\/\n+        public boolean isLiveOut(Value value) {\n+            return outValues.contains(value);\n+        }\n+\n+        \/**\n+         * {@return the set of live-out values}\n+         *\/\n+        public Set<Value> liveOut() {\n+            return new HashSet<>(outValues);\n+        }\n+\n+        \/**\n+         * Returns the first operation associated with a value and the associated block.\n+         * <p>\n+         * If the value is live-in or a block argument then the blocks first operation\n+         * is returned. Otherwise, the value is an operation result and its operation\n+         * is returned.\n+         *\n+         * @param value the value\n+         * @return first operation associated with a value and the associated block.\n+         *\/\n+        public Op getStartOperation(Value value) {\n+            if (isLiveIn(value) || value instanceof Block.Parameter) {\n+                \/\/ @@@ Check value is from this block\n+                return block.firstOp();\n+            } else {\n+                \/\/ @@@ Check value is from block\n+                Op.Result or = (Op.Result) value;\n+                return or.op();\n+            }\n+        }\n+\n+        \/**\n+         * Returns the end operation associated with a value and the associated block.\n+         * <p>\n+         * If the value is live-out then the blocks last (and terminating) operation\n+         * is returned. Otherwise, the value is dying in this block and the last\n+         * operation to use this value is returned.\n+         *\n+         * @param value the value\n+         * @return first operation associated with a value and the associated block.\n+         *\/\n+        public Op getEndOperation(Value value, Op startOp) {\n+            \/\/ Value is used by some other operation\n+            if (isLiveOut(value)) {\n+                return block.terminatingOp();\n+            }\n+\n+            \/\/ Value may be last used in this block, if so find it\n+            \/\/ @@@ Check startOp is of this block\n+            Op endOp = startOp;\n+            for (Op.Result useOpr : value.uses()) {\n+                Op useOp = useOpr.op();\n+                \/\/ Find the operation in the current block\n+                useOp = block.findAncestorOpInBlock(useOp);\n+                \/\/ Update if after\n+                if (useOp != null && isBeforeInBlock(endOp, useOp)) {\n+                    endOp = useOp;\n+                }\n+            }\n+            return endOp;\n+        }\n+    }\n+\n+    final Op op;\n+    final Map<Block, BlockInfo> livenessMapping;\n+\n+    \/**\n+     * Constructs liveness information for values declared in the bodies\n+     * of an operation.\n+     *\n+     * @param op the operation.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    public Liveness(Op op) {\n+        this.op = op;\n+        this.livenessMapping = new HashMap<>();\n+        for (Body cfg : op.bodies()) {\n+            Compute_LiveSets_SSA_ByVar(cfg);\n+        }\n+    }\n+\n+    \/*\n+    The algorithm to compute liveness information is derived from\n+    Domaine, & Brandner, Florian & Boissinot, Benoit & Darte, Alain & Dinechin, Benoit & Rastello, Fabrice.\n+    (2011). Computing Liveness Sets for SSA-Form Programs.\n+    https:\/\/inria.hal.science\/inria-00558509v2\/document\n+    Specifically Algorithm 6 & 7, adapted to work with block arguments and\n+    block parameters instead of phi operations.\n+    This is a simple algorithm that is easy to understand. We may need to review\n+    its usage within exception regions.\n+    We also may revisit this later with a more performant implementation\n+    perhaps based on the well known algorithm that uses fixpoint iteration.\n+     *\/\n+\n+    void Compute_LiveSets_SSA_ByVar(Body CFG) {\n+        for (Block b : CFG.blocks()) {\n+            livenessMapping.put(b, new BlockInfo(b));\n+        }\n+        for (Block b : CFG.blocks()) {\n+            for (Block.Parameter p : b.parameters()) {\n+                Compute_LiveSets_SSA_ByVar(CFG, p);\n+            }\n+\n+            for (Op op : b.ops()) {\n+                Compute_LiveSets_SSA_ByVar(CFG, op.result());\n+            }\n+        }\n+    }\n+\n+    void Compute_LiveSets_SSA_ByVar(Body CFG, Value v) {\n+        for (Op.Result use : v.uses()) {\n+            Block B = CFG.findAncestorBlockInBody(use.declaringBlock());\n+            Up_and_Mark_Stack(B, v);\n+        }\n+    }\n+\n+    void Up_and_Mark_Stack(Block B, Value v) {\n+        if (v.declaringBlock() == B) {\n+            return;\n+        }\n+        var lbi = livenessMapping.get(B);\n+        if (lbi.inValues.peek() == v) {\n+            return;\n+        }\n+        lbi.inValues.push(v);\n+        for (Block P : B.predecessors()) {\n+            lbi = livenessMapping.get(P);\n+            if (lbi.outValues.peek() != v) {\n+                lbi.outValues.push(v);\n+            }\n+            Up_and_Mark_Stack(P, v);\n+        }\n+    }\n+\n+    \/**\n+     * {@return the liveness information as a string}\n+     *\/\n+    public String toString() {\n+        StringWriter w = new StringWriter();\n+        writeTo(w);\n+        return w.toString();\n+    }\n+\n+    \/**\n+     * Writes the liveness information to the given writer.\n+     *\n+     * @param w the writer to write to.\n+     *\/\n+    public void writeTo(Writer w) {\n+        OpWriter ow = new OpWriter(w);\n+        ow.writeOp(op);\n+        try {\n+            w.write(\"\\n\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        Function<CodeItem, String> namer = ow.namer();\n+        op.traverse(null, CodeElement.blockVisitor((_, b) -> {\n+            BlockInfo liveness = getLiveness(b);\n+            try {\n+                w.write(\"^\" + namer.apply(b));\n+                w.write(\"\\n\");\n+                w.write(\"  Live-in values: \");\n+                w.write(liveness.inValues.stream()\n+                        .map(v -> \"%\" + namer.apply(v))\n+                        .collect(Collectors.joining(\",\")));\n+                w.write(\"\\n\");\n+                w.write(\"  Live-out values: \");\n+                w.write(liveness.outValues.stream()\n+                        .map(v -> \"%\" + namer.apply(v))\n+                        .collect(Collectors.joining(\",\")));\n+                w.write(\"\\n\");\n+                return null;\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }));\n+    }\n+\n+    \/**\n+     * Returns true if a value is last used by an operation.\n+     * <p>\n+     * The liveness information for the operation's parent block\n+     * is obtained. If the value is live-out then the value escapes\n+     * the block and is therefore not the last use, and this method\n+     * returns false.\n+     * If the operation is the last to use the value, this method\n+     * returns true. If the operation does not use the value and\n+     * the {@link BlockInfo#getEndOperation end operation}\n+     * occurs before the operation, this method returns true.\n+     * Otherwise, this method returns false.\n+     *\n+     * @param value the value\n+     * @param op    the operation\n+     * @return true if a value is last used by an operation\n+     *\/\n+    public boolean isLastUse(Value value, Op op) {\n+        Block block = op.parentBlock();\n+        BlockInfo liveness = getLiveness(block);\n+\n+        \/\/ Value is used by some successor\n+        if (liveness.isLiveOut(value))\n+            return false;\n+\n+        Op endOp = liveness.getEndOperation(value, op);\n+        \/\/ Last use or operation is after last use\n+        return endOp == op || isBeforeInBlock(endOp, op);\n+    }\n+\n+    \/**\n+     * {@return the liveness information associated with a block}\n+     *\n+     * @param block the block\n+     * @throws IllegalArgumentException if the block has no liveness information\n+     *\/\n+    public BlockInfo getLiveness(Block block) {\n+        BlockInfo lbi = livenessMapping.get(block);\n+        if (lbi == null) {\n+            throw new IllegalArgumentException(\"Block has no liveness information\");\n+        }\n+        return lbi;\n+    }\n+\n+    private static boolean isBeforeInBlock(Op thisOp, Op thatOp) {\n+        if (thisOp.result() == null || thatOp.result() == null) {\n+            throw new IllegalArgumentException(\"This or the given operation is not assigned to a block\");\n+        }\n+\n+        if (thisOp.parentBlock() != thatOp.parentBlock()) {\n+            throw new IllegalArgumentException(\"This and that operation are not assigned to the same blocks\");\n+        }\n+\n+        List<Op> ops = thisOp.parentBlock().ops();\n+        return ops.indexOf(thisOp) < ops.indexOf(thatOp);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Liveness.java","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * A simple and experimental pattern match mechanism on values and operations.\n+ * <p>\n+ * When the language has support for pattern matching with matcher methods we should be able to express\n+ * matching on values and operations more powerfully and concisely.\n+ *\/\n+public final class Patterns {\n+\n+    private Patterns() {\n+    }\n+\n+\n+    \/**\n+     * Traverses this operation and its descendant operations and returns the set of operations that are unused\n+     * (have no uses) and are pure (are instances of {@code Op.Pure} and thus have no side effects).\n+     *\n+     * @param op the operation to traverse\n+     * @return the set of used and pure operations.\n+     *\/\n+    public static Set<Op> matchUnusedPureOps(Op op) {\n+        return matchUnusedPureOps(op, o -> o instanceof Op.Pure);\n+    }\n+\n+    \/**\n+     * Traverses this operation and its descendant operations and returns the set of operations that are unused\n+     * (have no uses) and are pure (according to the given predicate).\n+     *\n+     * @param op       the operation to traverse\n+     * @param testPure the predicate to test if an operation is pure\n+     * @return the set of used and pure operations.\n+     *\/\n+    public static Set<Op> matchUnusedPureOps(Op op, Predicate<Op> testPure) {\n+        return match(\n+                new HashSet<>(),\n+                op, opP(o -> isDeadOp(o, testPure)),\n+                (ms, deadOps) -> {\n+                    deadOps.add(ms.op());\n+\n+                    \/\/ Dependent dead ops\n+                    matchDependentDeadOps(ms.op(), deadOps, testPure);\n+                    \/\/ @@@ No means to control traversal and only go deeper when\n+                    \/\/ there is only one user\n+\/\/                    ms.op().traverseOperands(null, (_a, arg) -> {\n+\/\/                        if (arg.result().users().size() == 1) {\n+\/\/                            deadOps.add(arg);\n+\/\/                        }\n+\/\/\n+\/\/                        return null;\n+\/\/                    });\n+\n+                    return deadOps;\n+                });\n+    }\n+\n+    static boolean isDeadOp(Op op, Predicate<Op> testPure) {\n+        if (op instanceof Op.Terminating) {\n+            return false;\n+        }\n+\n+        return op.result() != null && op.result().uses().isEmpty() && testPure.test(op);\n+    }\n+\n+    \/\/ @@@ this could be made generic with a method traversing backwards\n+    static void matchDependentDeadOps(Op op, Set<Op> deadOps, Predicate<Op> testPure) {\n+        for (Value arg : op.operands()) {\n+            if (arg instanceof Op.Result or) {\n+                if (arg.uses().size() == 1 && testPure.test(or.op())) {\n+                    deadOps.add(or.op());\n+\n+                    \/\/ Traverse only when a single user\n+                    matchDependentDeadOps(or.op(), deadOps, testPure);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ Matching of patterns\n+\n+    \/**\n+     * The state of a successful match of an operation with matched operands (if any)\n+     *\/\n+    public static final class MatchState {\n+        final Op op;\n+        final List<Value> matchedOperands;\n+\n+        MatchState(Op op, List<Value> matchedOperands) {\n+            this.op = op;\n+            this.matchedOperands = matchedOperands;\n+        }\n+\n+        \/**\n+         * {@return the matched operation}\n+         *\/\n+        public Op op() {\n+            return op;\n+        }\n+\n+        \/**\n+         * {@return the matched operands}\n+         *\/\n+        public List<Value> matchedOperands() {\n+            return matchedOperands;\n+        }\n+    }\n+\n+    record PatternAndFunction<R>(OpPattern p, BiFunction<MatchState, R, R> f) {\n+    }\n+\n+    \/\/ Visiting op pattern matcher\n+    static class OpPatternMatcher<R> implements BiFunction<R, Op, R> {\n+        final List<PatternAndFunction<R>> patterns;\n+        final PatternState state;\n+        final Map<MatchState, BiFunction<MatchState, R, R>> matches;\n+\n+        OpPatternMatcher(OpPattern p, BiFunction<MatchState, R, R> f) {\n+            this(List.of(new PatternAndFunction<>(p, f)));\n+        }\n+\n+        OpPatternMatcher(List<PatternAndFunction<R>> patterns) {\n+            this.patterns = patterns;\n+            this.state = new PatternState();\n+            this.matches = new HashMap<>();\n+        }\n+\n+        @Override\n+        public R apply(R r, Op op) {\n+            for (PatternAndFunction<R> pf : patterns) {\n+                if (pf.p.match(op, state)) {\n+                    MatchState ms = new MatchState(op, state.resetOnMatch());\n+\n+                    r = pf.f.apply(ms, r);\n+                } else {\n+                    state.resetOnNoMatch();\n+                }\n+            }\n+\n+            return r;\n+        }\n+    }\n+\n+    \/**\n+     * A match builder for declaring matching for one or more groups of operation patterns against a given traversable\n+     * and descendant operations (in order).\n+     * @param <R> the match result type\n+     *\/\n+    public static final class MultiMatchBuilder<R> {\n+        final CodeElement<?, ?> o;\n+        final R r;\n+        List<PatternAndFunction<R>> patterns;\n+\n+        MultiMatchBuilder(CodeElement<?, ?> o, R r) {\n+            this.o = o;\n+            this.r = r;\n+            this.patterns = new ArrayList<>();\n+        }\n+\n+        \/**\n+         * Declares a first of possibly other operation patterns in a group.\n+         *\n+         * @param p the operation pattern\n+         * @return a builder to declare further patterns in the group.\n+         *\/\n+        public MultiMatchCaseBuilder pattern(OpPattern p) {\n+            return new MultiMatchCaseBuilder(p);\n+        }\n+\n+        public R matchThenApply() {\n+            OpPatternMatcher<R> opm = new OpPatternMatcher<>(patterns);\n+            return o.traverse(r, CodeElement.opVisitor(opm));\n+        }\n+\n+        \/**\n+         * A builder to declare further operation patterns in a group or to associate a\n+         * target function to be applied if any of the patterns in the group match.\n+         *\/\n+        public final class MultiMatchCaseBuilder {\n+            List<OpPattern> patterns;\n+\n+            MultiMatchCaseBuilder(OpPattern p) {\n+                this.patterns = new ArrayList<>();\n+                patterns.add(p);\n+            }\n+\n+            \/**\n+             * Declares an operation pattern in the group.\n+             *\n+             * @param p the operation pattern\n+             * @return this builder.\n+             *\/\n+            public MultiMatchCaseBuilder pattern(OpPattern p) {\n+                patterns.add(p);\n+                return this;\n+            }\n+\n+            \/**\n+             * Declares the target function to be applied if any of the operation patterns on the group match.\n+             *\n+             * @param f the target function.\n+             * @return the match builder to build further groups.\n+             *\/\n+            public MultiMatchBuilder<R> target(BiFunction<MatchState, R, R> f) {\n+                patterns.stream().map(p -> new PatternAndFunction<>(p, f)).forEach(MultiMatchBuilder.this.patterns::add);\n+                return MultiMatchBuilder.this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Constructs a match builder from which to declare matching for one or more groups of operation patterns against a\n+     * given traversable and descendant operations (in order).\n+     *\n+     * @param r   the initial match result\n+     * @param t   the traversable\n+     * @param <R> the match result type\n+     * @return the match builder\n+     *\/\n+    public static <R> MultiMatchBuilder<R> multiMatch(R r, CodeElement<?, ?> t) {\n+        return new MultiMatchBuilder<>(t, r);\n+    }\n+\n+    \/**\n+     * Matches an operation pattern against the given traversable and descendant operations (in order).\n+     *\n+     * @param r         the initial match result\n+     * @param t         the traversable\n+     * @param opPattern the operation pattern\n+     * @param matcher   the function to be applied with a match state and the current match result when an\n+     *                  encountered operation matches the operation pattern\n+     * @param <R>       the match result type\n+     * @return the match result\n+     *\/\n+    public static <R> R match(R r, CodeElement<?, ?> t, OpPattern opPattern,\n+                              BiFunction<MatchState, R, R> matcher) {\n+        OpPatternMatcher<R> opm = new OpPatternMatcher<>(opPattern, matcher);\n+        return t.traverse(r, CodeElement.opVisitor(opm));\n+    }\n+\n+\n+    \/\/ Pattern classes\n+\n+    static final class PatternState {\n+        List<Value> matchedOperands;\n+\n+        void addOperand(Value v) {\n+            if (matchedOperands == null) {\n+                matchedOperands = new ArrayList<>();\n+            }\n+            matchedOperands.add(v);\n+        }\n+\n+        List<Value> resetOnMatch() {\n+            if (matchedOperands != null) {\n+                List<Value> r = matchedOperands;\n+                matchedOperands = null;\n+                return r;\n+            } else {\n+                return List.of();\n+            }\n+        }\n+\n+        void resetOnNoMatch() {\n+            if (matchedOperands != null) {\n+                matchedOperands.clear();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A pattern matching against a value or operation.\n+     *\/\n+    public static sealed abstract class Pattern {\n+        Pattern() {\n+        }\n+\n+        abstract boolean match(Value v, PatternState state);\n+    }\n+\n+    \/**\n+     * A pattern matching against an operation.\n+     *\/\n+    public static final class OpPattern extends Pattern {\n+        final Predicate<Op> opTest;\n+        final List<Pattern> operandPatterns;\n+\n+        OpPattern(Predicate<Op> opTest, List<Pattern> operandPatterns) {\n+            this.opTest = opTest;\n+            this.operandPatterns = List.copyOf(operandPatterns);\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            if (v instanceof Op.Result or) {\n+                return match(or.op(), state);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean match(Op op, PatternState state) {\n+            \/\/ Test does not match\n+            if (!opTest.test(op)) {\n+                return false;\n+            }\n+\n+            if (!operandPatterns.isEmpty()) {\n+                \/\/ Arity does not match\n+                if (op.operands().size() != operandPatterns.size()) {\n+                    return false;\n+                }\n+\n+                \/\/ Match all arguments\n+                for (int i = 0; i < operandPatterns.size(); i++) {\n+                    Pattern p = operandPatterns.get(i);\n+                    Value v = op.operands().get(i);\n+\n+                    if (!p.match(v, state)) {\n+                        return false;\n+                    }\n+                }\n+            }\n+\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * A pattern that unconditionally matches a value which is captured. If the value is an operation result of an\n+     * operation, then an operation pattern (if any) is further matched against the operation.\n+     *\/\n+    \/\/ @@@ type?\n+    static final class ValuePattern extends Pattern {\n+        final OpPattern opMatcher;\n+\n+        ValuePattern() {\n+            this(null);\n+        }\n+\n+        public ValuePattern(OpPattern opMatcher) {\n+            this.opMatcher = opMatcher;\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            \/\/ Capture the operand\n+            state.addOperand(v);\n+\n+            \/\/ Match on operation on nested pattern, if any\n+            return opMatcher == null || opMatcher.match(v, state);\n+        }\n+    }\n+\n+    \/**\n+     * A pattern that conditionally matches an operation result which is captured,  then an operation pattern (if any)\n+     * is further matched against the result's operation.\n+     *\/\n+    static final class OpResultPattern extends Pattern {\n+        final OpPattern opMatcher;\n+\n+        OpResultPattern() {\n+            this(null);\n+        }\n+\n+        public OpResultPattern(OpPattern opMatcher) {\n+            this.opMatcher = opMatcher;\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            if (!(v instanceof Op.Result)) {\n+                return false;\n+            }\n+\n+            \/\/ Capture the operand\n+            state.addOperand(v);\n+\n+            \/\/ Match on operation on nested pattern, if any\n+            return opMatcher == null || opMatcher.match(v, state);\n+        }\n+    }\n+\n+    \/**\n+     * A pattern that conditionally matches a block parameter which is captured.\n+     *\/\n+    static final class BlockParameterPattern extends Pattern {\n+        BlockParameterPattern() {\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            if (!(v instanceof Block.Parameter)) {\n+                return false;\n+            }\n+\n+            \/\/ Capture the operand\n+            state.addOperand(v);\n+\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * A pattern matching any value or operation.\n+     *\/\n+    static final class AnyPattern extends Pattern {\n+        AnyPattern() {\n+        }\n+\n+        @Override\n+        boolean match(Value v, PatternState state) {\n+            return true;\n+        }\n+    }\n+\n+\n+    \/\/ Pattern factories\n+\n+    \/**\n+     * Creates an operation pattern that tests against an operation by applying it to the predicate, and if\n+     * {@code true}, matches operand patterns against the operation's operands (in order) .\n+     * This operation pattern matches an operation if the test returns {@code true} and all operand patterns match\n+     * against the operation's operands.\n+     *\n+     * @param opTest the predicate\n+     * @param patterns the operand patterns\n+     * @return the operation pattern\n+     *\/\n+    public static OpPattern opP(Predicate<Op> opTest, Pattern... patterns) {\n+        return opP(opTest, List.of(patterns));\n+    }\n+\n+    \/**\n+     * Creates an operation pattern that tests against an operation by applying it to the predicate, and if\n+     * {@code true}, matches operand patterns against the operation's operands (in order) .\n+     * This operation pattern matches an operation if the test returns {@code true} and all operand patterns match\n+     * against the operation's operands.\n+     *\n+     * @param opTest the predicate\n+     * @param patterns the operand patterns\n+     * @return the operation pattern\n+     *\/\n+    public static OpPattern opP(Predicate<Op> opTest, List<Pattern> patterns) {\n+        return new OpPattern(opTest, patterns);\n+    }\n+\n+    \/**\n+     * Creates an operation pattern that tests if the operation is an instance of the class, and if\n+     * {@code true}, matches operand patterns against the operation's operands (in order) .\n+     * This operation pattern matches an operation if the test returns {@code true} and all operand patterns match\n+     * against the operation's operands.\n+     *\n+     * @param opClass the operation class\n+     * @param patterns the operand patterns\n+     * @return the operation pattern\n+     *\/\n+    public static OpPattern opP(Class<?> opClass, Pattern... patterns) {\n+        return opP(opClass::isInstance, patterns);\n+    }\n+\n+    \/**\n+     * Creates an operation pattern that tests if the operation is a {@link CoreOps.ConstantOp constant} operation\n+     * and whose constant value is equal to the given value.\n+     * This operation pattern matches an operation if the test returns {@code true}.\n+     *\n+     * @param value the value\n+     * @return the operation pattern.\n+     *\/\n+    public static OpPattern constantP(Object value) {\n+        return opP(op -> {\n+            if (op instanceof CoreOps.ConstantOp cop) {\n+                return Objects.equals(value, cop.value());\n+            }\n+\n+            return false;\n+        });\n+    }\n+\n+    \/**\n+     * Creates a value pattern that unconditionally matches any value and captures the value in match state.\n+     *\n+     * @return the value pattern.\n+     *\/\n+    public static Pattern valueP() {\n+        return new ValuePattern();\n+    }\n+\n+    \/**\n+     * Creates a value pattern that unconditionally matches any value and captures the value in match state, and\n+     * if the value is an operation result of an operation, then the operation pattern is matched against that\n+     * operation.\n+     * This value pattern matches value if value is not an operation result, or otherwise matches if the operation\n+     * pattern matches.\n+     *\n+     * @param opMatcher the operation pattern\n+     * @return the value pattern.\n+     *\/\n+    public static Pattern valueP(OpPattern opMatcher) {\n+        return new ValuePattern(opMatcher);\n+    }\n+\n+    \/**\n+     * Creates an operation result pattern that conditionally matches an operation result and captures it in match state.\n+     *\n+     * @return the operation result.\n+     *\/\n+    public static Pattern opResultP() {\n+        return new OpResultPattern();\n+    }\n+\n+    \/**\n+     * Creates an operation result pattern that conditionally matches an operation result and captures it in match state,\n+     * then the operation pattern is matched against the result's operation.\n+     *\n+     * @param opMatcher the operation pattern\n+     * @return the operation result.\n+     *\/\n+    public static Pattern opResultP(OpPattern opMatcher) {\n+        return new OpResultPattern(opMatcher);\n+    }\n+\n+    \/**\n+     * Creates a block parameter result pattern that conditionally matches a block parameter and captures it in match state.\n+     *\n+     * @return the block parameter.\n+     *\/\n+    public static Pattern blockParameterP() {\n+        return new BlockParameterPattern();\n+    }\n+\n+    \/**\n+     * Creates a pattern that unconditionally matches any value or operation.\n+     *\n+     * @return the value pattern.\n+     *\/\n+    public static Pattern _P() {\n+        return new AnyPattern();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/Patterns.java","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Functionality to transform a code model into pure SSA form, replacing operations that declare variables and\n+ * access them with the use of values they depend on or additional block parameters.\n+ *\/\n+public final class SSA {\n+    private SSA() {\n+    }\n+\n+    \/**\n+     * Applies an SSA transformation to an invokable operation, replacing operations that declare variables and\n+     * access them with the use of values they depend on or additional block parameters.\n+     * <p>\n+     * The operation should first be in lowered form before applying this transformation.\n+     * <p>\n+     * Note: this implementation does not currently work correctly when a variable is stored to within an exception\n+     * region and read from outside as a result of catching an exception. In such cases a complete transformation may be\n+     * not possible and such variables will need to be retained.\n+     *\n+     * @param iop the invokable operation\n+     * @return the transformed operation\n+     * @param <T> the invokable type\n+     *\/\n+    public static <T extends Op & Op.Invokable> T transform(T iop) {\n+        Map<Block, Set<CoreOps.VarOp>> joinPoints = new HashMap<>();\n+        Map<CoreOps.VarAccessOp.VarLoadOp, Object> loadValues = new HashMap<>();\n+        Map<Block.Reference, List<Object>> joinSuccessorValues = new HashMap<>();\n+\n+        Map<Body, Boolean> visited = new HashMap<>();\n+        Map<Block, Map<CoreOps.VarOp, Block.Parameter>> joinBlockArguments = new HashMap<>();\n+        @SuppressWarnings(\"unchecked\")\n+        T liop = (T) iop.transform(CopyContext.create(), (block, op) -> {\n+            \/\/ Compute join points and value mappings for body\n+            visited.computeIfAbsent(op.ancestorBody(), b -> {\n+                findJoinPoints(b, joinPoints);\n+                variableToValue(b, joinPoints, loadValues, joinSuccessorValues);\n+                return true;\n+            });\n+\n+            if (op instanceof CoreOps.VarOp || op instanceof CoreOps.VarAccessOp) {\n+                \/\/ Drop var operations\n+                if (op instanceof CoreOps.VarAccessOp.VarLoadOp vl) {\n+                    \/\/ Replace result of load\n+                    Object loadValue = loadValues.get(vl);\n+                    CopyContext cc = block.context();\n+                    Value v = loadValue instanceof VarOpBlockArgument vba\n+                            ? joinBlockArguments.get(vba.b()).get(vba.vop())\n+                            : cc.getValue((Value) loadValue);\n+                    cc.mapValue(op.result(), v);\n+                }\n+            } else if (op instanceof Op.Terminating) {\n+                for (Block.Reference s : op.successors()) {\n+                    List<Object> joinValues = joinSuccessorValues.get(s);\n+                    \/\/ Successor has join values\n+                    if (joinValues != null) {\n+                        CopyContext cc = block.context();\n+\n+                        \/\/ Lazily append target block arguments\n+                        joinBlockArguments.computeIfAbsent(s.targetBlock(), b -> {\n+                            Block.Builder bb = cc.getBlock(b);\n+                            return joinPoints.get(b).stream().collect(Collectors.toMap(\n+                                    varOp -> varOp,\n+                                    varOp -> bb.parameter(varOp.varType())));\n+                        });\n+\n+                        \/\/ Append successor arguments\n+                        List<Value> values = new ArrayList<>();\n+                        for (Object o : joinValues) {\n+                            Value v = o instanceof VarOpBlockArgument vba\n+                                    ? joinBlockArguments.get(vba.b()).get(vba.vop())\n+                                    : cc.getValue((Value) o);\n+                            values.add(v);\n+                        }\n+\n+                        \/\/ Map successor with append arguments\n+                        List<Value> toArgs = cc.getValues(s.arguments());\n+                        toArgs.addAll(values);\n+                        Block.Reference toS = cc.getBlock(s.targetBlock()).successor(toArgs);\n+                        cc.mapSuccessor(s, toS);\n+                    }\n+                }\n+\n+                block.apply(op);\n+            } else {\n+                block.apply(op);\n+            }\n+\n+            return block;\n+        });\n+        return liop;\n+    }\n+\n+    record VarOpBlockArgument(Block b, CoreOps.VarOp vop) {\n+    }\n+\n+    \/\/ @@@ Check for var uses in exception regions\n+    \/\/     A variable cannot be converted to SAA form if the variable is stored\n+    \/\/     to in an exception region and accessed from an associated catch region\n+\n+    static void variableToValue(Body body,\n+                                Map<Block, Set<CoreOps.VarOp>> joinPoints,\n+                                Map<CoreOps.VarAccessOp.VarLoadOp, Object> loadValues,\n+                                Map<Block.Reference, List<Object>> joinSuccessorValues) {\n+        Map<CoreOps.VarOp, Deque<Object>> variableStack = new HashMap<>();\n+        Node top = buildDomTree(body.entryBlock(), body.immediateDominators());\n+        variableToValue(top, variableStack, joinPoints, loadValues, joinSuccessorValues);\n+    }\n+\n+    \/**\n+     * Replaces usages of a variable with the corresponding value, from a given block node in the dominator tree.\n+     * <p>\n+     * The result of a {@code VarLoadOp} for variable, {@code V} say the result of a {@code VarOp} operation,\n+     * is replaced with the value passed as an operand to the immediately dominating {@code VarStoreOp} that operates\n+     * on {@code V}, or a block argument representing the equivalent of a phi-value of {@code V}.\n+     * After which, any related {@code VarOp}, {@code VarLoadOp}, or {@code VarStoreOp} operations are removed.\n+     *\n+     * @param n             the node in the dominator tree\n+     * @param variableStack the variable stack\n+     * @param joinPoints    the join points\n+     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+     * Section 5.2 and Figure 12.\n+     *\/\n+    static void variableToValue(Node n,\n+                                Map<CoreOps.VarOp, Deque<Object>> variableStack,\n+                                Map<Block, Set<CoreOps.VarOp>> joinPoints,\n+                                Map<CoreOps.VarAccessOp.VarLoadOp, Object> loadValues,\n+                                Map<Block.Reference, List<Object>> joinSuccessorValues) {\n+        int size = n.b().ops().size();\n+\n+        \/\/ Check if V is associated with block argument (phi)\n+        \/\/ Push argument onto V's stack\n+        {\n+            Set<CoreOps.VarOp> varOps = joinPoints.get(n.b());\n+            if (varOps != null) {\n+                varOps.forEach(v -> {\n+                    assert variableStack.get(v) != null;\n+                    variableStack.get(v).push(new VarOpBlockArgument(n.b(), v));\n+                });\n+            }\n+        }\n+\n+        {\n+            for (int i = 0; i < size - 1; i++) {\n+                Op op = n.b().ops().get(i);\n+\n+                if (op instanceof CoreOps.VarOp varOp) {\n+                    \/\/ Initial value assigned to variable\n+                    Value current = op.operands().get(0);\n+                    variableStack.computeIfAbsent(varOp, _k -> new ArrayDeque<>())\n+                            .push(current);\n+                } else if (op instanceof CoreOps.VarAccessOp.VarStoreOp storeOp) {\n+                    \/\/ Value assigned to variable\n+                    Value current = op.operands().get(1);\n+                    variableStack.computeIfAbsent(storeOp.varOp(), _k -> new ArrayDeque<>())\n+                            .push(current);\n+                } else if (op instanceof CoreOps.VarAccessOp.VarLoadOp loadOp) {\n+                    Object to = variableStack.get(loadOp.varOp()).peek();\n+                    loadValues.put(loadOp, to);\n+                } else if (op instanceof Op.Nested) {\n+                    \/\/ Traverse descendant variable loads for variables\n+                    \/\/ declared in the block's parent body\n+                    op.traverse(null, (o, codeElement) -> {\n+                        if (o instanceof CoreOps.VarAccessOp.VarLoadOp loadOp &&\n+                                loadOp.varOp().ancestorBody() == op.ancestorBody()) {\n+                            Object to = variableStack.get(loadOp.varOp()).peek();\n+                            loadValues.put(loadOp, to);\n+                        }\n+                        return null;\n+                    });\n+                }\n+            }\n+\n+            \/\/ Add successor args for joint points\n+            for (Block.Reference succ : n.b().successors()) {\n+                Set<CoreOps.VarOp> varOps = joinPoints.get(succ.targetBlock());\n+                if (varOps != null) {\n+                    List<Object> joinValues = varOps.stream()\n+                            .map(vop -> variableStack.get(vop).peek()).toList();\n+                    joinSuccessorValues.put(succ, joinValues);\n+                }\n+            }\n+\n+            \/\/ The result of a VarOp, a variable value, can only be used in VarStoreOp and VarLoadOp\n+            \/\/ therefore there is no need to check existing successor arguments\n+        }\n+\n+        \/\/ Traverse children of dom tree\n+        for (Node y : n.children()) {\n+            variableToValue(y, variableStack, joinPoints, loadValues, joinSuccessorValues);\n+        }\n+\n+        \/\/ Pop off values for variables\n+        {\n+            Set<CoreOps.VarOp> varOps = joinPoints.get(n.b());\n+            if (varOps != null) {\n+                varOps.forEach(v -> {\n+                    variableStack.get(v).pop();\n+                });\n+            }\n+\n+            for (int i = 0; i < size - 1; i++) {\n+                Op op = n.b().ops().get(i);\n+\n+                if (op instanceof CoreOps.VarOp varOp) {\n+                    variableStack.get(varOp).pop();\n+                } else if (op instanceof CoreOps.VarAccessOp.VarStoreOp storeOp) {\n+                    variableStack.get(storeOp.varOp()).pop();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Finds the join points of a body.\n+     * <p>\n+     * A join point is a block that is in the dominance frontier of one or more predecessors, that make one or more\n+     * stores to variables (using the {@code VarStoreOp} operation on the result of a {@code VarOp} operation).\n+     * The join point contains the set variables ({@code VarOp} operations) that are stored to.\n+     * <p>\n+     * A variable of a joint point indicates that a block argument may need to be added to the join point's block\n+     * when converting variables to SSA form. Different values of a variable may occur at different control flow\n+     * paths at the join point. The block argument represents the convergence of multiple values for the same\n+     * variable, where a predecessor assigns to the block argument.\n+     * (Block arguments are equivalent to phi-values, or phi-nodes, used in other representations.)\n+     *\n+     * @param body the body.\n+     * @param joinPoints the returned join points.\n+     * @implNote See \"Efficiently Computing Static Single Assignment Form and the Control Dependence Graph\" by Ron Cytron et. al.\n+     * Section 5.1 and Figure 11.\n+     *\/\n+    public static void findJoinPoints(Body body, Map<Block, Set<CoreOps.VarOp>> joinPoints) {\n+        Map<Block, Set<Block>> df = body.dominanceFrontier();\n+        Map<CoreOps.VarOp, Set<Block>> a = findVarStores(body);\n+\n+        int iterCount = 0;\n+        int[] hasAlready = new int[body.blocks().size()];\n+        int[] work = new int[body.blocks().size()];\n+\n+        Deque<Block> w = new ArrayDeque<>();\n+\n+        for (CoreOps.VarOp v : a.keySet()) {\n+            iterCount++;\n+\n+            for (Block x : a.get(v)) {\n+                work[x.index()] = iterCount;\n+                w.push(x);\n+            }\n+\n+            while (!w.isEmpty()) {\n+                Block x = w.pop();\n+\n+                for (Block y : df.getOrDefault(x, Set.of())) {\n+                    if (hasAlready[y.index()] < iterCount) {\n+                        \/\/ Only add to the join points if y is dominated by the var's block\n+                        if (y.isDominatedBy(v.parentBlock())) {\n+                            joinPoints.computeIfAbsent(y, _k -> new LinkedHashSet<>()).add(v);\n+                        }\n+                        hasAlready[y.index()] = iterCount;\n+\n+                        if (work[y.index()] < iterCount) {\n+                            work[y.index()] = iterCount;\n+                            w.push(y);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Returns map of variable to blocks that contain stores to the variables declared in the body\n+    \/\/ Throws ISE if a descendant store operation is encountered\n+    \/\/ @@@ Compute map for whole tree, then traverse keys with filter\n+    static Map<CoreOps.VarOp, Set<Block>> findVarStores(Body r) {\n+        return r.traverse(new LinkedHashMap<>(), CodeElement.opVisitor((stores, op) -> {\n+            if (op instanceof CoreOps.VarAccessOp.VarStoreOp storeOp) {\n+                if (storeOp.varOp().ancestorBody() != storeOp.ancestorBody()) {\n+                    throw new IllegalStateException(\"Descendant variable store operation\");\n+                }\n+                if (storeOp.varOp().ancestorBody() == r) {\n+                    stores.computeIfAbsent(storeOp.varOp(), _v -> new LinkedHashSet<>()).add(storeOp.parentBlock());\n+                }\n+            }\n+            return stores;\n+        }));\n+    }\n+\n+    record Node(Block b, Set<Node> children) {\n+    }\n+\n+    static Node buildDomTree(Block entryBlock, Map<Block, Block> idoms) {\n+        Map<Block, Node> tree = new HashMap<>();\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block id = e.getValue();\n+            Block b = e.getKey();\n+\n+            Node parent = tree.computeIfAbsent(id, _k -> new Node(_k, new HashSet<>()));\n+            if (b == entryBlock) {\n+                continue;\n+            }\n+\n+            Node child = tree.computeIfAbsent(b, _k -> new Node(_k, new HashSet<>()));\n+            parent.children.add(child);\n+        }\n+        return tree.get(entryBlock);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/SSA.java","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for analysing code models.\n+ *\/\n+package java.lang.reflect.code.analysis;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.PseudoInstruction;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * BranchCompactor is a CodeTransform skipping redundant branches to immediate targets.\n+ *\/\n+public final class BranchCompactor implements CodeTransform {\n+\n+    private BranchInstruction branch;\n+    private final List<PseudoInstruction> buffer = new ArrayList<>();\n+\n+    public BranchCompactor() {\n+    }\n+\n+    @Override\n+    public void accept(CodeBuilder cob, CodeElement coe) {\n+        if (branch == null) {\n+            if (coe instanceof BranchInstruction bi && bi.opcode().isUnconditionalBranch()) {\n+                \/\/unconditional branch is stored\n+                branch = bi;\n+            } else {\n+                \/\/all other elements are passed\n+                cob.with(coe);\n+            }\n+        } else {\n+            switch (coe) {\n+                case LabelTarget lt when branch.target() == lt.label() -> {\n+                    \/\/skip branch to immediate target\n+                    branch = null;\n+                    \/\/flush the buffer\n+                    atEnd(cob);\n+                    \/\/pass the target\n+                    cob.with(lt);\n+                }\n+                case PseudoInstruction pi -> {\n+                    \/\/buffer pseudo instructions\n+                    buffer.add(pi);\n+                }\n+                default -> {\n+                    \/\/any other instruction flushes the branch and buffer\n+                    atEnd(cob);\n+                    \/\/replay the code element\n+                    accept(cob, coe);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void atEnd(CodeBuilder cob) {\n+        if (branch != null) {\n+            \/\/flush the branch\n+            cob.with(branch);\n+            branch = null;\n+        }\n+        \/\/flush the buffer\n+        buffer.forEach(cob::with);\n+        buffer.clear();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BranchCompactor.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,1170 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Label;\n+import java.lang.constant.*;\n+import java.lang.reflect.code.op.CoreOps.*;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Quotable;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Transformer of code models to bytecode.\n+ *\/\n+public final class BytecodeGenerator {\n+\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_METAFACTORY = ofCallsiteBootstrap(\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"metafactory\",\n+            CD_CallSite, CD_MethodType, CD_MethodHandle, CD_MethodType);\n+\n+    private static final DirectMethodHandleDesc DMHD_LAMBDA_ALT_METAFACTORY = ofCallsiteBootstrap(\n+            LambdaMetafactory.class.describeConstable().orElseThrow(),\n+            \"altMetafactory\",\n+            CD_CallSite, CD_Object.arrayType());\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of hidden class and exposed\n+     * for invocation via a method handle.\n+     *\n+     * @param l the lookup\n+     * @param iop the invokable operation to transform to bytecode\n+     * @return the invoking method handle\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    public static <O extends Op & Op.Invokable> MethodHandle generate(MethodHandles.Lookup l, O iop) {\n+        String name = iop instanceof FuncOp fop ? fop.funcName() : \"m\";\n+        byte[] classBytes = generateClassData(l, name, iop);\n+\n+        MethodHandles.Lookup hcl;\n+        try {\n+            hcl = l.defineHiddenClass(classBytes, true);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            FunctionType ft = iop.invokableType();\n+            MethodType mt = MethodRef.toNominalDescriptor(ft).resolveConstantDesc(hcl);\n+            return hcl.findStatic(hcl.lookupClass(), name, mt);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Transforms the function operation to bytecode encapsulated in a method of a class file.\n+     * <p>\n+     * The name of the method is the function operation's {@link FuncOp#funcName() function name}.\n+     *\n+     * @param lookup the lookup\n+     * @param fop the function operation to transform to bytecode\n+     * @return the class file bytes\n+     *\/\n+    public static byte[] generateClassData(MethodHandles.Lookup lookup, FuncOp fop) {\n+        return generateClassData(lookup, fop.funcName(), fop);\n+    }\n+\n+    \/**\n+     * Transforms the invokable operation to bytecode encapsulated in a method of a class file.\n+     *\n+     * @param lookup the lookup\n+     * @param name the name to use for the method of the class file\n+     * @param iop the invokable operation to transform to bytecode\n+     * @return the class file bytes\n+     * @param <O> the type of the invokable operation\n+     *\/\n+    public static <O extends Op & Op.Invokable> byte[] generateClassData(MethodHandles.Lookup lookup,\n+                                                                         String name,\n+                                                                         O iop) {\n+        if (!iop.capturedValues().isEmpty()) {\n+            throw new UnsupportedOperationException(\"Operation captures values\");\n+        }\n+\n+        String packageName = lookup.lookupClass().getPackageName();\n+        ClassDesc className = ClassDesc.of(packageName.isEmpty()\n+                ? name\n+                : packageName + \".\" + name);\n+        byte[] classBytes = ClassFile.of().build(className, clb -> {\n+            List<LambdaOp> lambdaSink = new ArrayList<>();\n+            BitSet quotable = new BitSet();\n+            generateMethod(lookup, className, name, iop, clb, lambdaSink, quotable);\n+            for (int i = 0; i < lambdaSink.size(); i++) {\n+                LambdaOp lop = lambdaSink.get(i);\n+                if (quotable.get(i)) {\n+                    clb.withField(\"lambda$\" + i + \"$op\", CD_String, fb -> fb\n+                            .withFlags(ClassFile.ACC_STATIC)\n+                            .with(ConstantValueAttribute.of(quote(lop).toText())));\n+                }\n+                generateMethod(lookup, className, \"lambda$\" + i, lop, clb, lambdaSink, quotable);\n+            }\n+        });\n+        return classBytes;\n+    }\n+\n+    private static <O extends Op & Op.Invokable> void generateMethod(MethodHandles.Lookup lookup,\n+                                                                     ClassDesc className,\n+                                                                     String methodName,\n+                                                                     O iop,\n+                                                                     ClassBuilder clb,\n+                                                                     List<LambdaOp> lambdaSink,\n+                                                                     BitSet quotable) {\n+\n+        List<Value> capturedValues = iop instanceof LambdaOp lop ? lop.capturedValues() : List.of();\n+        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(\n+                iop.invokableType()).insertParameterTypes(0, capturedValues.stream()\n+                        .map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        clb.withMethodBody(methodName, mtd, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                cb -> cb.transforming(new BranchCompactor(), cob ->\n+                    new BytecodeGenerator(lookup, className, capturedValues, new Liveness(iop),\n+                                          iop.body().blocks(), cob, lambdaSink, quotable).generate()));\n+    }\n+\n+    private record Slot(int slot, TypeKind typeKind) {}\n+    private record ExceptionRegionWithBlocks(CoreOps.ExceptionRegionEnter ere, BitSet blocks) {}\n+\n+    private final MethodHandles.Lookup lookup;\n+    private final ClassDesc className;\n+    private final List<Value> capturedValues;\n+    private final List<Block> blocks;\n+    private final CodeBuilder cob;\n+    private final Label[] blockLabels;\n+    private final List<ExceptionRegionWithBlocks> allExceptionRegions;\n+    private final BitSet[] blocksRegionStack;\n+    private final BitSet blocksToVisit, catchingBlocks;\n+    private final Map<Value, Slot> slots;\n+    private final List<LambdaOp> lambdaSink;\n+    private final BitSet quotable;\n+    private Op.Result oprOnStack;\n+\n+    private BytecodeGenerator(MethodHandles.Lookup lookup,\n+                              ClassDesc className,\n+                              List<Value> capturedValues,\n+                              Liveness liveness,\n+                              List<Block> blocks,\n+                              CodeBuilder cob,\n+                              List<LambdaOp> lambdaSink,\n+                              BitSet quotable) {\n+        this.lookup = lookup;\n+        this.className = className;\n+        this.capturedValues = capturedValues;\n+        this.blocks = blocks;\n+        this.cob = cob;\n+        this.blockLabels = new Label[blocks.size()];\n+        this.allExceptionRegions = new ArrayList<>();\n+        this.blocksRegionStack = new BitSet[blocks.size()];\n+        this.blocksToVisit = new BitSet(blocks.size());\n+        this.catchingBlocks = new BitSet();\n+        this.slots = new HashMap<>();\n+        this.lambdaSink = lambdaSink;\n+        this.quotable = quotable;\n+    }\n+\n+    private void setExceptionRegionStack(Block.Reference target, BitSet activeRegionStack) {\n+        setExceptionRegionStack(target.targetBlock().index(), activeRegionStack);\n+    }\n+\n+    private void setExceptionRegionStack(int blockIndex, BitSet activeRegionStack) {\n+        if (blocksRegionStack[blockIndex] == null) {\n+            blocksToVisit.set(blockIndex);\n+            blocksRegionStack[blockIndex] = activeRegionStack;\n+            activeRegionStack.stream().forEach(r -> allExceptionRegions.get(r).blocks.set(blockIndex));\n+        }\n+    }\n+\n+    private Label getLabel(Block.Reference target) {\n+        return getLabel(target.targetBlock().index());\n+    }\n+\n+    private Label getLabel(int blockIndex) {\n+        Label l = blockLabels[blockIndex];\n+        if (l == null) {\n+            blockLabels[blockIndex] = l = cob.newLabel();\n+        }\n+        return l;\n+    }\n+\n+    private Slot allocateSlot(Value v) {\n+        return slots.computeIfAbsent(v, _ -> {\n+            TypeKind tk = toTypeKind(v.type());\n+            return new Slot(cob.allocateLocal(tk), tk);\n+        });\n+    }\n+\n+    private void storeIfUsed(Value v) {\n+        if (!v.uses().isEmpty()) {\n+            Slot slot = allocateSlot(v);\n+            cob.storeInstruction(slot.typeKind(), slot.slot());\n+        } else {\n+            \/\/ Only pop results from stack if the value has no further use (no valid slot)\n+            switch (toTypeKind(v.type()).slotSize()) {\n+                case 1 -> cob.pop();\n+                case 2 -> cob.pop2();\n+            }\n+        }\n+    }\n+\n+    private Slot load(Value v) {\n+        if (v instanceof Op.Result or &&\n+                or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                !constantOp.resultType().equals(JavaType.J_L_CLASS)) {\n+            cob.constantInstruction(((Constable)constantOp.value()).describeConstable().orElseThrow());\n+            return null;\n+        } else {\n+            Slot slot = slots.get(v);\n+            cob.loadInstruction(slot.typeKind(), slot.slot());\n+            return slot;\n+        }\n+    }\n+\n+    private void processFirstOperand(Op op) {\n+        processOperand(op.operands().getFirst());;\n+    }\n+\n+    private void processOperand(Value operand) {\n+        if (oprOnStack == null) {\n+            load(operand);\n+        } else {\n+            assert oprOnStack == operand;\n+            oprOnStack = null;\n+        }\n+    }\n+\n+    private void processOperands(Op op) {\n+        processOperands(op.operands());\n+    }\n+\n+    private void processOperands(List<Value> operands) {\n+        if (oprOnStack == null) {\n+            operands.forEach(this::load);\n+        } else {\n+            assert !operands.isEmpty() && oprOnStack == operands.getFirst();\n+            oprOnStack = null;\n+            for (int i = 1; i < operands.size(); i++) {\n+                load(operands.get(i));\n+            }\n+        }\n+    }\n+\n+    \/\/ Some of the operations can be deferred\n+    private static boolean canDefer(Op op) {\n+        return switch (op) {\n+            case ConstantOp cop -> canDefer(cop);\n+            case VarOp vop -> canDefer(vop);\n+            case VarAccessOp.VarLoadOp vlop -> canDefer(vlop);\n+            default -> false;\n+        };\n+    }\n+\n+    \/\/ Constant can be deferred, except for loading of a class constant, which  may throw an exception\n+    private static boolean canDefer(ConstantOp op) {\n+        return !op.resultType().equals(JavaType.J_L_CLASS);\n+    }\n+\n+    \/\/ Var with a single-use block parameter operand can be deferred\n+    private static boolean canDefer(VarOp op) {\n+        return op.operands().getFirst() instanceof Block.Parameter bp && bp.uses().size() == 1;\n+    }\n+\n+    \/\/ Var load can be deferred when not used as immediate operand\n+    private static boolean canDefer(VarAccessOp.VarLoadOp op) {\n+        return !isNextUse(op.result());\n+    }\n+\n+    \/\/ This method narrows the first operand inconveniences of some operations\n+    private static boolean isFirstOperand(Op nextOp, Op.Result opr) {\n+        return switch (nextOp) {\n+            \/\/ When there is no next operation\n+            case null -> false;\n+            \/\/ New object cannot use first operand from stack, new array fall through to the default\n+            case NewOp op when !(op.constructorType().returnType() instanceof ArrayType) ->\n+                false;\n+            \/\/ For lambda the effective operands are captured values\n+            case LambdaOp op ->\n+                !op.capturedValues().isEmpty() && op.capturedValues().getFirst() == opr;\n+            \/\/ Conditional branch may delegate to its binary test operation\n+            case ConditionalBranchOp op when getConditionForCondBrOp(op) instanceof CoreOps.BinaryTestOp bto ->\n+                isFirstOperand(bto, opr);\n+            \/\/ Var store effective first operand is not the first one\n+            case VarAccessOp.VarStoreOp op ->\n+                op.operands().get(1) == opr;\n+            \/\/ regular check of the first operand\n+            default ->\n+                !nextOp.operands().isEmpty() && nextOp.operands().getFirst() == opr;\n+        };\n+    }\n+\n+    \/\/ Determines if the operation result is immediatelly used by the next operation and so can stay on stack\n+    private static boolean isNextUse(Op.Result opr) {\n+        \/\/ Pass over deferred operations\n+        Op nextOp = opr.op();\n+        do {\n+            nextOp = opr.declaringBlock().nextOp(nextOp);\n+        } while (canDefer(nextOp));\n+        return isFirstOperand(nextOp, opr);\n+    }\n+\n+    private static boolean isConditionForCondBrOp(CoreOps.BinaryTestOp op) {\n+        \/\/ Result of op has one use as the operand of a CondBrOp op,\n+        \/\/ and both ops are in the same block\n+\n+        Set<Op.Result> uses = op.result().uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+        Op.Result use = uses.iterator().next();\n+\n+        if (use.declaringBlock() != op.parentBlock()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : use.op().successors()) {\n+            if (s.arguments().contains(op.result())) {\n+                return false;\n+            }\n+        }\n+\n+        return use.op() instanceof CoreOps.ConditionalBranchOp;\n+    }\n+\n+    private static ClassDesc toClassDesc(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toClassDesc(vt.valueType());\n+            case JavaType jt -> jt.toNominalDescriptor();\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n+    private static TypeKind toTypeKind(TypeElement t) {\n+        return switch (t) {\n+            case VarType vt -> toTypeKind(vt.valueType());\n+            case JavaType jt -> {\n+                TypeElement bt = jt.toBasicType();\n+                if (bt.equals(JavaType.VOID)) {\n+                    yield TypeKind.VoidType;\n+                } else if (bt.equals(JavaType.INT)) {\n+                    yield TypeKind.IntType;\n+                } else if (bt.equals(JavaType.J_L_OBJECT)) {\n+                    yield TypeKind.ReferenceType;\n+                } else if (bt.equals(JavaType.LONG)) {\n+                    yield TypeKind.LongType;\n+                } else if (bt.equals(JavaType.DOUBLE)) {\n+                    yield TypeKind.DoubleType;\n+                } else if (bt.equals(JavaType.BOOLEAN)) {\n+                    yield TypeKind.BooleanType;\n+                } else if (bt.equals(JavaType.BYTE)) {\n+                    yield TypeKind.ByteType;\n+                } else if (bt.equals(JavaType.CHAR)) {\n+                    yield TypeKind.CharType;\n+                } else if (bt.equals(JavaType.FLOAT)) {\n+                    yield TypeKind.FloatType;\n+                } else if (bt.equals(JavaType.SHORT)) {\n+                    yield TypeKind.ShortType;\n+                } else {\n+                    throw new IllegalArgumentException(\"Bad type: \" + t);\n+                }\n+            }\n+            default ->\n+                throw new IllegalArgumentException(\"Bad type: \" + t);\n+        };\n+    }\n+\n+    private void generate() {\n+        \/\/ Compute exception region membership\n+        setExceptionRegionStack(0, new BitSet());\n+        int blockIndex;\n+        while ((blockIndex = blocksToVisit.nextSetBit(0)) >= 0) {\n+            blocksToVisit.clear(blockIndex);\n+            BitSet activeRegionStack = blocksRegionStack[blockIndex];\n+            Block b = blocks.get(blockIndex);\n+            Op top = b.terminatingOp();\n+            switch (top) {\n+                case CoreOps.BranchOp bop ->\n+                    setExceptionRegionStack(bop.branch(), activeRegionStack);\n+                case CoreOps.ConditionalBranchOp cop -> {\n+                    setExceptionRegionStack(cop.falseBranch(), activeRegionStack);\n+                    setExceptionRegionStack(cop.trueBranch(), activeRegionStack);\n+                }\n+                case CoreOps.ExceptionRegionEnter er -> {\n+                    for (Block.Reference catchBlock : er.catchBlocks().reversed()) {\n+                        catchingBlocks.set(catchBlock.targetBlock().index());\n+                        setExceptionRegionStack(catchBlock, activeRegionStack);\n+                    }\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.set(allExceptionRegions.size());\n+                    ExceptionRegionWithBlocks newNode = new ExceptionRegionWithBlocks(er, new BitSet());\n+                    allExceptionRegions.add(newNode);\n+                    setExceptionRegionStack(er.start(), activeRegionStack);\n+                }\n+                case CoreOps.ExceptionRegionExit er -> {\n+                    activeRegionStack = (BitSet)activeRegionStack.clone();\n+                    activeRegionStack.clear(activeRegionStack.length() - 1);\n+                    setExceptionRegionStack(er.end(), activeRegionStack);\n+                }\n+                default -> {\n+                }\n+            }\n+        }\n+\n+        \/\/ Declare the exception regions\n+        for (ExceptionRegionWithBlocks erNode : allExceptionRegions.reversed()) {\n+            int start  = erNode.blocks.nextSetBit(0);\n+            while (start >= 0) {\n+                int end = erNode.blocks.nextClearBit(start);\n+                Label startLabel = getLabel(start);\n+                Label endLabel = getLabel(end);\n+                for (Block.Reference cbr : erNode.ere.catchBlocks()) {\n+                    List<Block.Parameter> params = cbr.targetBlock().parameters();\n+                    if (!params.isEmpty()) {\n+                        JavaType jt = (JavaType) params.get(0).type();\n+                        cob.exceptionCatch(startLabel, endLabel, getLabel(cbr), jt.toNominalDescriptor());\n+                    } else {\n+                        cob.exceptionCatchAll(startLabel, endLabel, getLabel(cbr));\n+                    }\n+                }\n+                start = erNode.blocks.nextSetBit(end);\n+            }\n+        }\n+\n+        \/\/ Process blocks in topological order\n+        \/\/ A jump instruction assumes the false successor block is\n+        \/\/ immediately after, in sequence, to the predecessor\n+        \/\/ since the jump instructions branch on a true condition\n+        \/\/ Conditions are inverted when lowered to bytecode\n+        for (Block b : blocks) {\n+            \/\/ Ignore any non-entry blocks that have no predecessors\n+            if (!b.isEntryBlock() && b.predecessors().isEmpty()) {\n+                continue;\n+            }\n+\n+            Label blockLabel = getLabel(b.index());\n+            cob.labelBinding(blockLabel);\n+\n+            \/\/ If b is the entry block then all its parameters conservatively require slots\n+            \/\/ Some unused parameters might be declared before others that are used\n+            if (b.isEntryBlock()) {\n+                List<Block.Parameter> parameters = b.parameters();\n+                int i = 0;\n+                \/\/ Captured values prepend parameters in lambda impl methods\n+                for (Value cv : capturedValues) {\n+                    slots.put(cv, new Slot(cob.parameterSlot(i++), toTypeKind(cv.type())));\n+                }\n+                for (Block.Parameter bp : parameters) {\n+                    slots.put(bp, new Slot(cob.parameterSlot(i++), toTypeKind(bp.type())));\n+                }\n+            }\n+\n+            \/\/ If b is a catch block then the exception argument will be represented on the stack\n+            if (catchingBlocks.get(b.index())) {\n+                \/\/ Retain block argument for exception table generation\n+                storeIfUsed(b.parameters().get(0));\n+            }\n+\n+            List<Op> ops = b.ops();\n+            oprOnStack = null;\n+            for (int i = 0; i < ops.size() - 1; i++) {\n+                final Op o = ops.get(i);\n+                final TypeElement oprType = o.resultType();\n+                final TypeKind rvt = toTypeKind(oprType);\n+                switch (o) {\n+                    case ConstantOp op -> {\n+                        if (!canDefer(op)) {\n+                            \/\/ Constant can be deferred, except for a class constant, which  may throw an exception\n+                            cob.ldc(((JavaType)op.value()).toNominalDescriptor());\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarOp op -> {\n+                        \/\/     %1 : Var<int> = var %0 @\"i\";\n+                        if (canDefer(op)) {\n+                            \/\/ Var with a single-use block parameter operand can be deferred\n+                            slots.put(op.result(), slots.get(op.operands().getFirst()));\n+                        } else {\n+                            processOperand(op.operands().getFirst());\n+                            allocateSlot(op.result());\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarAccessOp.VarLoadOp op -> {\n+                        if (canDefer(op)) {\n+                            \/\/ Var load can be deferred when not used as immediate operand\n+                            slots.computeIfAbsent(op.result(), r -> slots.get(op.operands().getFirst()));\n+                        } else {\n+                            processFirstOperand(op);\n+                            push(op.result());\n+                        }\n+                    }\n+                    case VarAccessOp.VarStoreOp op -> {\n+                        processOperand(op.operands().get(1));\n+                        storeIfUsed(op.operands().get(0));\n+                    }\n+                    case ConvOp op -> {\n+                        Value first = op.operands().getFirst();\n+                        processOperand(first);\n+                        TypeKind tk = toTypeKind(first.type());\n+                        if (tk != rvt) cob.convertInstruction(tk, rvt);\n+                        push(op.result());\n+                    }\n+                    case NegOp op -> {\n+                        processFirstOperand(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::neg(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ineg();\n+                            case LongType -> cob.lneg();\n+                            case FloatType -> cob.fneg();\n+                            case DoubleType -> cob.dneg();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case NotOp op -> {\n+                        processFirstOperand(op);\n+                        cob.ifThenElse(CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                        push(op.result());\n+                    }\n+                    case AddOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::add(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iadd();\n+                            case LongType -> cob.ladd();\n+                            case FloatType -> cob.fadd();\n+                            case DoubleType -> cob.dadd();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case SubOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::sub(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.isub();\n+                            case LongType -> cob.lsub();\n+                            case FloatType -> cob.fsub();\n+                            case DoubleType -> cob.dsub();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case MulOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::mul(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.imul();\n+                            case LongType -> cob.lmul();\n+                            case FloatType -> cob.fmul();\n+                            case DoubleType -> cob.dmul();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case DivOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::div(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.idiv();\n+                            case LongType -> cob.ldiv();\n+                            case FloatType -> cob.fdiv();\n+                            case DoubleType -> cob.ddiv();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ModOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::rem(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.irem();\n+                            case LongType -> cob.lrem();\n+                            case FloatType -> cob.frem();\n+                            case DoubleType -> cob.drem();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case AndOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::and(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.iand();\n+                            case LongType -> cob.land();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case OrOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::or(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ior();\n+                            case LongType -> cob.lor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case XorOp op -> {\n+                        processOperands(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::xor(TypeKind)\n+                            case IntType, BooleanType, ByteType, ShortType, CharType -> cob.ixor();\n+                            case LongType -> cob.lxor();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case LshlOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shl(TypeKind)\n+                            case IntType -> cob.ishl();\n+                            case LongType -> cob.lshl();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case AshrOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::shr(TypeKind)\n+                            case IntType, ByteType, ShortType, CharType -> cob.ishr();\n+                            case LongType -> cob.lshr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case LshrOp op -> {\n+                        processOperands(op);\n+                        adjustRightTypeToInt(op);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::ushr(TypeKind)\n+                            case IntType, ByteType, ShortType, CharType -> cob.iushr();\n+                            case LongType -> cob.lushr();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case ArrayAccessOp.ArrayLoadOp op -> {\n+                        processOperands(op);\n+                        cob.arrayLoadInstruction(rvt);\n+                        push(op.result());\n+                    }\n+                    case ArrayAccessOp.ArrayStoreOp op -> {\n+                        processOperands(op);\n+                        cob.arrayStoreInstruction(toTypeKind(op.operands().get(2).type()));\n+                        push(op.result());\n+                    }\n+                    case ArrayLengthOp op -> {\n+                        processFirstOperand(op);\n+                        cob.arraylength();\n+                        push(op.result());\n+                    }\n+                    case BinaryTestOp op -> {\n+                        if (!isConditionForCondBrOp(op)) {\n+                            processOperands(op);\n+                            cob.ifThenElse(prepareReverseCondition(op), CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                            push(op.result());\n+                        }\n+                        \/\/ Processing is deferred to the CondBrOp, do not process the op result\n+                    }\n+                    case NewOp op -> {\n+                        switch (op.constructorType().returnType()) {\n+                            case ArrayType at -> {\n+                                processOperands(op);\n+                                if (at.dimensions() == 1) {\n+                                    ClassDesc ctd = at.componentType().toNominalDescriptor();\n+                                    if (ctd.isPrimitive()) {\n+                                        cob.newarray(TypeKind.from(ctd));\n+                                    } else {\n+                                        cob.anewarray(ctd);\n+                                    }\n+                                } else {\n+                                    cob.multianewarray(at.toNominalDescriptor(), op.operands().size());\n+                                }\n+                            }\n+                            case JavaType jt -> {\n+                                cob.new_(jt.toNominalDescriptor())\n+                                    .dup();\n+                                processOperands(op);\n+                                cob.invokespecial(\n+                                        ((JavaType) op.resultType()).toNominalDescriptor(),\n+                                        ConstantDescs.INIT_NAME,\n+                                        MethodRef.toNominalDescriptor(op.constructorType())\n+                                                 .changeReturnType(ConstantDescs.CD_void));\n+                            }\n+                            default ->\n+                                throw new IllegalArgumentException(\"Invalid return type: \"\n+                                                                    + op.constructorType().returnType());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case InvokeOp op -> {\n+                        processOperands(op);\n+                        \/\/ @@@ Enhance method descriptor to include how the method is to be invoked\n+                        \/\/ Example result of DirectMethodHandleDesc.toString()\n+                        \/\/   INTERFACE_VIRTUAL\/IntBinaryOperator::applyAsInt(IntBinaryOperator,int,int)int\n+                        \/\/ This will avoid the need to reflectively operate on the descriptor\n+                        \/\/ which may be insufficient in certain cases.\n+                        DirectMethodHandleDesc.Kind descKind;\n+                        try {\n+                            descKind = resolveToMethodHandleDesc(lookup, op.invokeDescriptor()).kind();\n+                        } catch (ReflectiveOperationException e) {\n+                            \/\/ @@@ Approximate fallback\n+                            if (op.hasReceiver()) {\n+                                descKind = DirectMethodHandleDesc.Kind.VIRTUAL;\n+                            } else {\n+                                descKind = DirectMethodHandleDesc.Kind.STATIC;\n+                            }\n+                        }\n+                        MethodRef md = op.invokeDescriptor();\n+                        cob.invokeInstruction(\n+                                switch (descKind) {\n+                                    case STATIC, INTERFACE_STATIC   -> Opcode.INVOKESTATIC;\n+                                    case VIRTUAL                    -> Opcode.INVOKEVIRTUAL;\n+                                    case INTERFACE_VIRTUAL          -> Opcode.INVOKEINTERFACE;\n+                                    case SPECIAL, INTERFACE_SPECIAL -> Opcode.INVOKESPECIAL;\n+                                    default ->\n+                                        throw new IllegalStateException(\"Bad method descriptor resolution: \"\n+                                                                        + op.opType() + \" > \" + op.invokeDescriptor());\n+                                },\n+                                ((JavaType) md.refType()).toNominalDescriptor(),\n+                                md.name(),\n+                                MethodRef.toNominalDescriptor(md.type()),\n+                                switch (descKind) {\n+                                    case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> true;\n+                                    default -> false;\n+                                });\n+\n+                        push(op.result());\n+                    }\n+                    case FieldAccessOp.FieldLoadOp op -> {\n+                        processOperands(op);\n+                        FieldRef fd = op.fieldDescriptor();\n+                        if (op.operands().isEmpty()) {\n+                            cob.getstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        } else {\n+                            cob.getfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        }\n+                        push(op.result());\n+                    }\n+                    case FieldAccessOp.FieldStoreOp op -> {\n+                        processOperands(op);\n+                        FieldRef fd = op.fieldDescriptor();\n+                        if (op.operands().size() == 1) {\n+                            cob.putstatic(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        } else {\n+                            cob.putfield(\n+                                    ((JavaType) fd.refType()).toNominalDescriptor(),\n+                                    fd.name(),\n+                                    ((JavaType) fd.type()).toNominalDescriptor());\n+                        }\n+                    }\n+                    case InstanceOfOp op -> {\n+                        processFirstOperand(op);\n+                        cob.instanceof_(((JavaType) op.type()).toNominalDescriptor());\n+                        push(op.result());\n+                    }\n+                    case CastOp op -> {\n+                        processFirstOperand(op);\n+                        cob.checkcast(((JavaType) op.type()).toNominalDescriptor());\n+                        push(op.result());\n+                    }\n+                    case LambdaOp op -> {\n+                        JavaType intfType = (JavaType)op.functionalInterface();\n+                        MethodTypeDesc mtd = MethodRef.toNominalDescriptor(op.invokableType());\n+                        try {\n+                            Class<?> intfClass = intfType.resolve(lookup);\n+                            processOperands(op.capturedValues());\n+                            ClassDesc[] captureTypes = op.capturedValues().stream()\n+                                    .map(Value::type).map(BytecodeGenerator::toClassDesc).toArray(ClassDesc[]::new);\n+                            int lambdaIndex = lambdaSink.size();\n+                            if (Quotable.class.isAssignableFrom(intfClass)) {\n+                                \/\/ @@@ double the captured values to enable LambdaMetafactory.FLAG_QUOTABLE\n+                                for (Value cv : op.capturedValues()) {\n+                                    load(cv);\n+                                }\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_ALT_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        \/\/ @@@ double the descriptor parameters\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(),\n+                                                          Stream.concat(Stream.of(captureTypes),\n+                                                                        Stream.of(captureTypes)).toList()),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                                  className,\n+                                                                  \"lambda$\" + lambdaIndex,\n+                                                                  mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd,\n+                                        LambdaMetafactory.FLAG_QUOTABLE,\n+                                        MethodHandleDesc.ofField(DirectMethodHandleDesc.Kind.STATIC_GETTER,\n+                                                                 className,\n+                                                                 \"lambda$\" + lambdaIndex + \"$op\",\n+                                                                 CD_String)));\n+                                quotable.set(lambdaSink.size());\n+                            } else {\n+                                cob.invokedynamic(DynamicCallSiteDesc.of(\n+                                        DMHD_LAMBDA_METAFACTORY,\n+                                        funcIntfMethodName(intfClass),\n+                                        MethodTypeDesc.of(intfType.toNominalDescriptor(), captureTypes),\n+                                        mtd,\n+                                        MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.STATIC,\n+                                                                  className,\n+                                                                  \"lambda$\" + lambdaIndex,\n+                                                                  mtd.insertParameterTypes(0, captureTypes)),\n+                                        mtd));\n+                            }\n+                            lambdaSink.add(op);\n+                        } catch (ReflectiveOperationException e) {\n+                            throw new IllegalArgumentException(e);\n+                        }\n+                        push(op.result());\n+                    }\n+                    default ->\n+                        throw new UnsupportedOperationException(\"Unsupported operation: \" + ops.get(i));\n+                }\n+            }\n+            Op top = b.terminatingOp();\n+            switch (top) {\n+                case CoreOps.ReturnOp op -> {\n+                    Value a = op.returnValue();\n+                    if (a == null) {\n+                        cob.return_();\n+                    } else {\n+                        processFirstOperand(op);\n+                        cob.returnInstruction(toTypeKind(a.type()));\n+                    }\n+                }\n+                case ThrowOp op -> {\n+                    processFirstOperand(op);\n+                    cob.athrow();\n+                }\n+                case BranchOp op -> {\n+                    assignBlockArguments(op.branch());\n+                    cob.goto_(getLabel(op.branch()));\n+                }\n+                case ConditionalBranchOp op -> {\n+                    if (getConditionForCondBrOp(op) instanceof CoreOps.BinaryTestOp btop) {\n+                        \/\/ Processing of the BinaryTestOp was deferred, so it can be merged with CondBrOp\n+                        processOperands(btop);\n+                        conditionalBranch(btop, op.trueBranch(), op.falseBranch());\n+                    } else {\n+                        processOperands(op);\n+                        conditionalBranch(Opcode.IFEQ, op, op.trueBranch(), op.falseBranch());\n+                    }\n+                }\n+                case ExceptionRegionEnter op -> {\n+                    assignBlockArguments(op.start());\n+                }\n+                case ExceptionRegionExit op -> {\n+                    assignBlockArguments(op.end());\n+                    cob.goto_(getLabel(op.end()));\n+                }\n+                default ->\n+                    throw new UnsupportedOperationException(\"Terminating operation not supported: \" + top);\n+            }\n+        }\n+    }\n+\n+    private boolean inBlockArgs(Op.Result res) {\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : res.declaringBlock().successors()) {\n+            if (s.arguments().contains(res)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void push(Op.Result res) {\n+        assert oprOnStack == null;\n+        if (res.type().equals(JavaType.VOID)) return;\n+        if (isNextUse(res)) {\n+            if (res.uses().size() > 1 || inBlockArgs(res)) {\n+                switch (toTypeKind(res.type()).slotSize()) {\n+                    case 1 -> cob.dup();\n+                    case 2 -> cob.dup2();\n+                }\n+                storeIfUsed(res);\n+            }\n+            oprOnStack = res;\n+        } else {\n+            storeIfUsed(res);\n+            oprOnStack = null;\n+        }\n+    }\n+\n+    \/\/ the rhs of any shift instruction must be int or smaller -> convert longs\n+    private void adjustRightTypeToInt(Op op) {\n+        TypeElement right = op.operands().getLast().type();\n+        if (right.equals(JavaType.LONG)) {\n+            cob.convertInstruction(toTypeKind(right), TypeKind.IntType);\n+        }\n+    }\n+\n+    private static Op getConditionForCondBrOp(CoreOps.ConditionalBranchOp op) {\n+        Value p = op.predicate();\n+        if (p.uses().size() != 1) {\n+            return null;\n+        }\n+\n+        if (p.declaringBlock() != op.parentBlock()) {\n+            return null;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : op.successors()) {\n+            if (s.arguments().contains(p)) {\n+                return null;\n+            }\n+        }\n+\n+        if (p instanceof Op.Result or) {\n+            return or.op();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private String funcIntfMethodName(Class<?> intfc) {\n+        String uniqueName = null;\n+        for (Method m : intfc.getMethods()) {\n+            \/\/ ensure it's SAM interface\n+            String methodName = m.getName();\n+            if (Modifier.isAbstract(m.getModifiers())\n+                    && (m.getReturnType() != String.class\n+                        || m.getParameterCount() != 0\n+                        || !methodName.equals(\"toString\"))\n+                    && (m.getReturnType() != int.class\n+                        || m.getParameterCount() != 0\n+                        || !methodName.equals(\"hashCode\"))\n+                    && (m.getReturnType() != boolean.class\n+                        || m.getParameterCount() != 1\n+                        || m.getParameterTypes()[0] != Object.class\n+                        || !methodName.equals(\"equals\"))) {\n+                if (uniqueName == null) {\n+                    uniqueName = methodName;\n+                } else if (!uniqueName.equals(methodName)) {\n+                    \/\/ too many abstract methods\n+                    throw new IllegalArgumentException(\"Not a single-method interface: \" + intfc.getName());\n+                }\n+            }\n+        }\n+        if (uniqueName == null) {\n+            throw new IllegalArgumentException(\"No method in: \" + intfc.getName());\n+        }\n+        return uniqueName;\n+    }\n+\n+    private void conditionalBranch(BinaryTestOp op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        conditionalBranch(prepareReverseCondition(op), op, trueBlock, falseBlock);\n+    }\n+\n+    private void conditionalBranch(Opcode reverseOpcode, Op op, Block.Reference trueBlock, Block.Reference falseBlock) {\n+        if (!needToAssignBlockArguments(falseBlock)) {\n+            cob.branchInstruction(reverseOpcode, getLabel(falseBlock));\n+        } else {\n+            cob.ifThen(reverseOpcode,\n+                bb -> {\n+                    assignBlockArguments(falseBlock);\n+                    bb.goto_(getLabel(falseBlock));\n+                });\n+        }\n+        assignBlockArguments(trueBlock);\n+        cob.goto_(getLabel(trueBlock));\n+    }\n+\n+    private Opcode prepareReverseCondition(BinaryTestOp op) {\n+        return switch (toTypeKind(op.operands().get(0).type())) {\n+            case IntType ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ICMPNE;\n+                    case NeqOp _ -> Opcode.IF_ICMPEQ;\n+                    case GtOp _ -> Opcode.IF_ICMPLE;\n+                    case GeOp _ -> Opcode.IF_ICMPLT;\n+                    case LtOp _ -> Opcode.IF_ICMPGE;\n+                    case LeOp _ -> Opcode.IF_ICMPGT;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on int\");\n+                };\n+            case ReferenceType ->\n+                switch (op) {\n+                    case EqOp _ -> Opcode.IF_ACMPNE;\n+                    case NeqOp _ -> Opcode.IF_ACMPEQ;\n+                    default ->\n+                        throw new UnsupportedOperationException(op.opName() + \" on Object\");\n+                };\n+            case FloatType -> {\n+                cob.fcmpg(); \/\/ FCMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            case LongType -> {\n+                cob.lcmp();\n+                yield reverseIfOpcode(op);\n+            }\n+            case DoubleType -> {\n+                cob.dcmpg(); \/\/CMPL?\n+                yield reverseIfOpcode(op);\n+            }\n+            default ->\n+                throw new UnsupportedOperationException(op.opName() + \" on \" + op.operands().get(0).type());\n+        };\n+    }\n+\n+    private static Opcode reverseIfOpcode(BinaryTestOp op) {\n+        return switch (op) {\n+            case EqOp _ -> Opcode.IFNE;\n+            case NeqOp _ -> Opcode.IFEQ;\n+            case GtOp _ -> Opcode.IFLE;\n+            case GeOp _ -> Opcode.IFLT;\n+            case LtOp _ -> Opcode.IFGE;\n+            case LeOp _ -> Opcode.IFGT;\n+            default ->\n+                throw new UnsupportedOperationException(op.opName());\n+        };\n+    }\n+\n+    private boolean needToAssignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+        boolean need = false;\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(sargs.get(i))) {\n+                need = true;\n+                allocateSlot(barg);\n+            }\n+        }\n+        return need;\n+    }\n+\n+    private void assignBlockArguments(Block.Reference ref) {\n+        List<Value> sargs = ref.arguments();\n+        List<Block.Parameter> bargs = ref.targetBlock().parameters();\n+        \/\/ First push successor arguments on the stack, then pop and assign\n+        \/\/ so as not to overwrite slots that are reused slots at different argument positions\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            Value value = sargs.get(i);\n+            if (!barg.uses().isEmpty() && !barg.equals(value)) {\n+                if (oprOnStack == value) {\n+                    oprOnStack = null;\n+                } else {\n+                    load(value);\n+                }\n+                storeIfUsed(barg);\n+            }\n+        }\n+    }\n+\n+    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l,\n+                                                            MethodRef d) throws ReflectiveOperationException {\n+        MethodHandle mh = d.resolveToHandle(l);\n+\n+        if (mh.describeConstable().isEmpty()) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        MethodHandleDesc mhd = mh.describeConstable().get();\n+        if (!(mhd instanceof DirectMethodHandleDesc dmhd)) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        return dmhd;\n+    }\n+\n+    static CoreOps.FuncOp quote(CoreOps.LambdaOp lop) {\n+        List<Value> captures = lop.capturedValues();\n+\n+        \/\/ Build the function type\n+        List<TypeElement> params = captures.stream()\n+                .map(v -> v.type() instanceof VarType vt ? vt.valueType() : v.type())\n+                .toList();\n+        FunctionType ft = FunctionType.functionType(CoreOps.QuotedOp.QUOTED_TYPE, params);\n+\n+        \/\/ Build the function that quotes the lambda\n+        return CoreOps.func(\"q\", ft).body(b -> {\n+            \/\/ Create variables as needed and obtain the captured values\n+            \/\/ for the copied lambda\n+            List<Value> outputCaptures = new ArrayList<>();\n+            for (int i = 0; i < captures.size(); i++) {\n+                Value c = captures.get(i);\n+                Block.Parameter p = b.parameters().get(i);\n+                if (c.type() instanceof VarType _) {\n+                    Value var = b.op(CoreOps.var(String.valueOf(i), p));\n+                    outputCaptures.add(var);\n+                } else {\n+                    outputCaptures.add(p);\n+                }\n+            }\n+\n+            \/\/ Quoted the lambda expression\n+            Value q = b.op(CoreOps.quoted(b.parentBody(), qb -> {\n+                \/\/ Map the lambda's parent block to the quoted block\n+                \/\/ We are copying lop in the context of the quoted block\n+                qb.context().mapBlock(lop.parentBlock(), qb);\n+                \/\/ Map the lambda's captured values\n+                qb.context().mapValues(captures, outputCaptures);\n+                \/\/ Return the lambda to be copied in the quoted operation\n+                return lop;\n+            }));\n+            b.op(CoreOps._return(q));\n+        });\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":1170,"deletions":0,"binary":false,"changes":1170,"status":"added"},{"patch":"@@ -0,0 +1,479 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.bytecode;\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static java.lang.classfile.attribute.StackMapFrameInfo.SimpleVerificationTypeInfo.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.constant.MethodTypeDesc;\n+\n+\n+public final class BytecodeLift {\n+\n+    private final Block.Builder entryBlock;\n+    private final CodeModel codeModel;\n+    private final Map<Label, Block.Builder> blockMap;\n+    private final Map<String, Op.Result> varMap;\n+    private final Deque<Value> stack;\n+    private Block.Builder currentBlock;\n+\n+    private static String varName(int slot, TypeKind tk) {\n+        return tk.typeName() + slot;\n+    }\n+\n+    private static TypeElement toTypeElement(StackMapFrameInfo.VerificationTypeInfo vti) {\n+        return switch (vti) {\n+            case ITEM_INTEGER -> JavaType.INT;\n+            case ITEM_FLOAT -> JavaType.FLOAT;\n+            case ITEM_DOUBLE -> JavaType.DOUBLE;\n+            case ITEM_LONG -> JavaType.LONG;\n+            case ITEM_NULL -> JavaType.J_L_OBJECT;\n+            case StackMapFrameInfo.ObjectVerificationTypeInfo ovti ->\n+                    JavaType.ofNominalDescriptor(ovti.classSymbol());\n+            case StackMapFrameInfo.UninitializedVerificationTypeInfo _ ->\n+                    JavaType.J_L_OBJECT;\n+            default ->\n+                throw new IllegalArgumentException(\"Unexpected VTI: \" + vti);\n+\n+        };\n+    }\n+\n+    private TypeElement toTypeElement(ClassEntry ce) {\n+        return JavaType.ofNominalDescriptor(ce.asSymbol());\n+    }\n+\n+    private BytecodeLift(Block.Builder entryBlock, MethodModel methodModel) {\n+        if (!methodModel.flags().has(AccessFlag.STATIC)) {\n+            throw new IllegalArgumentException(\"Unsuported lift of non-static method: \" + methodModel);\n+        }\n+        this.entryBlock = entryBlock;\n+        this.currentBlock = entryBlock;\n+        this.codeModel = methodModel.code().orElseThrow();\n+        this.varMap = new HashMap<>();\n+        this.stack = new ArrayDeque<>();\n+        List<Block.Parameter> bps = entryBlock.parameters();\n+        List<ClassDesc> mps = methodModel.methodTypeSymbol().parameterList();\n+        for (int i = 0, slot = 0; i < bps.size(); i++) {\n+            TypeKind tk = TypeKind.from(mps.get(i)).asLoadable();\n+            varStore(slot, tk, bps.get(i));\n+            slot += tk.slotSize();\n+        }\n+        this.blockMap = codeModel.findAttribute(Attributes.STACK_MAP_TABLE).map(sma ->\n+                sma.entries().stream().collect(Collectors.toUnmodifiableMap(\n+                        StackMapFrameInfo::target,\n+                        smfi -> entryBlock.block(smfi.stack().stream().map(BytecodeLift::toTypeElement).toList())))).orElse(Map.of());\n+    }\n+\n+    private void varStore(int slot, TypeKind tk, Value value) {\n+        varMap.compute(varName(slot, tk), (varName, var) -> {\n+            if (var == null) {\n+                return op(CoreOps.var(varName, value));\n+            } else {\n+                op(CoreOps.varStore(var, value));\n+                return var;\n+            }\n+        });\n+    }\n+\n+    private Op.Result var(int slot, TypeKind tk) {\n+        Op.Result r = varMap.get(varName(slot, tk));\n+        if (r == null) throw new IllegalArgumentException(\"Undeclared variable: \" + slot + \"-\" + tk); \/\/ @@@ these cases may need lazy var injection\n+        return r;\n+    }\n+\n+    private Op.Result op(Op op) {\n+        return currentBlock.op(op);\n+    }\n+\n+    \/\/ Lift to core dialect\n+    public static CoreOps.FuncOp lift(byte[] classdata, String methodName) {\n+        return lift(classdata, methodName, null);\n+    }\n+\n+    public static CoreOps.FuncOp lift(byte[] classdata, String methodName, MethodTypeDesc methodType) {\n+        return lift(ClassFile.of(\n+                ClassFile.DebugElementsOption.DROP_DEBUG,\n+                ClassFile.LineNumbersOption.DROP_LINE_NUMBERS).parse(classdata).methods().stream()\n+                        .filter(mm -> mm.methodName().equalsString(methodName) && (methodType == null || mm.methodTypeSymbol().equals(methodType)))\n+                        .findFirst().orElseThrow(() -> new IllegalArgumentException(\"Unknown method: \" + methodName)));\n+    }\n+\n+    public static CoreOps.FuncOp lift(MethodModel methodModel) {\n+        return CoreOps.func(\n+                methodModel.methodName().stringValue(),\n+                MethodRef.ofNominalDescriptor(methodModel.methodTypeSymbol())).body(entryBlock ->\n+                        new BytecodeLift(entryBlock, methodModel).lift());\n+    }\n+\n+    private Block.Builder getBlock(Label l) {\n+        Block.Builder bb = blockMap.get(l);\n+        if (bb == null) {\n+            if (currentBlock == null) {\n+                throw new IllegalArgumentException(\"Block without an stack frame detected.\");\n+            } else {\n+                return newBlock();\n+            }\n+        }\n+        return bb;\n+    }\n+\n+    private Block.Builder newBlock() {\n+        return entryBlock.block(stack.stream().map(Value::type).toList());\n+    }\n+\n+    private void moveTo(Block.Builder next) {\n+        currentBlock = next;\n+        \/\/ Stack is reconstructed from block parameters\n+        stack.clear();\n+        if (currentBlock != null) {\n+            currentBlock.parameters().forEach(stack::add);\n+        }\n+    }\n+\n+    private void endOfFlow() {\n+        currentBlock = null;\n+        \/\/ Flow discontinued, stack cleared to be ready for the next label target\n+        stack.clear();\n+    }\n+\n+    private void lift() {\n+        final Map<ExceptionCatch, Op.Result> exceptionRegionsMap = new HashMap<>();\n+\n+        List<CodeElement> elements = codeModel.elementList();\n+        for (int i = 0; i < elements.size(); i++) {\n+            switch (elements.get(i)) {\n+                case ExceptionCatch _ -> {\n+                    \/\/ Exception blocks are inserted by label target (below)\n+                }\n+                case LabelTarget lt -> {\n+                    \/\/ Start of a new block\n+                    Block.Builder next = getBlock(lt.label());\n+                    if (currentBlock != null) {\n+                        \/\/ Implicit goto next block, add explicitly\n+                        \/\/ Use stack content as next block arguments\n+                        op(CoreOps.branch(next.successor(List.copyOf(stack))));\n+                    }\n+                    moveTo(next);\n+                    \/\/ Insert relevant tryStart and construct handler blocks, all in reversed order\n+                    for (ExceptionCatch ec : codeModel.exceptionHandlers().reversed()) {\n+                        if (lt.label() == ec.tryStart()) {\n+                            Block.Builder handler = getBlock(ec.handler());\n+                            \/\/ Create start block\n+                            next = newBlock();\n+                            Op ere = CoreOps.exceptionRegionEnter(next.successor(List.copyOf(stack)), handler.successor());\n+                            op(ere);\n+                            \/\/ Store ERE into map for exit\n+                            exceptionRegionsMap.put(ec, ere.result());\n+                            moveTo(next);\n+                        }\n+                    }\n+                    \/\/ Insert relevant tryEnd blocks in normal order\n+                    for (ExceptionCatch ec : codeModel.exceptionHandlers()) {\n+                        if (lt.label() == ec.tryEnd()) {\n+                            \/\/ Create exit block with parameters constructed from the stack\n+                            next = newBlock();\n+                            op(CoreOps.exceptionRegionExit(exceptionRegionsMap.get(ec), next.successor()));\n+                            moveTo(next);\n+                        }\n+                    }\n+                }\n+                case BranchInstruction inst when inst.opcode().isUnconditionalBranch() -> {\n+                    op(CoreOps.branch(getBlock(inst.target()).successor(List.copyOf(stack))));\n+                    endOfFlow();\n+                }\n+                case BranchInstruction inst -> {\n+                    \/\/ Conditional branch\n+                    Value operand = stack.pop();\n+                    Op cop = switch (inst.opcode()) {\n+                        case IFNE -> CoreOps.eq(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFEQ -> CoreOps.neq(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFGE -> CoreOps.lt(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFLE -> CoreOps.gt(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFGT -> CoreOps.le(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFLT -> CoreOps.ge(operand, op(CoreOps.constant(JavaType.INT, 0)));\n+                        case IFNULL -> CoreOps.neq(operand, op(CoreOps.constant(JavaType.J_L_OBJECT, Op.NULL_ATTRIBUTE_VALUE)));\n+                        case IFNONNULL -> CoreOps.eq(operand, op(CoreOps.constant(JavaType.J_L_OBJECT, Op.NULL_ATTRIBUTE_VALUE)));\n+                        case IF_ICMPNE -> CoreOps.eq(stack.pop(), operand);\n+                        case IF_ICMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                        case IF_ICMPGE -> CoreOps.lt(stack.pop(), operand);\n+                        case IF_ICMPLE -> CoreOps.gt(stack.pop(), operand);\n+                        case IF_ICMPGT -> CoreOps.le(stack.pop(), operand);\n+                        case IF_ICMPLT -> CoreOps.ge(stack.pop(), operand);\n+                        case IF_ACMPEQ -> CoreOps.neq(stack.pop(), operand);\n+                        case IF_ACMPNE -> CoreOps.eq(stack.pop(), operand);\n+                        default -> throw new UnsupportedOperationException(\"Unsupported branch instruction: \" + inst);\n+                    };\n+                    if (!stack.isEmpty()) {\n+                        throw new UnsupportedOperationException(\"Operands on stack for branch not supported\");\n+                    }\n+                    Block.Builder next = currentBlock.block();\n+                    op(CoreOps.conditionalBranch(op(cop),\n+                            next.successor(),\n+                            getBlock(inst.target()).successor()));\n+                    moveTo(next);\n+                }\n+    \/\/                case LookupSwitchInstruction si -> {\n+    \/\/                    \/\/ Default label is first successor\n+    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+    \/\/                    addSuccessors(si.cases(), blockMap, b);\n+    \/\/                }\n+    \/\/                case TableSwitchInstruction si -> {\n+    \/\/                    \/\/ Default label is first successor\n+    \/\/                    b.addSuccessor(blockMap.get(si.defaultTarget()));\n+    \/\/                    addSuccessors(si.cases(), blockMap, b);\n+    \/\/                }\n+                case ReturnInstruction inst when inst.typeKind() == TypeKind.VoidType -> {\n+                    op(CoreOps._return());\n+                    endOfFlow();\n+                }\n+                case ReturnInstruction _ -> {\n+                    op(CoreOps._return(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case ThrowInstruction _ -> {\n+                    op(CoreOps._throw(stack.pop()));\n+                    endOfFlow();\n+                }\n+                case LoadInstruction inst -> {\n+                    stack.push(op(CoreOps.varLoad(var(inst.slot(), inst.typeKind()))));\n+                }\n+                case StoreInstruction inst -> {\n+                    varStore(inst.slot(), inst.typeKind(), stack.pop());\n+                }\n+                case IncrementInstruction inst -> {\n+                    varStore(inst.slot(), TypeKind.IntType, op(CoreOps.add(\n+                            op(CoreOps.varLoad(var(inst.slot(), TypeKind.IntType))),\n+                            op(CoreOps.constant(JavaType.INT, inst.constant())))));\n+                }\n+                case ConstantInstruction inst -> {\n+                    stack.push(op(switch (inst.constantValue()) {\n+                        case ClassDesc v -> CoreOps.constant(JavaType.J_L_CLASS, JavaType.ofNominalDescriptor(v));\n+                        case Double v -> CoreOps.constant(JavaType.DOUBLE, v);\n+                        case Float v -> CoreOps.constant(JavaType.FLOAT, v);\n+                        case Integer v -> CoreOps.constant(JavaType.INT, v);\n+                        case Long v -> CoreOps.constant(JavaType.LONG, v);\n+                        case String v -> CoreOps.constant(JavaType.J_L_STRING, v);\n+                        default ->\n+                            \/\/ @@@ MethodType, MethodHandle, ConstantDynamic\n+                            throw new IllegalArgumentException(\"Unsupported constant value: \" + inst.constantValue());\n+                    }));\n+                }\n+                case ConvertInstruction inst -> {\n+                    stack.push(op(CoreOps.conv(switch (inst.toType()) {\n+                        case ByteType -> JavaType.BYTE;\n+                        case ShortType -> JavaType.SHORT;\n+                        case IntType -> JavaType.INT;\n+                        case FloatType -> JavaType.FLOAT;\n+                        case LongType -> JavaType.LONG;\n+                        case DoubleType -> JavaType.DOUBLE;\n+                        case CharType -> JavaType.CHAR;\n+                        case BooleanType -> JavaType.BOOLEAN;\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported conversion target: \" + inst.toType());\n+                    }, stack.pop())));\n+                }\n+                case OperatorInstruction inst -> {\n+                    Value operand = stack.pop();\n+                    stack.push(op(switch (inst.opcode()) {\n+                        case IADD, LADD, FADD, DADD ->\n+                                CoreOps.add(stack.pop(), operand);\n+                        case ISUB, LSUB, FSUB, DSUB ->\n+                                CoreOps.sub(stack.pop(), operand);\n+                        case IMUL, LMUL, FMUL, DMUL ->\n+                                CoreOps.mul(stack.pop(), operand);\n+                        case IDIV, LDIV, FDIV, DDIV ->\n+                                CoreOps.div(stack.pop(), operand);\n+                        case IREM, LREM, FREM, DREM ->\n+                                CoreOps.mod(stack.pop(), operand);\n+                        case INEG, LNEG, FNEG, DNEG ->\n+                                CoreOps.neg(operand);\n+                        case ARRAYLENGTH ->\n+                                CoreOps.arrayLength(operand);\n+                        case IAND, LAND ->\n+                                CoreOps.and(stack.pop(), operand);\n+                        case IOR, LOR ->\n+                                CoreOps.or(stack.pop(), operand);\n+                        case IXOR, LXOR ->\n+                                CoreOps.xor(stack.pop(), operand);\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported operator opcode: \" + inst.opcode());\n+                    }));\n+                }\n+                case FieldInstruction inst -> {\n+                        FieldRef fd = FieldRef.field(\n+                                JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                inst.name().stringValue(),\n+                                JavaType.ofNominalDescriptor(inst.typeSymbol()));\n+                        switch (inst.opcode()) {\n+                            case GETFIELD ->\n+                                stack.push(op(CoreOps.fieldLoad(fd, stack.pop())));\n+                            case GETSTATIC ->\n+                                stack.push(op(CoreOps.fieldLoad(fd)));\n+                            case PUTFIELD -> {\n+                                Value value = stack.pop();\n+                                stack.push(op(CoreOps.fieldStore(fd, stack.pop(), value)));\n+                            }\n+                            case PUTSTATIC ->\n+                                stack.push(op(CoreOps.fieldStore(fd, stack.pop())));\n+                            default ->\n+                                throw new IllegalArgumentException(\"Unsupported field opcode: \" + inst.opcode());\n+                        }\n+                }\n+                case ArrayStoreInstruction _ -> {\n+                    Value value = stack.pop();\n+                    Value index = stack.pop();\n+                    op(CoreOps.arrayStoreOp(stack.pop(), index, value));\n+                }\n+                case ArrayLoadInstruction _ -> {\n+                    Value index = stack.pop();\n+                    stack.push(op(CoreOps.arrayLoadOp(stack.pop(), index)));\n+                }\n+                case InvokeInstruction inst -> {\n+                    FunctionType mType = MethodRef.ofNominalDescriptor(inst.typeSymbol());\n+                    List<Value> operands = new ArrayList<>();\n+                    for (var _ : mType.parameterTypes()) {\n+                        operands.add(stack.pop());\n+                    }\n+                    MethodRef mDesc = MethodRef.method(\n+                            JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                            inst.name().stringValue(),\n+                            mType);\n+                    Op.Result result = switch (inst.opcode()) {\n+                        case INVOKEVIRTUAL, INVOKEINTERFACE -> {\n+                            operands.add(stack.pop());\n+                            yield op(CoreOps.invoke(mDesc, operands.reversed()));\n+                        }\n+                        case INVOKESTATIC ->\n+                            op(CoreOps.invoke(mDesc, operands.reversed()));\n+                        case INVOKESPECIAL -> {\n+                            if (inst.name().equalsString(ConstantDescs.INIT_NAME)) {\n+                                yield op(CoreOps._new(\n+                                        FunctionType.functionType(\n+                                                mDesc.refType(),\n+                                                mType.parameterTypes()),\n+                                        operands.reversed()));\n+                            } else {\n+                                operands.add(stack.pop());\n+                                yield op(CoreOps.invoke(mDesc, operands.reversed()));\n+                            }\n+                        }\n+                        default ->\n+                            throw new IllegalArgumentException(\"Unsupported invocation opcode: \" + inst.opcode());\n+                    };\n+                    if (!result.type().equals(JavaType.VOID)) {\n+                        stack.push(result);\n+                    }\n+                }\n+                case NewObjectInstruction _ -> {\n+                    \/\/ Skip over this and the dup to process the invoke special\n+                    if (i + 2 < elements.size() - 1\n+                            && elements.get(i + 1) instanceof StackInstruction dup\n+                            && dup.opcode() == Opcode.DUP) {\n+                        i++;\n+                    } else {\n+                        throw new UnsupportedOperationException(\"New must be followed by dup\");\n+                    }\n+                }\n+                case NewPrimitiveArrayInstruction inst -> {\n+                    stack.push(op(CoreOps.newArray(\n+                            switch (inst.typeKind()) {\n+                                case BooleanType -> JavaType.BOOLEAN_ARRAY;\n+                                case ByteType -> JavaType.BYTE_ARRAY;\n+                                case CharType -> JavaType.CHAR_ARRAY;\n+                                case DoubleType -> JavaType.DOUBLE_ARRAY;\n+                                case FloatType -> JavaType.FLOAT_ARRAY;\n+                                case IntType -> JavaType.INT_ARRAY;\n+                                case LongType -> JavaType.LONG_ARRAY;\n+                                case ShortType -> JavaType.SHORT_ARRAY;\n+                                default ->\n+                                        throw new UnsupportedOperationException(\"Unsupported new primitive array type: \" + inst.typeKind());\n+                            },\n+                            stack.pop())));\n+                }\n+                case NewReferenceArrayInstruction inst -> {\n+                    stack.push(op(CoreOps.newArray(\n+                            JavaType.ofNominalDescriptor(inst.componentType().asSymbol().arrayType()),\n+                            stack.pop())));\n+                }\n+                case NewMultiArrayInstruction inst -> {\n+                    stack.push(op(CoreOps._new(\n+                            FunctionType.functionType(\n+                                    JavaType.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                    Collections.nCopies(inst.dimensions(), JavaType.INT)),\n+                            IntStream.range(0, inst.dimensions()).mapToObj(_ -> stack.pop()).toList().reversed())));\n+                }\n+                case TypeCheckInstruction inst when inst.opcode() == Opcode.CHECKCAST -> {\n+                    stack.push(op(CoreOps.cast(JavaType.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                }\n+                case StackInstruction inst -> {\n+                    switch (inst.opcode()) {\n+                        case POP, POP2 -> stack.pop(); \/\/ @@@ check the type width\n+                        case DUP, DUP2 -> stack.push(stack.peek());\n+                        \/\/@@@ implement all other stack ops\n+                        default ->\n+                            throw new UnsupportedOperationException(\"Unsupported stack instruction: \" + inst);\n+                    }\n+                }\n+                case Instruction inst ->\n+                    throw new UnsupportedOperationException(\"Unsupported instruction: \" + inst.opcode().name());\n+                default ->\n+                    throw new UnsupportedOperationException(\"Unsupported code element: \" + elements.get(i));\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":479,"deletions":0,"binary":false,"changes":479,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for generating bytecode from code models and for generating code models from bytecode.\n+ *\/\n+package java.lang.reflect.code.bytecode;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,681 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.interpreter;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+public final class Interpreter {\n+    private Interpreter() {\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class InterpreterException extends RuntimeException {\n+        public InterpreterException(Throwable cause) {\n+            super(cause);\n+        }\n+    }\n+\n+    static InterpreterException interpreterException(Throwable cause) {\n+        return new InterpreterException(cause);\n+    }\n+\n+    record BlockContext(Block b, Map<Value, Object> values) {\n+    }\n+\n+    static final class OpContext {\n+        final Deque<BlockContext> stack = new ArrayDeque<>();\n+        final Deque<ExceptionRegionRecord> erStack = new ArrayDeque<>();\n+\n+        Object getValue(Value v) {\n+            \/\/ @@@ Only dominating values are accessible\n+            BlockContext bc = findContext(v);\n+            if (bc != null) {\n+                return bc.values.get(v);\n+            } else {\n+                throw interpreterException(new IllegalArgumentException(\"Undefined value: \" + v));\n+            }\n+        }\n+\n+        Object setValue(Value v, Object o) {\n+            BlockContext bc = findContext(v);\n+            if (bc != null) {\n+                throw interpreterException(new IllegalArgumentException(\"Value already defined: \" + v));\n+            }\n+            stack.peek().values.put(v, o);\n+            return o;\n+        }\n+\n+        BlockContext findContext(Value v) {\n+            Optional<BlockContext> ob = stack.stream().filter(b -> b.values.containsKey(v)).findFirst();\n+            return ob.orElse(null);\n+        }\n+\n+        boolean contains(Block.Reference s) {\n+            Block sb = s.targetBlock();\n+            return stack.stream().anyMatch(bc -> bc.b.equals(sb));\n+        }\n+\n+        void successor(Block.Reference sb) {\n+            List<Object> sbValues = sb.arguments().stream().map(this::getValue).toList();\n+\n+            Block b = sb.targetBlock();\n+            Map<Value, Object> bValues = new HashMap<>();\n+            for (int i = 0; i < sbValues.size(); i++) {\n+                bValues.put(b.parameters().get(i), sbValues.get(i));\n+            }\n+\n+            if (contains(sb)) {\n+                \/\/ if block is already dominating pop back up from the back branch to the block\n+                \/\/ before the successor block\n+                while (!stack.peek().b.equals(sb.targetBlock())) {\n+                    stack.pop();\n+                }\n+                stack.pop();\n+            }\n+            stack.push(new BlockContext(b, bValues));\n+        }\n+\n+        void successor(Block b, Map<Value, Object> bValues) {\n+            stack.push(new BlockContext(b, bValues));\n+        }\n+\n+        void popTo(BlockContext bc) {\n+            while (!stack.peek().equals(bc)) {\n+                stack.pop();\n+            }\n+        }\n+\n+        void pushExceptionRegion(ExceptionRegionRecord erb) {\n+            erStack.push(erb);\n+        }\n+\n+        void popExceptionRegion(CoreOps.ExceptionRegionEnter ers) {\n+            if (erStack.peek().ers != ers) {\n+                \/\/ @@@ Use internal exception type\n+                throw interpreterException(new IllegalStateException(\"Mismatched exception regions\"));\n+            }\n+            erStack.pop();\n+        }\n+\n+        Block exception(MethodHandles.Lookup l, Throwable e) {\n+            \/\/ Find the first matching exception region\n+            \/\/ with a catch block whose argument type is assignable-compatible to the throwable\n+            ExceptionRegionRecord er;\n+            Block cb = null;\n+            while ((er = erStack.poll()) != null &&\n+                    (cb = er.match(l, e)) == null) {\n+            }\n+\n+            if (er == null) {\n+                return null;\n+            }\n+\n+            \/\/ Pop the block context to the block defining the start of the exception region\n+            popTo(er.mark);\n+            return cb;\n+        }\n+    }\n+\n+    static final class VarBox\n+            implements CoreOps.Var<Object> {\n+        Object value;\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        VarBox(Object value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    record ClosureRecord(CoreOps.ClosureOp op,\n+                         Map<Value, Object> capturedValues) {\n+    }\n+\n+    record TupleRecord(List<Object> components) {\n+        Object getComponent(int index) {\n+            return components.get(index);\n+        }\n+\n+        TupleRecord with(int index, Object value) {\n+            List<Object> copy = new ArrayList<>(components);\n+            copy.set(index, value);\n+            return new TupleRecord(copy);\n+        }\n+    }\n+\n+    record ExceptionRegionRecord(BlockContext mark, CoreOps.ExceptionRegionEnter ers)\n+            implements CoreOps.ExceptionRegion {\n+        Block match(MethodHandles.Lookup l, Throwable e) {\n+            for (Block.Reference catchBlock : ers.catchBlocks()) {\n+                Block target = catchBlock.targetBlock();\n+                List<Block.Parameter> args = target.parameters();\n+                if (args.size() != 1) {\n+                    throw interpreterException(new IllegalStateException(\"Catch block must have one argument\"));\n+                }\n+                TypeElement et = args.get(0).type();\n+                if (et instanceof VarType vt) {\n+                    et = vt.valueType();\n+                }\n+                if (resolveToClass(l, et).isInstance(e)) {\n+                    return target;\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(T op,\n+                  Object... args) {\n+        return invoke(MethodHandles.publicLookup(), op, args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  Object... args) {\n+        return invoke(l, op, new ArrayList<>(Arrays.asList(args)));\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  Map<Value, Object> capturedValues,\n+                  Object... args) {\n+        return invoke(l, op, capturedValues, new ArrayList<>(Arrays.asList(args)));\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(T op,\n+                  List<Object> args) {\n+        return invoke(MethodHandles.publicLookup(), op, args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(T op,\n+                  Map<Value, Object> capturedValues,\n+                  List<Object> args) {\n+        return invoke(MethodHandles.publicLookup(), op, capturedValues, args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T op,\n+                  List<Object> args) {\n+        return invoke(l, op, Map.of(), args);\n+    }\n+\n+    public static <T extends Op & Op.Invokable>\n+    Object invoke(MethodHandles.Lookup l, T invokableOp,\n+                  Map<Value, Object> capturedValues,\n+                  List<Object> args) {\n+        Body r = invokableOp.bodies().get(0);\n+        return invoke(l, r, capturedValues, new OpContext(), args);\n+\n+    }\n+    static Object invoke(MethodHandles.Lookup l, Body r,\n+                                 Map<Value, Object> capturedValues, OpContext oc,\n+                                 List<Object> args) {\n+        return invoke(l,r.entryBlock(), capturedValues, oc, args);\n+    }\n+\n+    private static Object invoke(MethodHandles.Lookup l, Block first,\n+                  Map<Value, Object> capturedValues, OpContext oc,\n+                  List<Object> args) {\n+\n+        if (args.size() != first.parameters().size()) {\n+            throw interpreterException(new IllegalArgumentException(\"Incorrect number of arguments\"));\n+        }\n+        Map<Value, Object> values = new HashMap<>();\n+        for (int i = 0; i < first.parameters().size(); i++) {\n+            values.put(first.parameters().get(i), args.get(i));\n+        }\n+\n+        \/\/ Note that first block cannot have any successors so the queue will have at least one entry\n+        oc.stack.push(new BlockContext(first, values));\n+        capturedValues.forEach(oc::setValue);\n+        while (true) {\n+            BlockContext bc = oc.stack.peek();\n+\n+            \/\/ Execute all but the terminating operation\n+            int nops = bc.b.ops().size();\n+            try {\n+                for (int i = 0; i < nops - 1; i++) {\n+                    Op op = bc.b.ops().get(i);\n+                    assert !(op instanceof Op.Terminating) : op.opName();\n+\n+                    Object result = exec(l, oc, op);\n+                    oc.setValue(op.result(), result);\n+                }\n+            } catch (InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                processThrowable(oc, l, t);\n+                continue;\n+            }\n+\n+            \/\/ Execute the terminating operation\n+            Op to = bc.b.terminatingOp();\n+            if (to instanceof CoreOps.ConditionalBranchOp cb) {\n+                boolean p;\n+                Object bop = oc.getValue(cb.predicate());\n+                if (bop instanceof Boolean bp) {\n+                    p = bp;\n+                } else if (bop instanceof Integer ip) {\n+                    \/\/ @@@ This is required when lifting up from bytecode, since boolean values\n+                    \/\/ are erased to int values, abd the bytecode lifting implementation is not currently\n+                    \/\/ sophisticated enough to recover the type information\n+                    p = ip != 0;\n+                } else {\n+                    throw interpreterException(\n+                            new UnsupportedOperationException(\"Unsupported type input to operation: \" + cb));\n+                }\n+                Block.Reference sb = p ? cb.trueBranch() : cb.falseBranch();\n+                oc.successor(sb);\n+            } else if (to instanceof CoreOps.BranchOp b) {\n+                Block.Reference sb = b.branch();\n+\n+                oc.successor(sb);\n+            } else if (to instanceof CoreOps.ThrowOp _throw) {\n+                Throwable t = (Throwable) oc.getValue(_throw.argument());\n+                processThrowable(oc, l, t);\n+            } else if (to instanceof CoreOps.ReturnOp ret) {\n+                Value rv = ret.returnValue();\n+                return rv == null ? null : oc.getValue(rv);\n+            } else if (to instanceof CoreOps.YieldOp yop) {\n+                Value yv = yop.yieldValue();\n+                return yv == null ? null : oc.getValue(yv);\n+            } else if (to instanceof CoreOps.ExceptionRegionEnter ers) {\n+                var er = new ExceptionRegionRecord(oc.stack.peek(), ers);\n+                oc.setValue(ers.result(), er);\n+\n+                oc.pushExceptionRegion(er);\n+\n+                oc.successor(ers.start());\n+            } else if (to instanceof CoreOps.ExceptionRegionExit ere) {\n+                oc.popExceptionRegion(ere.regionStart());\n+\n+                oc.successor(ere.end());\n+            } else {\n+                throw interpreterException(\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+            }\n+        }\n+    }\n+\n+    static <T extends Op & Op.Invokable>\n+    Object interpretBody(MethodHandles.Lookup l, Body r,\n+                         OpContext oc) {\n+        return invoke(l, r, Map.of(), oc, List.of());\n+    }\n+\n+    static void processThrowable(OpContext oc, MethodHandles.Lookup l, Throwable t) {\n+        \/\/ Find a matching catch block\n+        Block cb = oc.exception(l, t);\n+        if (cb == null) {\n+            \/\/ If there is no matching catch bock then rethrow back to the caller\n+            eraseAndThrow(t);\n+            throw new InternalError(\"should not reach here\");\n+        }\n+\n+        \/\/ Add a new block context to the catch block with the exception as the argument\n+        Map<Value, Object> bValues = new HashMap<>();\n+        Block.Parameter eArg = cb.parameters().get(0);\n+        if (eArg.type() instanceof VarType) {\n+            bValues.put(eArg, new VarBox(t));\n+        } else {\n+            bValues.put(eArg, t);\n+        }\n+        oc.successor(cb, bValues);\n+    }\n+\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> void eraseAndThrow(Throwable e) throws E {\n+        throw (E) e;\n+    }\n+\n+    static Object exec(MethodHandles.Lookup l, OpContext oc, Op o) {\n+        if (o instanceof CoreOps.ConstantOp co) {\n+            if (co.resultType().equals(JavaType.J_L_CLASS)) {\n+                return resolveToClass(l, (JavaType) co.value());\n+            } else {\n+                return co.value();\n+            }\n+        } else if (o instanceof CoreOps.FuncCallOp fco) {\n+            String name = fco.funcName();\n+\n+            \/\/ Find top-level op\n+            Op top = fco;\n+            while (top.ancestorBody() != null) {\n+                top = top.ancestorBody().parentOp();\n+            }\n+\n+            \/\/ Ensure top-level op is a module and function name\n+            \/\/ is in the module's function table\n+            if (top instanceof CoreOps.ModuleOp mop) {\n+                CoreOps.FuncOp funcOp = mop.functionTable().get(name);\n+                if (funcOp == null) {\n+                    throw interpreterException(\n+                            new IllegalStateException\n+                                    (\"Function \" + name + \" cannot be resolved: not in module's function table\"));\n+                }\n+\n+                Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+                return Interpreter.invoke(funcOp, values);\n+            } else {\n+                throw interpreterException(\n+                        new IllegalStateException(\n+                                \"Function \" + name + \" cannot be resolved: top level op is not a module\"));\n+            }\n+        } else if (o instanceof CoreOps.InvokeOp co) {\n+            MethodHandle mh;\n+            if (co.hasReceiver()) {\n+                mh = methodHandle(l, co.invokeDescriptor());\n+            } else {\n+                mh = methodStaticHandle(l, co.invokeDescriptor());\n+            }\n+            MethodType target = resolveToMethodType(l, o.opType());\n+            mh = mh.asType(target).asFixedArity();\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            return invoke(mh, values);\n+        } else if (o instanceof CoreOps.NewOp no) {\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            JavaType nType = (JavaType) no.constructorType().returnType();\n+            if (nType instanceof ArrayType at) {\n+                if (values.length > at.dimensions()) {\n+                    throw interpreterException(new IllegalArgumentException(\"Bad constructor NewOp: \" + no));\n+                }\n+                int[] lengths = Stream.of(values).mapToInt(v -> (int) v).toArray();\n+                for (int length : lengths) {\n+                    nType = ((ArrayType)nType).componentType();\n+                }\n+                return Array.newInstance(resolveToClass(l, nType), lengths);\n+            } else {\n+                MethodHandle mh = constructorHandle(l, no.constructorType());\n+                return invoke(mh, values);\n+            }\n+        } else if (o instanceof CoreOps.QuotedOp qo) {\n+            Map<Value, Object> capturedValues = qo.capturedValues().stream()\n+                    .collect(toMap(v -> v, oc::getValue, (v, _) -> v, LinkedHashMap::new));\n+            return new Quoted(qo.quotedOp(), capturedValues);\n+        } else if (o instanceof CoreOps.LambdaOp lo) {\n+            Map<Value, Object> capturedValues = lo.capturedValues().stream()\n+                    .collect(toMap(v -> v, oc::getValue, (v, _) -> v, LinkedHashMap::new));\n+            Class<?> fi = resolveToClass(l, lo.functionalInterface());\n+\n+            MethodHandle fProxy = INVOKE_LAMBDA_MH.bindTo(l).bindTo(lo).bindTo(capturedValues)\n+                    .asCollector(Object[].class, lo.body().entryBlock().parameters().size());\n+            Object fiInstance = MethodHandleProxies.asInterfaceInstance(fi, fProxy);\n+\n+            \/\/ If a quotable lambda proxy again to implement Quotable\n+            if (Quotable.class.isAssignableFrom(fi)) {\n+                return Proxy.newProxyInstance(l.lookupClass().getClassLoader(), new Class<?>[]{fi},\n+                        (_, method, args) -> {\n+                            if (method.getDeclaringClass() == Quotable.class) {\n+                                \/\/ Implement Quotable::quoted\n+                                return new Quoted(lo, capturedValues);\n+                            } else {\n+                                \/\/ Delegate to FI instance\n+                                return method.invoke(fiInstance, args);\n+                            }\n+                        });\n+            } else {\n+                return fiInstance;\n+            }\n+        } else if (o instanceof CoreOps.ClosureOp co) {\n+            Map<Value, Object> capturedValues = co.capturedValues().stream()\n+                    .collect(toMap(v -> v, oc::getValue));\n+            return new ClosureRecord(co, capturedValues);\n+        } else if (o instanceof CoreOps.ClosureCallOp cco) {\n+            List<Object> values = o.operands().stream().map(oc::getValue).toList();\n+            ClosureRecord cr = (ClosureRecord) values.get(0);\n+\n+            return Interpreter.invoke(l, cr.op(), cr.capturedValues, values.subList(1, values.size()));\n+        } else if (o instanceof CoreOps.VarOp vo) {\n+            return new VarBox(oc.getValue(o.operands().get(0)));\n+        } else if (o instanceof CoreOps.VarAccessOp.VarLoadOp vlo) {\n+            \/\/ Cast to CoreOps.Var, since the instance may have originated as an external instance\n+            \/\/ via a captured value map\n+            CoreOps.Var<?> vb = (CoreOps.Var<?>) oc.getValue(o.operands().get(0));\n+            return vb.value();\n+        } else if (o instanceof CoreOps.VarAccessOp.VarStoreOp vso) {\n+            VarBox vb = (VarBox) oc.getValue(o.operands().get(0));\n+            vb.value = oc.getValue(o.operands().get(1));\n+            return null;\n+        } else if (o instanceof CoreOps.TupleOp to) {\n+            List<Object> values = o.operands().stream().map(oc::getValue).toList();\n+            return new TupleRecord(values);\n+        } else if (o instanceof CoreOps.TupleLoadOp tlo) {\n+            TupleRecord tb = (TupleRecord) oc.getValue(o.operands().get(0));\n+            return tb.getComponent(tlo.index());\n+        } else if (o instanceof CoreOps.TupleWithOp two) {\n+            TupleRecord tb = (TupleRecord) oc.getValue(o.operands().get(0));\n+            return tb.with(two.index(), oc.getValue(o.operands().get(1)));\n+        } else if (o instanceof CoreOps.FieldAccessOp.FieldLoadOp fo) {\n+            if (fo.operands().isEmpty()) {\n+                VarHandle vh = fieldStaticHandle(l, fo.fieldDescriptor());\n+                return vh.get();\n+            } else {\n+                Object v = oc.getValue(o.operands().get(0));\n+                VarHandle vh = fieldHandle(l, fo.fieldDescriptor());\n+                return vh.get(v);\n+            }\n+        } else if (o instanceof CoreOps.FieldAccessOp.FieldStoreOp fo) {\n+            if (fo.operands().size() == 1) {\n+                Object v = oc.getValue(o.operands().get(0));\n+                VarHandle vh = fieldStaticHandle(l, fo.fieldDescriptor());\n+                vh.set(v);\n+            } else {\n+                Object r = oc.getValue(o.operands().get(0));\n+                Object v = oc.getValue(o.operands().get(1));\n+                VarHandle vh = fieldHandle(l, fo.fieldDescriptor());\n+                vh.set(r, v);\n+            }\n+            return null;\n+        } else if (o instanceof CoreOps.InstanceOfOp io) {\n+            Object v = oc.getValue(o.operands().get(0));\n+            return isInstance(l, io.type(), v);\n+        } else if (o instanceof CoreOps.CastOp co) {\n+            Object v = oc.getValue(o.operands().get(0));\n+            return cast(l, co.type(), v);\n+        } else if (o instanceof CoreOps.ArrayLengthOp) {\n+            Object a = oc.getValue(o.operands().get(0));\n+            return Array.getLength(a);\n+        } else if (o instanceof CoreOps.ArrayAccessOp.ArrayLoadOp) {\n+            Object a = oc.getValue(o.operands().get(0));\n+            Object index = oc.getValue(o.operands().get(1));\n+            return Array.get(a, (int) index);\n+        } else if (o instanceof CoreOps.ArrayAccessOp.ArrayStoreOp) {\n+            Object a = oc.getValue(o.operands().get(0));\n+            Object index = oc.getValue(o.operands().get(1));\n+            Object v = oc.getValue(o.operands().get(2));\n+            Array.set(a, (int) index, v);\n+            return null;\n+        } else if (o instanceof CoreOps.ArithmeticOperation || o instanceof CoreOps.TestOperation) {\n+            MethodHandle mh = opHandle(o.opName(), o.opType());\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            return invoke(mh, values);\n+        } else if (o instanceof CoreOps.ConvOp) {\n+            MethodHandle mh = opHandle(o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+            Object[] values = o.operands().stream().map(oc::getValue).toArray();\n+            return invoke(mh, values);\n+        } else if (o instanceof CoreOps.AssertOp _assert) {\n+            \/\/Note: The nature of asserts and munged bodies may require a re-visiting.\n+            \/\/This code seems to work without poisoning contexts. See TestAssert.java in tests for relevant test coverage.\n+            Body testBody = _assert.bodies.get(0);\n+            boolean testResult = (boolean) interpretBody(l, testBody, oc);\n+            if (!testResult) {\n+                if (_assert.bodies.size() > 1) {\n+                    Body messageBody = _assert.bodies.get(1);\n+                    String message = String.valueOf(interpretBody(l, messageBody, oc));\n+                    throw new AssertionError(message);\n+                } else {\n+                    throw new AssertionError();\n+                }\n+            }\n+            return null;\n+        } else if (o instanceof CoreOps.ConcatOp) {\n+            return o.operands().stream()\n+                    .map(oc::getValue)\n+                    .map(String::valueOf)\n+                    .collect(Collectors.joining());\n+        } else {\n+            throw interpreterException(\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+        }\n+    }\n+\n+    static final MethodHandle INVOKE_LAMBDA_MH;\n+    static {\n+        try {\n+            INVOKE_LAMBDA_MH = MethodHandles.lookup().findStatic(Interpreter.class, \"invokeLambda\",\n+                    MethodType.methodType(Object.class, MethodHandles.Lookup.class,\n+                            CoreOps.LambdaOp.class, Map.class, Object[].class));\n+        } catch (Throwable t) {\n+            throw new InternalError(t);\n+        }\n+    }\n+\n+    static Object invokeLambda(MethodHandles.Lookup l, CoreOps.LambdaOp op, Map<Value, Object> capturedValues, Object[] args) {\n+        return invoke(l, op, capturedValues, args);\n+    }\n+\n+    static MethodHandle opHandle(String opName, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(MethodHandles.lookup(), ft).erase();\n+        try {\n+            return MethodHandles.lookup().findStatic(InvokableLeafOps.class, opName, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodRef d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n+    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodRef d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n+    static MethodHandle constructorHandle(MethodHandles.Lookup l, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(l, ft);\n+\n+        if (mt.returnType().isArray()) {\n+            if (mt.parameterCount() != 1 || mt.parameterType(0) != int.class) {\n+                throw interpreterException(new IllegalArgumentException(\"Bad constructor descriptor: \" + ft));\n+            }\n+            return MethodHandles.arrayConstructor(mt.returnType());\n+        } else {\n+            try {\n+                return l.findConstructor(mt.returnType(), mt.changeReturnType(void.class));\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw interpreterException(e);\n+            }\n+        }\n+    }\n+\n+    static VarHandle fieldStaticHandle(MethodHandles.Lookup l, FieldRef d) {\n+        return resolveToVarHandle(l, d);\n+    }\n+\n+    static VarHandle fieldHandle(MethodHandles.Lookup l, FieldRef d) {\n+        return resolveToVarHandle(l, d);\n+    }\n+\n+    static Object isInstance(MethodHandles.Lookup l, TypeElement d, Object v) {\n+        Class<?> c = resolveToClass(l, d);\n+        return c.isInstance(v);\n+    }\n+\n+    static Object cast(MethodHandles.Lookup l, TypeElement d, Object v) {\n+        Class<?> c = resolveToClass(l, d);\n+        return c.cast(v);\n+    }\n+\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d) {\n+        try {\n+            return d.resolveToHandle(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    static VarHandle resolveToVarHandle(MethodHandles.Lookup l, FieldRef d) {\n+        try {\n+            return d.resolveToHandle(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    public static MethodType resolveToMethodType(MethodHandles.Lookup l, FunctionType ft) {\n+        try {\n+            return MethodRef.toNominalDescriptor(ft).resolveConstantDesc(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    public static Class<?> resolveToClass(MethodHandles.Lookup l, TypeElement d) {\n+        try {\n+            if (d instanceof JavaType jt) {\n+                return jt.resolve(l);\n+            } else {\n+                throw new ReflectiveOperationException();\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw interpreterException(e);\n+        }\n+    }\n+\n+    static Object invoke(MethodHandle m, Object... args) {\n+        try {\n+            return m.invokeWithArguments(args);\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            eraseAndThrow(e);\n+            throw new InternalError(\"should not reach here\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":681,"deletions":0,"binary":false,"changes":681,"status":"added"},{"patch":"@@ -0,0 +1,487 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.interpreter;\n+\n+final class InvokableLeafOps {\n+\n+    public static String add(String a, String b) {\n+        return a.concat(b);\n+    }\n+\n+\n+    public static boolean eq(Object a, Object b) {\n+        return a == b;\n+    }\n+\n+    public static boolean neq(Object a, Object b) {\n+        return a != b;\n+    }\n+\n+\n+    public static boolean not(boolean l) {\n+        return !l;\n+    }\n+\n+    \/\/ int\n+\n+    public static int neg(int l) {\n+        return -l;\n+    }\n+\n+    public static int add(int l, int r) {\n+        return l + r;\n+    }\n+\n+    public static int sub(int l, int r) {\n+        return l - r;\n+    }\n+\n+    public static int mul(int l, int r) {\n+        return l * r;\n+    }\n+\n+    public static int div(int l, int r) {\n+        return l \/ r;\n+    }\n+\n+    public static int mod(int l, int r) {\n+        return l % r;\n+    }\n+\n+    public static int or(int l, int r) {\n+        return l | r;\n+    }\n+\n+    public static int and(int l, int r) {\n+        return l & r;\n+    }\n+\n+    public static int xor(int l, int r) {\n+        return l ^ r;\n+    }\n+\n+    public static int lshl(int l, int r) {\n+        return l << r;\n+    }\n+\n+    public static int ashr(int l, int r) {\n+        return l >> r;\n+    }\n+\n+    public static int lshr(int l, int r) {\n+        return l >>> r;\n+    }\n+\n+    public static int lshl(int l, long r) {\n+        return l << r;\n+    }\n+\n+    public static int ashr(int l, long r) {\n+        return l >> r;\n+    }\n+\n+    public static int lshr(int l, long r) {\n+        return l >>> r;\n+    }\n+\n+    public static boolean eq(int l, int r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(int l, int r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(int l, int r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(int l, int r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(int l, int r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(int l, int r) {\n+        return l <= r;\n+    }\n+\n+   \/\/ long\n+\n+    public static long neg(long l) {\n+        return -l;\n+    }\n+\n+    public static long add(long l, long r) {\n+        return l + r;\n+    }\n+\n+    public static long sub(long l, long r) {\n+        return l - r;\n+    }\n+\n+    public static long mul(long l, long r) {\n+        return l * r;\n+    }\n+\n+    public static long div(long l, long r) {\n+        return l \/ r;\n+    }\n+\n+    public static long mod(long l, long r) {\n+        return l % r;\n+    }\n+\n+    public static long or(long l, long r) {\n+        return l | r;\n+    }\n+\n+    public static long and(long l, long r) {\n+        return l & r;\n+    }\n+\n+    public static long xor(long l, long r) {\n+        return l ^ r;\n+    }\n+\n+    public static long lshl(long l, long r) {\n+        return l << r;\n+    }\n+\n+    public static long ashr(long l, long r) {\n+        return l >> r;\n+    }\n+\n+    public static long lshr(long l, long r) {\n+        return l >>> r;\n+    }\n+\n+    public static long lshl(long l, int r) {\n+        return l << r;\n+    }\n+\n+    public static long ashr(long l, int r) {\n+        return l >> r;\n+    }\n+\n+    public static long lshr(long l, int r) {\n+        return l >>> r;\n+    }\n+\n+    public static boolean eq(long l, long r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(long l, long r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(long l, long r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(long l, long r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(long l, long r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(long l, long r) {\n+        return l <= r;\n+    }\n+\n+\n+\n+    \/\/ float\n+\n+    static float neg(float l) {\n+        return -l;\n+    }\n+\n+    static float add(float l, float r) {\n+        return l + r;\n+    }\n+\n+    static float sub(float l, float r) {\n+        return l - r;\n+    }\n+\n+    static float mul(float l, float r) {\n+        return l * r;\n+    }\n+\n+    static float div(float l, float r) {\n+        return l \/ r;\n+    }\n+\n+    static float mod(float l, float r) {\n+        return l % r;\n+    }\n+\n+    public static boolean eq(float l, float r) {\n+        return l == r;\n+    }\n+\n+    public static boolean neq(float l, float r) {\n+        return l != r;\n+    }\n+\n+    public static boolean gt(float l, float r) {\n+        return l > r;\n+    }\n+\n+    public static boolean ge(float l, float r) {\n+        return l >= r;\n+    }\n+\n+    public static boolean lt(float l, float r) {\n+        return l < r;\n+    }\n+\n+    public static boolean le(float l, float r) {\n+        return l <= r;\n+    }\n+\n+\n+\n+    \/\/ double\n+\n+    static double neg(double l) {\n+        return -l;\n+    }\n+\n+    static double add(double l, double r) {\n+        return l + r;\n+    }\n+\n+    static double sub(double l, double r) {\n+        return l - r;\n+    }\n+\n+    static double mul(double l, double r) {\n+        return l * r;\n+    }\n+\n+    static double div(double l, double r) {\n+        return l \/ r;\n+    }\n+\n+    static double mod(double l, double r) {\n+        return l % r;\n+    }\n+\n+\n+\n+    \/\/ boolean\n+\n+    static boolean eq(boolean l, boolean r) {\n+        return l == r;\n+    }\n+\n+    static boolean neq(boolean l, boolean r) {\n+        return l != r;\n+    }\n+\n+    static boolean and(boolean l, boolean r) {\n+        return l & r;\n+    }\n+\n+    static boolean or(boolean l, boolean r) {\n+        return l | r;\n+    }\n+\n+    static boolean xor(boolean l, boolean r) {\n+        return l ^ r;\n+    }\n+\n+\n+    \/\/ Primitive conversions\n+\n+    \/\/ double conversion\n+    static double conv_double(double i) {\n+        return i;\n+    }\n+    static float conv_float(double i) {\n+        return (float) i;\n+    }\n+    static long conv_long(double i) {\n+        return (long) i;\n+    }\n+    static int conv_int(double i) {\n+        return (int) i;\n+    }\n+    static short conv_short(double i) {\n+        return (short) i;\n+    }\n+    static char conv_char(double i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(double i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ float conversion\n+    static double conv_double(float i) {\n+        return i;\n+    }\n+    static float conv_float(float i) {\n+        return i;\n+    }\n+    static long conv_long(float i) {\n+        return (long) i;\n+    }\n+    static int conv_int(float i) {\n+        return (int) i;\n+    }\n+    static short conv_short(float i) {\n+        return (short) i;\n+    }\n+    static char conv_char(float i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(float i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ long conversion\n+    static double conv_double(long i) {\n+        return (double) i;\n+    }\n+    static float conv_float(long i) {\n+        return (float) i;\n+    }\n+    static long conv_long(long i) {\n+        return i;\n+    }\n+    static int conv_int(long i) {\n+        return (int) i;\n+    }\n+    static short conv_short(long i) {\n+        return (short) i;\n+    }\n+    static char conv_char(long i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(long i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ int conversion\n+    static double conv_double(int i) {\n+        return (double) i;\n+    }\n+    static float conv_float(int i) {\n+        return (float) i;\n+    }\n+    static long conv_long(int i) {\n+        return i;\n+    }\n+    static int conv_int(int i) {\n+        return i;\n+    }\n+    static short conv_short(int i) {\n+        return (short) i;\n+    }\n+    static char conv_char(int i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(int i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ short conversion\n+    static double conv_double(short i) {\n+        return i;\n+    }\n+    static float conv_float(short i) {\n+        return i;\n+    }\n+    static long conv_long(short i) {\n+        return i;\n+    }\n+    static int conv_int(short i) {\n+        return i;\n+    }\n+    static short conv_short(short i) {\n+        return i;\n+    }\n+    static char conv_char(short i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(short i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ char conversion\n+    static double conv_double(char i) {\n+        return i;\n+    }\n+    static float conv_float(char i) {\n+        return i;\n+    }\n+    static long conv_long(char i) {\n+        return i;\n+    }\n+    static int conv_int(char i) {\n+        return i;\n+    }\n+    static short conv_short(char i) {\n+        return (short) i;\n+    }\n+    static char conv_char(char i) {\n+        return i;\n+    }\n+    static byte conv_byte(char i) {\n+        return (byte) i;\n+    }\n+\n+    \/\/ byte conversion\n+    static double conv_double(byte i) {\n+        return i;\n+    }\n+    static float conv_float(byte i) {\n+        return i;\n+    }\n+    static long conv_long(byte i) {\n+        return i;\n+    }\n+    static int conv_int(byte i) {\n+        return i;\n+    }\n+    static short conv_short(byte i) {\n+        return i;\n+    }\n+    static char conv_char(byte i) {\n+        return (char) i;\n+    }\n+    static byte conv_byte(byte i) {\n+        return i;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/InvokableLeafOps.java","additions":487,"deletions":0,"binary":false,"changes":487,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for interpreting code models.\n+ *\/\n+package java.lang.reflect.code.interpreter;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,3982 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.*;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * The set of core operations. A code model, produced by the Java compiler from Java program source and lowered to\n+ * consist only of core operations, represents the same Java program and preserves the program meaning as defined by\n+ * the Java Language Specification.\n+ *\/\n+public final class CoreOps {\n+\n+    \/\/ Split string to ensure the name does not get rewritten\n+    \/\/ when the script copies this source to the jdk.compiler module\n+    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n+\n+    static final String CoreOps_CLASS_NAME = PACKAGE_NAME + \".\" + CoreOps.class.getSimpleName();\n+\n+    private CoreOps() {\n+    }\n+\n+    \/**\n+     * The function operation, that can model a Java method.\n+     *\/\n+    @OpDeclaration(FuncOp.NAME)\n+    public static final class FuncOp extends OpWithDefinition implements Op.Invokable, Op.Isolated, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final String funcName;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcName = funcName;\n+                this.funcType = funcType;\n+            }\n+\n+            public FuncOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new FuncOp(funcName, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"func\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final Body body;\n+\n+        public static FuncOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new FuncOp(def, funcName);\n+        }\n+\n+        FuncOp(OpDefinition def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        FuncOp(FuncOp that, CopyContext cc, OpTransformer oa) {\n+            this(that, that.funcName, cc, oa);\n+        }\n+\n+        FuncOp(FuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.funcName = funcName;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public FuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncOp(this, cc, ot);\n+        }\n+\n+        public FuncOp transform(OpTransformer ot) {\n+            return new FuncOp(this, CopyContext.create(), ot);\n+        }\n+\n+        public FuncOp transform(String funcName, OpTransformer ot) {\n+            return new FuncOp(this, funcName, CopyContext.create(), ot);\n+        }\n+\n+        FuncOp(String funcName, Body.Builder bodyBuilder) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.funcName = funcName;\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            \/\/ and copy directly without lowering descendant operations\n+            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The function call operation, that models a call to a function, by name, declared in the module op that is also an\n+     * ancestor of this operation.\n+     *\/\n+    \/\/ @@@ stack effects equivalent to the call operation as if the function were a Java method?\n+    @OpDeclaration(FuncCallOp.NAME)\n+    public static final class FuncCallOp extends OpWithDefinition {\n+        public static final String NAME = \"func.call\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final TypeElement resultType;\n+\n+        public static FuncCallOp create(OpDefinition def) {\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+\n+            return new FuncCallOp(def, funcName);\n+        }\n+\n+        FuncCallOp(OpDefinition def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.resultType = def.resultType();\n+        }\n+\n+        FuncCallOp(FuncCallOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.funcName = that.funcName;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public FuncCallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new FuncCallOp(this, cc);\n+        }\n+\n+        FuncCallOp(String funcName, TypeElement resultType, List<Value> args) {\n+            super(NAME, args);\n+\n+            this.funcName = funcName;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The module operation, modeling a collection of functions,\n+     * and creating a symbol table of function name to function\n+     *\/\n+    @OpDeclaration(ModuleOp.NAME)\n+    public static final class ModuleOp extends OpWithDefinition implements Op.Isolated {\n+\n+        public static final String NAME = \"module\";\n+\n+        final Map<String, FuncOp> table;\n+        final Body body;\n+\n+        public static ModuleOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            return new ModuleOp(def);\n+        }\n+\n+        ModuleOp(OpDefinition def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        ModuleOp(ModuleOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.table = createTable(body);\n+        }\n+\n+        static Map<String, FuncOp> createTable(Body body) {\n+            Map<String, FuncOp> table = new HashMap<>();\n+            for (var op : body.entryBlock().ops()) {\n+                if (op instanceof FuncOp fop) {\n+                    table.put(fop.funcName(), fop);\n+                } else {\n+                    throw new IllegalArgumentException(\"Bad operation in module: \" + op);\n+                }\n+            }\n+            return Collections.unmodifiableMap(table);\n+        }\n+\n+        @Override\n+        public ModuleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModuleOp(this, cc, ot);\n+        }\n+\n+        public ModuleOp transform(OpTransformer ot) {\n+            return new ModuleOp(this, CopyContext.create(), ot);\n+        }\n+\n+        ModuleOp(List<FuncOp> functions) {\n+            super(NAME,\n+                    List.of());\n+\n+            Body.Builder bodyC = Body.Builder.of(null, FunctionType.VOID);\n+            Block.Builder entryBlock = bodyC.entryBlock();\n+            Map<String, FuncOp> table = new HashMap<>();\n+            for (FuncOp f : functions) {\n+                entryBlock.op(f);\n+                table.put(f.funcName(), f);\n+            }\n+            this.table = Collections.unmodifiableMap(table);\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Map<String, FuncOp> functionTable() {\n+            return table;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The quoted operation, that models the quoting of an operation.\n+     *\/\n+    @OpDeclaration(QuotedOp.NAME)\n+    public static final class QuotedOp extends OpWithDefinition implements Op.Nested, Op.Lowerable, Op.Pure {\n+        public static final String NAME = \"quoted\";\n+\n+        \/\/ Type name must be the same in the java.base and jdk.compiler module\n+        static final String Quoted_CLASS_NAME = PACKAGE_NAME +\n+                \".\" + Quoted.class.getSimpleName();\n+        public static final JavaType QUOTED_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Quoted_CLASS_NAME));\n+\n+        final Body quotedBody;\n+\n+        final Op quotedOp;\n+\n+        public QuotedOp(OpDefinition def) {\n+            super(def);\n+\n+            this.quotedBody = def.bodyDefinitions().get(0).build(this);\n+\n+            if (quotedBody.entryBlock().terminatingOp() instanceof YieldOp brk &&\n+                    brk.yieldValue() instanceof Result quotedOpResult) {\n+                this.quotedOp = quotedOpResult.op();\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        QuotedOp(QuotedOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.quotedBody = that.quotedBody.transform(cc, ot).build(this);\n+            this.quotedOp = that.quotedOp;\n+        }\n+\n+        @Override\n+        public QuotedOp transform(CopyContext cc, OpTransformer ot) {\n+            return new QuotedOp(this, cc, ot);\n+        }\n+\n+        QuotedOp(Body.Builder bodyC) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.quotedBody = bodyC.build(this);\n+            if (quotedBody.blocks().size() > 1) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!(quotedBody.entryBlock().terminatingOp() instanceof YieldOp yop)) {\n+                throw new IllegalArgumentException();\n+            }\n+            if (!(yop.yieldValue() instanceof Result r)) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.quotedOp = r.op();\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(quotedBody);\n+        }\n+\n+        public Op quotedOp() {\n+            return quotedOp;\n+        }\n+\n+        @Override\n+        public List<Value> capturedValues() {\n+            return quotedBody.capturedValues();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            \/\/ and copy directly without lowering descendant operations\n+            b.op(this, OpTransformer.COPYING_TRANSFORMER);\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return QUOTED_TYPE;\n+        }\n+    }\n+\n+    \/**\n+     * The lambda operation, that can model a Java lambda expression.\n+     *\/\n+    @OpDeclaration(LambdaOp.NAME)\n+    public static final class LambdaOp extends OpWithDefinition implements Op.Invokable, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final FunctionType funcType;\n+            final TypeElement functionalInterface;\n+\n+            Builder(Body.Builder ancestorBody, FunctionType funcType, TypeElement functionalInterface) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcType = funcType;\n+                this.functionalInterface = functionalInterface;\n+            }\n+\n+            public LambdaOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new LambdaOp(functionalInterface, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"lambda\";\n+\n+        final TypeElement functionalInterface;\n+        final Body body;\n+\n+        public LambdaOp(OpDefinition def) {\n+            super(def);\n+\n+            this.functionalInterface = def.resultType();\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        LambdaOp(LambdaOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.functionalInterface = that.functionalInterface;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public LambdaOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LambdaOp(this, cc, ot);\n+        }\n+\n+        LambdaOp(TypeElement functionalInterface, Body.Builder bodyC) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.functionalInterface = functionalInterface;\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public TypeElement functionalInterface() {\n+            return functionalInterface;\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public List<Value> capturedValues() {\n+            return body.capturedValues();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, (block, op) -> {\n+                if (op instanceof Op.Lowerable lop) {\n+                    return lop.lower(block);\n+                } else {\n+                    block.op(op);\n+                    return block;\n+                }\n+            });\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return functionalInterface();\n+        }\n+\n+        \/**\n+         * Determines if this lambda operation could have originated from a\n+         * method reference declared in Java source code.\n+         * <p>\n+         * Such a lambda operation is one with the following constraints:\n+         * <ol>\n+         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n+         *     <li>A body with only one (entry) block that contains only variable declaration\n+         *     operations, variable load operations, invoke operations to box or unbox\n+         *     primitive values, a single invoke operation to the method that is\n+         *     referenced, and a return operation.\n+         *     <li>if the return operation returns a non-void result then that result is,\n+         *     or uniquely depends on, the result of the referencing invoke operation.\n+         *     <li>If the lambda operation captures one value then the first operand corresponds\n+         *     to captured the value, and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         *     Otherwise, the first and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         * <\/ol>\n+         * A value, V2, uniquely depends on another value, V1, if the graph of what V2 depends on\n+         * contains only nodes with single edges terminating in V1, and the graph of what depends on V1\n+         * is bidirectionally equal to the graph of what V2 depends on.\n+         *\n+         * @return the invocation operation to the method referenced by the lambda\n+         * operation, otherwise empty.\n+         *\/\n+        public Optional<InvokeOp> methodReference() {\n+            \/\/ Single block\n+            if (body().blocks().size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Zero or one (this) capture\n+            List<Value> cvs = capturedValues();\n+            if (cvs.size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            Map<Value, Value> valueMapping = new HashMap<>();\n+            CoreOps.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, body().entryBlock().ops());\n+            if (methodRefInvokeOp == null) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Lambda's parameters map in encounter order with the invocation's operands\n+            List<Value> lambdaParameters = new ArrayList<>();\n+            if (cvs.size() == 1) {\n+                lambdaParameters.add(cvs.getFirst());\n+            }\n+            lambdaParameters.addAll(parameters());\n+            List<Value> methodRefOperands = methodRefInvokeOp.operands().stream().map(valueMapping::get).toList();\n+            if (!lambdaParameters.equals(methodRefOperands)) {\n+                return Optional.empty();\n+            }\n+\n+            return Optional.of(methodRefInvokeOp);\n+        }\n+\n+        static CoreOps.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n+            CoreOps.InvokeOp methodRefInvokeOp = null;\n+            for (Op op : ops) {\n+                switch (op) {\n+                    case CoreOps.VarOp varOp -> {\n+                        if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOps.VarAccessOp.VarStoreOp)) {\n+                            return null;\n+                        }\n+                    }\n+                    case CoreOps.VarAccessOp.VarLoadOp varLoadOp -> {\n+                        Value v = varLoadOp.varOp().operands().getFirst();\n+                        valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case CoreOps.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n+                        Value v = iop.operands().getFirst();\n+                        valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case CoreOps.InvokeOp iop -> {\n+                        if (methodRefInvokeOp != null) {\n+                            return null;\n+                        }\n+\n+                        for (Value o : iop.operands()) {\n+                            valueMapping.put(o, valueMapping.getOrDefault(o, o));\n+                        }\n+                        methodRefInvokeOp = iop;\n+                    }\n+                    case CoreOps.ReturnOp rop -> {\n+                        if (methodRefInvokeOp == null) {\n+                            return null;\n+                        }\n+                        Value r = rop.returnValue();\n+                        if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n+                            return null;\n+                        }\n+                        if (invokeResult.op() != methodRefInvokeOp) {\n+                            return null;\n+                        }\n+                        assert methodRefInvokeOp.result().uses().size() == 1;\n+                    }\n+                    default -> {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            return methodRefInvokeOp;\n+        }\n+\n+        private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+            for (Op.Result user : value.uses()) {\n+                if (opPredicate.test(user.op())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ @@@ Move to functionality on JavaType(s)\n+        static final Set<String> UNBOX_NAMES = Set.of(\n+                \"byteValue\",\n+                \"shortValue\",\n+                \"charValue\",\n+                \"intValue\",\n+                \"longValue\",\n+                \"floatValue\",\n+                \"doubleValue\",\n+                \"booleanValue\");\n+\n+        private static boolean isBoxOrUnboxInvocation(CoreOps.InvokeOp iop) {\n+            MethodRef mr = iop.invokeDescriptor();\n+            return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n+                    (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n+        }\n+    }\n+\n+    \/**\n+     * The closure operation, that can model a structured Java lambda expression\n+     * that has no target type (a functional interface).\n+     *\/\n+    @OpDeclaration(ClosureOp.NAME)\n+    public static final class ClosureOp extends OpWithDefinition implements Op.Invokable, Op.Lowerable {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcType = funcType;\n+            }\n+\n+            public ClosureOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new ClosureOp(body);\n+            }\n+        }\n+\n+        public static final String NAME = \"closure\";\n+\n+        final Body body;\n+\n+        public ClosureOp(OpDefinition def) {\n+            super(def);\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        ClosureOp(ClosureOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public ClosureOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ClosureOp(this, cc, ot);\n+        }\n+\n+        ClosureOp(Body.Builder bodyC) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.body = bodyC.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        @Override\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public List<Value> capturedValues() {\n+            return body.capturedValues();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer _ignore) {\n+            \/\/ Isolate body with respect to ancestor transformations\n+            b.op(this, (block, op) -> {\n+                if (op instanceof Op.Lowerable lop) {\n+                    return lop.lower(block);\n+                } else {\n+                    block.op(op);\n+                    return block;\n+                }\n+            });\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return body.bodyType();\n+        }\n+    }\n+\n+    \/**\n+     * The closure call operation, that models a call to a closure, by reference\n+     *\/\n+\/\/  @@@ stack effects equivalent to the invocation of an SAM of on an instance of an anonymous functional interface\n+\/\/  that is the target of the closures lambda expression.\n+    @OpDeclaration(ClosureCallOp.NAME)\n+    public static final class ClosureCallOp extends OpWithDefinition {\n+        public static final String NAME = \"closure.call\";\n+\n+        public ClosureCallOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ClosureCallOp(ClosureCallOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ClosureCallOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ClosureCallOp(this, cc);\n+        }\n+\n+        ClosureCallOp(List<Value> args) {\n+            super(NAME, args);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            FunctionType ft = (FunctionType) operands().getFirst().type();\n+            return ft.returnType();\n+        }\n+    }\n+\n+    \/**\n+     * The terminating return operation, that can model the Java language return statement.\n+     * <p>\n+     * This operation exits an isolated body.\n+     *\/\n+    @OpDeclaration(ReturnOp.NAME)\n+    public static final class ReturnOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"return\";\n+\n+        public ReturnOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        ReturnOp(ReturnOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ReturnOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ReturnOp(this, cc);\n+        }\n+\n+        ReturnOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        ReturnOp(Value operand) {\n+            super(NAME, List.of(operand));\n+        }\n+\n+        public Value returnValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating throw operation, that can model the Java language throw statement.\n+     *\/\n+    @OpDeclaration(ThrowOp.NAME)\n+    public static final class ThrowOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"throw\";\n+\n+        public ThrowOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+        }\n+\n+        ThrowOp(ThrowOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ThrowOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ThrowOp(this, cc);\n+        }\n+\n+        ThrowOp(Value e) {\n+            super(NAME, List.of(e));\n+        }\n+\n+        public Value argument() {\n+            return operands().get(0);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The assertion operation. Supporting assertions in statement form.\n+     *\/\n+    @OpDeclaration(AssertOp.NAME)\n+    public static final class AssertOp extends OpWithDefinition implements Op.Nested {\n+        public static final String NAME = \"assert\";\n+        public final List<Body> bodies;\n+\n+        public AssertOp(OpDefinition def) {\n+            super(def);\n+            var bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n+            checkBodies(bodies);\n+            this.bodies = bodies;\n+        }\n+\n+        public AssertOp(List<Body.Builder> bodies) {\n+            super(NAME, List.of());\n+            checkBodies(bodies);\n+            this.bodies = bodies.stream().map(b -> b.build(this)).toList();\n+        }\n+\n+        AssertOp(AssertOp that, CopyContext cc, OpTransformer ot) {\n+\n+            super(that, cc);\n+            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        private void checkBodies(List<?> bodies) {\n+            if (bodies.size() != 1 && bodies.size() != 2) {\n+                throw new IllegalArgumentException(\"Assert must have one or two bodies.\");\n+            }\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AssertOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return this.bodies;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating unreachable operation.\n+     * <p>\n+     * This operation models termination that is unreachable.\n+     *\/\n+    @OpDeclaration(UnreachableOp.NAME)\n+    public static class UnreachableOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"unreachable\";\n+\n+        public UnreachableOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must zero operands \" + def.name());\n+            }\n+        }\n+\n+        UnreachableOp(UnreachableOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public UnreachableOp transform(CopyContext cc, OpTransformer ot) {\n+            return new UnreachableOp(this, cc);\n+        }\n+\n+        UnreachableOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating yield operation.\n+     * <p>\n+     * This operation models exits from its parent body, yielding at most one value (zero value for yielding unit\n+     * or void)\n+     *\/\n+    @OpDeclaration(YieldOp.NAME)\n+    public static class YieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"yield\";\n+\n+        public YieldOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        YieldOp(YieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public YieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new YieldOp(this, cc);\n+        }\n+\n+        YieldOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        YieldOp(List<Value> operands) {\n+            super(NAME, operands);\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating unconditional branch operation.\n+     * <p>\n+     * This operation accepts a successor to the next block to branch to.\n+     *\/\n+    @OpDeclaration(BranchOp.NAME)\n+    public static class BranchOp extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"branch\";\n+\n+        final Block.Reference b;\n+\n+        public BranchOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty() || def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero arguments and one successor\" + def.name());\n+            }\n+\n+            this.b = def.successors().get(0);\n+        }\n+\n+        BranchOp(BranchOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.b = cc.getSuccessorOrCreate(that.b);\n+        }\n+\n+        @Override\n+        public BranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new BranchOp(this, cc);\n+        }\n+\n+        BranchOp(Block.Reference successor) {\n+            super(NAME, List.of());\n+\n+            this.b = successor;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(b);\n+        }\n+\n+        public Block.Reference branch() {\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The terminating conditional branch operation.\n+     * <p>\n+     * This operation accepts a boolean operand and two successors, the true successor and false successor.\n+     * When the operand is true the  true successor is selected, otherwise the false successor is selected.\n+     * The selected successor refers to the next block to branch to.\n+     *\/\n+    @OpDeclaration(ConditionalBranchOp.NAME)\n+    public static class ConditionalBranchOp extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"cbranch\";\n+\n+        final Block.Reference t;\n+        final Block.Reference f;\n+\n+        public ConditionalBranchOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1 || def.successors().size() != 2) {\n+                throw new IllegalArgumentException(\"Operation must one operand and two successors\" + def.name());\n+            }\n+\n+            this.t = def.successors().get(0);\n+            this.f = def.successors().get(1);\n+        }\n+\n+        ConditionalBranchOp(ConditionalBranchOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.t = cc.getSuccessorOrCreate(that.t);\n+            this.f = cc.getSuccessorOrCreate(that.f);\n+        }\n+\n+        @Override\n+        public ConditionalBranchOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConditionalBranchOp(this, cc);\n+        }\n+\n+        ConditionalBranchOp(Value p, Block.Reference t, Block.Reference f) {\n+            super(NAME, List.of(p));\n+\n+            this.t = t;\n+            this.f = f;\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(t, f);\n+        }\n+\n+        public Value predicate() {\n+            return operands().get(0);\n+        }\n+\n+        public Block.Reference trueBranch() {\n+            return t;\n+        }\n+\n+        public Block.Reference falseBranch() {\n+            return f;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The constant operation, that can model Java language literal and constant expressions.\n+     *\/\n+    @OpDeclaration(ConstantOp.NAME)\n+    public static class ConstantOp extends OpWithDefinition implements Op.Pure {\n+        public static final String NAME = \"constant\";\n+\n+        public static final String ATTRIBUTE_CONSTANT_VALUE = NAME + \".value\";\n+\n+        final Object value;\n+        final TypeElement type;\n+\n+        public static ConstantOp create(OpDefinition def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have zero operands\");\n+            }\n+\n+            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE, true,\n+                    v -> processConstantValue(def.resultType(), v));\n+            return new ConstantOp(def, value);\n+        }\n+\n+        static Object processConstantValue(TypeElement t, Object value) {\n+            if (t.equals(JavaType.BOOLEAN)) {\n+                if (value instanceof String s) {\n+                    return Boolean.valueOf(s);\n+                } else if (value instanceof Boolean) {\n+                    return value;\n+                }\n+            } else if (t.equals(JavaType.BYTE)) {\n+                if (value instanceof String s) {\n+                    return Byte.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.byteValue();\n+                }\n+            } else if (t.equals(JavaType.SHORT)) {\n+                if (value instanceof String s) {\n+                    return Short.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.shortValue();\n+                }\n+            } else if (t.equals(JavaType.CHAR)) {\n+                if (value instanceof String s) {\n+                    return s.charAt(0);\n+                } else if (value instanceof Character) {\n+                    return value;\n+                }\n+            } else if (t.equals(JavaType.INT)) {\n+                if (value instanceof String s) {\n+                    return Integer.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.intValue();\n+                }\n+            } else if (t.equals(JavaType.LONG)) {\n+                if (value instanceof String s) {\n+                    return Long.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.longValue();\n+                }\n+            } else if (t.equals(JavaType.FLOAT)) {\n+                if (value instanceof String s) {\n+                    return Float.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.floatValue();\n+                }\n+            } else if (t.equals(JavaType.DOUBLE)) {\n+                if (value instanceof String s) {\n+                    return Double.valueOf(s);\n+                } else if (value instanceof Number n) {\n+                    return n.doubleValue();\n+                }\n+            } else if (t.equals(JavaType.J_L_STRING)) {\n+                return value == NULL_ATTRIBUTE_VALUE ? null :\n+                        value.toString();\n+            } else if (t.equals(JavaType.J_L_CLASS)) {\n+                return value == NULL_ATTRIBUTE_VALUE ? null : JavaType.ofString(value.toString());\n+            } else if (value == NULL_ATTRIBUTE_VALUE) {\n+                return null; \/\/ null constant\n+            }\n+\n+            throw new UnsupportedOperationException(\"Unsupported constant type and value: \" + t + \" \" + value);\n+        }\n+\n+        ConstantOp(OpDefinition def, Object value) {\n+            super(def);\n+\n+            this.type = def.resultType();\n+            this.value = value;\n+        }\n+\n+        ConstantOp(ConstantOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.type = that.type;\n+            this.value = that.value;\n+        }\n+\n+        @Override\n+        public ConstantOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ConstantOp(this, cc);\n+        }\n+\n+        ConstantOp(TypeElement type, Object value) {\n+            super(NAME, List.of());\n+\n+            this.type = type;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", value == null ? NULL_ATTRIBUTE_VALUE : value);\n+            return attrs;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return type;\n+        }\n+    }\n+\n+    \/**\n+     * An operation characteristic indicating the operation's behavior may be emulated using Java reflection.\n+     * A descriptor is derived from or declared by the operation that can be resolved at runtime to\n+     * an instance of a reflective handle or member. That handle or member can be operated on to\n+     * emulate the operation's behavior, specifically as bytecode behavior.\n+     *\/\n+    public sealed interface ReflectiveOp {\n+    }\n+\n+    \/**\n+     * The invoke operation, that can model Java language method invocation expressions.\n+     *\/\n+    @OpDeclaration(InvokeOp.NAME)\n+    public static final class InvokeOp extends OpWithDefinition implements ReflectiveOp {\n+        public static final String NAME = \"invoke\";\n+        public static final String ATTRIBUTE_INVOKE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final MethodRef invokeDescriptor;\n+        final TypeElement resultType;\n+\n+        public static InvokeOp create(OpDefinition def) {\n+            MethodRef invokeDescriptor = def.extractAttributeValue(ATTRIBUTE_INVOKE_DESCRIPTOR,\n+                    true, v -> switch (v) {\n+                        case String s -> MethodRef.ofString(s);\n+                        case MethodRef md -> md;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n+                    });\n+\n+            return new InvokeOp(def, invokeDescriptor);\n+        }\n+\n+        InvokeOp(OpDefinition def, MethodRef invokeDescriptor) {\n+            super(def);\n+\n+            this.invokeDescriptor = invokeDescriptor;\n+            this.resultType = def.resultType();\n+        }\n+\n+        InvokeOp(InvokeOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.invokeDescriptor = that.invokeDescriptor;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public InvokeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InvokeOp(this, cc);\n+        }\n+\n+        InvokeOp(MethodRef invokeDescriptor, List<Value> args) {\n+            this(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+        }\n+\n+        InvokeOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+            super(NAME, args);\n+\n+            this.invokeDescriptor = invokeDescriptor;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", invokeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public MethodRef invokeDescriptor() {\n+            return invokeDescriptor;\n+        }\n+\n+        public boolean hasReceiver() {\n+            return operands().size() != invokeDescriptor().type().parameterTypes().size();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The conversion operation, that can model Java language implicit and explicit\n+     * conversions such as widening and narrowing.\n+     *\/\n+    @OpDeclaration(ConvOp.NAME)\n+    public static final class ConvOp extends OpWithDefinition implements Op.Pure {\n+        public static final String NAME = \"conv\";\n+\n+        final TypeElement resultType;\n+\n+        public ConvOp(OpDefinition def) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+        }\n+\n+        ConvOp(ConvOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ConvOp(this, cc);\n+        }\n+\n+        ConvOp(TypeElement resultType, Value arg) {\n+            super(NAME, List.of(arg));\n+\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The new operation, that can models Java language instance creation expressions.\n+     *\/\n+    @OpDeclaration(NewOp.NAME)\n+    public static final class NewOp extends OpWithDefinition implements ReflectiveOp {\n+        public static final String NAME = \"new\";\n+        public static final String ATTRIBUTE_NEW_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final FunctionType constructorType;\n+        final TypeElement resultType;\n+\n+        public static NewOp create(OpDefinition def) {\n+            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR, true,\n+                    v -> switch (v) {\n+                        case String s -> {\n+                            TypeElement te = CoreTypeFactory.CORE_TYPE_FACTORY\n+                                    .constructType(TypeDefinition.ofString(s));\n+                            if (!(te instanceof FunctionType ft)) {\n+                                throw new UnsupportedOperationException(\"Unsupported new descriptor value:\" + v);\n+                            }\n+                            yield ft;\n+                        }\n+                        case FunctionType ct -> ct;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported new descriptor value:\" + v);\n+                    });\n+            return new NewOp(def, constructorType);\n+        }\n+\n+        NewOp(OpDefinition def, FunctionType constructorType) {\n+            super(def);\n+\n+            this.constructorType = constructorType;\n+            this.resultType = def.resultType();\n+        }\n+\n+        NewOp(NewOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.constructorType = that.constructorType;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public NewOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NewOp(this, cc);\n+        }\n+\n+        NewOp(FunctionType constructorType, List<Value> args) {\n+            this(constructorType.returnType(), constructorType, args);\n+        }\n+\n+        NewOp(TypeElement resultType, FunctionType constructorType, List<Value> args) {\n+            super(NAME, args);\n+\n+            this.constructorType = constructorType;\n+            this.resultType = resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", constructorType);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeElement type() {\n+            return opType().returnType();\n+        }\n+\n+        public FunctionType constructorType() {\n+            return constructorType;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * An operation that performs access.\n+     *\/\n+    public sealed interface AccessOp {\n+    }\n+\n+    \/**\n+     * A field access operation, that can model Java langauge field access expressions.\n+     *\/\n+    public abstract static sealed class FieldAccessOp extends OpWithDefinition implements AccessOp, ReflectiveOp {\n+        public static final String ATTRIBUTE_FIELD_DESCRIPTOR = \"field.descriptor\";\n+\n+        final FieldRef fieldDescriptor;\n+\n+        FieldAccessOp(OpDefinition def, FieldRef fieldDescriptor) {\n+            super(def);\n+\n+            this.fieldDescriptor = fieldDescriptor;\n+        }\n+\n+        FieldAccessOp(FieldAccessOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.fieldDescriptor = that.fieldDescriptor;\n+        }\n+\n+        FieldAccessOp(String name, List<Value> operands,\n+                      FieldRef fieldDescriptor) {\n+            super(name, operands);\n+\n+            this.fieldDescriptor = fieldDescriptor;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", fieldDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public final FieldRef fieldDescriptor() {\n+            return fieldDescriptor;\n+        }\n+\n+        \/**\n+         * The field load operation, that can model Java language field access expressions combined with load access to\n+         * field instance variables.\n+         *\/\n+        @OpDeclaration(FieldLoadOp.NAME)\n+        public static final class FieldLoadOp extends FieldAccessOp implements Op.Pure {\n+            public static final String NAME = \"field.load\";\n+\n+            final TypeElement resultType;\n+\n+            public static FieldLoadOp create(OpDefinition def) {\n+                if (def.operands().size() > 1) {\n+                    throw new IllegalArgumentException(\"Operation must accept zero or one operand\");\n+                }\n+\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n+                            case String s -> FieldRef.ofString(s);\n+                            case FieldRef fd -> fd;\n+                            default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                        });\n+                return new FieldLoadOp(def, fieldDescriptor);\n+            }\n+\n+            FieldLoadOp(OpDefinition opdef, FieldRef fieldDescriptor) {\n+                super(opdef, fieldDescriptor);\n+\n+                resultType = opdef.resultType();\n+            }\n+\n+            FieldLoadOp(FieldLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                resultType = that.resultType();\n+            }\n+\n+            @Override\n+            public FieldLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new FieldLoadOp(this, cc);\n+            }\n+\n+            \/\/ instance\n+            FieldLoadOp(TypeElement resultType, FieldRef descriptor, Value receiver) {\n+                super(NAME, List.of(receiver), descriptor);\n+\n+                this.resultType = resultType;\n+            }\n+\n+            \/\/ static\n+            FieldLoadOp(TypeElement resultType, FieldRef descriptor) {\n+                super(NAME, List.of(), descriptor);\n+\n+                this.resultType = resultType;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return resultType;\n+            }\n+        }\n+\n+        \/**\n+         * The field store operation, that can model Java language field access expressions combined with store access\n+         * to field instance variables.\n+         *\/\n+        @OpDeclaration(FieldStoreOp.NAME)\n+        public static final class FieldStoreOp extends FieldAccessOp {\n+            public static final String NAME = \"field.store\";\n+\n+            public static FieldStoreOp create(OpDefinition def) {\n+                if (def.operands().size() > 2) {\n+                    throw new IllegalArgumentException(\"Operation must accept one or two operands\");\n+                }\n+\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n+                            case String s -> FieldRef.ofString(s);\n+                            case FieldRef fd -> fd;\n+                            default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                        });\n+                return new FieldStoreOp(def, fieldDescriptor);\n+            }\n+\n+            FieldStoreOp(OpDefinition opdef, FieldRef fieldDescriptor) {\n+                super(opdef, fieldDescriptor);\n+            }\n+\n+            FieldStoreOp(FieldStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public FieldStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new FieldStoreOp(this, cc);\n+            }\n+\n+            \/\/ instance\n+            FieldStoreOp(FieldRef descriptor, Value receiver, Value v) {\n+                super(NAME,\n+                        List.of(receiver, v), descriptor);\n+            }\n+\n+            \/\/ static\n+            FieldStoreOp(FieldRef descriptor, Value v) {\n+                super(NAME,\n+                        List.of(v), descriptor);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return JavaType.VOID;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The array length operation, that can model Java language field access expressions to the length field of an\n+     * array.\n+     *\/\n+    @OpDeclaration(ArrayLengthOp.NAME)\n+    public static final class ArrayLengthOp extends OpWithDefinition implements ReflectiveOp {\n+        public static final String NAME = \"array.length\";\n+\n+        public ArrayLengthOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        ArrayLengthOp(ArrayLengthOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ArrayLengthOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ArrayLengthOp(this, cc);\n+        }\n+\n+        ArrayLengthOp(Value array) {\n+            super(NAME, List.of(array));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.INT;\n+        }\n+    }\n+\n+    \/**\n+     * The array access operation, that can model Java language array access expressions.\n+     *\/\n+    public abstract static sealed class ArrayAccessOp extends OpWithDefinition implements AccessOp, ReflectiveOp {\n+        ArrayAccessOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2 && def.operands().size() != 3) {\n+                throw new IllegalArgumentException(\"Operation must have 2 or 3 operands\");\n+            }\n+\n+            \/\/ @@@ validate first operand is an array\n+        }\n+\n+        ArrayAccessOp(ArrayAccessOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        ArrayAccessOp(ArrayAccessOp that, List<Value> operands) {\n+            super(that.opName(), operands);\n+        }\n+\n+        ArrayAccessOp(String name,\n+                      Value array, Value index, Value v) {\n+            super(name, operands(array, index, v));\n+        }\n+\n+        static List<Value> operands(Value array, Value index, Value v) {\n+            return v == null\n+                    ? List.of(array, index)\n+                    : List.of(array, index, v);\n+        }\n+\n+        static TypeElement resultType(Value array, Value v) {\n+            if (!(array.type() instanceof ArrayType arrayType)) {\n+                throw new IllegalArgumentException(\"Type is not an array type: \" + array.type());\n+            }\n+\n+            \/\/ @@@ restrict to indexes of int?\n+            TypeElement componentType = arrayType.componentType();\n+            if (v == null) {\n+                return componentType;\n+            } else {\n+                return JavaType.VOID;\n+            }\n+        }\n+\n+        \/**\n+         * The array load operation, that can model Java language array expressions combined with load access to the\n+         * components of an array.\n+         *\/\n+        @OpDeclaration(ArrayLoadOp.NAME)\n+        public static final class ArrayLoadOp extends ArrayAccessOp implements Op.Pure {\n+            public static final String NAME = \"array.load\";\n+\n+            public ArrayLoadOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            ArrayLoadOp(ArrayLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public ArrayLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new ArrayLoadOp(this, cc);\n+            }\n+\n+            ArrayLoadOp(Value array, Value index) {\n+                super(NAME, array, index, null);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                Value array = operands().get(0);\n+                ArrayType t = (ArrayType) array.type();\n+                return t.componentType();\n+            }\n+        }\n+\n+        \/**\n+         * The array store operation, that can model Java language array expressions combined with store access to the\n+         * components of an array.\n+         *\/\n+        @OpDeclaration(ArrayStoreOp.NAME)\n+        public static final class ArrayStoreOp extends ArrayAccessOp {\n+            public static final String NAME = \"array.store\";\n+\n+            public ArrayStoreOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            ArrayStoreOp(ArrayStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            @Override\n+            public ArrayStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new ArrayStoreOp(this, cc);\n+            }\n+\n+            ArrayStoreOp(Value array, Value index, Value v) {\n+                super(NAME, array, index, v);\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return JavaType.VOID;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The instanceof operation, that can model Java language instanceof expressions when the instanceof keyword is a\n+     * type comparison operator.\n+     *\/\n+    @OpDeclaration(InstanceOfOp.NAME)\n+    public static final class InstanceOfOp extends OpWithDefinition implements Op.Pure, ReflectiveOp {\n+        public static final String NAME = \"instanceof\";\n+        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final TypeElement typeDescriptor;\n+\n+        public static InstanceOfOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+\n+            TypeElement typeDescriptor = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+                    v -> switch (v) {\n+                        case String s -> JavaType.ofString(s);\n+                        case JavaType td -> td;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n+                    });\n+            return new InstanceOfOp(def, typeDescriptor);\n+        }\n+\n+        InstanceOfOp(OpDefinition def, TypeElement typeDescriptor) {\n+            super(def);\n+\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        InstanceOfOp(InstanceOfOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.typeDescriptor = that.typeDescriptor;\n+        }\n+\n+        @Override\n+        public InstanceOfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new InstanceOfOp(this, cc);\n+        }\n+\n+        InstanceOfOp(TypeElement t, Value v) {\n+            super(NAME,\n+                    List.of(v));\n+\n+            this.typeDescriptor = t;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", typeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeElement type() {\n+            return typeDescriptor;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The cast operation, that can model Java language cast expressions.\n+     *\/\n+    @OpDeclaration(CastOp.NAME)\n+    public static final class CastOp extends OpWithDefinition implements Op.Pure, ReflectiveOp {\n+        public static final String NAME = \"cast\";\n+        public static final String ATTRIBUTE_TYPE_DESCRIPTOR = NAME + \".descriptor\";\n+\n+        final TypeElement resultType;\n+        final TypeElement typeDescriptor;\n+\n+        public static CastOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand \" + def.name());\n+            }\n+\n+            TypeElement type = def.extractAttributeValue(ATTRIBUTE_TYPE_DESCRIPTOR, true,\n+                    v -> switch (v) {\n+                        case String s -> JavaType.ofString(s);\n+                        case JavaType td -> td;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported type descriptor value:\" + v);\n+                    });\n+            return new CastOp(def, type);\n+        }\n+\n+        CastOp(OpDefinition def, TypeElement typeDescriptor) {\n+            super(def);\n+\n+            this.resultType = def.resultType();\n+            this.typeDescriptor = typeDescriptor;\n+        }\n+\n+        CastOp(CastOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.resultType = that.resultType;\n+            this.typeDescriptor = that.typeDescriptor;\n+        }\n+\n+        @Override\n+        public CastOp transform(CopyContext cc, OpTransformer ot) {\n+            return new CastOp(this, cc);\n+        }\n+\n+        CastOp(TypeElement resultType, TypeElement t, Value v) {\n+            super(NAME, List.of(v));\n+\n+            this.resultType = resultType;\n+            this.typeDescriptor = t;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", typeDescriptor);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public TypeElement type() {\n+            return typeDescriptor;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+\n+    \/**\n+     * A runtime representation of a variable.\n+     *\n+     * @param <T> the type of the var's value.\n+     * @@@ Ideally should never be exposed\n+     * @@@ Move to interpreter?\n+     *\/\n+    public interface Var<T> {\n+        \/**\n+         * {@return the value of a var}\n+         *\/\n+        T value();\n+\n+        \/**\n+         * Constructs an instance of a var.\n+         *\n+         * @param value the initial value of the var.\n+         * @param <T>   the type of the var's value.\n+         * @return the var\n+         *\/\n+        static <T> Var<T> of(T value) {\n+            return () -> value;\n+        }\n+    }\n+\n+    \/**\n+     * The variable operation, that can model declarations of Java language local variables, method parameters, or\n+     * lambda parameters.\n+     *\/\n+    @OpDeclaration(VarOp.NAME)\n+    public static final class VarOp extends OpWithDefinition {\n+        public static final String NAME = \"var\";\n+        public static final String ATTRIBUTE_NAME = NAME + \".name\";\n+\n+        final String varName;\n+        final TypeElement resultType;\n+\n+        public static VarOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            String name = def.extractAttributeValue(ATTRIBUTE_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported var name value:\" + v);\n+                    });\n+            return new VarOp(def, name);\n+        }\n+\n+        VarOp(OpDefinition def, String varName) {\n+            super(def);\n+\n+            this.varName = varName;\n+            this.resultType = def.resultType();\n+        }\n+\n+        VarOp(VarOp that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.varName = that.varName;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public VarOp transform(CopyContext cc, OpTransformer ot) {\n+            return new VarOp(this, cc);\n+        }\n+\n+        VarOp(String varName, Value init) {\n+            this(varName, init.type(), init);\n+        }\n+\n+        VarOp(String varName, TypeElement type, Value init) {\n+            super(NAME, List.of(init));\n+\n+            this.varName = varName;\n+            this.resultType = VarType.varType(type);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            if (varName == null) {\n+                return super.attributes();\n+            }\n+\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", varName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public String varName() {\n+            return varName;\n+        }\n+\n+        public TypeElement varType() {\n+            return ((VarType) resultType).valueType();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The var access operation, that can model access to Java language local variables, method parameters, or\n+     * lambda parameters.\n+     *\/\n+    public abstract static sealed class VarAccessOp extends OpWithDefinition implements AccessOp {\n+        VarAccessOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        VarAccessOp(VarAccessOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        VarAccessOp(String name, List<Value> operands) {\n+            super(name, operands);\n+        }\n+\n+        public VarOp varOp() {\n+            \/\/ @@@ At a high-level a Var value occur as a BlockArgument.\n+            \/\/ Lowering should remove such cases and the var definition should emerge\n+            \/\/ @@@ This method is used when transforming to pure SSA\n+            Result variable = (Result) operands().get(0);\n+            return (VarOp) variable.op();\n+        }\n+\n+        static Value checkIsVarOp(Value varValue) {\n+            if (!(varValue.type() instanceof VarType)) {\n+                throw new IllegalArgumentException(\"Value's type is not a variable type: \" + varValue);\n+            }\n+            return varValue;\n+        }\n+\n+        \/**\n+         * The variable load operation, that models a reading variable.\n+         *\/\n+        @OpDeclaration(VarLoadOp.NAME)\n+        public static final class VarLoadOp extends VarAccessOp {\n+            public static final String NAME = \"var.load\";\n+\n+            public VarLoadOp(OpDefinition opdef) {\n+                super(opdef);\n+\n+                if (opdef.operands().size() != 1) {\n+                    throw new IllegalArgumentException(\"Operation must have one operand\");\n+                }\n+                checkIsVarOp(opdef.operands().get(0));\n+            }\n+\n+            VarLoadOp(VarLoadOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            VarLoadOp(List<Value> varValue) {\n+                super(NAME, varValue);\n+            }\n+\n+            @Override\n+            public VarLoadOp transform(CopyContext cc, OpTransformer ot) {\n+                return new VarLoadOp(this, cc);\n+            }\n+\n+            \/\/ (Variable)VarType\n+            VarLoadOp(Value varValue) {\n+                super(NAME, List.of(varValue));\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                VarType vt = (VarType) operands().get(0).type();\n+                return vt.valueType();\n+            }\n+        }\n+\n+        \/**\n+         * The variable store operation, that can model a variable assignment.\n+         *\/\n+        @OpDeclaration(VarStoreOp.NAME)\n+        public static final class VarStoreOp extends VarAccessOp {\n+            public static final String NAME = \"var.store\";\n+\n+            public VarStoreOp(OpDefinition opdef) {\n+                super(opdef);\n+\n+                if (opdef.operands().size() != 2) {\n+                    throw new IllegalArgumentException(\"Operation must have two operands\");\n+                }\n+                checkIsVarOp(opdef.operands().get(0));\n+            }\n+\n+            VarStoreOp(VarStoreOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            VarStoreOp(List<Value> values) {\n+                super(NAME,\n+                        values);\n+            }\n+\n+            @Override\n+            public VarStoreOp transform(CopyContext cc, OpTransformer ot) {\n+                return new VarStoreOp(this, cc);\n+            }\n+\n+            \/\/ (Variable, VarType)void\n+            VarStoreOp(Value varValue, Value v) {\n+                super(NAME,\n+                        List.of(varValue, v));\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return JavaType.VOID;\n+            }\n+        }\n+    }\n+\n+    \/\/ Tuple operations, for modelling return with multiple values\n+\n+    \/**\n+     * The tuple operation. A tuple contain a fixed set of values accessible by their component index.\n+     *\/\n+    @OpDeclaration(TupleOp.NAME)\n+    public static final class TupleOp extends OpWithDefinition {\n+        public static final String NAME = \"tuple\";\n+\n+        public TupleOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        TupleOp(TupleOp that, CopyContext cc) {\n+            this(cc.getValues(that.operands()));\n+        }\n+\n+        @Override\n+        public TupleOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleOp(this, cc);\n+        }\n+\n+        TupleOp(List<? extends Value> componentValues) {\n+            super(NAME, componentValues);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return TupleType.tupleTypeFromValues(operands());\n+        }\n+    }\n+\n+    \/**\n+     * The tuple component load operation, that access the component of a tuple at a given, constant, component index.\n+     *\/\n+    @OpDeclaration(TupleLoadOp.NAME)\n+    public static final class TupleLoadOp extends OpWithDefinition {\n+        public static final String NAME = \"tuple.load\";\n+        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n+\n+        final int index;\n+\n+        public static TupleLoadOp create(OpDefinition def) {\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n+                    });\n+            return new TupleLoadOp(def, index);\n+        }\n+\n+        TupleLoadOp(OpDefinition def, int index) {\n+            super(def);\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        TupleLoadOp(TupleLoadOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        TupleLoadOp(TupleLoadOp that, List<Value> values) {\n+            super(NAME, values);\n+\n+            this.index = that.index;\n+        }\n+\n+        @Override\n+        public TupleLoadOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleLoadOp(this, cc);\n+        }\n+\n+        TupleLoadOp(Value tupleValue, int index) {\n+            super(NAME, List.of(tupleValue));\n+\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", index);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int index() {\n+            return index;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            Value tupleValue = operands().get(0);\n+            TupleType t = (TupleType) tupleValue.type();\n+            return t.componentTypes().get(index);\n+        }\n+    }\n+\n+    \/**\n+     * The tuple component set operation, that access the component of a tuple at a given, constant, component index.\n+     *\/\n+    @OpDeclaration(TupleWithOp.NAME)\n+    public static final class TupleWithOp extends OpWithDefinition {\n+        public static final String NAME = \"tuple.with\";\n+        public static final String ATTRIBUTE_INDEX = NAME + \".index\";\n+\n+        final int index;\n+\n+        public static TupleWithOp create(OpDefinition def) {\n+            if (def.operands().size() != 2) {\n+                throw new IllegalStateException(\"Operation must have two operands\");\n+            }\n+\n+            int index = def.extractAttributeValue(ATTRIBUTE_INDEX, true,\n+                    v -> switch (v) {\n+                        case String s -> Integer.valueOf(s);\n+                        case Integer i -> i;\n+                        default -> throw new UnsupportedOperationException(\"Unsupported tuple index value:\" + v);\n+                    });\n+            return new TupleWithOp(def, index);\n+        }\n+\n+        TupleWithOp(OpDefinition def, int index) {\n+            super(def);\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        TupleWithOp(TupleWithOp that, CopyContext cc) {\n+            this(that, cc.getValues(that.operands()));\n+        }\n+\n+        TupleWithOp(TupleWithOp that, List<Value> values) {\n+            super(NAME, values);\n+\n+            this.index = that.index;\n+        }\n+\n+        @Override\n+        public TupleWithOp transform(CopyContext cc, OpTransformer ot) {\n+            return new TupleWithOp(this, cc);\n+        }\n+\n+        TupleWithOp(Value tupleValue, int index, Value value) {\n+            super(NAME, List.of(tupleValue, value));\n+\n+            \/\/ @@@ Validate tuple type and index\n+            this.index = index;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", index);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public int index() {\n+            return index;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            Value tupleValue = operands().get(0);\n+            TupleType tupleType = (TupleType) tupleValue.type();\n+            Value value = operands().get(2);\n+\n+            List<TypeElement> tupleComponentTypes = new ArrayList<>(tupleType.componentTypes());\n+            tupleComponentTypes.set(index, value.type());\n+            return TupleType.tupleType(tupleComponentTypes);\n+        }\n+    }\n+\n+    \/\/ @@@ Sealed\n+    \/\/ Synthetic\/hidden type that is the result type of an ExceptionRegionStart operation\n+    \/\/ and is an operand of an ExceptionRegionEnd operation\n+\n+    \/**\n+     * A synthetic exception region type, that is the operation result-type of an exception region\n+     * start operation.\n+     *\/\n+    \/\/ @@@: Create as new type element\n+    public interface ExceptionRegion {\n+        TypeElement EXCEPTION_REGION_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(\"ExceptionRegion\"));\n+    }\n+\n+    \/**\n+     * The exception region start operation.\n+     *\/\n+    @OpDeclaration(ExceptionRegionEnter.NAME)\n+    public static final class ExceptionRegionEnter extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"exception.region.enter\";\n+\n+        \/\/ First successor is the non-exceptional successor whose target indicates\n+        \/\/ the first block in the exception region.\n+        \/\/ One or more subsequent successors target the exception catching blocks\n+        \/\/ each of which have one block argument whose type is an exception type.\n+        final List<Block.Reference> s;\n+\n+        public ExceptionRegionEnter(OpDefinition def) {\n+            super(def);\n+\n+            if (def.successors().size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n+            }\n+\n+            this.s = List.copyOf(def.successors());\n+        }\n+\n+        ExceptionRegionEnter(ExceptionRegionEnter that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+        }\n+\n+        @Override\n+        public ExceptionRegionEnter transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionRegionEnter(this, cc);\n+        }\n+\n+        ExceptionRegionEnter(List<Block.Reference> s) {\n+            super(NAME, List.of());\n+\n+            if (s.size() < 2) {\n+                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            }\n+\n+            this.s = List.copyOf(s);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return s;\n+        }\n+\n+        public Block.Reference start() {\n+            return s.get(0);\n+        }\n+\n+        public List<Block.Reference> catchBlocks() {\n+            return s.subList(1, s.size());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return ExceptionRegion.EXCEPTION_REGION_TYPE;\n+        }\n+    }\n+\n+    \/**\n+     * The exception region end operation.\n+     *\/\n+    @OpDeclaration(ExceptionRegionExit.NAME)\n+    public static final class ExceptionRegionExit extends OpWithDefinition implements Op.BlockTerminating {\n+        public static final String NAME = \"exception.region.exit\";\n+\n+        final Block.Reference end;\n+\n+        public ExceptionRegionExit(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\" + def.name());\n+            }\n+\n+            if (def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one successor\" + def.name());\n+            }\n+\n+            this.end = def.successors().get(0);\n+        }\n+\n+        ExceptionRegionExit(ExceptionRegionExit that, CopyContext cc) {\n+            super(that, cc);\n+\n+            this.end = cc.getSuccessorOrCreate(that.end);\n+        }\n+\n+        @Override\n+        public ExceptionRegionExit transform(CopyContext cc, OpTransformer ot) {\n+            return new ExceptionRegionExit(this, cc);\n+        }\n+\n+        ExceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+            super(NAME, checkValue(exceptionRegion));\n+\n+            this.end = end;\n+        }\n+\n+        static List<Value> checkValue(Value er) {\n+            if (!(er instanceof Result or && or.op() instanceof ExceptionRegionEnter)) {\n+                throw new IllegalArgumentException(\n+                        \"Operand not the result of an exception.region.start operation: \" + er);\n+            }\n+\n+            return List.of(er);\n+        }\n+\n+        @Override\n+        public List<Block.Reference> successors() {\n+            return List.of(end);\n+        }\n+\n+        public Block.Reference end() {\n+            return end;\n+        }\n+\n+        public ExceptionRegionEnter regionStart() {\n+            if (operands().get(0) instanceof Result or &&\n+                    or.op() instanceof ExceptionRegionEnter ers) {\n+                return ers;\n+            }\n+            throw new InternalError(\"Should not reach here\");\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The String Concatenation Operation\n+     *\/\n+\n+    @OpDeclaration(ConcatOp.NAME)\n+    public static final class ConcatOp extends OpWithDefinition implements Op.Pure {\n+        public static final String NAME = \"concat\";\n+\n+        public ConcatOp(ConcatOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        public ConcatOp(OpDefinition def) {\n+            super(def);\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Concatenation Operation must have two operands.\");\n+            }\n+        }\n+\n+        public ConcatOp(Value lhs, Value rhs) {\n+            super(ConcatOp.NAME, List.of(lhs, rhs));\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new ConcatOp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.J_L_STRING;\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Arithmetic ops\n+\n+    \/**\n+     * The arithmetic operation.\n+     *\/\n+    public static abstract class ArithmeticOperation extends OpWithDefinition implements Op.Pure {\n+        protected ArithmeticOperation(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n+            }\n+        }\n+\n+        protected ArithmeticOperation(ArithmeticOperation that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected ArithmeticOperation(String name, List<Value> operands) {\n+            super(name, operands);\n+        }\n+    }\n+\n+    \/**\n+     * The test operation.\n+     *\/\n+    public static abstract class TestOperation extends OpWithDefinition implements Op.Pure {\n+        protected TestOperation(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().isEmpty()) {\n+                throw new IllegalArgumentException(\"Operation must have one or more operands\");\n+            }\n+        }\n+\n+        protected TestOperation(TestOperation that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected TestOperation(String name, List<Value> operands) {\n+            super(name, operands);\n+        }\n+    }\n+\n+    \/**\n+     * The binary arithmetic operation.\n+     *\/\n+    public static abstract class BinaryOp extends ArithmeticOperation {\n+        protected BinaryOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected BinaryOp(BinaryOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected BinaryOp(String name, Value lhs, Value rhs) {\n+            super(name, List.of(lhs, rhs));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return operands().get(0).type();\n+        }\n+    }\n+\n+    \/**\n+     * The unary arithmetic operation.\n+     *\/\n+    public static abstract class UnaryOp extends ArithmeticOperation {\n+        protected UnaryOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected UnaryOp(UnaryOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected UnaryOp(String name, Value v) {\n+            super(name, List.of(v));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return operands().get(0).type();\n+        }\n+    }\n+\n+    \/**\n+     * The unary test operation.\n+     *\/\n+    public static abstract class UnaryTestOp extends TestOperation {\n+        protected UnaryTestOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Number of operands must be 1: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected UnaryTestOp(UnaryTestOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected UnaryTestOp(String name, Value v) {\n+            super(name, List.of(v));\n+        }\n+    }\n+\n+    \/**\n+     * The binary test operation.\n+     *\/\n+    public static abstract class BinaryTestOp extends TestOperation {\n+        protected BinaryTestOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 2) {\n+                throw new IllegalArgumentException(\"Number of operands must be 2: \" + def.operands().size());\n+            }\n+        }\n+\n+        protected BinaryTestOp(BinaryTestOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        protected BinaryTestOp(String name, Value lhs, Value rhs) {\n+            super(name, List.of(lhs, rhs));\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The add operation, that can model the Java language binary {@code +} operator for numeric types\n+     *\/\n+    @OpDeclaration(AddOp.NAME)\n+    public static final class AddOp extends BinaryOp {\n+        public static final String NAME = \"add\";\n+\n+        public AddOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        AddOp(AddOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AddOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AddOp(this, cc);\n+        }\n+\n+        AddOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The sub operation, that can model the Java language binary {@code -} operator for numeric types\n+     *\/\n+    @OpDeclaration(SubOp.NAME)\n+    public static final class SubOp extends BinaryOp {\n+        public static final String NAME = \"sub\";\n+\n+        public SubOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        SubOp(SubOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public SubOp transform(CopyContext cc, OpTransformer ot) {\n+            return new SubOp(this, cc);\n+        }\n+\n+        SubOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The mul operation, that can model the Java language binary {@code *} operator for numeric types\n+     *\/\n+    @OpDeclaration(MulOp.NAME)\n+    public static final class MulOp extends BinaryOp {\n+        public static final String NAME = \"mul\";\n+\n+        public MulOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        MulOp(MulOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public MulOp transform(CopyContext cc, OpTransformer ot) {\n+            return new MulOp(this, cc);\n+        }\n+\n+        MulOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The div operation, that can model the Java language binary {@code \/} operator for numeric types\n+     *\/\n+    @OpDeclaration(DivOp.NAME)\n+    public static final class DivOp extends BinaryOp {\n+        public static final String NAME = \"div\";\n+\n+        public DivOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        DivOp(DivOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public DivOp transform(CopyContext cc, OpTransformer ot) {\n+            return new DivOp(this, cc);\n+        }\n+\n+        DivOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The mod operation, that can model the Java language binary {@code %} operator for numeric types\n+     *\/\n+    @OpDeclaration(ModOp.NAME)\n+    public static final class ModOp extends BinaryOp {\n+        public static final String NAME = \"mod\";\n+\n+        public ModOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        ModOp(ModOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public ModOp transform(CopyContext cc, OpTransformer ot) {\n+            return new ModOp(this, cc);\n+        }\n+\n+        ModOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The bitwise\/logical or operation, that can model the Java language binary {@code |} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpDeclaration(OrOp.NAME)\n+    public static final class OrOp extends BinaryOp {\n+        public static final String NAME = \"or\";\n+\n+        public OrOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        OrOp(OrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public OrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new OrOp(this, cc);\n+        }\n+\n+        OrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The bitwise\/logical and operation, that can model the Java language binary {@code &} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpDeclaration(AndOp.NAME)\n+    public static final class AndOp extends BinaryOp {\n+        public static final String NAME = \"and\";\n+\n+        public AndOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        AndOp(AndOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AndOp(this, cc);\n+        }\n+\n+        AndOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The xor operation, that can model the Java language binary {@code ^} operator for integral types\n+     * and booleans\n+     *\/\n+    @OpDeclaration(XorOp.NAME)\n+    public static final class XorOp extends BinaryOp {\n+        public static final String NAME = \"xor\";\n+\n+        public XorOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        XorOp(XorOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public XorOp transform(CopyContext cc, OpTransformer ot) {\n+            return new XorOp(this, cc);\n+        }\n+\n+        XorOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The (logical) shift left operation, that can model the Java language binary {@code <<} operator for integral types\n+     *\/\n+    @OpDeclaration(LshlOp.NAME)\n+    public static final class LshlOp extends BinaryOp {\n+        public static final String NAME = \"lshl\";\n+\n+        public LshlOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LshlOp(LshlOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LshlOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LshlOp(this, cc);\n+        }\n+\n+        LshlOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The (arithmetic) shift right operation, that can model the Java language binary {@code >>} operator for integral types\n+     *\/\n+    @OpDeclaration(AshrOp.NAME)\n+    public static final class AshrOp extends CoreOps.BinaryOp {\n+        public static final String NAME = \"ashr\";\n+\n+        public AshrOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        AshrOp(AshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public AshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AshrOp(this, cc);\n+        }\n+\n+        AshrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The unsigned (logical) shift right operation, that can model the Java language binary {@code >>>} operator for integral types\n+     *\/\n+    @OpDeclaration(LshrOp.NAME)\n+    public static final class LshrOp extends CoreOps.BinaryOp {\n+        public static final String NAME = \"lshr\";\n+\n+        public LshrOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LshrOp(LshrOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LshrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LshrOp(this, cc);\n+        }\n+\n+        LshrOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The neg operation, that can model the Java language unary {@code -} operator for numeric types\n+     *\/\n+    @OpDeclaration(NegOp.NAME)\n+    public static final class NegOp extends UnaryOp {\n+        public static final String NAME = \"neg\";\n+\n+        public NegOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        NegOp(NegOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NegOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NegOp(this, cc);\n+        }\n+\n+        NegOp(Value v) {\n+            super(NAME, v);\n+        }\n+    }\n+\n+    \/**\n+     * The not operation, that can model the Java language unary {@code !} operator for boolean types\n+     *\/\n+    @OpDeclaration(NotOp.NAME)\n+    public static final class NotOp extends UnaryOp {\n+        public static final String NAME = \"not\";\n+\n+        public NotOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        NotOp(NotOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NotOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NotOp(this, cc);\n+        }\n+\n+        NotOp(Value v) {\n+            super(NAME, v);\n+        }\n+    }\n+\n+    \/**\n+     * The equals operation, that can model the Java language equality {@code ==} operator for numeric, boolean\n+     * and reference types\n+     *\/\n+    @OpDeclaration(EqOp.NAME)\n+    public static final class EqOp extends BinaryTestOp {\n+        public static final String NAME = \"eq\";\n+\n+        public EqOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        EqOp(EqOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public EqOp transform(CopyContext cc, OpTransformer ot) {\n+            return new EqOp(this, cc);\n+        }\n+\n+        EqOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The not equals operation, that can model the Java language equality {@code !=} operator for numeric, boolean\n+     * and reference types\n+     *\/\n+    @OpDeclaration(NeqOp.NAME)\n+    public static final class NeqOp extends BinaryTestOp {\n+        public static final String NAME = \"neq\";\n+\n+        public NeqOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        NeqOp(NeqOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public NeqOp transform(CopyContext cc, OpTransformer ot) {\n+            return new NeqOp(this, cc);\n+        }\n+\n+        NeqOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The greater than operation, that can model the Java language relational {@code >} operator for numeric types\n+     *\/\n+    @OpDeclaration(GtOp.NAME)\n+    public static final class GtOp extends BinaryTestOp {\n+        public static final String NAME = \"gt\";\n+\n+        public GtOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        GtOp(GtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GtOp(this, cc);\n+        }\n+\n+        GtOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The greater than or equal to operation, that can model the Java language relational {@code >=} operator for\n+     * numeric types\n+     *\/\n+    @OpDeclaration(GeOp.NAME)\n+    public static final class GeOp extends BinaryTestOp {\n+        public static final String NAME = \"ge\";\n+\n+        public GeOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        GeOp(GeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public GeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new GeOp(this, cc);\n+        }\n+\n+        GeOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The less than operation, that can model the Java language relational {@code <} operator for\n+     * numeric types\n+     *\/\n+    @OpDeclaration(LtOp.NAME)\n+    public static final class LtOp extends BinaryTestOp {\n+        public static final String NAME = \"lt\";\n+\n+        public LtOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LtOp(LtOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LtOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LtOp(this, cc);\n+        }\n+\n+        LtOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+    \/**\n+     * The less than or equal to operation, that can model the Java language relational {@code <=} operator for\n+     * numeric types\n+     *\/\n+    @OpDeclaration(LeOp.NAME)\n+    public static final class LeOp extends BinaryTestOp {\n+        public static final String NAME = \"le\";\n+\n+        public LeOp(OpDefinition opdef) {\n+            super(opdef);\n+        }\n+\n+        LeOp(LeOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public LeOp transform(CopyContext cc, OpTransformer ot) {\n+            return new LeOp(this, cc);\n+        }\n+\n+        LeOp(Value lhs, Value rhs) {\n+            super(NAME, lhs, rhs);\n+        }\n+    }\n+\n+\n+    \/**\n+     * A factory for core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = OpFactory.OP_FACTORY.get(CoreOps.class);\n+\n+    \/**\n+     * Creates a function operation builder\n+     *\n+     * @param funcName the function name\n+     * @param funcType the function type\n+     * @return the function operation builder\n+     *\/\n+    public static FuncOp.Builder func(String funcName, FunctionType funcType) {\n+        return new FuncOp.Builder(null, funcName, funcType);\n+    }\n+\n+    \/**\n+     * Creates a function operation\n+     *\n+     * @param funcName the function name\n+     * @param body     the function body\n+     * @return the function operation\n+     *\/\n+    public static FuncOp func(String funcName, Body.Builder body) {\n+        return new FuncOp(funcName, body);\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param funcName the name of the function operation\n+     * @param funcType the function type\n+     * @param args     the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, FunctionType funcType, Value... args) {\n+        return funcCall(funcName, funcType, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param funcName the name of the function operation\n+     * @param funcType the function type\n+     * @param args     the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(String funcName, FunctionType funcType, List<Value> args) {\n+        return new FuncCallOp(funcName, funcType.returnType(), args);\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param func the target function\n+     * @param args the function arguments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(FuncOp func, Value... args) {\n+        return funcCall(func, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a function call operation\n+     *\n+     * @param func the target function\n+     * @param args the function argments\n+     * @return the function call operation\n+     *\/\n+    public static FuncCallOp funcCall(FuncOp func, List<Value> args) {\n+        return new FuncCallOp(func.funcName(), func.invokableType().returnType(), args);\n+    }\n+\n+    \/**\n+     * Creates a module operation.\n+     *\n+     * @param functions the functions of the module operation\n+     * @return the module operation\n+     *\/\n+    public static ModuleOp module(FuncOp... functions) {\n+        return module(List.of(functions));\n+    }\n+\n+    \/**\n+     * Creates a module operation.\n+     *\n+     * @param functions the functions of the module operation\n+     * @return the module operation\n+     *\/\n+    public static ModuleOp module(List<FuncOp> functions) {\n+        return new ModuleOp(List.copyOf(functions));\n+    }\n+\n+    \/**\n+     * Creates a quoted operation.\n+     *\n+     * @param ancestorBody the ancestor of the body of the quoted operation\n+     * @param opFunc       a function that accepts the body of the quoted operation and returns the operation to be quoted\n+     * @return the quoted operation\n+     *\/\n+    public static QuotedOp quoted(Body.Builder ancestorBody,\n+                                  Function<Block.Builder, Op> opFunc) {\n+        Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        Block.Builder block = body.entryBlock();\n+        block.op(_yield(\n+                block.op(opFunc.apply(block))));\n+        return new QuotedOp(body);\n+    }\n+\n+    \/**\n+     * Creates a quoted operation.\n+     *\n+     * @param body quoted operation body\n+     * @return the quoted operation\n+     *\/\n+    public static QuotedOp quoted(Body.Builder body) {\n+        return new QuotedOp(body);\n+    }\n+\n+    \/**\n+     * Creates a lambda operation.\n+     *\n+     * @param ancestorBody        the ancestor of the body of the lambda operation\n+     * @param funcType            the lambda operation's function type\n+     * @param functionalInterface the lambda operation's functional interface type\n+     * @return the lambda operation\n+     *\/\n+    public static LambdaOp.Builder lambda(Body.Builder ancestorBody,\n+                                          FunctionType funcType, TypeElement functionalInterface) {\n+        return new LambdaOp.Builder(ancestorBody, funcType, functionalInterface);\n+    }\n+\n+    \/**\n+     * Creates a lambda operation.\n+     *\n+     * @param functionalInterface the lambda operation's functional interface type\n+     * @param body                the body of the lambda operation\n+     * @return the lambda operation\n+     *\/\n+    public static LambdaOp lambda(TypeElement functionalInterface, Body.Builder body) {\n+        return new LambdaOp(functionalInterface, body);\n+    }\n+\n+    \/**\n+     * Creates a closure operation.\n+     *\n+     * @param ancestorBody the ancestor of the body of the closure operation\n+     * @param funcType     the closure operation's function type\n+     * @return the closure operation\n+     *\/\n+    public static ClosureOp.Builder closure(Body.Builder ancestorBody,\n+                                            FunctionType funcType) {\n+        return new ClosureOp.Builder(ancestorBody, funcType);\n+    }\n+\n+    \/**\n+     * Creates a closure operation.\n+     *\n+     * @param body the body of the closure operation\n+     * @return the closure operation\n+     *\/\n+    public static ClosureOp closure(Body.Builder body) {\n+        return new ClosureOp(body);\n+    }\n+\n+    \/**\n+     * Creates a closure call operation.\n+     *\n+     * @param args the closure arguments. The first argument is the closure operation to be called\n+     * @return the closure call operation\n+     *\/\n+    \/\/ @@@: Is this the right signature?\n+    public static ClosureCallOp closureCall(Value... args) {\n+        return closureCall(List.of(args));\n+    }\n+\n+    \/**\n+     * Creates a closure call operation.\n+     *\n+     * @param args the closure arguments. The first argument is the closure operation to be called\n+     * @return the closure call operation\n+     *\/\n+    \/\/ @@@: Is this the right signature?\n+    public static ClosureCallOp closureCall(List<Value> args) {\n+        return new ClosureCallOp(args);\n+    }\n+\n+    \/**\n+     * Creates an exception region enter operation\n+     *\n+     * @param start    the exception region block\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region enter operation\n+     *\/\n+    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, Block.Reference... catchers) {\n+        return exceptionRegionEnter(start, List.of(catchers));\n+    }\n+\n+    \/**\n+     * Creates an exception region enter operation\n+     *\n+     * @param start    the exception region block\n+     * @param catchers the blocks handling exceptions thrown by the region block\n+     * @return the exception region enter operation\n+     *\/\n+    public static ExceptionRegionEnter exceptionRegionEnter(Block.Reference start, List<Block.Reference> catchers) {\n+        List<Block.Reference> s = new ArrayList<>();\n+        s.add(start);\n+        s.addAll(catchers);\n+        return new ExceptionRegionEnter(s);\n+    }\n+\n+    \/**\n+     * Creates an exception region exit operation\n+     *\n+     * @param exceptionRegion the exception region to be exited\n+     * @param end             the block to which control is transferred after the exception region is exited\n+     * @return the exception region exit operation\n+     *\/\n+    public static ExceptionRegionExit exceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+        return new ExceptionRegionExit(exceptionRegion, end);\n+    }\n+\n+    \/**\n+     * Creates a return operation.\n+     *\n+     * @return the return operation\n+     *\/\n+    public static ReturnOp _return() {\n+        return new ReturnOp();\n+    }\n+\n+    \/**\n+     * Creates a return operation.\n+     *\n+     * @param returnValue the return value\n+     * @return the return operation\n+     *\/\n+    public static ReturnOp _return(Value returnValue) {\n+        return new ReturnOp(returnValue);\n+    }\n+\n+    \/**\n+     * Creates a throw operation.\n+     *\n+     * @param exceptionValue the thrown value\n+     * @return the throw operation\n+     *\/\n+    public static ThrowOp _throw(Value exceptionValue) {\n+        return new ThrowOp(exceptionValue);\n+    }\n+\n+    \/**\n+     * Creates an unreachable operation.\n+     *\n+     * @return the unreachable operation\n+     *\/\n+    public static UnreachableOp unreachable() {\n+        return new UnreachableOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     *\n+     * @return the yield operation\n+     *\/\n+    public static YieldOp _yield() {\n+        return new YieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     *\n+     * @param yieldValue the yielded value\n+     * @return the yield operation\n+     *\/\n+    public static YieldOp _yield(Value yieldValue) {\n+        return new YieldOp(List.of(yieldValue));\n+    }\n+\n+    \/**\n+     * Creates an assert operation.\n+     *\n+     * @param bodies the nested bodies\n+     * @return the assert operation\n+     *\/\n+    public static AssertOp _assert(List<Body.Builder> bodies) {\n+        return new AssertOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates an unconditional break operation.\n+     *\n+     * @param target the jump target\n+     * @return the unconditional break operation\n+     *\/\n+    public static BranchOp branch(Block.Reference target) {\n+        return new BranchOp(target);\n+    }\n+\n+    \/**\n+     * Creates a conditional break operation.\n+     *\n+     * @param condValue   the test value of the conditional break operation\n+     * @param trueTarget  the jump target when the test value evaluates to true\n+     * @param falseTarget the jump target when the test value evaluates to false\n+     * @return the conditional break operation\n+     *\/\n+    public static ConditionalBranchOp conditionalBranch(Value condValue,\n+                                                        Block.Reference trueTarget, Block.Reference falseTarget) {\n+        return new ConditionalBranchOp(condValue, trueTarget, falseTarget);\n+    }\n+\n+    \/**\n+     * Creates a constant operation.\n+     *\n+     * @param type  the constant type\n+     * @param value the constant value\n+     * @return the constant operation\n+     *\/\n+    public static ConstantOp constant(TypeElement type, Object value) {\n+        return new ConstantOp(type, value);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(MethodRef invokeDescriptor, Value... args) {\n+        return new InvokeOp(invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, Value... args) {\n+        return new InvokeOp(returnType, invokeDescriptor, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an invoke operation.\n+     *\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n+     * @return the invoke operation\n+     *\/\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(returnType, invokeDescriptor, args);\n+    }\n+\n+    \/**\n+     * Creates a conversion operation.\n+     *\n+     * @param to   the conversion target type\n+     * @param from the value to be converted\n+     * @return the conversion operation\n+     *\/\n+    public static ConvOp conv(TypeElement to, Value from) {\n+        return new ConvOp(to, from);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param constructorType the constructor type\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(FunctionType constructorType, Value... args) {\n+        return _new(constructorType, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param constructorType the constructor type\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(FunctionType constructorType, List<Value> args) {\n+        return new NewOp(constructorType, args);\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param constructorType the constructor type\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n+                             Value... args) {\n+        return _new(returnType, constructorType, List.of(args));\n+    }\n+\n+    \/**\n+     * Creates an instance creation operation.\n+     *\n+     * @param returnType      the instance type\n+     * @param constructorType the constructor type\n+     * @param args            the constructor arguments\n+     * @return the instance creation operation\n+     *\/\n+    public static NewOp _new(TypeElement returnType, FunctionType constructorType,\n+                             List<Value> args) {\n+        return new NewOp(returnType, constructorType, args);\n+    }\n+\n+    \/**\n+     * Creates an array creation operation.\n+     *\n+     * @param arrayType the array type\n+     * @param length    the array size\n+     * @return the array creation operation\n+     *\/\n+    public static NewOp newArray(TypeElement arrayType, Value length) {\n+        return _new(FunctionType.functionType(arrayType, JavaType.INT), length);\n+    }\n+\n+    \/\/ @@@ Add field load\/store overload with explicit fieldType\n+\n+    \/**\n+     * Creates a field load operation to a non-static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param receiver   the receiver value\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor, Value receiver) {\n+        return new FieldAccessOp.FieldLoadOp(descriptor.type(), descriptor, receiver);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a non-static field.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param descriptor the field descriptor\n+     * @param receiver   the receiver value\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor, Value receiver) {\n+        return new FieldAccessOp.FieldLoadOp(resultType, descriptor, receiver);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(FieldRef descriptor) {\n+        return new FieldAccessOp.FieldLoadOp(descriptor.type(), descriptor);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param descriptor the field descriptor\n+     * @return the field load operation\n+     *\/\n+    public static FieldAccessOp.FieldLoadOp fieldLoad(TypeElement resultType, FieldRef descriptor) {\n+        return new FieldAccessOp.FieldLoadOp(resultType, descriptor);\n+    }\n+\n+    \/**\n+     * Creates a field store operation to a non-static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param receiver   the receiver value\n+     * @param v          the value to store\n+     * @return the field store operation\n+     *\/\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value receiver, Value v) {\n+        return new FieldAccessOp.FieldStoreOp(descriptor, receiver, v);\n+    }\n+\n+    \/**\n+     * Creates a field load operation to a static field.\n+     *\n+     * @param descriptor the field descriptor\n+     * @param v          the value to store\n+     * @return the field store operation\n+     *\/\n+    public static FieldAccessOp.FieldStoreOp fieldStore(FieldRef descriptor, Value v) {\n+        return new FieldAccessOp.FieldStoreOp(descriptor, v);\n+    }\n+\n+    \/**\n+     * Creates an array length operation.\n+     *\n+     * @param array the array value\n+     * @return the array length operation\n+     *\/\n+    public static ArrayLengthOp arrayLength(Value array) {\n+        return new ArrayLengthOp(array);\n+    }\n+\n+    \/**\n+     * Creates an array load operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @return the array load operation\n+     *\/\n+    public static ArrayAccessOp.ArrayLoadOp arrayLoadOp(Value array, Value index) {\n+        return new ArrayAccessOp.ArrayLoadOp(array, index);\n+    }\n+\n+    \/**\n+     * Creates an array store operation.\n+     *\n+     * @param array the array value\n+     * @param index the index value\n+     * @param v     the value to store\n+     * @return the array store operation\n+     *\/\n+    public static ArrayAccessOp.ArrayStoreOp arrayStoreOp(Value array, Value index, Value v) {\n+        return new ArrayAccessOp.ArrayStoreOp(array, index, v);\n+    }\n+\n+    \/**\n+     * Creates an instanceof operation.\n+     *\n+     * @param t the type to test against\n+     * @param v the value to test\n+     * @return the instanceof operation\n+     *\/\n+    public static InstanceOfOp instanceOf(TypeElement t, Value v) {\n+        return new InstanceOfOp(t, v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param v          the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeElement resultType, Value v) {\n+        return new CastOp(resultType, resultType, v);\n+    }\n+\n+    \/**\n+     * Creates a cast operation.\n+     *\n+     * @param resultType the result type of the operation\n+     * @param t          the type to cast to\n+     * @param v          the value to cast\n+     * @return the cast operation\n+     *\/\n+    public static CastOp cast(TypeElement resultType, JavaType t, Value v) {\n+        return new CastOp(resultType, t, v);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(Value init) {\n+        return var(null, init);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, Value init) {\n+        return new VarOp(name, init);\n+    }\n+\n+    \/**\n+     * Creates a var operation.\n+     *\n+     * @param name the name of the var\n+     * @param type the type of the var's value\n+     * @param init the initial value of the var\n+     * @return the var operation\n+     *\/\n+    public static VarOp var(String name, TypeElement type, Value init) {\n+        return new VarOp(name, type, init);\n+    }\n+\n+    \/**\n+     * Creates a var load operation.\n+     *\n+     * @param varValue the var value\n+     * @return the var load operation\n+     *\/\n+    public static VarAccessOp.VarLoadOp varLoad(Value varValue) {\n+        return new VarAccessOp.VarLoadOp(varValue);\n+    }\n+\n+    \/**\n+     * Creates a var store operation.\n+     *\n+     * @param varValue the var value\n+     * @param v        the value to store in the var\n+     * @return the var store operation\n+     *\/\n+    public static VarAccessOp.VarStoreOp varStore(Value varValue, Value v) {\n+        return new VarAccessOp.VarStoreOp(varValue, v);\n+    }\n+\n+    \/**\n+     * Creates a tuple operation.\n+     *\n+     * @param componentValues the values of tuple (in order)\n+     * @return the tuple operation\n+     *\/\n+    public static TupleOp tuple(Value... componentValues) {\n+        return tuple(List.of(componentValues));\n+    }\n+\n+    \/**\n+     * Creates a tuple operation.\n+     *\n+     * @param componentValues the values of tuple (in order)\n+     * @return the tuple operation\n+     *\/\n+    public static TupleOp tuple(List<? extends Value> componentValues) {\n+        return new TupleOp(componentValues);\n+    }\n+\n+    \/**\n+     * Creates a tuple load operation.\n+     *\n+     * @param tuple the tuple value\n+     * @param index the component index value\n+     * @return the tuple load operation\n+     *\/\n+    public static TupleLoadOp tupleLoad(Value tuple, int index) {\n+        return new TupleLoadOp(tuple, index);\n+    }\n+\n+    \/**\n+     * Creates a tuple with operation.\n+     *\n+     * @param tuple the tuple value\n+     * @param index the component index value\n+     * @param value the component value\n+     * @return the tuple with operation\n+     *\/\n+    public static TupleWithOp tupleWith(Value tuple, int index, Value value) {\n+        return new TupleWithOp(tuple, index, value);\n+    }\n+\n+    \/\/\n+    \/\/ Arithmetic ops\n+\n+    \/**\n+     * Creates an add operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the add operation\n+     *\/\n+    public static BinaryOp add(Value lhs, Value rhs) {\n+        return new AddOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a sub operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the sub operation\n+     *\/\n+    public static BinaryOp sub(Value lhs, Value rhs) {\n+        return new SubOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mul operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mul operation\n+     *\/\n+    public static BinaryOp mul(Value lhs, Value rhs) {\n+        return new MulOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a div operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the div operation\n+     *\/\n+    public static BinaryOp div(Value lhs, Value rhs) {\n+        return new DivOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a mod operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the mod operation\n+     *\/\n+    public static BinaryOp mod(Value lhs, Value rhs) {\n+        return new ModOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical or operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the or operation\n+     *\/\n+    public static BinaryOp or(Value lhs, Value rhs) {\n+        return new OrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical and operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the and operation\n+     *\/\n+    public static BinaryOp and(Value lhs, Value rhs) {\n+        return new AndOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a bitwise\/logical xor operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp xor(Value lhs, Value rhs) {\n+        return new XorOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a left shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp lshl(Value lhs, Value rhs) {\n+        return new LshlOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a right shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp ashr(Value lhs, Value rhs) {\n+        return new AshrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates an unsigned right shift operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the xor operation\n+     *\/\n+    public static BinaryOp lshr(Value lhs, Value rhs) {\n+        return new LshrOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a neg operation.\n+     *\n+     * @param v the operand\n+     * @return the neg operation\n+     *\/\n+    public static UnaryOp neg(Value v) {\n+        return new NegOp(v);\n+    }\n+\n+    \/**\n+     * Creates a not operation.\n+     *\n+     * @param v the operand\n+     * @return the not operation\n+     *\/\n+    public static UnaryOp not(Value v) {\n+        return new NotOp(v);\n+    }\n+\n+\n+    \/**\n+     * Creates an equals comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the equals comparison operation\n+     *\/\n+    public static BinaryTestOp eq(Value lhs, Value rhs) {\n+        return new EqOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a not equals comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the not equals comparison operation\n+     *\/\n+    public static BinaryTestOp neq(Value lhs, Value rhs) {\n+        return new NeqOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a greater than comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the greater than comparison operation\n+     *\/\n+    public static BinaryTestOp gt(Value lhs, Value rhs) {\n+        return new GtOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a greater than or equals to comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the greater than or equals to comparison operation\n+     *\/\n+    public static BinaryTestOp ge(Value lhs, Value rhs) {\n+        return new GeOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a less than comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the less than comparison operation\n+     *\/\n+    public static BinaryTestOp lt(Value lhs, Value rhs) {\n+        return new LtOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a less than or equals to comparison operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the less than or equals to comparison operation\n+     *\/\n+    public static BinaryTestOp le(Value lhs, Value rhs) {\n+        return new LeOp(lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a string concatenation operation.\n+     *\n+     * @param lhs the first operand\n+     * @param rhs the second operand\n+     * @return the string concatenation operation\n+     *\/\n+    public static ConcatOp concat(Value lhs, Value rhs) {\n+        return new ConcatOp(lhs, rhs);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":3982,"deletions":0,"binary":false,"changes":3982,"status":"added"},{"patch":"@@ -0,0 +1,3151 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.TupleType;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.VarType;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.JavaType.*;\n+\n+\/**\n+ * The set of extended operations. A code model, produced by the Java compiler from Java program source, may consist of\n+ * extended operations and core operations. Such a model represents the same Java program and preserves the program\n+ * meaning as defined by the Java Language Specification\n+ * <p>\n+ * Extended operations model specific Java language constructs, often those with structured control flow and nested\n+ * code. Each operation is transformable into a sequence of core operations, commonly referred to as lowering. Those\n+ * that implement {@link Op.Lowerable} can transform themselves and will transform associated extended operations\n+ * that are not explicitly lowerable.\n+ * <p>\n+ * A code model, produced by the Java compiler from source, and consisting of extended operations and core operations\n+ * can be transformed to one consisting only of core operations, where all extended operations are lowered. This\n+ * transformation preserves programing meaning. The resulting lowered code model also represents the same Java program.\n+ *\/\n+public class ExtendedOps {\n+    \/\/ Split string to ensure the name does not get rewritten\n+    \/\/ when the script copies this source to the jdk.compiler module\n+    static final String PACKAGE_NAME = \"java.lang\" + \".reflect.code\";\n+\n+    static final String ExtendedOps_CLASS_NAME = PACKAGE_NAME + \".\" + ExtendedOps.class.getSimpleName();\n+\n+    ExtendedOps() {\n+    }\n+\n+    \/**\n+     * The label operation, that can model Java language statements with label identifiers.\n+     *\/\n+    public static sealed abstract class JavaLabelOp extends OpWithDefinition implements Op.Lowerable, Op.BodyTerminating {\n+        JavaLabelOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() > 1) {\n+                throw new IllegalArgumentException(\"Operation must have zero or one operand \" + def.name());\n+            }\n+        }\n+\n+        JavaLabelOp(JavaLabelOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        JavaLabelOp(String name, Value label) {\n+            super(name, checkLabel(label));\n+        }\n+\n+        static List<Value> checkLabel(Value label) {\n+            return label == null ? List.of() : List.of(label);\n+        }\n+\n+        Op innerMostEnclosingTarget() {\n+            \/*\n+                A break statement with no label attempts to transfer control to the\n+                innermost enclosing switch, while, do, or for statement; this enclosing statement,\n+                which is called the break target, then immediately completes normally.\n+\n+                A break statement with label Identifier attempts to transfer control to the\n+                enclosing labeled statement (14.7) that has the same Identifier as its label;\n+                this enclosing statement, which is called the break target, then immediately completes normally.\n+                In this case, the break target need not be a switch, while, do, or for statement.\n+             *\/\n+\n+            \/\/ No label\n+            \/\/ Get innermost enclosing loop operation\n+            \/\/ @@@ expand to support innermost enclosing switch operation\n+            Op op = this;\n+            Body b;\n+            do {\n+                b = op.ancestorBody();\n+                op = b.parentOp();\n+                if (op == null) {\n+                    throw new IllegalStateException(\"No enclosing loop\");\n+                }\n+            } while (!(op instanceof Op.Loop));\n+            \/\/ } while (!(op instanceof Op.Loop lop));\n+            \/\/ error: variable lop might not have been initialized\n+            Op.Loop lop = (Op.Loop) op;\n+            return lop.loopBody() == b ? op : null;\n+        }\n+\n+        boolean isUnlabeled() {\n+            return operands().isEmpty();\n+        }\n+\n+        Op target() {\n+            \/\/ If unlabeled then find the nearest enclosing op\n+            \/\/ Otherwise obtain the label target\n+            if (isUnlabeled()) {\n+                return innerMostEnclosingTarget();\n+            }\n+\n+            Value value = operands().get(0);\n+            if (value instanceof Result r && r.op().ancestorBody().parentOp() instanceof JavaLabeledOp lop) {\n+                return lop.target();\n+            } else {\n+                throw new IllegalStateException(\"Bad label value: \" + value + \" \" + ((Result) value).op());\n+            }\n+        }\n+\n+        Block.Builder lower(Block.Builder b, Function<BranchTarget, Block.Builder> f) {\n+            Op opt = target();\n+            BranchTarget t = getBranchTarget(b.context(), opt);\n+            if (t != null) {\n+                b.op(branch(f.apply(t).successor()));\n+            } else {\n+                throw new IllegalStateException(\"No branch target for operation: \" + opt);\n+            }\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language break statements with label identifiers.\n+     *\/\n+    @OpDeclaration(JavaBreakOp.NAME)\n+    public static final class JavaBreakOp extends JavaLabelOp {\n+        public static final String NAME = \"java.break\";\n+\n+        public JavaBreakOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaBreakOp(JavaBreakOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaBreakOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBreakOp(this, cc);\n+        }\n+\n+        JavaBreakOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::breakBlock);\n+        }\n+    }\n+\n+    \/**\n+     * The break operation, that can model Java language continue statements with label identifiers.\n+     *\/\n+    @OpDeclaration(JavaContinueOp.NAME)\n+    public static final class JavaContinueOp extends JavaLabelOp {\n+        public static final String NAME = \"java.continue\";\n+\n+        public JavaContinueOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaContinueOp(JavaContinueOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaContinueOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaContinueOp(this, cc);\n+        }\n+\n+        JavaContinueOp(Value label) {\n+            super(NAME, label);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, BranchTarget::continueBlock);\n+        }\n+    }\n+\n+    record BranchTarget(Block.Builder breakBlock, Block.Builder continueBlock) {\n+    }\n+\n+    static final String BRANCH_TARGET_MAP_PROPERTY_KEY = \"BRANCH_TARGET_MAP\";\n+\n+    static BranchTarget getBranchTarget(CopyContext cc, Op op) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Op, BranchTarget> m = (Map<Op, BranchTarget>) cc.getProperty(BRANCH_TARGET_MAP_PROPERTY_KEY);\n+        if (m != null) {\n+            return m.get(op);\n+        }\n+\n+        return null;\n+    }\n+\n+    static void setBranchTarget(CopyContext cc, Op label, BranchTarget t) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<Op, BranchTarget> x = (Map<Op, BranchTarget>) cc.computePropertyIfAbsent(\n+                BRANCH_TARGET_MAP_PROPERTY_KEY, k -> new HashMap<>());\n+        x.put(label, t);\n+    }\n+\n+    \/**\n+     * The yield operation, that can model Java language yield statements.\n+     *\/\n+    @OpDeclaration(JavaYieldOp.NAME)\n+    public static final class JavaYieldOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"java.yield\";\n+\n+        public JavaYieldOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaYieldOp(JavaYieldOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaYieldOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaYieldOp(this, cc);\n+        }\n+\n+        JavaYieldOp() {\n+            super(NAME,\n+                    List.of());\n+        }\n+\n+        JavaYieldOp(Value operand) {\n+            super(NAME, List.of(operand));\n+        }\n+\n+        public Value yieldValue() {\n+            if (operands().size() == 1) {\n+                return operands().get(0);\n+            } else {\n+                \/\/ @@@\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The block operation, that can model Java language blocks.\n+     *\/\n+    @OpDeclaration(JavaBlockOp.NAME)\n+    \/\/ @@@ Support synchronized attribute\n+    public static final class JavaBlockOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.block\";\n+\n+        final Body body;\n+\n+        public JavaBlockOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaBlockOp(JavaBlockOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaBlockOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaBlockOp(this, cc, ot);\n+        }\n+\n+        \/\/ @@@ Support non-void result type\n+        JavaBlockOp(Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The labeled operation, that can model Java language labeled statements.\n+     *\/\n+    @OpDeclaration(JavaLabeledOp.NAME)\n+    public static final class JavaLabeledOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.labeled\";\n+\n+        final Body body;\n+\n+        public JavaLabeledOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        JavaLabeledOp(JavaLabeledOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaLabeledOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaLabeledOp(this, cc, ot);\n+        }\n+\n+        JavaLabeledOp(Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (!body.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Body should have zero parameters: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        public Op label() {\n+            return body.entryBlock().firstOp();\n+        }\n+\n+        public Op target() {\n+            return body.entryBlock().nextOp(label());\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            AtomicBoolean first = new AtomicBoolean();\n+            b.transformBody(body, List.of(), opT.andThen((block, op) -> {\n+                \/\/ Drop first operation that corresponds to the label\n+                if (!first.get()) {\n+                    first.set(true);\n+                    return block;\n+                }\n+\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(exit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The if operation, that can model Java language if, if-then, and if-then-else statements.\n+     *\/\n+    @OpDeclaration(JavaIfOp.NAME)\n+    public static final class JavaIfOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        static final FunctionType PREDICATE_TYPE = FunctionType.functionType(BOOLEAN);\n+\n+        static final FunctionType ACTION_TYPE = FunctionType.VOID;\n+\n+        public static class IfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            IfBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+            }\n+\n+            public ThenBuilder _if(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ThenBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ThenBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ElseIfBuilder then(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+\n+            public ElseIfBuilder then() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new ElseIfBuilder(ancestorBody, bodies);\n+            }\n+        }\n+\n+        public static class ElseIfBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            public ElseIfBuilder(Body.Builder ancestorBody, List<Body.Builder> bodies) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = bodies;\n+            }\n+\n+            public ThenBuilder elseif(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, PREDICATE_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new ThenBuilder(ancestorBody, bodies);\n+            }\n+\n+            public JavaIfOp _else(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+\n+            public JavaIfOp _else() {\n+                Body.Builder body = Body.Builder.of(ancestorBody, ACTION_TYPE);\n+                body.entryBlock().op(_yield());\n+                bodies.add(body);\n+\n+                return new JavaIfOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.if\";\n+\n+        final List<Body> bodies;\n+\n+        public JavaIfOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaIfOp(JavaIfOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaIfOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaIfOp(this, cc, ot);\n+        }\n+\n+        JavaIfOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            \/\/ Normalize by adding an empty else action\n+            \/\/ @@@ Is this needed?\n+            if (bodyCs.size() % 2 == 0) {\n+                bodyCs = new ArrayList<>(bodyCs);\n+                Body.Builder end = Body.Builder.of(bodyCs.get(0).ancestorBody(),\n+                        FunctionType.VOID);\n+                end.entryBlock().op(_yield());\n+                bodyCs.add(end);\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+\n+            if (bodies.size() < 2) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body action;\n+                if (i == bodies.size() - 1) {\n+                    action = bodies.get(i);\n+                } else {\n+                    action = bodies.get(i + 1);\n+                    Body fromPred = bodies.get(i);\n+                    if (!fromPred.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                        throw new IllegalArgumentException(\"Illegal predicate body descriptor: \" + fromPred.bodyType());\n+                    }\n+                }\n+                if (!action.bodyType().equals(FunctionType.VOID)) {\n+                    throw new IllegalArgumentException(\"Illegal action body descriptor: \" + action.bodyType());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Create predicate and action blocks\n+            List<Block.Builder> builders = new ArrayList<>();\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                if (i == bodies.size() - 1) {\n+                    builders.add(b.block());\n+                } else {\n+                    builders.add(i == 0 ? b : b.block());\n+                    builders.add(b.block());\n+                }\n+            }\n+\n+            for (int i = 0; i < bodies.size(); i += 2) {\n+                Body actionBody;\n+                Block.Builder action;\n+                if (i == bodies.size() - 1) {\n+                    actionBody = bodies.get(i);\n+                    action = builders.get(i);\n+                } else {\n+                    Body predBody = bodies.get(i);\n+                    actionBody = bodies.get(i + 1);\n+\n+                    Block.Builder pred = builders.get(i);\n+                    action = builders.get(i + 1);\n+                    Block.Builder next = builders.get(i + 2);\n+\n+                    pred.transformBody(predBody, List.of(), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp yo) {\n+                            block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                                    action.successor(), next.successor()));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                        return block;\n+                    }));\n+                }\n+\n+                action.transformBody(actionBody, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The switch expression operation, that can model Java language switch expressions.\n+     *\/\n+    @OpDeclaration(JavaSwitchExpressionOp.NAME)\n+    public static final class JavaSwitchExpressionOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        public static final String NAME = \"java.switch.expression\";\n+\n+        final TypeElement resultType;\n+        final List<Body> bodies;\n+\n+        public JavaSwitchExpressionOp(OpDefinition def) {\n+            super(def);\n+\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaSwitchExpressionOp(JavaSwitchExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaSwitchExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaSwitchExpressionOp(TypeElement resultType, Value target, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of(target));\n+\n+            \/\/ Each case is modelled as a contiguous pair of bodies\n+            \/\/ The first body models the case labels, and the second models the case expression or statements\n+            \/\/ The labels body has a parameter whose type is target operand's type and returns a boolean value\n+            \/\/ The statements\/expression body has no parameters and returns the result whose type is the result of\n+            \/\/ the switch expression\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            \/\/ @@@ when resultType is null, we assume statements\/expressions bodies have the same yieldType\n+            this.resultType = resultType == null ? bodies.get(1).yieldType() : resultType;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The switch fall-through operation, that can model fall-through to the next statement in the switch block after\n+     * the last statement of the current switch label.\n+     *\/\n+    @OpDeclaration(JavaSwitchFallthroughOp.NAME)\n+    public static final class JavaSwitchFallthroughOp extends OpWithDefinition implements Op.BodyTerminating {\n+        public static final String NAME = \"java.switch.fallthrough\";\n+\n+        public JavaSwitchFallthroughOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaSwitchFallthroughOp(JavaSwitchFallthroughOp that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public JavaSwitchFallthroughOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaSwitchFallthroughOp(this, cc);\n+        }\n+\n+        JavaSwitchFallthroughOp() {\n+            super(NAME, List.of());\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The for operation, that can model a Java language for statement.\n+     *\/\n+    @OpDeclaration(JavaForOp.NAME)\n+    public static final class JavaForOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static final class InitBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+\n+            InitBuilder(Body.Builder ancestorBody,\n+                        List<? extends TypeElement> initTypes) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes.stream().map(VarType::varType).toList();\n+            }\n+\n+            public JavaForOp.CondBuilder init(Consumer<Block.Builder> c) {\n+                Body.Builder init = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(TupleType.tupleType(initTypes)));\n+                c.accept(init.entryBlock());\n+\n+                return new CondBuilder(ancestorBody, initTypes, init);\n+            }\n+        }\n+\n+        public static final class CondBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+\n+            public CondBuilder(Body.Builder ancestorBody,\n+                               List<? extends TypeElement> initTypes,\n+                               Body.Builder init) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+            }\n+\n+            public JavaForOp.UpdateBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder cond = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(BOOLEAN, initTypes));\n+                c.accept(cond.entryBlock());\n+\n+                return new UpdateBuilder(ancestorBody, initTypes, init, cond);\n+            }\n+        }\n+\n+        public static final class UpdateBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+\n+            public UpdateBuilder(Body.Builder ancestorBody,\n+                                 List<? extends TypeElement> initTypes,\n+                                 Body.Builder init, Body.Builder cond) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+            }\n+\n+            public JavaForOp.BodyBuilder cond(Consumer<Block.Builder> c) {\n+                Body.Builder update = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, initTypes));\n+                c.accept(update.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, initTypes, init, cond, update);\n+            }\n+\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> initTypes;\n+            final Body.Builder init;\n+            final Body.Builder cond;\n+            final Body.Builder update;\n+\n+            public BodyBuilder(Body.Builder ancestorBody,\n+                               List<? extends TypeElement> initTypes,\n+                               Body.Builder init, Body.Builder cond, Body.Builder update) {\n+                this.ancestorBody = ancestorBody;\n+                this.initTypes = initTypes;\n+                this.init = init;\n+                this.cond = cond;\n+                this.update = update;\n+            }\n+\n+            public JavaForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, initTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaForOp(init, cond, update, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.for\";\n+\n+        final Body init;\n+        final Body cond;\n+        final Body update;\n+        final Body body;\n+\n+        public static JavaForOp create(OpDefinition def) {\n+            return new JavaForOp(def);\n+        }\n+\n+        public JavaForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.init = def.bodyDefinitions().get(0).build(this);\n+            this.cond = def.bodyDefinitions().get(1).build(this);\n+            this.update = def.bodyDefinitions().get(2).build(this);\n+            this.body = def.bodyDefinitions().get(3).build(this);\n+        }\n+\n+        JavaForOp(JavaForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.cond = that.cond.transform(cc, ot).build(this);\n+            this.update = that.update.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaForOp(this, cc, ot);\n+        }\n+\n+        JavaForOp(Body.Builder initC,\n+                  Body.Builder condC,\n+                  Body.Builder updateC,\n+                  Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.init = initC.build(this);\n+\n+            this.cond = condC.build(this);\n+\n+            this.update = updateC.build(this);\n+            if (!update.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Update should return void: \" + update.bodyType());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(init, cond, update, body);\n+        }\n+\n+        public Body init() {\n+            return init;\n+        }\n+\n+        public Body cond() {\n+            return cond;\n+        }\n+\n+        public Body update() {\n+            return update;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder update = b.block();\n+            Block.Builder exit = b.block();\n+\n+            List<Value> initValues = new ArrayList<>();\n+            \/\/ @@@ Init body has one yield operation yielding\n+            \/\/  void, a single variable, or a tuple of one or more variables\n+            b.transformBody(init, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.TupleOp) {\n+                    \/\/ Drop Tuple if a yielded\n+                    boolean isResult = op.result().uses().size() == 1 &&\n+                            op.result().uses().stream().allMatch(r -> r.op() instanceof YieldOp);\n+                    if (!isResult) {\n+                        block.op(op);\n+                    }\n+                } else if (op instanceof YieldOp yop) {\n+                    if (yop.yieldValue() == null) {\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    } else if (yop.yieldValue() instanceof Result or) {\n+                        if (or.op() instanceof CoreOps.TupleOp top) {\n+                            initValues.addAll(block.context().getValues(top.operands()));\n+                        } else {\n+                            initValues.addAll(block.context().getValues(yop.operands()));\n+                        }\n+                        block.op(branch(header.successor()));\n+                        return block;\n+                    }\n+\n+                    throw new IllegalStateException(\"Bad yield operation\");\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(cond, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+            body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            update.transformBody(this.update, initValues, opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    block.op(branch(header.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The enhanced for operation, that can model a Java language enhanced for statement.\n+     *\/\n+    @OpDeclaration(JavaEnhancedForOp.NAME)\n+    public static final class JavaEnhancedForOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static final class ExpressionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement iterableType;\n+            final TypeElement elementType;\n+\n+            ExpressionBuilder(Body.Builder ancestorBody,\n+                              TypeElement iterableType, TypeElement elementType) {\n+                this.ancestorBody = ancestorBody;\n+                this.iterableType = iterableType;\n+                this.elementType = elementType;\n+            }\n+\n+            public DefinitionBuilder expression(Consumer<Block.Builder> c) {\n+                Body.Builder expression = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(iterableType));\n+                c.accept(expression.entryBlock());\n+\n+                return new DefinitionBuilder(ancestorBody, elementType, expression);\n+            }\n+        }\n+\n+        public static final class DefinitionBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement elementType;\n+            final Body.Builder expression;\n+\n+            DefinitionBuilder(Body.Builder ancestorBody,\n+                              TypeElement elementType, Body.Builder expression) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+            }\n+\n+            public BodyBuilder definition(Consumer<Block.Builder> c) {\n+                return definition(elementType, c);\n+            }\n+\n+            public BodyBuilder definition(TypeElement bodyElementType, Consumer<Block.Builder> c) {\n+                Body.Builder definition = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(bodyElementType, elementType));\n+                c.accept(definition.entryBlock());\n+\n+                return new BodyBuilder(ancestorBody, elementType, expression, definition);\n+            }\n+        }\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement elementType;\n+            final Body.Builder expression;\n+            final Body.Builder definition;\n+\n+            BodyBuilder(Body.Builder ancestorBody,\n+                        TypeElement elementType, Body.Builder expression, Body.Builder definition) {\n+                this.ancestorBody = ancestorBody;\n+                this.elementType = elementType;\n+                this.expression = expression;\n+                this.definition = definition;\n+            }\n+\n+            public JavaEnhancedForOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, elementType));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaEnhancedForOp(expression, definition, body);\n+            }\n+        }\n+\n+        static final String NAME = \"java.enhancedFor\";\n+\n+        final Body expression;\n+        final Body init;\n+        final Body body;\n+\n+        public static JavaEnhancedForOp create(OpDefinition def) {\n+            return new JavaEnhancedForOp(def);\n+        }\n+\n+        public JavaEnhancedForOp(OpDefinition def) {\n+            super(def);\n+\n+            this.expression = def.bodyDefinitions().get(0).build(this);\n+            this.init = def.bodyDefinitions().get(1).build(this);\n+            this.body = def.bodyDefinitions().get(2).build(this);\n+        }\n+\n+        JavaEnhancedForOp(JavaEnhancedForOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.expression = that.expression.transform(cc, ot).build(this);\n+            this.init = that.init.transform(cc, ot).build(this);\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public JavaEnhancedForOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaEnhancedForOp(this, cc, ot);\n+        }\n+\n+        JavaEnhancedForOp(Body.Builder expressionC, Body.Builder initC, Body.Builder bodyC) {\n+            super(NAME, List.of());\n+\n+            this.expression = expressionC.build(this);\n+            if (expression.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Expression should return non-void value: \" + expression.bodyType());\n+            }\n+            if (!expression.bodyType().parameterTypes().isEmpty()) {\n+                throw new IllegalArgumentException(\"Expression should have zero parameters: \" + expression.bodyType());\n+            }\n+\n+            this.init = initC.build(this);\n+            if (init.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Initialization should return non-void value: \" + init.bodyType());\n+            }\n+            if (init.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Initialization should have one parameter: \" + init.bodyType());\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Body should return void: \" + body.bodyType());\n+            }\n+            if (body.bodyType().parameterTypes().size() != 1) {\n+                throw new IllegalArgumentException(\"Body should have one parameter: \" + body.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(expression, init, body);\n+        }\n+\n+        public Body expression() {\n+            return expression;\n+        }\n+\n+        public Body initialization() {\n+            return init;\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return body;\n+        }\n+\n+        static final MethodRef ITERABLE_ITERATOR = MethodRef.method(Iterable.class, \"iterator\", Iterator.class);\n+        static final MethodRef ITERATOR_HAS_NEXT = MethodRef.method(Iterator.class, \"hasNext\", boolean.class);\n+        static final MethodRef ITERATOR_NEXT = MethodRef.method(Iterator.class, \"next\", Object.class);\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            JavaType elementType = (JavaType) init.entryBlock().parameters().get(0).type();\n+            boolean isArray = expression.bodyType().returnType() instanceof ArrayType;\n+\n+            Block.Builder preHeader = b.block(expression.bodyType().returnType());\n+            Block.Builder header = b.block(isArray ? List.of(INT) : List.of());\n+            Block.Builder init = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.transformBody(expression, List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yop) {\n+                    Value loopSource = block.context().getValue(yop.yieldValue());\n+                    block.op(branch(preHeader.successor(loopSource)));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            if (isArray) {\n+                Value array = preHeader.parameters().get(0);\n+                Value arrayLength = preHeader.op(arrayLength(array));\n+                Value i = preHeader.op(constant(INT, 0));\n+                preHeader.op(branch(header.successor(i)));\n+\n+                i = header.parameters().get(0);\n+                Value p = header.op(lt(i, arrayLength));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(arrayLoadOp(array, i));\n+                List<Value> initValues = new ArrayList<>();\n+                \/\/ @@@ Init body has one yield operation yielding a single variable\n+                init.transformBody(this.init, List.of(e), (block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                });\n+\n+                Block.Builder update = b.block();\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, update));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                i = update.op(add(i, update.op(constant(INT, 1))));\n+                update.op(branch(header.successor(i)));\n+            } else {\n+                JavaType iterable = type(type(Iterator.class), elementType);\n+                Value iterator = preHeader.op(CoreOps.invoke(iterable, ITERABLE_ITERATOR, preHeader.parameters().get(0)));\n+                preHeader.op(branch(header.successor()));\n+\n+                Value p = header.op(CoreOps.invoke(ITERATOR_HAS_NEXT, iterator));\n+                header.op(conditionalBranch(p, init.successor(), exit.successor()));\n+\n+                Value e = init.op(CoreOps.invoke(elementType, ITERATOR_NEXT, iterator));\n+                List<Value> initValues = new ArrayList<>();\n+                init.transformBody(this.init, List.of(e), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        initValues.addAll(block.context().getValues(yop.operands()));\n+                        block.op(branch(body.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+                body.transformBody(this.body, initValues, opT.andThen((block, op) -> {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The while operation, that can model a Java language while statement.\n+     *\/\n+    @OpDeclaration(JavaWhileOp.NAME)\n+    public static final class JavaWhileOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            PredicateBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaWhileOp.BodyBuilder predicate(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp.BodyBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder predicate;\n+\n+            BodyBuilder(Body.Builder ancestorBody, Body.Builder predicate) {\n+                this.ancestorBody = ancestorBody;\n+                this.predicate = predicate;\n+            }\n+\n+            public JavaWhileOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaWhileOp(List.of(predicate, body));\n+            }\n+        }\n+\n+        private static final String NAME = \"java.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaWhileOp(OpDefinition def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaWhileOp(Body.Builder predicate, Body.Builder body) {\n+            super(NAME, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(predicate, body).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            \/\/ @@@ This will change with pattern bindings\n+            if (!bodies.get(0).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n+            }\n+            if (!bodies.get(1).bodyType().equals(FunctionType.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n+            }\n+        }\n+\n+        JavaWhileOp(JavaWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder header = b.block();\n+            Block.Builder body = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(header.successor()));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The do-while operation, that can model a Java language do statement.\n+     *\/\n+    \/\/ @@@ Unify JavaDoWhileOp and JavaWhileOp with common abstract superclass\n+    @OpDeclaration(JavaDoWhileOp.NAME)\n+    public static final class JavaDoWhileOp extends OpWithDefinition implements Op.Loop, Op.Lowerable {\n+\n+        public static class PredicateBuilder {\n+            final Body.Builder ancestorBody;\n+            private final Body.Builder body;\n+\n+            PredicateBuilder(Body.Builder ancestorBody, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.body = body;\n+            }\n+\n+            public JavaDoWhileOp predicate(Consumer<Block.Builder> c) {\n+                Body.Builder predicate = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(predicate.entryBlock());\n+\n+                return new JavaDoWhileOp(List.of(body, predicate));\n+            }\n+        }\n+\n+        public static class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+\n+            BodyBuilder(Body.Builder ancestorBody) {\n+                this.ancestorBody = ancestorBody;\n+            }\n+\n+            public JavaDoWhileOp.PredicateBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(body.entryBlock());\n+\n+                return new JavaDoWhileOp.PredicateBuilder(ancestorBody, body);\n+            }\n+        }\n+\n+        private static final String NAME = \"java.do.while\";\n+\n+        private final List<Body> bodies;\n+\n+        public JavaDoWhileOp(OpDefinition def) {\n+            super(def);\n+\n+            \/\/ @@@ Validate\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+        }\n+\n+        JavaDoWhileOp(Body.Builder body, Body.Builder predicate) {\n+            super(NAME, List.of());\n+\n+            Objects.requireNonNull(body);\n+\n+            this.bodies = Stream.of(body, predicate).filter(Objects::nonNull)\n+                    .map(bc -> bc.build(this)).toList();\n+\n+            if (!bodies.get(0).bodyType().equals(FunctionType.VOID)) {\n+                throw new IllegalArgumentException(\n+                        \"Body descriptor should be \" + FunctionType.functionType(VOID) +\n+                                \" but is \" + bodies.get(1).bodyType());\n+            }\n+            if (!bodies.get(1).bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\n+                        \"Predicate body descriptor should be \" + FunctionType.functionType(BOOLEAN) +\n+                                \" but is \" + bodies.get(0).bodyType());\n+            }\n+        }\n+\n+        JavaDoWhileOp(JavaDoWhileOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        @Override\n+        public JavaDoWhileOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaDoWhileOp(this, cc, ot);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        public Body predicateBody() {\n+            return bodies.get(1);\n+        }\n+\n+        @Override\n+        public Body loopBody() {\n+            return bodies.get(0);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder body = b.block();\n+            Block.Builder header = b.block();\n+            Block.Builder exit = b.block();\n+\n+            b.op(branch(body.successor()));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, header));\n+\n+            body.transformBody(loopBody(), List.of(), opT.andThen((block, op) -> {\n+                \/\/ @@@ Composition of lowerable ops\n+                if (op instanceof Lowerable lop) {\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            header.transformBody(predicateBody(), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof CoreOps.YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            body.successor(), exit.successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and-or operation, that can model Java language condition-or or conditional-and expressions.\n+     *\/\n+    public static sealed abstract class JavaConditionalOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+        final List<Body> bodies;\n+\n+        public JavaConditionalOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(JavaConditionalOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream().map(b -> b.transform(cc, ot).build(this)).toList();\n+        }\n+\n+        JavaConditionalOp(String name, List<Body.Builder> bodyCs) {\n+            super(name, List.of());\n+\n+            if (bodyCs.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            for (Body b : bodies) {\n+                if (!b.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                    throw new IllegalArgumentException(\"Body conditional body descriptor: \" + b.bodyType());\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        static Block.Builder lower(Block.Builder startBlock, OpTransformer opT, JavaConditionalOp cop) {\n+            List<Body> bodies = cop.bodies();\n+\n+            Block.Builder exit = startBlock.block();\n+            TypeElement oprType = cop.result().type();\n+            Block.Parameter arg = exit.parameter(oprType);\n+            startBlock.context().mapValue(cop.result(), arg);\n+\n+            \/\/ Transform bodies in reverse order\n+            \/\/ This makes available the blocks to be referenced as successors in prior blocks\n+\n+            Block.Builder pred = null;\n+            for (int i = bodies.size() - 1; i >= 0; i--) {\n+                OpTransformer opt;\n+                if (i == bodies.size() - 1) {\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOps.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            block.op(branch(exit.successor(p)));\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                } else {\n+                    Block.Builder nextPred = pred;\n+                    opt = (block, op) -> {\n+                        if (op instanceof CoreOps.YieldOp yop) {\n+                            Value p = block.context().getValue(yop.yieldValue());\n+                            if (cop instanceof JavaConditionalAndOp) {\n+                                block.op(conditionalBranch(p, nextPred.successor(), exit.successor(p)));\n+                            } else {\n+                                block.op(conditionalBranch(p, exit.successor(p), nextPred.successor()));\n+                            }\n+                        } else if (op instanceof Lowerable lop) {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            \/\/ Copy\n+                            block.apply(op);\n+                        }\n+                        return block;\n+                    };\n+                }\n+\n+                Body fromPred = bodies.get(i);\n+                if (i == 0) {\n+                    startBlock.transformBody(fromPred, List.of(), opt);\n+                } else {\n+                    pred = startBlock.block(fromPred.bodyType().parameterTypes());\n+                    pred.transformBody(fromPred, pred.parameters(), opT.andThen(opt));\n+                }\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return BOOLEAN;\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-and operation, that can model Java language conditional-and expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalAndOp.NAME)\n+    public static final class JavaConditionalAndOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                and(lhs);\n+                and(rhs);\n+            }\n+\n+            public Builder and(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalAndOp build() {\n+                return new JavaConditionalAndOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cand\";\n+\n+        public JavaConditionalAndOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalAndOp(JavaConditionalAndOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalAndOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalAndOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalAndOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional-or operation, that can model Java language conditional-or expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalOrOp.NAME)\n+    public static final class JavaConditionalOrOp extends JavaConditionalOp {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final List<Body.Builder> bodies;\n+\n+            Builder(Body.Builder ancestorBody, Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+                this.ancestorBody = ancestorBody;\n+                this.bodies = new ArrayList<>();\n+                or(lhs);\n+                or(rhs);\n+            }\n+\n+            public Builder or(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(BOOLEAN));\n+                c.accept(body.entryBlock());\n+                bodies.add(body);\n+\n+                return this;\n+            }\n+\n+            public JavaConditionalOrOp build() {\n+                return new JavaConditionalOrOp(bodies);\n+            }\n+        }\n+\n+        public static final String NAME = \"java.cor\";\n+\n+        public JavaConditionalOrOp(OpDefinition def) {\n+            super(def);\n+        }\n+\n+        JavaConditionalOrOp(JavaConditionalOrOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc, ot);\n+        }\n+\n+        @Override\n+        public JavaConditionalOrOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalOrOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalOrOp(List<Body.Builder> bodyCs) {\n+            super(NAME, bodyCs);\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return lower(b, opT, this);\n+        }\n+    }\n+\n+    \/**\n+     * The conditional operation, that can model Java language conditional operator {@code ?} expressions.\n+     *\/\n+    @OpDeclaration(JavaConditionalExpressionOp.NAME)\n+    public static final class JavaConditionalExpressionOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        public static final String NAME = \"java.cexpression\";\n+\n+        final TypeElement resultType;\n+        \/\/ {cond, truepart, falsepart}\n+        final List<Body> bodies;\n+\n+        public JavaConditionalExpressionOp(OpDefinition def) {\n+            super(def);\n+\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Operation must have no operands\");\n+            }\n+\n+            \/\/ @@@ Validate\n+\n+            this.bodies = def.bodyDefinitions().stream().map(bd -> bd.build(this)).toList();\n+            this.resultType = def.resultType();\n+        }\n+\n+        JavaConditionalExpressionOp(JavaConditionalExpressionOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            \/\/ Copy body\n+            this.bodies = that.bodies.stream()\n+                    .map(b -> b.transform(cc, ot).build(this)).toList();\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public JavaConditionalExpressionOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaConditionalExpressionOp(this, cc, ot);\n+        }\n+\n+        JavaConditionalExpressionOp(TypeElement expressionType, List<Body.Builder> bodyCs) {\n+            super(NAME, List.of());\n+\n+            this.bodies = bodyCs.stream().map(bc -> bc.build(this)).toList();\n+            \/\/ @@@ when expressionType is null, we assume truepart and falsepart have the same yieldType\n+            this.resultType = expressionType == null ? bodies.get(1).yieldType() : expressionType;\n+\n+            if (bodies.size() < 3) {\n+                throw new IllegalArgumentException(\"Incorrect number of bodies: \" + bodies.size());\n+            }\n+\n+            Body cond = bodies.get(0);\n+            if (!cond.bodyType().equals(FunctionType.functionType(BOOLEAN))) {\n+                throw new IllegalArgumentException(\"Illegal cond body descriptor: \" + cond.bodyType());\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return bodies;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            Block.Builder exit = b.block(resultType());\n+            exit.context().mapValue(result(), exit.parameters().get(0));\n+\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            List<Block.Builder> builders = List.of(b.block(), b.block());\n+            b.transformBody(bodies.get(0), List.of(), opT.andThen((block, op) -> {\n+                if (op instanceof YieldOp yo) {\n+                    block.op(conditionalBranch(block.context().getValue(yo.yieldValue()),\n+                            builders.get(0).successor(), builders.get(1).successor()));\n+                } else if (op instanceof Lowerable lop) {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    block = lop.lower(block, opT);\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            }));\n+\n+            for (int i = 0; i < 2; i++) {\n+                builders.get(i).transformBody(bodies.get(i + 1), List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp yop) {\n+                        block.op(branch(exit.successor(block.context().getValue(yop.yieldValue()))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            return exit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+    }\n+\n+    \/**\n+     * The try operation, that can model Java language try statements.\n+     *\/\n+    @OpDeclaration(JavaTryOp.NAME)\n+    public static final class JavaTryOp extends OpWithDefinition implements Op.Nested, Op.Lowerable {\n+\n+        public static final class BodyBuilder {\n+            final Body.Builder ancestorBody;\n+            final List<? extends TypeElement> resourceTypes;\n+            final Body.Builder resources;\n+\n+            BodyBuilder(Body.Builder ancestorBody, List<? extends TypeElement> resourceTypes, Body.Builder resources) {\n+                this.ancestorBody = ancestorBody;\n+                this.resourceTypes = resourceTypes;\n+                this.resources = resources;\n+            }\n+\n+            public CatchBuilder body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, resourceTypes));\n+                c.accept(body.entryBlock());\n+\n+                return new CatchBuilder(ancestorBody, resources, body);\n+            }\n+        }\n+\n+        public static final class CatchBuilder {\n+            final Body.Builder ancestorBody;\n+            final Body.Builder resources;\n+            final Body.Builder body;\n+            final List<Body.Builder> catchers;\n+\n+            CatchBuilder(Body.Builder ancestorBody, Body.Builder resources, Body.Builder body) {\n+                this.ancestorBody = ancestorBody;\n+                this.resources = resources;\n+                this.body = body;\n+                this.catchers = new ArrayList<>();\n+            }\n+\n+            \/\/ @@@ multi-catch\n+            public CatchBuilder _catch(TypeElement exceptionType, Consumer<Block.Builder> c) {\n+                Body.Builder _catch = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(VOID, exceptionType));\n+                c.accept(_catch.entryBlock());\n+                catchers.add(_catch);\n+\n+                return this;\n+            }\n+\n+            public JavaTryOp _finally(Consumer<Block.Builder> c) {\n+                Body.Builder _finally = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+                c.accept(_finally.entryBlock());\n+\n+                return new JavaTryOp(resources, body, catchers, _finally);\n+            }\n+\n+            public JavaTryOp noFinalizer() {\n+                return new JavaTryOp(resources, body, catchers, null);\n+            }\n+        }\n+\n+        static final String NAME = \"java.try\";\n+\n+        final Body resources;\n+        final Body body;\n+        final List<Body> catchers;\n+        final Body finalizer;\n+\n+        public static JavaTryOp create(OpDefinition def) {\n+            return new JavaTryOp(def);\n+        }\n+\n+        public JavaTryOp(OpDefinition def) {\n+            super(def);\n+\n+            List<Body> bodies = def.bodyDefinitions().stream().map(b -> b.build(this)).toList();\n+            Body first = bodies.get(0);\n+            if (first.bodyType().returnType().equals(VOID)) {\n+                this.resources = null;\n+                this.body = first;\n+            } else {\n+                this.resources = first;\n+                this.body = bodies.get(1);\n+            }\n+\n+            Body last = bodies.get(bodies.size() - 1);\n+            if (last.bodyType().parameterTypes().isEmpty()) {\n+                this.finalizer = last;\n+            } else {\n+                this.finalizer = null;\n+            }\n+            this.catchers = bodies.subList(\n+                    resources == null ? 1 : 2,\n+                    bodies.size() - (finalizer == null ? 0 : 1));\n+        }\n+\n+        JavaTryOp(JavaTryOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            if (that.resources != null) {\n+                this.resources = that.resources.transform(cc, ot).build(this);\n+            } else {\n+                this.resources = null;\n+            }\n+            this.body = that.body.transform(cc, ot).build(this);\n+            this.catchers = that.catchers.stream()\n+                    .map(b -> b.transform(cc, ot).build(this))\n+                    .toList();\n+            if (that.finalizer != null) {\n+                this.finalizer = that.finalizer.transform(cc, ot).build(this);\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public JavaTryOp transform(CopyContext cc, OpTransformer ot) {\n+            return new JavaTryOp(this, cc, ot);\n+        }\n+\n+        JavaTryOp(Body.Builder resourcesC,\n+                  Body.Builder bodyC,\n+                  List<Body.Builder> catchersC,\n+                  Body.Builder finalizerC) {\n+            super(NAME, List.of());\n+\n+            if (resourcesC != null) {\n+                this.resources = resourcesC.build(this);\n+                if (resources.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Resources should not return void: \" + resources.bodyType());\n+                }\n+                if (!resources.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Resources should have zero parameters: \" + resources.bodyType());\n+                }\n+            } else {\n+                this.resources = null;\n+            }\n+\n+            this.body = bodyC.build(this);\n+            if (!body.bodyType().returnType().equals(VOID)) {\n+                throw new IllegalArgumentException(\"Try should return void: \" + body.bodyType());\n+            }\n+\n+            this.catchers = catchersC.stream().map(c -> c.build(this)).toList();\n+            for (Body _catch : catchers) {\n+                if (!_catch.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Catch should return void: \" + _catch.bodyType());\n+                }\n+                if (_catch.bodyType().parameterTypes().size() != 1) {\n+                    throw new IllegalArgumentException(\"Catch should have zero parameters: \" + _catch.bodyType());\n+                }\n+            }\n+\n+            if (finalizerC != null) {\n+                this.finalizer = finalizerC.build(this);\n+                if (!finalizer.bodyType().returnType().equals(VOID)) {\n+                    throw new IllegalArgumentException(\"Finally should return void: \" + finalizer.bodyType());\n+                }\n+                if (!finalizer.bodyType().parameterTypes().isEmpty()) {\n+                    throw new IllegalArgumentException(\"Finally should have zero parameters: \" + finalizer.bodyType());\n+                }\n+            } else {\n+                this.finalizer = null;\n+            }\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            ArrayList<Body> bodies = new ArrayList<>();\n+            if (resources != null) {\n+                bodies.add(resources);\n+            }\n+            bodies.add(body);\n+            bodies.addAll(catchers);\n+            if (finalizer != null) {\n+                bodies.add(finalizer);\n+            }\n+            return bodies;\n+        }\n+\n+        public Body resources() {\n+            return resources;\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        public List<Body> catchers() {\n+            return catchers;\n+        }\n+\n+        public Body finalizer() {\n+            return finalizer;\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            if (resources != null) {\n+                throw new UnsupportedOperationException(\"Lowering of try-with-resources is unsupported\");\n+            }\n+\n+            Block.Builder exit = b.block();\n+            setBranchTarget(b.context(), this, new BranchTarget(exit, null));\n+\n+            \/\/ Simple case with no catch and finally bodies\n+            if (catchers.isEmpty() && finalizer == null) {\n+                b.transformBody(body, List.of(), (block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                });\n+                return exit;\n+            }\n+\n+            Block.Builder tryRegionEnter = b.block();\n+            Block.Builder tryRegionExit = b.block();\n+\n+            \/\/ Construct the catcher block builders\n+            List<Block.Builder> catchers = catchers().stream()\n+                    .map(catcher -> b.block())\n+                    .toList();\n+            Block.Builder catcherFinally = null;\n+            if (finalizer != null) {\n+                catcherFinally = b.block();\n+                catchers = new ArrayList<>(catchers);\n+                catchers.add(catcherFinally);\n+            }\n+\n+            \/\/ Enter the try exception region\n+            Result tryExceptionRegion = b.op(exceptionRegionEnter(tryRegionEnter.successor(), catchers.stream()\n+                    .map(Block.Builder::successor)\n+                    .toList()));\n+\n+            OpTransformer tryExitTransformer;\n+            if (finalizer != null) {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    if (op instanceof CoreOps.ReturnOp) {\n+                        return inlineFinalizer(block, tryExceptionRegion, opT);\n+                    } else if (op instanceof ExtendedOps.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                        return inlineFinalizer(block, tryExceptionRegion, opT);\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            } else {\n+                tryExitTransformer = opT.compose((block, op) -> {\n+                    \/\/ @@@ break and continue\n+                    \/\/ when target break\/continue is enclosing the try\n+                    if (op instanceof CoreOps.ReturnOp) {\n+                        Block.Builder tryRegionReturnExit = block.block();\n+                        block.op(exceptionRegionExit(tryExceptionRegion, tryRegionReturnExit.successor()));\n+                        return tryRegionReturnExit;\n+                    } else {\n+                        return block;\n+                    }\n+                });\n+            }\n+            \/\/ Inline the try body\n+            AtomicBoolean hasTryRegionExit = new AtomicBoolean();\n+            tryRegionEnter.transformBody(body, List.of(), tryExitTransformer.andThen((block, op) -> {\n+                if (op instanceof YieldOp) {\n+                    hasTryRegionExit.set(true);\n+                    block.op(branch(tryRegionExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op instanceof Lowerable lop) {\n+                        block = lop.lower(block, tryExitTransformer);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                }\n+                return block;\n+            }));\n+\n+            Block.Builder finallyEnter = null;\n+            if (finalizer != null) {\n+                finallyEnter = b.block();\n+                if (hasTryRegionExit.get()) {\n+                    \/\/ Exit the try exception region\n+                    tryRegionExit.op(exceptionRegionExit(tryExceptionRegion, finallyEnter.successor()));\n+                }\n+            } else if (hasTryRegionExit.get()) {\n+                \/\/ Exit the try exception region\n+                tryRegionExit.op(exceptionRegionExit(tryExceptionRegion, exit.successor()));\n+            }\n+\n+            \/\/ Inline the catch bodies\n+            for (int i = 0; i < this.catchers.size(); i++) {\n+                Block.Builder catcher = catchers.get(i);\n+                Body catcherBody = this.catchers.get(i);\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcher.parameter(catcherBody.bodyType().parameterTypes().get(0));\n+\n+                if (finalizer != null) {\n+                    Block.Builder catchRegionEnter = b.block();\n+                    Block.Builder catchRegionExit = b.block();\n+\n+                    \/\/ Enter the catch exception region\n+                    Result catchExceptionRegion = catcher.op(\n+                            exceptionRegionEnter(catchRegionEnter.successor(), catcherFinally.successor()));\n+\n+                    OpTransformer catchExitTransformer = opT.compose((block, op) -> {\n+                        if (op instanceof CoreOps.ReturnOp) {\n+                            return inlineFinalizer(block, catchExceptionRegion, opT);\n+                        } else if (op instanceof ExtendedOps.JavaLabelOp lop && ifExitFromTry(lop)) {\n+                            return inlineFinalizer(block, catchExceptionRegion, opT);\n+                        } else {\n+                            return block;\n+                        }\n+                    });\n+                    \/\/ Inline the catch body\n+                    AtomicBoolean hasCatchRegionExit = new AtomicBoolean();\n+                    catchRegionEnter.transformBody(catcherBody, List.of(t), catchExitTransformer.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            hasCatchRegionExit.set(true);\n+                            block.op(branch(catchRegionExit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, catchExitTransformer);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+\n+                    \/\/ Exit the catch exception region\n+                    if (hasCatchRegionExit.get()) {\n+                        hasTryRegionExit.set(true);\n+                        catchRegionExit.op(exceptionRegionExit(catchExceptionRegion, finallyEnter.successor()));\n+                    }\n+                } else {\n+                    \/\/ Inline the catch body\n+                    catcher.transformBody(catcherBody, List.of(t), opT.andThen((block, op) -> {\n+                        if (op instanceof YieldOp) {\n+                            block.op(branch(exit.successor()));\n+                        } else {\n+                            \/\/ @@@ Composition of lowerable ops\n+                            if (op instanceof Lowerable lop) {\n+                                block = lop.lower(block, opT);\n+                            } else {\n+                                block.op(op);\n+                            }\n+                        }\n+                        return block;\n+                    }));\n+                }\n+            }\n+\n+            if (finalizer != null && hasTryRegionExit.get()) {\n+                \/\/ Inline the finally body\n+                finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(exit.successor()));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+\n+            \/\/ Inline the finally body as a catcher of Throwable and adjusting to throw\n+            if (finalizer != null) {\n+                \/\/ Create the throwable argument\n+                Block.Parameter t = catcherFinally.parameter(type(Throwable.class));\n+\n+                catcherFinally.transformBody(finalizer, List.of(), opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(_throw(t));\n+                    } else {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        if (op instanceof Lowerable lop) {\n+                            block = lop.lower(block, opT);\n+                        } else {\n+                            block.op(op);\n+                        }\n+                    }\n+                    return block;\n+                }));\n+            }\n+            return exit;\n+        }\n+\n+        boolean ifExitFromTry(JavaLabelOp lop) {\n+            Op target = lop.target();\n+            return target == this || ifAncestorOp(target, this);\n+        }\n+\n+        static boolean ifAncestorOp(Op ancestor, Op op) {\n+            while (op.ancestorBody() != null) {\n+                op = op.ancestorBody().parentOp();\n+                if (op == ancestor) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        Block.Builder inlineFinalizer(Block.Builder block1, Value exceptionRegion, OpTransformer opT) {\n+            Block.Builder finallyEnter = block1.block();\n+            Block.Builder finallyExit = block1.block();\n+\n+            block1.op(exceptionRegionExit(exceptionRegion, finallyEnter.successor()));\n+\n+            \/\/ Inline the finally body\n+            finallyEnter.transformBody(finalizer, List.of(), opT.andThen((block2, op2) -> {\n+                if (op2 instanceof YieldOp) {\n+                    block2.op(branch(finallyExit.successor()));\n+                } else {\n+                    \/\/ @@@ Composition of lowerable ops\n+                    if (op2 instanceof Lowerable lop2) {\n+                        block2 = lop2.lower(block2, opT);\n+                    } else {\n+                        block2.op(op2);\n+                    }\n+                }\n+                return block2;\n+            }));\n+\n+            return finallyExit;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return VOID;\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    static final String Pattern_CLASS_NAME = ExtendedOps_CLASS_NAME + \"$\" + Pattern.class.getSimpleName();\n+\n+    \/\/ Reified pattern nodes\n+\n+    \/**\n+     * Synthetic pattern types\n+     * \/\/ @@@ Replace with types extending from TypeElement\n+     *\/\n+    public sealed interface Pattern {\n+\n+        \/**\n+         * Synthetic binding pattern type.\n+         *\n+         * @param <T> the type of values that are bound\n+         *\/\n+        final class Binding<T> implements Pattern {\n+            Binding() {\n+            }\n+        }\n+\n+        \/**\n+         * Synthetic record pattern type.\n+         *\n+         * @param <T> the type of records that are bound\n+         *\/\n+        final class Record<T> implements Pattern {\n+            Record() {\n+            }\n+        }\n+\n+        \/\/ @@@ Pattern types\n+\n+        JavaType PATTERN_BINDING_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Binding.class.getSimpleName()));\n+        JavaType PATTERN_RECORD_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+                \"$\" + Pattern.Record.class.getSimpleName()));\n+\n+        static JavaType bindingType(TypeElement t) {\n+            return type(PATTERN_BINDING_TYPE, (JavaType) t);\n+        }\n+\n+        static JavaType recordType(TypeElement t) {\n+            return type(PATTERN_RECORD_TYPE, (JavaType) t);\n+        }\n+\n+        static TypeElement targetType(TypeElement t) {\n+            return ((ClassType) t).typeArguments().get(0);\n+        }\n+    }\n+\n+    \/**\n+     * Pattern operations.\n+     *\/\n+    public static final class PatternOps {\n+        PatternOps() {\n+        }\n+\n+        \/**\n+         * The pattern operation.\n+         *\/\n+        public static sealed abstract class PatternOp extends OpWithDefinition implements Op.Pure {\n+            PatternOp(OpDefinition def) {\n+                super(def);\n+            }\n+\n+            PatternOp(PatternOp that, CopyContext cc) {\n+                super(that, cc);\n+            }\n+\n+            PatternOp(String name, List<Value> operands) {\n+                super(name, operands);\n+            }\n+        }\n+\n+        \/**\n+         * The binding pattern operation, that can model Java language type patterns.\n+         *\/\n+        @OpDeclaration(BindingPatternOp.NAME)\n+        public static final class BindingPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.binding\";\n+\n+            public static final String ATTRIBUTE_BINDING_NAME = NAME + \".binding.name\";\n+\n+            final TypeElement resultType;\n+            final String bindingName;\n+\n+            public static BindingPatternOp create(OpDefinition def) {\n+                String name = def.extractAttributeValue(ATTRIBUTE_BINDING_NAME, true,\n+                        v -> switch (v) {\n+                            case String s -> s;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported pattern binding name value:\" + v);\n+                        });\n+                return new BindingPatternOp(def, name);\n+            }\n+\n+            BindingPatternOp(OpDefinition def, String bindingName) {\n+                super(def);\n+\n+                this.bindingName = bindingName;\n+                this.resultType = def.resultType();\n+            }\n+\n+            BindingPatternOp(BindingPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.bindingName = that.bindingName;\n+                this.resultType = that.resultType;\n+            }\n+\n+            @Override\n+            public BindingPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new BindingPatternOp(this, cc);\n+            }\n+\n+            BindingPatternOp(TypeElement targetType, String bindingName) {\n+                super(NAME, List.of());\n+\n+                this.bindingName = bindingName;\n+                this.resultType = Pattern.bindingType(targetType);\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+                attrs.put(\"\", bindingName);\n+                return attrs;\n+            }\n+\n+            public String bindingName() {\n+                return bindingName;\n+            }\n+\n+            public TypeElement targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return resultType;\n+            }\n+        }\n+\n+        \/**\n+         * The record pattern operation, that can model Java language record patterns.\n+         *\/\n+        @OpDeclaration(RecordPatternOp.NAME)\n+        public static final class RecordPatternOp extends PatternOp {\n+            public static final String NAME = \"pattern.record\";\n+\n+            public static final String ATTRIBUTE_RECORD_DESCRIPTOR = NAME + \".descriptor\";\n+\n+            final RecordTypeRef recordDescriptor;\n+\n+            public static RecordPatternOp create(OpDefinition def) {\n+                RecordTypeRef recordDescriptor = def.extractAttributeValue(ATTRIBUTE_RECORD_DESCRIPTOR,true,\n+                        v -> switch (v) {\n+                            case String s -> RecordTypeRef.ofString(s);\n+                            case RecordTypeRef rtd -> rtd;\n+                            default -> throw new UnsupportedOperationException(\"Unsupported record type descriptor value:\" + v);\n+                        });\n+\n+                return new RecordPatternOp(def, recordDescriptor);\n+            }\n+\n+            RecordPatternOp(OpDefinition def, RecordTypeRef recordDescriptor) {\n+                super(def);\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            RecordPatternOp(RecordPatternOp that, CopyContext cc) {\n+                super(that, cc);\n+\n+                this.recordDescriptor = that.recordDescriptor;\n+            }\n+\n+            @Override\n+            public RecordPatternOp transform(CopyContext cc, OpTransformer ot) {\n+                return new RecordPatternOp(this, cc);\n+            }\n+\n+            RecordPatternOp(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n+                \/\/ The type of each value is a subtype of Pattern\n+                \/\/ The number of values corresponds to the number of components of the record\n+                super(NAME, List.copyOf(nestedPatterns));\n+\n+                this.recordDescriptor = recordDescriptor;\n+            }\n+\n+            @Override\n+            public Map<String, Object> attributes() {\n+                HashMap<String, Object> m = new HashMap<>(super.attributes());\n+                m.put(\"\", recordDescriptor);\n+                return Collections.unmodifiableMap(m);\n+            }\n+\n+            public RecordTypeRef recordDescriptor() {\n+                return recordDescriptor;\n+            }\n+\n+            public TypeElement targetType() {\n+                return Pattern.targetType(resultType());\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return Pattern.recordType(recordDescriptor.recordType());\n+            }\n+        }\n+\n+        \/**\n+         * The match operation, that can model Java language pattern matching.\n+         *\/\n+        @OpDeclaration(MatchOp.NAME)\n+        public static final class MatchOp extends OpWithDefinition implements Op.Isolated, Op.Lowerable {\n+            public static final String NAME = \"pattern.match\";\n+\n+            final Body pattern;\n+            final Body match;\n+\n+            public MatchOp(OpDefinition def) {\n+                super(def);\n+\n+                this.pattern = def.bodyDefinitions().get(0).build(this);\n+                this.match = def.bodyDefinitions().get(1).build(this);\n+            }\n+\n+            MatchOp(MatchOp that, CopyContext cc, OpTransformer ot) {\n+                super(that, cc);\n+\n+                this.pattern = that.pattern.transform(cc, ot).build(this);\n+                this.match = that.match.transform(cc, ot).build(this);\n+            }\n+\n+            @Override\n+            public MatchOp transform(CopyContext cc, OpTransformer ot) {\n+                return new MatchOp(this, cc, ot);\n+            }\n+\n+            MatchOp(Value target, Body.Builder patternC, Body.Builder matchC) {\n+                super(NAME,\n+                        List.of(target));\n+\n+                this.pattern = patternC.build(this);\n+                this.match = matchC.build(this);\n+            }\n+\n+            @Override\n+            public List<Body> bodies() {\n+                return List.of(pattern, match);\n+            }\n+\n+            public Body pattern() {\n+                return pattern;\n+            }\n+\n+            public Body match() {\n+                return match;\n+            }\n+\n+            public Value target() {\n+                return operands().get(0);\n+            }\n+\n+            @Override\n+            public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+                \/\/ No match block\n+                Block.Builder endNoMatchBlock = b.block();\n+                \/\/ Match block\n+                Block.Builder endMatchBlock = b.block();\n+                \/\/ End block\n+                Block.Builder endBlock = b.block();\n+                Block.Parameter matchResult = endBlock.parameter(resultType());\n+                \/\/ Map match operation result\n+                b.context().mapValue(result(), matchResult);\n+\n+                List<Value> patternValues = new ArrayList<>();\n+                Op patternYieldOp = pattern.entryBlock().terminatingOp();\n+                Op.Result rootPatternValue = (Op.Result) patternYieldOp.operands().get(0);\n+                Block.Builder currentBlock = lower(endNoMatchBlock, b,\n+                        patternValues,\n+                        rootPatternValue.op(),\n+                        b.context().getValue(target()));\n+                currentBlock.op(branch(endMatchBlock.successor()));\n+\n+                \/\/ No match block\n+                \/\/ Pass false\n+                endNoMatchBlock.op(branch(endBlock.successor(\n+                        endNoMatchBlock.op(constant(BOOLEAN, false)))));\n+\n+                \/\/ Match block\n+                \/\/ Lower match body and pass true\n+                endMatchBlock.transformBody(match, patternValues, opT.andThen((block, op) -> {\n+                    if (op instanceof YieldOp) {\n+                        block.op(branch(endBlock.successor(\n+                                block.op(constant(BOOLEAN, true)))));\n+                    } else if (op instanceof Lowerable lop) {\n+                        \/\/ @@@ Composition of lowerable ops\n+                        block = lop.lower(block, opT);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                }));\n+\n+                return endBlock;\n+            }\n+\n+            static Block.Builder lower(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       Op pattern, Value target) {\n+                if (pattern instanceof ExtendedOps.PatternOps.RecordPatternOp rp) {\n+                    return lowerRecordPattern(endNoMatchBlock, currentBlock, bindings, rp, target);\n+                } else if (pattern instanceof ExtendedOps.PatternOps.BindingPatternOp bp) {\n+                    return lowerBindingPattern(endNoMatchBlock, currentBlock, bindings, bp, target);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Unknown pattern op: \" + pattern);\n+                }\n+            }\n+\n+            static Block.Builder lowerRecordPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       ExtendedOps.PatternOps.RecordPatternOp rpOp, Value target) {\n+                TypeElement targetType = rpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                Op.Result isInstance = currentBlock.op(CoreOps.instanceOf(targetType, target));\n+                currentBlock.op(conditionalBranch(isInstance, nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(CoreOps.cast(targetType, target));\n+\n+                \/\/ Access component values of record and match on each as nested target\n+                List<Value> dArgs = rpOp.operands();\n+                for (int i = 0; i < dArgs.size(); i++) {\n+                    Op.Result nestedPattern = (Op.Result) dArgs.get(i);\n+                    \/\/ @@@ Handle exceptions?\n+                    Value nestedTarget = currentBlock.op(CoreOps.invoke(rpOp.recordDescriptor().methodForComponent(i), target));\n+\n+                    currentBlock = lower(endNoMatchBlock, currentBlock, bindings, nestedPattern.op(), nestedTarget);\n+                }\n+\n+                return currentBlock;\n+            }\n+\n+            static Block.Builder lowerBindingPattern(Block.Builder endNoMatchBlock, Block.Builder currentBlock,\n+                                       List<Value> bindings,\n+                                       ExtendedOps.PatternOps.BindingPatternOp bpOp, Value target) {\n+                TypeElement targetType = bpOp.targetType();\n+\n+                Block.Builder nextBlock = currentBlock.block();\n+\n+                \/\/ Check if instance of target type\n+                currentBlock.op(conditionalBranch(currentBlock.op(CoreOps.instanceOf(targetType, target)),\n+                        nextBlock.successor(), endNoMatchBlock.successor()));\n+\n+                currentBlock = nextBlock;\n+\n+                target = currentBlock.op(CoreOps.cast(targetType, target));\n+                bindings.add(target);\n+\n+                return currentBlock;\n+            }\n+\n+            @Override\n+            public TypeElement resultType() {\n+                return BOOLEAN;\n+            }\n+        }\n+    }\n+\n+\n+    \/**\n+     * A factory for extended and core operations.\n+     *\/\n+    \/\/ @@@ Compute lazily\n+    public static final OpFactory FACTORY = CoreOps.FACTORY.andThen(OpFactory.OP_FACTORY.get(ExtendedOps.class));\n+\n+\n+    \/**\n+     * Creates a continue operation.\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue() {\n+        return _continue(null);\n+    }\n+\n+    \/**\n+     * Creates a continue operation.\n+     * @param label the value associated with where to continue from\n+     * @return the continue operation\n+     *\/\n+    public static JavaContinueOp _continue(Value label) {\n+        return new JavaContinueOp(label);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break() {\n+        return _break(null);\n+    }\n+\n+    \/**\n+     * Creates a break operation.\n+     * @param label the value associated with where to continue from\n+     * @return the break operation\n+     *\/\n+    public static JavaBreakOp _break(Value label) {\n+        return new JavaBreakOp(label);\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield() {\n+        return new JavaYieldOp();\n+    }\n+\n+    \/**\n+     * Creates a yield operation.\n+     * @param operand the value to yield\n+     * @return the yield operation\n+     *\/\n+    public static JavaYieldOp java_yield(Value operand) {\n+        return new JavaYieldOp(operand);\n+    }\n+\n+    \/**\n+     * Creates a block operation.\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaBlockOp block(Body.Builder body) {\n+        return new JavaBlockOp(body);\n+    }\n+\n+    \/**\n+     * Creates a labeled operation.\n+     * @param body the body builder of the operation to be built and become its child\n+     * @return the block operation\n+     *\/\n+    public static JavaLabeledOp labeled(Body.Builder body) {\n+        return new JavaLabeledOp(body);\n+    }\n+\n+    \/**\n+     * Creates an if operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the if operation builder\n+     *\/\n+    public static JavaIfOp.IfBuilder _if(Body.Builder ancestorBody) {\n+        return new JavaIfOp.IfBuilder(ancestorBody);\n+    }\n+\n+    \/\/ Pairs of\n+    \/\/   predicate ()boolean, body ()void\n+    \/\/ And one optional body ()void at the end\n+\n+    \/**\n+     * Creates an if operation.\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the if operation\n+     *\/\n+    public static JavaIfOp _if(List<Body.Builder> bodies) {\n+        return new JavaIfOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     * <p>\n+     * The result type of the operation will be derived from the yield type of the second body\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(Value target, List<Body.Builder> bodies) {\n+        return new JavaSwitchExpressionOp(null, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch expression operation.\n+     *\n+     * @param resultType the result type of the expression\n+     * @param target the switch target value\n+     * @param bodies the body builders of the operation to be built and become its children\n+     * @return the switch expression operation\n+     *\/\n+    public static JavaSwitchExpressionOp switchExpression(TypeElement resultType, Value target,\n+                                                          List<Body.Builder> bodies) {\n+        Objects.requireNonNull(resultType);\n+        return new JavaSwitchExpressionOp(resultType, target, bodies);\n+    }\n+\n+    \/**\n+     * Creates a switch fallthrough operation.\n+     * @return the switch fallthrough operation\n+     *\/\n+    public static JavaSwitchFallthroughOp switchFallthroughOp() {\n+        return new JavaSwitchFallthroughOp();\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param initTypes the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, TypeElement... initTypes) {\n+        return _for(ancestorBody, List.of(initTypes));\n+    }\n+\n+    \/**\n+     * Creates a for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param initTypes the types of initialized variables\n+     * @return the for operation builder\n+     *\/\n+    public static JavaForOp.InitBuilder _for(Body.Builder ancestorBody, List<? extends TypeElement> initTypes) {\n+        return new JavaForOp.InitBuilder(ancestorBody, initTypes);\n+    }\n+\n+\n+    \/**\n+     * Creates a for operation.\n+     * @param init the init body builder of the operation to be built and become its child\n+     * @param cond the cond body builder of the operation to be built and become its child\n+     * @param update the update body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the for operation\n+     *\/\n+    \/\/ init ()Tuple<Var<T1>, Var<T2>, ..., Var<TN>>, or init ()void\n+    \/\/ cond (Var<T1>, Var<T2>, ..., Var<TN>)boolean\n+    \/\/ update (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    \/\/ body (Var<T1>, Var<T2>, ..., Var<TN>)void\n+    public static JavaForOp _for(Body.Builder init,\n+                                 Body.Builder cond,\n+                                 Body.Builder update,\n+                                 Body.Builder body) {\n+        return new JavaForOp(init, cond, update, body);\n+    }\n+\n+    \/**\n+     * Creates an enhanced for operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param iterableType the iterable type\n+     * @param elementType the element type\n+     * @return the enhanced for operation builder\n+     *\/\n+    public static JavaEnhancedForOp.ExpressionBuilder enhancedFor(Body.Builder ancestorBody,\n+                                                                  TypeElement iterableType, TypeElement elementType) {\n+        return new JavaEnhancedForOp.ExpressionBuilder(ancestorBody, iterableType, elementType);\n+    }\n+\n+    \/\/ expression ()I<E>\n+    \/\/ init (E )Var<T>\n+    \/\/ body (Var<T> )void\n+\n+    \/**\n+     * Creates an enhanced for operation.\n+     * @param expression the expression body builder of the operation to be built and become its child\n+     * @param init the init body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the enhanced for operation\n+     *\/\n+    public static JavaEnhancedForOp enhancedFor(Body.Builder expression,\n+                                                Body.Builder init,\n+                                                Body.Builder body) {\n+        return new JavaEnhancedForOp(expression, init, body);\n+    }\n+\n+    \/**\n+     * Creates a while operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the while operation builder\n+     *\/\n+    public static JavaWhileOp.PredicateBuilder _while(Body.Builder ancestorBody) {\n+        return new JavaWhileOp.PredicateBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a while operation.\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the while operation\n+     *\/\n+    \/\/ predicate, ()boolean, may be null for predicate returning true\n+    \/\/ body, ()void\n+    public static JavaWhileOp _while(Body.Builder predicate, Body.Builder body) {\n+        return new JavaWhileOp(predicate, body);\n+    }\n+\n+    \/**\n+     * Creates a do operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @return the do operation builder\n+     *\/\n+    public static JavaDoWhileOp.BodyBuilder doWhile(Body.Builder ancestorBody) {\n+        return new JavaDoWhileOp.BodyBuilder(ancestorBody);\n+    }\n+\n+    \/**\n+     * Creates a do operation.\n+     * @param predicate the predicate body builder of the operation to be built and become its child\n+     * @param body the main body builder of the operation to be built and become its child\n+     * @return the do operation\n+     *\/\n+    public static JavaDoWhileOp doWhile(Body.Builder body, Body.Builder predicate) {\n+        return new JavaDoWhileOp(body, predicate);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param lhs a consumer that builds the left-hand side body\n+     * @param rhs a consumer that builds the right-hand side body\n+     * @return the conditional-and operation builder\n+     *\/\n+    public static JavaConditionalAndOp.Builder conditionalAnd(Body.Builder ancestorBody,\n+                                                              Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalAndOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param lhs a consumer that builds the left-hand side body\n+     * @param rhs a consumer that builds the right-hand side body\n+     * @return the conditional-or operation builder\n+     *\/\n+    public static JavaConditionalOrOp.Builder conditionalOr(Body.Builder ancestorBody,\n+                                                            Consumer<Block.Builder> lhs, Consumer<Block.Builder> rhs) {\n+        return new JavaConditionalOrOp.Builder(ancestorBody, lhs, rhs);\n+    }\n+\n+    \/**\n+     * Creates a conditional-and operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-and operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalAndOp conditionalAnd(List<Body.Builder> bodies) {\n+        return new JavaConditionalAndOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional-or operation\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional-or operation\n+     *\/\n+    \/\/ predicates, ()boolean\n+    public static JavaConditionalOrOp conditionalOr(List<Body.Builder> bodies) {\n+        return new JavaConditionalOrOp(bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     * @param expressionType the result type of the expression\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(TypeElement expressionType,\n+                                                                    List<Body.Builder> bodies) {\n+        Objects.requireNonNull(expressionType);\n+        return new JavaConditionalExpressionOp(expressionType, bodies);\n+    }\n+\n+    \/**\n+     * Creates a conditional operation\n+     * <p>\n+     * The result type of the operation will be derived from the yield type of the second body\n+     * @param bodies the body builders of operation to be built and become its children\n+     * @return the conditional operation\n+     *\/\n+    public static JavaConditionalExpressionOp conditionalExpression(List<Body.Builder> bodies) {\n+        return new JavaConditionalExpressionOp(null, bodies);\n+    }\n+\n+    \/**\n+     * Creates try operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param c a consumer that builds the try body\n+     * @return the try operation builder\n+     *\/\n+    public static JavaTryOp.CatchBuilder _try(Body.Builder ancestorBody, Consumer<Block.Builder> c) {\n+        Body.Builder _try = Body.Builder.of(ancestorBody, FunctionType.VOID);\n+        c.accept(_try.entryBlock());\n+        return new JavaTryOp.CatchBuilder(ancestorBody, null, _try);\n+    }\n+\n+    \/**\n+     * Creates try-with-resources operation builder.\n+     * @param ancestorBody the nearest ancestor body builder from which to construct\n+     *                             body builders for this operation\n+     * @param c a consumer that builds the resources body\n+     * @return the try-with-resources operation builder\n+     *\/\n+    public static JavaTryOp.BodyBuilder tryWithResources(Body.Builder ancestorBody,\n+                                                         List<? extends TypeElement> resourceTypes,\n+                                                         Consumer<Block.Builder> c) {\n+        resourceTypes = resourceTypes.stream().map(VarType::varType).toList();\n+        Body.Builder resources = Body.Builder.of(ancestorBody,\n+                FunctionType.functionType(TupleType.tupleType(resourceTypes)));\n+        c.accept(resources.entryBlock());\n+        return new JavaTryOp.BodyBuilder(ancestorBody, resourceTypes, resources);\n+    }\n+\n+    \/\/ resources ()Tuple<Var<R1>, Var<R2>, ..., Var<RN>>, or null\n+    \/\/ try (Var<R1>, Var<R2>, ..., Var<RN>)void, or try ()void\n+    \/\/ catch (E )void, where E <: Throwable\n+    \/\/ finally ()void, or null\n+\n+    \/**\n+     * Creates a try or try-with-resources operation.\n+     * @param resources the try body builder of the operation to be built and become its child,\n+     *                  may be null\n+     * @param body the try body builder of the operation to be built and become its child\n+     * @param catchers the catch body builders of the operation to be built and become its children\n+     * @param finalizer the finalizer body builder of the operation to be built and become its child\n+     * @return the try or try-with-resources operation\n+     *\/\n+    public static JavaTryOp _try(Body.Builder resources,\n+                                 Body.Builder body,\n+                                 List<Body.Builder> catchers,\n+                                 Body.Builder finalizer) {\n+        return new JavaTryOp(resources, body, catchers, finalizer);\n+    }\n+\n+    \/\/\n+    \/\/ Patterns\n+\n+    \/**\n+     * Creates a pattern match operation.\n+     * @param target the target value\n+     * @param pattern the pattern body builder of the operation to be built and become its child\n+     * @param match the match body builder of the operation to be built and become its child\n+     * @return the pattern match operation\n+     *\/\n+    public static PatternOps.MatchOp match(Value target,\n+                                           Body.Builder pattern, Body.Builder match) {\n+        return new PatternOps.MatchOp(target, pattern, match);\n+    }\n+\n+    \/**\n+     * Creates a pattern binding operation.\n+     * @param type the type of value to be bound\n+     * @param bindingName the binding name\n+     * @return the pattern binding operation\n+     *\/\n+    public static PatternOps.BindingPatternOp bindingPattern(TypeElement type, String bindingName) {\n+        return new PatternOps.BindingPatternOp(type, bindingName);\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, Value... nestedPatterns) {\n+        return recordPattern(recordDescriptor, List.of(nestedPatterns));\n+    }\n+\n+    \/**\n+     * Creates a record pattern operation.\n+     * @param recordDescriptor the record descriptor\n+     * @param nestedPatterns the nested pattern values\n+     * @return the record pattern operation\n+     *\/\n+    public static PatternOps.RecordPatternOp recordPattern(RecordTypeRef recordDescriptor, List<Value> nestedPatterns) {\n+        return new PatternOps.RecordPatternOp(recordDescriptor, nestedPatterns);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":3151,"deletions":0,"binary":false,"changes":3151,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.code.Op;\n+\n+\/**\n+ * An operation declaration annotation.\n+ * <p>\n+ * This annotation may be declared on a concrete class implementing an {@link Op operation} whose name is a constant\n+ * that can be declared as this attribute's value.\n+ * <p>\n+ * Tooling can process declarations of this annotation to build a factory for constructing operations from their name.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface OpDeclaration {\n+    \/**\n+     * {@return the operation name}\n+     *\/\n+    String value();\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpDeclaration.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * An operation in general form that is utilized to construct a concrete subclass of {@link Op},\n+ * such as a subclass of {@link OpWithDefinition}, associated with the operation name.\n+ *\n+ * @param name            the operation name\n+ * @param operands        the list of operands\n+ * @param successors      the list of successors\n+ * @param resultType      the operation result type\n+ * @param attributes      the attribute map, modifiable\n+ * @param bodyDefinitions the list of body builders for building the bodies\n+ * @apiNote Deserializers of operations may utilize this record to construct operations,\n+ * thereby separating the specifics of deserializing from construction.\n+ *\/\n+public record OpDefinition(String name,\n+                           List<Value> operands,\n+                           List<Block.Reference> successors,\n+                           TypeElement resultType,\n+                           Map<String, Object> attributes,\n+                           List<Body.Builder> bodyDefinitions) {\n+\n+    \/**\n+     * Removes an attribute value from the attributes map, converts the value by applying it\n+     * to mapping function, and returns the result.\n+     *\n+     * <p>If the attribute is a default attribute then this method first attempts to\n+     * remove the attribute whose name is the empty string, otherwise if there is no such\n+     * attribute present or the attribute is not a default attribute then this method\n+     * attempts to remove the attribute with the given name.\n+     *\n+     * <p>On successful removal of the attribute its value is converted by applying the value\n+     * to the mapping function.\n+     *\n+     * @param name the attribute name.\n+     * @param isDefault true if the attribute is a default attribute\n+     * @return the converted attribute value\n+     * @param <T> the converted attribute value type\n+     * @throws IllegalArgumentException if there is no attribute present\n+     *\/\n+    public <T> T extractAttributeValue(String name, boolean isDefault, Function<Object, T> mapper) {\n+        Object value = attributes.remove(isDefault ? \"\" : name);\n+        if (value == null) {\n+            if (!isDefault) {\n+                throw new IllegalArgumentException(\"Required attribute not present: \"\n+                        + name);\n+            }\n+\n+            value = attributes.remove(name);\n+        }\n+\n+        return mapper.apply(value);\n+    }\n+\n+    \/**\n+     * Copies an operation to its operation definition.\n+     *\n+     * @param cc the copy context\n+     * @param op the operation\n+     * @return the copied operation definition.\n+     *\/\n+    public static OpDefinition fromOp(CopyContext cc, Op op) {\n+        return new OpDefinition(\n+                op.opName(),\n+                cc.getValues(op.operands()),\n+                op.successors().stream().map(cc::getSuccessorOrCreate).toList(),\n+                op.resultType(),\n+                new HashMap<>(op.attributes()),\n+                op.bodies().stream().map(b -> b.copy(cc)).toList()\n+        );\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpDefinition.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.code.Op;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+\/**\n+ * An operation factory for constructing an {@link Op operation} from its {@link OpDefinition operation definition}.\n+ *\/\n+@FunctionalInterface\n+public interface OpFactory {\n+    \/**\n+     * A class value for lazily computing an operation factory for {@link Op operation} classes\n+     * annotated with {@link OpDeclaration} and enclosed within a given class to compute over.\n+     * <p>\n+     * Each enclosed class annotated with {@code OpDeclaration} must declare a public static method named {@code create}\n+     * with one parameter type of {@link OpDefinition} and return type that is the concrete class type.\n+     * Alternatively, the concrete class must declare public constructor with one parameter type of\n+     * {@link OpDefinition}.\n+     *\/\n+    ClassValue<OpFactory> OP_FACTORY = new ClassValue<>() {\n+        @Override\n+        protected OpFactory computeValue(Class<?> c) {\n+            \/\/ @@@ See https:\/\/bugs.openjdk.org\/browse\/JDK-8321207\n+            final Map<String, Class<? extends Op>> opMapping = createOpMapping(c);\n+\n+            return def -> {\n+                var opClass = opMapping.get(def.name());\n+                if (opClass == null) {\n+                    return null;\n+                }\n+\n+                return constructOp(opClass, def);\n+            };\n+        }\n+    };\n+\n+    \/**\n+     * Constructs an {@link Op operation} from its operation definition.\n+     * <p>\n+     * If there is no mapping from the operation definition's name to a concrete\n+     * class of an {@code Op} then this method returns null.\n+     *\n+     * @param def the operation definition\n+     * @return the operation, otherwise null\n+     *\/\n+    Op constructOp(OpDefinition def);\n+\n+    \/**\n+     * Constructs an {@link Op operation} from its operation definition.\n+     * <p>\n+     * If there is no mapping from the operation definition's name to a concrete\n+     * class of an {@code Op} then this method throws UnsupportedOperationException.\n+     *\n+     * @param def the operation definition\n+     * @return the operation, otherwise null\n+     * @throws UnsupportedOperationException if there is no mapping from the operation definition's\n+     *                                       name to a concrete class of an {@code Op}\n+     *\/\n+    default Op constructOpOrFail(OpDefinition def) {\n+        Op op = constructOp(def);\n+        if (op == null) {\n+            throw new UnsupportedOperationException(\"Unsupported operation: \" + def.name());\n+        }\n+\n+        return op;\n+    }\n+\n+    \/**\n+     * Compose this operation factory with another operation factory.\n+     * <p>\n+     * If there is no mapping in this operation factory then the result\n+     * of the other operation factory is returned.\n+     *\n+     * @param after the other operation factory.\n+     * @return the composed operation factory.\n+     *\/\n+    default OpFactory andThen(OpFactory after) {\n+        return def -> {\n+            Op op = constructOp(def);\n+            return op != null ? op : after.constructOp(def);\n+        };\n+    }\n+\n+    private static Map<String, Class<? extends Op>> createOpMapping(Class<?> opClasses) {\n+        Map<String, Class<? extends Op>> mapping = new HashMap<>();\n+        for (Class<?> opClass : opClasses.getNestMembers()) {\n+            if (opClass.isAnnotationPresent(OpDeclaration.class)) {\n+                if (!Modifier.isPublic(opClass.getModifiers())) {\n+                    throw new InternalError(\"Operation class not public: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(opClass)) {\n+                    throw new InternalError(\"Operation class is not assignable to Op: \" + opClass);\n+                }\n+\n+                MethodHandle handle = getOpConstructorMethodHandle(opClass);\n+                if (handle == null) {\n+                    throw new InternalError(\"Operation constructor for operation class not found: \" + opClass.getName());\n+                }\n+\n+                if (!Op.class.isAssignableFrom(handle.type().returnType())) {\n+                    throw new InternalError(\"Operation constructor does not return an Op: \" + handle);\n+                }\n+\n+                String opName = opClass.getAnnotation(OpDeclaration.class).value();\n+                @SuppressWarnings(\"unchecked\")\n+                var opClassCast = (Class<Op>) opClass;\n+                mapping.put(opName, opClassCast);\n+            }\n+        }\n+        return mapping;\n+    }\n+\n+    private static MethodHandle getOpConstructorMethodHandle(Class<?> opClass) {\n+        Method method = null;\n+        try {\n+            method = opClass.getMethod(\"create\", OpDefinition.class);\n+        } catch (NoSuchMethodException e) {\n+        }\n+\n+        if (method != null) {\n+            if (!Modifier.isStatic(method.getModifiers())) {\n+                throw new InternalError(\"Operation constructor is not a static method: \" + method);\n+            }\n+\n+            try {\n+\/*__return MethodHandles.lookup().unreflect(method);__*\/                return MethodHandles.publicLookup().unreflect(method);\n+            } catch (IllegalAccessException e) {\n+                throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                        method);\n+            }\n+        }\n+\n+        Constructor<?> constructor;\n+        try {\n+            constructor = opClass.getConstructor(OpDefinition.class);\n+        } catch (NoSuchMethodException e) {\n+            return null;\n+        }\n+\n+        try {\n+\/*__return MethodHandles.lookup().unreflectConstructor(constructor);__*\/            return MethodHandles.publicLookup().unreflectConstructor(constructor);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(\"Inaccessible operation constructor for operation: \" +\n+                    constructor);\n+        }\n+    }\n+\n+    private static Op constructOp(Class<? extends Op> opClass, OpDefinition opDef) {\n+        class Enclosed {\n+            private static final ClassValue<Function<OpDefinition, Op>> OP_CONSTRUCTOR = new ClassValue<>() {\n+                @Override\n+                protected Function<OpDefinition, Op> computeValue(Class<?> opClass) {\n+                    final MethodHandle opConstructorMH = getOpConstructorMethodHandle(opClass);\n+                    assert opConstructorMH != null;\n+\n+                    return operationDefinition -> {\n+                        try {\n+                            return (Op) opConstructorMH.invoke(operationDefinition);\n+                        } catch (RuntimeException | Error e) {\n+                            throw e;\n+                        } catch (Throwable t) {\n+                            throw new RuntimeException(t);\n+                        }\n+                    };\n+                }\n+            };\n+        }\n+        return Enclosed.OP_CONSTRUCTOR.get(opClass).apply(opDef);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpFactory.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.*;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * An operation that may be constructed with an operation {@link OpDefinition definition}.\n+ *\/\n+public abstract class OpWithDefinition extends Op {\n+\n+    \/**\n+     * The attribute name associated with the location attribute.\n+     *\/\n+    public static final String ATTRIBUTE_LOCATION = \"loc\";\n+\n+    \/**\n+     * Constructs an operation by copying given operation.\n+     *\n+     * @param that the operation to copy.\n+     * @param cc   the copy context.\n+     * @implSpec The default implementation calls the constructor with the operation's name, result type, and a list\n+     * values computed, in order, by mapping the operation's operands using the copy context.\n+     *\/\n+    protected OpWithDefinition(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+\n+    \/**\n+     * Constructs an operation with a name, operation result type, and list of operands.\n+     *\n+     * @param name     the operation name.\n+     * @param operands the list of operands, a copy of the list is performed if required.\n+     *\/\n+    protected OpWithDefinition(String name, List<? extends Value> operands) {\n+        super(name, operands);\n+    }\n+\n+    \/**\n+     * Constructs an operation from its operation definition.\n+     *\n+     * @param def the operation definition.\n+     * @implSpec This implementation invokes the {@link Op#Op(String, List) constructor}\n+     * accepting the non-optional components of the operation definition, {@code name}, {@code resultType},\n+     * and {@code operands}:\n+     * <pre> {@code\n+     *  this(def.name(), def.resultType(), def.operands());\n+     * }<\/pre>\n+     * If the attributes component of the operation definition is copied as if by {@code Map.copyOf}.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected OpWithDefinition(OpDefinition def) {\n+        super(def.name(), def.operands());\n+        setLocation(extractLocation(def));\n+    }\n+\n+    static Location extractLocation(OpDefinition def) {\n+        Object v = def.attributes().get(ATTRIBUTE_LOCATION);\n+        return switch(v) {\n+            case String s -> Location.fromString(s);\n+            case Location loc -> loc;\n+            case null -> null;\n+            default -> throw new UnsupportedOperationException(\"Unsupported location value:\" + v);\n+        };\n+    }\n+\n+    @Override\n+    public Map<String, Object> attributes() {\n+        Location l = location();\n+        return l == null ? Map.of() : Map.of(ATTRIBUTE_LOCATION, l);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/OpWithDefinition.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for operations declared in code models that can represent Java programs.\n+ *\/\n+package java.lang.reflect.code.op;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for a code metamodel that is used to quote Java code as code models, build code models, and transform code models.\n+ *\/\n+package java.lang.reflect.code;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,607 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.TypeDefinition;\n+import java.lang.reflect.code.op.*;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.parser.impl.DescParser;\n+import java.lang.reflect.code.parser.impl.Lexer;\n+import java.lang.reflect.code.parser.impl.Scanner;\n+import java.lang.reflect.code.parser.impl.Tokens;\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.type.TypeElementFactory;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * A parser of serialized code models from their textual form.\n+ * <p>\n+ * The syntactic grammar of a code mode is specified in the grammar notation, and is a subset of the grammar,\n+ * specified by the JLS, see section 2.4. (Except that we cannot express non-terminal symbols in italic type.)\n+ * <p>\n+ * {@snippet lang=text :\n+ * Operation:\n+ *   [Value =] Name {Operands} {Successors} {Attributes} {Bodies} ;\n+ *\n+ * Operands:\n+ *   ValueIdentifier {ValueIdentifier}\n+ *\n+ * Successors:\n+ *   Successor {Successor}\n+ *\n+ * Successor:\n+ *   BlockIdentifier\n+ *   BlockIdentifier ()\n+ *   BlockIdentifier ( ValueIdentifier {, ValueIdentifier} )\n+ *\n+ * Attributes:\n+ *   Attribute {Attribute}\n+ *\n+ * Attribute:\n+ *   @ AttributeValue\n+ *   @ Name = AttributeValue\n+ *\n+ * AttributeValue:\n+ *   Name\n+ *   StringLiteral\n+ *   NullLiteral\n+ *\n+ * Bodies:\n+ *   Body {Body}\n+ *\n+ * Body:\n+ *   BlockIdentifier ( ) Type -> { Operations {Block} }\n+ *   BlockIdentifier ( Value {, Value} ) Type -> { Operations {Block} }\n+ *\n+ * Operations:\n+ *   Operation {Operation}\n+ *\n+ * Block:\n+ *   BlockIdentifier : Operations\n+ *   BlockIdentifier ( ) : Operations\n+ *   BlockIdentifier ( Value {, Value} ) : Operations\n+ *\n+ * BlockIdentifier:\n+ *   ^ Identifier\n+ *\n+ * Value:\n+ *   ValueIdentifier : Type\n+ *\n+ * ValueIdentifier:\n+ *   % JavaLetterOrDigit {JavaLetterOrDigit}\n+ *\n+ * Name:\n+ *   Identifier\n+ *   Name . Identifier\n+ *\n+ * Type:\n+ *   same as in section 4.1 of JLS but without any annotations\n+ *\n+ * Identifier:\n+ *   same as in section 3 of JLS\n+ *\n+ * JavaLetterOrDigit:\n+ *   same as in section 3 of JLS\n+ *\n+ * StringLiteral:\n+ *   same as in section 3 of JLS\n+ *\n+ * NullLiteral:\n+ *   same as in section 3 of JLS\n+ * }\n+ *\/\n+public final class OpParser {\n+\n+    \/**\n+     * Parse a code model from its serialized textual form obtained from an input stream.\n+     *\n+     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param in the input stream\n+     * @return the list of operations\n+     * @throws IOException if parsing fails\n+     *\/\n+    public static List<Op> fromStream(OpFactory opFactory, InputStream in) throws IOException {\n+        return fromStream(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n+    }\n+\n+    public static List<Op> fromStream(OpFactory opFactory, TypeElementFactory typeFactory, InputStream in) throws IOException {\n+        String s = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        return fromString(opFactory, typeFactory, s);\n+    }\n+\n+    \/**\n+     * Parse a code model from its serialized textual form obtained from an input string.\n+     *\n+     * @param opFactory the operation factory used to construct operations from their general definition\n+     * @param in the input string\n+     * @return the list of operations\n+     *\/\n+    public static List<Op> fromString(OpFactory opFactory, String in) {\n+        return parse(opFactory, CoreTypeFactory.CORE_TYPE_FACTORY, in);\n+    }\n+\n+    public static List<Op> fromString(OpFactory opFactory, TypeElementFactory typeFactory, String in) {\n+        return parse(opFactory, typeFactory, in);\n+    }\n+\n+    \/**\n+     * Parse a code model, modeling a method, from its serialized textual form obtained from an input string.\n+     *\n+     * @param in the input string\n+     * @return the func operation\n+     *\/\n+    public static Op fromStringOfFuncOp(String in) {\n+        Op op = fromString(ExtendedOps.FACTORY, in).get(0);\n+        if (!(op instanceof CoreOps.FuncOp)) {\n+            throw new IllegalArgumentException(\"Op is not a FuncOp: \" + op);\n+        }\n+        return op;\n+    }\n+\n+    static List<Op> parse(OpFactory opFactory, TypeElementFactory typeFactory, String in) {\n+        Lexer lexer = Scanner.factory().newScanner(in);\n+        lexer.nextToken();\n+\n+        List<OpNode> opNodes = new OpParser(lexer).parseNodes();\n+\n+        Context c = new Context(opFactory, typeFactory);\n+        return opNodes.stream().map(n -> nodeToOp(n, TypeDefinition.VOID, c, null)).toList();\n+    }\n+\n+\n+    static final class Context {\n+        final Context parent;\n+        final OpFactory opFactory;\n+        final TypeElementFactory typeFactory;\n+        final Map<String, Value> valueMap;\n+        final Map<String, Block.Builder> blockMap;\n+\n+        Context(Context that, boolean isolated) {\n+            this.parent = that;\n+            this.opFactory = that.opFactory;\n+            this.typeFactory = that.typeFactory;\n+            this.valueMap = isolated ? new HashMap<>() : new HashMap<>(that.valueMap);\n+            this.blockMap = new HashMap<>();\n+        }\n+\n+        Context(OpFactory opFactory, TypeElementFactory typeFactory) {\n+            this.parent = null;\n+            this.opFactory = opFactory;\n+            this.typeFactory = typeFactory;\n+            this.valueMap = new HashMap<>();\n+            this.blockMap = new HashMap<>();\n+        }\n+\n+        Context fork(boolean isolated) {\n+            return new Context(this, isolated);\n+        }\n+\n+        void putValue(String name, Value opr) {\n+            valueMap.put(name, opr);\n+        }\n+\n+        Value getValue(String name) {\n+            Value value = valueMap.get(name);\n+            if (value == null) {\n+                \/\/ @@@ location\n+                throw new IllegalArgumentException(\"Undeclared value referenced: \" + name);\n+            }\n+\n+            return value;\n+        }\n+\n+        void putBlock(String name, Block.Builder bm) {\n+            blockMap.put(name, bm);\n+        }\n+\n+        Block.Builder getBlock(String name) {\n+            Block.Builder block = blockMap.get(name);\n+            if (block == null) {\n+                \/\/ @@@ location\n+                throw new IllegalArgumentException(\"Undeclared block referenced: \" + name);\n+            }\n+\n+            return block;\n+        }\n+    }\n+\n+    static Op nodeToOp(OpNode opNode, TypeDefinition rtype, Context c, Body.Builder ancestorBody) {\n+        OpDefinition opdef = nodeToOpDef(opNode, rtype, c, ancestorBody);\n+        return c.opFactory.constructOpOrFail(opdef);\n+    }\n+\n+    static OpDefinition nodeToOpDef(OpNode opNode, TypeDefinition rtype, Context c, Body.Builder ancestorBody) {\n+        String operationName = opNode.name;\n+        List<Value> operands = opNode.operands.stream().map(c::getValue).toList();\n+        List<Block.Reference> successors = opNode.successors.stream()\n+                .map(n -> nodeToSuccessor(n, c)).toList();\n+        List<Body.Builder> bodies = opNode.bodies.stream()\n+                .map(n -> nodeToBody(n, c.fork(false), ancestorBody)).toList();\n+        return new OpDefinition(operationName,\n+                operands,\n+                successors,\n+                c.typeFactory.constructType(rtype),\n+                opNode.attributes,\n+                bodies);\n+    }\n+\n+    static Body.Builder nodeToBody(BodyNode n, Context c, Body.Builder ancestorBody) {\n+        Body.Builder body = Body.Builder.of(ancestorBody,\n+                \/\/ Create function type with just the return type and add parameters afterward\n+                FunctionType.functionType(c.typeFactory.constructType(n.rtype)));\n+        Block.Builder eb = body.entryBlock();\n+\n+        \/\/ Create blocks upfront for forward referencing successors\n+        for (int i = 0; i < n.blocks.size(); i++) {\n+            BlockNode bn = n.blocks.get(i);\n+            Block.Builder b;\n+            if (i == 0) {\n+                b = body.entryBlock();\n+            } else {\n+                b = eb.block();\n+                c.putBlock(bn.name, b);\n+            }\n+\n+            for (ValueNode a : bn.parameters) {\n+                Block.Parameter v = b.parameter(c.typeFactory.constructType(a.type));\n+                c.putValue(a.name, v);\n+            }\n+        }\n+\n+        \/\/ Create operations\n+        for (int i = 0; i < n.blocks.size(); i++) {\n+            BlockNode bn = n.blocks.get(i);\n+            Block.Builder b;\n+            if (i == 0) {\n+                b = body.entryBlock();\n+            } else {\n+                b = c.getBlock(n.blocks.get(i).name);\n+            }\n+\n+            for (OpNode on : bn.ops) {\n+                ValueNode r = on.result;\n+                if (r != null) {\n+                    Op.Result v = b.op(nodeToOp(on, r.type, c, body));\n+                    c.putValue(r.name, v);\n+                } else {\n+                    b.op(nodeToOp(on, TypeDefinition.VOID, c, body));\n+                }\n+            }\n+        }\n+\n+        return body;\n+    }\n+\n+    static Block.Reference nodeToSuccessor(SuccessorNode n, Context c) {\n+        return c.getBlock(n.blockName).successor(n.arguments().stream().map(c::getValue).toList());\n+    }\n+\n+    \/\/ @@@ Add tokens to access position of nodes on error\n+\n+    record OpNode(ValueNode result,\n+                  String name,\n+                  List<String> operands,\n+                  List<SuccessorNode> successors,\n+                  Map<String, Object> attributes,\n+                  List<BodyNode> bodies) {\n+    }\n+\n+    record SuccessorNode(String blockName,\n+                         List<String> arguments) {\n+    }\n+\n+    record BodyNode(TypeDefinition rtype,\n+                    List<BlockNode> blocks) {\n+    }\n+\n+    record BlockNode(String name,\n+                     List<ValueNode> parameters,\n+                     List<OpNode> ops) {\n+    }\n+\n+    record ValueNode(String name,\n+                     TypeDefinition type) {\n+    }\n+\n+    final Lexer lexer;\n+\n+    OpParser(Lexer lexer) {\n+        this.lexer = lexer;\n+    }\n+\n+    List<OpNode> parseNodes() {\n+        List<OpNode> ops = new ArrayList<>();\n+        while (lexer.token().kind != Tokens.TokenKind.EOF) {\n+            ops.add(parseOperation());\n+        }\n+        return ops;\n+    }\n+\n+    OpNode parseOperation() {\n+        ValueNode operationResult;\n+        if (lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER)) {\n+            operationResult = parseValueNode();\n+            lexer.accept(Tokens.TokenKind.EQ);\n+        } else {\n+            operationResult = null;\n+        }\n+\n+        String operationName = parseName();\n+\n+        \/\/ Operands\n+        final List<String> operands;\n+        if (lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER)) {\n+            operands = parseOperands();\n+        } else {\n+            operands = List.of();\n+        }\n+\n+        \/\/ Successors\n+        \/\/ ^name(%x, %d)\n+        final List<SuccessorNode> successors;\n+        if (lexer.is(Tokens.TokenKind.CARET)) {\n+            successors = parseSuccessors();\n+        } else {\n+            successors = List.of();\n+        }\n+\n+        \/\/ Attributes\n+        final Map<String, Object> attributes;\n+        if (lexer.is(Tokens.TokenKind.MONKEYS_AT)) {\n+            attributes = parseAttributes();\n+        } else {\n+            attributes = Map.of();\n+        }\n+\n+        \/\/ Bodies\n+        List<BodyNode> bodies;\n+        if (lexer.is(Tokens.TokenKind.CARET) || lexer.is(Tokens.TokenKind.LPAREN)) {\n+            bodies = parseBodies();\n+        } else {\n+            bodies = List.of();\n+        }\n+\n+        lexer.accept(Tokens.TokenKind.SEMI);\n+\n+        return new OpNode(operationResult, operationName, operands, successors, attributes, bodies);\n+    }\n+\n+    Map<String, Object> parseAttributes() {\n+        Map<String, Object> attributes = new HashMap<>();\n+        while (lexer.acceptIf(Tokens.TokenKind.MONKEYS_AT)) {\n+            String attributeName;\n+            if (lexer.is(Tokens.TokenKind.IDENTIFIER)) {\n+                attributeName = parseName();\n+                lexer.accept(Tokens.TokenKind.EQ);\n+            } else {\n+                attributeName = \"\";\n+            }\n+            Object attributeValue = parseAttributeValue();\n+            attributes.put(attributeName, attributeValue);\n+        }\n+        return attributes;\n+    }\n+\n+    Object parseAttributeValue() {\n+        if (lexer.is(Tokens.TokenKind.IDENTIFIER)) {\n+            return parseName();\n+        }\n+\n+        Object value = parseLiteral(lexer.token());\n+        lexer.nextToken();\n+\n+        return value;\n+    }\n+\n+    Object parseLiteral(Tokens.Token t) {\n+        return switch (t.kind) {\n+            case STRINGLITERAL -> t.stringVal();\n+            case NULL -> Op.NULL_ATTRIBUTE_VALUE;\n+            default -> throw lexer.unexpected();\n+        };\n+    }\n+\n+    List<String> parseOperands() {\n+        List<String> operands = new ArrayList<>();\n+        while (lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER)) {\n+            operands.add(lexer.token().name().substring(1));\n+            lexer.nextToken();\n+        }\n+        return operands;\n+    }\n+\n+    List<SuccessorNode> parseSuccessors() {\n+        List<SuccessorNode> successors = new ArrayList<>();\n+\n+        while (lexer.is(Tokens.TokenKind.CARET) && !isBody()) {\n+            lexer.nextToken();\n+            successors.add(parseSuccessor());\n+        }\n+\n+        return successors;\n+    }\n+\n+    \/\/ Lookahead from \"^\" to determine if Body\n+    boolean isBody() {\n+        assert lexer.is(Tokens.TokenKind.CARET);\n+\n+        int pos = 1;\n+        lexer.token(pos++);\n+        assert lexer.token(1).kind == Tokens.TokenKind.IDENTIFIER;\n+\n+        if (lexer.token(pos++).kind != Tokens.TokenKind.LPAREN) {\n+            return false;\n+        }\n+\n+        Tokens.Token t;\n+        while ((t = lexer.token(pos++)).kind != Tokens.TokenKind.RPAREN) {\n+            if (t.kind == Tokens.TokenKind.EOF) {\n+                return false;\n+            } else if (t.kind == Tokens.TokenKind.COLON) {\n+                \/\/ Encountered Value\n+                return true;\n+            }\n+        }\n+\n+        \/\/ Encountered return type\n+        return lexer.token(pos++).kind == Tokens.TokenKind.IDENTIFIER;\n+    }\n+\n+    SuccessorNode parseSuccessor() {\n+        String blockName = lexer.accept(Tokens.TokenKind.IDENTIFIER).name();\n+\n+        List<String> arguments = new ArrayList<>();\n+        if (lexer.acceptIf(Tokens.TokenKind.LPAREN) && !lexer.acceptIf(Tokens.TokenKind.RPAREN)) {\n+            do {\n+                arguments.add(lexer.accept(Tokens.TokenKind.VALUE_IDENTIFIER).name().substring(1));\n+            } while (lexer.acceptIf(Tokens.TokenKind.COMMA));\n+            lexer.accept(Tokens.TokenKind.RPAREN);\n+        }\n+\n+        return new SuccessorNode(blockName, arguments);\n+    }\n+\n+    List<BodyNode> parseBodies() {\n+        List<BodyNode> bodies = new ArrayList<>();\n+        while (lexer.is(Tokens.TokenKind.CARET) || lexer.is(Tokens.TokenKind.LPAREN)) {\n+            BodyNode body = parseBody();\n+            bodies.add(body);\n+        }\n+        return bodies;\n+    }\n+\n+    BodyNode parseBody() {\n+        \/\/ Body name\n+        final String bodyName;\n+        if (lexer.acceptIf(Tokens.TokenKind.CARET)) {\n+            bodyName = lexer.accept(Tokens.TokenKind.IDENTIFIER).name();\n+        } else {\n+            bodyName = null;\n+        }\n+\n+        \/\/ Entry block header\n+        List<ValueNode> arguments = parseBlockHeaderArguments(true);\n+        \/\/ Body return type\n+        TypeDefinition rtype = parseTypeDef();\n+\n+        lexer.accept(Tokens.TokenKind.ARROW);\n+        lexer.accept(Tokens.TokenKind.LBRACE);\n+\n+        List<BlockNode> blocks = parseBlocks(bodyName, arguments);\n+\n+        lexer.accept(Tokens.TokenKind.RBRACE);\n+\n+        return new BodyNode(rtype, blocks);\n+    }\n+\n+    List<ValueNode> parseBlockHeaderArguments(boolean isEntryBlock) {\n+        boolean parseArguments;\n+        if (isEntryBlock) {\n+            lexer.accept(Tokens.TokenKind.LPAREN);\n+            parseArguments = true;\n+        } else {\n+            parseArguments = lexer.acceptIf(Tokens.TokenKind.LPAREN);\n+        }\n+        if (!parseArguments || lexer.acceptIf(Tokens.TokenKind.RPAREN)) {\n+            return new ArrayList<>();\n+        }\n+\n+        List<ValueNode> arguments = new ArrayList<>();\n+        do {\n+            arguments.add(parseValueNode());\n+        } while (lexer.acceptIf(Tokens.TokenKind.COMMA));\n+        lexer.accept(Tokens.TokenKind.RPAREN);\n+\n+        return arguments;\n+    }\n+\n+    ValueNode parseValueNode() {\n+        String valueName = lexer.accept(Tokens.TokenKind.VALUE_IDENTIFIER).name().substring(1);\n+\n+        lexer.accept(Tokens.TokenKind.COLON);\n+\n+        TypeDefinition type = parseTypeDef();\n+\n+        return new ValueNode(valueName, type);\n+    }\n+\n+    List<BlockNode> parseBlocks(String entryBlockName, List<ValueNode> entryBlockArguments) {\n+        List<BlockNode> blocks = new ArrayList<>();\n+\n+        \/\/ Entry block ops\n+        BlockNode entryBlock = new BlockNode(entryBlockName, entryBlockArguments, parseOperations());\n+        blocks.add(entryBlock);\n+\n+        \/\/ Subsequent blocks\n+        while (lexer.acceptIf(Tokens.TokenKind.CARET)) {\n+            String blockName = lexer.accept(Tokens.TokenKind.IDENTIFIER).name();\n+            List<ValueNode> blockArguments = parseBlockHeaderArguments(false);\n+\n+            lexer.accept(Tokens.TokenKind.COLON);\n+\n+            BlockNode block = new BlockNode(blockName, blockArguments, parseOperations());\n+            blocks.add(block);\n+        }\n+\n+        return blocks;\n+    }\n+\n+    List<OpNode> parseOperations() {\n+        List<OpNode> ops = new ArrayList<>();\n+        while (lexer.is(Tokens.TokenKind.MONKEYS_AT) || lexer.is(Tokens.TokenKind.VALUE_IDENTIFIER) || lexer.is(Tokens.TokenKind.IDENTIFIER)) {\n+            OpNode op = parseOperation();\n+            ops.add(op);\n+        }\n+        return ops;\n+    }\n+\n+    String parseName() {\n+        Tokens.Token t = lexer.accept(Tokens.TokenKind.IDENTIFIER);\n+        StringBuilder name = new StringBuilder();\n+        name.append(t.name());\n+        while (lexer.acceptIf(Tokens.TokenKind.DOT)) {\n+            name.append(Tokens.TokenKind.DOT.name);\n+            t = lexer.accept(Tokens.TokenKind.IDENTIFIER);\n+            name.append(t.name());\n+        }\n+        return name.toString();\n+    }\n+\n+    TypeDefinition parseTypeDef() {\n+        return DescParser.parseTypeDefinition(lexer);\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/OpParser.java","additions":607,"deletions":0,"binary":false,"changes":607,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.parser.impl.Tokens.Token;\n+import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n+import java.lang.reflect.code.type.*;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.reflect.code.type.impl.FieldRefImpl;\n+import java.lang.reflect.code.type.impl.MethodRefImpl;\n+import java.lang.reflect.code.type.impl.RecordTypeRefImpl;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class DescParser {\n+    private DescParser() {}\n+\n+    \/**\n+     * Parse a type definition from its serialized textual form.\n+     * @param desc the serialized type definition\n+     * @return the type definition\n+     *\/\n+    public static TypeDefinition parseTypeDefinition(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseTypeDefinition(s);\n+    }\n+\n+    \/**\n+     * Parse a method reference from its serialized textual form.\n+     *\n+     * @param desc the serialized method reference\n+     * @return the method reference\n+     *\/\n+    public static MethodRef parseMethodRef(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseMethodRef(s);\n+    }\n+\n+    \/**\n+     * Parse a field reference from its serialized textual form.\n+     *\n+     * @param desc the serialized field reference\n+     * @return the field reference\n+     *\/\n+    public static FieldRef parseFieldRef(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseFieldRef(s);\n+    }\n+\n+    \/**\n+     * Parse a record type reference from its serialized textual form.\n+     *\n+     * @param desc the serialized record type reference\n+     * @return the record type reference\n+     *\/\n+    public static RecordTypeRef parseRecordTypeRef(String desc) {\n+        Scanner s = Scanner.factory().newScanner(desc);\n+        s.nextToken();\n+        return parseRecordTypeRef(s);\n+    }\n+\n+    public static TypeDefinition parseTypeDefinition(Lexer l) {\n+        StringBuilder identifier = new StringBuilder();\n+        if (l.token().kind == TokenKind.HASH) {\n+            \/\/ Quoted identifier\n+            Token t = l.token();\n+            while (t.kind != TokenKind.LT) {\n+                identifier.append(t.kind == TokenKind.IDENTIFIER ? t.name() : t.kind.name);\n+                l.nextToken();\n+                t = l.token();\n+            }\n+        } else {\n+            \/\/ Qualified identifier\n+            Tokens.Token t = l.accept(TokenKind.IDENTIFIER,\n+                    TokenKind.PLUS, TokenKind.SUB);\n+            identifier.append(t.kind == TokenKind.IDENTIFIER ? t.name() : t.kind.name);\n+            while (l.acceptIf(Tokens.TokenKind.DOT)) {\n+                identifier.append(Tokens.TokenKind.DOT.name);\n+                t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+                identifier.append(t.name());\n+            }\n+        }\n+\n+        \/\/ Type parameters\n+        List<TypeDefinition> args;\n+        if (l.token().kind == Tokens.TokenKind.LT) {\n+            args = new ArrayList<>();\n+            do {\n+                l.nextToken();\n+                TypeDefinition arg = parseTypeDefinition(l);\n+                args.add(arg);\n+            } while (l.token().kind == Tokens.TokenKind.COMMA);\n+            l.accept(Tokens.TokenKind.GT);\n+        } else {\n+            args = List.of();\n+        }\n+\n+        \/\/ @@@ Enclosed\/inner classes, separated by $ which may also be parameterized\n+\n+        \/\/ Parse array-like syntax []+\n+        int dims = 0;\n+        while (l.acceptIf(Tokens.TokenKind.LBRACKET)) {\n+            l.accept(Tokens.TokenKind.RBRACKET);\n+            dims++;\n+        }\n+\n+        TypeDefinition td = new TypeDefinition(identifier.toString(), args);\n+        if (dims > 0) {\n+            \/\/ If array-like then type definition becomes a child with identifier [+\n+            return new TypeDefinition(\"[\".repeat(dims), List.of(td));\n+        } else {\n+            return td;\n+        }\n+    }\n+\n+    static TypeElement parseTypeElement(Lexer l) {\n+        TypeDefinition typeDesc = parseTypeDefinition(l);\n+        return CoreTypeFactory.CORE_TYPE_FACTORY.constructType(typeDesc);\n+    }\n+\n+    \/\/ (T, T, T, T)R\n+    static FunctionType parseMethodType(Lexer l) {\n+        List<TypeElement> ptypes = new ArrayList<>();\n+        l.accept(Tokens.TokenKind.LPAREN);\n+        if (l.token().kind != Tokens.TokenKind.RPAREN) {\n+            ptypes.add(parseTypeElement(l));\n+            while (l.acceptIf(Tokens.TokenKind.COMMA)) {\n+                ptypes.add(parseTypeElement(l));\n+            }\n+        }\n+        l.accept(Tokens.TokenKind.RPAREN);\n+        TypeElement rtype = parseTypeElement(l);\n+        return FunctionType.functionType(rtype, ptypes);\n+    }\n+\n+    static MethodRef parseMethodRef(Lexer l) {\n+        TypeElement refType = parseTypeElement(l);\n+\n+        l.accept(Tokens.TokenKind.COLCOL);\n+\n+        String methodName;\n+        if (l.acceptIf(Tokens.TokenKind.LT)) {\n+            \/\/ Special name such as \"<new>\"\n+            Tokens.Token t = l.accept(Tokens.TokenKind.IDENTIFIER);\n+            l.accept(Tokens.TokenKind.GT);\n+            methodName = \"<\" + t.name() + \">\";\n+        } else {\n+            methodName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n+        }\n+\n+        FunctionType mtype = parseMethodType(l);\n+\n+        return new MethodRefImpl(refType, methodName, mtype);\n+    }\n+\n+    static FieldRef parseFieldRef(Lexer l) {\n+        TypeElement refType = parseTypeElement(l);\n+\n+        l.accept(Tokens.TokenKind.COLCOL);\n+\n+        String fieldName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n+\n+        FunctionType mtype = parseMethodType(l);\n+        if (!mtype.parameterTypes().isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new FieldRefImpl(refType, fieldName, mtype.returnType());\n+    }\n+\n+    static RecordTypeRef parseRecordTypeRef(Lexer l) {\n+        List<RecordTypeRef.ComponentRef> components = new ArrayList<>();\n+        l.accept(Tokens.TokenKind.LPAREN);\n+        if (l.token().kind != Tokens.TokenKind.RPAREN) {\n+            do {\n+                TypeElement componentType = parseTypeElement(l);\n+                String componentName = l.accept(Tokens.TokenKind.IDENTIFIER).name();\n+\n+                components.add(new RecordTypeRef.ComponentRef(componentType, componentName));\n+            } while(l.acceptIf(Tokens.TokenKind.COMMA));\n+        }\n+        l.accept(Tokens.TokenKind.RPAREN);\n+        TypeElement recordType = parseTypeElement(l);\n+        return new RecordTypeRefImpl(recordType, components);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/DescParser.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+final class Errors {\n+\n+    private Errors() {\n+    }\n+\n+    static final class Error {\n+        String s;\n+\n+        Error(String s) {\n+            this.s = s;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return s;\n+        }\n+    }\n+\n+    static final Error IllegalUnicodeEsc = new Error(\"illegal unicode escape\");\n+    static final Error IllegalNonasciiDigit = new Error(\"illegal non-ASCII digit\");\n+    static final Error IllegalEscChar = new Error(\"illegal escape character\");\n+    static final Error IllegalUnderscore = new Error(\"illegal underscore\");\n+    static final Error IllegalLineEndInCharLit = new Error(\"illegal line end in character literal\");\n+    static final Error IllegalDot = new Error(\"illegal '.'\");\n+    static final Error MalformedFpLit = new Error(\"malformed floating-point literal\");\n+    static final Error InvalidHexNumber = new Error(\"hexadecimal numbers must contain at least one hexadecimal digit\");\n+    static final Error InvalidBinaryNumber = new Error(\"binary numbers must contain at least one binary digit\");\n+    static final Error EmptyCharLit = new Error(\"empty character literal\");\n+    static final Error UnclosedStrLit = new Error(\"unclosed string literal\");\n+    static final Error UnclosedComment = new Error(\"unclosed comment\");\n+    static final Error UnclosedCharLit = new Error(\"unclosed character literal\");\n+\n+    static Error IllegalChar(String c) {\n+        return new Error(\"unmappable character for encoding \" + c);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Errors.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,1130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.parser.impl.Tokens.TokenKind;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode\n+ * escape sequences into a token sequence.\n+ *\/\n+final class JavaBasedTokenizer extends UnicodeReader {\n+    \/**\n+     * If true then prints token information after each nextToken().\n+     *\/\n+    private static final boolean scannerDebug = false;\n+\n+    \/**\n+     * Sentinel for non-value.\n+     *\/\n+    private static final int NOT_FOUND = -1;\n+\n+    \/**\n+     * The log to be used for error reporting. Copied from scanner factory.\n+     *\/\n+    private final Log log;\n+\n+    \/**\n+     * The token factory. Copied from scanner factory.\n+     *\/\n+    private final Tokens tokens;\n+\n+    \/**\n+     * The token kind, set by nextToken().\n+     *\/\n+    Tokens.TokenKind tk;\n+\n+    \/**\n+     * The token's radix, set by nextToken().\n+     *\/\n+    int radix;\n+\n+    \/**\n+     * The token's name, set by nextToken().\n+     *\/\n+    String name;\n+\n+    \/**\n+     * The position where a lexical error occurred;\n+     *\/\n+    int errPos = Position.NOPOS;\n+\n+    \/**\n+     * true if contains escape sequences, set by nextToken().\n+     *\/\n+    boolean hasEscapeSequences;\n+\n+    \/**\n+     * Buffer for building literals, used by nextToken().\n+     *\/\n+    StringBuilder sb;\n+\n+    \/**\n+     * Construct a Java token scanner from the input character array.\n+     *\n+     * @param fac    the factory which created this Scanner\n+     * @param array  the input character array.\n+     * @param length The length of the meaningful content in the array.\n+     *\/\n+    JavaBasedTokenizer(Scanner.Factory fac, char[] array, int length) {\n+        super(fac, array, length);\n+        this.log = fac.log;\n+        this.tokens = fac.tokens;\n+        this.sb = new StringBuilder(256);\n+    }\n+\n+    \/**\n+     * Report an error at the given position using the provided arguments.\n+     *\n+     * @param pos position in input buffer.\n+     * @param key error key to report.\n+     *\/\n+    void lexError(int pos, Errors.Error key) {\n+        tk = Tokens.TokenKind.ERROR;\n+        errPos = pos;\n+        log.error(pos, key);\n+    }\n+\n+    \/**\n+     * Add a character to the literal buffer.\n+     *\n+     * @param ch character to add.\n+     *\/\n+    void put(char ch) {\n+        sb.append(ch);\n+    }\n+\n+    \/**\n+     * Add a codepoint to the literal buffer.\n+     *\n+     * @param codePoint codepoint to add.\n+     *\/\n+    void putCodePoint(int codePoint) {\n+        sb.appendCodePoint(codePoint);\n+    }\n+\n+    \/**\n+     * Add current character or codepoint to the literal buffer.\n+     *\/\n+    void put() {\n+        if (isSurrogate()) {\n+            putCodePoint(getCodepoint());\n+        } else {\n+            put(get());\n+        }\n+    }\n+\n+    \/**\n+     * Add a string to the literal buffer.\n+     *\/\n+    void put(String string) {\n+        sb.append(string);\n+    }\n+\n+    \/**\n+     * Add current character or codepoint to the literal buffer then return next character.\n+     *\/\n+    char putThenNext() {\n+        put();\n+\n+        return next();\n+    }\n+\n+    \/**\n+     * If the specified character ch matches the current character then add current character\n+     * to the literal buffer and then advance.\n+     *\n+     * @param ch character to match.\n+     * @return true if ch matches current character.\n+     *\/\n+    boolean acceptThenPut(char ch) {\n+        if (is(ch)) {\n+            put(get());\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * If either ch1 or ch2 matches the current character then add current character\n+     * to the literal buffer and then advance.\n+     *\n+     * @param ch1 first character to match.\n+     * @param ch2 second character to match.\n+     * @return true if either ch1 or ch2 matches current character.\n+     *\/\n+    boolean acceptOneOfThenPut(char ch1, char ch2) {\n+        if (isOneOf(ch1, ch2)) {\n+            put(get());\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Test if the current character is a line terminator.\n+     *\n+     * @return true if current character is a line terminator.\n+     *\/\n+    private boolean isEOLN() {\n+        return isOneOf('\\n', '\\r');\n+    }\n+\n+    \/**\n+     * Processes the current character and places in the literal buffer. If the current\n+     * character is a backslash then the next character is validated as a proper\n+     * escape character. Conversion of escape sequences takes place at end of nextToken().\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanLitChar(int pos) {\n+        if (acceptThenPut('\\\\')) {\n+            hasEscapeSequences = true;\n+\n+            switch (get()) {\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                    char leadch = get();\n+                    putThenNext();\n+\n+                    if (inRange('0', '7')) {\n+                        putThenNext();\n+\n+                        if (leadch <= '3' && inRange('0', '7')) {\n+                            putThenNext();\n+                        }\n+                    }\n+                    break;\n+\n+                case 'b':\n+                case 't':\n+                case 'n':\n+                case 'f':\n+                case 'r':\n+                case '\\'':\n+                case '\\\"':\n+                case '\\\\':\n+                    putThenNext();\n+                    break;\n+\n+                case '\\n':\n+                case '\\r':\n+                    lexError(position(), Errors.IllegalEscChar);\n+                    break;\n+\n+                default:\n+                    lexError(position(), Errors.IllegalEscChar);\n+                    break;\n+            }\n+        } else {\n+            putThenNext();\n+        }\n+    }\n+\n+    \/**\n+     * Scan a string literal.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanString(int pos) {\n+        \/\/ Assume the best.\n+        tk = Tokens.TokenKind.STRINGLITERAL;\n+        \/\/ Skip first quote.\n+        next();\n+\n+        \/\/ While characters are available.\n+        while (isAvailable()) {\n+            if (accept('\\\"')) {\n+                return;\n+            }\n+\n+            if (isEOLN()) {\n+                \/\/ Line terminator in string literal is an error.\n+                \/\/ Fall out to unclosed string literal error.\n+                break;\n+            } else {\n+                \/\/ Add character to string buffer.\n+                scanLitChar(pos);\n+            }\n+        }\n+\n+        lexError(pos, Errors.UnclosedStrLit);\n+    }\n+\n+    \/**\n+     * Scan sequence of digits.\n+     *\n+     * @param pos        position of the first character in literal.\n+     * @param digitRadix radix of numeric literal.\n+     *\/\n+    private void scanDigits(int pos, int digitRadix) {\n+        int leadingUnderscorePos = is('_') ? position() : NOT_FOUND;\n+        int trailingUnderscorePos;\n+\n+        do {\n+            if (!is('_')) {\n+                put();\n+                trailingUnderscorePos = NOT_FOUND;\n+            } else {\n+                trailingUnderscorePos = position();\n+            }\n+\n+            next();\n+        } while (digit(pos, digitRadix) >= 0 || is('_'));\n+\n+        if (leadingUnderscorePos != NOT_FOUND) {\n+            lexError(leadingUnderscorePos, Errors.IllegalUnderscore);\n+        } else if (trailingUnderscorePos != NOT_FOUND) {\n+            lexError(trailingUnderscorePos, Errors.IllegalUnderscore);\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part of hexadecimal floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanHexExponentAndSuffix(int pos) {\n+        if (acceptOneOfThenPut('p', 'P')) {\n+            skipIllegalUnderscores();\n+            acceptOneOfThenPut('+', '-');\n+            skipIllegalUnderscores();\n+\n+            if (digit(pos, 10) >= 0) {\n+                scanDigits(pos, 10);\n+            } else {\n+                lexError(pos, Errors.MalformedFpLit);\n+            }\n+        } else {\n+            lexError(pos, Errors.MalformedFpLit);\n+        }\n+\n+        if (acceptOneOfThenPut('f', 'F')) {\n+            tk = Tokens.TokenKind.FLOATLITERAL;\n+            radix = 16;\n+        } else {\n+            acceptOneOfThenPut('d', 'D');\n+            tk = Tokens.TokenKind.DOUBLELITERAL;\n+            radix = 16;\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part of floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanFraction(int pos) {\n+        skipIllegalUnderscores();\n+\n+        if (digit(pos, 10) >= 0) {\n+            scanDigits(pos, 10);\n+        }\n+\n+        int index = sb.length();\n+\n+        if (acceptOneOfThenPut('e', 'E')) {\n+            skipIllegalUnderscores();\n+            acceptOneOfThenPut('+', '-');\n+            skipIllegalUnderscores();\n+\n+            if (digit(pos, 10) >= 0) {\n+                scanDigits(pos, 10);\n+                return;\n+            }\n+\n+            lexError(pos, Errors.MalformedFpLit);\n+            sb.setLength(index);\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part and 'd' or 'f' suffix of floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanFractionAndSuffix(int pos) {\n+        radix = 10;\n+        scanFraction(pos);\n+\n+        if (acceptOneOfThenPut('f', 'F')) {\n+            tk = Tokens.TokenKind.FLOATLITERAL;\n+        } else {\n+            acceptOneOfThenPut('d', 'D');\n+            tk = Tokens.TokenKind.DOUBLELITERAL;\n+        }\n+    }\n+\n+    \/**\n+     * Read fractional part and 'd' or 'f' suffix of hexadecimal floating point number.\n+     *\n+     * @param pos position of the first character in literal.\n+     *\/\n+    private void scanHexFractionAndSuffix(int pos, boolean seendigit) {\n+        radix = 16;\n+        assert is('.');\n+        putThenNext();\n+        skipIllegalUnderscores();\n+\n+        if (digit(pos, 16) >= 0) {\n+            seendigit = true;\n+            scanDigits(pos, 16);\n+        }\n+\n+        if (!seendigit)\n+            lexError(pos, Errors.InvalidHexNumber);\n+        else\n+            scanHexExponentAndSuffix(pos);\n+    }\n+\n+    \/**\n+     * Skip over underscores and report as a error if found.\n+     *\/\n+    private void skipIllegalUnderscores() {\n+        if (is('_')) {\n+            lexError(position(), Errors.IllegalUnderscore);\n+            skip('_');\n+        }\n+    }\n+\n+    \/**\n+     * Read a number. (Spec. 3.10)\n+     *\n+     * @param pos   position of the first character in literal.\n+     * @param radix the radix of the number; one of 2, 8, 10, 16.\n+     *\/\n+    private void scanNumber(int pos, int radix) {\n+        \/\/ for octal, allow base-10 digit in case it's a float literal\n+        this.radix = radix;\n+        int digitRadix = (radix == 8 ? 10 : radix);\n+        int firstDigit = digit(pos, Math.max(10, digitRadix));\n+        boolean seendigit = firstDigit >= 0;\n+        boolean seenValidDigit = firstDigit >= 0 && firstDigit < digitRadix;\n+\n+        if (seendigit) {\n+            scanDigits(pos, digitRadix);\n+        }\n+\n+        if (radix == 16 && is('.')) {\n+            scanHexFractionAndSuffix(pos, seendigit);\n+        } else if (seendigit && radix == 16 && isOneOf('p', 'P')) {\n+            scanHexExponentAndSuffix(pos);\n+        } else if (digitRadix == 10 && is('.')) {\n+            putThenNext();\n+            scanFractionAndSuffix(pos);\n+        } else if (digitRadix == 10 && isOneOf('e', 'E', 'f', 'F', 'd', 'D')) {\n+            scanFractionAndSuffix(pos);\n+        } else {\n+            if (!seenValidDigit) {\n+                switch (radix) {\n+                    case 2:\n+                        lexError(pos, Errors.InvalidBinaryNumber);\n+                        break;\n+                    case 16:\n+                        lexError(pos, Errors.InvalidHexNumber);\n+                        break;\n+                }\n+            }\n+            \/\/ If it is not a floating point literal,\n+            \/\/ the octal number should be rescanned correctly.\n+            if (radix == 8) {\n+                sb.setLength(0);\n+                reset(pos);\n+                scanDigits(pos, 8);\n+            }\n+\n+            if (acceptOneOf('l', 'L')) {\n+                tk = Tokens.TokenKind.LONGLITERAL;\n+            } else {\n+                tk = Tokens.TokenKind.INTLITERAL;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Determines if the sequence in the literal buffer is a token (keyword, operator.)\n+     *\/\n+    private void checkIdent(Tokens.TokenKind identifier) {\n+        name = sb.toString();\n+        tk = tokens.lookupKind(name, identifier);\n+    }\n+\n+    \/**\n+     * Read an identifier. (Spec. 3.8)\n+     *\/\n+    private void scanIdent() {\n+        scanIdent(Tokens.TokenKind.IDENTIFIER);\n+    }\n+\n+    \/**\n+     * Read an identifier. (Spec. 3.8)\n+     *\/\n+    private void scanIdent(Tokens.TokenKind identifier) {\n+        putThenNext();\n+\n+        do {\n+            switch (get()) {\n+                case 'A':\n+                case 'B':\n+                case 'C':\n+                case 'D':\n+                case 'E':\n+                case 'F':\n+                case 'G':\n+                case 'H':\n+                case 'I':\n+                case 'J':\n+                case 'K':\n+                case 'L':\n+                case 'M':\n+                case 'N':\n+                case 'O':\n+                case 'P':\n+                case 'Q':\n+                case 'R':\n+                case 'S':\n+                case 'T':\n+                case 'U':\n+                case 'V':\n+                case 'W':\n+                case 'X':\n+                case 'Y':\n+                case 'Z':\n+                case 'a':\n+                case 'b':\n+                case 'c':\n+                case 'd':\n+                case 'e':\n+                case 'f':\n+                case 'g':\n+                case 'h':\n+                case 'i':\n+                case 'j':\n+                case 'k':\n+                case 'l':\n+                case 'm':\n+                case 'n':\n+                case 'o':\n+                case 'p':\n+                case 'q':\n+                case 'r':\n+                case 's':\n+                case 't':\n+                case 'u':\n+                case 'v':\n+                case 'w':\n+                case 'x':\n+                case 'y':\n+                case 'z':\n+                case '$':\n+                case '_':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n+                case '8':\n+                case '9':\n+                    break;\n+\n+                case '\\u0000':\n+                case '\\u0001':\n+                case '\\u0002':\n+                case '\\u0003':\n+                case '\\u0004':\n+                case '\\u0005':\n+                case '\\u0006':\n+                case '\\u0007':\n+                case '\\u0008':\n+                case '\\u000E':\n+                case '\\u000F':\n+                case '\\u0010':\n+                case '\\u0011':\n+                case '\\u0012':\n+                case '\\u0013':\n+                case '\\u0014':\n+                case '\\u0015':\n+                case '\\u0016':\n+                case '\\u0017':\n+                case '\\u0018':\n+                case '\\u0019':\n+                case '\\u001B':\n+                case '\\u007F':\n+                    next();\n+                    continue;\n+\n+                case '\\u001A': \/\/ EOI is also a legal identifier part\n+                    if (isAvailable()) {\n+                        next();\n+                        continue;\n+                    }\n+\n+                    checkIdent(identifier);\n+                    return;\n+\n+                default:\n+                    boolean isJavaIdentifierPart;\n+\n+                    if (isASCII()) {\n+                        \/\/ all ASCII range chars already handled, above\n+                        isJavaIdentifierPart = false;\n+                    } else {\n+                        if (Character.isIdentifierIgnorable(get())) {\n+                            next();\n+                            continue;\n+                        }\n+\n+                        isJavaIdentifierPart = isSurrogate()\n+                                ? Character.isJavaIdentifierPart(getCodepoint())\n+                                : Character.isJavaIdentifierPart(get());\n+                    }\n+\n+                    if (!isJavaIdentifierPart) {\n+                        checkIdent(identifier);\n+                        return;\n+                    }\n+            }\n+\n+            putThenNext();\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Read token (main entrypoint.)\n+     *\/\n+    public Tokens.Token readToken() {\n+        sb.setLength(0);\n+        name = null;\n+        radix = 0;\n+        hasEscapeSequences = false;\n+\n+        int pos = 0;\n+        List<Tokens.Comment> comments = null;\n+\n+        try {\n+            loop:\n+            while (true) {\n+                pos = position();\n+\n+                switch (get()) {\n+                    case ' ':  \/\/ (Spec 3.6)\n+                    case '\\t': \/\/ (Spec 3.6)\n+                    case '\\f': \/\/ (Spec 3.6)\n+                        skipWhitespace();\n+                        processWhiteSpace(pos, position());\n+                        break;\n+\n+                    case '\\n': \/\/ (Spec 3.4)\n+                        next();\n+                        processLineTerminator(pos, position());\n+                        break;\n+\n+                    case '\\r': \/\/ (Spec 3.4)\n+                        next();\n+                        accept('\\n');\n+                        processLineTerminator(pos, position());\n+                        break;\n+\n+                    case 'A':\n+                    case 'B':\n+                    case 'C':\n+                    case 'D':\n+                    case 'E':\n+                    case 'F':\n+                    case 'G':\n+                    case 'H':\n+                    case 'I':\n+                    case 'J':\n+                    case 'K':\n+                    case 'L':\n+                    case 'M':\n+                    case 'N':\n+                    case 'O':\n+                    case 'P':\n+                    case 'Q':\n+                    case 'R':\n+                    case 'S':\n+                    case 'T':\n+                    case 'U':\n+                    case 'V':\n+                    case 'W':\n+                    case 'X':\n+                    case 'Y':\n+                    case 'Z':\n+                    case 'a':\n+                    case 'b':\n+                    case 'c':\n+                    case 'd':\n+                    case 'e':\n+                    case 'f':\n+                    case 'g':\n+                    case 'h':\n+                    case 'i':\n+                    case 'j':\n+                    case 'k':\n+                    case 'l':\n+                    case 'm':\n+                    case 'n':\n+                    case 'o':\n+                    case 'p':\n+                    case 'q':\n+                    case 'r':\n+                    case 's':\n+                    case 't':\n+                    case 'u':\n+                    case 'v':\n+                    case 'w':\n+                    case 'x':\n+                    case 'y':\n+                    case 'z':\n+                    case '$':\n+                    case '_': \/\/ (Spec. 3.8)\n+                        scanIdent();\n+                        break loop;\n+\n+                    case '%':\n+                        scanIdent(Tokens.TokenKind.VALUE_IDENTIFIER);\n+                        break loop;\n+\n+                    case '0': \/\/ (Spec. 3.10)\n+                        next();\n+\n+                        if (acceptOneOf('x', 'X')) {\n+                            skipIllegalUnderscores();\n+                            scanNumber(pos, 16);\n+                        } else if (acceptOneOf('b', 'B')) {\n+                            skipIllegalUnderscores();\n+                            scanNumber(pos, 2);\n+                        } else {\n+                            put('0');\n+\n+                            if (is('_')) {\n+                                int savePos = position();\n+                                skip('_');\n+\n+                                if (digit(pos, 10) < 0) {\n+                                    lexError(savePos, Errors.IllegalUnderscore);\n+                                }\n+                            }\n+\n+                            scanNumber(pos, 8);\n+                        }\n+                        break loop;\n+\n+                    case '1':\n+                    case '2':\n+                    case '3':\n+                    case '4':\n+                    case '5':\n+                    case '6':\n+                    case '7':\n+                    case '8':\n+                    case '9':  \/\/ (Spec. 3.10)\n+                        scanNumber(pos, 10);\n+                        break loop;\n+\n+                    case '.': \/\/ (Spec. 3.12)\n+                        next();\n+                        int savePos = position();\n+\n+                        if (accept('.')) {\n+                            lexError(savePos, Errors.IllegalDot);\n+                        } else if (digit(pos, 10) >= 0) {\n+                            put('.');\n+                            scanFractionAndSuffix(pos); \/\/ (Spec. 3.10)\n+                        } else {\n+                            tk = Tokens.TokenKind.DOT;\n+                        }\n+                        break loop;\n+\n+                    case ',': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.COMMA;\n+                        break loop;\n+\n+                    case '(': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.LPAREN;\n+                        break loop;\n+\n+                    case ')': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.RPAREN;\n+                        break loop;\n+\n+                    case '[': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.LBRACKET;\n+                        break loop;\n+\n+                    case ']': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.RBRACKET;\n+                        break loop;\n+\n+                    case '{': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.LBRACE;\n+                        break loop;\n+\n+                    case '}': \/\/ (Spec. 3.12)\n+                        next();\n+                        tk = Tokens.TokenKind.RBRACE;\n+                        break loop;\n+\n+                    case '?':\n+                        next();\n+                        tk = Tokens.TokenKind.QUES;\n+                        break loop;\n+\n+                    case ';':\n+                        next();\n+                        tk = Tokens.TokenKind.SEMI;\n+                        break loop;\n+\n+                    case ':':\n+                        next();\n+                        if (accept(':')) {\n+                            tk = Tokens.TokenKind.COLCOL;\n+                        } else {\n+                            tk = Tokens.TokenKind.COLON;\n+                        }\n+                        break loop;\n+\n+                    case '&':\n+                        next();\n+                        tk = Tokens.TokenKind.AMP;\n+                        break loop;\n+\n+                    case '@':\n+                        next();\n+                        tk = Tokens.TokenKind.MONKEYS_AT;\n+                        break loop;\n+\n+                    case '^':\n+                        next();\n+                        tk = Tokens.TokenKind.CARET;\n+                        break loop;\n+\n+                    case '=':\n+                        next();\n+                        tk = Tokens.TokenKind.EQ;\n+                        break loop;\n+\n+                    case '<':\n+                        next();\n+                        tk = Tokens.TokenKind.LT;\n+                        break loop;\n+\n+                    case '>':\n+                        next();\n+                        tk = Tokens.TokenKind.GT;\n+                        break loop;\n+\n+                    case '#':\n+                        next();\n+                        tk = TokenKind.HASH;\n+                        break loop;\n+\n+                    case '+':\n+                        next();\n+                        tk = Tokens.TokenKind.PLUS;\n+                        break loop;\n+\n+                    case '-':\n+                        next();\n+                        if (accept('>')) {\n+                            tk = Tokens.TokenKind.ARROW;\n+                        } else {\n+                            tk = Tokens.TokenKind.SUB;\n+                        }\n+                        break loop;\n+\n+                    case '\/':\n+                        next();\n+\n+                        if (accept('\/')) { \/\/ (Spec. 3.7)\n+                            skipToEOLN();\n+\n+                            if (isAvailable()) {\n+                                comments = appendComment(comments, processComment(pos, position(), Tokens.Comment.CommentStyle.LINE));\n+                            }\n+                            break;\n+                        } else if (accept('*')) { \/\/ (Spec. 3.7)\n+                            while (isAvailable()) {\n+                                if (accept('*')) {\n+                                    if (is('\/')) {\n+                                        break;\n+                                    }\n+                                } else {\n+                                    next();\n+                                }\n+                            }\n+\n+                            if (accept('\/')) {\n+                                comments = appendComment(comments, processComment(pos, position(), Tokens.Comment.CommentStyle.BLOCK));\n+\n+                                break;\n+                            } else {\n+                                lexError(pos, Errors.UnclosedComment);\n+\n+                                break loop;\n+                            }\n+                        } else {\n+                            lexError(pos, Errors.UnclosedComment);\n+                        }\n+                        break loop;\n+\n+                    case '\\'': \/\/ (Spec. 3.10)\n+                        next();\n+\n+                        if (accept('\\'')) {\n+                            lexError(pos, Errors.EmptyCharLit);\n+                        } else {\n+                            if (isEOLN()) {\n+                                lexError(pos, Errors.IllegalLineEndInCharLit);\n+                            }\n+\n+                            scanLitChar(pos);\n+\n+                            if (accept('\\'')) {\n+                                tk = Tokens.TokenKind.CHARLITERAL;\n+                            } else {\n+                                lexError(pos, Errors.UnclosedCharLit);\n+                            }\n+                        }\n+                        break loop;\n+\n+                    case '\\\"': \/\/ (Spec. 3.10)\n+                        scanString(pos);\n+                        break loop;\n+\n+                    default:\n+                        boolean isJavaIdentifierStart;\n+\n+                        if (isASCII()) {\n+                            \/\/ all ASCII range chars already handled, above\n+                            isJavaIdentifierStart = false;\n+                        } else {\n+                            isJavaIdentifierStart = isSurrogate()\n+                                    ? Character.isJavaIdentifierStart(getCodepoint())\n+                                    : Character.isJavaIdentifierStart(get());\n+                        }\n+\n+                        if (isJavaIdentifierStart) {\n+                            scanIdent();\n+                        } else if (digit(pos, 10) >= 0) {\n+                            scanNumber(pos, 10);\n+                        } else if (is((char) EOI) || !isAvailable()) {\n+                            tk = Tokens.TokenKind.EOF;\n+                            pos = position();\n+                        } else {\n+                            String arg;\n+\n+                            if (isSurrogate()) {\n+                                int codePoint = getCodepoint();\n+                                char hi = Character.highSurrogate(codePoint);\n+                                char lo = Character.lowSurrogate(codePoint);\n+                                arg = String.format(\"\\\\u%04x\\\\u%04x\", (int) hi, (int) lo);\n+                            } else {\n+                                char ch = get();\n+                                arg = (32 < ch && ch < 127) ? String.format(\"%s\", ch) :\n+                                        String.format(\"\\\\u%04x\", (int) ch);\n+                            }\n+\n+                            lexError(pos, Errors.IllegalChar(arg));\n+                            next();\n+                        }\n+                        break loop;\n+                }\n+            }\n+\n+            int endPos = position();\n+\n+            if (tk.tag == Tokens.Token.Tag.DEFAULT) {\n+                return new Tokens.Token(tk, pos, endPos, comments);\n+            } else if (tk.tag == Tokens.Token.Tag.NAMED) {\n+                return new Tokens.NamedToken(tk, pos, endPos, name, comments);\n+            } else {\n+                \/\/ Get characters from string buffer.\n+                String string = sb.toString();\n+\n+                \/\/ Translate escape sequences if present.\n+                if (hasEscapeSequences) {\n+                    try {\n+                        string = string.translateEscapes();\n+                    } catch (Exception ex) {\n+                        \/\/ Error already reported, just use untranslated string.\n+                    }\n+                }\n+\n+                if (tk.tag == Tokens.Token.Tag.STRING) {\n+                    \/\/ Build string token.\n+                    return new Tokens.StringToken(tk, pos, endPos, string, comments);\n+                } else {\n+                    \/\/ Build numeric token.\n+                    return new Tokens.NumericToken(tk, pos, endPos, string, radix, comments);\n+                }\n+            }\n+        } finally {\n+            int endPos = position();\n+\n+            if (scannerDebug) {\n+                System.out.println(\"nextToken(\" + pos\n+                        + \",\" + endPos + \")=|\" +\n+                        new String(getRawCharacters(pos, endPos))\n+                        + \"| \" + tk.name());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Appends a comment to the list of comments preceding the current token.\n+     *\n+     * @param comments existing list of comments.\n+     * @param comment  comment to append.\n+     * @return new list with comment prepended to the existing list.\n+     *\/\n+    List<Tokens.Comment> appendComment(List<Tokens.Comment> comments, Tokens.Comment comment) {\n+        if (comments == null) {\n+            comments = new ArrayList<>();\n+        }\n+        \/\/ prepend\n+        comments.add(0, comment);\n+        return comments;\n+    }\n+\n+    \/**\n+     * Return the position where a lexical error occurred.\n+     *\n+     * @return position in the input buffer of where the error occurred.\n+     *\/\n+    public int errPos() {\n+        return errPos;\n+    }\n+\n+    \/**\n+     * Set the position where a lexical error occurred.\n+     *\n+     * @param pos position in the input buffer of where the error occurred.\n+     *\/\n+    public void errPos(int pos) {\n+        errPos = pos;\n+    }\n+\n+    \/**\n+     * Called when a complete comment has been scanned. pos and endPos\n+     * will mark the comment boundary.\n+     *\n+     * @param pos    position of the opening \/ in the input buffer.\n+     * @param endPos position + 1 of the closing \/ in the input buffer.\n+     * @param style  style of comment.\n+     * @return the constructed BasicComment.\n+     *\/\n+    Tokens.Comment processComment(int pos, int endPos, Tokens.Comment.CommentStyle style) {\n+        if (scannerDebug) {\n+            System.out.println(\"processComment(\" + pos\n+                    + \",\" + endPos + \",\" + style + \")=|\"\n+                    + new String(getRawCharacters(pos, endPos))\n+                    + \"|\");\n+        }\n+\n+        char[] buf = getRawCharacters(pos, endPos);\n+        return new BasicComment(style, new String(buf));\n+    }\n+\n+    \/**\n+     * Called when a complete whitespace run has been scanned. pos and endPos\n+     * will mark the whitespace boundary.\n+     * <p>\n+     * (Spec 3.6)\n+     *\n+     * @param pos    position in input buffer of first whitespace character.\n+     * @param endPos position + 1 in input buffer of last whitespace character.\n+     *\/\n+    void processWhiteSpace(int pos, int endPos) {\n+        if (scannerDebug) {\n+            System.out.println(\"processWhitespace(\" + pos\n+                    + \",\" + endPos + \")=|\" +\n+                    new String(getRawCharacters(pos, endPos))\n+                    + \"|\");\n+        }\n+    }\n+\n+    \/**\n+     * Called when a line terminator has been processed.\n+     *\n+     * @param pos    position in input buffer of first character in sequence.\n+     * @param endPos position + 1 in input buffer of last character in sequence.\n+     *\/\n+    void processLineTerminator(int pos, int endPos) {\n+        if (scannerDebug) {\n+            System.out.println(\"processTerminator(\" + pos\n+                    + \",\" + endPos + \")=|\" +\n+                    new String(getRawCharacters(pos, endPos))\n+                    + \"|\");\n+        }\n+    }\n+\n+    \/**\n+     * Build a map for translating between line numbers and positions in the input.\n+     *\n+     * @return a LineMap\n+     *\/\n+    public Position.LineMap getLineMap() {\n+        return Position.makeLineMap(getRawCharacters(), length(), false);\n+    }\n+\n+    \/**\n+     * Scan a documentation comment; determine if a deprecated tag is present.\n+     * Called once the initial \/, * have been skipped, positioned at the second *\n+     * (which is treated as the beginning of the first line).\n+     * Stops positioned at the closing '\/'.\n+     *\n+     * @param style Style of comment\n+     *              LINE starting with \/\/\n+     *              BLOCK starting with \/*\n+     *\/\n+    record BasicComment(Tokens.Comment.CommentStyle style, String text) implements Tokens.Comment {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/JavaBasedTokenizer.java","additions":1130,"deletions":0,"binary":false,"changes":1130,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.parser.impl.Position.LineMap;\n+import java.lang.reflect.code.parser.impl.Tokens.Token;\n+import java.util.Arrays;\n+\n+\/**\n+ * The lexical analyzer maps an input stream consisting of ASCII\n+ * characters and Unicode escapes into a token sequence.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public sealed interface Lexer permits Scanner {\n+\n+    \/**\n+     * Consume the next token.\n+     *\/\n+    void nextToken();\n+\n+    \/**\n+     * Return current token.\n+     *\/\n+    Tokens.Token token();\n+\n+    \/**\n+     * Return token with given lookahead.\n+     *\/\n+    Tokens.Token token(int lookahead);\n+\n+    \/**\n+     * Return the last character position of the previous token.\n+     *\/\n+    Tokens.Token prevToken();\n+\n+    \/**\n+     * Return the position where a lexical error occurred;\n+     *\/\n+    int errPos();\n+\n+    \/**\n+     * Set the position where a lexical error occurred;\n+     *\/\n+    void errPos(int pos);\n+\n+    \/**\n+     * Build a map for translating between line numbers and\n+     * positions in the input.\n+     *\n+     * @return a LineMap\n+     *\/\n+    LineMap getLineMap();\n+\n+    default boolean is(Tokens.TokenKind tk) {\n+        Tokens.Token t = token();\n+        if (t.kind == tk) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    default Tokens.Token accept(Tokens.TokenKind tk) {\n+        Tokens.Token t = token();\n+        if (t.kind == tk) {\n+            nextToken();\n+            return t;\n+        } else {\n+            \/\/ @@@ Exception\n+            LineMap lineMap = getLineMap();\n+            int lineNumber = lineMap.getLineNumber(t.pos);\n+            int columnNumber = lineMap.getColumnNumber(t.pos);\n+            throw new IllegalArgumentException(\"Expected \" + tk + \" but observed \" + t.kind +\n+                    \" \" + lineNumber + \":\" + columnNumber);\n+        }\n+    }\n+\n+    default Tokens.Token accept(Tokens.TokenKind... tks) {\n+        Token t = token();\n+        for (Tokens.TokenKind tk : tks) {\n+            if (acceptIf(tk)) {\n+                return t;\n+            }\n+        }\n+        \/\/ @@@ Exception\n+        LineMap lineMap = getLineMap();\n+        int lineNumber = lineMap.getLineNumber(t.pos);\n+        int columnNumber = lineMap.getColumnNumber(t.pos);\n+        throw new IllegalArgumentException(\"Expected one of \" + Arrays.toString(tks) + \" but observed \" + t.kind +\n+                \" \" + lineNumber + \":\" + columnNumber);\n+    }\n+\n+    default boolean acceptIf(Tokens.TokenKind tk) {\n+        Tokens.Token t = token();\n+        if (t.kind == tk) {\n+            nextToken();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    default RuntimeException unexpected() {\n+        Tokens.Token t = token();\n+        LineMap lineMap = getLineMap();\n+        int lineNumber = lineMap.getLineNumber(t.pos);\n+        int columnNumber = lineMap.getColumnNumber(t.pos);\n+        return new IllegalArgumentException(\"Unexpected token \" + t.kind +\n+                \" \" + lineNumber + \":\" + columnNumber);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Lexer.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+final class Log {\n+    Log() {\n+    }\n+\n+    public void error(int pos, Errors.Error errorKey) {\n+        \/\/ @@@ Exception\n+        throw new IllegalStateException(\"Lexer error: \" + errorKey.toString() + \" :\" + pos);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Log.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.BitSet;\n+\n+\/**\n+ * A class that defines source code positions as simple character\n+ * offsets from the beginning of the file. The first character\n+ * is at position 0.\n+ * <p>\n+ * Support is also provided for (line,column) coordinates, but tab\n+ * expansion is optional and no Unicode escape translation is considered.\n+ * The first character is at location (1,1).\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Position {\n+    static final int NOPOS = -1;\n+\n+    static final int FIRSTPOS = 0;\n+    static final int FIRSTLINE = 1;\n+    static final int FIRSTCOLUMN = 1;\n+\n+    static final int LINESHIFT = 10;\n+    static final int MAXCOLUMN = (1 << LINESHIFT) - 1;\n+    static final int MAXLINE = (1 << (Integer.SIZE - LINESHIFT)) - 1;\n+\n+    static final int MAXPOS = Integer.MAX_VALUE;\n+\n+    \/**\n+     * This is class is not supposed to be instantiated.\n+     *\/\n+    private Position() {\n+    }\n+\n+    \/**\n+     * A two-way map between line\/column numbers and positions,\n+     * derived from a scan done at creation time.  Tab expansion is\n+     * optionally supported via a character map.  Text content\n+     * is not retained.\n+     * <p>\n+     * Notes:  The first character position FIRSTPOS is at\n+     * (FIRSTLINE,FIRSTCOLUMN).  No account is taken of Unicode escapes.\n+     *\n+     * @param src        Source characters\n+     * @param max        Number of characters to read\n+     * @param expandTabs If true, expand tabs when calculating columns\n+     *\/\n+    static LineMap makeLineMap(char[] src, int max, boolean expandTabs) {\n+        LineMapImpl lineMap = expandTabs ?\n+                new LineTabMapImpl(max) : new LineMapImpl();\n+        lineMap.build(src, max);\n+        return lineMap;\n+    }\n+\n+    \/**\n+     * Encode line and column numbers in an integer as:\n+     * {@code line-number << LINESHIFT + column-number }.\n+     * {@link Position#NOPOS} represents an undefined position.\n+     *\n+     * @param line number of line (first is 1)\n+     * @param col  number of character on line (first is 1)\n+     * @return an encoded position or {@link Position#NOPOS}\n+     * if the line or column number is too big to\n+     * represent in the encoded format\n+     * @throws IllegalArgumentException if line or col is less than 1\n+     *\/\n+    static int encodePosition(int line, int col) {\n+        if (line < 1)\n+            throw new IllegalArgumentException(\"line must be greater than 0\");\n+        if (col < 1)\n+            throw new IllegalArgumentException(\"column must be greater than 0\");\n+\n+        if (line > MAXLINE || col > MAXCOLUMN) {\n+            return NOPOS;\n+        }\n+        return (line << LINESHIFT) + col;\n+    }\n+\n+    public interface LineMap {\n+        \/**\n+         * Finds the start position of a line.\n+         *\n+         * @param line line number (beginning at 1)\n+         * @return position of first character in line\n+         * @throws IndexOutOfBoundsException if {@code lineNumber < 1}\n+         *                                   if {@code lineNumber > no. of lines}\n+         *\/\n+        long getStartPosition(long line);\n+\n+        \/**\n+         * Finds the position corresponding to a (line,column).\n+         *\n+         * @param line   line number (beginning at 1)\n+         * @param column tab-expanded column number (beginning 1)\n+         * @return position of character\n+         * @throws IndexOutOfBoundsException if {@code line < 1}\n+         *                                   if {@code line > no. of lines}\n+         *\/\n+        long getPosition(long line, long column);\n+\n+        \/**\n+         * Finds the line containing a position; a line termination\n+         * character is on the line it terminates.\n+         *\n+         * @param pos character offset of the position\n+         * @return the line number of pos (first line is 1)\n+         *\/\n+        long getLineNumber(long pos);\n+\n+        \/**\n+         * Finds the column for a character position.\n+         * Tab characters preceding the position on the same line\n+         * will be expanded when calculating the column number.\n+         *\n+         * @param pos character offset of the position\n+         * @return the tab-expanded column number of pos (first column is 1)\n+         *\/\n+        long getColumnNumber(long pos);\n+\n+        \/**\n+         * Find the start position of a line.\n+         *\n+         * @param line number of line (first is 1)\n+         * @return position of first character in line\n+         * @throws ArrayIndexOutOfBoundsException if {@code lineNumber < 1}\n+         *                                        if {@code lineNumber > no. of lines}\n+         *\/\n+        int getStartPosition(int line);\n+\n+        \/**\n+         * Find the position corresponding to a (line,column).\n+         *\n+         * @param line   number of line (first is 1)\n+         * @param column number of character on line (first is 1)\n+         * @return position of character\n+         * @throws ArrayIndexOutOfBoundsException if {@code line < 1}\n+         *                                        if {@code line > no. of lines}\n+         *\/\n+        int getPosition(int line, int column);\n+\n+        \/**\n+         * Find the line containing a position; a line termination\n+         * character is on the line it terminates.\n+         *\n+         * @param pos character offset of the position\n+         * @return the line number on which pos occurs (first line is 1)\n+         *\/\n+        int getLineNumber(int pos);\n+\n+        \/**\n+         * Find the column for a character position.\n+         * Note:  this method does not handle tab expansion.\n+         * If tab expansion is needed, use a LineTabMap instead.\n+         *\n+         * @param pos character offset of the position\n+         * @return the column number at which pos occurs\n+         *\/\n+        int getColumnNumber(int pos);\n+    }\n+\n+    static class LineMapImpl implements LineMap {\n+        int[] startPosition; \/\/ start position of each line\n+\n+        LineMapImpl() {\n+        }\n+\n+        void build(char[] src, int max) {\n+            int c = 0;\n+            int i = 0;\n+            int[] linebuf = new int[max];\n+            while (i < max) {\n+                linebuf[c++] = i;\n+                do {\n+                    char ch = src[i];\n+                    if (ch == '\\r' || ch == '\\n') {\n+                        if (ch == '\\r' && (i + 1) < max && src[i + 1] == '\\n')\n+                            i += 2;\n+                        else\n+                            ++i;\n+                        break;\n+                    } else if (ch == '\\t')\n+                        setTabPosition(i);\n+                } while (++i < max);\n+            }\n+            this.startPosition = new int[c];\n+            System.arraycopy(linebuf, 0, startPosition, 0, c);\n+        }\n+\n+        @Override\n+        public int getStartPosition(int line) {\n+            return startPosition[line - FIRSTLINE];\n+        }\n+\n+        @Override\n+        public long getStartPosition(long line) {\n+            return getStartPosition(longToInt(line));\n+        }\n+\n+        @Override\n+        public int getPosition(int line, int column) {\n+            return startPosition[line - FIRSTLINE] + column - FIRSTCOLUMN;\n+        }\n+\n+        @Override\n+        public long getPosition(long line, long column) {\n+            return getPosition(longToInt(line), longToInt(column));\n+        }\n+\n+        \/\/ Cache of last line number lookup\n+        private int lastPosition = Position.FIRSTPOS;\n+        private int lastLine = Position.FIRSTLINE;\n+\n+        @Override\n+        public int getLineNumber(int pos) {\n+            if (pos == lastPosition) {\n+                return lastLine;\n+            }\n+            lastPosition = pos;\n+\n+            int low = 0;\n+            int high = startPosition.length - 1;\n+            while (low <= high) {\n+                int mid = (low + high) >> 1;\n+                int midVal = startPosition[mid];\n+\n+                if (midVal < pos)\n+                    low = mid + 1;\n+                else if (midVal > pos)\n+                    high = mid - 1;\n+                else {\n+                    lastLine = mid + 1; \/\/ pos is at beginning of this line\n+                    return lastLine;\n+                }\n+            }\n+            lastLine = low;\n+            return lastLine;  \/\/ pos is on this line\n+        }\n+\n+        @Override\n+        public long getLineNumber(long pos) {\n+            return getLineNumber(longToInt(pos));\n+        }\n+\n+        @Override\n+        public int getColumnNumber(int pos) {\n+            return pos - startPosition[getLineNumber(pos) - FIRSTLINE] + FIRSTCOLUMN;\n+        }\n+\n+        @Override\n+        public long getColumnNumber(long pos) {\n+            return getColumnNumber(longToInt(pos));\n+        }\n+\n+        static int longToInt(long longValue) {\n+            int intValue = (int) longValue;\n+            if (intValue != longValue)\n+                throw new IndexOutOfBoundsException();\n+            return intValue;\n+        }\n+\n+        void setTabPosition(int offset) {\n+        }\n+    }\n+\n+    \/**\n+     * A LineMap that handles tab expansion correctly.  The cost is\n+     * an additional bit per character in the source array.\n+     *\/\n+    static class LineTabMapImpl extends LineMapImpl {\n+        private final BitSet tabMap;       \/\/ bits set for tab positions.\n+\n+        LineTabMapImpl(int max) {\n+            super();\n+            tabMap = new BitSet(max);\n+        }\n+\n+        @Override\n+        void setTabPosition(int offset) {\n+            tabMap.set(offset);\n+        }\n+\n+        @Override\n+        public int getColumnNumber(int pos) {\n+            int lineStart = startPosition[getLineNumber(pos) - FIRSTLINE];\n+            int column = 0;\n+            for (int bp = lineStart; bp < pos; bp++) {\n+                if (tabMap.get(bp))\n+                    column = tabulate(column);\n+                else\n+                    column++;\n+            }\n+            return column + FIRSTCOLUMN;\n+        }\n+\n+        @Override\n+        public int getPosition(int line, int column) {\n+            int pos = startPosition[line - FIRSTLINE];\n+            column -= FIRSTCOLUMN;\n+            int col = 0;\n+            while (col < column) {\n+                pos++;\n+                if (tabMap.get(pos))\n+                    col = tabulate(col);\n+                else\n+                    col++;\n+            }\n+            return pos;\n+        }\n+    }\n+\n+    \/**\n+     * Tabulator column increment.\n+     *\/\n+    static final int TabInc = 8;\n+\n+    \/**\n+     * Bump column to the next tab.\n+     *\/\n+    static int tabulate(int column) {\n+        return (column \/ TabInc * TabInc) + TabInc;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Position.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.lang.reflect.code.parser.impl.Position.LineMap;\n+\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.parser.impl.Tokens.DUMMY;\n+import static java.lang.reflect.code.parser.impl.Tokens.Token;\n+\n+\/**\n+ * The lexical analyzer maps an input stream consisting of\n+ * ASCII characters and Unicode escapes into a token sequence.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Scanner implements Lexer {\n+\n+    private final Tokens tokens;\n+\n+    \/**\n+     * The token, set by nextToken().\n+     *\/\n+    private Token token;\n+\n+    \/**\n+     * The previous token, set by nextToken().\n+     *\/\n+    private Token prevToken;\n+\n+    \/**\n+     * Buffer of saved tokens (used during lookahead)\n+     *\/\n+    private final List<Token> savedTokens = new ArrayList<>();\n+\n+    private final JavaBasedTokenizer tokenizer;\n+\n+    Scanner(Factory fac, char[] buf, int inputLength) {\n+        this(fac, new JavaBasedTokenizer(fac, buf, inputLength));\n+    }\n+\n+    Scanner(Factory fac, JavaBasedTokenizer tokenizer) {\n+        this.tokenizer = tokenizer;\n+        tokens = fac.tokens;\n+        token = prevToken = DUMMY;\n+    }\n+\n+    public Token token() {\n+        return token(0);\n+    }\n+\n+    public Token token(int lookahead) {\n+        if (lookahead == 0) {\n+            return token;\n+        } else {\n+            ensureLookahead(lookahead);\n+            return savedTokens.get(lookahead - 1);\n+        }\n+    }\n+\n+    \/\/where\n+    private void ensureLookahead(int lookahead) {\n+        for (int i = savedTokens.size(); i < lookahead; i++) {\n+            savedTokens.add(tokenizer.readToken());\n+        }\n+    }\n+\n+    public Token prevToken() {\n+        return prevToken;\n+    }\n+\n+    public void nextToken() {\n+        prevToken = token;\n+        if (!savedTokens.isEmpty()) {\n+            token = savedTokens.remove(0);\n+        } else {\n+            token = tokenizer.readToken();\n+        }\n+    }\n+\n+    public LineMap getLineMap() {\n+        return tokenizer.getLineMap();\n+    }\n+\n+    public int errPos() {\n+        return tokenizer.errPos();\n+    }\n+\n+    public void errPos(int pos) {\n+        tokenizer.errPos(pos);\n+    }\n+\n+    public static final class Factory {\n+        final Log log;\n+        final Tokens tokens;\n+\n+        \/**\n+         * Create a new scanner factory.\n+         *\/\n+        Factory() {\n+            this.log = new Log();\n+            this.tokens = new Tokens();\n+        }\n+\n+        public Scanner newScanner(CharSequence input) {\n+            if (input instanceof CharBuffer charBuffer) {\n+                return newScanner(toArray(charBuffer), charBuffer.limit());\n+            } else {\n+                char[] array = input.toString().toCharArray();\n+                return newScanner(array, array.length);\n+            }\n+        }\n+\n+        public Scanner newScanner(char[] input, int inputLength) {\n+            return new Scanner(this, input, inputLength);\n+        }\n+\n+        static char[] toArray(CharBuffer buffer) {\n+            if (buffer.hasArray())\n+                return buffer.compact().flip().array();\n+            else\n+                return buffer.toString().toCharArray();\n+        }\n+\n+        static final Factory INSTANCE = new Factory();\n+    }\n+\n+    public static Factory factory() {\n+        return Factory.INSTANCE;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Scanner.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * A class that defines codes\/utilities for Java source tokens\n+ * returned from lexical analysis.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public final class Tokens {\n+\n+    \/**\n+     * Keyword array. Maps name indices to Token.\n+     *\/\n+    private final Map<String, TokenKind> keywords = new HashMap<>();\n+\n+    Tokens() {\n+        for (TokenKind t : TokenKind.values()) {\n+            if (t.name != null) {\n+                keywords.put(t.name, t);\n+            }\n+        }\n+    }\n+\n+    TokenKind lookupKind(String name, TokenKind identifier) {\n+        TokenKind t = keywords.get(name);\n+        return (t != null) ? t : identifier;\n+    }\n+\n+    \/**\n+     * This enum defines all tokens used by the javac scanner. A token is\n+     * optionally associated with a name.\n+     *\/\n+    public enum TokenKind implements Predicate<TokenKind> {\n+        EOF(),\n+        ERROR(),\n+        IDENTIFIER(Token.Tag.NAMED),\n+        VALUE_IDENTIFIER(Token.Tag.NAMED),\n+        EXTENDS(\"extends\", Token.Tag.NAMED),\n+        SUPER(\"super\", Token.Tag.NAMED),\n+        INTLITERAL(Token.Tag.NUMERIC),\n+        LONGLITERAL(Token.Tag.NUMERIC),\n+        FLOATLITERAL(Token.Tag.NUMERIC),\n+        DOUBLELITERAL(Token.Tag.NUMERIC),\n+        CHARLITERAL(Token.Tag.NUMERIC),\n+        STRINGLITERAL(Token.Tag.STRING),\n+        TRUE(\"true\", Token.Tag.NAMED),\n+        FALSE(\"false\", Token.Tag.NAMED),\n+        NULL(\"null\", Token.Tag.NAMED),\n+        UNDERSCORE(\"_\", Token.Tag.NAMED),\n+        ARROW(\"->\"),\n+        LPAREN(\"(\"),\n+        RPAREN(\")\"),\n+        LBRACE(\"{\"),\n+        RBRACE(\"}\"),\n+        LBRACKET(\"[\"),\n+        RBRACKET(\"]\"),\n+        COMMA(\",\"),\n+        DOT(\".\"),\n+        EQ(\"=\"),\n+        GT(\">\"),\n+        LT(\"<\"),\n+        QUES(\"?\"),\n+        COLON(\":\"),\n+        COLCOL(\"::\"),\n+        SEMI(\";\"),\n+        PLUS(\"+\"),\n+        SUB(\"-\"),\n+        AMP(\"&\"),\n+        CARET(\"^\"),\n+        MONKEYS_AT(\"@\"),\n+        HASH(\"#\"),\n+        CUSTOM;\n+\n+        public final String name;\n+        public final Token.Tag tag;\n+\n+        TokenKind() {\n+            this(null, Token.Tag.DEFAULT);\n+        }\n+\n+        TokenKind(String name) {\n+            this(name, Token.Tag.DEFAULT);\n+        }\n+\n+        TokenKind(Token.Tag tag) {\n+            this(null, tag);\n+        }\n+\n+        TokenKind(String name, Token.Tag tag) {\n+            this.name = name;\n+            this.tag = tag;\n+        }\n+\n+        public String toString() {\n+            return switch (this) {\n+                case IDENTIFIER -> \"token.identifier\";\n+                case VALUE_IDENTIFIER -> \"token.value-identifier\";\n+                case CHARLITERAL -> \"token.character\";\n+                case STRINGLITERAL -> \"token.string\";\n+                case INTLITERAL -> \"token.integer\";\n+                case LONGLITERAL -> \"token.long-integer\";\n+                case FLOATLITERAL -> \"token.float\";\n+                case DOUBLELITERAL -> \"token.double\";\n+                case ERROR -> \"token.bad-symbol\";\n+                case EOF -> \"token.end-of-input\";\n+                case DOT, COMMA, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE -> \"'\" + name + \"'\";\n+                default -> name;\n+            };\n+        }\n+\n+        @Override\n+        public boolean test(TokenKind that) {\n+            return this == that;\n+        }\n+    }\n+\n+    public interface Comment {\n+\n+        enum CommentStyle {\n+            LINE,\n+            BLOCK,\n+        }\n+\n+        String text();\n+\n+        CommentStyle style();\n+    }\n+\n+    \/**\n+     * This is the class representing a javac token. Each token has several fields\n+     * that are set by the javac lexer (i.e. start\/end position, string value, etc).\n+     *\/\n+    public static class Token {\n+\n+        \/**\n+         * tags constants\n+         **\/\n+        public enum Tag {\n+            DEFAULT,\n+            NAMED,\n+            STRING,\n+            NUMERIC\n+        }\n+\n+        \/**\n+         * The token kind\n+         *\/\n+        public final TokenKind kind;\n+\n+        \/**\n+         * The start position of this token\n+         *\/\n+        public final int pos;\n+\n+        \/**\n+         * The end position of this token\n+         *\/\n+        public final int endPos;\n+\n+        \/**\n+         * Comment reader associated with this token\n+         *\/\n+        public final List<Comment> comments;\n+\n+        Token(TokenKind kind, int pos, int endPos, List<Comment> comments) {\n+            this.kind = kind;\n+            this.pos = pos;\n+            this.endPos = endPos;\n+            this.comments = comments == null ? null : List.copyOf(comments);\n+            checkKind();\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.DEFAULT) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.DEFAULT);\n+            }\n+        }\n+\n+        public String name() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public String stringVal() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int radix() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static final class NamedToken extends Token {\n+        \/**\n+         * The name of this token\n+         *\/\n+        public final String name;\n+\n+        NamedToken(TokenKind kind, int pos, int endPos, String name, List<Comment> comments) {\n+            super(kind, pos, endPos, comments);\n+            this.name = name;\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.NAMED) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.NAMED);\n+            }\n+        }\n+\n+        @Override\n+        public String name() {\n+            return name;\n+        }\n+    }\n+\n+    static class StringToken extends Token {\n+        \/**\n+         * The string value of this token\n+         *\/\n+        public final String stringVal;\n+\n+        StringToken(TokenKind kind, int pos, int endPos, String stringVal, List<Comment> comments) {\n+            super(kind, pos, endPos, comments);\n+            this.stringVal = stringVal;\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.STRING) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.STRING);\n+            }\n+        }\n+\n+        @Override\n+        public String stringVal() {\n+            return stringVal;\n+        }\n+    }\n+\n+    static final class NumericToken extends StringToken {\n+        \/**\n+         * The 'radix' value of this token\n+         *\/\n+        public final int radix;\n+\n+        NumericToken(TokenKind kind, int pos, int endPos, String stringVal, int radix, List<Comment> comments) {\n+            super(kind, pos, endPos, stringVal, comments);\n+            this.radix = radix;\n+        }\n+\n+        void checkKind() {\n+            if (kind.tag != Tag.NUMERIC) {\n+                throw new AssertionError(\"Bad token kind - expected \" + Tag.NUMERIC);\n+            }\n+        }\n+\n+        @Override\n+        public int radix() {\n+            return radix;\n+        }\n+    }\n+\n+    public static final Token DUMMY =\n+            new Token(TokenKind.ERROR, 0, 0, null);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/Tokens.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,564 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.parser.impl;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * The unicode character reader used by the javac\/javadoc lexer\/tokenizer, returns characters\n+ * one by one as contained in the input stream, handling unicode escape sequences accordingly.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b><\/p>\n+ *\/\n+sealed class UnicodeReader permits JavaBasedTokenizer {\n+    \/**\n+     * End of input character.  Used as a sentinel to denote the\n+     * character one beyond the last defined character in a\n+     * source file.\n+     *\/\n+    static final byte EOI = 0x1A;\n+\n+    \/**\n+     * Buffer containing characters from source file. May contain extraneous characters\n+     * beyond this.length.\n+     *\/\n+    private final char[] buffer;\n+\n+    \/**\n+     * Length of meaningful content in buffer.\n+     *\/\n+    private final int length;\n+\n+    \/**\n+     * Character buffer index of character currently being observed.\n+     *\/\n+    private int position;\n+\n+    \/**\n+     * Number of characters combined to provide character currently being observed. Typically\n+     * one, but may be more when combinations of surrogate pairs and unicode escape sequences\n+     * are read.\n+     *\/\n+    private int width;\n+\n+    \/**\n+     * Character currently being observed. If a surrogate pair is read then will be the high\n+     * member of the pair.\n+     *\/\n+    private char character;\n+\n+    \/**\n+     * Codepoint of character currently being observed. Typically equivalent to the character\n+     * but will have a value greater that 0xFFFF when a surrogate pair.\n+     *\/\n+    private int codepoint;\n+\n+    \/**\n+     * true if the last character was a backslash. This is used to handle the special case\n+     * when a backslash precedes an unicode escape. In that case, the second backslash\n+     * is treated as a backslash and not part of an unicode escape.\n+     *\/\n+    private boolean wasBackslash;\n+\n+    \/**\n+     * true if the last character was derived from an unicode escape sequence.\n+     *\/\n+    private boolean wasUnicodeEscape;\n+\n+    \/**\n+     * Log for error reporting.\n+     *\/\n+    private final Log log;\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param sf     scan factory.\n+     * @param array  array containing contents of source.\n+     * @param length length of meaningful content in buffer.\n+     *\/\n+    UnicodeReader(Scanner.Factory sf, char[] array, int length) {\n+        this.buffer = array;\n+        this.length = length;\n+        this.position = 0;\n+        this.width = 0;\n+        this.character = '\\0';\n+        this.codepoint = 0;\n+        this.wasBackslash = false;\n+        this.wasUnicodeEscape = false;\n+        this.log = sf.log;\n+\n+        nextCodePoint();\n+    }\n+\n+    \/**\n+     * Returns the length of the buffer. This is length of meaningful content in buffer and\n+     * not the length of the buffer array.\n+     *\n+     * @return length of the buffer.\n+     *\/\n+    protected int length() {\n+        return length;\n+    }\n+\n+    \/**\n+     * Return true if current position is within the meaningful part of the buffer.\n+     *\n+     * @return true if current position is within the meaningful part of the buffer.\n+     *\/\n+    protected boolean isAvailable() {\n+        return position < length;\n+    }\n+\n+    \/**\n+     * Fetches the next 16-bit character from the buffer and places it in this.character.\n+     *\/\n+    private void nextCodeUnit() {\n+        \/\/ Index of next character in buffer.\n+        int index = position + width;\n+\n+        \/\/ If past end of buffer.\n+        if (length <= index) {\n+            \/\/ End of file is marked with EOI.\n+            character = EOI;\n+        } else {\n+            \/\/ Next character in buffer.\n+            character = buffer[index];\n+            \/\/ Increment length of codepoint.\n+            width++;\n+        }\n+    }\n+\n+    \/**\n+     * Fetches the next 16-bit character from the buffer. If an unicode escape\n+     * is detected then converts the unicode escape to a character.\n+     *\/\n+    private void nextUnicodeInputCharacter() {\n+        \/\/ Position to next codepoint.\n+        position += width;\n+        \/\/ Codepoint has no characters yet.\n+        width = 0;\n+\n+        \/\/ Fetch next character.\n+        nextCodeUnit();\n+\n+        if (character == '\\\\' && (!wasBackslash || wasUnicodeEscape)) {\n+            \/\/ Is a backslash and may be an unicode escape.\n+            switch (unicodeEscape()) {\n+                case BACKSLASH -> {\n+                    wasUnicodeEscape = false;\n+                    wasBackslash = !wasBackslash;\n+                }\n+                case VALID_ESCAPE -> {\n+                    wasUnicodeEscape = true;\n+                    wasBackslash = character == '\\\\' && !wasBackslash;\n+                }\n+                case BROKEN_ESCAPE -> nextUnicodeInputCharacter(); \/\/skip broken unicode escapes\n+            }\n+        } else {\n+            wasBackslash = false;\n+            wasUnicodeEscape = false;\n+        }\n+\n+        \/\/ Codepoint and character match if not surrogate.\n+        codepoint = (int) character;\n+    }\n+\n+    \/**\n+     * Fetches the nextcode point from the buffer. If an unicode escape is recognized\n+     * then converts unicode escape to a character. If two characters are a surrogate pair\n+     * then converts to a codepoint.\n+     *\/\n+    private void nextCodePoint() {\n+        \/\/ Next unicode character.\n+        nextUnicodeInputCharacter();\n+\n+        \/\/ Return early if ASCII or not a surrogate pair.\n+        if (isASCII() || !Character.isHighSurrogate(character)) {\n+            return;\n+        }\n+\n+        \/\/ Capture high surrogate and position.\n+        char hi = character;\n+        int savePosition = position;\n+        int saveWidth = width;\n+\n+        \/\/ Get potential low surrogate.\n+        nextUnicodeInputCharacter();\n+        char lo = character;\n+\n+        if (Character.isLowSurrogate(lo)) {\n+            \/\/ Start codepoint at start of high surrogate.\n+            position = savePosition;\n+            width += saveWidth;\n+            \/\/ Compute codepoint.\n+            codepoint = Character.toCodePoint(hi, lo);\n+        } else {\n+            \/\/ Restore to treat high surrogate as just a character.\n+            position = savePosition;\n+            width = saveWidth;\n+            character = hi;\n+            codepoint = (int) hi;\n+            \/\/ Could potential report an error here (old code did not.)\n+        }\n+    }\n+\n+    \/**\n+     * Converts an unicode escape into a character.\n+     *\n+     * @return true if was an unicode escape.\n+     *\/\n+    private UnicodeEscapeResult unicodeEscape() {\n+        \/\/ Start of unicode escape (past backslash.)\n+        int start = position + width;\n+\n+        \/\/ Default to backslash result, unless proven otherwise.\n+        character = '\\\\';\n+        width = 1;\n+\n+        \/\/ Skip multiple 'u'.\n+        int index;\n+        for (index = start; index < length; index++) {\n+            if (buffer[index] != 'u') {\n+                break;\n+            }\n+        }\n+\n+        \/\/ Needs to have been at least one u.\n+        if (index == start) {\n+            return UnicodeEscapeResult.BACKSLASH;\n+        }\n+\n+        int code = 0;\n+\n+        for (int i = 0; i < 4; i++) {\n+            \/\/ Translate and merge digit.\n+            int digit = index < length ? Character.digit(buffer[index], 16) : -1;\n+            code = code << 4 | digit;\n+\n+            \/\/ If invalid digit.\n+            if (code < 0) {\n+                break;\n+            }\n+\n+            \/\/ On to next character.\n+            index++;\n+        }\n+\n+        \/\/ Skip digits even if error.\n+        width = index - position;\n+\n+        \/\/ If all digits are good.\n+        if (code >= 0) {\n+            character = (char) code;\n+            return UnicodeEscapeResult.VALID_ESCAPE;\n+        } else {\n+            log.error(index, Errors.IllegalUnicodeEsc);\n+            return UnicodeEscapeResult.BROKEN_ESCAPE;\n+        }\n+    }\n+\n+    private enum UnicodeEscapeResult {\n+        BACKSLASH,\n+        VALID_ESCAPE,\n+        BROKEN_ESCAPE\n+    }\n+\n+    \/**\n+     * Return the current position in the character buffer.\n+     *\n+     * @return current position in the character buffer.\n+     *\/\n+    protected int position() {\n+        return position;\n+    }\n+\n+\n+    \/**\n+     * Reset the reader to the specified position.\n+     * Warning: Do not use when previous character was an ASCII or unicode backslash.\n+     *\n+     * @param pos\n+     *\/\n+    protected void reset(int pos) {\n+        position = pos;\n+        width = 0;\n+        wasBackslash = false;\n+        wasUnicodeEscape = false;\n+        nextCodePoint();\n+    }\n+\n+    \/**\n+     * Return the current character in at the current position.\n+     *\n+     * @return current character in at the current position.\n+     *\/\n+    protected char get() {\n+        return character;\n+    }\n+\n+    \/**\n+     * Return the current codepoint in at the current position.\n+     *\n+     * @return current codepoint in at the current position.\n+     *\/\n+    protected int getCodepoint() {\n+        return codepoint;\n+    }\n+\n+    \/**\n+     * Returns true if the current codepoint is a surrogate.\n+     *\n+     * @return true if the current codepoint is a surrogate.\n+     *\/\n+    protected boolean isSurrogate() {\n+        return 0xFFFF < codepoint;\n+    }\n+\n+    \/**\n+     * Returns true if the current character is ASCII.\n+     *\n+     * @return true if the current character is ASCII.\n+     *\/\n+    protected boolean isASCII() {\n+        return character <= 0x7F;\n+    }\n+\n+    \/**\n+     * Advances the current character to the next character.\n+     *\n+     * @return next character.\n+     *\/\n+    protected char next() {\n+        nextCodePoint();\n+\n+        return character;\n+    }\n+\n+    \/**\n+     * Compare character. Returns true if a match.\n+     *\n+     * @param ch character to match.\n+     * @return true if a match.\n+     *\/\n+    protected boolean is(char ch) {\n+        return character == ch;\n+    }\n+\n+    \/**\n+     * Match one of the arguments. Returns true if a match.\n+     *\/\n+    protected boolean isOneOf(char ch1, char ch2) {\n+        return is(ch1) || is(ch2);\n+    }\n+\n+    protected boolean isOneOf(char ch1, char ch2, char ch3) {\n+        return is(ch1) || is(ch2) || is(ch3);\n+    }\n+\n+    protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {\n+        return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);\n+    }\n+\n+    \/**\n+     * Tests to see if current character is in the range of lo to hi characters (inclusive).\n+     *\n+     * @param lo lowest character in range.\n+     * @param hi highest character in range.\n+     * @return true if the current character is in range.\n+     *\/\n+    protected boolean inRange(char lo, char hi) {\n+        return lo <= character && character <= hi;\n+    }\n+\n+    \/**\n+     * Compare character and advance if a match. Returns true if a match.\n+     *\n+     * @param ch character to match.\n+     * @return true if a match.\n+     *\/\n+    protected boolean accept(char ch) {\n+        if (is(ch)) {\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Match one of the arguments and advance if a match. Returns true if a match.\n+     *\/\n+    protected boolean acceptOneOf(char ch1, char ch2) {\n+        if (isOneOf(ch1, ch2)) {\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    protected boolean acceptOneOf(char ch1, char ch2, char ch3) {\n+        if (isOneOf(ch1, ch2, ch3)) {\n+            next();\n+\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Skip over all occurrences of character.\n+     *\n+     * @param ch character to accept.\n+     *\/\n+    protected void skip(char ch) {\n+        while (accept(ch)) {\n+            \/\/ next\n+        }\n+    }\n+\n+    \/**\n+     * Skip over ASCII white space characters.\n+     *\/\n+    protected void skipWhitespace() {\n+        while (acceptOneOf(' ', '\\t', '\\f')) {\n+            \/\/ next\n+        }\n+    }\n+\n+    \/**\n+     * Skip to end of line.\n+     *\/\n+    protected void skipToEOLN() {\n+        while (isAvailable()) {\n+            if (isOneOf('\\r', '\\n')) {\n+                break;\n+            }\n+\n+            next();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Compare string and advance if a match. Returns true if a match.\n+     * Warning: Do not use when previous character was a backslash\n+     * (confuses state of wasBackslash.)\n+     *\n+     * @param string string to match character for character.\n+     * @return true if a match.\n+     *\/\n+    protected boolean accept(String string) {\n+        \/\/ Quick test.\n+        if (string.length() == 0 || !is(string.charAt(0))) {\n+            return false;\n+        }\n+\n+        \/\/ Be prepared to retreat if not a match.\n+        int savedPosition = position;\n+\n+        nextCodePoint();\n+\n+        \/\/ Check each character.\n+        for (int i = 1; i < string.length(); i++) {\n+            if (!is(string.charAt(i))) {\n+                \/\/ Restart if not a match.\n+                reset(savedPosition);\n+\n+                return false;\n+            }\n+\n+            nextCodePoint();\n+        }\n+\n+        return true;\n+    }\n+\n+    \/**\n+     * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not\n+     * advance character.\n+     *\n+     * @param pos        starting position.\n+     * @param digitRadix base of number being converted.\n+     * @return value of digit.\n+     *\/\n+    protected int digit(int pos, int digitRadix) {\n+        int result;\n+\n+        \/\/ Just an ASCII digit.\n+        if (inRange('0', '9')) {\n+            \/\/ Fast common case.\n+            result = character - '0';\n+\n+            return result < digitRadix ? result : -1;\n+        }\n+\n+        \/\/ Handle other digits.\n+        result = isSurrogate() ? Character.digit(codepoint, digitRadix) :\n+                Character.digit(character, digitRadix);\n+\n+        if (result >= 0 && !isASCII()) {\n+            log.error(position(), Errors.IllegalNonasciiDigit);\n+            character = \"0123456789abcdef\".charAt(result);\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Returns the input buffer. Unicode escape sequences are not translated.\n+     *\n+     * @return the input buffer.\n+     *\/\n+    public char[] getRawCharacters() {\n+        return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);\n+    }\n+\n+    \/**\n+     * Returns a copy of a character array subset of the input buffer.\n+     * The returned array begins at the {@code beginIndex} and\n+     * extends to the character at index {@code endIndex - 1}.\n+     * Thus the length of the substring is {@code endIndex-beginIndex}.\n+     * This behavior is like\n+     * {@code String.substring(beginIndex, endIndex)}.\n+     * Unicode escape sequences are not translated.\n+     *\n+     * @param beginIndex the beginning index, inclusive.\n+     * @param endIndex   the ending index, exclusive.\n+     * @throws ArrayIndexOutOfBoundsException if either offset is outside of the\n+     *                                        array bounds\n+     *\/\n+    public char[] getRawCharacters(int beginIndex, int endIndex) {\n+        return Arrays.copyOfRange(buffer, beginIndex, endIndex);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/impl\/UnicodeReader.java","additions":564,"deletions":0,"binary":false,"changes":564,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for parsing code models.\n+ *\/\n+package java.lang.reflect.code.parser;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/parser\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+\n+\/**\n+ * An array type.\n+ *\/\n+public final class ArrayType implements JavaType {\n+    static final String NAME = \"[\";\n+\n+    final JavaType componentType;\n+\n+    ArrayType(JavaType componentType) {\n+        this.componentType = componentType;\n+    }\n+\n+    \/**\n+     * {@return the array type's component type}\n+     *\/\n+    public JavaType componentType() {\n+        return componentType;\n+    }\n+\n+    public int dimensions() {\n+        int dims = 0;\n+        JavaType current = this;\n+        while (current instanceof ArrayType at) {\n+            dims++;\n+            current = at.componentType();\n+        }\n+        return dims;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        int dims = 0;\n+        TypeElement current = this;\n+        while (current instanceof ArrayType at) {\n+            dims++;\n+            current = at.componentType();\n+        }\n+        return new TypeDefinition(\"[\".repeat(dims), List.of(current.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof ArrayType that &&\n+                componentType.equals(that.componentType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 17 * componentType.hashCode();\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        return JavaType.array(componentType.erasure());\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        return JavaType.J_L_OBJECT;\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return \"[\" + componentType.toNominalDescriptorString();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+\/**\n+ * A class type.\n+ *\/\n+public final class ClassType implements TypeVarRef.Owner, JavaType {\n+    \/\/ Fully qualified name\n+    private final String type;\n+\n+    private final List<JavaType> typeArguments;\n+\n+    ClassType(String type) {\n+        this(type, List.of());\n+    }\n+\n+    ClassType(String type, List<JavaType> typeArguments) {\n+        switch (type) {\n+            case \"boolean\", \"char\", \"byte\", \"short\", \"int\", \"long\",\n+                    \"float\", \"double\", \"void\" -> throw new IllegalArgumentException();\n+        }\n+        this.type = type;\n+        this.typeArguments = List.copyOf(typeArguments);\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        List<TypeDefinition> args = typeArguments.stream()\n+                .map(TypeElement::toTypeDefinition)\n+                .toList();\n+\n+        TypeDefinition td = new TypeDefinition(type, args);\n+        return td;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        ClassType typeDesc = (ClassType) o;\n+\n+        if (!type.equals(typeDesc.type)) return false;\n+        return typeArguments.equals(typeDesc.typeArguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = type.hashCode();\n+        result = 31 * result + typeArguments.hashCode();\n+        return result;\n+    }\n+\n+    \/**\n+     * {@return the unboxed primitive type associated with this class type (if any)}\n+     *\/\n+    public Optional<PrimitiveType> unbox() {\n+        class LazyHolder {\n+            static final Map<ClassType, PrimitiveType> wrapperToPrimitive = Map.of(\n+                    J_L_BYTE, BYTE,\n+                    J_L_SHORT, SHORT,\n+                    J_L_INTEGER, INT,\n+                    J_L_LONG, LONG,\n+                    J_L_FLOAT, FLOAT,\n+                    J_L_DOUBLE, DOUBLE,\n+                    J_L_CHARACTER, CHAR,\n+                    J_L_BOOLEAN, BOOLEAN\n+            );\n+        }\n+        return Optional.ofNullable(LazyHolder.wrapperToPrimitive.get(this));\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        return rawType();\n+    }\n+\n+    \/\/ Conversions\n+\n+    public ClassType rawType() {\n+        return new ClassType(type);\n+    }\n+\n+    public boolean hasTypeArguments() {\n+        return !typeArguments.isEmpty();\n+    }\n+\n+    public List<JavaType> typeArguments() {\n+        return typeArguments;\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        return JavaType.J_L_OBJECT;\n+    }\n+\n+    public String toClassName() {\n+        return type;\n+    }\n+\n+    public String toInternalName() {\n+        return toClassDescriptor(type);\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return toBytecodeDescriptor(type);\n+    }\n+\n+    static String toBytecodeDescriptor(String type) {\n+        if (type.equals(\"null\")) {\n+            type = Object.class.getName();\n+        }\n+\n+        return \"L\" + type.replace('.', '\/') + \";\";\n+    }\n+\n+    static String toClassDescriptor(String type) {\n+        return type.replace('.', '\/');\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public final class CoreTypeFactory {\n+\n+    private CoreTypeFactory() {\n+    }\n+\n+    \/\/ Code model type factory composed\n+\n+    \/**\n+     * Create a code model factory combining and composing the construction\n+     * of code model types with types constructed from the given type factory.\n+     *\n+     * @param f the type factory.\n+     * @return the code model factory.\n+     *\/\n+    public static TypeElementFactory codeModelTypeFactory(TypeElementFactory f) {\n+        class CodeModelFactory implements TypeElementFactory {\n+            final TypeElementFactory thisThenF = this.andThen(f);\n+\n+            @Override\n+            public TypeElement constructType(TypeDefinition tree) {\n+                return switch (tree.identifier()) {\n+                    case VarType.NAME -> {\n+                        if (tree.arguments().size() != 1) {\n+                            throw new IllegalArgumentException();\n+                        }\n+\n+                        TypeElement v = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (v == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        yield VarType.varType(v);\n+                    }\n+                    case TupleType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        List<TypeElement> cs = new ArrayList<>(tree.arguments().size());\n+                        for (TypeDefinition child : tree.arguments()) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            cs.add(c);\n+                        }\n+                        yield TupleType.tupleType(cs);\n+                    }\n+                    case FunctionType.NAME -> {\n+                        if (tree.arguments().isEmpty()) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+\n+                        TypeElement rt = thisThenF.constructType(tree.arguments().getFirst());\n+                        if (rt == null) {\n+                            throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                        }\n+                        List<TypeElement> pts = new ArrayList<>(tree.arguments().size() - 1);\n+                        for (TypeDefinition child : tree.arguments().subList(1, tree.arguments().size())) {\n+                            TypeElement c = thisThenF.constructType(child);\n+                            if (c == null) {\n+                                throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                            }\n+                            pts.add(c);\n+                        }\n+                        yield FunctionType.functionType(rt, pts);\n+                    }\n+                    default -> null;\n+                };\n+            }\n+        }\n+        if (f instanceof CodeModelFactory) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new CodeModelFactory().thisThenF;\n+    }\n+\n+    \/\/ Java type factory\n+\n+    \/**\n+     * The Java type factory.\n+     *\/\n+    public static final TypeElementFactory JAVA_TYPE_FACTORY = new TypeElementFactory() {\n+        @Override\n+        public TypeElement constructType(TypeDefinition tree) {\n+            String identifier = tree.identifier();\n+            int dimensions = 0;\n+            if (identifier.startsWith(\"[\")) {\n+                if (tree.arguments().size() != 1) {\n+                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                }\n+                for (int i = 1; i < identifier.length(); i++) {\n+                    if (identifier.charAt(i) != '[') {\n+                        throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                    }\n+                }\n+                dimensions = identifier.length();\n+                tree = tree.arguments().getFirst();\n+                identifier = tree.identifier();\n+            }\n+\n+            List<JavaType> typeArguments = new ArrayList<>(tree.arguments().size());\n+            for (TypeDefinition child : tree.arguments()) {\n+                TypeElement t = JAVA_TYPE_FACTORY.constructType(child);\n+                if (!(t instanceof JavaType a)) {\n+                    throw new IllegalArgumentException(\"Bad type: \" + tree);\n+                }\n+                typeArguments.add(a);\n+            }\n+            if (identifier.equals(\"+\") || identifier.equals(\"-\")) {\n+                \/\/ wildcard type\n+                BoundKind kind = identifier.equals(\"+\") ?\n+                        BoundKind.EXTENDS : BoundKind.SUPER;\n+                return JavaType.wildcard(kind, typeArguments.get(0));\n+            } else if (identifier.startsWith(\"#\")) {\n+                \/\/ type-var\n+                if (typeArguments.size() != 1) {\n+                    throw new IllegalArgumentException(\"Bad type-variable bounds: \" + tree);\n+                }\n+                String[] parts = identifier.substring(1).split(\"::\");\n+                if (parts.length == 2) {\n+                    \/\/ class type-var\n+                    return JavaType.typeVarRef(parts[1],\n+                            (ClassType)constructType(parseTypeDef(parts[0])),\n+                            typeArguments.get(0));\n+                } else {\n+                    \/\/ method type-var\n+                    return JavaType.typeVarRef(parts[2],\n+                            parseMethodRef(String.format(\"%s::%s\", parts[0], parts[1])),\n+                            typeArguments.get(0));\n+                }\n+            }\n+            JavaType t = switch (identifier) {\n+                case \"boolean\" -> JavaType.BOOLEAN;\n+                case \"byte\" -> JavaType.BYTE;\n+                case \"char\" -> JavaType.CHAR;\n+                case \"short\" -> JavaType.SHORT;\n+                case \"int\" -> JavaType.INT;\n+                case \"long\" -> JavaType.LONG;\n+                case \"float\" -> JavaType.FLOAT;\n+                case \"double\" -> JavaType.DOUBLE;\n+                case \"void\" -> JavaType.VOID;\n+                default -> JavaType.ofNominalDescriptor(ClassDesc.of(identifier));\n+            };\n+            if (!typeArguments.isEmpty()) {\n+                t = JavaType.type(t, typeArguments);\n+            }\n+            return dimensions == 0 ?\n+                    t : JavaType.array(t, dimensions);\n+        }\n+    };\n+\n+\n+    \/**\n+     * The core type factory that can construct instance of {@link JavaType}\n+     * or code model types such as {@link VarType} or {@link TupleType} that\n+     * may contain instances of those types.\n+     *\/\n+    public static final TypeElementFactory CORE_TYPE_FACTORY = codeModelTypeFactory(JAVA_TYPE_FACTORY);\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodRef parseMethodRef(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(desc);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static TypeDefinition parseTypeDef(String desc) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(desc);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.type.impl.FieldRefImpl;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.code.TypeElement;\n+\n+\/**\n+ * The symbolic reference to a Java field.\n+ *\/\n+public sealed interface FieldRef permits FieldRefImpl {\n+    TypeElement refType();\n+\n+    String name();\n+\n+    TypeElement type();\n+\n+    \/\/ Conversions\n+\n+    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static FieldRef field(Field f) {\n+        return field(f.getDeclaringClass(), f.getName(), f.getType());\n+    }\n+\n+    static FieldRef field(Class<?> refType, String name, Class<?> type) {\n+        return field(JavaType.type(refType), name, JavaType.type(type));\n+    }\n+\n+    static FieldRef field(TypeElement refType, String name, TypeElement type) {\n+        return new FieldRefImpl(refType, name, type);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static FieldRef ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseFieldRef(s);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FieldRef.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A function type.\n+ *\/\n+public final class FunctionType implements TypeElement {\n+    \/\/ @@@ Change to \"->\" when the textual form supports it\n+    static final String NAME = \"func\";\n+\n+    \/**\n+     * The function type with no parameters, returning void.\n+     *\/\n+    \/\/ @@@ Uses JavaType\n+    public static final FunctionType VOID = functionType(JavaType.VOID);\n+\n+    final TypeElement returnType;\n+    final List<TypeElement> parameterTypes;\n+\n+    FunctionType(TypeElement returnType, List<? extends TypeElement> parameterTypes) {\n+        this.returnType = returnType;\n+        this.parameterTypes = List.copyOf(parameterTypes);\n+    }\n+\n+    \/**\n+     * {@return the function type's return type}\n+     *\/\n+    public TypeElement returnType() {\n+        return returnType;\n+    }\n+\n+    \/**\n+     * {@return the function type's parameter types}\n+     *\/\n+    public List<TypeElement> parameterTypes() {\n+        return parameterTypes;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME,\n+                Stream.concat(Stream.of(returnType), parameterTypes.stream())\n+                        .map(TypeElement::toTypeDefinition).toList());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof FunctionType that &&\n+                returnType.equals(that.returnType) &&\n+                parameterTypes.equals(that.parameterTypes);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = returnType.hashCode();\n+        result = 31 * result + parameterTypes.hashCode();\n+        return result;\n+    }\n+\n+    \/**\n+     * Constructs a function type.\n+     *\n+     * @param returnType the function type's return type.\n+     * @param parameterTypes the function type's parameter types.\n+     * @return a function type.\n+     *\/\n+    public static FunctionType functionType(TypeElement returnType, List<? extends TypeElement> parameterTypes) {\n+        Objects.requireNonNull(returnType);\n+        Objects.requireNonNull(parameterTypes);\n+        return new FunctionType(returnType, parameterTypes);\n+    }\n+    \/**\n+     * Constructs a function type.\n+     *\n+     * @param returnType the function type's return type.\n+     * @param parameterTypes the function type's parameter types.\n+     * @return a function type.\n+     *\/\n+    public static FunctionType functionType(TypeElement returnType, TypeElement... parameterTypes) {\n+        return functionType(returnType, List.of(parameterTypes));\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/FunctionType.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * The symbolic description of a Java type.\n+ *\/\n+public sealed interface JavaType extends TypeElement permits ClassType, ArrayType,\n+                                                             PrimitiveType, WildcardType, TypeVarRef {\n+\n+    \/\/ @@@ Share with general void type?\n+    PrimitiveType VOID = new PrimitiveType(\"void\");\n+\n+    PrimitiveType BOOLEAN = new PrimitiveType(\"boolean\");\n+\n+    ClassType J_L_BOOLEAN = new ClassType(\"java.lang.Boolean\");\n+\n+    ArrayType BOOLEAN_ARRAY = new ArrayType(BOOLEAN);\n+\n+    PrimitiveType BYTE = new PrimitiveType(\"byte\");\n+\n+    ClassType J_L_BYTE = new ClassType(\"java.lang.Byte\");\n+\n+    ArrayType BYTE_ARRAY = new ArrayType(BYTE);\n+\n+    PrimitiveType CHAR = new PrimitiveType(\"char\");\n+\n+    ClassType J_L_CHARACTER = new ClassType(\"java.lang.Character\");\n+\n+    ArrayType CHAR_ARRAY = new ArrayType(CHAR);\n+\n+    PrimitiveType SHORT = new PrimitiveType(\"short\");\n+\n+    ClassType J_L_SHORT = new ClassType(\"java.lang.Short\");\n+\n+    ArrayType SHORT_ARRAY = new ArrayType(SHORT);\n+\n+    PrimitiveType INT = new PrimitiveType(\"int\");\n+\n+    ClassType J_L_INTEGER = new ClassType(\"java.lang.Integer\");\n+\n+    ArrayType INT_ARRAY = new ArrayType(INT);\n+\n+    PrimitiveType LONG = new PrimitiveType(\"long\");\n+\n+    ClassType J_L_LONG = new ClassType(\"java.lang.Long\");\n+\n+    ArrayType LONG_ARRAY = new ArrayType(LONG);\n+\n+    PrimitiveType FLOAT = new PrimitiveType(\"float\");\n+\n+    ClassType J_L_FLOAT = new ClassType(\"java.lang.Float\");\n+\n+    ArrayType FLOAT_ARRAY = new ArrayType(FLOAT);\n+\n+    PrimitiveType DOUBLE = new PrimitiveType(\"double\");\n+\n+    ClassType J_L_DOUBLE = new ClassType(\"java.lang.Double\");\n+\n+    ArrayType DOUBLE_ARRAY = new ArrayType(DOUBLE);\n+\n+    ClassType J_L_OBJECT = new ClassType(\"java.lang.Object\");\n+\n+    ArrayType J_L_OBJECT_ARRAY = new ArrayType(J_L_OBJECT);\n+\n+    ClassType J_L_CLASS = new ClassType(\"java.lang.Class\");\n+\n+    ClassType J_L_STRING = new ClassType(\"java.lang.String\");\n+\n+    ClassType J_L_STRING_TEMPLATE = new ClassType(\"java.lang.StringTemplate\");\n+\n+    ClassType J_L_STRING_TEMPLATE_PROCESSOR = new ClassType(\"java.lang.StringTemplate$Processor\");\n+\n+    ClassType J_U_LIST = new ClassType(\"java.util.List\");\n+\n+    \/\/ Conversions\n+\n+    JavaType toBasicType();\n+\n+\n+    String toNominalDescriptorString();\n+\n+    default ClassDesc toNominalDescriptor() {\n+        return ClassDesc.ofDescriptor(toNominalDescriptorString());\n+    }\n+\n+    default Class<?> resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        return (Class<?>) toNominalDescriptor().resolveConstantDesc(l);\n+    }\n+\n+    \/**\n+     * {@return the erasure of this Java type, as per JLS 4.6}\n+     *\/\n+    JavaType erasure();\n+\n+    \/\/ Factories\n+\n+    static JavaType type(Class<?> c) {\n+        if (c.isPrimitive()) {\n+            return new PrimitiveType(c.getName());\n+        } else if (c.isArray()) {\n+            return array(type(c.getComponentType()));\n+        } else {\n+            return new ClassType(c.getName());\n+        }\n+    }\n+\n+    static JavaType type(Class<?> c, Class<?>... typeArguments) {\n+        return type(c, List.of(typeArguments));\n+    }\n+\n+    static JavaType type(Class<?> c, List<Class<?>> typeArguments) {\n+        if (c.isPrimitive()) {\n+            throw new IllegalArgumentException(\"Cannot parameterize a primitive type\");\n+        } else if (c.isArray()) {\n+            return array(type(c.getComponentType(), typeArguments));\n+        } else {\n+            return new ClassType(c.getName(),\n+                    typeArguments.stream().map(JavaType::type).toList());\n+        }\n+    }\n+\n+    static JavaType ofNominalDescriptor(ClassDesc d) {\n+        return ofNominalDescriptorStringInternal(d.descriptorString(), 0);\n+    }\n+\n+    static JavaType ofNominalDescriptorString(String d) {\n+        return ofNominalDescriptor(ClassDesc.ofDescriptor(d));\n+    }\n+\n+    private static JavaType ofNominalDescriptorStringInternal(String descriptor, int i) {\n+        if (descriptor.charAt(i) == '[') {\n+            return new ArrayType(ofNominalDescriptorStringInternal(descriptor, i + 1));\n+        } else {\n+            return switch (descriptor.charAt(i)) {\n+                case 'V' -> JavaType.VOID;\n+                case 'I' -> JavaType.INT;\n+                case 'J' -> JavaType.LONG;\n+                case 'C' -> JavaType.CHAR;\n+                case 'S' -> JavaType.SHORT;\n+                case 'B' -> JavaType.BYTE;\n+                case 'F' -> JavaType.FLOAT;\n+                case 'D' -> JavaType.DOUBLE;\n+                case 'Z' -> JavaType.BOOLEAN;\n+                case 'L' -> {\n+                    \/\/ La.b.c.Class;\n+                    String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n+                    yield new ClassType(typeName);\n+                }\n+                default -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n+    static JavaType type(JavaType t, JavaType... typeArguments) {\n+        return type(t, List.of(typeArguments));\n+    }\n+\n+    static JavaType type(JavaType t, List<JavaType> typeArguments) {\n+        return switch (t) {\n+            case ArrayType at -> array(type(at.componentType(), typeArguments));\n+            case ClassType ct when !ct.hasTypeArguments() -> new ClassType(ct.toClassName(), typeArguments);\n+            default -> throw new IllegalArgumentException(\"Cannot parameterize type: \" + t);\n+        };\n+    }\n+\n+    \/**\n+     * Constructs an array type.\n+     *\n+     * @param elementType the array type's element type.\n+     * @return an array type.\n+     *\/\n+    static ArrayType array(JavaType elementType) {\n+        Objects.requireNonNull(elementType);\n+        return new ArrayType(elementType);\n+    }\n+\n+    \/**\n+     * Constructs an array type.\n+     *\n+     * @param elementType the array type's element type.\n+     * @param dims the array type dimension\n+     * @return an array type.\n+     * @throws IllegalArgumentException if {@code dims < 1}.\n+     *\/\n+    static ArrayType array(JavaType elementType, int dims) {\n+        Objects.requireNonNull(elementType);\n+        if (dims < 1) {\n+            throw new IllegalArgumentException(\"Invalid dimension: \" + dims);\n+        }\n+        for (int i = 1 ; i < dims ; i++) {\n+            elementType = array(elementType);\n+        }\n+        return array(elementType);\n+    }\n+\n+    \/**\n+     * Constructs an unbounded wildcard type.\n+     *\n+     * @return an unbounded wildcard type.\n+     *\/\n+    static WildcardType wildcard() {\n+        return new WildcardType(BoundKind.EXTENDS, JavaType.J_L_OBJECT);\n+    }\n+\n+    \/**\n+     * Constructs a bounded wildcard type of the given kind.\n+     *\n+     * @return a bounded wildcard type.\n+     *\/\n+    static WildcardType wildcard(BoundKind kind, JavaType bound) {\n+        return new WildcardType(kind, bound);\n+    }\n+\n+    \/**\n+     * Constructs a reference to a type-variable with the given owner.\n+     *\n+     * @param bound the type-variable bound.\n+     * @param owner the type-variable owner.\n+     * @return a type-variable reference.\n+     *\/\n+    static TypeVarRef typeVarRef(String name, TypeVarRef.Owner owner, JavaType bound) {\n+        return new TypeVarRef(name, owner, bound);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static JavaType ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return (JavaType) CoreTypeFactory.JAVA_TYPE_FACTORY.constructType(java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(s));\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.impl.MethodRefImpl;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+\n+\/**\n+ * The symbolic reference to a Java method.\n+ *\/\n+\/\/ @@@ require invoke kind:\n+\/\/    special, static, virtual\n+\/\/    interface_special, interface_static, interface_virtual\n+\/\/  Otherwise it is not possible to generate correct bytecode invoke instruction with\n+\/\/  a symbolic reference to a method or an interface method, specifically a\n+\/\/  constant pool entry of CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info.\n+\/\/\n+\/\/  We can infer the kind, if we can resolve the types and lookup the declared method\n+public sealed interface MethodRef extends TypeVarRef.Owner permits MethodRefImpl {\n+\n+    TypeElement refType();\n+\n+    String name();\n+\n+    FunctionType type();\n+\n+    \/\/ Resolutions and model access\n+\n+    Executable resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    Optional<CoreOps.FuncOp> codeModel(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+\n+    \/\/ Factories\n+\n+    static MethodRef method(Method m) {\n+        return method(m.getDeclaringClass(), m.getName(), m.getReturnType(), m.getParameterTypes());\n+    }\n+\n+    static MethodRef method(Class<?> refType, String name, MethodType mt) {\n+        return method(refType, name, mt.returnType(), mt.parameterList());\n+    }\n+\n+    static MethodRef method(Class<?> refType, String name, Class<?> retType, Class<?>... params) {\n+        return method(refType, name, retType, List.of(params));\n+    }\n+\n+    static MethodRef method(Class<?> refType, String name, Class<?> retType, List<Class<?>> params) {\n+        return method(JavaType.type(refType), name, JavaType.type(retType), params.stream().map(JavaType::type).toList());\n+    }\n+\n+\n+    static MethodRef method(TypeElement refType, String name, FunctionType type) {\n+        return new MethodRefImpl(refType, name, type);\n+    }\n+\n+    static MethodRef method(TypeElement refType, String name, TypeElement retType, TypeElement... params) {\n+        return method(refType, name, functionType(retType, params));\n+    }\n+\n+    static MethodRef method(TypeElement refType, String name, TypeElement retType, List<? extends TypeElement> params) {\n+        return method(refType, name, functionType(retType, params));\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static MethodRef ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseMethodRef(s);\n+    }\n+\n+\n+    \/\/ MethodTypeDesc factories\n+    \/\/ @@@ Where else to place them?\n+\n+    static FunctionType ofNominalDescriptor(MethodTypeDesc d) {\n+        return FunctionType.functionType(\n+                JavaType.ofNominalDescriptor(d.returnType()),\n+                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n+    }\n+\n+    static MethodTypeDesc toNominalDescriptor(FunctionType t) {\n+        return MethodTypeDesc.of(\n+                toClassDesc(t.returnType()),\n+                t.parameterTypes().stream().map(MethodRef::toClassDesc).toList());\n+    }\n+\n+    private static ClassDesc toClassDesc(TypeElement e) {\n+        if (!(e instanceof JavaType jt)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return jt.toNominalDescriptor();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/MethodRef.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+\/**\n+ * A primitive type.\n+ *\/\n+public final class PrimitiveType implements JavaType {\n+    \/\/ Fully qualified name\n+    private final String type;\n+\n+    PrimitiveType(String type) {\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(type, List.of());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        PrimitiveType typeDesc = (PrimitiveType) o;\n+\n+        return type.equals(typeDesc.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return type.hashCode();\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        return this;\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        return switch (bytecodeKind) {\n+            case 'V' -> JavaType.VOID;\n+            case 'J' -> JavaType.LONG;\n+            case 'F' -> JavaType.FLOAT;\n+            case 'D' -> JavaType.DOUBLE;\n+            default -> JavaType.INT;\n+        };\n+    }\n+\n+    \/**\n+     * {@return the boxed class type associated with this primitive type (if any)}\n+     *\/\n+    public Optional<ClassType> box() {\n+        class LazyHolder {\n+            static final Map<PrimitiveType, ClassType> primitiveToWrapper = Map.of(\n+                    BYTE, J_L_BYTE,\n+                    SHORT, J_L_SHORT,\n+                    INT, J_L_INTEGER,\n+                    LONG, J_L_LONG,\n+                    FLOAT, J_L_FLOAT,\n+                    DOUBLE, J_L_DOUBLE,\n+                    CHAR, J_L_CHARACTER,\n+                    BOOLEAN, J_L_BOOLEAN\n+            );\n+        }\n+        return Optional.ofNullable(LazyHolder.primitiveToWrapper.get(this));\n+    };\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        return toBytecodeDescriptor(type);\n+    }\n+\n+    static String toBytecodeDescriptor(String type) {\n+        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n+        return bytecodeKind.toString();\n+    }\n+\n+    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n+\n+    static {\n+        PRIMITIVE_TYPE_MAP = Map.of(\n+                \"boolean\", 'Z',\n+                \"byte\", 'B',\n+                \"short\", 'S',\n+                \"char\", 'C',\n+                \"int\", 'I',\n+                \"long\", 'J',\n+                \"float\", 'F',\n+                \"double\", 'D',\n+                \"void\", 'V'\n+        );\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.type.impl.RecordTypeRefImpl;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * The symbolic reference to a Java record type.\n+ *\/\n+public sealed interface RecordTypeRef permits RecordTypeRefImpl {\n+    TypeElement recordType();\n+\n+    \/**\n+     * The symbolic reference to a Java record component.\n+     * @param type the type of the component\n+     * @param name the name of the component\n+     *\/\n+    record ComponentRef(TypeElement type, String name) {}\n+\n+    List<ComponentRef> components();\n+\n+    MethodRef methodForComponent(int i);\n+\n+    \/\/ Factories\n+\n+    static RecordTypeRef recordType(Class<? extends Record> c) {\n+        List<ComponentRef> components = Stream.of(c.getRecordComponents())\n+                .map(rc -> new ComponentRef(JavaType.type(rc.getType()), rc.getName()))\n+                .toList();\n+        return recordType(JavaType.type(c), components);\n+    }\n+\n+    static RecordTypeRef recordType(TypeElement recordType, ComponentRef... components) {\n+        return recordType(recordType, List.of(components));\n+    }\n+\n+    static RecordTypeRef recordType(TypeElement recordType, List<ComponentRef> components) {\n+        return new RecordTypeRefImpl(recordType, components);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    static RecordTypeRef ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseRecordTypeRef(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/RecordTypeRef.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.Value;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A tuple type.\n+ *\/\n+public final class TupleType implements TypeElement {\n+    static final String NAME = \"Tuple\";\n+\n+    final List<TypeElement> componentTypes;\n+\n+    TupleType(List<? extends TypeElement> componentTypes) {\n+        this.componentTypes = List.copyOf(componentTypes);\n+    }\n+\n+    \/**\n+     * {@return the tuple's component types, in order}\n+     *\/\n+    public List<TypeElement> componentTypes() {\n+        return componentTypes;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, componentTypes.stream().map(TypeElement::toTypeDefinition).toList());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof TupleType that && componentTypes.equals(that.componentTypes);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return componentTypes.hashCode();\n+    }\n+\n+    \/**\n+     * Constructs a tuple type.\n+     *\n+     * @param componentTypes the tuple type's component types.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleType(List<? extends TypeElement> componentTypes) {\n+        Objects.requireNonNull(componentTypes);\n+        return new TupleType(componentTypes);\n+    }\n+\n+    \/**\n+     * Constructs a tuple type.\n+     *\n+     * @param componentTypes the tuple type's component types.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleType(TypeElement... componentTypes) {\n+        return tupleType(List.of(componentTypes));\n+    }\n+\n+    \/**\n+     * Constructs a tuple type whose components are the types of\n+     * the given values.\n+     *\n+     * @param values the values.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleTypeFromValues(List<? extends Value> values) {\n+        return tupleType(values.stream().map(Value::type).toList());\n+    }\n+\n+    \/**\n+     * Constructs a tuple type whose components are the types of\n+     * the given values.\n+     *\n+     * @param values the values.\n+     * @return a tuple type.\n+     *\/\n+    public static TupleType tupleTypeFromValues(Value... values) {\n+        return tupleType(Stream.of(values).map(Value::type).toList());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TupleType.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A type in general symbolic structured form.\n+ * <p>\n+ * A type definition can be converted to an instance of a type, a {@link TypeElement type element}, using\n+ * a {@link TypeElementFactory}.\n+ *\/\n+public record TypeDefinition(String identifier, List<TypeDefinition> arguments) {\n+\n+    public static final TypeDefinition VOID = new TypeDefinition(\"void\", List.of());\n+\n+    public TypeDefinition {\n+        arguments = List.copyOf(arguments);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toString(this);\n+    }\n+\n+    static String toString(TypeDefinition t) {\n+        if (t.arguments.isEmpty()) {\n+            return t.identifier;\n+        }\n+\n+        \/\/ Unpack array-like identifier [+\n+        int dimensions = 0;\n+        if (t.arguments.size() == 1) {\n+            dimensions = dimensions(t.identifier);\n+            if (dimensions > 0) {\n+                t = t.arguments.getFirst();\n+            }\n+        }\n+\n+        StringBuilder s = new StringBuilder();\n+        s.append(t.identifier);\n+        if (!t.arguments.isEmpty()) {\n+            String args = t.arguments.stream()\n+                    .map(Object::toString)\n+                    .collect(Collectors.joining(\", \", \"<\", \">\"));\n+            s.append(args);\n+        }\n+\n+        \/\/ Write out array-like syntax at end []+\n+        if (dimensions > 0) {\n+            s.append(\"[]\".repeat(dimensions));\n+        }\n+\n+        return s.toString();\n+    }\n+\n+    static int dimensions(String identifier) {\n+        if (!identifier.isEmpty() && identifier.charAt(0) == '[') {\n+            for (int i = 1; i < identifier.length(); i++) {\n+                if (identifier.charAt(i) != '[') {\n+                    return 0;\n+                }\n+            }\n+            return identifier.length();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    \/\/ Factories\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    public static TypeDefinition ofString(String s) {\n+\/*__throw new UnsupportedOperationException();__*\/        return java.lang.reflect.code.parser.impl.DescParser.parseTypeDefinition(s);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeDefinition.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@FunctionalInterface\n+public interface TypeElementFactory {\n+\/\/    record TypeTree(String name, List<TypeTree> children) {}\n+\n+    \/\/ Use TypeDefinition as temporary intermediate type representation\n+    TypeElement constructType(TypeDefinition tree);\n+\n+    default TypeElementFactory andThen(TypeElementFactory after) {\n+        return t -> {\n+            TypeElement te = constructType(t);\n+            return te != null ? te : after.constructType(t);\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeElementFactory.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+\/**\n+ * A type-variable reference.\n+ *\/\n+public final class TypeVarRef implements JavaType {\n+\n+    final String name;\n+    final Owner owner;\n+    final JavaType bound;\n+\n+    TypeVarRef(String name, Owner owner, JavaType bound) {\n+        this.name = name;\n+        this.owner = owner;\n+        this.bound = bound;\n+    }\n+\n+    \/**\n+     * {@return the type-variable name}\n+     *\/\n+    public String name() {\n+        return name;\n+    }\n+\n+    \/**\n+     * {@return the type-variable bound}\n+     *\/\n+    public JavaType bound() {\n+        return bound;\n+    }\n+\n+    \/**\n+     * {@return the owner of this type-variable}\n+     *\/\n+    public Owner owner() {\n+        return owner;\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        return bound.erasure();\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(String.format(\"#%s::%s\", owner, name),\n+                List.of(bound.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof TypeVarRef that &&\n+                name.equals(that.name) &&\n+                bound.equals(that.bound);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return name.hashCode();\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        throw new UnsupportedOperationException(\"Type var\");\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        throw new UnsupportedOperationException(\"Type var\");\n+    }\n+\n+    \/**\n+     * The owner of a type-variable - either a class or a method.\n+     *\/\n+    public sealed interface Owner permits ClassType, MethodRef { }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+package java.lang.reflect.code.type;\n+\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * A variable type.\n+ *\/\n+public final class VarType implements TypeElement {\n+    static final String NAME = \"Var\";\n+\n+    final TypeElement variableType;\n+\n+    VarType(TypeElement variableType) {\n+        this.variableType = variableType;\n+    }\n+\n+    \/**\n+     * {@return the variable type's value type}\n+     *\/\n+    public TypeElement valueType() {\n+        return variableType;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        return new TypeDefinition(NAME, List.of(variableType.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof VarType that &&\n+                variableType.equals(that.variableType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return variableType.hashCode();\n+    }\n+\n+    \/**\n+     * Constructs a variable type.\n+     *\n+     * @param valueType the variable's value type.\n+     * @return a variable type.\n+     *\/\n+    public static VarType varType(TypeElement valueType) {\n+        Objects.requireNonNull(valueType);\n+        return new VarType(valueType);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/VarType.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * A wildcard type.\n+ *\/\n+public final class WildcardType implements JavaType {\n+\n+    final BoundKind kind;\n+    final JavaType boundType;\n+\n+    WildcardType(BoundKind kind, JavaType boundType) {\n+        this.kind = kind;\n+        this.boundType = boundType;\n+    }\n+\n+    \/**\n+     * {@return the wildcard type's bound type}\n+     *\/\n+    public JavaType boundType() {\n+        return boundType;\n+    }\n+\n+    \/**\n+     * {@return the wildcard type's bound kind}\n+     *\/\n+    public BoundKind boundKind() {\n+        return kind;\n+    }\n+\n+    @Override\n+    public TypeDefinition toTypeDefinition() {\n+        String prefix = kind == BoundKind.EXTENDS ? \"+\" : \"-\";\n+        return new TypeDefinition(prefix, List.of(boundType.toTypeDefinition()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return toTypeDefinition().toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof WildcardType that &&\n+                kind.equals(that.kind) &&\n+                boundType.equals(that.boundType);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(boundType, kind);\n+    }\n+\n+    @Override\n+    public JavaType erasure() {\n+        throw new UnsupportedOperationException(\"Wildcard type\");\n+    }\n+\n+    @Override\n+    public JavaType toBasicType() {\n+        throw new UnsupportedOperationException(\"Wildcard type\");\n+    }\n+\n+    @Override\n+    public String toNominalDescriptorString() {\n+        throw new UnsupportedOperationException(\"Wildcard type\");\n+    }\n+\n+    public enum BoundKind {\n+        EXTENDS,\n+        SUPER\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/WildcardType.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type.impl;\n+\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+\n+public final class FieldRefImpl implements FieldRef {\n+    final TypeElement refType;\n+    final String name;\n+    final TypeElement type;\n+\n+    public FieldRefImpl(TypeElement refType, String name, TypeElement type) {\n+        this.refType = refType;\n+        this.name = name;\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TypeElement refType() {\n+        return refType;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public TypeElement type() {\n+        return type;\n+    }\n+\n+    @Override\n+    public Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        Class<?> refC = resolve(l, refType);\n+        Class<?> typeC = resolve(l, type);\n+\n+        Field f = refC.getDeclaredField(name);\n+        if (!f.getType().equals(typeC)) {\n+            throw new NoSuchFieldException();\n+        }\n+\n+        return f;\n+    }\n+\n+    @Override\n+    public VarHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        Class<?> refC = resolve(l, refType);\n+        Class<?> typeC = resolve(l, type);\n+\n+        VarHandle vh = null;\n+        ReflectiveOperationException c = null;\n+\n+        try {\n+            vh = l.findStaticVarHandle(refC, name, typeC);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            c = e;\n+        }\n+\n+        if (c != null) {\n+            c = null;\n+            try {\n+                vh = l.findVarHandle(refC, name, typeC);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                c = e;\n+            }\n+        }\n+\n+        if (c != null) {\n+            throw c;\n+        }\n+\n+        assert vh != null;\n+        return vh;\n+    }\n+\n+    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (t instanceof JavaType jt) {\n+            return jt.resolve(l);\n+        } else {\n+            \/\/ @@@\n+            throw new ReflectiveOperationException();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return refType + \"::\" + name + \"()\" + type;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        FieldRefImpl fieldDesc = (FieldRefImpl) o;\n+\n+        if (!refType.equals(fieldDesc.refType)) return false;\n+        if (!name.equals(fieldDesc.name)) return false;\n+        return type.equals(fieldDesc.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = refType.hashCode();\n+        result = 31 * result + name.hashCode();\n+        result = 31 * result + type.hashCode();\n+        return result;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/FieldRefImpl.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type.impl;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleInfo;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.Optional;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public final class MethodRefImpl implements MethodRef {\n+    final TypeElement refType;\n+    final String name;\n+    final FunctionType type;\n+\n+    public MethodRefImpl(TypeElement refType, String name, FunctionType type) {\n+        this.refType = refType;\n+        this.name = name;\n+        this.type = type;\n+    }\n+\n+    @Override\n+    public TypeElement refType() {\n+        return refType;\n+    }\n+\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public FunctionType type() {\n+        return type;\n+    }\n+\n+    @Override\n+    public Method resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        \/\/ @@@ Constructor\n+        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l));\n+        return methodHandleInfo.reflectAs(Method.class, l);\n+    }\n+\n+    @Override\n+    public MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        \/\/ @@@ kind\n+        Class<?> refC = resolve(l, refType);\n+\n+        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n+\n+        MethodHandle mh = null;\n+        ReflectiveOperationException c = null;\n+\n+        try {\n+            mh = l.findStatic(refC, name, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            c = e;\n+        }\n+\n+        if (c != null) {\n+            c = null;\n+            try {\n+                mh = l.findVirtual(refC, name, mt);\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                c = e;\n+            }\n+        }\n+\n+        if (c != null) {\n+            throw c;\n+        }\n+\n+        assert mh != null;\n+        return mh;\n+    }\n+\n+    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (t instanceof JavaType jt) {\n+            return jt.resolve(l);\n+        } else {\n+            \/\/ @@@\n+            throw new ReflectiveOperationException();\n+        }\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    @Override\n+    public Optional<CoreOps.FuncOp> codeModel(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+\/*__throw new UnsupportedOperationException();__*\/        return resolveToMember(l).getCodeModel();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return refType + \"::\" + name +\n+            type.parameterTypes().stream().map(TypeElement::toString)\n+                    .collect(joining(\", \", \"(\", \")\")) + type.returnType();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        MethodRefImpl that = (MethodRefImpl) o;\n+\n+        if (!refType.equals(that.refType)) return false;\n+        if (!name.equals(that.name)) return false;\n+        return type.equals(that.type);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = refType.hashCode();\n+        result = 31 * result + name.hashCode();\n+        result = 31 * result + type.hashCode();\n+        return result;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.type.impl;\n+\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.List;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public final class RecordTypeRefImpl implements RecordTypeRef {\n+    final TypeElement recordType;\n+    final List<ComponentRef> components;\n+\n+    public RecordTypeRefImpl(TypeElement recordType, List<ComponentRef> components) {\n+        this.recordType = recordType;\n+        this.components = List.copyOf(components);\n+    }\n+\n+    @Override\n+    public TypeElement recordType() {\n+        return recordType;\n+    }\n+\n+    @Override\n+    public List<ComponentRef> components() {\n+        return components;\n+    }\n+\n+    @Override\n+    public MethodRef methodForComponent(int i) {\n+        if (i < 0 || i >= components.size()) {\n+            throw new IndexOutOfBoundsException();\n+        }\n+\n+        ComponentRef c = components.get(i);\n+        return MethodRef.method(recordType, c.name(), c.type());\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return components.stream()\n+                .map(c -> c.type().toString() + \" \" + c.name())\n+                .collect(joining(\", \", \"(\", \")\")) +\n+                recordType.toString();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/RecordTypeRefImpl.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Types and symbolic references for code models.\n+ *\/\n+package java.lang.reflect.code.type;\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.writer;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.OpDefinition;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.*;\n+import java.util.*;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.*;\n+\n+\/**\n+ * A transformer of code models to models that build them.\n+ * <p>\n+ * A building code model when executed will construct the same code model it was transformed from.\n+ * Such a building code model could be transformed to bytecode and stored in class files.\n+ *\/\n+public class OpBuilder {\n+\n+    static final JavaType J_C_O_OP_DEFINITION = type(OpDefinition.class);\n+\n+    static final MethodRef OP_FACTORY_CONSTRUCT = MethodRef.method(OpFactory.class, \"constructOp\",\n+            Op.class, OpDefinition.class);\n+\n+    static final MethodRef TYPE_ELEMENT_FACTORY_CONSTRUCT = MethodRef.method(TypeElementFactory.class, \"constructType\",\n+            TypeElement.class, TypeDefinition.class);\n+\n+    static final MethodRef TYPE_DEFINITION_OF_STRING = MethodRef.method(TypeDefinition.class, \"ofString\",\n+            TypeDefinition.class, String.class);\n+\n+    static final MethodRef BODY_BUILDER_OF = MethodRef.method(Body.Builder.class, \"of\",\n+            Body.Builder.class, Body.Builder.class, FunctionType.class);\n+\n+    static final MethodRef BODY_BUILDER_ENTRY_BLOCK = MethodRef.method(Body.Builder.class, \"entryBlock\",\n+            Block.Builder.class);\n+\n+    static final MethodRef BLOCK_BUILDER_SUCCESSOR = MethodRef.method(Block.Builder.class, \"successor\",\n+            Block.Reference.class, Value[].class);\n+\n+    static final MethodRef BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+            Op.Result.class, Op.class);\n+\n+    static final MethodRef BLOCK_BUILDER_BLOCK = MethodRef.method(Block.Builder.class, \"block\",\n+            Block.Builder.class, TypeElement[].class);\n+\n+    static final MethodRef BLOCK_BUILDER_PARAMETER = MethodRef.method(Block.Builder.class, \"parameter\",\n+            Block.Parameter.class, TypeElement.class);\n+\n+    static final MethodRef FUNCTION_TYPE_FUNCTION_TYPE = MethodRef.method(FunctionType.class, \"functionType\",\n+            FunctionType.class, TypeElement.class, TypeElement[].class);\n+\n+    static final MethodRef METHOD_REF_OF_STRING = MethodRef.method(MethodRef.class, \"ofString\",\n+            MethodRef.class, String.class);\n+\n+    static final MethodRef FIELD_REF_OF_STRING = MethodRef.method(FieldRef.class, \"ofString\",\n+            FieldRef.class, String.class);\n+\n+    static final MethodRef RECORD_TYPE_REF_OF_STRING = MethodRef.method(RecordTypeRef.class, \"ofString\",\n+            RecordTypeRef.class, String.class);\n+\n+\n+    static final JavaType J_U_LIST = type(List.class);\n+\n+    static final MethodRef LIST_OF_ARRAY = MethodRef.method(J_U_LIST, \"of\",\n+            J_U_LIST, array(J_L_OBJECT, 1));\n+\n+    static final JavaType J_U_MAP = type(Map.class);\n+\n+    static final JavaType J_U_HASH_MAP = type(HashMap.class);\n+\n+    static final JavaType J_U_MAP_ENTRY = type(Map.Entry.class);\n+\n+    static final MethodRef MAP_ENTRY = MethodRef.method(J_U_MAP, \"entry\",\n+            J_U_MAP, J_L_OBJECT, J_L_OBJECT);\n+\n+    static final MethodRef MAP_OF = MethodRef.method(J_U_MAP, \"of\",\n+            J_U_MAP);\n+\n+    static final MethodRef MAP_OF_ARRAY = MethodRef.method(J_U_MAP, \"of\",\n+            J_U_MAP, array(J_U_MAP_ENTRY, 1));\n+\n+    static final MethodRef MAP_PUT = MethodRef.method(J_U_MAP, \"put\",\n+            J_L_OBJECT, J_L_OBJECT, J_L_OBJECT);\n+\n+\n+    static final FunctionType OP_DEFINITION_F_TYPE = functionType(\n+            J_C_O_OP_DEFINITION,\n+            J_L_STRING,\n+            J_U_LIST,\n+            J_U_LIST,\n+            type(TypeElement.class),\n+            J_U_MAP,\n+            J_U_LIST);\n+\n+    static final FunctionType BUILDER_F_TYPE = functionType(type(Op.class),\n+            type(OpFactory.class),\n+            type(TypeElementFactory.class));\n+\n+\n+    Map<Value, Value> valueMap;\n+\n+    Map<Block, Value> blockMap;\n+\n+    Block.Builder builder;\n+\n+    Value opFactory;\n+\n+    Value typeElementFactory;\n+\n+    \/**\n+     * Transform the given code model to one that builds it.\n+     *\n+     * @param op the code model\n+     * @return the building code model.\n+     *\/\n+    public static FuncOp createBuilderFunction(Op op) {\n+        return new OpBuilder().build(op);\n+    }\n+\n+    OpBuilder() {\n+        this.valueMap = new HashMap<>();\n+        this.blockMap = new HashMap<>();\n+    }\n+\n+    FuncOp build(Op op) {\n+        Body.Builder body = Body.Builder.of(null, BUILDER_F_TYPE);\n+\n+        builder = body.entryBlock();\n+        opFactory = builder.parameters().get(0);\n+        typeElementFactory = builder.parameters().get(1);\n+\n+        Value ancestorBody = builder.op(constant(type(Body.Builder.class), null));\n+        Value result = buildOp(ancestorBody, op);\n+        builder.op(_return(result));\n+\n+        return func(\"builder.\" + op.opName(), body);\n+    }\n+\n+\n+    Value buildOp(Value ancestorBody, Op inputOp) {\n+        List<Value> bodies = new ArrayList<>();\n+        for (Body inputBody : inputOp.bodies()) {\n+            Value body = buildBody(ancestorBody, inputBody);\n+            bodies.add(body);\n+        }\n+\n+        List<Value> operands = new ArrayList<>();\n+        for (Value inputOperand : inputOp.operands()) {\n+            Value operand = valueMap.get(inputOperand);\n+            operands.add(operand);\n+        }\n+\n+        List<Value> successors = new ArrayList<>();\n+        for (Block.Reference inputSuccessor : inputOp.successors()) {\n+            List<Value> successorArgs = new ArrayList<>();\n+            for (Value inputOperand : inputSuccessor.arguments()) {\n+                Value operand = valueMap.get(inputOperand);\n+                successorArgs.add(operand);\n+            }\n+            Value referencedBlock = blockMap.get(inputSuccessor.targetBlock());\n+\n+            List<Value> args = new ArrayList<>();\n+            args.add(referencedBlock);\n+            args.addAll(successorArgs);\n+            Value successor = builder.op(invoke(BLOCK_BUILDER_SUCCESSOR, args));\n+            successors.add(successor);\n+        }\n+\n+        Value opDef = buildOpDefinition(\n+                inputOp.opName(),\n+                operands,\n+                successors,\n+                inputOp.resultType(),\n+                inputOp.attributes(),\n+                bodies);\n+        return builder.op(invoke(OP_FACTORY_CONSTRUCT, opFactory, opDef));\n+    }\n+\n+\n+    Value buildOpDefinition(String name,\n+                            List<Value> operands,\n+                            List<Value> successors,\n+                            TypeElement resultType,\n+                            Map<String, Object> attributes,\n+                            List<Value> bodies) {\n+        List<Value> args = List.of(\n+                builder.op(constant(J_L_STRING, name)),\n+                buildList(type(Value.class), operands),\n+                buildList(type(Block.Reference.class), successors),\n+                buildType(resultType),\n+                buildAttributeMap(attributes),\n+                buildList(type(Body.Builder.class), bodies));\n+        return builder.op(_new(OP_DEFINITION_F_TYPE, args));\n+    }\n+\n+    Value buildBody(Value ancestorBodyValue, Body inputBody) {\n+        Value yieldType = buildType(inputBody.yieldType());\n+        Value bodyType = builder.op(invoke(FUNCTION_TYPE_FUNCTION_TYPE, yieldType));\n+        Value body = builder.op(invoke(BODY_BUILDER_OF, ancestorBodyValue, bodyType));\n+\n+        Value entryBlock = null;\n+        for (Block inputBlock : inputBody.blocks()) {\n+            Value block;\n+            if (inputBlock.isEntryBlock()) {\n+                block = entryBlock = builder.op(invoke(BODY_BUILDER_ENTRY_BLOCK, body));\n+            } else {\n+                assert entryBlock != null;\n+                block = builder.op(invoke(BLOCK_BUILDER_BLOCK, entryBlock));\n+            }\n+            blockMap.put(inputBlock, block);\n+\n+            for (Block.Parameter inputP : inputBlock.parameters()) {\n+                Value type = buildType(inputP.type());\n+                Value blockParameter = builder.op(invoke(BLOCK_BUILDER_PARAMETER, block, type));\n+                valueMap.put(inputP, blockParameter);\n+            }\n+        }\n+\n+        for (Block inputBlock : inputBody.blocks()) {\n+            Value block = blockMap.get(inputBlock);\n+            for (Op inputOp : inputBlock.ops()) {\n+                Value op = buildOp(body, inputOp);\n+                Value result = builder.op(invoke(BLOCK_BUILDER_OP, block, op));\n+                valueMap.put(inputOp.result(), result);\n+            }\n+        }\n+\n+        return body;\n+    }\n+\n+    Value buildType(TypeElement t) {\n+        Value typeString = builder.op(constant(J_L_STRING, t.toString()));\n+        Value typeDef = builder.op(invoke(TYPE_DEFINITION_OF_STRING, typeString));\n+        return builder.op(invoke(TYPE_ELEMENT_FACTORY_CONSTRUCT, typeElementFactory, typeDef));\n+    }\n+\n+    Value buildAttributeMap(Map<String, Object> attributes) {\n+        List<Value> keysAndValues = new ArrayList<>();\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            Value key = builder.op(constant(J_L_STRING, entry.getKey()));\n+            Value value = buildAttributeValue(entry.getValue());\n+            keysAndValues.add(key);\n+            keysAndValues.add(value);\n+        }\n+        return buildMap(J_L_STRING, J_L_OBJECT, keysAndValues);\n+    }\n+\n+    Value buildAttributeValue(Object value) {\n+        return switch (value) {\n+            case Boolean v -> {\n+                yield builder.op(constant(BOOLEAN, value));\n+            }\n+            case Byte v -> {\n+                yield builder.op(constant(BYTE, value));\n+            }\n+            case Short v -> {\n+                yield builder.op(constant(SHORT, value));\n+            }\n+            case Character v -> {\n+                yield builder.op(constant(CHAR, value));\n+            }\n+            case Integer v -> {\n+                yield builder.op(constant(INT, value));\n+            }\n+            case Long v -> {\n+                yield builder.op(constant(LONG, value));\n+            }\n+            case Float v -> {\n+                yield builder.op(constant(FLOAT, value));\n+            }\n+            case Double v -> {\n+                yield builder.op(constant(DOUBLE, value));\n+            }\n+            case Class<?> v -> {\n+                yield buildType(JavaType.type(v));\n+            }\n+            case String s -> {\n+                yield builder.op(constant(J_L_STRING, value));\n+            }\n+            case MethodRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(METHOD_REF_OF_STRING, string));\n+            }\n+            case FieldRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(FIELD_REF_OF_STRING, string));\n+            }\n+            case RecordTypeRef r -> {\n+                Value string = builder.op(constant(J_L_STRING, value.toString()));\n+                yield builder.op(invoke(RECORD_TYPE_REF_OF_STRING, string));\n+            }\n+            case TypeElement f -> {\n+                yield buildType(f);\n+            }\n+            case Location l -> {\n+                \/\/ @@@ Construct location explicitly\n+                yield builder.op(constant(J_L_STRING, l.toString()));\n+            }\n+            case Object o when value == Op.NULL_ATTRIBUTE_VALUE -> {\n+                yield builder.op(fieldLoad(FieldRef.field(Op.class, \"NULL_ATTRIBUTE_VALUE\", Object.class)));\n+            }\n+            default -> {\n+                \/\/ @@@ use the result of value.toString()?\n+                throw new UnsupportedOperationException(\"Unsupported attribute value: \" + value);\n+            }\n+        };\n+    }\n+\n+\n+    Value buildMap(JavaType keyType, JavaType valueType, List<Value> keysAndValues) {\n+        JavaType mapType = type(J_U_MAP, keyType, valueType);\n+        if (keysAndValues.isEmpty()) {\n+            return builder.op(invoke(MAP_OF));\n+        } else {\n+            Value map = builder.op(_new(mapType, functionType(J_U_HASH_MAP)));\n+            for (int i = 0; i < keysAndValues.size(); i += 2) {\n+                Value key = keysAndValues.get(i);\n+                Value value = keysAndValues.get(i + 1);\n+                builder.op(invoke(MAP_PUT, map, key, value));\n+            }\n+            return map;\n+        }\n+    }\n+\n+\n+    Value buildList(JavaType elementType, List<Value> elements) {\n+        JavaType listType = type(J_U_LIST, elementType);\n+        if (elements.size() < 11) {\n+            MethodRef listOf = MethodRef.method(J_U_LIST, \"of\",\n+                    J_U_LIST, Collections.nCopies(elements.size(), J_L_OBJECT));\n+            return builder.op(invoke(listType, listOf, elements));\n+        } else {\n+            Value array = buildArray(elementType, elements);\n+            return builder.op(invoke(listType, LIST_OF_ARRAY, array));\n+        }\n+    }\n+\n+\n+    Value buildArray(JavaType elementType, List<Value> elements) {\n+        Value array = builder.op(newArray(elementType,\n+                builder.op(constant(INT, elements.size()))));\n+        for (int i = 0; i < elements.size(); i++) {\n+            builder.op(arrayStoreOp(array, elements.get(i),\n+                    builder.op(constant(INT, i))));\n+        }\n+        return array;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -0,0 +1,497 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.writer;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.OpWithDefinition;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * A writer of code models to the textual form.\n+ * <p>\n+ * A code model in textual form may be parsed back into the runtime form by parsing it.\n+ *\/\n+\/\/ @@@ We cannot link to OpParser since this code is copied into the jdk.compiler module\n+public final class OpWriter {\n+\n+    static final class GlobalValueBlockNaming implements Function<CodeItem, String> {\n+        final Map<CodeItem, String> gn;\n+        int valueOrdinal = 0;\n+        int blockOrdinal = 0;\n+\n+        GlobalValueBlockNaming() {\n+            this.gn = new HashMap<>();\n+        }\n+\n+        @Override\n+        public String apply(CodeItem codeItem) {\n+            return switch (codeItem) {\n+                case Block block -> gn.computeIfAbsent(block, _b -> \"block_\" + blockOrdinal++);\n+                case Value value -> gn.computeIfAbsent(value, _v -> String.valueOf(valueOrdinal++));\n+                default -> throw new IllegalStateException(\"Unexpected code item: \" + codeItem);\n+            };\n+        }\n+    }\n+\n+    static final class AttributeMapper {\n+        static String toString(Object value) {\n+            return value == Op.NULL_ATTRIBUTE_VALUE\n+                    ? \"null\"\n+                    : \"\\\"\" + quote(value.toString()) + \"\\\"\";\n+        }\n+    }\n+\n+    \/\/ Copied from com.sun.tools.javac.util.Convert\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        return switch (ch) {\n+            case '\\b' -> \"\\\\b\";\n+            case '\\f' -> \"\\\\f\";\n+            case '\\n' -> \"\\\\n\";\n+            case '\\r' -> \"\\\\r\";\n+            case '\\t' -> \"\\\\t\";\n+            case '\\'' -> \"\\\\'\";\n+            case '\\\"' -> \"\\\\\\\"\";\n+            case '\\\\' -> \"\\\\\\\\\";\n+            default -> (isPrintableAscii(ch))\n+                    ? String.valueOf(ch)\n+                    : String.format(\"\\\\u%04x\", (int) ch);\n+        };\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+    static final class IndentWriter extends Writer {\n+        static final int INDENT = 2;\n+\n+        final Writer w;\n+        int indent;\n+        boolean writeIndent = true;\n+\n+        IndentWriter(Writer w) {\n+            this(w, 0);\n+        }\n+\n+        IndentWriter(Writer w, int indent) {\n+            this.w = w;\n+            this.indent = indent;\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) throws IOException {\n+            if (writeIndent) {\n+                w.write(\" \".repeat(indent));\n+                writeIndent = false;\n+            }\n+            w.write(cbuf, off, len);\n+            if (len > 0 && cbuf[off + len - 1] == '\\n') {\n+                writeIndent = true;\n+            }\n+        }\n+\n+        @Override\n+        public void flush() throws IOException {\n+            w.flush();\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            w.close();\n+        }\n+\n+        void in() {\n+            in(INDENT);\n+        }\n+\n+        void in(int i) {\n+            indent += i;\n+        }\n+\n+        void out() {\n+            out(INDENT);\n+        }\n+\n+        void out(int i) {\n+            indent -= i;\n+        }\n+    }\n+\n+    \/**\n+     * Computes global names for blocks and values in a code model.\n+     * <p>\n+     * The code model is traversed in the same order as if the model\n+     * was written. Therefore, the names in the returned map will the\n+     * same as the names that are written. This can be useful for debugging\n+     * and testing.\n+     *\n+     * @param root the code model\n+     * @return the map of computed names, modifiable\n+     *\/\n+    public static Map<CodeItem, String> computeGlobalNames(Op root) {\n+        GlobalValueBlockNaming gn = root.traverse(new GlobalValueBlockNaming(), (n, e) -> {\n+            switch (e) {\n+                case Op op -> {\n+                    for (Block.Reference r : op.successors()) {\n+                        n.apply(r.targetBlock());\n+                    }\n+\n+                    if (root != op) {\n+                        Op.Result opr = op.result();\n+                        if (!opr.type().equals(JavaType.VOID)) {\n+                            n.apply(opr);\n+                        }\n+                    }\n+                }\n+                case Block block -> {\n+                    if (!block.isEntryBlock()) {\n+                        n.apply(block);\n+                    }\n+                    for (Block.Parameter p : block.parameters()) {\n+                        n.apply(p);\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return n;\n+        });\n+\n+        return gn.gn;\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to the character stream.\n+     * <p>\n+     * A carriage return will be written after the model is writen, and\n+     * then character stream will be flushed.\n+     *\n+     * @param w the character stream\n+     * @param op the code model\n+     *\/\n+    public static void writeTo(Writer w, Op op) {\n+        OpWriter ow = new OpWriter(w);\n+        ow.writeOp(op);\n+        ow.write(\"\\n\");\n+        try {\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a code model (an operation) to the character stream.\n+     * <p>\n+     * A carriage return will be written after the model is writen, and\n+     * then character stream will be flushed.\n+     *\n+     * @param w the character stream\n+     * @param op the code model\n+     * @param options the writer options\n+     *\/\n+    public static void writeTo(Writer w, Op op, Option... options) {\n+        OpWriter ow = new OpWriter(w, options);\n+        ow.writeOp(op);\n+        ow.write(\"\\n\");\n+        try {\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/**\n+     * An option that affects the writing operations.\n+     *\/\n+    public sealed interface Option {\n+    }\n+\n+    \/**\n+     * An option describing the function to use for naming code items.\n+     *\/\n+    public sealed interface CodeItemNamerOption extends Option\n+            permits NamerOptionImpl {\n+\n+        static CodeItemNamerOption of(Function<CodeItem, String> named) {\n+            return new NamerOptionImpl(named);\n+        }\n+\n+        static CodeItemNamerOption defaultValue() {\n+            return of(new GlobalValueBlockNaming());\n+        }\n+\n+        Function<CodeItem, String> namer();\n+    }\n+    private record NamerOptionImpl(Function<CodeItem, String> namer) implements CodeItemNamerOption {\n+    }\n+\n+    \/**\n+     * An option describing whether location information should be written or dropped.\n+     *\/\n+    public enum LocationOption implements Option {\n+        \/** Writes location *\/\n+        WRITE_LOCATION,\n+        \/** Drops location *\/\n+        DROP_LOCATION;\n+\n+        public static LocationOption defaultValue() {\n+            return WRITE_LOCATION;\n+        }\n+    }\n+\n+    final Function<CodeItem, String> namer;\n+    final IndentWriter w;\n+    final boolean dropLocation;\n+\n+    \/**\n+     * Creates a writer of code models (operations) to their textual form.\n+     *\n+     * @param w the character stream writer to write the textual form.\n+     *\/\n+    public OpWriter(Writer w) {\n+        this.w = new IndentWriter(w);\n+        this.namer = new GlobalValueBlockNaming();\n+        this.dropLocation = false;\n+    }\n+\n+    \/**\n+     * Creates a writer of code models (operations) to their textual form.\n+     *\n+     * @param w the character stream writer to write the textual form.\n+     * @param options the writer options\n+     *\/\n+    public OpWriter(Writer w, Option... options) {\n+        Function<CodeItem, String> namer = null;\n+        boolean dropLocation = false;\n+        for (Option option : options) {\n+            switch (option) {\n+                case CodeItemNamerOption namerOption -> {\n+                    namer = namerOption.namer();\n+                }\n+                case LocationOption locationOption -> {\n+                    dropLocation = locationOption ==\n+                            LocationOption.DROP_LOCATION;\n+                }\n+            }\n+        }\n+\n+        this.w = new IndentWriter(w);\n+        this.namer = (namer == null) ? new GlobalValueBlockNaming() : namer;\n+        this.dropLocation = dropLocation;\n+    }\n+\n+    \/**\n+     * {@return the function that names blocks and values.}\n+     *\/\n+    public Function<CodeItem, String> namer() {\n+        return namer;\n+    }\n+\n+    \/**\n+     * Writes a code model, an operation, to the character stream.\n+     *\n+     * @param op the code model\n+     *\/\n+    public void writeOp(Op op) {\n+        write(op.opName());\n+\n+        if (!op.operands().isEmpty()) {\n+            write(\" \");\n+            writeSpaceSeparatedList(op.operands(), this::writeValueUse);\n+        }\n+\n+        if (!op.successors().isEmpty()) {\n+            write(\" \");\n+            writeSpaceSeparatedList(op.successors(), this::writeSuccessor);\n+        }\n+\n+        Map<String, Object> attributes = op.attributes();\n+        if (dropLocation && !attributes.isEmpty() &&\n+                attributes.containsKey(OpWithDefinition.ATTRIBUTE_LOCATION)) {\n+            attributes = new HashMap<>(attributes);\n+            attributes.remove(OpWithDefinition.ATTRIBUTE_LOCATION);\n+        }\n+        if (!attributes.isEmpty()) {\n+            write(\" \");\n+            writeSpaceSeparatedList(attributes.entrySet(), e -> writeAttribute(e.getKey(), e.getValue()));\n+        }\n+\n+        if (!op.bodies().isEmpty()) {\n+            int nBodies = op.bodies().size();\n+            if (nBodies == 1) {\n+                write(\" \");\n+            } else {\n+                write(\"\\n\");\n+                w.in();\n+                w.in();\n+            }\n+            boolean first = true;\n+            for (Body body : op.bodies()) {\n+                if (!first) {\n+                    write(\"\\n\");\n+                }\n+                writeBody(body);\n+                first = false;\n+            }\n+            if (nBodies > 1) {\n+                w.out();\n+                w.out();\n+            }\n+        }\n+\n+        write(\";\");\n+    }\n+\n+    void writeSuccessor(Block.Reference successor) {\n+        writeBlockName(successor.targetBlock());\n+        if (!successor.arguments().isEmpty()) {\n+            write(\"(\");\n+            writeCommaSeparatedList(successor.arguments(), this::writeValueUse);\n+            write(\")\");\n+        }\n+    }\n+\n+    void writeAttribute(String name, Object value) {\n+        write(\"@\");\n+        if (!name.isEmpty()) {\n+            write(name);\n+            write(\"=\");\n+        }\n+        write(AttributeMapper.toString(value));\n+    }\n+\n+    void writeBody(Body body) {\n+        Block eb = body.entryBlock();\n+        write(\"(\");\n+        writeCommaSeparatedList(eb.parameters(), this::writeValueDeclaration);\n+        write(\")\");\n+        writeType(body.bodyType().returnType());\n+        write(\" -> {\\n\");\n+        w.in();\n+        for (Block b : body.blocks()) {\n+            if (!b.isEntryBlock()) {\n+                write(\"\\n\");\n+            }\n+            writeBlock(b);\n+        }\n+        w.out();\n+        write(\"}\");\n+    }\n+\n+    void writeBlock(Block block) {\n+        if (!block.isEntryBlock()) {\n+            writeBlockName(block);\n+            if (!block.parameters().isEmpty()) {\n+                write(\"(\");\n+                writeCommaSeparatedList(block.parameters(), this::writeValueDeclaration);\n+                write(\")\");\n+            }\n+            write(\":\\n\");\n+        }\n+        w.in();\n+        for (Op op : block.ops()) {\n+            Op.Result opr = op.result();\n+            if (!opr.type().equals(JavaType.VOID)) {\n+                writeValueDeclaration(opr);\n+                write(\" = \");\n+            }\n+            writeOp(op);\n+            write(\"\\n\");\n+        }\n+        w.out();\n+    }\n+\n+    void writeBlockName(Block b) {\n+        write(\"^\");\n+        write(namer.apply(b));\n+    }\n+\n+    void writeValueUse(Value v) {\n+        write(\"%\");\n+        write(namer.apply(v));\n+    }\n+\n+    void writeValueDeclaration(Value v) {\n+        write(\"%\");\n+        write(namer.apply(v));\n+        write(\" : \");\n+        writeType(v.type());\n+    }\n+\n+    <T> void writeSpaceSeparatedList(Iterable<T> l, Consumer<T> c) {\n+        writeSeparatedList(\" \", l, c);\n+    }\n+\n+    <T> void writeCommaSeparatedList(Iterable<T> l, Consumer<T> c) {\n+        writeSeparatedList(\", \", l, c);\n+    }\n+\n+    <T> void writeSeparatedList(String separator, Iterable<T> l, Consumer<T> c) {\n+        boolean first = true;\n+        for (T t : l) {\n+            if (!first) {\n+                write(separator);\n+            }\n+            c.accept(t);\n+            first = false;\n+        }\n+    }\n+\n+    void writeType(TypeElement te) {\n+        write(te.toTypeDefinition().toString());\n+    }\n+\n+    void write(String s) {\n+        try {\n+            w.write(s);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpWriter.java","additions":497,"deletions":0,"binary":false,"changes":497,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Functionality for writing and storing code models.\n+ *\/\n+package java.lang.reflect.code.writer;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/package-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.annotation.*;\n+\n+\/**\n+ * Enables code reflection for a method annotated with this annotation.\n+ *\/\n+@Target({ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface CodeReflection {\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/CodeReflection.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,8 @@\n+    exports java.lang.reflect.code;\n+    exports java.lang.reflect.code.analysis;\n+    exports java.lang.reflect.code.bytecode;\n+    exports java.lang.reflect.code.interpreter;\n+    exports java.lang.reflect.code.op;\n+    exports java.lang.reflect.code.parser;\n+    exports java.lang.reflect.code.type;\n+    exports java.lang.reflect.code.writer;\n@@ -377,0 +385,1 @@\n+    exports java.lang.reflect.code.type.impl;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -971,0 +972,16 @@\n+\n+    \/**\n+     * Returns the code model of provided executable element (if any).\n+     * <p>\n+     * If the executable element has a code model then it will be an instance of\n+     * {@code java.lang.reflect.code.op.CoreOps.FuncOp}.\n+     * Note: due to circular dependencies we cannot refer to the type explicitly.\n+     *\n+     * @implSpec The default implementation unconditionally returns an empty optional.\n+     * @param e the executable element.\n+     * @return the code model of the provided executable element (if any).\n+     * @since 99\n+     *\/\n+    default Optional<Object> getBody(ExecutableElement e) {\n+        return Optional.empty();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,401 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.dot;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Value;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class DotGenerator {\n+\n+    final Writer w;\n+\n+    interface NodeProperty {\n+        String key();\n+\n+        String value();\n+\n+        default String toText() {\n+            return key() + \"=\" + value();\n+        }\n+    }\n+\n+    static NodeProperty property(String key, String value) {\n+        return new NodeProperty() {\n+            @Override\n+            public String key() {\n+                return key;\n+            }\n+\n+            @Override\n+            public String value() {\n+                return value;\n+            }\n+        };\n+    }\n+\n+    static String properties(List<? extends NodeProperty> properties) {\n+        return properties.stream().map(NodeProperty::toText).collect(Collectors.joining(\" \", \"[\", \"]\"));\n+    }\n+\n+    static NodeProperty label(String name) {\n+        return new NodeProperty() {\n+            @Override\n+            public String key() {\n+                return \"label\";\n+            }\n+\n+            @Override\n+            public String value() {\n+                return \"\\\"\" + name + \"\\\"\";\n+            }\n+        };\n+    }\n+\n+    enum Shape implements NodeProperty {\n+        BOX(\"box\"),\n+        ELLIPSE(\"ellipse\"),\n+        HEXAGONE(\"hexagon\"),\n+        INVERTED_TRAPEZIUM(\"invtrapezium\");\n+\n+        final String value;\n+\n+        Shape(String value) {\n+            this.value = value;\n+        }\n+\n+\n+        @Override\n+        public String key() {\n+            return \"shape\";\n+        }\n+\n+        @Override\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private DotGenerator(Writer w) {\n+        this.w = w;\n+    }\n+\n+    void digraph() {\n+        write(\"digraph G {\\n\");\n+    }\n+\n+    void node(Object o, String properties) {\n+        write(\"%s %s;\\n\", System.identityHashCode(o), properties);\n+    }\n+\n+    void node(Object o, NodeProperty... properties) {\n+        node(o, List.of(properties));\n+    }\n+\n+    void node(Object o, List<? extends NodeProperty> properties) {\n+        node(o, properties(properties));\n+    }\n+\n+    void edge(Object from, Object to) {\n+        write(\"%s -> %s;\\n\", System.identityHashCode(from), System.identityHashCode(to));\n+    }\n+\n+    void write(String format, Object... args) {\n+        write(w, format, args);\n+    }\n+\n+    void end() {\n+        write(w, \"}\\n\");\n+        try {\n+            w.flush();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    static void write(Writer w, String format, Object... args) {\n+        try {\n+            w.write(String.format(format, args));\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Generates the representation tree for a given operation.\n+     *\n+     * @param op the operation\n+     * @param w  the writer to write the sr.dot file\n+     *\/\n+    public static void representationTree(Op op, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        op.traverse(null, (t, codeElement) -> switch (codeElement) {\n+            case Body b -> {\n+                dg.node(b, label(\"\"), Shape.HEXAGONE, property(\"style\", \"filled\"));\n+\n+                dg.edge(b.parentOp(), b);\n+\n+                yield null;\n+            }\n+            case Block b -> {\n+                dg.node(b, label(\"\"), Shape.BOX);\n+\n+                dg.edge(b.parentBody(), b);\n+\n+                yield null;\n+            }\n+            case Op o -> {\n+                List<NodeProperty> ps;\n+                if (o instanceof Op.Terminating) {\n+                    ps = List.of(label(o.opName()), Shape.ELLIPSE, property(\"style\", \"filled\"));\n+                } else {\n+                    ps = List.of(label(o.opName()), Shape.ELLIPSE);\n+                }\n+                dg.node(o, ps);\n+                if (o.parentBlock() != null) {\n+                    dg.edge(o.parentBlock(), o);\n+                }\n+\n+                yield null;\n+            }\n+        });\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body graph (CFG) for a given body.\n+     *\n+     * @param body the body\n+     * @param w    the writer to write the sr.dot file\n+     *\/\n+    public static void bodyGraph(Body body, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        Block eb = body.entryBlock();\n+        Deque<Block> stack = new ArrayDeque<>();\n+        Set<Block> visited = new HashSet<>();\n+        stack.push(eb);\n+        while (!stack.isEmpty()) {\n+            Block b = stack.pop();\n+            if (!visited.add(b)) {\n+                continue;\n+            }\n+\n+            dg.node(b, label(\"\"), Shape.BOX);\n+\n+            List<Block.Reference> successors = b.terminatingOp().successors();\n+            for (Block.Reference s : successors) {\n+                dg.edge(b, s.targetBlock());\n+\n+                stack.push(s.targetBlock());\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body dominator tree for a given body.\n+     *\n+     * @param body the body\n+     * @param w    the writer to write the sr.dot file\n+     *\/\n+    public static void bodyDominatorTree(Body body, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        Block eb = body.entryBlock();\n+        Map<Block, Block> idoms = body.immediateDominators();\n+\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block child = e.getKey();\n+            Block parent = e.getValue();\n+\n+            dg.node(child, label(\"\"), Shape.BOX);\n+\n+            if (child != eb) {\n+                dg.edge(parent, child);\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body dominator tree for a given body, with the dominance\n+     * frontier set presented for each block.\n+     * <p>\n+     * The dominance frontier of a block, b say, is the set of blocks where the b's\n+     * dominance stops.\n+     *\n+     * @param body the body\n+     * @param w    the writer to write the sr.dot file\n+     *\/\n+    public static void bodyDominanceFrontierTree(Body body, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        Block eb = body.entryBlock();\n+        Map<Block, Block> idoms = body.immediateDominators();\n+        Map<Block, Set<Block>> df = body.dominanceFrontier();\n+\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block child = e.getKey();\n+            Block parent = e.getValue();\n+\n+            Set<Block> frontiers = df.get(child);\n+\n+            String s = frontiers == null || frontiers.isEmpty()\n+                    ? \"[-]\"\n+                    : frontiers.stream().map(b -> String.valueOf(b.index())).collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            dg.node(child, label(\"\" + \"\\n\" + s), Shape.BOX);\n+\n+            if (child != eb) {\n+                dg.edge(parent, child);\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    \/**\n+     * Generates a body data dependence dag for a given body.\n+     *\n+     * @param body  the body\n+     * @param names a map of block arguments to names\n+     * @param w     the writer to write the sr.dot file\n+     *\/\n+    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names, Writer w) {\n+        dataDependenceGraph(body, names, false, w);\n+    }\n+\n+    \/**\n+     * Generates a body data dependence graph for a given body.\n+     *\n+     * @param body              the body\n+     * @param names             a map of block arguments to names\n+     * @param traverseblockArgs true if a graph is produced, otherwise a DAG\n+     * @param w                 the writer to write the sr.dot file\n+     *\/\n+    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names,\n+                                           boolean traverseblockArgs, Writer w) {\n+        DotGenerator dg = new DotGenerator(w);\n+\n+        dg.digraph();\n+\n+        record Edge(Value from, Value to) {\n+        }\n+\n+        Set<Value> visted = new HashSet<>();\n+        Set<Edge> vistedEdges = new HashSet<>();\n+        Deque<Value> stack = new ArrayDeque<>(getValues(body));\n+        while (!stack.isEmpty()) {\n+            Value v = stack.pop();\n+            if (!visted.add(v)) {\n+                continue;\n+            }\n+\n+            if (v instanceof Op.Result or) {\n+                if (!or.op().operands().isEmpty() || !(or.op() instanceof Op.Terminating)) {\n+                    dg.node(v, label(or.op().opName()), Shape.INVERTED_TRAPEZIUM);\n+                }\n+            } else if (v instanceof Block.Parameter ba) {\n+                String n = names.get(v);\n+                if (n != null) {\n+                    dg.node(v, label(n), Shape.INVERTED_TRAPEZIUM,\n+                            property(\"style\", \"filled\"));\n+                } else {\n+                    Block b = ba.declaringBlock();\n+                    dg.node(v, label(\"(\" + b.parameters().indexOf(ba) + \")\"), Shape.BOX,\n+                            property(\"style\", \"filled\"));\n+                }\n+            }\n+\n+            Set<Op.Result> uses = v.uses();\n+            stack.addAll(uses);\n+            for (Op.Result use : uses) {\n+                if (traverseblockArgs && use.op() instanceof Op.Terminating) {\n+                    for (Block.Reference s : use.op().successors()) {\n+                        int i = s.arguments().indexOf(v);\n+                        if (i != -1) {\n+                            Block.Parameter ba = s.targetBlock().parameters().get(i);\n+\n+                            if (vistedEdges.add(new Edge(v, ba))) {\n+                                dg.edge(v, ba);\n+                            }\n+                            stack.add(ba);\n+                        }\n+                    }\n+                }\n+\n+                if (use.op().operands().contains(v)) {\n+                    if (vistedEdges.add(new Edge(v, use))) {\n+                        dg.edge(v, use);\n+                    }\n+                }\n+            }\n+        }\n+\n+        dg.end();\n+    }\n+\n+    static List<Value> getValues(Body r) {\n+        return r.traverse(new ArrayList<>(), (values, codeElement) -> switch (codeElement) {\n+            case Block b -> {\n+                values.addAll(b.parameters());\n+                yield values;\n+            }\n+            case Op o -> {\n+                values.add(o.result());\n+                yield values;\n+            }\n+            default -> values;\n+        });\n+    }\n+\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotGenerator.java","additions":401,"deletions":0,"binary":false,"changes":401,"status":"added"},{"patch":"@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.dot;\n+\n+import jdk.code.tools.renderer.CommonRenderer;\n+\n+import java.io.Writer;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.util.*;\n+\n+\/**\n+ * Created by gfrost\n+ * http:\/\/www.graphviz.org\/Documentation\/dotguide.pdf\n+ *\/\n+public class DotRenderer extends CommonRenderer<DotRenderer> {\n+    public DotRenderer() {\n+        super();\n+    }\n+\n+    static String sysident(Object o) {\n+        return Integer.toString(System.identityHashCode(o));\n+    }\n+\n+    DotRenderer end() {\n+        return out().cbrace().nl();\n+    }\n+\n+    public DotRenderer start(String name) {\n+        return append(\"digraph\").space().append(name).obrace().in().nl();\n+    }\n+\n+    public DotRenderer rankdir(String s) {\n+        return append(\"rankdir\").equal().append(s).semicolon().nl();\n+    }\n+\n+    public DotRenderer concentrate() {\n+        return append(\"concentrate=true\").nl();\n+    }\n+\n+    public DotRenderer newrank() {\n+        return append(\"newrank=true\").nl();\n+    }\n+\n+    public DotRenderer edgesFirst() {\n+        return append(\"outputorder=edgesfirst\").nl();\n+    }\n+\n+\n+    public <T extends CommonRenderer<T>> DotRenderer graph(NestedRendererSAM<GraphRenderer> nb) {\n+\n+        nb.build(new GraphRenderer(this)).end();\n+        return self();\n+    }\n+\n+\n+    public static class GraphRenderer extends CommonRenderer<GraphRenderer> {\n+        public GraphRenderer(DotRenderer dotRenderer) {\n+            super(dotRenderer);\n+        }\n+\n+        GraphRenderer end() {\n+            return self();\n+        }\n+\n+        public GraphRenderer node(String name, String shape, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, shape)).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer node(String name, String shape) {\n+            return node(name, shape, (n) -> n);\n+        }\n+\n+        public GraphRenderer record(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"record\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer record(String name) {\n+            return record(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer ellipse(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"ellipse\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer ellipse(String name) {\n+            return ellipse(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer ellipse(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"ellipse\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer ellipse(Object o) {\n+            return ellipse(o, (n) -> n);\n+        }\n+\n+        public GraphRenderer circle(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"circle\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer circle(String name) {\n+            return circle(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer invertedtrapezium(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"invtrapezium\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer invertedtrapezium(String name) {\n+            return invertedtrapezium(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer invertedtrapezium(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"invtrapezium\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer invertedtrapezium(Object o) {\n+            return invertedtrapezium(o, (n) -> n);\n+        }\n+\n+        public GraphRenderer box(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"box\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer box(String name) {\n+            return box(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer box(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"box\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer box(Object o) {\n+            return box(o, (n) -> n);\n+        }\n+\n+        public GraphRenderer hexagon(String name, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, name, \"hexagon\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer hexagon(String name) {\n+            return hexagon(name, (n) -> n);\n+        }\n+\n+        public GraphRenderer hexagon(Object o, NestedRendererSAM<NodeRenderer> sam) {\n+            sam.build(new NodeRenderer(this, sysident(o), \"hexagon\")).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer hexagon(Object o) {\n+            return hexagon(o, (n) -> n);\n+        }\n+\n+        public static class NodeRenderer extends CommonRenderer<NodeRenderer> {\n+            NodeRenderer(GraphRenderer graphRenderer, String name, String shape) {\n+                super(graphRenderer);\n+                append(name).osbrace().append(\"shape\").equal().oquot().append(shape).cquot().space();\n+                \/\/ append(name).osbrace().append(\"shape\").equal().append(shape).space();\n+                \/\/   append(name).osbrace();\/\/.append(\"shape\").equal().append(shape).space();\n+            }\n+\n+            public NodeRenderer end() {\n+                return csbrace().semicolon().nl();\n+            }\n+\n+            NodeRenderer label(String label, NestedRendererSAM<LabelRenderer> sam) {\n+                LabelRenderer renderer = new LabelRenderer(this, label);\n+                sam.build(renderer).end();\n+                return self();\n+            }\n+\n+            NodeRenderer label(NestedRendererSAM<LabelRenderer> sam) {\n+                LabelRenderer renderer = new LabelRenderer(this, \"\");\n+                sam.build(renderer).end();\n+                return self();\n+            }\n+\n+            NodeRenderer label(String label) {\n+                return label(label, (l) -> l);\n+            }\n+\n+\n+            public NodeRenderer color(String color) {\n+                return append(\"color\").equal().oquot().append(color).cquot().space();\n+            }\n+\n+            public NodeRenderer style(String style) {\n+                return append(\"style\").equal().oquot().append(style).cquot().space();\n+            }\n+\n+            public static class LabelRenderer extends CommonRenderer<LabelRenderer> {\n+                int count = 0;\n+\n+                LabelRenderer(NodeRenderer nodeRenderer, String label) {\n+                    super(nodeRenderer);\n+                    append(\"label\").equal().oquot().append(label);\n+                }\n+\n+                public LabelRenderer end() {\n+                    return cquot().space();\n+                }\n+\n+                LabelRenderer port(String label, String text) {\n+                    if (count > 0) {\n+                        pipe();\n+                    }\n+                    count++;\n+                    return lt().append(label).gt().append(text);\n+                }\n+\n+                LabelRenderer label(String label, String text) {\n+                    if (count > 0) {\n+                        pipe();\n+                    }\n+                    count++;\n+                    return append(text);\n+                }\n+\n+                LabelRenderer box(NestedRendererSAM<BoxRenderer> sam) {\n+                    sam.build(new BoxRenderer(this)).end();\n+                    count = 0;\n+                    return self();\n+                }\n+\n+                static class BoxRenderer extends CommonRenderer<BoxRenderer> {\n+                    int count = 0;\n+\n+                    BoxRenderer(LabelRenderer labelRenderer) {\n+                        super(labelRenderer);\n+                        pipe().obrace();\n+                    }\n+\n+                    BoxRenderer(BoxRenderer boxRenderer) {\n+                        super(boxRenderer);\n+                        pipe().obrace();\n+                    }\n+\n+                    BoxRenderer end() {\n+                        return cbrace().pipe();\n+                    }\n+\n+                    BoxRenderer port(String label, String text) {\n+                        if (count > 0) {\n+                            pipe();\n+                        }\n+                        count++;\n+                        return lt().append(label).gt().append(text);\n+                    }\n+\n+                    BoxRenderer label(String text) {\n+                        if (count > 0) {\n+                            pipe();\n+                        }\n+                        count++;\n+                        return append(text);\n+                    }\n+\n+                    BoxRenderer box(NestedRendererSAM<BoxRenderer> sam) {\n+                        sam.build(new BoxRenderer(this)).end();\n+                        count = 0;\n+                        return self();\n+                    }\n+                }\n+            }\n+        }\n+\n+        public GraphRenderer edge(String from, String to, NestedRendererSAM<EdgeRenderer> sam) {\n+            sam.build(new EdgeRenderer(this, from, to)).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer edge(String from, String to) {\n+            return edge(from, to, (n) -> n);\n+        }\n+\n+        public GraphRenderer edge(Object from, Object to, NestedRendererSAM<EdgeRenderer> sam) {\n+            sam.build(new EdgeRenderer(this, sysident(from), sysident(to))).end();\n+            return self();\n+        }\n+\n+        public GraphRenderer edge(Object from, Object to) {\n+            return edge(from, to, (n) -> n);\n+        }\n+\n+        public static class EdgeRenderer extends CommonRenderer<EdgeRenderer> {\n+            EdgeRenderer(GraphRenderer graphRenderer, String from, String to) {\n+                super(graphRenderer);\n+                append(from).rarrow().append(to).osbrace();\n+            }\n+\n+            public EdgeRenderer end() {\n+                return csbrace().semicolon().nl().self();\n+            }\n+\n+            EdgeRenderer label(String label, NestedRendererSAM<LabelRenderer> sam) {\n+                LabelRenderer renderer = new LabelRenderer(this, label);\n+                sam.build(renderer).end();\n+                return self();\n+            }\n+\n+\n+            EdgeRenderer label(String label) {\n+                return label(label, (l) -> l);\n+            }\n+\n+            public static class LabelRenderer extends CommonRenderer<LabelRenderer> {\n+\n+                LabelRenderer(EdgeRenderer edgeRenderer, String label) {\n+                    super(edgeRenderer);\n+                    append(\"label\").equal().oquot().append(label);\n+                }\n+\n+                public LabelRenderer end() {\n+                    return cquot().space();\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    public static void representationTree(Op op, Writer w) {\n+        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n+            op.traverse(null, (t, codeElement) -> switch (codeElement) {\n+                case Body b -> {\n+                    g.hexagon(b, (n) -> n.label(\"\").style(\"filled\"));\n+                    g.edge(b.parentOp(), b);\n+                    yield null;\n+                }\n+                case Block b -> {\n+                    g.box(b, (n) -> n.label(\"\"));\n+                    g.edge(b.parentBody(), b);\n+                    yield null;\n+                }\n+                case Op o -> {\n+                    if (o instanceof Op.Terminating) {\n+                        g.ellipse(o, (n) -> n.label(o.opName()).style(\"filled\"));\n+                    } else {\n+                        g.ellipse(o, (n) -> n.label(o.opName()));\n+                    }\n+                    if (o.parentBlock() != null) {\n+                        g.edge(o.parentBlock(), o);\n+                    }\n+                    yield null;\n+                }\n+            });\n+            return g;\n+        }).end();\n+\n+    }\n+\n+    public static void bodyGraph(Body body, Writer w) {\n+        Block eb = body.entryBlock();\n+        Deque<Block> stack = new ArrayDeque<>();\n+        Set<Block> visited = new HashSet<>();\n+        stack.push(eb);\n+        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n+            while (!stack.isEmpty()) {\n+                Block b = stack.pop();\n+                if (!visited.add(b)) {\n+                    continue;\n+                }\n+\n+                g.box(b, (box) -> box.label(\"\"));\n+\n+                List<Block.Reference> successors = b.terminatingOp().successors();\n+                for (Block.Reference s : successors) {\n+                    g.edge(b, s.targetBlock());\n+\n+                    stack.push(s.targetBlock());\n+                }\n+            }\n+            return g;\n+        }).end();\n+\n+    }\n+\n+    public static void bodyDominatorTree(Body body, Writer w) {\n+        Block eb = body.entryBlock();\n+        Map<Block, Block> idoms = body.immediateDominators();\n+\n+        new DotRenderer().writer(w).start(\"g\").graph((g) -> {\n+            for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+                Block child = e.getKey();\n+                Block parent = e.getValue();\n+\n+                g.box(child, (b) -> b.label(\"\"));\n+\n+                if (child != eb) {\n+                    g.edge(parent, child);\n+                }\n+            }\n+            return g;\n+        }).end();\n+    }\n+\n+    \/**\n+     * Generates a body data dependence graph for a given body.\n+     *\n+     * @param body              the body\n+     * @param names             a map of block arguments to names\n+     * @param traverseblockArgs true if a graph is produced, otherwise a DAG\n+     * @param w                 the writer to write the sr.dot file\n+     *\/\n+    public static void dataDependenceGraph(Body body, Map<Block.Parameter, String> names,\n+                                           boolean traverseblockArgs, Writer w) {\n+\n+\n+        record Edge(Value from, Value to) {\n+        }\n+        new DotRenderer().writer(w).start(\"SR\").graph((g) -> {\n+            Set<Value> visted = new HashSet<>();\n+            Set<Edge> vistedEdges = new HashSet<>();\n+            Deque<Value> stack = new ArrayDeque<>(getValues(body));\n+            while (!stack.isEmpty()) {\n+                Value v = stack.pop();\n+                if (!visted.add(v)) {\n+                    continue;\n+                }\n+\n+                if (v instanceof Op.Result or) {\n+                    if (!or.op().operands().isEmpty() || !(or.op() instanceof Op.Terminating)) {\n+                        g.invertedtrapezium(v, (node) -> node.label(or.op().opName()));\n+                    }\n+                } else if (v instanceof Block.Parameter ba) {\n+                    String n = names.get(v);\n+                    if (n != null) {\n+                        g.invertedtrapezium(v, (node) -> node.label(n).style(\"filled\"));\n+                    } else {\n+                        Block b = ba.declaringBlock();\n+\n+                        g.box(v, (node) -> node.label(\"(\" + b.parameters().indexOf(ba) + \")\").style(\"filled\"));\n+                    }\n+                }\n+\n+                Set<Op.Result> uses = v.uses();\n+                stack.addAll(uses);\n+                for (Op.Result use : uses) {\n+                    if (traverseblockArgs && use.op() instanceof Op.Terminating) {\n+                        for (Block.Reference s : use.op().successors()) {\n+                            int i = s.arguments().indexOf(v);\n+                            if (i != -1) {\n+                                Block.Parameter ba = s.targetBlock().parameters().get(i);\n+\n+                                if (vistedEdges.add(new Edge(v, ba))) {\n+                                    g.edge(v, ba);\n+                                }\n+                                stack.add(ba);\n+                            }\n+                        }\n+                    }\n+\n+                    if (use.op().operands().contains(v)) {\n+                        if (vistedEdges.add(new Edge(v, use))) {\n+                            g.edge(v, use);\n+                        }\n+                    }\n+                }\n+            }\n+            return g;\n+        }).end();\n+    }\n+\n+    private static List<Value> getValues(Body r) {\n+        return r.traverse(new ArrayList<>(), (values, codeElement) -> switch (codeElement) {\n+            case Block b -> {\n+                values.addAll(b.parameters());\n+                yield values;\n+            }\n+            case Op op -> {\n+                values.add(op.result());\n+                yield values;\n+            }\n+            default -> values;\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotRenderer.java","additions":512,"deletions":0,"binary":false,"changes":512,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.dot;\n+\n+import jdk.code.tools.renderer.ProcessRunner;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Created by gfrost\n+ * http:\/\/graphviz.org\/Documentation.php\n+ * http:\/\/graphviz.org\/content\/arrow-shapes\n+ * http:\/\/graphviz.org\/content\/rootNode-shapes\n+ * http:\/\/graphviz.org\/content\/attrs\n+ * http:\/\/www.graphviz.org\/Documentation\/dotguide.pdf\n+ *\/\n+public final class DotViewer {\n+    private DotViewer() {\n+    }\n+\n+    \/\/ Look at Path.of() ..... ;)  I think I may have reimplemented it\n+    static String[] svgViewers = new String[]{\n+            System.getenv(\"SVG_VIEWER_PATH\"),\n+            System.getProperty(\"SVG_VIEWER_PATH\"),\n+            \"\/usr\/bin\/google-chrome\",\n+            \"\/snap\/chromium\/1466\/usr\/lib\/chromium-browser\/chrome\",\n+            \"\/usr\/bin\/gpicview\",\n+            \"\/Applications\/Google Chrome.app\/Contents\/MacOS\/Google Chrome\",\n+            \"\/usr\/bin\/xdg-open\"\n+    };\n+    static String[] dotLocations = new String[]{\n+            System.getenv(\"DOT_PATH\"),\n+            System.getProperty(\"DOT_PATH\"),\n+            \"\/usr\/bin\/dot\",\n+            \"\/usr\/local\/bin\/dot\" \/\/ mac\n+    };\n+\n+    static String getLocation(String[] possibles) {\n+        for (String s : possibles) {\n+            if (s != null && !s.equals(\"\")) {\n+                File file = new File(s);\n+                if (file.exists() && file.canExecute()) {\n+                    return s;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static void view(String dotSource) {\n+\n+        String dot = getLocation(dotLocations);\n+        System.out.println(dotSource);\n+        String svgViewer = getLocation(svgViewers);\n+\n+        if (dot != null && svgViewer != null) {\n+            try {\n+                File tempFile = File.createTempFile(\"ast\", \".svg\");\n+                ProcessRunner.run(dot)\n+                        .opt(\"-Tsvg\")\n+                        .opt(\"-o\").file(tempFile)\n+                        .temp(\"ast\", \"dot\", dotSource)\n+                        .go(false);\n+                ProcessRunner.run(svgViewer)\n+                        .file(tempFile)\n+                        .go(false);\n+\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();\n+            }\n+        }\n+\n+    }\n+\n+    public static void viewNoWait(String dotSource) {\n+        String dot = getLocation(dotLocations);\n+        String svgViewer = getLocation(svgViewers);\n+\n+        if (dot != null && svgViewer != null) {\n+            try {\n+                File tempDotFile = File.createTempFile(\"ast\", \"dot\");\n+                FileWriter tempDotFileWriter = new FileWriter(tempDotFile);\n+                tempDotFileWriter.append(dotSource);\n+                tempDotFileWriter.close();\n+                File tempPngFile = File.createTempFile(\"ast\", \"svg\");\n+                List<String> dotCommand = new ArrayList<>();\n+                dotCommand.add(dot);\n+                dotCommand.add(\"-Tsvg\");\n+                dotCommand.add(\"-o\");\n+                dotCommand.add(tempPngFile.getAbsolutePath());\n+                dotCommand.add(tempDotFile.getAbsolutePath());\n+\n+                ProcessBuilder dotBuilder = new ProcessBuilder(dotCommand);\n+                Process dotProcess = dotBuilder.start();\n+                dotProcess.waitFor();\n+\n+                List<String> fehCommand = new ArrayList<>();\n+                fehCommand.add(svgViewer);\n+                \/\/  fehCommand.add(\"-t\");\n+                fehCommand.add(tempPngFile.getAbsolutePath());\n+                ProcessBuilder fehBuilder = new ProcessBuilder(fehCommand);\n+                Process fehProcess = fehBuilder.start();\n+\n+            } catch (IOException | InterruptedException ioe) {\n+                ioe.printStackTrace();\n+            }\n+        } else if (dot == null) {\n+            System.out.println(\"Sorry can't find \/usr\/bin\/dot (sudo apt-get install graphviz)\");\n+        } else {\n+            System.out.println(\"Sorry can't find a suitable SVG Viewer\");\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        \/\/ https:\/\/renenyffenegger.ch\/notes\/tools\/Graphviz\/examples\/index\n+\n+        StringWriter dotw = new StringWriter();\n+        \/\/ http:\/\/magjac.com\/graphviz-visual-editor\/\n+        new DotRenderer().writer(dotw).start(\"mine\").graph(\n+                (g) -> g\n+                        .box(\"A\",\n+                                (box) -> box\n+                                        .label(\"Snarlywang\")\n+                                        .color(\"lightyellow\")\n+                                        .style(\"filled\")\n+                        )\n+                        .record(\"B\",\n+                                (record) -> record\n+                                        .color(\"lightgreen\")\n+                                        .style(\"filled\")\n+                                        .label((label) -> label\n+                                                .port(\"left\", \"left\")\n+                                                .box(\n+                                                        (vertical) -> vertical\n+                                                                .port(\"top\", \"top\")\n+                                                                .label(\"center\")\n+                                                                .port(\"bottom\", \"bottom\")\n+                                                )\n+                                                .port(\"right\", \"right\")\n+                                        )\n+                        )\n+                        .edge(\"A\", \"B:top:nw\", (e) -> e.label(\"1\"))\n+                        .edge(\"A\", \"B:bottom:se\", (e) -> e.label(\"2\"))\n+                        .edge(\"A\", \"B:left:w\", (e) -> e.label(\"3\"))\n+                        .edge(\"A\", \"B:right:e\", (e) -> e.label(\"4\"))\n+        ).end();\n+        DotViewer.view(dotw.toString());\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/dot\/DotViewer.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.StringWriter;\n+\n+public final class CStyleRenderer extends CommonRenderer<CStyleRenderer> {\n+    public CStyleRenderer() {\n+        super();\n+    }\n+\n+    public CStyleRenderer func(String identifier, TextRenderer.NestedRendererSAM<CStyleRenderer> args,\n+                               TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n+        return keyword(\"func\").space().identifier(identifier).parenthesized(args).braced(body).nl();\n+    }\n+\n+    public CStyleRenderer forLoop(TextRenderer.NestedRendererSAM<CStyleRenderer> init, TextRenderer.NestedRendererSAM<CStyleRenderer> cond,\n+                                  TextRenderer.NestedRendererSAM<CStyleRenderer> mutator, TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n+        return forKeyword().oparen().nest(init).semicolon().space().nest(cond).semicolon().space().\n+                nest(mutator).cparen().braced(body).nl();\n+    }\n+\n+    public CStyleRenderer whileLoop(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> body) {\n+        return whileKeyword().oparen().nest(cond).cparen().braced(body).nl();\n+    }\n+\n+    public CStyleRenderer ifCondRaw(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody) {\n+        return ifKeyword().oparen().nest(cond).cparen().braced(thenBody);\n+    }\n+\n+    public CStyleRenderer ifCond(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody) {\n+        return ifCondRaw(cond, thenBody).nl();\n+    }\n+\n+    public CStyleRenderer ifCond(TextRenderer.NestedRendererSAM<CStyleRenderer> cond, TextRenderer.NestedRendererSAM<CStyleRenderer> thenBody,\n+                                 TextRenderer.NestedRendererSAM<CStyleRenderer> elseBody) {\n+        return ifCondRaw(cond, thenBody).elseKeyword().braced(elseBody).nl();\n+    }\n+\n+    public CStyleRenderer var(Class<?> clazz, String name) {\n+        return type(clazz.getName()).space().identifier(name);\n+    }\n+\n+    public CStyleRenderer assign(String identifier) {\n+        return identifier(identifier).equal();\n+    }\n+\n+    static public void main(String[] args) {\n+        StringWriter writer = new StringWriter();\n+        CStyleRenderer renderer = new CStyleRenderer().writer(writer).colorize();\n+        renderer.lineComment(\"A new function\");\n+        renderer.func(\"funcName\",\n+                (as) -> as.var(int.class, \"name\").comma().space()\n+                        .var(int.class, \"name2\"),\n+                (fb) -> fb.lineComment(\"Inside body of func\")\n+                        .append(\"here;\\nis;\\nsome text\").semicolon().nl()\n+                        .forLoop(\n+                                (in) -> in.var(int.class, \"a\").equal().decLiteral(0),\n+                                (cc) -> cc.identifier(\"a\").op(\"<\").decLiteral(10),\n+                                (mu) -> mu.assign(\"a\").identifier(\"a\").op(\"+\").decLiteral(1),\n+                                (lb) -> lb.lineComment(\"in loop\")\n+                                        .ifCond(\n+                                                (cc) -> cc.identifier(\"a\").op(\">\").decLiteral(2),\n+                                                (th) -> th.lineComment(\"positive\"),\n+                                                (el) -> el.lineComment(\"not so much \")\n+                                        )\n+                        )\n+                        .nl()\n+        ).nl();\n+        System.out.println(writer);\n+\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/CStyleRenderer.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public class CommonRenderer<T extends CommonRenderer<T>> extends TextRenderer<T> {\n+\n+    public CommonRenderer() {\n+    }\n+\n+    public CommonRenderer(TextRenderer<?> renderer) {\n+        super(renderer);\n+    }\n+\n+    public T semicolon() {\n+        return op(\";\");\n+    }\n+\n+    public T comma() {\n+        return op(\",\");\n+    }\n+\n+    public T commaSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T commaSeparator() {\n+        if (!first()) {\n+            comma().space();\n+        }\n+        return self();\n+    }\n+\n+    public T commaSpaceSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T commaSpaceSeparator() {\n+        if (!first()) {\n+            comma().space();\n+        }\n+        return self();\n+    }\n+\n+    public T spaceSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T spaceSeparator() {\n+        if (!first()) {\n+            space();\n+        }\n+        return self();\n+    }\n+\n+    public T newlineSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T newlineSeparator() {\n+        if (!first()) {\n+            nl();\n+        }\n+        return self();\n+    }\n+\n+    public T semicolonSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T semicolonSeparator() {\n+        if (!first()) {\n+            semicolon();\n+        }\n+        return self();\n+    }\n+\n+    public T semicolonSpaceSeparatedList() {\n+        return startList();\n+    }\n+\n+    public T semicolonSpaceSeparator() {\n+        if (!first()) {\n+            semicolon().space();\n+        }\n+        return self();\n+    }\n+\n+    public T dot() {\n+        return op(\".\");\n+    }\n+\n+\n+    public T equal() {\n+        return op(\"=\");\n+    }\n+\n+\n+    public T plusplus() {\n+        return op(\"++\");\n+    }\n+\n+\n+    public T minusminus() {\n+        return op(\"--\");\n+    }\n+\n+    public T lineComment(String line) {\n+        return op(\"\/\/\").space().comment(line).nl();\n+    }\n+\n+\n+    public T blockComment(String block) {\n+        return op(\"\/*\").nl().comment(block).nl().op(\"*\/\").nl();\n+    }\n+\n+    public T newKeyword() {\n+        return keyword(\"new\");\n+    }\n+\n+\n+    public T staticKeyword() {\n+        return keyword(\"static\");\n+    }\n+\n+\n+    public T constKeyword() {\n+        return keyword(\"const\");\n+    }\n+\n+    public T ifKeyword() {\n+        return keyword(\"if\");\n+\n+    }\n+\n+\n+    public T whileKeyword() {\n+        return keyword(\"while\");\n+    }\n+\n+\n+    public T breakKeyword() {\n+        return keyword(\"break\");\n+\n+    }\n+\n+\n+    public T continueKeyword() {\n+        return keyword(\"continue\");\n+    }\n+\n+\n+    public T query() {\n+        return op(\"?\");\n+    }\n+\n+\n+    public T colon() {\n+        return op(\":\");\n+    }\n+\n+\n+    public T nullKeyword() {\n+        return keyword(\"null\");\n+\n+    }\n+\n+\n+    public T elseKeyword() {\n+        return keyword(\"else\");\n+    }\n+\n+\n+    public T returnKeyword() {\n+        return keyword(\"return\");\n+    }\n+\n+\n+    public T switchKeyword() {\n+        return keyword(\"switch\");\n+    }\n+\n+\n+    public T caseKeyword() {\n+        return keyword(\"case\");\n+    }\n+\n+\n+    public T defaultKeyword() {\n+        return keyword(\"default\");\n+    }\n+\n+    public T doKeyword() {\n+        return keyword(\"do\");\n+    }\n+\n+    public T forKeyword() {\n+        return keyword(\"for\");\n+    }\n+\n+    public T ampersand() {\n+        return op(\"&\");\n+    }\n+\n+    public T braced(NestedRendererSAM<T> nb) {\n+        return nb.build(obrace().nl().in()).out().cbrace().self();\n+    }\n+\n+    public T osbrace() {\n+        return open(\"[\");\n+    }\n+\n+\n+    public T csbrace() {\n+        return close(\"]\");\n+    }\n+\n+\n+    public T parenthesized(NestedRendererSAM<T> nb) {\n+        return nb.build(oparen().in()).out().cparen().self();\n+    }\n+\n+    public T underscore() {\n+        return op(\"_\");\n+    }\n+\n+    public T oparen() {\n+        return open(\"(\");\n+    }\n+\n+    public T cparen() {\n+        return close(\")\");\n+    }\n+\n+    public T obrace() {\n+        return open(\"{\");\n+    }\n+\n+    public T cbrace() {\n+        return close(\"}\");\n+    }\n+\n+    public T at() {\n+        return op(\"@\").self();\n+    }\n+\n+    public T caret() {\n+        return op(\"^\").self();\n+    }\n+\n+    public T percent() {\n+        return op(\"%\").self();\n+    }\n+\n+    public T pipe() {\n+        return op(\"|\").self();\n+    }\n+\n+    public T rarrow() {\n+        return op(\"->\").self();\n+    }\n+\n+    public T larrow() {\n+        return op(\"<-\").self();\n+    }\n+\n+    public T lt() {\n+        return op(\"<\").self();\n+    }\n+\n+    public T gt() {\n+        return op(\">\").self();\n+    }\n+\n+    public T asterisk() {\n+        return op(\"*\").self();\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/CommonRenderer.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public final class Diff {\n+    private Diff() {\n+    }\n+\n+    public static void annotate(File file, int line, int col, String msg) {\n+        List<String> lines = getLines(file);\n+        for (int i = Math.max(line - 2, 0); i < (line - 1); i++) {\n+            System.out.printf(\"    %2d:%s\\n\", i + 1, lines.get(i));\n+        }\n+        String text = lines.get(line - 1);\n+        System.out.printf(\" -> %2d:%s\\n      \", line, text);\n+        for (int i = 0; i < col; i++) {\n+            System.out.print(\" \");\n+        }\n+        System.out.println(\"^ \" + msg);\n+        for (int i = line; i < Math.min(line + 2, lines.size() - 1); i++) {\n+            System.out.printf(\"    %2d:%s\\n\", i + 1, lines.get(i));\n+        }\n+\n+    }\n+\n+    static List<String> getLines(File file) {\n+        List<String> lines = new ArrayList<>();\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file)));\n+            for (String line = br.readLine(); line != null; line = br.readLine()) {\n+                lines.add(line);\n+            }\n+            br.close();\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return lines;\n+    }\n+\n+    public static class DiffResult {\n+        String lhs;\n+        String rhs;\n+        public String result;\n+        public int exitStatus;\n+\n+        public DiffResult(String lhs, String rhs, String result, int exitStatus) {\n+            this.lhs = lhs;\n+            this.rhs = rhs;\n+            this.result = result;\n+            this.exitStatus = exitStatus;\n+        }\n+    }\n+\n+    public static DiffResult diff(String lhs, String rhs, int width) {\n+        try {\n+            File lhsFile = File.createTempFile(\"lhs\", \"txt\");\n+            FileWriter lhsw = new FileWriter(lhsFile);\n+            lhsw.append(lhs);\n+            lhsw.close();\n+            File rhsFile = File.createTempFile(\"rhs\", \"txt\");\n+            FileWriter rhsw = new FileWriter(rhsFile);\n+            rhsw.append(rhs);\n+            rhsw.close();\n+\n+            List<String> command = new ArrayList<>();\n+            command.add(\"sdiff\");\n+            command.add(\"--expand-tabs\");\n+            command.add(\"--ignore-all-space\");\n+            command.add(\"--width=\" + width);\n+            command.add(\"--ignore-blank-lines\");\n+            command.add(lhsFile.getAbsolutePath());\n+            command.add(rhsFile.getAbsolutePath());\n+\n+            ProcessBuilder builder = new ProcessBuilder(command);\n+            final Process process = builder.start();\n+            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n+            StringBuilder out = new StringBuilder();\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                if (line.contains(\"|\")) {\n+                    out.append(TerminalColors.Color.RED.colorize(line)).append(\"\\n\");\n+                } else {\n+                    out.append(TerminalColors.Color.GREEN.colorize(line)).append(\"\\n\");\n+                }\n+\n+            }\n+            process.waitFor();\n+            br.close();\n+            lhsFile.delete();\n+            rhsFile.delete();\n+            return new DiffResult(lhs, rhs, out.toString(), process.exitValue());\n+        } catch (IOException | InterruptedException ioe) {\n+            ioe.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+\n+    public static File write(File file, String text) {\n+        try {\n+            PrintWriter pw = new PrintWriter(file);\n+            pw.append(text);\n+            pw.append(\"\\n\");\n+            pw.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return file;\n+    }\n+\n+\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/Diff.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Value;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public final class GlobalValueBlockNaming {\n+    final Map<Value, String> gvn;\n+    final Map<Block, String> gbn;\n+    int valueOrdinal = 0;\n+    int blockOrdinal = 0;\n+\n+    GlobalValueBlockNaming() {\n+        this.gvn = new HashMap<>();\n+        this.gbn = new HashMap<>();\n+    }\n+\n+    String getValueName(Value _v) {\n+        return gvn.computeIfAbsent(_v, v -> String.valueOf(valueOrdinal++));\n+    }\n+\n+    String getBlockName(Block _b) {\n+        return gbn.computeIfAbsent(_b, b -> \"block_\" + blockOrdinal++);\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/GlobalValueBlockNaming.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public class ProcessRunner {\n+\n+    static public ProcessRunner run(String prog) {\n+        return new ProcessRunner(prog);\n+    }\n+\n+    static public ProcessRunner run(File file) {\n+        return new ProcessRunner(file);\n+    }\n+\n+    List<String> args = new ArrayList<>();\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public ProcessRunner(String prog) {\n+        opt(prog);\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public ProcessRunner(File prog) {\n+        file(prog);\n+    }\n+\n+    public ProcessRunner opt(String... argsToAdd) {\n+        for (String s : argsToAdd) {\n+            args.add(s);\n+        }\n+        return this;\n+    }\n+\n+    public ProcessRunner fileOpt(String opt, File file) {\n+        return opt(opt).file(file);\n+    }\n+\n+    public ProcessRunner dirOpt(String opt, File dir) {\n+        dir.mkdir();\n+        return fileOpt(opt, dir);\n+    }\n+\n+    public ProcessRunner file(File file) {\n+        opt(file.getAbsolutePath());\n+        return this;\n+    }\n+\n+    public ProcessRunner files(File[] files) {\n+        for (File f : files) {\n+            file(f);\n+        }\n+        return this;\n+    }\n+\n+    public void files(List<File> rsFiles) {\n+        files(rsFiles.toArray(new File[0]));\n+    }\n+\n+    public static class Result {\n+        public Result() {\n+        }\n+\n+        public void scan(Pattern pattern, Scanner scanner) {\n+            for (List<String> list : streams) { \/\/stdout then stderr\n+                for (String text : list) {\n+                    Matcher matcher;\n+                    if ((matcher = pattern.matcher(text)).matches()) {\n+                        scanner.process(matcher);\n+                    }\n+                }\n+            }\n+        }\n+\n+        public interface Scanner {\n+            void process(Matcher m);\n+        }\n+\n+        public int status = -1;\n+        public boolean ok = false;\n+        public String commandLine = \"\";\n+\n+        public List<String> stdout = new ArrayList<>();\n+        public List<String> stderr = new ArrayList<>();\n+        public List<List<String>> streams = List.of(stdout, stderr);\n+    }\n+\n+\n+    public Result go(boolean verbose) {\n+        Result result = new Result();\n+\n+        StringBuilder commandBuilder = new StringBuilder();\n+\n+        for (String arg : args) {\n+            commandBuilder.append(arg + \" \");\n+            if (verbose) {\n+                System.out.print(arg + \" \");\n+            }\n+        }\n+\n+        result.commandLine = commandBuilder.toString();\n+        ProcessBuilder processBuilder = new ProcessBuilder(args);\n+        try {\n+            Process process = processBuilder.start();\n+            Thread stdout = new StreamReader(\"OUT\", process.getErrorStream(), result.stdout, verbose).thread;\n+            Thread stderr = new StreamReader(\"ERR\", process.getInputStream(), result.stderr, verbose).thread;\n+            result.status = process.waitFor();\n+            stdout.join();\n+            stderr.join();\n+            result.ok = result.status == 0;\n+        } catch (IOException | InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        return result;\n+    }\n+\n+    public ProcessRunner temp(String prefix, String suffix, String text) {\n+        try {\n+            File tempFile = File.createTempFile(prefix, suffix);\n+            FileWriter tempDotFileWriter = new FileWriter(tempFile);\n+            tempDotFileWriter.append(text);\n+            tempDotFileWriter.close();\n+            file(tempFile);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return this;\n+    }\n+\n+\n+    static class StreamReader {\n+        Thread thread;\n+\n+        StreamReader(final String prefix, InputStream is, final List<String> out, final boolean verbose) {\n+            final BufferedReader br = new BufferedReader(new InputStreamReader(is));\n+            thread = new Thread(() -> {\n+                try {\n+                    for (String string = br.readLine(); string != null; string = br.readLine()) {\n+                        if (verbose) {\n+                            System.out.println(prefix + \":\" + string);\n+                        }\n+                        out.add(string);\n+                    }\n+                    br.close();\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            thread.start();\n+\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/ProcessRunner.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Body;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+\n+import java.io.*;\n+import java.lang.reflect.code.type.JavaType;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * Created by gfrost\n+ *\/\n+public final class SRRenderer extends CommonRenderer<SRRenderer> {\n+\n+    static class AttributeMapper {\n+        static String toString(Object value) {\n+            if (value instanceof Integer i && i >= 0) {\n+                return Integer.toString(i);\n+            } else if (value == null) {\n+                return \"null\";\n+            } else {\n+                return \"\\\"\" + quote(value.toString()) + \"\\\"\";\n+            }\n+        }\n+    }\n+\n+    \/\/ Copied from com.sun.tools.javac.util.Convert\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        switch (ch) {\n+            case '\\b':  return \"\\\\b\";\n+            case '\\f':  return \"\\\\f\";\n+            case '\\n':  return \"\\\\n\";\n+            case '\\r':  return \"\\\\r\";\n+            case '\\t':  return \"\\\\t\";\n+            case '\\'':  return \"\\\\'\";\n+            case '\\\"':  return \"\\\\\\\"\";\n+            case '\\\\':  return \"\\\\\\\\\";\n+            default:\n+                return (isPrintableAscii(ch))\n+                        ? String.valueOf(ch)\n+                        : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+\n+    SRRenderer() {\n+        super();\n+    }\n+\n+    SRRenderer caretLabelTarget(String name) {\n+        return caret().labelTarget(name).self();\n+    }\n+\n+    SRRenderer atIdentifier(String name) {\n+        return at().identifier(name).self();\n+    }\n+\n+    SRRenderer percentLiteral(String name) {\n+        return percent().literal(name).self();\n+    }\n+\n+    SRRenderer spaceColonSpace() {\n+        return space().colon().space();\n+    }\n+\n+    SRRenderer spaceEqualSpace() {\n+        return space().equal().space();\n+    }\n+\n+    public void write(Op op) {\n+        GlobalValueBlockNaming gn = new GlobalValueBlockNaming();\n+        write(gn, op);\n+        nl();\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Block.Reference successor) {\n+        caretLabelTarget(gn.getBlockName(successor.targetBlock()));\n+        if (!successor.arguments().isEmpty()) {\n+            oparen().commaSeparatedList();\n+            for (var a : successor.arguments()) {\n+                commaSeparator();\n+                percentLiteral(gn.getValueName(a));\n+            }\n+            cparen();\n+        }\n+\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Op op) {\n+        keyword(op.opName());\n+        if (!op.operands().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (var v : op.operands()) {\n+                spaceSeparator();\n+                percentLiteral(gn.getValueName(v));\n+            }\n+        }\n+        if (!op.successors().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (Block.Reference sb : op.successors()) {\n+                spaceSeparator();\n+                write(gn, sb);\n+            }\n+        }\n+\n+        if (!op.attributes().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (var e : op.attributes().entrySet()) {\n+                spaceSeparator();\n+                String name = e.getKey();\n+                if (!name.isEmpty()) {\n+                    atIdentifier(name).equal().identifier(AttributeMapper.toString(e.getValue()));\n+                } else {\n+                    atIdentifier(AttributeMapper.toString(e.getValue()));\n+                }\n+            }\n+        }\n+\n+        if (!op.bodies().isEmpty()) {\n+            int nBodies = op.bodies().size();\n+            if (nBodies == 1) {\n+                space();\n+            } else {\n+                nl().in().in();\n+            }\n+            \/\/ @@@ separated list state does not nest as state.first gets overwritten\n+            boolean first = true;\n+            for (Body body : op.bodies()) {\n+                if (!first) {\n+                    nl();\n+                }\n+                write(gn, body);\n+                first = false;\n+            }\n+            if (nBodies > 1) {\n+                out().out();\n+            }\n+        }\n+\n+        semicolon();\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Block block, boolean isEntryBlock) {\n+        if (!isEntryBlock) {\n+            caretLabelTarget(gn.getBlockName(block));\n+            if (!block.parameters().isEmpty()) {\n+                oparen().commaSpaceSeparatedList();\n+                for (var v : block.parameters()) {\n+                    commaSpaceSeparator();\n+                    writeValueDecl(gn, v);\n+                }\n+                cparen();\n+            }\n+            colon().nl();\n+        }\n+        in();\n+        for (Op op : block.ops()) {\n+            Op.Result or = op.result();\n+            if (!or.type().equals(JavaType.VOID)) {\n+                writeValueDecl(gn, or);\n+                spaceEqualSpace();\n+            }\n+            write(gn, op);\n+            nl();\n+        }\n+        out();\n+    }\n+\n+    public void write(GlobalValueBlockNaming gn, Body body) {\n+        Block eb = body.entryBlock();\n+        oparen().commaSpaceSeparatedList();\n+        for (var v : eb.parameters()) {\n+            commaSpaceSeparator();\n+            writeValueDecl(gn, v);\n+        }\n+        cparen().type(body.bodyType().returnType().toString()).space().rarrow().space().obrace().nl();\n+        in();\n+        boolean isEntryBlock = true;\n+        for (Block b : body.blocks()) {\n+            if (!isEntryBlock) {\n+                nl();\n+            }\n+            write(gn, b, isEntryBlock);\n+            isEntryBlock = false;\n+        }\n+        out();\n+        cbrace();\n+    }\n+\n+    public void writeValueDecl(GlobalValueBlockNaming gn, Value v) {\n+        percentLiteral(gn.getValueName(v)).spaceColonSpace().type(v.type().toString());\n+    }\n+\n+    \/\/ @@@ Not used\n+    public void write(GlobalValueBlockNaming gn, CoreOps.FuncOp fRep) {\n+        this.append(fRep.opName());\/\/ w.write(name);\n+        if (!fRep.operands().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (var v : fRep.operands()) {\n+                spaceSeparator();\n+                percentLiteral(gn.getValueName(v));\n+            }\n+        }\n+        if (!fRep.successors().isEmpty()) {\n+            space().spaceSeparatedList();\n+            for (Block.Reference sb : fRep.successors()) {\n+                spaceSeparator();\n+                write(gn, sb);\n+            }\n+        }\n+        if (!fRep.attributes().isEmpty()) {\n+            space();\n+            for (var e : fRep.attributes().entrySet()) {\n+                String name = e.getKey();\n+                String value = AttributeMapper.toString(e.getValue());\n+                op(\"@\");\n+                if (name.isEmpty()) {\n+                    literal(value);\n+                } else {\n+                    identifier(name).equal().literal(value);\n+                }\n+            }\n+        }\n+        if (!fRep.bodies().isEmpty()) {\n+            space().newlineSeparatedList();\n+            for (Body body : fRep.bodies()) {\n+                newlineSeparator();\n+                write(gn, body);\n+            }\n+        }\n+\n+    }\n+\n+    public static void write(Writer writer, Op op) {\n+        new SRRenderer().writer(writer).write(op);\n+    }\n+\n+    public static void write(OutputStream out, Op op) {\n+        write(new OutputStreamWriter(out, StandardCharsets.UTF_8), op);\n+    }\n+\n+    public static String stringify(Op op) {\n+        StringWriter sw = new StringWriter();\n+        write(sw, op);\n+        return sw.toString();\n+    }\n+\n+    public static String colorize(TextRenderer.TokenColorMap tokenColorMap, Op op) {\n+        StringWriter sw = new StringWriter();\n+        new SRRenderer().writer(sw).colorize(tokenColorMap).write(op);\n+        return sw.toString();\n+    }\n+\n+    public static String colorize(Op op) {\n+        return colorize(new TextRenderer.TokenColorMap(), op);\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/SRRenderer.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+package jdk.code.tools.renderer;\n+\n+\n+public final class TerminalColors {\n+    private TerminalColors() {\n+    }\n+\n+    public interface Colorizer {\n+        String colorize(String text);\n+    }\n+\n+    public enum Color implements Colorizer {\n+        \/\/ https:\/\/www.lihaoyi.com\/post\/BuildyourownCommandLinewithANSIescapecodes.html#8-colors\n+        NONE(\"0\"),\n+        BLACK(\"38;5;0\"), DARKGREEN(\"38;5;22\"), DARKBLUE(\"38;5;27\"),\n+        GREY(\"38;5;247\"), RED(\"38;5;1\"), GREEN(\"38;5;77\"), YELLOW(\"38;5;185\"),\n+        BLUE(\"38;5;31\"), WHITE(\"38;5;251\"), ORANGE(\"38;5;208\"), PURPLE(\"38;5;133\");\n+        final String escSequence;\n+\n+        Color(String seq) {\n+            escSequence = \"\\u001b[\" + seq + \"m\";\n+        }\n+\n+        public String colorize(String string) {\n+            return (this == NONE) ? string : escSequence + string + NONE.escSequence;\n+        }\n+    }\n+}\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/TerminalColors.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.code.tools.renderer;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.util.Map;\n+\n+public class TextRenderer<T extends TextRenderer<T>> {\n+\n+    public interface NestedRendererSAM<T> {\n+        T build(T nb);\n+    }\n+\n+    public enum TokenType {\n+        WHITESPACE, OP, TYPE, CONTROL, LITERAL, COMMENT, KEYWORD, IDENTIFIER, LABELTARGET, NONE\n+    }\n+\n+    public static class TokenColorMap {\n+\n+\n+        private final Map<TokenType, TerminalColors.Colorizer> map;\n+\n+        public TokenColorMap(Map<TokenType, TerminalColors.Colorizer> map) {\n+            this.map = map;\n+        }\n+\n+        public TokenColorMap() {\n+            this(Map.of(\n+                    TokenType.NONE, TerminalColors.Color.WHITE,\n+                    TokenType.IDENTIFIER, TerminalColors.Color.YELLOW,\n+                    TokenType.LABELTARGET, TerminalColors.Color.BLUE,\n+                    TokenType.TYPE, TerminalColors.Color.WHITE,\n+                    TokenType.COMMENT, TerminalColors.Color.GREEN,\n+                    TokenType.KEYWORD, TerminalColors.Color.ORANGE,\n+                    TokenType.CONTROL, TerminalColors.Color.GREY,\n+                    TokenType.LITERAL, TerminalColors.Color.GREEN,\n+                    TokenType.OP, TerminalColors.Color.WHITE,\n+                    TokenType.WHITESPACE, TerminalColors.Color.WHITE));\n+        }\n+\n+        public String colorize(TokenType tokenType, String string) {\n+            if (map.containsKey(tokenType)) {\n+                return map.get(tokenType).colorize(string);\n+            } else {\n+                return string;\n+            }\n+        }\n+    }\n+\n+    public static class State {\n+        public Writer writer;\n+        public int indent;\n+        public TokenColorMap tokenColorMap = null;\n+        public boolean isFirst = false;\n+\n+        public boolean newLined = false;\n+\n+        State() {\n+            this.writer = null;\n+            this.indent = 0;\n+            this.tokenColorMap = null;\n+            this.isFirst = false;\n+            this.newLined = true;\n+        }\n+    }\n+\n+    public T writer(Writer writer) {\n+        this.state.writer = writer;\n+        return self();\n+    }\n+\n+    public T colorize(TokenColorMap tokenColorMap) {\n+        this.state.tokenColorMap = tokenColorMap;\n+        return self();\n+    }\n+\n+    public T colorize() {\n+        return colorize(new TokenColorMap());\n+    }\n+\n+    public State state;\n+\n+    protected TextRenderer() {\n+        this.state = new State();\n+    }\n+\n+    protected TextRenderer(TextRenderer<?> renderer) {\n+        this.state = renderer.state;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T self() {\n+        return (T) this;\n+    }\n+\n+\n+    public boolean first() {\n+        var was = state.isFirst;\n+        state.isFirst = false;\n+        return was;\n+    }\n+\n+    public T startList() {\n+        state.isFirst = true;\n+        return self();\n+    }\n+\n+    public T append(String text) {\n+        try {\n+            \/\/ While we do expect appends text to be simple tokens. We can handle newlines.\n+            var lines = text.split(\"\\n\");\n+            for (int i = 0; i < lines.length - 1; i++) {\n+                state.writer.append(\" \".repeat(state.indent) + lines[i] + \"\\n\");\n+                state.newLined = true;\n+            }\n+            if (state.newLined) {\n+                state.writer.append(\" \".repeat(state.indent));\n+            }\n+            state.writer.append(lines[lines.length - 1]);\n+            state.newLined = false;\n+            return self();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    public T identifier(String ident) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.IDENTIFIER, ident));\n+        } else {\n+            return append(ident);\n+        }\n+    }\n+\n+    public T type(String typeName) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.TYPE, typeName));\n+        } else {\n+            return append(typeName);\n+        }\n+    }\n+\n+    public T keyword(String keyword) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.KEYWORD, keyword));\n+        } else {\n+            return append(keyword);\n+        }\n+    }\n+\n+    public T literal(String literal) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.LITERAL, literal));\n+        } else {\n+            return append(literal);\n+        }\n+    }\n+\n+    public T ws(String whitespace) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.WHITESPACE, whitespace));\n+        } else {\n+            return append(whitespace);\n+        }\n+    }\n+\n+    public T op(String op) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.OP, op));\n+        } else {\n+            return append(op);\n+        }\n+    }\n+\n+    public T control(String control) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.CONTROL, control));\n+        } else {\n+            return append(control);\n+        }\n+    }\n+\n+    public T labelTarget(String labelTarget) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.LABELTARGET, labelTarget));\n+        } else {\n+            return append(labelTarget);\n+        }\n+    }\n+\n+    public T comment(String comment) {\n+        if (state.tokenColorMap != null) {\n+            return append(state.tokenColorMap.colorize(TokenType.COMMENT, comment));\n+        } else {\n+            return append(comment);\n+        }\n+    }\n+\n+    public T strLiteral(String s) {\n+        return oquot().literal(s).cquot();\n+    }\n+\n+    public T oquot() {\n+        return literal(\"\\\"\");\n+    }\n+\n+    public T cquot() {\n+        return literal(\"\\\"\");\n+    }\n+\n+    public T decLiteral(int i) {\n+        return literal(String.format(\"%d\", i));\n+    }\n+\n+    public T hexLiteral(int i) {\n+        return literal(String.format(\"%x\", i));\n+    }\n+\n+    public T in() {\n+        state.indent += 2;\n+        return self();\n+    }\n+\n+    public T out() {\n+        state.indent -= 2;\n+        return self();\n+    }\n+\n+    public T flush() {\n+        try {\n+            state.writer.flush();\n+            return self();\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    public T nl() {\n+        try {\n+            \/\/ note we go directly to the underlying writer!\n+            state.writer.append(\"\\n\");\n+            state.newLined = true;\n+            return flush().self();\n+        } catch (IOException ioe) {\n+            throw new RuntimeException(ioe);\n+        }\n+    }\n+\n+    public T space() {\n+        return ws(\" \");\n+    }\n+\n+    public T nest(NestedRendererSAM<T> nb) {\n+        return nb.build(self());\n+    }\n+\n+    public T open(String op) {\n+        control(op);\n+        return self();\n+    }\n+\n+    public T close(String op) {\n+        control(op);\n+        return self();\n+    }\n+}\n+\n","filename":"src\/jdk.code.tools\/share\/classes\/jdk\/code\/tools\/renderer\/TextRenderer.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Tools module for code reflection, providing useful ancillary functionality\n+ * that may not be necessary in the java.base module.\n+ *\n+ *\/\n+module jdk.code.tools {\n+    exports jdk.code.tools.dot;\n+    exports jdk.code.tools.renderer;\n+}\n+\n","filename":"src\/jdk.code.tools\/share\/classes\/module-info.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -258,0 +258,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -245,0 +246,12 @@\n+    \/\/ For code reflection\n+    public final Type codeReflectionType;\n+    public final Type quotedType;\n+    public final Type quotableType;\n+    public final Type closureOpType;\n+    public final Type lambdaOpType;\n+    public final Type opInterpreterType;\n+    public final Type opParserType;\n+    public final Type opType;\n+    public final MethodSymbol opInterpreterInvoke;\n+    public final MethodSymbol opParserFromString;\n+\n@@ -628,0 +641,19 @@\n+        \/\/ For code reflection\n+        codeReflectionType = enterClass(\"java.lang.runtime.CodeReflection\");\n+        quotedType = enterClass(\"java.lang.reflect.code.Quoted\");\n+        quotableType = enterClass(\"java.lang.reflect.code.Quotable\");\n+        closureOpType = enterClass(\"java.lang.reflect.code.op.CoreOps$ClosureOp\");\n+        lambdaOpType = enterClass(\"java.lang.reflect.code.op.CoreOps$LambdaOp\");\n+        opInterpreterType = enterClass(\"java.lang.reflect.code.interpreter.Interpreter\");\n+        opType = enterClass(\"java.lang.reflect.code.Op\");\n+        opInterpreterInvoke = new MethodSymbol(PUBLIC | STATIC | VARARGS,\n+                names.fromString(\"invoke\"),\n+                new MethodType(List.of(opType, new ArrayType(objectType, arrayClass)), objectType,\n+                        List.nil(), methodClass),\n+                opInterpreterType.tsym);\n+        opParserType = enterClass(\"java.lang.reflect.code.parser.OpParser\");\n+        opParserFromString = new MethodSymbol(PUBLIC | STATIC,\n+                names.fromString(\"fromStringOfFuncOp\"),\n+                new MethodType(List.of(stringType), opType,\n+                        List.nil(), methodClass),\n+                opParserType.tsym);\n@@ -634,0 +666,2 @@\n+        synthesizeEmptyInterfaceIfMissing(quotedType);\n+        synthesizeEmptyInterfaceIfMissing(quotableType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -207,0 +217,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -210,0 +262,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -248,5 +302,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -307,0 +368,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -310,0 +372,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -324,1 +387,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -333,1 +396,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -351,1 +414,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -355,1 +418,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -365,1 +428,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -388,2 +451,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -417,1 +480,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5325,0 +5401,6 @@\n+\n+    \/\/ code reflection\n+\n+    public boolean isQuoted(Type type) {\n+        return type.tsym == syms.quotedType.tsym;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":96,"deletions":14,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import com.sun.tools.javac.code.Types;\n@@ -107,0 +108,2 @@\n+    private final Types types;\n+\n@@ -131,0 +134,1 @@\n+        types = Types.instance(context);\n@@ -562,11 +566,16 @@\n-            try {\n-                \/\/compute target-type; this logic could be shared with Attr\n-                TargetInfo targetInfo = attr.getTargetInfo(speculativeTree, resultInfo, argtypes());\n-                Type lambdaType = targetInfo.descriptor;\n-                Type currentTarget = targetInfo.target;\n-                \/\/check compatibility\n-                checkLambdaCompatible(lambdaType, resultInfo);\n-                return currentTarget;\n-            } catch (FunctionDescriptorLookupError ex) {\n-                resultInfo.checkContext.report(null, ex.getDiagnostic());\n-                return null; \/\/cannot get here\n+            if (types.isQuoted(resultInfo.pt)) {\n+                \/\/ quoted lambda - always correct\n+                return resultInfo.pt;\n+            } else {\n+                try {\n+                    \/\/compute target-type; this logic could be shared with Attr\n+                    TargetInfo targetInfo = attr.getTargetInfo(speculativeTree, resultInfo, argtypes());\n+                    Type lambdaType = targetInfo.descriptor;\n+                    Type currentTarget = targetInfo.target;\n+                    \/\/check compatibility\n+                    checkLambdaCompatible(lambdaType, resultInfo);\n+                    return currentTarget;\n+                } catch (FunctionDescriptorLookupError ex) {\n+                    resultInfo.checkContext.report(null, ex.getDiagnostic());\n+                    return null; \/\/cannot get here\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -64,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -426,0 +432,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3118,0 +3137,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3261,0 +3288,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -837,1 +837,1 @@\n-                if (!inferenceContext.inferencevars.contains(pt)) {\n+                if (!types.isQuoted(pt) && !inferenceContext.inferencevars.contains(pt)) {\n@@ -1229,1 +1229,1 @@\n-            if (!types.isFunctionalInterface(pt)) {\n+            if (types.isQuoted(pt) || !types.isFunctionalInterface(pt)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -442,0 +445,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                syntheticInits.append(capturedArg);\n+            }\n+        }\n+\n@@ -523,0 +532,6 @@\n+        if (context.isQuotable()) {\n+            for (JCExpression capturedArg : tree.codeReflectionInfo.capturedArgs()) {\n+                indy_args = indy_args.append(capturedArg);\n+            }\n+        }\n+\n@@ -924,0 +939,1 @@\n+                slam.codeReflectionInfo = tree.codeReflectionInfo;\n@@ -1143,0 +1159,1 @@\n+                    t.tsym != syms.quotableType.tsym &&\n@@ -1149,0 +1166,1 @@\n+            flags |= context.isQuotable() ? FLAG_QUOTABLE : 0;\n@@ -1171,0 +1189,4 @@\n+            if (context.isQuotable()) {\n+                VarSymbol reflectField = (VarSymbol)tree.codeReflectionInfo.quotedField();\n+                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+            }\n@@ -1865,0 +1887,1 @@\n+                        isQuotable() ||\n@@ -1875,0 +1898,4 @@\n+\n+            boolean isQuotable() {\n+                return tree.codeReflectionInfo != null;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,2625 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.source.tree.LambdaExpressionTree;\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.ArrayType;\n+import com.sun.tools.javac.code.Type.ClassType;\n+import com.sun.tools.javac.code.Type.IntersectionClassType;\n+import com.sun.tools.javac.code.Type.MethodType;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.code.Type.UnionClassType;\n+import com.sun.tools.javac.code.Type.WildcardType;\n+import com.sun.tools.javac.code.TypeTag;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.comp.DeferredAttr.FilterScanner;\n+import com.sun.tools.javac.jvm.ByteCodes;\n+import com.sun.tools.javac.jvm.Gen;\n+import com.sun.tools.javac.resources.CompilerProperties.Notes;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCArrayAccess;\n+import com.sun.tools.javac.tree.JCTree.JCAssign;\n+import com.sun.tools.javac.tree.JCTree.JCBinary;\n+import com.sun.tools.javac.tree.JCTree.JCBlock;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression;\n+import com.sun.tools.javac.tree.JCTree.JCFunctionalExpression.CodeReflectionInfo;\n+import com.sun.tools.javac.tree.JCTree.JCIdent;\n+import com.sun.tools.javac.tree.JCTree.JCLambda;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.JCNewArray;\n+import com.sun.tools.javac.tree.JCTree.JCNewClass;\n+import com.sun.tools.javac.tree.JCTree.JCReturn;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.tree.JCTree.JCAssert;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Log;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+import com.sun.tools.javac.util.Options;\n+import jdk.internal.java.lang.reflect.code.*;\n+import jdk.internal.java.lang.reflect.code.op.CoreOps;\n+import jdk.internal.java.lang.reflect.code.op.ExtendedOps;\n+import jdk.internal.java.lang.reflect.code.type.*;\n+import jdk.internal.java.lang.reflect.code.type.WildcardType.BoundKind;\n+\n+import javax.lang.model.element.Modifier;\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.sun.tools.javac.code.Flags.PARAMETER;\n+import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.TypeTag.BOT;\n+import static com.sun.tools.javac.code.TypeTag.METHOD;\n+import static com.sun.tools.javac.code.TypeTag.NONE;\n+import static com.sun.tools.javac.main.Option.G_CUSTOM;\n+\n+\/**\n+ * This a tree translator that adds the code model to all method declaration marked\n+ * with the {@code CodeReflection} annotation. The model is expressed using the code\n+ * reflection API (see jdk.internal.java.lang.reflect.code).\n+ *\/\n+public class ReflectMethods extends TreeTranslator {\n+    protected static final Context.Key<ReflectMethods> reflectMethodsKey = new Context.Key<>();\n+\n+    public static ReflectMethods instance(Context context) {\n+        ReflectMethods instance = context.get(reflectMethodsKey);\n+        if (instance == null)\n+            instance = new ReflectMethods(context);\n+        return instance;\n+    }\n+\n+    private final Types types;\n+    private final Names names;\n+    private final Symtab syms;\n+    private final Gen gen;\n+    private final Log log;\n+    private final boolean dumpIR;\n+    private final boolean lineDebugInfo;\n+\n+    \/\/ @@@ Separate out mutable state\n+    private TreeMaker make;\n+    private ListBuffer<JCTree> classOps;\n+    \/\/ Also used by BodyScanner\n+    private Symbol.ClassSymbol currentClassSym;\n+    private int lambdaCount;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ReflectMethods(Context context) {\n+        context.put(reflectMethodsKey, this);\n+        Options options = Options.instance(context);\n+        dumpIR = options.isSet(\"dumpIR\");\n+        lineDebugInfo =\n+                options.isUnset(G_CUSTOM) ||\n+                        options.isSet(G_CUSTOM, \"lines\");\n+        names = Names.instance(context);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        gen = Gen.instance(context);\n+        log = Log.instance(context);\n+\n+\n+    }\n+\n+    \/\/ Cannot compute within constructor due to circular dependencies on bootstrap compilation\n+    \/\/ syms.objectType == null\n+    private Map<JavaType, Type> primitiveAndBoxTypeMap;\n+    Map<JavaType, Type> primitiveAndBoxTypeMap() {\n+        Map<JavaType, Type> m = primitiveAndBoxTypeMap;\n+        if (m == null) {\n+            m = primitiveAndBoxTypeMap = Map.ofEntries(\n+                    Map.entry(JavaType.BOOLEAN, syms.booleanType),\n+                    Map.entry(JavaType.BYTE, syms.byteType),\n+                    Map.entry(JavaType.SHORT, syms.shortType),\n+                    Map.entry(JavaType.CHAR, syms.charType),\n+                    Map.entry(JavaType.INT, syms.intType),\n+                    Map.entry(JavaType.LONG, syms.longType),\n+                    Map.entry(JavaType.FLOAT, syms.floatType),\n+                    Map.entry(JavaType.DOUBLE, syms.doubleType),\n+                    Map.entry(JavaType.J_L_OBJECT, syms.objectType),\n+                    Map.entry(JavaType.J_L_BOOLEAN, types.boxedTypeOrType(syms.booleanType)),\n+                    Map.entry(JavaType.J_L_BYTE, types.boxedTypeOrType(syms.byteType)),\n+                    Map.entry(JavaType.J_L_SHORT, types.boxedTypeOrType(syms.shortType)),\n+                    Map.entry(JavaType.J_L_CHARACTER, types.boxedTypeOrType(syms.charType)),\n+                    Map.entry(JavaType.J_L_INTEGER, types.boxedTypeOrType(syms.intType)),\n+                    Map.entry(JavaType.J_L_LONG, types.boxedTypeOrType(syms.longType)),\n+                    Map.entry(JavaType.J_L_FLOAT, types.boxedTypeOrType(syms.floatType)),\n+                    Map.entry(JavaType.J_L_DOUBLE, types.boxedTypeOrType(syms.doubleType))\n+            );\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        if (tree.sym.attribute(syms.codeReflectionType.tsym) != null) {\n+            \/\/ if the method is annotated, scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanMethod();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.MethodIrDump(tree.sym.enclClass(), tree.sym, funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                classOps.add(opFieldDecl(tree.name, tree.getModifiers().flags, funcOp));\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the method body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.MethodIrSkip(tree.sym.enclClass(), tree.sym, ex.tree.getTag().toString()));\n+            }\n+        }\n+        super.visitMethodDef(tree);\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ListBuffer<JCTree> prevClassOps = classOps;\n+        Symbol.ClassSymbol prevClassSym = currentClassSym;\n+        int prevLambdaCount = lambdaCount;\n+        try {\n+            lambdaCount = 0;\n+            currentClassSym = tree.sym;\n+            classOps = new ListBuffer<>();\n+            super.visitClassDef(tree);\n+            tree.defs = tree.defs.prependList(classOps.toList());\n+        } finally {\n+            lambdaCount = prevLambdaCount;\n+            classOps = prevClassOps;\n+            currentClassSym = prevClassSym;\n+            result = tree;\n+        }\n+    }\n+\n+    @Override\n+    public void visitLambda(JCLambda tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(tree, kind);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, null);\n+\n+                switch (kind) {\n+                    case QUOTED_STRUCTURAL -> {\n+                        JCIdent opFieldId = make.Ident(opField.sym);\n+                        ListBuffer<JCExpression> interpreterArgs = new ListBuffer<>();\n+                        JCMethodInvocation parsedOp = make.App(make.Ident(syms.opParserFromString), com.sun.tools.javac.util.List.of(opFieldId));\n+                        interpreterArgs.append(parsedOp);\n+                        \/\/ append captured vars\n+                        interpreterArgs.appendList(capturedArgs.toList());\n+\n+                        JCMethodInvocation interpreterInvoke = make.App(make.Ident(syms.opInterpreterInvoke), interpreterArgs.toList());\n+                        interpreterInvoke.varargsElement = syms.objectType;\n+                        super.visitLambda(tree);\n+                        result = interpreterInvoke;\n+                    }\n+                    case QUOTABLE -> {\n+                        \/\/ leave the lambda in place, but also leave a trail for LambdaToMethod\n+                        tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                        super.visitLambda(tree);\n+                    }\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitLambda(tree);\n+        }\n+    }\n+\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        FunctionalExpressionKind kind = functionalKind(tree);\n+        Assert.check(kind != FunctionalExpressionKind.QUOTED_STRUCTURAL,\n+                \"structural quoting not supported for method references\");\n+        MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+        JCVariableDecl recvDecl = memberReferenceToLambda.receiverVar();\n+        JCLambda lambdaTree = memberReferenceToLambda.lambda();\n+\n+        if (kind.isQuoted) {\n+            \/\/ quoted lambda - scan it\n+            BodyScanner bodyScanner = new BodyScanner(lambdaTree, kind);\n+            try {\n+                CoreOps.FuncOp funcOp = bodyScanner.scanLambda();\n+                if (dumpIR) {\n+                    \/\/ dump the method IR if requested\n+                    log.note(Notes.QuotedIrDump(funcOp.toText()));\n+                }\n+                \/\/ create a static final field holding the op' string text.\n+                \/\/ The name of the field is foo$op, where 'foo' is the name of the corresponding method.\n+                JCVariableDecl opField = opFieldDecl(lambdaName(), 0, funcOp);\n+                classOps.add(opField);\n+                ListBuffer<JCExpression> capturedArgs = quotedCapturedArgs(tree, bodyScanner, recvDecl);\n+                tree.codeReflectionInfo = new CodeReflectionInfo(opField.sym, capturedArgs.toList());\n+                super.visitReference(tree);\n+                if (recvDecl != null) {\n+                    result = copyReferenceWithReceiverVar(tree, recvDecl);\n+                }\n+            } catch (UnsupportedASTException ex) {\n+                \/\/ whoops, some AST node inside the quoted lambda body were not supported. Log it and move on.\n+                log.note(ex.tree, Notes.QuotedIrSkip(ex.tree.getTag().toString()));\n+                result = tree;\n+            }\n+        } else {\n+            super.visitReference(tree);\n+        }\n+    }\n+\n+    ListBuffer<JCExpression> quotedCapturedArgs(DiagnosticPosition pos, BodyScanner bodyScanner, JCVariableDecl recvDecl) {\n+        ListBuffer<JCExpression> capturedArgs = new ListBuffer<>();\n+        for (Symbol capturedSym : bodyScanner.stack.localToOp.keySet()) {\n+            if (capturedSym.kind == Kind.TYP) {\n+                \/\/ captured this\n+                capturedArgs.add(make.at(pos).This(capturedSym.type));\n+            } else if (recvDecl != null && capturedSym == recvDecl.sym) {\n+                \/\/ captured method reference receiver\n+                capturedArgs.add(make.at(pos).Ident(recvDecl.sym));\n+            } else if (capturedSym.kind == Kind.VAR) {\n+                \/\/ captured var\n+                VarSymbol var = (VarSymbol)capturedSym;\n+                if (var.getConstValue() == null) {\n+                    capturedArgs.add(make.at(pos).Ident(capturedSym));\n+                } else {\n+                    capturedArgs.add(make.at(pos).Literal(var.getConstValue()));\n+                }\n+            } else {\n+                throw new AssertionError(\"Unexpected captured symbol: \" + capturedSym);\n+            }\n+        }\n+        return capturedArgs;\n+    }\n+\n+    \/*\n+     * Creates a let expression of the kind:\n+     * let $recv in $recv::memberRef\n+     *\n+     * This is required to make sure that LambdaToMethod doesn't end up emitting the\n+     * code for capturing the bound method reference receiver twice.\n+     *\/\n+    JCExpression copyReferenceWithReceiverVar(JCMemberReference ref, JCVariableDecl recvDecl) {\n+        JCMemberReference newRef = make.at(ref).Reference(ref.mode, ref.name, make.Ident(recvDecl.sym), ref.typeargs);\n+        newRef.type = ref.type;\n+        newRef.target = ref.target;\n+        newRef.refPolyKind = ref.refPolyKind;\n+        newRef.referentType = ref.referentType;\n+        newRef.kind = ref.kind;\n+        newRef.varargsElement = ref.varargsElement;\n+        newRef.ownerAccessible = ref.ownerAccessible;\n+        newRef.sym = ref.sym;\n+        newRef.codeReflectionInfo = ref.codeReflectionInfo;\n+        return make.at(ref).LetExpr(recvDecl, newRef).setType(newRef.type);\n+    }\n+\n+    Name lambdaName() {\n+        return names.fromString(\"lambda\").append('$', names.fromString(String.valueOf(lambdaCount++)));\n+    }\n+\n+    private JCVariableDecl opFieldDecl(Name prefix, long flags, CoreOps.FuncOp op) {\n+        VarSymbol opFieldSym = new VarSymbol(flags | Flags.STATIC | Flags.FINAL | Flags.SYNTHETIC,\n+                prefix.append('$', names.fromString(\"op\")),\n+                syms.stringType,\n+                currentClassSym);\n+\n+        currentClassSym.members().enter(opFieldSym);\n+        JCLiteral opText = make.Literal(op.toText());\n+        JCVariableDecl opFieldTree = make.VarDef(opFieldSym, opText);\n+        return opFieldTree;\n+    }\n+\n+    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+        \/\/ note that this method does NOT support recursion.\n+        this.make = make;\n+        JCTree res = translate(cdef);\n+        return res;\n+    }\n+\n+    public CoreOps.FuncOp getMethodBody(Symbol.ClassSymbol classSym, JCMethodDecl methodDecl, JCBlock attributedBody, TreeMaker make) {\n+        \/\/ if the method is annotated, scan it\n+        \/\/ Called from JavacElements::getBody\n+        try {\n+            this.make = make;\n+            currentClassSym = classSym;\n+            BodyScanner bodyScanner = new BodyScanner(methodDecl, attributedBody);\n+            return bodyScanner.scanMethod();\n+        } finally {\n+            currentClassSym = null;\n+            this.make = null;\n+        }\n+    }\n+\n+    static class BodyStack {\n+        final BodyStack parent;\n+\n+        \/\/ Tree associated with body\n+        final JCTree tree;\n+\n+        \/\/ Body to add blocks\n+        final Body.Builder body;\n+        \/\/ Current block to add operations\n+        Block.Builder block;\n+\n+        \/\/ Map of symbols (method arguments and local variables) to varOp values\n+        final Map<Symbol, Value> localToOp;\n+\n+        \/\/ Label\n+        Map.Entry<String, Op.Result> label;\n+\n+        BodyStack(BodyStack parent, JCTree tree, FunctionType bodyType) {\n+            this.parent = parent;\n+\n+            this.tree = tree;\n+\n+            this.body = Body.Builder.of(parent != null ? parent.body : null, bodyType);\n+            this.block = body.entryBlock();\n+\n+            this.localToOp = new LinkedHashMap<>(); \/\/ order is important for captured values\n+        }\n+\n+        public void setLabel(String labelName, Op.Result labelValue) {\n+            if (label != null) {\n+                throw new IllegalStateException(\"Label already defined: \" + labelName);\n+            }\n+            label = Map.entry(labelName, labelValue);\n+        }\n+    }\n+\n+    class BodyScanner extends FilterScanner {\n+        private final JCTree body;\n+        private final Name name;\n+        private final BodyStack top;\n+        private BodyStack stack;\n+        private Op lastOp;\n+        private Value result;\n+        private Type pt = Type.noType;\n+        private boolean isQuoted;\n+        private Type bodyTarget;\n+        private JCTree currentNode;\n+\n+        \/\/ Only few AST nodes supported for now\n+        private static final Set<JCTree.Tag> SUPPORTED_TAGS =\n+                Set.of(Tag.VARDEF,\n+                        Tag.RETURN, Tag.THROW, Tag.BREAK, Tag.CONTINUE,\n+                        Tag.PLUS, Tag.MINUS, Tag.MUL, Tag.DIV, Tag.MOD,\n+                        Tag.NEG, Tag.NOT,\n+                        Tag.BITOR, Tag.BITAND, Tag.BITXOR,\n+                        Tag.SL, Tag.SR, Tag.USR,\n+                        Tag.PLUS_ASG, Tag.MINUS_ASG, Tag.MUL_ASG, Tag.DIV_ASG, Tag.MOD_ASG,\n+                        Tag.POSTINC, Tag.PREINC, Tag.POSTDEC, Tag.PREDEC,\n+                        Tag.EQ, Tag.NE, Tag.LT, Tag.LE, Tag.GT, Tag.GE,\n+                        Tag.AND, Tag.OR,\n+                        Tag.LITERAL, Tag.IDENT, Tag.TYPEIDENT, Tag.ASSIGN, Tag.EXEC, Tag.PARENS,\n+                        Tag.SELECT, Tag.INDEXED, Tag.APPLY,\n+                        Tag.TYPECAST, Tag.TYPETEST,\n+                        Tag.NEWCLASS, Tag.NEWARRAY, Tag.LAMBDA, Tag.REFERENCE,\n+                        Tag.BLOCK, Tag.IF, Tag.WHILELOOP, Tag.DOLOOP, Tag.FOREACHLOOP, Tag.FORLOOP, Tag.TRY,\n+                        Tag.SWITCH_EXPRESSION, Tag.YIELD,\n+                        Tag.CONDEXPR,\n+                        Tag.ASSERT,\n+                        Tag.LABELLED,\n+                        Tag.SKIP,\n+                        Tag.TYPEARRAY);\n+\n+        BodyScanner(JCMethodDecl tree) {\n+            this(tree, tree.body);\n+        }\n+\n+        BodyScanner(JCMethodDecl tree, JCBlock body) {\n+            super(SUPPORTED_TAGS);\n+\n+            this.currentNode = tree;\n+            this.body = body;\n+            this.name = tree.name;\n+            this.isQuoted = false;\n+\n+            List<TypeElement> parameters = new ArrayList<>();\n+            int blockArgOffset = 0;\n+            \/\/ Instance methods model \"this\" as an additional argument occurring\n+            \/\/ before all other arguments.\n+            \/\/ @@@ Inner classes.\n+            \/\/ We need to capture all \"this\", in nested order, as arguments.\n+            if (!tree.getModifiers().getFlags().contains(Modifier.STATIC)) {\n+                parameters.add(typeToTypeElement(tree.sym.owner.type));\n+                blockArgOffset++;\n+            }\n+            tree.sym.type.getParameterTypes().stream().map(this::typeToTypeElement).forEach(parameters::add);\n+\n+            FunctionType bodyType = FunctionType.functionType(\n+                    typeToTypeElement(tree.sym.type.getReturnType()), parameters);\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, bodyType);\n+\n+            \/\/ @@@ this as local variable? (it can never be stored to)\n+            for (int i = 0 ; i < tree.params.size() ; i++) {\n+                Op.Result paramOp = append(CoreOps.var(\n+                        tree.params.get(i).name.toString(),\n+                        top.block.parameters().get(blockArgOffset + i)));\n+                top.localToOp.put(tree.params.get(i).sym, paramOp);\n+            }\n+\n+            bodyTarget = tree.sym.type.getReturnType();\n+        }\n+\n+        BodyScanner(JCLambda tree, FunctionalExpressionKind kind) {\n+            super(SUPPORTED_TAGS);\n+            assert kind != FunctionalExpressionKind.NOT_QUOTED;\n+\n+            this.currentNode = tree;\n+            this.body = tree;\n+            this.name = names.fromString(\"quotedLambda\");\n+            this.isQuoted = true;\n+\n+            com.sun.tools.javac.util.List<Type> nil = com.sun.tools.javac.util.List.nil();\n+            MethodType mtype = new MethodType(nil, syms.quotedType, nil, syms.methodClass);\n+            FunctionType mtDesc = FunctionType.functionType(typeToTypeElement(mtype.restype),\n+                    mtype.getParameterTypes().map(this::typeToTypeElement));\n+\n+            this.stack = this.top = new BodyStack(null, tree.body, mtDesc);\n+\n+            bodyTarget = tree.target.getReturnType();\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            JCTree prev = currentNode;\n+            currentNode = tree;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                currentNode = prev;\n+            }\n+        }\n+\n+        void pushBody(JCTree tree, FunctionType bodyType) {\n+            stack = new BodyStack(stack, tree, bodyType);\n+            lastOp = null; \/\/ reset\n+        }\n+\n+        void popBody() {\n+            stack = stack.parent;\n+        }\n+\n+        Value varOpValue(Symbol sym) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                Value v = s.localToOp.get(sym);\n+                if (v != null) {\n+                    return v;\n+                }\n+                s = s.parent;\n+            }\n+            if (isQuoted) {\n+                return capturedOpValue(sym);\n+            } else {\n+                throw new NoSuchElementException(sym.toString());\n+            }\n+        }\n+\n+        Value capturedOpValue(Symbol sym) {\n+            var capturedVar = top.localToOp.get(sym);\n+            if (capturedVar == null) {\n+                var capturedArg = top.block.parameter(typeToTypeElement(sym.type));\n+                capturedVar = top.block.op(CoreOps.var(sym.name.toString(), capturedArg));\n+                top.localToOp.put(sym, capturedVar);\n+            }\n+            return capturedVar;\n+        }\n+\n+        Value thisValue() { \/\/ @@@: outer this?\n+            if (isQuoted) {\n+                \/\/ capture this - add captured class symbol to the stack top local mappings\n+                var capturedThis = top.localToOp.get(currentClassSym);\n+                if (capturedThis == null) {\n+                    capturedThis = top.block.parameter(typeToTypeElement(currentClassSym.type));\n+                    top.localToOp.put(currentClassSym, capturedThis);\n+                }\n+                return capturedThis;\n+            } else {\n+                return top.block.parameters().get(0);\n+            }\n+        }\n+\n+        Value getLabel(String labelName) {\n+            BodyStack s = stack;\n+            while (s != null) {\n+                if (s.label != null && s.label.getKey().equals(labelName)) {\n+                    return s.label.getValue();\n+                }\n+                s = s.parent;\n+            }\n+            throw new NoSuchElementException(labelName);\n+        }\n+\n+        private Op.Result append(Op op) {\n+            return append(op, generateLocation(currentNode, false), stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l) {\n+            return append(op, l, stack);\n+        }\n+\n+        private Op.Result append(Op op, Location l, BodyStack stack) {\n+            lastOp = op;\n+            op.setLocation(l);\n+            return stack.block.apply(op);\n+        }\n+\n+        Location generateLocation(JCTree node, boolean includeSourceReference) {\n+            if (!lineDebugInfo) {\n+                return Location.NO_LOCATION;\n+            }\n+\n+            int pos = node.getStartPosition();\n+            int line = log.currentSource().getLineNumber(pos);\n+            int col = log.currentSource().getColumnNumber(pos, false);\n+            String path;\n+            if (includeSourceReference) {\n+                path = log.currentSource().getFile().toUri().toString();\n+            } else {\n+                path = null;\n+            }\n+            return new Location(path, line, col);\n+        }\n+\n+        private <O extends Op & Op.Terminating> void appendTerminating(Supplier<O> sop) {\n+            \/\/ Append only if an existing terminating operation is not present\n+            if (lastOp == null || !(lastOp instanceof Op.Terminating)) {\n+                append(sop.get());\n+            }\n+        }\n+\n+        public Value toValue(JCTree tree) {\n+            return toValue(tree, Type.noType);\n+        }\n+\n+        public Value toValue(JCTree tree, Type target) {\n+            result = null; \/\/ reset\n+            Type prevPt = pt;\n+            try {\n+                pt = target;\n+                scan(tree);\n+                return result != null ?\n+                        coerce(result, tree.type, target) :\n+                        null;\n+            } finally {\n+                pt = prevPt;\n+            }\n+        }\n+\n+        Value coerce(Value sourceValue, Type sourceType, Type targetType) {\n+            if (sourceType.isReference() && targetType.isReference() &&\n+                    !types.isSubtype(types.erasure(sourceType), types.erasure(targetType))) {\n+                return append(CoreOps.cast(typeToTypeElement(targetType), sourceValue));\n+            } else {\n+                return convert(sourceValue, targetType);\n+            }\n+        }\n+\n+        Value boxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.boxedTypeOrType(source));\n+        }\n+\n+        Value unboxIfNeeded(Value exprVal) {\n+            Type source = typeElementToType(exprVal.type());\n+            return source.hasTag(NONE) ?\n+                    exprVal : convert(exprVal, types.unboxedTypeOrType(source));\n+        }\n+\n+        Value convert(Value exprVal, Type target) {\n+            Type source = typeElementToType(exprVal.type());\n+            boolean sourcePrimitive = source.isPrimitive();\n+            boolean targetPrimitive = target.isPrimitive();\n+            if (target.hasTag(NONE)) {\n+                return exprVal;\n+            } else if (sourcePrimitive == targetPrimitive) {\n+                if (!sourcePrimitive || types.isSameType(source, target)) {\n+                    return exprVal;\n+                } else {\n+                    \/\/ implicit primitive conversion\n+                    return append(CoreOps.conv(typeToTypeElement(target), exprVal));\n+                }\n+            } else if (sourcePrimitive) {\n+                \/\/ we need to box\n+                Type unboxedTarget = types.unboxedType(target);\n+                if (!unboxedTarget.hasTag(NONE)) {\n+                    \/\/ non-Object target\n+                    return box(exprVal, target);\n+                } else {\n+                    \/\/ Object target\n+                    return box(exprVal, types.boxedClass(source).type);\n+                }\n+            } else {\n+                \/\/ we need to unbox\n+                return unbox(exprVal, source, target, types.unboxedType(source));\n+            }\n+        }\n+\n+        Value box(Value valueExpr, Type box) {\n+            \/\/ Boxing is a static method e.g., java.lang.Integer::valueOf(int)java.lang.Integer\n+            MethodRef boxMethod = MethodRef.method(typeToTypeElement(box), names.valueOf.toString(),\n+                    FunctionType.functionType(typeToTypeElement(box), typeToTypeElement(types.unboxedType(box))));\n+            return append(CoreOps.invoke(boxMethod, valueExpr));\n+        }\n+\n+        Value unbox(Value valueExpr, Type box, Type primitive, Type unboxedType) {\n+            if (unboxedType.hasTag(NONE)) {\n+                \/\/ Object target, first downcast to correct wrapper type\n+                unboxedType = primitive;\n+                box = types.boxedClass(unboxedType).type;\n+                valueExpr = append(CoreOps.cast(typeToTypeElement(box), valueExpr));\n+            }\n+            \/\/ Unboxing is a virtual method e.g., java.lang.Integer::intValue()int\n+            MethodRef unboxMethod = MethodRef.method(typeToTypeElement(box),\n+                    unboxedType.tsym.name.append(names.Value).toString(),\n+                    FunctionType.functionType(typeToTypeElement(unboxedType)));\n+            return append(CoreOps.invoke(unboxMethod, valueExpr));\n+        }\n+\n+        @Override\n+        void skip(JCTree tree) {\n+            \/\/ this method is called for unsupported AST nodes (see 'SUPPORTED_TAGS')\n+            throw unsupported(tree);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            Value initOp;\n+            if (tree.init != null) {\n+                initOp = toValue(tree.init, tree.type);\n+            } else {\n+                initOp = append(defaultValue(tree.type));\n+            }\n+            result = append(CoreOps.var(tree.name.toString(), typeToTypeElement(tree.type), initOp));\n+            stack.localToOp.put(tree.sym, result);\n+        }\n+\n+        @Override\n+        public void visitAssign(JCAssign tree) {\n+            \/\/ Consume top node that applies to write access\n+            JCTree lhs = TreeInfo.skipParens(tree.lhs);\n+            Type target = tree.lhs.type;\n+            switch (lhs.getTag()) {\n+                case IDENT: {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+                            append(CoreOps.varStore(varOp, result));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fd = symbolToFieldRef(sym, symbolSiteType(sym));\n+                            if (sym.isStatic()) {\n+                                append(CoreOps.fieldStore(fd, result));\n+                            } else {\n+                                append(CoreOps.fieldStore(fd, thisValue(), result));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(tree);\n+                        }\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+                    if (sym.isStatic()) {\n+                        append(CoreOps.fieldStore(fr, result));\n+                    } else {\n+                        append(CoreOps.fieldStore(fr, receiver, result));\n+                    }\n+                    break;\n+                }\n+                case INDEXED: {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    \/\/ Scan the rhs, the assign expression result is its input\n+                    result = toValue(tree.rhs, target);\n+\n+                    append(CoreOps.arrayStoreOp(array, index, result));\n+                    break;\n+                }\n+                default:\n+                    throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitAssignop(JCTree.JCAssignOp tree) {\n+            \/\/ Capture applying rhs and operation\n+            Function<Value, Value> scanRhs = (lhs) -> {\n+                Type unboxedType = types.unboxedTypeOrType(tree.type);\n+                JavaType resultType = typeToTypeElement(unboxedType);\n+                Value rhs = toValue(tree.rhs, unboxedType);\n+                lhs = unboxIfNeeded(lhs);\n+\n+                Value assignOpResult = switch (tree.getTag()) {\n+\n+                    \/\/ Arithmetic operations\n+                    case PLUS_ASG -> append(CoreOps.add(lhs, rhs));\n+                    case MINUS_ASG -> append(CoreOps.sub(lhs, rhs));\n+                    case MUL_ASG -> append(CoreOps.mul(lhs, rhs));\n+                    case DIV_ASG -> append(CoreOps.div(lhs, rhs));\n+                    case MOD_ASG -> append(CoreOps.mod(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+                return result = convert(assignOpResult, tree.type);\n+            };\n+\n+            applyCompoundAssign(tree.lhs, scanRhs);\n+        }\n+\n+        void applyCompoundAssign(JCTree.JCExpression lhs, Function<Value, Value> scanRhs) {\n+            \/\/ Consume top node that applies to access\n+            lhs = TreeInfo.skipParens(lhs);\n+            switch (lhs.getTag()) {\n+                case IDENT -> {\n+                    JCIdent assign = (JCIdent) lhs;\n+\n+                    Symbol sym = assign.sym;\n+                    switch (sym.getKind()) {\n+                        case LOCAL_VARIABLE, PARAMETER -> {\n+                            Value varOp = varOpValue(sym);\n+\n+                            Op.Result lhsOpValue = append(CoreOps.varLoad(varOp));\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            append(CoreOps.varStore(varOp, r));\n+                        }\n+                        case FIELD -> {\n+                            FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+\n+                            Op.Result lhsOpValue;\n+                            TypeElement resultType = typeToTypeElement(sym.type);\n+                            if (sym.isStatic()) {\n+                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fr));\n+                            } else {\n+                                lhsOpValue = append(CoreOps.fieldLoad(resultType, fr, thisValue()));\n+                            }\n+                            \/\/ Scan the rhs\n+                            Value r = scanRhs.apply(lhsOpValue);\n+\n+                            if (sym.isStatic()) {\n+                                append(CoreOps.fieldStore(fr, r));\n+                            } else {\n+                                append(CoreOps.fieldStore(fr, thisValue(), r));\n+                            }\n+                        }\n+                        default -> {\n+                            \/\/ @@@ Cannot reach here?\n+                            throw unsupported(lhs);\n+                        }\n+                    }\n+                }\n+                case SELECT -> {\n+                    JCFieldAccess assign = (JCFieldAccess) lhs;\n+\n+                    Value receiver = toValue(assign.selected);\n+\n+                    Symbol sym = assign.sym;\n+                    FieldRef fr = symbolToFieldRef(sym, assign.selected.type);\n+\n+                    Op.Result lhsOpValue;\n+                    TypeElement resultType = typeToTypeElement(sym.type);\n+                    if (sym.isStatic()) {\n+                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fr));\n+                    } else {\n+                        lhsOpValue = append(CoreOps.fieldLoad(resultType, fr, receiver));\n+                    }\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    if (sym.isStatic()) {\n+                        append(CoreOps.fieldStore(fr, r));\n+                    } else {\n+                        append(CoreOps.fieldStore(fr, receiver, r));\n+                    }\n+                }\n+                case INDEXED -> {\n+                    JCArrayAccess assign = (JCArrayAccess) lhs;\n+\n+                    Value array = toValue(assign.indexed);\n+                    Value index = toValue(assign.index);\n+\n+                    Op.Result lhsOpValue = append(CoreOps.arrayLoadOp(array, index));\n+                    \/\/ Scan the rhs\n+                    Value r = scanRhs.apply(lhsOpValue);\n+\n+                    append(CoreOps.arrayStoreOp(array, index, r));\n+                }\n+                default -> throw unsupported(lhs);\n+            }\n+        }\n+\n+        @Override\n+        public void visitIdent(JCIdent tree) {\n+            \/\/ Visited only for read access\n+\n+            Symbol sym = tree.sym;\n+            switch (sym.getKind()) {\n+                case LOCAL_VARIABLE, RESOURCE_VARIABLE, BINDING_VARIABLE, PARAMETER, EXCEPTION_PARAMETER -> {\n+                    Value varOp = varOpValue(sym);\n+                    if (varOp.type() instanceof VarType) {\n+                        \/\/ regular var\n+                        result = append(CoreOps.varLoad(varOp));\n+                    } else {\n+                        \/\/ captured value\n+                        result = varOp;\n+                    }\n+                }\n+                case FIELD, ENUM_CONSTANT -> {\n+                    if (sym.name.equals(names._this)) {\n+                        result = thisValue();\n+                    } else {\n+                        FieldRef fr = symbolToFieldRef(sym, symbolSiteType(sym));\n+                        TypeElement resultType = typeToTypeElement(sym.type);\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOps.fieldLoad(resultType, fr));\n+                        } else {\n+                            result = append(CoreOps.fieldLoad(resultType, fr, thisValue()));\n+                        }\n+                    }\n+                }\n+                case INTERFACE, CLASS, ENUM -> {\n+                    result = null;\n+                }\n+                default -> {\n+                    \/\/ @@@ Cannot reach here?\n+                    throw unsupported(tree);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeIdent(JCTree.JCPrimitiveTypeTree tree) {\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitTypeArray(JCTree.JCArrayTypeTree tree) {\n+            result = null; \/\/ MyType[].class is handled in visitSelect just as MyType.class\n+        }\n+\n+        @Override\n+        public void visitSelect(JCFieldAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Type qualifierTarget = qualifierTarget(tree);\n+            \/\/ @@@: might cause redundant load if accessed symbol is static but the qualifier is not a type\n+            Value receiver = toValue(tree.selected);\n+\n+            if (tree.name.equals(names._class)) {\n+                result = append(CoreOps.constant(JavaType.J_L_CLASS, typeToTypeElement(tree.selected.type)));\n+            } else if (types.isArray(tree.selected.type)) {\n+                if (tree.sym.equals(syms.lengthVar)) {\n+                    result = append(CoreOps.arrayLength(receiver));\n+                } else {\n+                    \/\/ Should not reach here\n+                    throw unsupported(tree);\n+                }\n+            } else {\n+                Symbol sym = tree.sym;\n+                switch (sym.getKind()) {\n+                    case FIELD, ENUM_CONSTANT -> {\n+                        FieldRef fr = symbolToFieldRef(sym, qualifierTarget.hasTag(NONE) ?\n+                                tree.selected.type : qualifierTarget);\n+                        TypeElement resultType = typeToTypeElement(types.memberType(tree.selected.type, sym));\n+                        if (sym.isStatic()) {\n+                            result = append(CoreOps.fieldLoad(resultType, fr));\n+                        } else {\n+                            result = append(CoreOps.fieldLoad(resultType, fr, receiver));\n+                        }\n+                    }\n+                    case INTERFACE, CLASS, ENUM -> {\n+                        result = null;\n+                    }\n+                    default -> {\n+                        \/\/ @@@ Cannot reach here?\n+                        throw unsupported(tree);\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void visitIndexed(JCArrayAccess tree) {\n+            \/\/ Visited only for read access\n+\n+            Value array = toValue(tree.indexed);\n+\n+            Value index = toValue(tree.index);\n+\n+            result = append(CoreOps.arrayLoadOp(array, index));\n+        }\n+\n+        @Override\n+        public void visitApply(JCTree.JCMethodInvocation tree) {\n+            \/\/ @@@ Symbol.externalType, for use with inner classes\n+\n+            \/\/ @@@ this.xyz(...) calls in a constructor\n+\n+            \/\/ @@@ super.xyz(...) calls\n+            \/\/ Modeling with a call operation would result in the receiver type differing from that\n+            \/\/ in the method reference, perhaps that is sufficient?\n+\n+            JCTree meth = TreeInfo.skipParens(tree.meth);\n+            switch (meth.getTag()) {\n+                case IDENT: {\n+                    JCIdent access = (JCIdent) meth;\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    if (!sym.isStatic()) {\n+                        args.add(thisValue());\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, symbolSiteType(sym));\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                case SELECT: {\n+                    JCFieldAccess access = (JCFieldAccess) meth;\n+\n+                    Type qualifierTarget = qualifierTarget(access);\n+                    Value receiver = toValue(access.selected, qualifierTarget);\n+\n+                    Symbol sym = access.sym;\n+                    List<Value> args = new ArrayList<>();\n+                    if (!sym.isStatic()) {\n+                        args.add(receiver);\n+                    }\n+\n+                    args.addAll(scanMethodArguments(tree.args, tree.meth.type, tree.varargsElement));\n+\n+                    MethodRef mr = symbolToErasedMethodRef(sym, qualifierTarget.hasTag(NONE) ?\n+                            access.selected.type : qualifierTarget);\n+                    Value res = append(CoreOps.invoke(typeToTypeElement(meth.type.getReturnType()), mr, args));\n+                    if (sym.type.getReturnType().getTag() != TypeTag.VOID) {\n+                        result = res;\n+                    }\n+                    break;\n+                }\n+                default:\n+                    unsupported(meth);\n+            }\n+        }\n+\n+        List<Value> scanMethodArguments(List<JCExpression> args, Type methodType, Type varargsElement) {\n+            ListBuffer<Value> argValues = new ListBuffer<>();\n+            com.sun.tools.javac.util.List<Type> targetTypes = methodType.getParameterTypes();\n+            if (varargsElement != null) {\n+                targetTypes = targetTypes.reverse().tail;\n+                for (int i = 0 ; i < args.size() - (methodType.getParameterTypes().size() - 1) ; i++) {\n+                    targetTypes = targetTypes.prepend(varargsElement);\n+                }\n+                targetTypes = targetTypes.reverse();\n+            }\n+\n+            for (JCTree.JCExpression arg : args) {\n+                argValues.add(toValue(arg, targetTypes.head));\n+                targetTypes = targetTypes.tail;\n+            }\n+            return argValues.toList();\n+        }\n+\n+        @Override\n+        public void visitReference(JCTree.JCMemberReference tree) {\n+            MemberReferenceToLambda memberReferenceToLambda = new MemberReferenceToLambda(tree, currentClassSym);\n+            JCVariableDecl recv = memberReferenceToLambda.receiverVar();\n+            if (recv != null) {\n+                scan(recv);\n+            }\n+            scan(memberReferenceToLambda.lambda());\n+        }\n+\n+        Type qualifierTarget(JCFieldAccess tree) {\n+            Type selectedType = types.skipTypeVars(tree.selected.type, true);\n+            return selectedType.isCompound() ?\n+                    tree.sym.owner.type :\n+                    Type.noType;\n+        }\n+\n+        @Override\n+        public void visitTypeCast(JCTree.JCTypeCast tree) {\n+            Value v = toValue(tree.expr);\n+\n+            Type expressionType = tree.expr.type;\n+            Type type = tree.type;\n+            if (expressionType.isPrimitive() && type.isPrimitive()) {\n+                if (expressionType.equals(type)) {\n+                    \/\/ Redundant cast\n+                    result = v;\n+                } else {\n+                    result = append(CoreOps.conv(typeToTypeElement(type), v));\n+                }\n+            } else if (expressionType.isPrimitive() || type.isPrimitive()) {\n+                result = convert(v, tree.type);\n+            } else if (!expressionType.hasTag(BOT) &&\n+                    types.isAssignable(expressionType, type)) {\n+                \/\/ Redundant cast\n+                result = v;\n+            } else {\n+                \/\/ Reference cast\n+                JavaType jt = typeToTypeElement(types.erasure(type));\n+                result = append(CoreOps.cast(typeToTypeElement(type), jt, v));\n+            }\n+        }\n+\n+        @Override\n+        public void visitTypeTest(JCTree.JCInstanceOf tree) {\n+            Value target = toValue(tree.expr);\n+\n+            if (tree.pattern.getTag() != Tag.IDENT) {\n+                result = scanPattern(tree.getPattern(), target);\n+            } else {\n+                result = append(CoreOps.instanceOf(typeToTypeElement(tree.pattern.type), target));\n+            }\n+        }\n+\n+        Value scanPattern(JCTree.JCPattern pattern, Value target) {\n+            \/\/ Type of pattern\n+            JavaType patternType;\n+            if (pattern instanceof JCTree.JCBindingPattern p) {\n+                patternType = ExtendedOps.Pattern.bindingType(typeToTypeElement(p.type));\n+            } else if (pattern instanceof JCTree.JCRecordPattern p) {\n+                patternType = ExtendedOps.Pattern.recordType(typeToTypeElement(p.record.type));\n+            } else {\n+                throw unsupported(pattern);\n+            }\n+\n+            \/\/ Push pattern body\n+            pushBody(pattern, FunctionType.functionType(patternType));\n+\n+            \/\/ @@@ Assumes just pattern nodes, likely will change when method patterns are supported\n+            \/\/     that have expressions for any arguments (which perhaps in turn may have pattern expressions)\n+            List<JCVariableDecl> variables = new ArrayList<>();\n+            class PatternScanner extends FilterScanner {\n+\n+                private Value result;\n+\n+                public PatternScanner() {\n+                    super(Set.of(Tag.BINDINGPATTERN, Tag.RECORDPATTERN));\n+                }\n+\n+                @Override\n+                public void visitBindingPattern(JCTree.JCBindingPattern binding) {\n+                    JCVariableDecl var = binding.var;\n+                    variables.add(var);\n+\n+                    result = append(ExtendedOps.bindingPattern(typeToTypeElement(var.type), var.name.toString()));\n+                }\n+\n+                @Override\n+                public void visitRecordPattern(JCTree.JCRecordPattern record) {\n+                    \/\/ @@@ Is always Identifier to record?\n+                    \/\/ scan(record.deconstructor);\n+\n+                    List<Value> nestedValues = new ArrayList<>();\n+                    for (JCTree.JCPattern jcPattern : record.nested) {\n+                        nestedValues.add(toValue(jcPattern));\n+                    }\n+\n+                    result = append(ExtendedOps.recordPattern(symbolToRecordTypeRef(record.record), nestedValues));\n+                }\n+\n+                Value toValue(JCTree tree) {\n+                    result = null;\n+                    scan(tree);\n+                    return result;\n+                }\n+            }\n+            \/\/ Scan pattern\n+            Value patternValue = new PatternScanner().toValue(pattern);\n+            append(CoreOps._yield(patternValue));\n+            Body.Builder patternBody = stack.body;\n+\n+            \/\/ Pop body\n+            popBody();\n+\n+            \/\/ Find nearest ancestor body stack element associated with a statement tree\n+            \/\/ @@@ Strengthen check of tree?\n+            BodyStack _variablesStack = stack;\n+            while (!(_variablesStack.tree instanceof JCTree.JCStatement)) {\n+                _variablesStack = _variablesStack.parent;\n+            }\n+            BodyStack variablesStack = _variablesStack;\n+\n+            \/\/ Create pattern var ops for pattern variables using the\n+            \/\/ builder associated with the nearest statement tree\n+            for (JCVariableDecl jcVar : variables) {\n+                Value init = variablesStack.block.op(defaultValue(jcVar.type));\n+                Op.Result op = variablesStack.block.op(CoreOps.var(jcVar.name.toString(), typeToTypeElement(jcVar.type), init));\n+                variablesStack.localToOp.put(jcVar.sym, op);\n+            }\n+\n+            \/\/ Create pattern descriptor\n+            List<JavaType> patternDescParams = variables.stream().map(var -> typeToTypeElement(var.type)).toList();\n+            FunctionType matchFuncType = FunctionType.functionType(JavaType.VOID, patternDescParams);\n+\n+            \/\/ Create the match body, assigning pattern values to pattern variables\n+            Body.Builder matchBody = Body.Builder.of(patternBody.ancestorBody(), matchFuncType);\n+            Block.Builder matchBuilder = matchBody.entryBlock();\n+            for (int i = 0; i < variables.size(); i++) {\n+                Value v = matchBuilder.parameters().get(i);\n+                Value var = variablesStack.localToOp.get(variables.get(i).sym);\n+                matchBuilder.op(CoreOps.varStore(var, v));\n+            }\n+            matchBuilder.op(CoreOps._yield());\n+\n+            \/\/ Create the match operation\n+            return append(ExtendedOps.match(target, patternBody, matchBody));\n+        }\n+\n+        @Override\n+        public void visitNewClass(JCTree.JCNewClass tree) {\n+            \/\/ @@@ Support anonymous classes\n+            if (tree.def != null) {\n+                throw unsupported(tree);\n+            }\n+\n+            Type type = tree.type;\n+            Type outer = type.getEnclosingType();\n+            List<Value> args = new ArrayList<>();\n+            if (!outer.hasTag(TypeTag.NONE)) {\n+                \/\/ Obtain outer value for inner class, and add as first argument\n+                JCTree.JCExpression encl = tree.encl;\n+                Value outerInstance;\n+                if (encl == null) {\n+                    outerInstance = thisValue();\n+                } else {\n+                    outerInstance = toValue(tree.encl);\n+                }\n+                args.add(outerInstance);\n+            }\n+\n+            \/\/ Create erased method type reference for constructor, where\n+            \/\/ the return type declares the class to instantiate\n+            \/\/ @@@ require symbol site type?\n+            MethodRef methodRef = symbolToErasedMethodRef(tree.constructor);\n+            FunctionType constructorType = FunctionType.functionType(\n+                    symbolToErasedDesc(tree.constructor.owner),\n+                    methodRef.type().parameterTypes());\n+\n+            args.addAll(scanMethodArguments(tree.args, tree.constructorType, tree.varargsElement));\n+\n+            result = append(CoreOps._new(typeToTypeElement(type), constructorType, args));\n+        }\n+\n+        @Override\n+        public void visitNewArray(JCTree.JCNewArray tree) {\n+            if (tree.elems != null) {\n+                int length = tree.elems.size();\n+                Op.Result a = append(CoreOps.newArray(\n+                        typeToTypeElement(tree.type),\n+                        append(CoreOps.constant(JavaType.INT, length))));\n+                int i = 0;\n+                for (JCExpression elem : tree.elems) {\n+                    Value element = toValue(elem, types.elemtype(tree.type));\n+                    append(CoreOps.arrayStoreOp(\n+                            a,\n+                            append(CoreOps.constant(JavaType.INT, i)),\n+                            element));\n+                    i++;\n+                }\n+\n+                result = a;\n+            } else {\n+                List<Value> indexes = new ArrayList<>();\n+                for (JCTree.JCExpression dim : tree.dims) {\n+                    indexes.add(toValue(dim));\n+                }\n+\n+                JavaType arrayType = typeToTypeElement(tree.type);\n+                FunctionType constructorType = FunctionType.functionType(arrayType,\n+                        indexes.stream().map(Value::type).toList());\n+                result = append(CoreOps._new(arrayType, constructorType, indexes));\n+            }\n+        }\n+\n+        @Override\n+        public void visitLambda(JCTree.JCLambda tree) {\n+            FunctionalExpressionKind kind = functionalKind(tree);\n+            final FunctionType lambdaType = switch (kind) {\n+                case QUOTED_STRUCTURAL -> typeToFunctionType(tree.target);\n+                default -> typeToFunctionType(types.findDescriptorType(tree.target));\n+            };\n+\n+            \/\/ Push quoted body\n+            \/\/ We can either be explicitly quoted or a structural quoted expression\n+            \/\/ within some larger reflected code\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                pushBody(tree.body, FunctionType.VOID);\n+            }\n+\n+            \/\/ Push lambda body\n+            pushBody(tree.body, lambdaType);\n+\n+            \/\/ Map lambda parameters to varOp values\n+            for (int i = 0; i < tree.params.size(); i++) {\n+                JCVariableDecl p = tree.params.get(i);\n+                Op.Result paramOp = append(CoreOps.var(\n+                        p.name.toString(),\n+                        stack.block.parameters().get(i)));\n+                stack.localToOp.put(p.sym, paramOp);\n+            }\n+\n+            \/\/ Scan the lambda body\n+            if (tree.getBodyKind() == LambdaExpressionTree.BodyKind.EXPRESSION) {\n+                Value exprVal = toValue(tree.body, tree.getDescriptorType(types).getReturnType());\n+                if (!tree.body.type.hasTag(TypeTag.VOID)) {\n+                    append(CoreOps._return(exprVal));\n+                } else {\n+                    appendTerminating(CoreOps::_return);\n+                }\n+            } else {\n+                Type prevBodyTarget = bodyTarget;\n+                try {\n+                    bodyTarget = tree.getDescriptorType(types).getReturnType();\n+                    toValue(tree.body);\n+                    \/\/ @@@ Check if unreachable\n+                    appendTerminating(CoreOps::_return);\n+                } finally {\n+                    bodyTarget = prevBodyTarget;\n+                }\n+            }\n+\n+            Op lambdaOp = switch (kind) {\n+                case QUOTED_STRUCTURAL -> {\n+                    yield CoreOps.closure(stack.body);\n+                }\n+                case QUOTABLE, NOT_QUOTED -> {\n+                    \/\/ Get the functional interface type\n+                    JavaType fiType = typeToTypeElement(tree.target);\n+                    \/\/ build functional lambda\n+                    yield CoreOps.lambda(fiType, stack.body);\n+                }\n+            };\n+\n+            \/\/ Pop lambda body\n+            popBody();\n+\n+            Value lambdaResult;\n+            if (isQuoted) {\n+                lambdaResult = append(lambdaOp, generateLocation(tree, true));\n+            } else {\n+                lambdaResult = append(lambdaOp);\n+            }\n+\n+            if (isQuoted || kind == FunctionalExpressionKind.QUOTED_STRUCTURAL) {\n+                append(CoreOps._yield(lambdaResult));\n+                CoreOps.QuotedOp quotedOp = CoreOps.quoted(stack.body);\n+\n+                \/\/ Pop quoted body\n+                popBody();\n+\n+                lambdaResult = append(quotedOp);\n+            }\n+\n+            result = lambdaResult;\n+        }\n+\n+        @Override\n+        public void visitIf(JCTree.JCIf tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            boolean first = true;\n+            while (tree != null) {\n+                \/\/ @@@ cond.type can be boolean or Boolean\n+                JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+                \/\/ Push if condition\n+                pushBody(cond,\n+                        FunctionType.functionType(JavaType.BOOLEAN));\n+                Value last = toValue(cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(last));\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if condition\n+                popBody();\n+\n+                \/\/ Push if body\n+                pushBody(tree.thenpart, FunctionType.VOID);\n+\n+                scan(tree.thenpart);\n+                appendTerminating(CoreOps::_yield);\n+                bodies.add(stack.body);\n+\n+                \/\/ Pop if body\n+                popBody();\n+\n+                JCTree.JCStatement elsepart = tree.elsepart;\n+                if (elsepart == null) {\n+                    tree = null;\n+                }\n+                else if (elsepart.getTag() == Tag.BLOCK) {\n+                    \/\/ Push else body\n+                    pushBody(elsepart, FunctionType.VOID);\n+\n+                    scan(elsepart);\n+                    appendTerminating(CoreOps::_yield);\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop else body\n+                    popBody();\n+\n+                    tree = null;\n+                } else if (elsepart.getTag() == Tag.IF) {\n+                    tree = (JCTree.JCIf) elsepart;\n+                }\n+                first = false;\n+            }\n+\n+            append(ExtendedOps._if(bodies));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitSwitchExpression(JCTree.JCSwitchExpression tree) {\n+            Value target = toValue(tree.selector);\n+\n+            FunctionType caseLabelType = FunctionType.functionType(JavaType.BOOLEAN, target.type());\n+            Type switchType = adaptBottom(tree.type);\n+            FunctionType actionType = FunctionType.functionType(typeToTypeElement(switchType));\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            for (JCTree.JCCase c : tree.cases) {\n+                \/\/ Labels body\n+                JCTree.JCCaseLabel headCl = c.labels.head;\n+                if (headCl instanceof JCTree.JCPatternCaseLabel pcl) {\n+                    if (c.labels.size() > 1) {\n+                        throw unsupported(c);\n+                    }\n+\n+                    pushBody(pcl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.guard != null) {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+\n+                        pushBody(pcl.pat, FunctionType.functionType(JavaType.BOOLEAN));\n+                        Value patVal = scanPattern(pcl.pat, localTarget);\n+                        append(CoreOps._yield(patVal));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        pushBody(c.guard, FunctionType.functionType(JavaType.BOOLEAN));\n+                        append(CoreOps._yield(toValue(c.guard)));\n+                        clBodies.add(stack.body);\n+                        popBody();\n+\n+                        localResult = append(ExtendedOps.conditionalAnd(clBodies));\n+                    } else {\n+                        localResult = scanPattern(pcl.pat, localTarget);\n+                    }\n+                    \/\/ Yield the boolean result of the condition\n+                    append(CoreOps._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCConstantCaseLabel ccl) {\n+                    pushBody(headCl, caseLabelType);\n+\n+                    Value localTarget = stack.block.parameters().get(0);\n+                    final Value localResult;\n+                    if (c.labels.size() == 1) {\n+                        Value expr = toValue(ccl.expr);\n+                        \/\/ @@@ Conversion of localTarget\n+                        if (ccl.expr.type.isPrimitive()) {\n+                            localResult = append(CoreOps.eq(localTarget, expr));\n+                        } else {\n+                            localResult = append(CoreOps.invoke(\n+                                    MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                    localTarget, expr));\n+                        }\n+                    } else {\n+                        List<Body.Builder> clBodies = new ArrayList<>();\n+                        for (JCTree.JCCaseLabel cl : c.labels) {\n+                            ccl = (JCTree.JCConstantCaseLabel) cl;\n+                            pushBody(ccl, FunctionType.functionType(JavaType.BOOLEAN));\n+\n+                            Value expr = toValue(ccl.expr);\n+                            \/\/ @@@ Conversion of localTarget\n+                            final Value labelResult;\n+                            if (ccl.expr.type.isPrimitive()) {\n+                                labelResult = append(CoreOps.eq(localTarget, expr));\n+                            } else {\n+                                labelResult = append(CoreOps.invoke(\n+                                        MethodRef.method(Objects.class, \"equals\", boolean.class, Object.class, Object.class),\n+                                        localTarget, expr));\n+                            }\n+\n+                            append(CoreOps._yield(labelResult));\n+                            clBodies.add(stack.body);\n+\n+                            \/\/ Pop label\n+                            popBody();\n+                        }\n+\n+                        localResult = append(ExtendedOps.conditionalOr(clBodies));\n+                    }\n+\n+                    append(CoreOps._yield(localResult));\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop labels\n+                    popBody();\n+                } else if (headCl instanceof JCTree.JCDefaultCaseLabel) {\n+                    \/\/ @@@ Do we need to model the default label body?\n+                    pushBody(headCl, FunctionType.VOID);\n+\n+                    append(CoreOps._yield());\n+                    bodies.add(stack.body);\n+\n+                    \/\/ Pop label\n+                    popBody();\n+                } else {\n+                    throw unsupported(tree);\n+                }\n+\n+                \/\/ Statements body\n+                switch (c.caseKind) {\n+                    case RULE -> {\n+                        pushBody(c.body, actionType);\n+                        Type yieldType = adaptBottom(tree.type);\n+                        if (c.body instanceof JCExpression) {\n+                            \/\/ Yield the boolean result of the condition\n+                            Value bodyVal = toValue(c.body, yieldType);\n+                            append(CoreOps._yield(bodyVal));\n+                        } else {\n+                            \/\/ Otherwise there is a yield statement\n+                            Type prevBodyTarget = bodyTarget;\n+                            try {\n+                                bodyTarget = yieldType;\n+                                Value bodyVal = toValue(c.body);\n+                            } finally {\n+                                bodyTarget = prevBodyTarget;\n+                            }\n+                        }\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                    case STATEMENT -> {\n+                        \/\/ @@@ Avoid nesting for a single block? Goes against \"say what you see\"\n+                        \/\/ boolean oneBlock = c.stats.size() == 1 && c.stats.head instanceof JCBlock;\n+                        pushBody(c, actionType);\n+\n+                        scan(c.stats);\n+\n+                        appendTerminating(c.completesNormally\n+                                ? ExtendedOps::switchFallthroughOp\n+                                : CoreOps::unreachable);\n+\n+                        bodies.add(stack.body);\n+\n+                        \/\/ Pop block\n+                        popBody();\n+                    }\n+                };\n+            }\n+\n+            result = append(ExtendedOps.switchExpression(actionType.returnType(), target, bodies));\n+        }\n+\n+        @Override\n+        public void visitYield(JCTree.JCYield tree) {\n+            Value retVal = toValue(tree.value, bodyTarget);\n+            if (retVal == null) {\n+                result = append(ExtendedOps.java_yield());\n+            } else {\n+                result = append(ExtendedOps.java_yield(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            \/\/ @@@ cond.type can be boolean or Boolean\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            append(ExtendedOps._while(condition, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n+            \/\/ @@@ Patterns\n+            \/\/ @@@ cond.type can be boolean or Boolean\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push while body\n+            pushBody(tree.body, FunctionType.VOID);\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop while body\n+            popBody();\n+\n+            \/\/ Push while condition\n+            pushBody(cond, FunctionType.functionType(JavaType.BOOLEAN));\n+            Value last = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(last));\n+            Body.Builder condition = stack.body;\n+\n+            \/\/ Pop while condition\n+            popBody();\n+\n+            append(ExtendedOps.doWhile(body, condition));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n+            \/\/ Push expression\n+            pushBody(tree.expr, FunctionType.functionType(typeToTypeElement(tree.expr.type)));\n+            Value last = toValue(tree.expr);\n+            \/\/ Yield the Iterable result of the expression\n+            append(CoreOps._yield(last));\n+            Body.Builder expression = stack.body;\n+\n+            \/\/ Pop expression\n+            popBody();\n+\n+            JCVariableDecl var = tree.getVariable();\n+            JavaType eType = typeToTypeElement(var.type);\n+            VarType varEType = VarType.varType(typeToTypeElement(var.type));\n+\n+            \/\/ Push init\n+            \/\/ @@@ When lhs assignment is a pattern we embed the pattern match into the init body and\n+            \/\/ return the bound variables\n+            pushBody(var, FunctionType.functionType(varEType, eType));\n+            Op.Result varEResult = append(CoreOps.var(var.name.toString(), stack.block.parameters().get(0)));\n+            append(CoreOps._yield(varEResult));\n+            Body.Builder init = stack.body;\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varEType));\n+            stack.localToOp.put(var.sym, stack.block.parameters().get(0));\n+\n+            scan(tree.body);\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+            \/\/ Pop body\n+            popBody();\n+\n+            append(ExtendedOps.enhancedFor(expression, init, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitForLoop(JCTree.JCForLoop tree) {\n+            class VarDefScanner extends FilterScanner {\n+                final List<JCVariableDecl> decls;\n+\n+                public VarDefScanner() {\n+                    super(Set.of(Tag.VARDEF));\n+                    this.decls = new ArrayList<>();\n+                }\n+\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    decls.add(tree);\n+                }\n+\n+                void mapVarsToBlockArguments() {\n+                    for (int i = 0; i < decls.size(); i++) {\n+                        stack.localToOp.put(decls.get(i).sym, stack.block.parameters().get(i));\n+                    }\n+                }\n+\n+                List<VarType> varTypes() {\n+                    return decls.stream()\n+                            .map(t -> VarType.varType(typeToTypeElement(t.type)))\n+                            .toList();\n+                }\n+\n+                List<Value> varValues() {\n+                    return decls.stream()\n+                            .map(t -> stack.localToOp.get(t.sym))\n+                            .toList();\n+                }\n+            }\n+\n+            \/\/ Scan local variable declarations\n+            VarDefScanner vds = new VarDefScanner();\n+            vds.scan(tree.init);\n+            List<VarType> varTypes = vds.varTypes();\n+\n+            \/\/ Push init\n+            if (varTypes.size() > 1) {\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(varTypes)));\n+                scan(tree.init);\n+\n+                \/\/ Capture all local variable declarations in tuple\n+                append(CoreOps._yield(append(CoreOps.tuple(vds.varValues()))));\n+            } else if (varTypes.size() == 1) {\n+                pushBody(null, FunctionType.functionType(varTypes.get(0)));\n+                scan(tree.init);\n+\n+                append(CoreOps._yield(vds.varValues().get(0)));\n+            } else {\n+                pushBody(null, FunctionType.VOID);\n+                scan(tree.init);\n+\n+                append(CoreOps._yield());\n+            }\n+            Body.Builder init = stack.body;\n+\n+            \/\/ Pop init\n+            popBody();\n+\n+            \/\/ Push cond\n+            pushBody(tree.cond, FunctionType.functionType(JavaType.BOOLEAN, varTypes));\n+            if (tree.cond != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                Value last = toValue(tree.cond);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(last));\n+            } else {\n+                append(CoreOps._yield(append(CoreOps.constant(JavaType.BOOLEAN, true))));\n+            }\n+            Body.Builder cond = stack.body;\n+\n+            \/\/ Pop cond\n+            popBody();\n+\n+            \/\/ Push update\n+            \/\/ @@@ tree.step is a List<JCStatement>\n+            pushBody(null, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (!tree.step.isEmpty()) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.step);\n+            }\n+            append(CoreOps._yield());\n+            Body.Builder update = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            \/\/ Push body\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, varTypes));\n+            if (tree.body != null) {\n+                vds.mapVarsToBlockArguments();\n+\n+                scan(tree.body);\n+            }\n+            appendTerminating(ExtendedOps::_continue);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop update\n+            popBody();\n+\n+            append(ExtendedOps._for(init, cond, update, body));\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitConditional(JCTree.JCConditional tree) {\n+            List<Body.Builder> bodies = new ArrayList<>();\n+\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            JCTree.JCExpression truepart = TreeInfo.skipParens(tree.truepart);\n+\n+            Type condType = adaptBottom(tree.type);\n+\n+            \/\/ Push true body\n+            pushBody(truepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value trueVal = toValue(truepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOps._yield(trueVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop true body\n+            popBody();\n+\n+            JCTree.JCExpression falsepart = TreeInfo.skipParens(tree.falsepart);\n+\n+            \/\/ Push false body\n+            pushBody(falsepart,\n+                    FunctionType.functionType(typeToTypeElement(condType)));\n+\n+            Value falseVal = toValue(falsepart, condType);\n+            \/\/ Yield the result\n+            append(CoreOps._yield(falseVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop false body\n+            popBody();\n+\n+            result = append(ExtendedOps.conditionalExpression(typeToTypeElement(condType), bodies));\n+        }\n+\n+        private Type condType(JCExpression tree, Type type) {\n+            if (type.hasTag(BOT)) {\n+                return adaptBottom(tree.type);\n+            } else {\n+                return type;\n+            }\n+        }\n+\n+        private Type adaptBottom(Type type) {\n+            return type.hasTag(BOT) ?\n+                    (pt.hasTag(NONE) ? syms.objectType : pt) :\n+                    type;\n+        }\n+\n+        @Override\n+        public void visitAssert(JCAssert tree) {\n+            \/\/ assert <cond:body1> [detail:body2]\n+\n+            List<Body.Builder> bodies = new ArrayList<>();\n+            JCTree.JCExpression cond = TreeInfo.skipParens(tree.cond);\n+\n+            \/\/ Push condition\n+            pushBody(cond,\n+                    FunctionType.functionType(JavaType.BOOLEAN));\n+            Value condVal = toValue(cond);\n+\n+            \/\/ Yield the boolean result of the condition\n+            append(CoreOps._yield(condVal));\n+            bodies.add(stack.body);\n+\n+            \/\/ Pop condition\n+            popBody();\n+\n+            if (tree.detail != null) {\n+                JCTree.JCExpression detail = TreeInfo.skipParens(tree.detail);\n+\n+                pushBody(detail,\n+                         FunctionType.functionType(typeToTypeElement(tree.detail.type)));\n+                Value detailVal = toValue(detail);\n+\n+                append(CoreOps._yield(detailVal));\n+                bodies.add(stack.body);\n+\n+                \/\/Pop detail\n+                popBody();\n+            }\n+\n+            result = append(CoreOps._assert(bodies));\n+\n+        }\n+\n+        @Override\n+        public void visitBlock(JCTree.JCBlock tree) {\n+            if (stack.tree == tree) {\n+                \/\/ Block is associated with the visit of a parent structure\n+                scan(tree.stats);\n+            } else {\n+                \/\/ Otherwise, independent block structure\n+                \/\/ @@@ Support synchronized blocks\n+                \/\/ Push block\n+                pushBody(tree, FunctionType.VOID);\n+                scan(tree.stats);\n+                appendTerminating(CoreOps::_yield);\n+                Body.Builder body = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+\n+                append(ExtendedOps.block(body));\n+            }\n+            result = null;\n+        }\n+\n+        @Override\n+        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n+            \/\/ Push block\n+            pushBody(tree, FunctionType.VOID);\n+            \/\/ Create constant for label\n+            String labelName = tree.label.toString();\n+            Op.Result label = append(CoreOps.constant(JavaType.J_L_STRING, labelName));\n+            \/\/ Set label on body stack\n+            stack.setLabel(labelName, label);\n+            scan(tree.body);\n+            appendTerminating(CoreOps::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            result = append(ExtendedOps.labeled(body));\n+        }\n+\n+        @Override\n+        public void visitTry(JCTree.JCTry tree) {\n+            List<JCVariableDecl> rVariableDecls = new ArrayList<>();\n+            List<TypeElement> rTypes = new ArrayList<>();\n+            Body.Builder resources;\n+            if (!tree.resources.isEmpty()) {\n+                \/\/ Resources body returns a tuple that contains the resource variables\/values\n+                \/\/ in order of declaration\n+                for (JCTree resource : tree.resources) {\n+                    if (resource instanceof JCVariableDecl vdecl) {\n+                        rVariableDecls.add(vdecl);\n+                        rTypes.add(VarType.varType(typeToTypeElement(vdecl.type)));\n+                    } else {\n+                        rTypes.add(typeToTypeElement(resource.type));\n+                    }\n+                }\n+\n+                \/\/ Push resources body\n+                pushBody(null, FunctionType.functionType(TupleType.tupleType(rTypes)));\n+\n+                List<Value> rValues = new ArrayList<>();\n+                for (JCTree resource : tree.resources) {\n+                    rValues.add(toValue(resource));\n+                }\n+\n+                append(CoreOps._yield(append(CoreOps.tuple(rValues))));\n+                resources = stack.body;\n+\n+                \/\/ Pop resources body\n+                popBody();\n+            } else {\n+                resources = null;\n+            }\n+\n+            \/\/ Push body\n+            \/\/ Try body accepts the resource variables (in order of declaration).\n+            List<VarType> rVarTypes = rTypes.stream().<VarType>mapMulti((t, c) -> {\n+                if (t instanceof VarType vt) {\n+                    c.accept(vt);\n+                }\n+            }).toList();\n+            pushBody(tree.body, FunctionType.functionType(JavaType.VOID, rVarTypes));\n+            for (int i = 0; i < rVariableDecls.size(); i++) {\n+                stack.localToOp.put(rVariableDecls.get(i).sym, stack.block.parameters().get(i));\n+            }\n+            scan(tree.body);\n+            appendTerminating(CoreOps::_yield);\n+            Body.Builder body = stack.body;\n+\n+            \/\/ Pop block\n+            popBody();\n+\n+            List<Body.Builder> catchers = new ArrayList<>();\n+            for (JCTree.JCCatch catcher : tree.catchers) {\n+                \/\/ Push body\n+                pushBody(catcher.body, FunctionType.functionType(JavaType.VOID, typeToTypeElement(catcher.param.type)));\n+                Op.Result exVariable = append(CoreOps.var(\n+                        catcher.param.name.toString(),\n+                        stack.block.parameters().get(0)));\n+                stack.localToOp.put(catcher.param.sym, exVariable);\n+                scan(catcher.body);\n+                appendTerminating(CoreOps::_yield);\n+                catchers.add(stack.body);\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+\n+            Body.Builder finalizer;\n+            if (tree.finalizer != null) {\n+                \/\/ Push body\n+                pushBody(tree.finalizer, FunctionType.VOID);\n+                scan(tree.finalizer);\n+                appendTerminating(CoreOps::_yield);\n+                finalizer = stack.body;\n+\n+                \/\/ Pop block\n+                popBody();\n+            }\n+            else {\n+                finalizer = null;\n+            }\n+\n+            result = append(ExtendedOps._try(resources, body, catchers, finalizer));\n+        }\n+\n+        @Override\n+        public void visitUnary(JCTree.JCUnary tree) {\n+            Tag tag = tree.getTag();\n+            switch (tag) {\n+                case POSTINC, POSTDEC, PREINC, PREDEC -> {\n+                    \/\/ Capture applying rhs and operation\n+                    Function<Value, Value> scanRhs = (lhs) -> {\n+                        Value one = append(numericOneValue(tree.type));\n+                        Value unboxedLhs = unboxIfNeeded(lhs);\n+\n+                        Value unboxedLhsPlusOne = switch (tree.getTag()) {\n+                            \/\/ Arithmetic operations\n+                            case POSTINC, PREINC -> append(CoreOps.add(unboxedLhs, one));\n+                            case POSTDEC, PREDEC -> append(CoreOps.sub(unboxedLhs, one));\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        Value lhsPlusOne = convert(unboxedLhsPlusOne, tree.type);\n+\n+                        \/\/ Assign expression result\n+                        result =  switch (tree.getTag()) {\n+                            case POSTINC, POSTDEC -> lhs;\n+                            case PREINC, PREDEC -> lhsPlusOne;\n+\n+                            default -> throw unsupported(tree);\n+                        };\n+                        return lhsPlusOne;\n+                    };\n+\n+                    applyCompoundAssign(tree.arg, scanRhs);\n+                }\n+                case NEG -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOps.neg(rhs));\n+                }\n+                case NOT -> {\n+                    Value rhs = toValue(tree.arg, tree.type);\n+                    result = append(CoreOps.not(rhs));\n+                }\n+                default -> throw unsupported(tree);\n+            }\n+        }\n+\n+        @Override\n+        public void visitBinary(JCBinary tree) {\n+            Tag tag = tree.getTag();\n+            if (tag == Tag.AND || tag == Tag.OR) {\n+                \/\/ Logical operations\n+                \/\/ @@@ Flatten nested sequences\n+\n+                \/\/ Push lhs\n+                pushBody(tree.lhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value lhs = toValue(tree.lhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(lhs));\n+                Body.Builder bodyLhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                \/\/ Push rhs\n+                pushBody(tree.rhs, FunctionType.functionType(JavaType.BOOLEAN));\n+                Value rhs = toValue(tree.rhs);\n+                \/\/ Yield the boolean result of the condition\n+                append(CoreOps._yield(rhs));\n+                Body.Builder bodyRhs = stack.body;\n+\n+                \/\/ Pop lhs\n+                popBody();\n+\n+                List<Body.Builder> bodies = List.of(bodyLhs, bodyRhs);\n+                result = append(tag == Tag.AND\n+                        ? ExtendedOps.conditionalAnd(bodies)\n+                        : ExtendedOps.conditionalOr(bodies));\n+            } else if (tag == Tag.PLUS && tree.operator.opcode == ByteCodes.string_add) {\n+                \/\/Ignore the operator and query both subexpressions for their type with concats\n+                Type lhsType = tree.lhs.type;\n+                Type rhsType = tree.rhs.type;\n+\n+                Value lhs = toValue(tree.lhs, lhsType);\n+                Value rhs = toValue(tree.rhs, rhsType);\n+\n+                result = append(CoreOps.concat(lhs, rhs));\n+            }\n+            else {\n+                Type opType = tree.operator.type.getParameterTypes().getFirst();\n+                \/\/ @@@ potentially handle shift input conversion like other binary ops\n+                boolean isShift = tag == Tag.SL || tag == Tag.SR || tag == Tag.USR;\n+                Value lhs = toValue(tree.lhs, opType);\n+                Value rhs = toValue(tree.rhs, isShift ? tree.operator.type.getParameterTypes().getLast() : opType);\n+\n+                result = switch (tag) {\n+                    \/\/ Arithmetic operations\n+                    case PLUS -> append(CoreOps.add(lhs, rhs));\n+                    case MINUS -> append(CoreOps.sub(lhs, rhs));\n+                    case MUL -> append(CoreOps.mul(lhs, rhs));\n+                    case DIV -> append(CoreOps.div(lhs, rhs));\n+                    case MOD -> append(CoreOps.mod(lhs, rhs));\n+\n+                    \/\/ Test operations\n+                    case EQ -> append(CoreOps.eq(lhs, rhs));\n+                    case NE -> append(CoreOps.neq(lhs, rhs));\n+                    \/\/\n+                    case LT -> append(CoreOps.lt(lhs, rhs));\n+                    case LE -> append(CoreOps.le(lhs, rhs));\n+                    case GT -> append(CoreOps.gt(lhs, rhs));\n+                    case GE -> append(CoreOps.ge(lhs, rhs));\n+\n+                    \/\/ Bitwise operations (including their boolean variants)\n+                    case BITOR -> append(CoreOps.or(lhs, rhs));\n+                    case BITAND -> append(CoreOps.and(lhs, rhs));\n+                    case BITXOR -> append(CoreOps.xor(lhs, rhs));\n+\n+                    \/\/ Shift operations\n+                    case SL -> append(CoreOps.lshl(lhs, rhs));\n+                    case SR -> append(CoreOps.ashr(lhs, rhs));\n+                    case USR -> append(CoreOps.lshr(lhs, rhs));\n+\n+                    default -> throw unsupported(tree);\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void visitLiteral(JCLiteral tree) {\n+            Object value = switch (tree.type.getTag()) {\n+                case BOOLEAN -> tree.value instanceof Integer i && i == 1;\n+                case CHAR -> (char) (int) tree.value;\n+                default -> tree.value;\n+            };\n+            Type constantType = adaptBottom(tree.type);\n+            result = append(CoreOps.constant(typeToTypeElement(constantType), value));\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            Value retVal = toValue(tree.expr, bodyTarget);\n+            if (retVal == null) {\n+                result = append(CoreOps._return());\n+            } else {\n+                result = append(CoreOps._return(retVal));\n+            }\n+        }\n+\n+        @Override\n+        public void visitThrow(JCTree.JCThrow tree) {\n+            Value throwVal = toValue(tree.expr);\n+            result = append(CoreOps._throw(throwVal));\n+        }\n+\n+        @Override\n+        public void visitBreak(JCTree.JCBreak tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOps._break(label));\n+        }\n+\n+        @Override\n+        public void visitContinue(JCTree.JCContinue tree) {\n+            Value label = tree.label != null\n+                    ? getLabel(tree.label.toString())\n+                    : null;\n+            result = append(ExtendedOps._continue(label));\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ do nothing\n+        }\n+\n+\n+        UnsupportedASTException unsupported(JCTree tree) {\n+            return new UnsupportedASTException(tree);\n+        }\n+\n+        CoreOps.FuncOp scanMethod() {\n+            scan(body);\n+            \/\/ @@@ Check if unreachable\n+            appendTerminating(CoreOps::_return);\n+            CoreOps.FuncOp func = CoreOps.func(name.toString(), stack.body);\n+            func.setLocation(generateLocation(currentNode, true));\n+            return func;\n+        }\n+\n+        CoreOps.FuncOp scanLambda() {\n+            scan(body);\n+            append(CoreOps._return(result));\n+            return CoreOps.func(name.toString(), stack.body);\n+        }\n+\n+        JavaType symbolToErasedDesc(Symbol s) {\n+            return typeToTypeElement(s.erasure(types));\n+        }\n+\n+        JavaType typeToTypeElement(Type t) {\n+            t = normalizeType(t);\n+            return switch (t.getTag()) {\n+                case VOID -> JavaType.VOID;\n+                case CHAR -> JavaType.CHAR;\n+                case BOOLEAN -> JavaType.BOOLEAN;\n+                case BYTE -> JavaType.BYTE;\n+                case SHORT -> JavaType.SHORT;\n+                case INT -> JavaType.INT;\n+                case FLOAT -> JavaType.FLOAT;\n+                case LONG -> JavaType.LONG;\n+                case DOUBLE -> JavaType.DOUBLE;\n+                case ARRAY -> {\n+                    Type et = ((ArrayType)t).elemtype;\n+                    yield JavaType.array(typeToTypeElement(et));\n+                }\n+                case WILDCARD -> {\n+                    Type.WildcardType wt = (Type.WildcardType)t;\n+                    yield wt.isUnbound() ?\n+                            JavaType.wildcard() :\n+                            JavaType.wildcard(wt.isExtendsBound() ? BoundKind.EXTENDS : BoundKind.SUPER, typeToTypeElement(wt.type));\n+                }\n+                case TYPEVAR -> t.tsym.owner.kind == Kind.MTH ?\n+                        JavaType.typeVarRef(t.tsym.name.toString(), symbolToErasedMethodRef(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound())) :\n+                        JavaType.typeVarRef(t.tsym.name.toString(),\n+                                (jdk.internal.java.lang.reflect.code.type.ClassType)symbolToErasedDesc(t.tsym.owner),\n+                                typeToTypeElement(t.getUpperBound()));\n+                case CLASS -> {\n+                    Assert.check(!t.isIntersection() && !t.isUnion());\n+                    \/\/ @@@ Need to clean this up, probably does not work inner generic classes\n+                    \/\/ whose enclosing class is also generic\n+                    List<JavaType> typeArguments;\n+                    if (t.getTypeArguments().nonEmpty()) {\n+                        typeArguments = new ArrayList<>();\n+                        for (Type ta : t.getTypeArguments()) {\n+                            typeArguments.add(typeToTypeElement(ta));\n+                        }\n+                    } else {\n+                        typeArguments = List.of();\n+                    }\n+\n+                    \/\/ Use flat name to ensure demarcation of nested classes\n+                    yield JavaType.type(JavaType.ofNominalDescriptor(ClassDesc.of(t.tsym.flatName().toString())), typeArguments);\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported type: kind=\" + t.getKind() + \" type=\" + t);\n+                }\n+            };\n+        }\n+\n+        Type symbolSiteType(Symbol s) {\n+            boolean isMember = s.owner == syms.predefClass ||\n+                    s.isMemberOf(currentClassSym, types);\n+            return isMember ? currentClassSym.type : s.owner.type;\n+        }\n+\n+        FieldRef symbolToFieldRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedFieldRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        FieldRef symbolToErasedFieldRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return FieldRef.field(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s, Type site) {\n+            \/\/ @@@ Made Gen::binaryQualifier public, duplicate logic?\n+            \/\/ Ensure correct qualifying class is used in the reference, see JLS 13.1\n+            \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/jls-13.html#jls-13.1\n+            return symbolToErasedMethodRef(gen.binaryQualifier(s, types.erasure(site)));\n+        }\n+\n+        MethodRef symbolToErasedMethodRef(Symbol s) {\n+            Type erasedType = s.erasure(types);\n+            return MethodRef.method(\n+                    typeToTypeElement(s.owner.erasure(types)),\n+                    s.name.toString(),\n+                    typeToTypeElement(erasedType.getReturnType()),\n+                    erasedType.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        FunctionType symbolToFunctionType(Symbol s) {\n+            return typeToFunctionType(s.type);\n+        }\n+\n+        FunctionType typeToFunctionType(Type t) {\n+            return FunctionType.functionType(\n+                    typeToTypeElement(t.getReturnType()),\n+                    t.getParameterTypes().stream().map(this::typeToTypeElement).toArray(TypeElement[]::new));\n+        }\n+\n+        RecordTypeRef symbolToRecordTypeRef(Symbol.ClassSymbol s) {\n+            TypeElement recordType = typeToTypeElement(s.type);\n+            List<RecordTypeRef.ComponentRef> components = s.getRecordComponents().stream()\n+                    .map(rc -> new RecordTypeRef.ComponentRef(typeToTypeElement(rc.type), rc.name.toString()))\n+                    .toList();\n+            return RecordTypeRef.recordType(recordType, components);\n+        }\n+\n+        Op defaultValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE -> CoreOps.constant(typeToTypeElement(t), (byte)0);\n+                case CHAR -> CoreOps.constant(typeToTypeElement(t), (char)0);\n+                case BOOLEAN -> CoreOps.constant(typeToTypeElement(t), false);\n+                case SHORT -> CoreOps.constant(typeToTypeElement(t), (short)0);\n+                case INT -> CoreOps.constant(typeToTypeElement(t), 0);\n+                case FLOAT -> CoreOps.constant(typeToTypeElement(t), 0f);\n+                case LONG -> CoreOps.constant(typeToTypeElement(t), 0L);\n+                case DOUBLE -> CoreOps.constant(typeToTypeElement(t), 0d);\n+                default -> CoreOps.constant(typeToTypeElement(t), null);\n+            };\n+        }\n+\n+        Op numericOneValue(Type t) {\n+            return switch (t.getTag()) {\n+                case BYTE -> CoreOps.constant(typeToTypeElement(t), (byte)1);\n+                case CHAR -> CoreOps.constant(typeToTypeElement(t), (char)1);\n+                case SHORT -> CoreOps.constant(typeToTypeElement(t), (short)1);\n+                case INT -> CoreOps.constant(typeToTypeElement(t), 1);\n+                case FLOAT -> CoreOps.constant(typeToTypeElement(t), 1f);\n+                case LONG -> CoreOps.constant(typeToTypeElement(t), 1L);\n+                case DOUBLE -> CoreOps.constant(typeToTypeElement(t), 1d);\n+                case CLASS -> numericOneValue(types.unboxedType(t));\n+                default -> throw new UnsupportedOperationException(t.toString());\n+            };\n+        }\n+\n+        Type normalizeType(Type t) {\n+            Assert.check(!t.hasTag(METHOD));\n+            return types.upward(t, false, types.captures(t));\n+        }\n+\n+        Type typeElementToType(TypeElement desc) {\n+            return primitiveAndBoxTypeMap().getOrDefault(desc, Type.noType);\n+        }\n+\n+        public boolean checkDenotableInTypeDesc(Type t) {\n+            return denotableChecker.visit(t, null);\n+        }\n+        \/\/ where\n+\n+        \/**\n+         * A type visitor that descends into the given type looking for types that are non-denotable\n+         * in code model types. Examples of such types are: type-variables (regular or captured),\n+         * wildcard type argument, intersection types, union types. The visit methods return false\n+         * as soon as a non-denotable type is encountered and true otherwise. (see {@link Check#checkDenotable(Type)}.\n+         *\/\n+        private static final Types.SimpleVisitor<Boolean, Void> denotableChecker = new Types.SimpleVisitor<>() {\n+            @Override\n+            public Boolean visitType(Type t, Void s) {\n+                return true;\n+            }\n+            @Override\n+            public Boolean visitClassType(ClassType t, Void s) {\n+                if (t.isUnion() || t.isIntersection()) {\n+                    \/\/ union and intersections cannot be denoted in code model types\n+                    return false;\n+                }\n+                \/\/ @@@ What about enclosing types?\n+                for (Type targ : t.getTypeArguments()) {\n+                    \/\/ propagate into type arguments\n+                    if (!visit(targ, s)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public Boolean visitTypeVar(TypeVar t, Void s) {\n+                \/\/ type variables cannot be denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitWildcardType(WildcardType t, Void s) {\n+                \/\/ wildcards cannot de denoted in code model types\n+                return false;\n+            }\n+\n+            @Override\n+            public Boolean visitArrayType(ArrayType t, Void s) {\n+                \/\/ propagate into element type\n+                return visit(t.elemtype, s);\n+            }\n+        };\n+\n+    }\n+\n+    \/**\n+     * An exception thrown when an unsupported AST node is found when building a method IR.\n+     *\/\n+    static class UnsupportedASTException extends RuntimeException {\n+\n+        private static final long serialVersionUID = 0;\n+        transient final JCTree tree;\n+\n+        public UnsupportedASTException(JCTree tree) {\n+            this.tree = tree;\n+        }\n+    }\n+\n+    enum FunctionalExpressionKind {\n+        QUOTED_STRUCTURAL(true), \/\/ this is transitional\n+        QUOTABLE(true),\n+        NOT_QUOTED(false);\n+\n+        final boolean isQuoted;\n+\n+        FunctionalExpressionKind(boolean isQuoted) {\n+            this.isQuoted = isQuoted;\n+        }\n+    }\n+\n+    FunctionalExpressionKind functionalKind(JCFunctionalExpression functionalExpression) {\n+        if (functionalExpression.target.hasTag(TypeTag.METHOD)) {\n+            return FunctionalExpressionKind.QUOTED_STRUCTURAL;\n+        } else if (types.asSuper(functionalExpression.target, syms.quotableType.tsym) != null) {\n+            return FunctionalExpressionKind.QUOTABLE;\n+        } else {\n+            return FunctionalExpressionKind.NOT_QUOTED;\n+        }\n+    }\n+\n+    \/*\n+     * Converts a method reference which cannot be used directly into a lambda.\n+     * This code has been derived from LambdaToMethod::MemberReferenceToLambda. The main\n+     * difference is that, while that code concerns with translation strategy, boxing\n+     * conversion and type erasure, this version does not and, as such, can remain\n+     * at a higher level. Note that this code needs to create a synthetic variable\n+     * declaration in case of a bounded method reference whose receiver expression\n+     * is other than 'this'\/'super' (this is done to prevent the receiver expression\n+     * from being computed twice).\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final Symbol owner;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private JCVariableDecl receiverVar = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree, Symbol currentClass) {\n+            this.tree = tree;\n+            this.owner = new MethodSymbol(0, names.lambda, tree.target, currentClass);\n+            if (tree.kind == ReferenceKind.BOUND && !isThisOrSuper(tree.getQualifierExpression())) {\n+                \/\/ true bound method reference, hoist receiver expression out\n+                Type recvType = types.asSuper(tree.getQualifierExpression().type, tree.sym.owner);\n+                VarSymbol vsym = makeSyntheticVar(\"rec$\", recvType);\n+                receiverVar = make.VarDef(vsym, tree.getQualifierExpression());\n+            }\n+        }\n+\n+        JCVariableDecl receiverVar() {\n+            return receiverVar;\n+        }\n+\n+        JCLambda lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                return slam;\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            com.sun.tools.javac.util.List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+            VarSymbol receiverParam = null;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    if (receiverVar != null) {\n+                        receiverParam = receiverVar.sym;\n+                    }\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    receiverParam = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+            }\n+            for (int i = 0; descPTypes.nonEmpty(); ++i) {\n+                \/\/ By default use the implementation method parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                descPTypes = descPTypes.tail;\n+            }\n+\n+            return receiverParam;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol receiverParam) {\n+            JCExpression qualifier = receiverParam != null ?\n+                    make.at(tree.pos).Ident(receiverParam) :\n+                    tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCMethodInvocation apply = make.Apply(com.sun.tools.javac.util.List.nil(), select, args.toList()).\n+                    setType(tree.referentType.getReturnType());\n+\n+            apply.varargsElement = tree.varargsElement;\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            Type expectedType = tree.referentType.getReturnType().hasTag(TypeTag.VOID) ?\n+                    tree.expr.type : tree.referentType.getReturnType();\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(expectedType)),\n+                        com.sun.tools.javac.util.List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCExpression newType = make.Type(types.erasure(expectedType));\n+                if (expectedType.tsym.type.getTypeArguments().nonEmpty()) {\n+                    newType = make.TypeApply(newType, com.sun.tools.javac.util.List.nil());\n+                }\n+                JCNewClass newClass = make.NewClass(null,\n+                        com.sun.tools.javac.util.List.nil(),\n+                        newType,\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.referentType;\n+                newClass.type = expectedType;\n+                newClass.varargsElement = tree.varargsElement;\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol makeSyntheticVar(String name, Type type) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), type, owner);\n+            vsym.pos = tree.pos;\n+            return vsym;\n+        }\n+\n+        private VarSymbol addParameter(String name, Type type, boolean genArg) {\n+            VarSymbol vsym = makeSyntheticVar(name, type);\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+\n+        boolean isThisOrSuper(JCExpression expression) {\n+            return TreeInfo.isThisQualifier(expression) || TreeInfo.isSuperQualifier(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":2625,"deletions":0,"binary":false,"changes":2625,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-    Symbol binaryQualifier(Symbol sym, Type site) {\n+    public Symbol binaryQualifier(Symbol sym, Type site) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1612,0 +1612,4 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                env.tree = ReflectMethods.instance(context).translateTopLevelClass(env.tree, localMake);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -46,0 +47,1 @@\n+import com.sun.source.tree.Tree;\n@@ -47,0 +49,1 @@\n+import com.sun.tools.javac.api.JavacScope;\n@@ -48,0 +51,1 @@\n+import com.sun.tools.javac.api.JavacTrees;\n@@ -59,0 +63,1 @@\n+import com.sun.tools.javac.comp.Attr;\n@@ -62,0 +67,1 @@\n+import com.sun.tools.javac.comp.ReflectMethods;\n@@ -67,0 +73,1 @@\n+import com.sun.tools.javac.tree.TreeMaker;\n@@ -74,1 +81,1 @@\n-import com.sun.tools.javac.comp.Attr;\n+\n@@ -77,1 +84,0 @@\n-import com.sun.tools.javac.comp.Resolve.RecoveryLoadClass;\n@@ -79,0 +85,2 @@\n+import jdk.internal.java.lang.reflect.code.op.CoreOps;\n+\n@@ -97,0 +105,1 @@\n+    private final JavacTrees javacTrees;\n@@ -99,0 +108,1 @@\n+    private final ReflectMethods reflectMethods;\n@@ -101,0 +111,1 @@\n+    private final TreeMaker make;\n@@ -121,0 +132,2 @@\n+        javacTrees = JavacTrees.instance(context);\n+        reflectMethods = ReflectMethods.instance(context);\n@@ -124,0 +137,1 @@\n+        make = TreeMaker.instance(context);\n@@ -796,0 +810,32 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public Optional<Object> getBody(ExecutableElement e) {\n+        if (e.getModifiers().contains(Modifier.ABSTRACT) ||\n+                e.getModifiers().contains(Modifier.NATIVE)) {\n+            return Optional.empty();\n+        }\n+\n+        CoreOps.FuncOp funcOp;\n+        try {\n+            JCMethodDecl methodTree = (JCMethodDecl)getTree(e);\n+            JavacScope scope = javacTrees.getScope(javacTrees.getPath(e));\n+            ClassSymbol enclosingClass = (ClassSymbol) scope.getEnclosingClass();\n+            funcOp = attr.runWithAttributedMethod(scope.getEnv(), methodTree,\n+                    attribBlock -> reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make));\n+        } catch (RuntimeException ex) {  \/\/ ReflectMethods.UnsupportedASTException\n+            \/\/ some other error occurred when attempting to attribute the method\n+            \/\/ @@@ better report of error\n+            ex.printStackTrace();\n+            return Optional.empty();\n+        }\n+\n+        \/\/ Reparse using API in java.base\n+        try {\n+            String opString = funcOp.toText();\n+            Class<?> opParserClass = Class.forName(\"java.lang.reflect.code.parser.OpParser\");\n+            Method fromStringMethod = opParserClass.getDeclaredMethod(\"fromStringOfFuncOp\", String.class);\n+            return Optional.of(fromStringMethod.invoke(null, opString));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1401,0 +1401,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4087,0 +4095,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.tools.javac.code.Type.MethodType;\n@@ -756,1 +757,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -765,0 +767,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public CodeReflectionInfo codeReflectionInfo;\n@@ -767,1 +771,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -769,0 +780,2 @@\n+\n+        public record CodeReflectionInfo(Symbol quotedField, List<JCExpression> capturedArgs) { }\n@@ -1960,1 +1973,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2546,1 +2559,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -170,0 +170,13 @@\n+    public static boolean isSuperQualifier(JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisQualifier(skipParens(tree));\n+            case IDENT: {\n+                JCIdent id = (JCIdent)tree;\n+                return id.name == id.name.table.names._super;\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -664,1 +664,6 @@\n-   -:jdk_security\n\\ No newline at end of file\n+   -:jdk_security\n+\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n+\n","filename":"test\/jdk\/TEST.groups","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @summary Test symbolic access of method\n+ * @run testng TreeAccessTest\n+ *\/\n+\n+public class TreeAccessTest {\n+\n+    @CodeReflection\n+    public int m(String s) {\n+        return s.length();\n+    }\n+\n+    @Test\n+    void testTreeAccess() throws Exception {\n+        Method m = TreeAccessTest.class.getDeclaredMethod(\"m\", String.class);\n+\n+        Optional<CoreOps.FuncOp> tree = m.getCodeModel();\n+        Assert.assertTrue(tree.isPresent());\n+\n+        CoreOps.FuncOp methodTree = tree.get();\n+\n+        String expectedTree = \"\"\"\n+                func @\"m\" (%0 : TreeAccessTest, %1 : java.lang.String)int -> {\n+                      %2 : Var<java.lang.String> = var %1 @\"s\";\n+                      %3 : java.lang.String = var.load %2;\n+                      %4 : int = invoke %3 @\"java.lang.String::length()int\";\n+                      return %4;\n+                };\n+                \"\"\";\n+\n+        Assert.assertEquals(canonicalizeDescription(methodTree.toText()), canonicalizeDescription(expectedTree));\n+    }\n+\n+    static String canonicalizeDescription(String d) {\n+        return OpParser.fromString(ExtendedOps.FACTORY, d).get(0).toText();\n+    }\n+\n+    @Test\n+    public int n(String s) {\n+        return s.length();\n+    }\n+\n+    @Test\n+    void testNoTree() throws Exception {\n+        Method m = TreeAccessTest.class.getDeclaredMethod(\"n\", String.class);\n+\n+        Optional<CoreOps.FuncOp> tree = m.getCodeModel();\n+        Assert.assertTrue(tree.isEmpty());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/cr\/TreeAccessTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,372 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run junit CoreBinaryOpsTest\n+ *\/\n+\n+import org.junit.jupiter.api.Named;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.function.ThrowingSupplier;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Parameter;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CoreBinaryOpsTest {\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    static int and(int left, int right) {\n+        return left & right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int add(int left, int right) {\n+        return left + right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int div(int left, int right) {\n+        return left \/ right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class})\n+    static int leftShift(int left, int right) {\n+        return left << right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static int leftShiftIL(int left, long right) {\n+        return left << right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static long leftShiftLI(long left, int right) {\n+        return left << right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int mod(int left, int right) {\n+        return left % right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int mul(int left, int right) {\n+        return left * right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    static int or(int left, int right) {\n+        return left | right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class})\n+    static int signedRightShift(int left, int right) {\n+        return left >> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static int signedRightShiftIL(int left, long right) {\n+        return left >> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static long signedRightShiftLI(long left, int right) {\n+        return left >> right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, float.class, double.class})\n+    static int sub(int left, int right) {\n+        return left - right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class})\n+    static int unsignedRightShift(int left, int right) {\n+        return left >>> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static int unsignedRightShiftIL(int left, long right) {\n+        return left >>> right;\n+    }\n+\n+    @CodeReflection\n+    @Direct\n+    static long unsignedRightShiftLI(long left, int right) {\n+        return left >>> right;\n+    }\n+\n+    @CodeReflection\n+    @SupportedTypes(types = {int.class, long.class, boolean.class})\n+    static int xor(int left, int right) {\n+        return left ^ right;\n+    }\n+\n+    @ParameterizedTest\n+    @CodeReflectionExecutionSource\n+    void test(CoreOps.FuncOp funcOp, Object left, Object right) {\n+        Result interpret = runCatching(() -> interpret(left, right, funcOp));\n+        Result bytecode = runCatching(() -> bytecode(left, right, funcOp));\n+        assertResults(interpret, bytecode);\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface SupportedTypes {\n+        Class<?>[] types();\n+    }\n+\n+    \/\/ mark as \"do not transform\"\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @interface Direct {\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.METHOD)\n+    @ArgumentsSource(CodeReflectionSourceProvider.class)\n+    @interface CodeReflectionExecutionSource {\n+    }\n+\n+    static class CodeReflectionSourceProvider implements ArgumentsProvider {\n+        private static final Map<JavaType, List<Object>> INTERESTING_INPUTS = Map.of(\n+                JavaType.INT, List.of(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, 0, -1),\n+                JavaType.LONG, List.of(Long.MIN_VALUE, Long.MAX_VALUE, 1, 0, -1),\n+                JavaType.DOUBLE, List.of(Double.MIN_VALUE, Double.MAX_VALUE, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.MIN_NORMAL, 1, 0, -1),\n+                JavaType.FLOAT, List.of(Float.MIN_VALUE, Float.MAX_VALUE, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.MIN_NORMAL, 1, 0, -1),\n+                JavaType.BOOLEAN, List.of(true, false)\n+        );\n+\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {\n+            Method testMethod = extensionContext.getRequiredTestMethod();\n+            return codeReflectionMethods(extensionContext.getRequiredTestClass())\n+                    .flatMap(method -> {\n+                        CoreOps.FuncOp funcOp = method.getCodeModel().orElseThrow(\n+                                () -> new IllegalStateException(\"Expected code model to be present for method \" + method)\n+                        );\n+                        SupportedTypes supportedTypes = method.getAnnotation(SupportedTypes.class);\n+                        if (method.isAnnotationPresent(Direct.class)) {\n+                            if (supportedTypes != null) {\n+                                throw new IllegalArgumentException(\"Direct should not be combined with SupportedTypes\");\n+                            }\n+                            return Stream.of(funcOp);\n+                        }\n+                        if (supportedTypes == null || supportedTypes.types().length == 0) {\n+                            throw new IllegalArgumentException(\"Missing supported types\");\n+                        }\n+                        return Arrays.stream(supportedTypes.types())\n+                                .map(type -> retype(funcOp, type));\n+                    })\n+                    .flatMap(transformedFunc -> argumentsForMethod(transformedFunc, testMethod));\n+        }\n+\n+        private static <T> Stream<List<T>> cartesianProduct(List<List<T>> source) {\n+            if (source.isEmpty()) {\n+                return Stream.of(new ArrayList<>());\n+            }\n+            return source.getFirst().stream()\n+                    .flatMap(e -> cartesianProduct(source.subList(1, source.size())).map(l -> {\n+                        ArrayList<T> newList = new ArrayList<>(l);\n+                        newList.add(e);\n+                        return newList;\n+                    }));\n+        }\n+\n+        private static CoreOps.FuncOp retype(CoreOps.FuncOp original, Class<?> newType) {\n+            JavaType type = JavaType.type(newType);\n+            FunctionType functionType = original.invokableType();\n+            if (functionType.parameterTypes().stream().allMatch(t -> t.equals(type))) {\n+                return original; \/\/ already expected type\n+            }\n+            if (functionType.parameterTypes().stream().distinct().count() != 1) {\n+                original.writeTo(System.err);\n+                throw new IllegalArgumentException(\"Only FuncOps with exactly one distinct parameter type are supported\");\n+            }\n+            \/\/ if the return type does not match the input types, we keep it\n+            TypeElement retType = functionType.returnType().equals(functionType.parameterTypes().getFirst())\n+                    ? type\n+                    : functionType.returnType();\n+            return CoreOps.func(original.funcName(), FunctionType.functionType(retType, type, type))\n+                    .body(builder -> builder.transformBody(original.body(), builder.parameters(), (block, op) -> {\n+                                block.context().mapValue(op.result(), block.op(retype(block.context(), op)));\n+                                return block;\n+                            })\n+                    );\n+        }\n+\n+        private static Op retype(CopyContext context, Op op) {\n+            return switch (op) {\n+                case CoreOps.VarOp varOp ->\n+                        CoreOps.var(varOp.varName(), context.getValueOrDefault(varOp.operands().getFirst(), varOp.operands().getFirst()));\n+                default -> op;\n+            };\n+        }\n+\n+        private static Stream<Arguments> argumentsForMethod(CoreOps.FuncOp funcOp, Method testMethod) {\n+            Parameter[] testMethodParameters = testMethod.getParameters();\n+            List<TypeElement> funcParameters = funcOp.invokableType().parameterTypes();\n+            if (testMethodParameters.length - 1 != funcParameters.size()) {\n+                throw new IllegalArgumentException(\"method \" + testMethod + \" does not take the correct number of parameters\");\n+            }\n+            if (testMethodParameters[0].getType() != CoreOps.FuncOp.class) {\n+                throw new IllegalArgumentException(\"method \" + testMethod + \" does not take a leading FuncOp argument\");\n+            }\n+            Named<CoreOps.FuncOp> opNamed = Named.of(funcOp.funcName() + \"{\" + funcOp.invokableType() + \"}\", funcOp);\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            for (int i = 1; i < testMethodParameters.length; i++) {\n+                Class<?> resolved = resolveParameter(funcParameters.get(i - 1), lookup);\n+                if (!isCompatible(resolved, testMethodParameters[i].getType())) {\n+                    System.out.println(testMethod + \" does not accept inputs of type \" + resolved + \" at index \" + i);\n+                    return Stream.empty();\n+                }\n+            }\n+            List<List<Object>> allInputs = new ArrayList<>();\n+            for (TypeElement parameterType : funcParameters) {\n+                allInputs.add(INTERESTING_INPUTS.get((JavaType) parameterType));\n+            }\n+            return cartesianProduct(allInputs)\n+                    .map(objects -> {\n+                        objects.add(opNamed);\n+                        return objects.reversed().toArray(); \/\/ reverse so FuncOp is at the beginning\n+                    })\n+                    .map(Arguments::of);\n+        }\n+\n+        private static Class<?> resolveParameter(TypeElement typeElement, MethodHandles.Lookup lookup) {\n+            try {\n+                return ((JavaType) typeElement).resolve(lookup);\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        \/\/ check whether elements of type sourceType can be passed to a parameter of parameterType\n+        private static boolean isCompatible(Class<?> sourceType, Class<?> parameterType) {\n+            return wrapped(parameterType).isAssignableFrom(wrapped(sourceType));\n+        }\n+\n+        private static Class<?> wrapped(Class<?> target) {\n+            return MethodType.methodType(target).wrap().returnType();\n+        }\n+\n+        private static Stream<Method> codeReflectionMethods(Class<?> testClass) {\n+            return Arrays.stream(testClass.getDeclaredMethods())\n+                    .filter(method -> method.accessFlags().contains(AccessFlag.STATIC))\n+                    .filter(method -> method.isAnnotationPresent(CodeReflection.class));\n+        }\n+\n+    }\n+\n+    private static Object interpret(Object left, Object right, CoreOps.FuncOp op) {\n+        return Interpreter.invoke(MethodHandles.lookup(), op, left, right);\n+    }\n+\n+    private static Object bytecode(Object left, Object right, CoreOps.FuncOp op) throws Throwable {\n+        CoreOps.FuncOp func = SSA.transform(op.transform((block, o) -> {\n+            if (o instanceof Op.Lowerable lowerable) {\n+                return lowerable.lower(block);\n+            } else {\n+                block.op(o);\n+                return block;\n+            }\n+        }));\n+        MethodHandle handle = BytecodeGenerator.generate(MethodHandles.lookup(), func);\n+        return handle.invoke(left, right);\n+    }\n+\n+    private static void assertResults(Result first, Result second) {\n+        System.out.println(\"first: \" + first);\n+        System.out.println(\"second: \" + second);\n+        \/\/ either the same error occurred on both or no error occurred\n+        if (first.throwable != null || second.throwable != null) {\n+            assertNotNull(first.throwable, \"only second threw an exception\");\n+            assertNotNull(second.throwable, \"only first threw an exception\");\n+            if (first.throwable.getClass() != second.throwable.getClass()) {\n+                first.throwable.printStackTrace();\n+                second.throwable.printStackTrace();\n+                fail(\"Different exceptions were thrown\");\n+            }\n+            return;\n+        }\n+        \/\/ otherwise, both results should be non-null and equals\n+        assertNotNull(first.onSuccess);\n+        assertEquals(first.onSuccess, second.onSuccess);\n+    }\n+\n+    private static <T> Result runCatching(ThrowingSupplier<T> supplier) {\n+        Object value = null;\n+        Throwable interpretThrowable = null;\n+        try {\n+            value = supplier.get();\n+        } catch (Throwable t) {\n+            interpretThrowable = t;\n+        }\n+        return new Result(value, interpretThrowable);\n+    }\n+\n+    record Result(Object onSuccess, Throwable throwable) {\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCreation\n+ *\/\n+\n+public class TestArrayCreation {\n+    @CodeReflection\n+    public static String[] f() {\n+        return new String[10];\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f2() {\n+        return new String[10][];\n+    }\n+\n+    @Test\n+    public void testf2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f2());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f3() {\n+        return new String[10][10];\n+    }\n+\n+    @Test\n+    public void testf3() {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f3());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayCreation.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayTypes\n+ *\/\n+\n+public class TestArrayTypes {\n+    @CodeReflection\n+    public static Class<?> f() {\n+        return String[].class;\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f());\n+    }\n+\n+    @CodeReflection\n+    public static Class<?> f2() {\n+        return int[][].class;\n+    }\n+\n+    @Test\n+    public void testf2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f2());\n+    }\n+\n+    @CodeReflection\n+    public static Class<?> f3() {\n+        return CoreOps.ArrayLengthOp[][][][][][][].class;\n+    }\n+\n+    @Test\n+    public void testf3() {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f), f3());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestArrayTypes.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestArrayTypes.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestBinops\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestBinops {\n+\n+    @CodeReflection\n+    public static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @Test\n+    public void testNot() {\n+        CoreOps.FuncOp f = getFuncOp(\"not\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, true), not(true));\n+        Assert.assertEquals(Interpreter.invoke(f, false), not(false));\n+    }\n+\n+    @CodeReflection\n+    public static int mod(int a, int b) {\n+        return a % b;\n+    }\n+\n+    @Test\n+    public void testMod() {\n+        CoreOps.FuncOp f = getFuncOp(\"mod\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), mod(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static int bitand(int a, int b) {\n+        return a & b;\n+    }\n+\n+    @Test\n+    public void testBitand() {\n+        CoreOps.FuncOp f = getFuncOp(\"bitand\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitand(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static int bitor(int a, int b) {\n+        return a | b;\n+    }\n+\n+    @Test\n+    public void testBitor() {\n+        CoreOps.FuncOp f = getFuncOp(\"bitor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitor(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static int bitxor(int a, int b) {\n+        return a ^ b;\n+    }\n+\n+    @Test\n+    public void testBitxor() {\n+        CoreOps.FuncOp f = getFuncOp(\"bitxor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 10, 3), bitxor(10, 3));\n+    }\n+\n+    @CodeReflection\n+    public static boolean booland(boolean a, boolean b) {\n+        return a & b;\n+    }\n+\n+    @Test\n+    public void testBooland() {\n+        CoreOps.FuncOp f = getFuncOp(\"booland\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, true, false), booland(true, false));\n+    }\n+\n+    @CodeReflection\n+    public static boolean boolor(boolean a, boolean b) {\n+        return a | b;\n+    }\n+\n+    @Test\n+    public void testBoolor() {\n+        CoreOps.FuncOp f = getFuncOp(\"boolor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, false, true), boolor(false, true));\n+    }\n+\n+    @CodeReflection\n+    public static boolean boolxor(boolean a, boolean b) {\n+        return a ^ b;\n+    }\n+\n+    @Test\n+    public void testBoolxor() {\n+        CoreOps.FuncOp f = getFuncOp(\"boolxor\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, true, true), boolxor(true, true));\n+    }\n+\n+    @CodeReflection\n+    public static double doublemod(double a, double b) {\n+        return a % b;\n+    }\n+\n+    @Test\n+    public void testDoublemod() {\n+        CoreOps.FuncOp f = getFuncOp(\"doublemod\");\n+\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 15.6, 2.1), doublemod(15.6, 2.1));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBinops.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBinops.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestBlockIndexes\n+ *\/\n+\n+public class TestBlockIndexes {\n+\n+    @CodeReflection\n+    static int f(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testBlockIndexes() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        assertBlockIndexes(f);\n+\n+        AtomicBoolean first = new AtomicBoolean(true);\n+        f = f.transform((block, op) -> {\n+            if (first.getAndSet(false)) {\n+                \/\/ Create some blocks without predecessors\n+                for (int i = 0; i < 5; i++) {\n+                    Block.Builder redundant = block.block();\n+                    redundant.op(CoreOps._return());\n+                }\n+            }\n+            block.op(op);\n+            return block;\n+        });\n+        assertBlockIndexes(f);\n+    }\n+\n+    static void assertBlockIndexes(CoreOps.FuncOp f) {\n+        for (Block b : f.body().blocks()) {\n+            Assert.assertEquals(b.index(), b.parentBody().blocks().indexOf(b));\n+        }\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBlockIndexes.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockIndexes.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestBlockOp\n+ *\/\n+\n+public class TestBlockOp {\n+\n+    @CodeReflection\n+    public static int f() {\n+        int i = 0;\n+\n+        {\n+            i++;\n+        }\n+\n+        {\n+            i += 2;\n+        }\n+\n+        return i;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBlockOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockOp.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestBlockParameters\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+\n+public class TestBlockParameters {\n+    static FuncOp m() {\n+        return func(\"f\", functionType(INT, INT, INT))\n+                .body(fe -> {\n+                    LambdaOp lop = lambda(fe.parentBody(), functionType(INT, INT), JavaType.type(FunctionType.class))\n+                            .body(le -> {\n+                                le.op(_return(le.parameters().get(0)));\n+                            });\n+                    fe.op(lop);\n+                    Block.Builder b = fe.block(INT, INT);\n+                    fe.op(branch(b.successor(fe.parameters())));\n+\n+                    b.op(_return(b.parameters().get(0)));\n+                });\n+    }\n+\n+    @Test\n+    public void t() {\n+        FuncOp m = m();\n+        m.traverse(null, CodeElement.blockVisitor((_, b) -> {\n+            for (Block.Parameter p : b.parameters()) {\n+                testBlockParameter(p);\n+            }\n+\n+            return null;\n+        }));\n+    }\n+\n+    void testBlockParameter(Block.Parameter p) {\n+        Assert.assertEquals(p.index(), p.declaringBlock().parameters().indexOf(p));\n+\n+        if (p.invokableOperation() instanceof Op.Invokable iop) {\n+            Assert.assertTrue(p.declaringBlock().isEntryBlock());\n+            Assert.assertEquals(p.index(), iop.parameters().indexOf(p));\n+        } else {\n+            \/\/ There are no non-invokable operations with bodies in the model\n+            Assert.assertFalse(p.declaringBlock().isEntryBlock());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBlockParameters.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestBreakContinue\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.BitSet;\n+import java.util.Optional;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+public class TestBreakContinue {\n+\n+    @CodeReflection\n+    public static BitSet forLoopBreakContinue(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        for (int i = 0; i < 8; i++) {\n+            b.set(i);\n+            int r = f.applyAsInt(i);\n+            if (r == 0) {\n+                continue;\n+            } else if (r == 1) {\n+                break;\n+            }\n+            b.set(i * 2);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testForLoopBreakContinue() {\n+        CoreOps.FuncOp f = getFuncOp(\"forLoopBreakContinue\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        IntUnaryOperator o = i -> {\n+            if (i <= 3) return -1;\n+            if (i <= 5) return 0;\n+            return 1;\n+        };\n+        Assert.assertEquals(Interpreter.invoke(lf, o), forLoopBreakContinue(o));\n+    }\n+\n+    @CodeReflection\n+    public static BitSet nestedForLoopBreakContinue(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        for (int j = 0; j < 8; j++) {\n+            b.set(j);\n+            int r = f.applyAsInt(j);\n+            if (r == 0) {\n+                continue;\n+            } else if (r == 1) {\n+                break;\n+            }\n+            for (int i = 8; i < 16; i++) {\n+                b.set(i);\n+                r = f.applyAsInt(i);\n+                if (r == 2) {\n+                    continue;\n+                } else if (r == 3) {\n+                    break;\n+                }\n+                b.set(i * 2);\n+            }\n+            b.set(j * 2);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testNestedForLoopBreakContinue() {\n+        CoreOps.FuncOp f = getFuncOp(\"nestedForLoopBreakContinue\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int r = -1; r < 4; r++) {\n+            int fr = r;\n+            IntUnaryOperator o = i -> fr;\n+            Assert.assertEquals(Interpreter.invoke(lf, o), nestedForLoopBreakContinue(o));\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static BitSet forLoopLabeledBreakContinue(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        outer: for (int j = 0; j < 8; j++) {\n+            b.set(j);\n+            int r = f.applyAsInt(j);\n+            if (r == 0) {\n+                continue outer;\n+            } else if (r == 1) {\n+                break outer;\n+            }\n+            inner: for (int i = 8; i < 16; i++) {\n+                b.set(i);\n+                r = f.applyAsInt(i);\n+                if (r == 2) {\n+                    continue inner;\n+                } else if (r == 3) {\n+                    break inner;\n+                } else if (r == 4) {\n+                    continue outer;\n+                } else if (r == 5) {\n+                    break outer;\n+                }\n+                b.set(i * 2);\n+            }\n+            b.set(j * 2);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testForLoopLabeledBreakContinue() {\n+        CoreOps.FuncOp f = getFuncOp(\"forLoopLabeledBreakContinue\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int r = -1; r < 6; r++) {\n+            int fr = r;\n+            IntUnaryOperator o = i -> fr;\n+            Assert.assertEquals(Interpreter.invoke(lf, o), forLoopLabeledBreakContinue(o));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static BitSet blockBreak(IntUnaryOperator f) {\n+        BitSet b = new BitSet();\n+        a: b: {\n+            b.set(1);\n+            if (f.applyAsInt(1) != 0) {\n+                break a;\n+            }\n+            b.set(2);\n+            if (f.applyAsInt(2) != 0) {\n+                break b;\n+            }\n+            b.set(3);\n+            c: {\n+                b.set(4);\n+                if (f.applyAsInt(4) != 0) {\n+                    break a;\n+                }\n+                b.set(5);\n+                if (f.applyAsInt(5) != 0) {\n+                    break b;\n+                }\n+                b.set(6);\n+                if (f.applyAsInt(6) != 0) {\n+                    break c;\n+                }\n+                b.set(7);\n+            }\n+            b.set(8);\n+        }\n+        return b;\n+    }\n+\n+    @Test\n+    public void testBlockBreak() {\n+        CoreOps.FuncOp f = getFuncOp(\"blockBreak\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int i = 0; i < 7; i++) {\n+            int fi = i;\n+            IntUnaryOperator o = v -> v == fi ? 1 : 0;\n+            Assert.assertEquals(Interpreter.invoke(lf, o), blockBreak(o));\n+        }\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestBreakContinue.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBreakContinue.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.util.function.IntBinaryOperator;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.FunctionType.VOID;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+\/*\n+ * @test\n+ * @run testng TestBuild\n+ *\/\n+\n+public class TestBuild {\n+\n+    public LambdaOp f() {\n+        IntBinaryOperator ibo = (IntBinaryOperator & Quotable) (a, b) -> a + b;\n+        Quotable iboq = (Quotable) ibo;\n+        return SSA.transform((LambdaOp) iboq.quoted().op());\n+    }\n+\n+    @Test\n+    public void testBoundValueAsOperand() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.invokableType());\n+        var block = body.entryBlock();\n+\n+        var a = f.body().entryBlock().parameters().get(0);\n+        var b = f.body().entryBlock().parameters().get(1);\n+        \/\/ Passing bound values as operands to a new unbound operation\n+        var addop = add(a, b);\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> block.op(addop));\n+    }\n+\n+    @Test\n+    public void testBoundValueAsHeaderArgument() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.invokableType());\n+        var block = body.entryBlock();\n+        var anotherBlock = block.block(INT, INT);\n+\n+        var a = f.body().entryBlock().parameters().get(0);\n+        var b = f.body().entryBlock().parameters().get(1);\n+        \/\/ Passing bound values as header arguments of a header\n+        \/\/ that is the successor of a terminal operation\n+        var brop = branch(anotherBlock.successor(a, b));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> block.op(brop));\n+    }\n+\n+    @Test\n+    public void testUnmappedBoundValue() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.invokableType());\n+        var block = body.entryBlock();\n+\n+        var freturnOp = f.body().entryBlock().terminatingOp();\n+        \/\/ Unmapped bound value that is operand of the bound return op\n+        Assert.assertThrows(IllegalArgumentException.class, () -> block.op(freturnOp));\n+    }\n+\n+    @Test\n+    public void testMappingToBoundValue() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.invokableType());\n+        var block = body.entryBlock();\n+\n+        var result = f.body().entryBlock().firstOp().result();\n+        \/\/ Mapping to a bound value\n+        Assert.assertThrows(IllegalArgumentException.class, () -> block.context().mapValue(result, result));\n+    }\n+\n+    @Test\n+    public void testMappedBoundValue() {\n+        LambdaOp f = f();\n+\n+        var body = Body.Builder.of(null, f.invokableType());\n+        var block = body.entryBlock();\n+\n+        var a = block.parameters().get(0);\n+        var b = block.parameters().get(1);\n+        var result = block.op(add(a, b));\n+        \/\/ Map the bound value used as the operand to the bound return op to\n+        \/\/ the above value\n+        block.context().mapValue(f.body().entryBlock().firstOp().result(), result);\n+\n+        var freturnOp = f.body().entryBlock().terminatingOp();\n+        \/\/ No error since values (operands) are mapped\n+        block.op(freturnOp);\n+    }\n+\n+    @Test\n+    public void testPartiallyConstructedValueAccess() {\n+        var body = Body.Builder.of(null, functionType(INT, INT, INT));\n+        var block = body.entryBlock();\n+\n+        Block.Parameter a = block.parameters().get(0);\n+        Block.Parameter b = block.parameters().get(1);\n+        Op.Result result = block.op(add(a, b));\n+\n+        \/\/ Access the declaring block of values before the block and its body are\n+        \/\/ constructed\n+        Assert.assertThrows(IllegalStateException.class, a::declaringBlock);\n+        Assert.assertThrows(IllegalStateException.class, result::declaringBlock);\n+        \/\/ Access to parent block\/body of operation result before they are constructed\n+        Assert.assertThrows(IllegalStateException.class, result.op()::parentBlock);\n+        Assert.assertThrows(IllegalStateException.class, result.op()::ancestorBody);\n+        \/\/ Access to set of users before constructed\n+        Assert.assertThrows(IllegalStateException.class, a::uses);\n+\n+        block.op(_return(result));\n+\n+        var f = func(\"f\", body);\n+\n+        Assert.assertNotNull(a.declaringBlock());\n+        Assert.assertNotNull(result.declaringBlock());\n+        Assert.assertNotNull(result.op().parentBlock());\n+        Assert.assertNotNull(result.op().ancestorBody());\n+        Assert.assertNotNull(a.uses());\n+    }\n+\n+    @Test\n+    public void testPartiallyConstructedHeaderAccess() {\n+        var body = Body.Builder.of(null, functionType(INT, INT, INT));\n+        var block = body.entryBlock();\n+        var anotherBlock = block.block(INT, INT);\n+\n+        var a = block.parameters().get(0);\n+        var b = block.parameters().get(1);\n+        Block.Reference successor = anotherBlock.successor(a, b);\n+        \/\/ Access to target block before constructed\n+        Assert.assertThrows(IllegalStateException.class, successor::targetBlock);\n+        block.op(branch(anotherBlock.successor(a, b)));\n+\n+        a = anotherBlock.parameters().get(0);\n+        b = anotherBlock.parameters().get(1);\n+        var result = anotherBlock.op(add(a, b));\n+        anotherBlock.op(_return(result));\n+\n+        var f = func(\"f\", body);\n+\n+        Assert.assertNotNull(successor.targetBlock());\n+    }\n+\n+    @Test\n+    public void testValueUseFromOtherModel() {\n+        var abody = Body.Builder.of(null, functionType(INT, INT, INT));\n+        var ablock = abody.entryBlock();\n+        var aa = ablock.parameters().get(0);\n+        var ab = ablock.parameters().get(1);\n+\n+        var bbody = Body.Builder.of(null, abody.bodyType());\n+        var bblock = bbody.entryBlock();\n+\n+        \/\/ Operation uses values from another model\n+        var addOp = add(aa, ab);\n+        Assert.assertThrows(IllegalStateException.class, () -> bblock.op(addOp));\n+    }\n+\n+    @Test\n+    public void testHeaderFromOtherBody() {\n+        var abody = Body.Builder.of(null, VOID);\n+        var ablock = abody.entryBlock().block();\n+\n+        var bbody = Body.Builder.of(null, VOID);\n+        var bblock = bbody.entryBlock();\n+\n+        \/\/ Operation uses header with target block from another model\n+        var brOp = branch(ablock.successor());\n+        Assert.assertThrows(IllegalStateException.class, () -> bblock.op(brOp));\n+    }\n+\n+    @Test\n+    public void testHeaderFromEntryBlock() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        Assert.assertThrows(IllegalStateException.class, block::successor);\n+    }\n+\n+    @Test\n+    public void testBuiltBodyBuilder() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+        func(\"f\", body);\n+\n+        \/\/ Body is built\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testBodyBuilderWithBuiltAncestor() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+        func(\"f\", body);\n+\n+        \/\/ ancestor body is built\n+        Assert.assertThrows(IllegalStateException.class, () -> Body.Builder.of(body, VOID));\n+    }\n+\n+    @Test\n+    public void testBodyBuilderWithUnbuiltChildren() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+\n+        Body.Builder.of(body, VOID);\n+\n+        \/\/ Great-grandchild body is not built\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testMistmatchedBody() {\n+        var body1 = Body.Builder.of(null, VOID);\n+        var block1 = body1.entryBlock();\n+\n+        var anotherBody = Body.Builder.of(null, VOID);\n+\n+        var body2 = Body.Builder.of(anotherBody, VOID);\n+        var block2 = body2.entryBlock();\n+        block2.op(_return());\n+        var lambdaOp = lambda(type(Runnable.class), body2);\n+\n+        \/\/ Op's grandparent body is not parent body of block1\n+        Assert.assertThrows(IllegalStateException.class, () -> block1.op(lambdaOp));\n+    }\n+\n+    @Test\n+    public void testAppendAfterTerminatingOperation() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+\n+        \/\/ Append operation after terminating operation\n+        Assert.assertThrows(IllegalStateException.class, () -> block.op(_return()));\n+    }\n+\n+    @Test\n+    public void testNoTerminatingOperation() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(constant(INT, 0));\n+\n+        \/\/ No terminating operation\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testUnreferencedBlocksRemoved() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        block.op(_return());\n+\n+        \/\/ Create empty blocks\n+        block.block();\n+        block.block();\n+        block.block();\n+\n+        FuncOp f = func(\"f\", body);\n+        Assert.assertEquals(f.body().blocks().size(), 1);\n+    }\n+\n+    @Test\n+    public void testEmptyEntryBlock() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testNonEmptyEntryBlockNoTerminatingOp() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        \/\/ No terminating op\n+        block.op(constant(INT, 0));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testEmptyBlockWithPredecessor() {\n+        var body = Body.Builder.of(null, VOID);\n+        var entryBlock = body.entryBlock();\n+        \/\/ Create empty block\n+        var block = entryBlock.block();\n+        \/\/ Branch to empty block\n+        entryBlock.op(branch(block.successor()));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testNonEmptyBlockNoTerminatingOp() {\n+        var body = Body.Builder.of(null, VOID);\n+        var entryBlock = body.entryBlock();\n+        \/\/ Create empty block\n+        var block = entryBlock.block();\n+        \/\/ Branch to empty block\n+        entryBlock.op(branch(block.successor()));\n+        \/\/ No terminating op\n+        block.op(constant(INT, 0));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestClosureOps\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.type.JavaType;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.add;\n+import static java.lang.reflect.code.op.CoreOps.closure;\n+import static java.lang.reflect.code.op.CoreOps.closureCall;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.op.CoreOps.quoted;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public class TestClosureOps {\n+\n+    static class Builder {\n+        static final MethodRef ACCEPT_METHOD = MethodRef.method(type(TestClosureOps.Builder.class), \"accept\",\n+                INT, CoreOps.QuotedOp.QUOTED_TYPE);\n+\n+        static int accept(Quoted c) {\n+            Assert.assertEquals(1, c.capturedValues().size());\n+            Assert.assertEquals(1, c.capturedValues().values().iterator().next());\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) c.op(),\n+                    c.capturedValues(), 42);\n+            return r;\n+        }\n+    }\n+\n+    @Test\n+    public void testQuotedWithCapture() {\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional type = (int)int\n+                    \/\/ op descriptor = ()Quoted<ClosureOp>\n+                    CoreOps.QuotedOp qop = quoted(block.parentBody(), qblock -> {\n+                        return closure(qblock.parentBody(), functionType(INT, INT))\n+                                .body(cblock -> {\n+                                    Block.Parameter ci = cblock.parameters().get(0);\n+\n+                                    cblock.op(_return(\n+                                            \/\/ capture i from function's body\n+                                            cblock.op(add(i, ci))\n+                                    ));\n+                                });\n+                    });\n+                    Op.Result cquoted = block.op(qop);\n+\n+                    Op.Result or = block.op(CoreOps.invoke(TestClosureOps.Builder.ACCEPT_METHOD, cquoted));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testWithCapture() {\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional type = (int)int\n+                    \/\/   captures i\n+                    CoreOps.ClosureOp closure = CoreOps.closure(block.parentBody(),\n+                                    functionType(INT, INT))\n+                            .body(cblock -> {\n+                                Block.Parameter ci = cblock.parameters().get(0);\n+\n+                                cblock.op(_return(\n+                                        cblock.op(add(i, ci))));\n+                            });\n+                    Op.Result c = block.op(closure);\n+\n+                    Op.Result fortyTwo = block.op(constant(INT, 42));\n+                    Op.Result or = block.op(closureCall(c, fortyTwo));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testQuotableModel() {\n+        Quoted quoted = () -> {};\n+        Op qop = quoted.op();\n+        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Assert.assertTrue(top instanceof CoreOps.FuncOp);\n+\n+        CoreOps.FuncOp fop = (CoreOps.FuncOp) top;\n+        Assert.assertEquals(JavaType.type(Quoted.class), fop.invokableType().returnType());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestClosureOps.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestConcat\n+ *\/\n+\n+public class TestConcat {\n+\n+    static final String TESTSTR = \"TESTING STRING\";\n+\n+    @CodeReflection\n+    static String f() {\n+       int test = 1;\n+       String res = \"HI \" + TESTSTR + test;\n+       return res;\n+    }\n+\n+\n+    @CodeReflection\n+    public static String byteConcat1(byte b, String s) {\n+       return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String byteConcat2(String s, byte b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String shortConcat1(short b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String shortConcat2(String s, short b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcat1(int b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String intConcat2(String s, int b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String longConcat1(long b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String longConcat2(String s, long b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String floatConcat1(float b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String floatConcat2(String s, float b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String doubleConcat1(double b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String doubleConcat2(String s, double b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String booleanConcat1(boolean b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String booleanConcat2(String s, boolean b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String charConcat1(char b, String s) {\n+        return b + s;\n+    }\n+    @CodeReflection\n+    public static String charConcat2(String s, char b) {\n+        return s + b;\n+    }\n+    @CodeReflection\n+    public static String objectConcat1(Object b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String objectConcat2(String s, Object b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String objectConcat3(TestObject b, String s) {\n+        return b + s;\n+    }\n+\n+    @CodeReflection\n+    public static String objectConcat4(String s, TestObject b) {\n+        return s + b;\n+    }\n+\n+    @CodeReflection\n+    public static String stringConcat(String b, String s) {\n+        return b + s;\n+    }\n+\n+\n+    record TestMethodData(Class<?> first, Class<?> second, String third) {\n+    }\n+\n+    static final Map<Class<?>, Object> valMap;\n+    static {\n+        valMap = new HashMap<>();\n+        valMap.put(byte.class, (byte) 42);\n+        valMap.put(short.class, (short) 42);\n+        valMap.put(int.class, 42);\n+        valMap.put(long.class, (long) 42);\n+        valMap.put(float.class, 42f);\n+        valMap.put(double.class, 42d);\n+        valMap.put(char.class, 'z');\n+        valMap.put(boolean.class, false);\n+        valMap.put(Object.class, new Object() {\n+                    @Override\n+                    public String toString() {\n+                        return \"I'm a test string.\";\n+                    }\n+                });\n+        valMap.put(TestObject.class, new TestObject());\n+        valMap.put(String.class, TESTSTR);\n+    }\n+    private static String testName(Class<?> n, Integer i){\n+        return n.getSimpleName().toLowerCase() + \"Concat\" + i;\n+    }\n+    @DataProvider(name = \"testData\")\n+    public static Object[][]  testData() {\n+        Set<Class<?>> types = Set.of(byte.class, short.class, int.class, long.class, float.class,\n+                double.class, char.class, boolean.class, Object.class);\n+\n+        \/\/Types from types concatenated to strings left-to-right and right-to-left\n+        Stream<TestMethodData> s1 = types.stream().map(t -> new TestMethodData(t, String.class, testName(t, 1)));\n+        Stream<TestMethodData> s2 = types.stream().map(t -> new TestMethodData(String.class, t, testName(t, 2)));\n+\n+        \/\/Custom Object and basic string concat tests\n+        Stream<TestMethodData> s3 = Stream.of(new TestMethodData(TestObject.class, String.class, testName(Object.class, 3)),\n+                                      new TestMethodData(String.class, TestObject.class, testName(Object.class, 4)),\n+                                      new TestMethodData(String.class, String.class, \"stringConcat\"));\n+\n+        Object[] t = Stream.concat(Stream.concat(s1,s2),s3).toArray();\n+\n+        Object[][] args = new Object[t.length][];\n+\n+        for(int i = 0; i < args.length; i++) {\n+            args[i] = new Object[]{ t[i] };\n+        }\n+\n+        return args;\n+    }\n+\n+    @Test(dataProvider = \"testData\")\n+    public static void testRun(TestMethodData t) {\n+        try {\n+            Object[] args = new Object[] {valMap.get(t.first), valMap.get(t.second)};\n+            Class<TestConcat> clazz = TestConcat.class;\n+            Method method = clazz.getDeclaredMethod(t.third, t.first, t.second);\n+            CoreOps.FuncOp f = method.getCodeModel().orElseThrow();\n+            var res1 = Interpreter.invoke(MethodHandles.lookup(), f, args);\n+            var res2 = method.invoke(null, args);\n+\n+            Assert.assertEquals(res1, res2);\n+\n+        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static final class TestObject {\n+        TestObject(){}\n+\n+        @Override\n+        public String toString() {\n+            return \"TestObject String\";\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConcat.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestConditionalExpression\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestConditionalExpression {\n+    @CodeReflection\n+    public static int simpleExpression(boolean b, int x, int y) {\n+        return b ? x : y;\n+    }\n+\n+    @Test\n+    public void testSimpleExpression() {\n+        CoreOps.FuncOp f = getFuncOp(\"simpleExpression\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, true, 1, 2), simpleExpression(true, 1, 2));\n+        Assert.assertEquals(Interpreter.invoke(lf, false, 1, 2), simpleExpression(false, 1, 2));\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestConditionalExpression.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalExpression.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestConditionalOp\n+ *\/\n+\n+public class TestConditionalOp {\n+\n+    @CodeReflection\n+    static boolean f(boolean a, boolean b, boolean c, List<String> l) {\n+        return F.a(a, l) || (F.b(b, l) && F.c(c, l));\n+    }\n+\n+    static class F {\n+        static boolean a(boolean a, List<String> l) {\n+            l.add(\"a\");\n+            return a;\n+        }\n+\n+        static boolean b(boolean b, List<String> l) {\n+            l.add(\"b\");\n+            return b;\n+        }\n+\n+        static boolean c(boolean c, List<String> l) {\n+            l.add(\"c\");\n+            return c;\n+        }\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestConditionalOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int i = 0; i < 8; i++) {\n+            boolean a = (i & 1) != 0;\n+            boolean b = (i & 2) != 0;\n+            boolean c = (i & 4) != 0;\n+            List<String> la = new ArrayList<>();\n+            boolean ra = (boolean) Interpreter.invoke(MethodHandles.lookup(), lf, a, b, c, la);\n+\n+            List<String> le = new ArrayList<>();\n+            boolean re = f(a, b, c, le);\n+\n+            Assert.assertEquals(ra, re);\n+            Assert.assertEquals(la, le);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConditionalOp.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestConstants\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestConstants {\n+\n+    @CodeReflection\n+    public static boolean c_boolean() {\n+        return true;\n+    }\n+\n+    @CodeReflection\n+    public static boolean c_boolean_f() {\n+        return false;\n+    }\n+\n+    @CodeReflection\n+    public static byte c_byte() {\n+        return 42;\n+    }\n+\n+    @CodeReflection\n+    public static byte c_byte_neg() {\n+        return -42;\n+    }\n+\n+    @CodeReflection\n+    public static short c_short() {\n+        return 42;\n+    }\n+\n+    @CodeReflection\n+    public static short c_short_neg() {\n+        return -42;\n+    }\n+\n+    @CodeReflection\n+    public static char c_char() {\n+        return 'A';\n+    }\n+\n+    @CodeReflection\n+    public static int c_int() {\n+        return 42;\n+    }\n+\n+    @CodeReflection\n+    public static int c_int_neg() {\n+        return -42;\n+    }\n+\n+    @CodeReflection\n+    public static long c_long() {\n+        return 42L;\n+    }\n+\n+    @CodeReflection\n+    public static long c_long_neg() {\n+        return -42L;\n+    }\n+\n+    @CodeReflection\n+    public static float c_float() {\n+        return 1.0f;\n+    }\n+\n+    @CodeReflection\n+    public static float c_float_neg() {\n+        return -1.0f;\n+    }\n+\n+    @CodeReflection\n+    public static double c_double() {\n+        return 1.0;\n+    }\n+\n+    @CodeReflection\n+    public static double c_double_neg() {\n+        return -1.0;\n+    }\n+\n+    @CodeReflection\n+    public static String c_String() {\n+        String s = \"42\";\n+        s = null;\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    public static Class<?> c_Class() {\n+        return String.class;\n+    }\n+\n+    @CodeReflection\n+    public static Class<?> c_Class_primitive() {\n+        return float.class;\n+    }\n+\n+    @DataProvider\n+    static Object[][] provider() {\n+        return new Object[][] {\n+                { boolean.class },\n+                { byte.class },\n+                { short.class },\n+                { char.class },\n+                { int.class },\n+                { long.class },\n+                { float.class },\n+                { double.class },\n+                { String.class },\n+                { Class.class }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provider\")\n+    public void testString(Class<?> c) throws Exception {\n+        String name = \"c_\" + c.getSimpleName();\n+        List<Method> ms = Stream.of(TestConstants.class.getDeclaredMethods())\n+                .filter(m -> m.getName().startsWith(name))\n+                .toList();\n+\n+        for (Method m : ms) {\n+            CoreOps.FuncOp f = m.getCodeModel().get();\n+\n+            f.writeTo(System.out);\n+\n+            Assert.assertEquals(Interpreter.invoke(f), m.invoke(null));\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static String compareNull(String s) {\n+        if (s == null) {\n+            return \"NULL\";\n+        } else {\n+            return s;\n+        }\n+    }\n+\n+    @Test\n+    public void testCompareNull() {\n+        CoreOps.FuncOp f = getFuncOp(\"compareNull\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf, (Object) null), compareNull(null));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestConstants.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestConstants.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestCopy\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.OpDefinition;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+public class TestCopy {\n+\n+    @CodeReflection\n+    static int f(int i) {\n+        IntUnaryOperator f = j -> i + j;\n+        return f.applyAsInt(42);\n+    }\n+\n+    @Test\n+    public void testCopy() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        Op copy = f.copy();\n+\n+        Assert.assertEquals(f.toText(), copy.toText());\n+    }\n+\n+    @Test\n+    public void testCopyWithDefinition() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        OpDefinition odef = OpDefinition.fromOp(CopyContext.create(), f);\n+        Op copy = CoreOps.FACTORY.constructOp(odef);\n+\n+        Assert.assertEquals(f.toText(), copy.toText());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestCopy.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestCopy.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+import static java.lang.reflect.code.op.CoreOps.conditionalBranch;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+\n+\/*\n+ * @test\n+ * @run testng TestDominate\n+ *\/\n+\n+public class TestDominate {\n+\n+    @Test\n+    public void testIfElse() {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+            Block.Builder ifBlock = entry.block();\n+            Block.Builder elseBlock = entry.block();\n+            Block.Builder end = entry.block();\n+\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n+            entry.op(conditionalBranch(p, ifBlock.successor(), elseBlock.successor()));\n+\n+            ifBlock.op(branch(end.successor()));\n+\n+            elseBlock.op(branch(end.successor()));\n+\n+            end.op(_return());\n+        });\n+\n+        boolean[][] bvs = new boolean[][]{\n+                {true, false, false, false},\n+                {true, true, false, false},\n+                {true, false, true, false},\n+                {true, false, false, true}\n+        };\n+\n+        test(f, bvs);\n+    }\n+\n+    @Test\n+    public void testForwardSuccessors() {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+            Block.Builder b1 = entry.block();\n+            Block.Builder b2 = entry.block();\n+            Block.Builder b3 = entry.block();\n+            Block.Builder b4 = entry.block();\n+            Block.Builder b5 = entry.block();\n+\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n+            entry.op(conditionalBranch(p, b4.successor(), b2.successor()));\n+\n+            b4.op(conditionalBranch(p, b5.successor(), b3.successor()));\n+\n+            b2.op(conditionalBranch(p, b5.successor(), b1.successor()));\n+\n+            b5.op(_return());\n+\n+            b3.op(branch(b1.successor()));\n+\n+            b1.op(_return());\n+        });\n+\n+        f.writeTo(System.out);\n+        boolean[][] bvs = new boolean[][]{\n+                {true, false, false, false, false, false},\n+                {true, true, false, false, false, false},\n+                {true, true, true, false, false, false},\n+                {true, false, false, true, false, false},\n+                {true, false, false, false, true, false},\n+                {true, false, false, false, false, true},\n+        };\n+\n+        test(f, bvs);\n+    }\n+\n+    @Test\n+    public void testBackbranch() {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+            Block.Builder cond = entry.block();\n+            Block.Builder body = entry.block();\n+            Block.Builder update = entry.block();\n+            Block.Builder end = entry.block();\n+\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n+            entry.op(branch(cond.successor()));\n+\n+            cond.op(conditionalBranch(p, body.successor(), end.successor()));\n+\n+            body.op(branch(update.successor()));\n+\n+            update.op(branch(cond.successor()));\n+\n+            end.op(_return());\n+\n+        });\n+\n+        boolean[][] bvs = new boolean[][]{\n+                {true, false, false, false, false},\n+                {true, true, false, false, false},\n+                {true, true, true, false, false},\n+                {true, true, true, true, false},\n+                {true, true, false, false, true},\n+        };\n+        test(f, bvs);\n+    }\n+\n+    static void test(CoreOps.FuncOp f, boolean[][] bvs) {\n+        Block[] bs = f.body().blocks().toArray(Block[]::new);\n+        for (int i = 0; i < bs.length; i++) {\n+            for (int j = 0; j < bs.length; j++) {\n+                Block x = bs[i];\n+                Block y = bs[j];\n+                Assert.assertEquals(y.isDominatedBy(x), bvs[j][i]);\n+            }\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testImmediateDominators() {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+            Block.Builder b6 = entry.block();\n+            Block.Builder b5 = entry.block();\n+            Block.Builder b4 = entry.block();\n+            Block.Builder b3 = entry.block();\n+            Block.Builder b2 = entry.block();\n+            Block.Builder b1 = entry.block();\n+\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n+            entry.op(branch(b6.successor()));\n+\n+            b6.op(conditionalBranch(p, b5.successor(), b4.successor()));\n+\n+            b5.op(branch(b1.successor()));\n+\n+            b4.op(conditionalBranch(p, b2.successor(), b3.successor()));\n+\n+            b1.op(branch(b2.successor()));\n+\n+            b2.op(conditionalBranch(p, b1.successor(), b3.successor()));\n+\n+            b3.op(branch(b2.successor()));\n+        });\n+        f.writeTo(System.out);\n+        Map<Block, Block> idoms = f.body().immediateDominators();\n+        System.out.println(idoms);\n+\n+        Block entry = f.body().entryBlock();\n+        Block b6 = entry.successors().get(0).targetBlock();\n+\n+        for (Block b : f.body().blocks()) {\n+            if (b == entry || b == b6) {\n+                Assert.assertEquals(idoms.get(b), entry);\n+            } else {\n+                Assert.assertEquals(idoms.get(b), b6);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCytronExample() {\n+        CoreOps.FuncOp f = func(\"f\", FunctionType.VOID).body(entry -> {\n+            Block.Builder exit = entry.block();\n+            Block.Builder b12 = entry.block();\n+            Block.Builder b11 = entry.block();\n+            Block.Builder b10 = entry.block();\n+            Block.Builder b9 = entry.block();\n+            Block.Builder b8 = entry.block();\n+            Block.Builder b7 = entry.block();\n+            Block.Builder b6 = entry.block();\n+            Block.Builder b5 = entry.block();\n+            Block.Builder b4 = entry.block();\n+            Block.Builder b3 = entry.block();\n+            Block.Builder b2 = entry.block();\n+            Block.Builder b1 = entry.block();\n+\n+            Op.Result p = entry.op(constant(JavaType.BOOLEAN, true));\n+\n+            entry.op(conditionalBranch(p, exit.successor(), b1.successor()));\n+\n+            b1.op(branch(b2.successor()));\n+\n+            b2.op(conditionalBranch(p, b3.successor(), b7.successor()));\n+\n+            b3.op(conditionalBranch(p, b4.successor(), b5.successor()));\n+\n+            b4.op(branch(b6.successor()));\n+\n+            b5.op(branch(b6.successor()));\n+\n+            b6.op(branch(b8.successor()));\n+\n+            b7.op(branch(b8.successor()));\n+\n+            b8.op(branch(b9.successor()));\n+\n+            b9.op(conditionalBranch(p, b10.successor(), b11.successor()));\n+\n+            b10.op(branch(b11.successor()));\n+\n+            b11.op(conditionalBranch(p, b12.successor(), b9.successor()));\n+\n+            b12.op(conditionalBranch(p, exit.successor(), b2.successor()));\n+\n+            exit.op(_return());\n+        });\n+\n+        f.writeTo(System.out);\n+\n+        Map<Block, Block> idoms = f.body().immediateDominators();\n+        Node<String> domTree = buildDomTree(f.body().entryBlock(), idoms).transform(b -> Integer.toString(b.index()));\n+        Node<String> domTreeExpected =\n+                node(\"0\",\n+                        node(\"1\",\n+                                node(\"2\",\n+                                        node(\"7\"),\n+                                        node(\"8\",\n+                                                node(\"9\",\n+                                                        node(\"10\"),\n+                                                        node(\"11\",\n+                                                                node(\"12\")))),\n+                                        node(\"3\",\n+                                                node(\"4\"), node(\"5\"), node(\"6\")))),\n+                        node(\"13\"));\n+        Assert.assertEquals(domTree, domTreeExpected);\n+\n+\n+        Map<String, Set<String>> df = f.body().dominanceFrontier().entrySet().stream()\n+                .map(e -> Map.entry(Integer.toString(e.getKey().index()),\n+                        e.getValue().stream().map(b -> Integer.toString(b.index())).collect(Collectors.toSet())))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        Map<String, Set<String>> dfExpected = Map.ofEntries(\n+                Map.entry(\"1\", Set.of(\"13\")),\n+                Map.entry(\"2\", Set.of(\"13\", \"2\")),\n+                Map.entry(\"3\", Set.of(\"8\")),\n+                Map.entry(\"4\", Set.of(\"6\")),\n+                Map.entry(\"5\", Set.of(\"6\")),\n+                Map.entry(\"6\", Set.of(\"8\")),\n+                Map.entry(\"7\", Set.of(\"8\")),\n+                Map.entry(\"8\", Set.of(\"13\", \"2\")),\n+                Map.entry(\"9\", Set.of(\"13\", \"2\", \"9\")),\n+                Map.entry(\"10\", Set.of(\"11\")),\n+                Map.entry(\"11\", Set.of(\"13\", \"2\", \"9\")),\n+                Map.entry(\"12\", Set.of(\"13\", \"2\"))\n+        );\n+        Assert.assertEquals(df, dfExpected);\n+    }\n+\n+    static Node<Block> buildDomTree(Block entryBlock, Map<Block, Block> idoms) {\n+        Map<Block, Node<Block>> m = new HashMap<>();\n+        for (Map.Entry<Block, Block> e : idoms.entrySet()) {\n+            Block id = e.getValue();\n+            Block b = e.getKey();\n+            if (b == entryBlock) {\n+                continue;\n+            }\n+\n+            Node<Block> parent = m.computeIfAbsent(id, _k -> new Node<>(_k, new HashSet<>()));\n+            Node<Block> child = m.computeIfAbsent(b, _k -> new Node<>(_k, new HashSet<>()));\n+            parent.children.add(child);\n+        }\n+        return m.get(entryBlock);\n+    }\n+\n+    @SafeVarargs\n+    static <T> Node<T> node(T t, Node<T>... children) {\n+        return new Node<>(t, Set.of(children));\n+    }\n+\n+    static <T> Node<T> node(T t, Set<Node<T>> children) {\n+        return new Node<>(t, children);\n+    }\n+\n+    record Node<T>(T t, Set<Node<T>> children) {\n+        <U> Node<U> transform(Function<T, U> f) {\n+            Set<Node<U>> mchildren = new HashSet<>();\n+            for (Node<T> nc : children) {\n+                mchildren.add(nc.transform(f));\n+            }\n+            return node(f.apply(t), mchildren);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestDominate.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestEnhancedForOp\n+ *\/\n+\n+public class TestEnhancedForOp {\n+\n+    @CodeReflection\n+    public static int f() {\n+        int j = 0;\n+        for (int i : List.of(1, 2, 3, 4)) {\n+            j += i;\n+        }\n+        return j;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestEnhancedForOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f());\n+    }\n+\n+\n+    @CodeReflection\n+    public static int array(int[] a) {\n+        int j = 0;\n+        for (int i : a) {\n+            j += i;\n+        }\n+        return j;\n+    }\n+\n+    @Test\n+    public void testArray() {\n+        CoreOps.FuncOp f = getFuncOp(\"array\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        int[] ia = new int[] {1, 2, 3, 4};\n+        Assert.assertEquals(Interpreter.invoke(lf, ia), array(ia));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestEnhancedForOp.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestErasure\n+ *\/\n+\n+import static org.testng.Assert.*;\n+import org.testng.annotations.*;\n+\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Test\n+public class TestErasure {\n+\n+    @Test(dataProvider = \"typesAndErasures\")\n+    public void testErasure(String testName, TypeAndErasure typeAndErasure) {\n+        assertEquals(typeAndErasure.type.erasure(), typeAndErasure.erasure);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] typesAndErasures() {\n+        List<TypeAndErasure> typeAndErasures = new ArrayList<>();\n+        typeAndErasures.addAll(primitives());\n+        typeAndErasures.addAll(references());\n+        typeAndErasures.addAll(genericReferences());\n+        typeAndErasures.addAll(arrays());\n+        typeAndErasures.addAll(typeVars());\n+        return typeAndErasures.stream()\n+                .map(t -> new Object[] { t.type.toString(), t })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    static List<TypeAndErasure> primitives() {\n+        return List.of(\n+                new TypeAndErasure(JavaType.BOOLEAN, JavaType.BOOLEAN),\n+                new TypeAndErasure(JavaType.CHAR, JavaType.CHAR),\n+                new TypeAndErasure(JavaType.BYTE, JavaType.BYTE),\n+                new TypeAndErasure(JavaType.SHORT, JavaType.SHORT),\n+                new TypeAndErasure(JavaType.INT, JavaType.INT),\n+                new TypeAndErasure(JavaType.FLOAT, JavaType.FLOAT),\n+                new TypeAndErasure(JavaType.LONG, JavaType.LONG),\n+                new TypeAndErasure(JavaType.DOUBLE, JavaType.DOUBLE),\n+                new TypeAndErasure(JavaType.VOID, JavaType.VOID));\n+    }\n+\n+    static List<TypeAndErasure> references() {\n+        return List.of(\n+                new TypeAndErasure(JavaType.J_L_STRING, JavaType.J_L_STRING),\n+                new TypeAndErasure(JavaType.J_L_OBJECT, JavaType.J_L_OBJECT));\n+    }\n+\n+    static List<TypeAndErasure> genericReferences() {\n+        JavaType LIST = JavaType.type(List.class);\n+        List<TypeAndErasure> genericTypes = new ArrayList<>();\n+        BoundKind[] kinds = new BoundKind[] { null, BoundKind.EXTENDS, BoundKind.SUPER };\n+        for (BoundKind kind : kinds) {\n+            for (TypeAndErasure t : references()) {\n+                JavaType arg = t.type;\n+                if (kind != null) {\n+                    arg = JavaType.wildcard(kind, arg);\n+                }\n+                genericTypes.add(new TypeAndErasure(JavaType.type(LIST, arg), LIST));\n+            }\n+            for (TypeAndErasure t : primitives()) {\n+                JavaType arg = JavaType.array(t.type);\n+                if (kind != null) {\n+                    arg = JavaType.wildcard(kind, arg);\n+                }\n+                genericTypes.add(new TypeAndErasure(JavaType.type(LIST, arg), LIST));\n+            }\n+        }\n+        return genericTypes;\n+    }\n+\n+    static List<TypeAndErasure> arrays() {\n+        List<TypeAndErasure> arrayTypes = new ArrayList<>();\n+        for (int dims = 1 ; dims <= 3 ; dims++) {\n+            for (TypeAndErasure t : primitives()) {\n+                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+            for (TypeAndErasure t : references()) {\n+                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+            for (TypeAndErasure t : genericReferences()) {\n+                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+        }\n+        return arrayTypes;\n+    }\n+\n+    static List<TypeAndErasure> typeVars() {\n+        List<TypeAndErasure> typeVars = new ArrayList<>();\n+        for (int dims = 1 ; dims <= 3 ; dims++) {\n+            for (TypeAndErasure t : references()) {\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", (ClassType)JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+            for (TypeAndErasure t : genericReferences()) {\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", (ClassType)JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+            for (TypeAndErasure t : arrays()) {\n+                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", (ClassType)JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+        }\n+        return typeVars;\n+    }\n+\n+    record TypeAndErasure(JavaType type, JavaType erasure) { }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestErasure.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,499 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestExceptionRegionOps\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps._throw;\n+import static java.lang.reflect.code.op.CoreOps.branch;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.exceptionRegionEnter;\n+import static java.lang.reflect.code.op.CoreOps.exceptionRegionExit;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.type.FunctionType.*;\n+import static java.lang.reflect.code.type.JavaType.*;\n+import static java.lang.reflect.code.type.JavaType.VOID;\n+\n+public class TestExceptionRegionOps {\n+\n+    public void testF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchER1ISE = fblock.block(type(IllegalStateException.class));\n+                    var catchER1IAE = fblock.block(type(IllegalArgumentException.class));\n+                    var enterER1 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchER1ISE.successor(), catchER1IAE.successor()));\n+\n+                    \/\/ Start of exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er1, end.successor()));\n+                    });\n+\n+                    \/\/ First catch block for exception region\n+                    catchER1ISE.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Second catch for exception region\n+                    catchER1IAE.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testF);\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new NullPointerException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    public void testCatchThrowableF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (Throwable e) {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrowable() {\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchER1ISE = fblock.block(type(IllegalStateException.class));\n+                    var catchER1T = fblock.block(type(Throwable.class));\n+                    var enterER1 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchER1ISE.successor(), catchER1T.successor()));\n+\n+                    \/\/ Start of exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er1, end.successor()));\n+                    });\n+\n+                    \/\/ First catch block for exception region\n+                    catchER1ISE.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Second catch for exception region\n+                    catchER1T.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testCatchThrowableF);\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    public void testNestedF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            try {\n+                c.accept(1);\n+                c.accept(-1);\n+            } catch (IllegalStateException e) {\n+                c.accept(2);\n+                c.accept(-1);\n+            }\n+            c.accept(3);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            c.accept(4);\n+            c.accept(-1);\n+        }\n+        c.accept(5);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testNested() {\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, type(IntConsumer.class)))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchER1 = fblock.block(type(IllegalArgumentException.class));\n+                    var catchER2 = fblock.block(type(IllegalStateException.class));\n+                    var enterER1 = fblock.block();\n+                    var enterER2 = fblock.block();\n+                    var b3 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchER1.successor()));\n+\n+                    \/\/ Start of first exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                    });\n+                    var er2 = enterER1.op(exceptionRegionEnter(\n+                            enterER2.successor(),\n+                            catchER2.successor()));\n+\n+                    \/\/ Start of second exception region\n+                    enterER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of second exception region\n+                        b.op(exceptionRegionExit(er2, b3.successor()));\n+                    });\n+\n+                    \/\/ Catch block for second exception region\n+                    catchER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(b3.successor()));\n+                    });\n+\n+                    b3.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of first exception region\n+                        b.op(exceptionRegionExit(er1, end.successor()));\n+                    });\n+\n+                    \/\/ Catch block for first exception region\n+                    catchER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 4))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 5))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testNestedF);\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+            if (i == 4) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 5) throw new RuntimeException();\n+        });\n+    }\n+\n+    public void testCatchFinallyF(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = func(\"f\", functionType(VOID, JavaType.type(IntConsumer.class)))\n+                .body(fbody -> {\n+                    var fblock = fbody.entryBlock();\n+                    var catchRE = fblock.block(type(IllegalStateException.class));\n+                    var catchAll = fblock.block(type(Throwable.class));\n+                    var enterER1 = fblock.block();\n+                    var exitER1 = fblock.block();\n+                    var enterER2 = fblock.block();\n+                    var exitER2 = fblock.block();\n+                    var end = fblock.block();\n+\n+                    \/\/\n+                    var c = fblock.parameters().get(0);\n+                    var er1 = fblock.op(exceptionRegionEnter(\n+                            enterER1.successor(),\n+                            catchRE.successor(), catchAll.successor()));\n+\n+                    \/\/ Start of exception region\n+                    enterER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 0))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er1, exitER1.successor()));\n+                    });\n+                    \/\/ Inline finally\n+                    exitER1.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Catch block for RuntimeException\n+                    var er2 = catchRE.op(exceptionRegionEnter(\n+                            enterER2.successor(),\n+                            catchAll.successor()));\n+                    \/\/ Start of exception region\n+                    enterER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 1))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        \/\/ End of exception region\n+                        b.op(exceptionRegionExit(er2, exitER2.successor()));\n+                    });\n+                    \/\/ Inline finally\n+                    exitER2.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(branch(end.successor()));\n+                    });\n+\n+                    \/\/ Catch all block for finally\n+                    catchAll.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 2))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_throw(catchAll.parameters().get(0)));\n+                    });\n+\n+                    \/\/\n+                    end.ops(b -> {\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, 3))));\n+                        b.op(CoreOps.invoke(INT_CONSUMER_ACCEPT_METHOD, c, b.op(constant(INT, -1))));\n+                        b.op(_return());\n+                    });\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), f, c),\n+                this::testCatchFinallyF\n+                );\n+\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+    }\n+\n+    static final MethodRef INT_CONSUMER_ACCEPT_METHOD = MethodRef.method(type(IntConsumer.class), \"accept\",\n+            VOID, INT);\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestExceptionRegionOps.java","additions":499,"deletions":0,"binary":false,"changes":499,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestForOp\n+ *\/\n+\n+public class TestForOp {\n+\n+    @CodeReflection\n+    public static int f() {\n+        int j = 0;\n+        for (int i = 0; i < 10; i++) {\n+            j += i;\n+        }\n+        return j;\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f());\n+    }\n+\n+    @CodeReflection\n+    public static int f2() {\n+        int k = 0;\n+        for (int i = 0, j = 0; i < 10; i++, j++) {\n+            k += i;\n+            k += j;\n+        }\n+        return k;\n+    }\n+\n+    @Test\n+    public void testf2() {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f2());\n+    }\n+\n+    @CodeReflection\n+    public static int f3() {\n+        int k = 0;\n+        int i = 0;\n+        int j = 0;\n+        for (i = 0, j = 0; i < 10; i++, j++) {\n+            k += i;\n+            k += j;\n+        }\n+        return k;\n+    }\n+\n+    @Test\n+    public void testf3() {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), f3());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestForOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestForOp.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestIfOp\n+ *\/\n+\n+public class TestIfOp {\n+\n+    @CodeReflection\n+    public static String f(int i) {\n+        String s;\n+        if (i <= 1) {\n+            s = \"<=ONE\";\n+        } else if (i == 2) {\n+            s = \"TWO\";\n+        } else if (i == 3) {\n+            s = \"THREE\";\n+        } else if (i == 4) {\n+            s = \"FOUR\";\n+        } else {\n+            s = \">=FIVE\";\n+        }\n+        return s;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestIfOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    @Test\n+    public void testf() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int i = 0; i < 6; i++) {\n+            Assert.assertEquals(Interpreter.invoke(lf, i), f(i));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestIfOp.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+\n+\/*\n+ * @test\n+ * @run testng TestInline\n+ *\/\n+\n+public class TestInline {\n+\n+    @Test\n+    public void testInline() {\n+        Quoted q = (int a, int b) -> a + b;\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    var cb = fblock.inline(cop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    Assert.assertEquals(fblock, cb);\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineVar() {\n+        Quoted q = (int a, int b) -> a + b;\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    Op.Result v = fblock.op(var(fblock.op(constant(INT, 0))));\n+\n+                    var cb = fblock.inline(cop, List.of(i, fortyTwo), (b, value) -> {\n+                        b.op(varStore(v, value));\n+                    });\n+                    Assert.assertEquals(fblock, cb);\n+\n+                    fblock.op(_return(fblock.op(varLoad(v))));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+\n+    @Test\n+    public void testInlineLowerMultipleReturn() {\n+        Quoted q = (int a, int b) ->  {\n+            if (a < 10) {\n+                return a + b;\n+            }\n+            return a - b;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+        cop.writeTo(System.out);\n+        CoreOps.ClosureOp lcop = cop.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lcop.writeTo(System.out);\n+\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    var cb = fblock.inline(lcop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    Assert.assertNotEquals(fblock, cb);\n+                });\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineLowerMultipleReturnVar() {\n+        Quoted q = (int a, int b) ->  {\n+            if (a < 10) {\n+                return a + b;\n+            }\n+            return a - b;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+        cop.writeTo(System.out);\n+        CoreOps.ClosureOp lcop = cop.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lcop.writeTo(System.out);\n+\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    Op.Result v = fblock.op(var(fblock.op(constant(INT, 0))));\n+\n+                    var cb = fblock.inline(lcop, List.of(i, fortyTwo), (b, value) -> {\n+                        b.op(varStore(v, value));\n+                    });\n+                    Assert.assertNotEquals(fblock, cb);\n+\n+                    cb.op(_return(cb.op(varLoad(v))));\n+                });\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineMultipleReturnLower() {\n+        Quoted q = (int a, int b) ->  {\n+            if (a < 10) {\n+                return a + b;\n+            }\n+            return a - b;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+        cop.writeTo(System.out);\n+\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(fblock -> {\n+                    Block.Parameter i = fblock.parameters().get(0);\n+\n+                    Op.Result fortyTwo = fblock.op(constant(INT, 42));\n+\n+                    var cb = fblock.inline(cop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    Assert.assertEquals(fblock, cb);\n+                });\n+        f.writeTo(System.out);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    @Test\n+    public void testInlineVoid() {\n+        Quoted q = (int[] a) -> {\n+            a[0] = 42;\n+            return;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(JavaType.VOID, JavaType.type(int[].class)))\n+                .body(fblock -> {\n+                    Block.Parameter a = fblock.parameters().get(0);\n+\n+                    var cb = fblock.inline(cop, List.of(a), Block.Builder.INLINE_RETURN);\n+                    Assert.assertEquals(fblock, cb);\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int[] a = new int[1];\n+        Interpreter.invoke(MethodHandles.lookup(), f, a);\n+        Assert.assertEquals(a[0], 42);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestLambdaOps\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.op.CoreOps.LambdaOp;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+@Test\n+public class TestLambdaOps {\n+    static class Builder {\n+        static final MethodRef ACCEPT_METHOD = MethodRef.method(type(Builder.class), \"accept\",\n+                INT, CoreOps.QuotedOp.QUOTED_TYPE);\n+\n+        static int accept(Quoted l) {\n+            Assert.assertEquals(1, l.capturedValues().size());\n+            Assert.assertEquals(1, l.capturedValues().values().iterator().next());\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) l.op(),\n+                    l.capturedValues(), 42);\n+            return r;\n+        }\n+    }\n+\n+    @Test\n+    public void testQuotedWithCapture() {\n+        \/\/ functional type = (int)int\n+        FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional type = (int)int\n+                    \/\/ op type = ()Quoted<LambdaOp>\n+                    QuotedOp qop = quoted(block.parentBody(), qblock -> {\n+                        return lambda(qblock.parentBody(),\n+                                functionType(INT, INT), type(IntUnaryOperator.class))\n+                                .body(lblock -> {\n+                                    Block.Parameter li = lblock.parameters().get(0);\n+\n+                                    lblock.op(_return(\n+                                            \/\/ capture i from function's body\n+                                            lblock.op(add(i, li))\n+                                    ));\n+                                });\n+                    });\n+                    Op.Result lquoted = block.op(qop);\n+\n+                    Op.Result or = block.op(invoke(Builder.ACCEPT_METHOD, lquoted));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    static final MethodRef INT_UNARY_OPERATOR_METHOD = MethodRef.method(\n+            IntUnaryOperator.class, \"applyAsInt\",\n+            int.class, int.class);\n+\n+    @Test\n+    public void testWithCapture() {\n+        \/\/ functional type = (int)int\n+        FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional type = (int)int\n+                    \/\/ op type = ()IntUnaryOperator\n+                    \/\/   captures i\n+                    LambdaOp lambda = lambda(block.parentBody(),\n+                            functionType(INT, INT), type(IntUnaryOperator.class))\n+                            .body(lblock -> {\n+                                Block.Parameter li = lblock.parameters().get(0);\n+\n+                                lblock.op(_return(\n+                                        lblock.op(add(i, li))));\n+                            });\n+                    Op.Result fi = block.op(lambda);\n+\n+                    Op.Result fortyTwo = block.op(constant(INT, 42));\n+                    Op.Result or = block.op(invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n+                    block.op(_return(or));\n+                });\n+\n+        f.writeTo(System.out);\n+\n+        int ir = (int) Interpreter.invoke(MethodHandles.lookup(), f, 1);\n+        Assert.assertEquals(ir, 43);\n+    }\n+\n+    static int f(int i) {\n+        IntUnaryOperator fi = li -> {\n+            return i + li;\n+        };\n+\n+        int fortyTwo = 42;\n+        int or = fi.applyAsInt(fortyTwo);\n+        return or;\n+    }\n+\n+    @Test\n+    public void testQuotableModel() {\n+        Quotable quotable = (Runnable & Quotable) () -> {};\n+        Op qop = quotable.quoted().op();\n+        Op top = qop.ancestorBody().parentOp().ancestorBody().parentOp();\n+        Assert.assertTrue(top instanceof CoreOps.FuncOp);\n+\n+        CoreOps.FuncOp fop = (CoreOps.FuncOp) top;\n+        Assert.assertEquals(type(Quoted.class), fop.invokableType().returnType());\n+    }\n+\n+    @FunctionalInterface\n+    public interface QuotableIntSupplier extends IntSupplier, Quotable {\n+    }\n+\n+    @CodeReflection\n+    static QuotableIntSupplier quote(int i) {\n+        QuotableIntSupplier s = () -> i;\n+        return s;\n+    }\n+\n+    @Test\n+    public void testQuote() {\n+        FuncOp g = getFuncOp(\"quote\");\n+        g.writeTo(System.out);\n+\n+        {\n+            QuotableIntSupplier op = (QuotableIntSupplier) Interpreter.invoke(MethodHandles.lookup(), g, 42);\n+            Assert.assertEquals(op.getAsInt(), 42);\n+\n+            Quoted q = op.quoted();\n+            q.op().writeTo(System.out);\n+            Assert.assertEquals(q.capturedValues().size(), 1);\n+            Assert.assertEquals(((Var<?>)q.capturedValues().values().iterator().next()).value(), 42);\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), q.capturedValues(), List.of());\n+            Assert.assertEquals(r, 42);\n+\n+            Map<Value, Object> cvs = Map.of(\n+                    q.capturedValues().keySet().iterator().next(),\n+                    CoreOps.Var.of(0)\n+            );\n+            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), cvs, List.of());\n+            Assert.assertEquals(r, 0);\n+        }\n+\n+        {\n+            QuotableIntSupplier op = quote(42);\n+            Assert.assertEquals(op.getAsInt(), 42);\n+\n+            Quoted q = op.quoted();\n+            q.op().writeTo(System.out);\n+            System.out.print(q.capturedValues().values());\n+            Assert.assertEquals(q.capturedValues().size(), 1);\n+            Assert.assertEquals(((Var<?>)q.capturedValues().values().iterator().next()).value(), 42);\n+\n+            int r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), q.capturedValues(), List.of());\n+            Assert.assertEquals(r, 42);\n+\n+            Map<Value, Object> cvs = Map.of(\n+                    q.capturedValues().keySet().iterator().next(),\n+                    CoreOps.Var.of(0)\n+            );\n+            r = (int) Interpreter.invoke(MethodHandles.lookup(), (LambdaOp) q.op(), cvs, List.of());\n+            Assert.assertEquals(r, 0);\n+        }\n+    }\n+\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable {}\n+\n+    interface QuotableFunction<T, R> extends Function<T, R>, Quotable {}\n+\n+    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R>, Quotable {}\n+\n+    @DataProvider\n+    Iterator<Quotable> methodRefLambdas() {\n+        return List.of(\n+                (QuotableIntUnaryOperator) TestLambdaOps::m1,\n+                (QuotableIntUnaryOperator) TestLambdaOps::m2,\n+                (QuotableFunction<Integer, Integer>) TestLambdaOps::m1,\n+                (QuotableFunction<Integer, Integer>) TestLambdaOps::m2,\n+                (QuotableIntUnaryOperator) this::m3,\n+                (QuotableBiFunction<TestLambdaOps, Integer, Integer>) TestLambdaOps::m4\n+        ).iterator();\n+    }\n+\n+    @Test(dataProvider = \"methodRefLambdas\")\n+    public void testIsMethodReference(Quotable q) {\n+        Quoted quoted = q.quoted();\n+        CoreOps.LambdaOp lop = (CoreOps.LambdaOp) quoted.op();\n+        Assert.assertTrue(lop.methodReference().isPresent());\n+    }\n+\n+    static int m1(int i) {\n+        return i;\n+    }\n+\n+    static Integer m2(Integer i) {\n+        return i;\n+    }\n+\n+    int m3(int i) {\n+        return i;\n+    }\n+\n+    static int m4(TestLambdaOps tl, int i) {\n+        return i;\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestLambdaOps.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.TypeElement;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.type.MethodRef.method;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+\n+\/*\n+ * @test\n+ * @run testng TestLinqUsingQuoted\n+ *\/\n+\n+public class TestLinqUsingQuoted {\n+\n+    \/\/ Query interfaces\n+\n+    public interface Queryable {\n+        TypeElement elementType();\n+\n+        \/\/ Queryable<T> -> Queryable<U>\n+        FuncOp expression();\n+\n+        QueryProvider provider();\n+\n+        \/\/ T -> boolean\n+        \/\/ Predicate<T>\n+        default Queryable where(Quoted f) {\n+            \/\/ @@@@ validate\n+            ClosureOp c = (ClosureOp) f.op();\n+            return insertQuery(elementType(), \"where\", c);\n+        }\n+\n+        \/\/ T -> R\n+        \/\/ Function<T, R>\n+        default Queryable select(Quoted f) {\n+            \/\/ @@@@ validate\n+            ClosureOp c = (ClosureOp) f.op();\n+            return insertQuery(c.invokableType().returnType(), \"select\", c);\n+        }\n+\n+        private Queryable insertQuery(TypeElement et, String name, ClosureOp c) {\n+            QueryProvider qp = provider();\n+\n+            FuncOp currentQueryExpression = expression();\n+            FuncOp nextQueryExpression = currentQueryExpression.transform((block, op) -> {\n+                if (op instanceof ReturnOp rop && rop.ancestorBody() == currentQueryExpression.body()) {\n+                    Value query = block.context().getValue(rop.returnValue());\n+\n+                    Op.Result quotedLambda = block.op(quoted(block.parentBody(), qblock -> c));\n+\n+                    MethodRef md = method(qp.queryableType(), name,\n+                            functionType(qp.queryableType(), QuotedOp.QUOTED_TYPE));\n+                    Op.Result queryable = block.op(invoke(md, query, quotedLambda));\n+\n+                    block.op(_return(queryable));\n+                } else {\n+                    block.op(op);\n+                }\n+                return block;\n+            });\n+\n+            return qp.createQuery(et, nextQueryExpression);\n+        }\n+\n+        \/\/ Iterate\n+        \/\/ Queryable -> Stream\n+        default QueryResult elements() {\n+            TypeElement resultType = JavaType.type(JavaType.type(Stream.class), (JavaType) elementType());\n+            return insertQueryResult(\"elements\", resultType);\n+        }\n+\n+        \/\/ Count\n+        \/\/ Queryable -> Long\n+        default QueryResult count() {\n+            return insertQueryResult(\"count\", JavaType.LONG);\n+        }\n+\n+        private QueryResult insertQueryResult(String name, TypeElement resultType) {\n+            QueryProvider qp = provider();\n+\n+            \/\/ Copy function expression, replacing return type\n+            FuncOp currentQueryExpression = expression();\n+            FuncOp nextQueryExpression = func(\"queryresult\",\n+                    functionType(qp.queryResultType(), currentQueryExpression.invokableType().parameterTypes()))\n+                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n+                        MethodRef md = method(qp.queryableType(), name, functionType(qp.queryResultType()));\n+                        Op.Result queryResult = block.op(invoke(md, query));\n+\n+                        block.op(_return(queryResult));\n+                    }));\n+            return qp.createQueryResult(resultType, nextQueryExpression);\n+        }\n+    }\n+\n+    public interface QueryResult {\n+        TypeElement resultType();\n+\n+        \/\/ Queryable -> QueryResult\n+        FuncOp expression();\n+\n+        Object execute();\n+    }\n+\n+    public interface QueryProvider {\n+        TypeElement queryableType();\n+\n+        TypeElement queryResultType();\n+\n+        Queryable createQuery(TypeElement elementType, FuncOp expression);\n+\n+        QueryResult createQueryResult(TypeElement resultType, FuncOp expression);\n+\n+        Queryable newQuery(TypeElement elementType);\n+    }\n+\n+\n+    \/\/ Query implementation\n+\n+    public static final class TestQueryable implements Queryable {\n+        final TypeElement elementType;\n+        final TestQueryProvider provider;\n+        final FuncOp expression;\n+\n+        TestQueryable(TypeElement elementType, TestQueryProvider provider) {\n+            this.elementType = elementType;\n+            this.provider = provider;\n+\n+            \/\/ Initial expression is an identity function\n+            var funType = functionType(provider().queryableType(), provider().queryableType());\n+            this.expression = func(\"query\", funType)\n+                    .body(b -> b.op(_return(b.parameters().get(0))));\n+        }\n+\n+        TestQueryable(TypeElement elementType, TestQueryProvider provider, FuncOp expression) {\n+            this.elementType = elementType;\n+            this.provider = provider;\n+            this.expression = expression;\n+        }\n+\n+        @Override\n+        public TypeElement elementType() {\n+            return elementType;\n+        }\n+\n+        @Override\n+        public FuncOp expression() {\n+            return expression;\n+        }\n+\n+        @Override\n+        public QueryProvider provider() {\n+            return provider;\n+        }\n+    }\n+\n+    public record TestQueryResult(TypeElement resultType, FuncOp expression) implements QueryResult {\n+        @Override\n+        public Object execute() {\n+            \/\/ @@@ Compile\/translate the expression and execute it\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static final class TestQueryProvider implements QueryProvider {\n+        final TypeElement queryableType;\n+        final TypeElement queryResultType;\n+\n+        TestQueryProvider() {\n+            this.queryableType = JavaType.type(Queryable.class);\n+            this.queryResultType = JavaType.type(QueryResult.class);\n+        }\n+\n+        @Override\n+        public TypeElement queryableType() {\n+            return queryableType;\n+        }\n+\n+        @Override\n+        public TypeElement queryResultType() {\n+            return queryResultType;\n+        }\n+\n+        @Override\n+        public TestQueryable createQuery(TypeElement elementType, FuncOp expression) {\n+            return new TestQueryable(elementType, this, expression);\n+        }\n+\n+        @Override\n+        public QueryResult createQueryResult(TypeElement resultType, FuncOp expression) {\n+            return new TestQueryResult(resultType, expression);\n+        }\n+\n+        @Override\n+        public Queryable newQuery(TypeElement elementType) {\n+            return new TestQueryable(elementType, this);\n+        }\n+    }\n+\n+\n+    static class Customer {\n+        \/\/ 1st column\n+        String contactName;\n+        \/\/ 2nd column\n+        String phone;\n+        \/\/ 3rd column\n+        String city;\n+    }\n+\n+    @Test\n+    public void testSimpleQuery() {\n+        QueryProvider qp = new TestQueryProvider();\n+\n+        QueryResult qr = qp.newQuery(JavaType.type(Customer.class))\n+                \/\/ c -> c.city.equals(\"London\")\n+                .where((Customer c) -> c.city.equals(\"London\"))\n+                \/\/ c -> c.contactName\n+                .select((Customer c) -> c.contactName).elements();\n+\n+        qr.expression().writeTo(System.out);\n+\n+        QueryResult qr2 = (QueryResult) Interpreter.invoke(MethodHandles.lookup(),\n+                qr.expression(), qp.newQuery(JavaType.type(Customer.class)));\n+\n+        qr2.expression().writeTo(System.out);\n+\n+        Assert.assertEquals(qr.expression().toText(), qr2.expression().toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,333 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestLiveness\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+public class TestLiveness {\n+\n+    static final String F = \"\"\"\n+            func @\"f\" (%0 : int, %1 : int)int -> {\n+                %2 : int = add %0 %1;\n+                return %2;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testF() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, F).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of()));\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String IF_ELSE = \"\"\"\n+            func @\"ifelse\" (%0 : int, %1 : int, %2 : int)int -> {\n+                %3 : int = constant @\"10\";\n+                %4 : boolean = lt %2 %3;\n+                cbranch %4 ^block_0 ^block_1;\n+\n+              ^block_0:\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %0 %5;\n+                branch ^block_2(%6, %1);\n+\n+              ^block_1:\n+                %7 : int = constant @\"2\";\n+                %8 : int = add %1 %7;\n+                branch ^block_2(%0, %8);\n+\n+              ^block_2(%9 : int, %10 : int):\n+                %11 : int = add %9 %10;\n+                return %11;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testIfElse() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, IF_ELSE).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0, 1)),\n+                1, List.of(Set.of(0, 1), Set.of()),\n+                2, List.of(Set.of(0, 1), Set.of()),\n+                3, List.of(Set.of(), Set.of())\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String LOOP = \"\"\"\n+            func @\"loop\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : int = constant @\"0\";\n+                branch ^block_0(%1, %2);\n+\n+              ^block_0(%3 : int, %4 : int):\n+                %5 : boolean = lt %4 %0;\n+                cbranch %5 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %6 : int = add %3 %4;\n+                branch ^block_3;\n+\n+              ^block_3:\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %4 %7;\n+                branch ^block_0(%6, %8);\n+\n+              ^block_2:\n+                return %3;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testLoop() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, LOOP).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0)),\n+                1, List.of(Set.of(0), Set.of(0, 3, 4)),\n+                2, List.of(Set.of(0, 3, 4), Set.of(0, 4, 6)),\n+                3, List.of(Set.of(3), Set.of()),\n+                4, List.of(Set.of(0, 4, 6), Set.of(0))\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String IF_ELSE_NESTED = \"\"\"\n+            func @\"ifelseNested\" (%0 : int, %1 : int, %2 : int, %3 : int, %4 : int)int -> {\n+                %5 : int = constant @\"20\";\n+                %6 : boolean = lt %4 %5;\n+                cbranch %6 ^block_0 ^block_1;\n+\n+              ^block_0:\n+                %7 : int = constant @\"10\";\n+                %8 : boolean = lt %4 %7;\n+                cbranch %8 ^block_2 ^block_3;\n+\n+              ^block_2:\n+                %9 : int = constant @\"1\";\n+                %10 : int = add %0 %9;\n+                branch ^block_4(%10, %1);\n+\n+              ^block_3:\n+                %11 : int = constant @\"2\";\n+                %12 : int = add %1 %11;\n+                branch ^block_4(%0, %12);\n+\n+              ^block_4(%13 : int, %14 : int):\n+                %15 : int = constant @\"3\";\n+                %16 : int = add %2 %15;\n+                branch ^block_5(%13, %14, %16, %3);\n+\n+              ^block_1:\n+                %17 : int = constant @\"20\";\n+                %18 : boolean = gt %4 %17;\n+                cbranch %18 ^block_6 ^block_7;\n+\n+              ^block_6:\n+                %19 : int = constant @\"4\";\n+                %20 : int = add %0 %19;\n+                branch ^block_8(%20, %1);\n+\n+              ^block_7:\n+                %21 : int = constant @\"5\";\n+                %22 : int = add %1 %21;\n+                branch ^block_8(%0, %22);\n+\n+              ^block_8(%23 : int, %24 : int):\n+                %25 : int = constant @\"6\";\n+                %26 : int = add %3 %25;\n+                branch ^block_5(%23, %24, %2, %26);\n+\n+              ^block_5(%27 : int, %28 : int, %29 : int, %30 : int):\n+                %31 : int = add %27 %28;\n+                %32 : int = add %31 %29;\n+                %33 : int = add %32 %30;\n+                return %33;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testIfElseNested() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, IF_ELSE_NESTED).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0, 1, 2, 3, 4)),\n+                1, List.of(Set.of(0, 1, 2, 3, 4), Set.of(0, 1, 2, 3)),\n+                2, List.of(Set.of(0, 1, 2, 3, 4), Set.of(0, 1, 2, 3)),\n+                3, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                4, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                5, List.of(Set.of(2, 3), Set.of()),\n+                6, List.of(Set.of(), Set.of()),\n+                7, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                8, List.of(Set.of(0, 1, 2, 3), Set.of(2, 3)),\n+                9, List.of(Set.of(2, 3), Set.of())\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static final String LOOP_NESTED = \"\"\"\n+            func @\"loopNested\" (%0 : int)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : int = constant @\"0\";\n+                branch ^block_0(%1, %2);\n+\n+              ^block_0(%3 : int, %4 : int):\n+                %5 : boolean = lt %4 %0;\n+                cbranch %5 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %6 : int = constant @\"0\";\n+                branch ^block_3(%3, %6);\n+\n+              ^block_3(%7 : int, %8 : int):\n+                %9 : boolean = lt %8 %0;\n+                cbranch %9 ^block_4 ^block_5;\n+\n+              ^block_4:\n+                %10 : int = add %7 %4;\n+                %11 : int = add %10 %8;\n+                branch ^block_6;\n+\n+              ^block_6:\n+                %12 : int = constant @\"1\";\n+                %13 : int = add %8 %12;\n+                branch ^block_3(%11, %13);\n+\n+              ^block_5:\n+                branch ^block_7;\n+\n+              ^block_7:\n+                %14 : int = constant @\"1\";\n+                %15 : int = add %4 %14;\n+                branch ^block_0(%7, %15);\n+\n+              ^block_2:\n+                return %3;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testLoopNested() {\n+        Op op = OpParser.fromString(CoreOps.FACTORY, LOOP_NESTED).getFirst();\n+\n+        var actual = liveness(op);\n+        var expected = Map.of(\n+                0, List.of(Set.of(), Set.of(0)),\n+                1, List.of(Set.of(0), Set.of(0, 3, 4)),\n+                2, List.of(Set.of(0, 3, 4), Set.of(0, 4)),\n+                3, List.of(Set.of(3), Set.of()),\n+                4, List.of(Set.of(0, 4), Set.of(0, 4, 7, 8)),\n+                5, List.of(Set.of(0, 4, 7, 8), Set.of(0, 4, 8, 11)),\n+                6, List.of(Set.of(0, 4, 7), Set.of(0, 4, 7)),\n+                7, List.of(Set.of(0, 4, 8, 11), Set.of(0, 4)),\n+                8, List.of(Set.of(0, 4, 7), Set.of(0))\n+        );\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static Map<Integer, List<Set<Integer>>> liveness(Op op) {\n+        Liveness l = new Liveness(op);\n+        System.out.println(l);\n+\n+        Map<Value, Integer> valueMap = valueNameMapping(op);\n+        Map<Block, Integer> blockMap = blockNameMapping(op);\n+\n+        return op.traverse(new HashMap<>(),\n+                CodeElement.blockVisitor((m, b) -> {\n+                    if (b.parentBody().parentOp() == op) {\n+                        Liveness.BlockInfo lbi = l.getLiveness(b);\n+                        m.put(blockMap.get(b),\n+                                List.of(\n+                                        lbi.liveIn().stream().map(valueMap::get).collect(Collectors.toSet()),\n+                                        lbi.liveOut().stream().map(valueMap::get).collect(Collectors.toSet())\n+                                ));\n+                    }\n+                    return m;\n+                }));\n+    }\n+\n+    static Map<Block, Integer> blockNameMapping(Op top) {\n+        AtomicInteger i = new AtomicInteger();\n+        return top.traverse(new HashMap<>(), CodeElement.blockVisitor((m, b) -> {\n+            if (b.parentBody().parentOp() != top) {\n+                return m;\n+            }\n+\n+            m.computeIfAbsent(b, _ -> i.getAndIncrement());\n+            for (Block.Reference s : b.successors()) {\n+                m.computeIfAbsent(s.targetBlock(), _ -> i.getAndIncrement());\n+            }\n+\n+            return m;\n+        }));\n+    }\n+\n+    static Map<Value, Integer> valueNameMapping(Op top) {\n+        AtomicInteger i = new AtomicInteger();\n+        return top.traverse(new HashMap<>(), (m, e) -> {\n+            switch (e) {\n+                case Block b -> {\n+                    for (Block.Parameter p : b.parameters()) {\n+                        m.put(p, i.getAndIncrement());\n+                    }\n+                }\n+                case Op op -> {\n+                    Op.Result r = op.result();\n+                    if (r != null && !r.type().equals(JavaType.VOID)) {\n+                        m.put(r, i.getAndIncrement());\n+                    }\n+                }\n+                default -> {\n+                }\n+            }\n+            return m;\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLiveness.java","additions":333,"deletions":0,"binary":false,"changes":333,"status":"added"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.PrintStream;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.arrayStoreOp;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.fieldLoad;\n+import static java.lang.reflect.code.op.CoreOps.newArray;\n+import static java.lang.reflect.code.type.MethodRef.method;\n+import static java.lang.reflect.code.type.JavaType.*;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLocalTransformationsAdaption\n+ *\/\n+\n+public class TestLocalTransformationsAdaption {\n+\n+    @CodeReflection\n+    static int f(int i) {\n+        IntBinaryOperator add = (a, b) -> {\n+            return add(a, b);\n+        };\n+\n+        try {\n+            IntUnaryOperator add42 = (a) -> {\n+                return add.applyAsInt(a, 42);\n+            };\n+\n+            int j = add42.applyAsInt(i);\n+\n+            IntBinaryOperator f = (a, b) -> {\n+                if (i < 0) {\n+                    throw new RuntimeException();\n+                }\n+\n+                IntUnaryOperator g = (c) -> {\n+                    return add(a, c);\n+                };\n+\n+                return g.applyAsInt(b);\n+            };\n+\n+            return f.applyAsInt(j, j);\n+        } catch (RuntimeException e) {\n+            throw new IndexOutOfBoundsException(i);\n+        }\n+    }\n+\n+    @Test\n+    public void testInvocation() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), f, 2);\n+        Assert.assertEquals(x, f(2));\n+\n+        try {\n+            Interpreter.invoke(MethodHandles.lookup(), f, -10);\n+            Assert.fail();\n+        } catch (Throwable e) {\n+            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n+        }\n+    }\n+\n+    @Test\n+    public void testFuncEntryExit() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        AtomicBoolean first = new AtomicBoolean(true);\n+        CoreOps.FuncOp fc = f.transform((block, op) -> {\n+            if (first.get()) {\n+                printConstantString(block, \"ENTRY\");\n+                first.set(false);\n+            }\n+\n+            switch (op) {\n+                case CoreOps.ReturnOp returnOp when getNearestInvokeableAncestorOp(returnOp) instanceof CoreOps.FuncOp: {\n+                    printConstantString(block, \"EXIT\");\n+                    break;\n+                }\n+                case CoreOps.ThrowOp throwOp: {\n+                    printConstantString(block, \"EXIT\");\n+                    break;\n+                }\n+                default:\n+            }\n+\n+            block.apply(op);\n+\n+            return block;\n+        });\n+        fc.writeTo(System.out);\n+\n+        fc = fc.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        fc.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), fc, 2);\n+        Assert.assertEquals(x, f(2));\n+\n+        try {\n+            Interpreter.invoke(MethodHandles.lookup(), fc, -10);\n+            Assert.fail();\n+        } catch (Throwable e) {\n+            Assert.assertEquals(IndexOutOfBoundsException.class, e.getClass());\n+        }\n+    }\n+\n+    static void printConstantString(Function<Op, Op.Result> opBuilder, String s) {\n+        Op.Result c = opBuilder.apply(constant(J_L_STRING, s));\n+        Value System_out = opBuilder.apply(fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n+        opBuilder.apply(CoreOps.invoke(method(PrintStream.class, \"println\", void.class, String.class), System_out, c));\n+    }\n+\n+    static Op getNearestInvokeableAncestorOp(Op op) {\n+        do {\n+            op = op.ancestorBody().parentOp();\n+        } while (!(op instanceof Op.Invokable));\n+        return op;\n+    }\n+\n+\n+    @Test\n+    public void testReplaceCall() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp fc = f.transform((block, op) -> {\n+            switch (op) {\n+                case CoreOps.InvokeOp invokeOp when invokeOp.invokeDescriptor().equals(ADD_METHOD): {\n+                    \/\/ Get the adapted operands, and pass those to the new call method\n+                    List<Value> adaptedOperands = block.context().getValues(op.operands());\n+                    Op.Result adaptedResult = block.apply(CoreOps.invoke(ADD_WITH_PRINT_METHOD, adaptedOperands));\n+                    \/\/ Map the old call result to the new call result, so existing operations can be\n+                    \/\/ adapted to use the new result\n+                    block.context().mapValue(invokeOp.result(), adaptedResult);\n+                    break;\n+                }\n+                default: {\n+                    block.apply(op);\n+                }\n+            }\n+            return block;\n+        });\n+        fc.writeTo(System.out);\n+\n+        fc = fc.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        fc.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), fc, 2);\n+        Assert.assertEquals(x, f(2));\n+    }\n+\n+\n+    @Test\n+    public void testCallEntryExit() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp fc = f.transform((block, op) -> {\n+            switch (op) {\n+                case CoreOps.InvokeOp invokeOp: {\n+                    printCall(block.context(), invokeOp, block);\n+                    break;\n+                }\n+                default: {\n+                    block.apply(op);\n+                }\n+            }\n+            return block;\n+        });\n+        fc.writeTo(System.out);\n+\n+        fc = fc.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        fc.writeTo(System.out);\n+\n+        int x = (int) Interpreter.invoke(MethodHandles.lookup(), fc, 2);\n+        Assert.assertEquals(x, f(2));\n+    }\n+\n+    static void printCall(CopyContext cc, CoreOps.InvokeOp invokeOp, Function<Op, Op.Result> opBuilder) {\n+        List<Value> adaptedInvokeOperands = cc.getValues(invokeOp.operands());\n+\n+        String prefix = \"ENTER\";\n+\n+        Value arrayLength = opBuilder.apply(\n+                constant(INT, adaptedInvokeOperands.size()));\n+        Value formatArray = opBuilder.apply(\n+                newArray(type(Object[].class), arrayLength));\n+\n+        Value indexZero = null;\n+        for (int i = 0; i < adaptedInvokeOperands.size(); i++) {\n+            Value operand = adaptedInvokeOperands.get(i);\n+\n+            Value index = opBuilder.apply(\n+                    constant(INT, i));\n+            if (i == 0) {\n+                indexZero = index;\n+            }\n+\n+            if (operand.type().equals(INT)) {\n+                operand = opBuilder.apply(\n+                        CoreOps.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), operand));\n+                \/\/ @@@ Other primitive types\n+            }\n+            opBuilder.apply(\n+                    arrayStoreOp(formatArray, index, operand));\n+        }\n+\n+        Op.Result formatString = opBuilder.apply(\n+                constant(J_L_STRING,\n+                        prefix + \": \" + invokeOp.invokeDescriptor() + \"(\" + formatString(adaptedInvokeOperands) + \")%n\"));\n+        Value System_out = opBuilder.apply(fieldLoad(FieldRef.field(System.class, \"out\", PrintStream.class)));\n+        opBuilder.apply(\n+                CoreOps.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n+                        System_out, formatString, formatArray));\n+\n+        \/\/ Method call\n+\n+        Op.Result adaptedInvokeResult = opBuilder.apply(invokeOp);\n+\n+        \/\/ After method call\n+\n+        prefix = \"EXIT\";\n+\n+        if (adaptedInvokeResult.type().equals(INT)) {\n+            adaptedInvokeResult = opBuilder.apply(\n+                    CoreOps.invoke(method(Integer.class, \"valueOf\", Integer.class, int.class), adaptedInvokeResult));\n+            \/\/ @@@ Other primitive types\n+        }\n+        opBuilder.apply(\n+                arrayStoreOp(formatArray, indexZero, adaptedInvokeResult));\n+\n+        formatString = opBuilder.apply(\n+                constant(J_L_STRING,\n+                        prefix + \": \" + invokeOp.invokeDescriptor() + \" -> \" + formatString(adaptedInvokeResult.type()) + \"%n\"));\n+        opBuilder.apply(\n+                CoreOps.invoke(method(PrintStream.class, \"printf\", PrintStream.class, String.class, Object[].class),\n+                        System_out, formatString, formatArray));\n+    }\n+\n+    static String formatString(List<Value> vs) {\n+        return vs.stream().map(v -> formatString(v.type())).collect(Collectors.joining(\",\"));\n+    }\n+\n+    static String formatString(TypeElement t) {\n+        if (t.equals(INT)) {\n+            return \"%d\";\n+        } else {\n+            return \"%s\";\n+        }\n+    }\n+\n+\n+    static final MethodRef ADD_METHOD = MethodRef.method(\n+            TestLocalTransformationsAdaption.class, \"add\",\n+            int.class, int.class, int.class);\n+\n+    static int add(int a, int b) {\n+        return a + b;\n+    }\n+\n+    static final MethodRef ADD_WITH_PRINT_METHOD = MethodRef.method(\n+            TestLocalTransformationsAdaption.class, \"addWithPrint\",\n+            int.class, int.class, int.class);\n+\n+    static int addWithPrint(int a, int b) {\n+        System.out.printf(\"Adding %d + %d%n\", a, b);\n+        return a + b;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestLocalTransformationsAdaption.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLocalTransformationsAdaption.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestPatterns\n+ * @enablePreview\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestPatterns {\n+\n+    interface Point {\n+    }\n+\n+    record ConcretePoint(int x, int y) implements Point {\n+    }\n+\n+    enum Color {RED, GREEN, BLUE}\n+\n+    record ColoredPoint(ConcretePoint p, Color c) implements Point {\n+    }\n+\n+    record Rectangle(Point upperLeft, Point lowerRight) {\n+    }\n+\n+\n+    @CodeReflection\n+    public static String recordPatterns(Object r) {\n+        if (r instanceof Rectangle(\n+                ColoredPoint(ConcretePoint p, Color c),\n+                ColoredPoint lr)) {\n+            return p.toString();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    @Test\n+    public void testRecordPatterns() {\n+        CoreOps.FuncOp f = getFuncOp(\"recordPatterns\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        {\n+            Rectangle r = new Rectangle(\n+                    new ColoredPoint(new ConcretePoint(1, 2), Color.RED),\n+                    new ColoredPoint(new ConcretePoint(3, 4), Color.BLUE));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+\n+        {\n+            Rectangle r = new Rectangle(\n+                    new ColoredPoint(new ConcretePoint(1, 2), Color.RED),\n+                    new ConcretePoint(3, 4));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+\n+        {\n+            Rectangle r = new Rectangle(\n+                    new ConcretePoint(1, 2),\n+                    new ConcretePoint(3, 4));\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+\n+        {\n+            String r = \"\";;\n+            Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), lf, r), recordPatterns(r));\n+        }\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestPatterns.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPatterns.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestPrimitiveCast\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+public class TestPrimitiveCast {\n+\n+    static final Function<Object, String> FROM_DOUBLE = v -> fromDouble((double) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromDouble(double v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_FLOAT = v -> fromFloat((float) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromFloat(float v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_LONG = v -> fromLong((long) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromLong(long v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_INT = v -> fromInt((int) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromInt(int v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_SHORT = v -> fromShort((short) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromShort(short v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_CHAR = v -> fromChar((char) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromChar(char v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    static final Function<Object, String> FROM_BYTE = v -> fromByte((byte) v);\n+\n+    @CodeReflection\n+    @SuppressWarnings(\"cast\")\n+    static String fromByte(byte v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+        return collect(d, f, l, i, s, c, b);\n+    }\n+\n+    @DataProvider\n+    static Object[][] fromMethods() {\n+        return new Object[][] {\n+                { \"fromDouble\", Math.PI, FROM_DOUBLE},\n+                { \"fromDouble\", 65.1, FROM_DOUBLE},\n+                { \"fromFloat\", (float) Math.PI, FROM_FLOAT},\n+                { \"fromFloat\", 65.1f, FROM_FLOAT},\n+                { \"fromLong\", Long.MAX_VALUE, FROM_LONG},\n+                { \"fromInt\", Integer.MAX_VALUE, FROM_INT},\n+                { \"fromShort\", Short.MAX_VALUE, FROM_SHORT},\n+                { \"fromChar\", Character.MAX_VALUE, FROM_CHAR},\n+                { \"fromByte\", Byte.MAX_VALUE, FROM_BYTE},\n+        };\n+    };\n+\n+    @Test(dataProvider = \"fromMethods\")\n+    public void testFromDouble(String name, Object value, Function<Object, String> m) {\n+        CoreOps.FuncOp f = getFuncOp(name);\n+        Assert.assertEquals(Interpreter.invoke(MethodHandles.lookup(), f, value), m.apply(value));\n+    }\n+\n+\n+    static String collect(Object... values) {\n+        return Stream.of(values).map(Object::toString).collect(joining(\" \"));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestPrimitiveCast.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestPrimitiveCast.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.op.CoreOps.FuncOp;\n+import static java.lang.reflect.code.op.CoreOps.VarAccessOp.VarLoadOp;\n+import static java.lang.reflect.code.op.CoreOps.VarAccessOp.VarStoreOp;\n+import static java.lang.reflect.code.op.CoreOps.VarOp;\n+\n+\/*\n+ * @test\n+ * @run testng TestRemoveFinalVars\n+ *\/\n+\n+public class TestRemoveFinalVars {\n+\n+    @CodeReflection\n+    static boolean f() {\n+        final int x = 8; \/\/ final var\n+        int y = x + 2; \/\/ final var\n+        int z = y + 3; \/\/ non final var\n+        z++;\n+        return x == 8 && y == 10 && z == 14;\n+    }\n+\n+    @Test\n+    void test() {\n+        FuncOp f = getFuncOp(this.getClass(),\"f\");\n+        f.writeTo(System.out);\n+        FuncOp lf = lower(f);\n+        lf.writeTo(System.out);\n+\n+        FuncOp f2 = f.transform(TestRemoveFinalVars::rmFinalVars);\n+        f2.writeTo(System.out);\n+        FuncOp lf2 = lower(f2);\n+        lf2.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), Interpreter.invoke(lf2));\n+\n+        SSA.transform(lower(f)).writeTo(System.out);\n+    }\n+\n+    static FuncOp lower(FuncOp funcOp) {\n+        return funcOp.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+    }\n+\n+    static Block.Builder rmFinalVars(Block.Builder block, Op op) {\n+        if (op instanceof VarOp varOp) {\n+            \/\/ Is the variable stored to? If not we can remove it\n+            \/\/ otherwise, it's not considered final and we copy it\n+            if (isValueUsedWithOp(varOp.result(), o -> o instanceof VarStoreOp)) {\n+                block.op(varOp);\n+            }\n+        } else if (op instanceof VarLoadOp varLoadOp) {\n+            \/\/ If the variable is not stored to\n+            if (!isValueUsedWithOp(varLoadOp.varOp().result(), o -> o instanceof VarStoreOp)) {\n+                \/\/ Map result of load from variable to the value that initialized the variable\n+                \/\/ Subsequently encountered input operations using the result will be copied\n+                \/\/ to output operations using the mapped value\n+                CopyContext cc = block.context();\n+                cc.mapValue(varLoadOp.result(), cc.getValue(varLoadOp.varOp().operands().get(0)));\n+            } else {\n+                block.op(varLoadOp);\n+            }\n+        } else {\n+            block.op(op);\n+        }\n+        return block;\n+    }\n+\n+    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+        for (Op.Result user : value.uses()) {\n+            if (opPredicate.test(user.op())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestRemoveFinalVars.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSSA\n+ *\/\n+\n+public class TestSSA {\n+\n+    @CodeReflection\n+    static int ifelse(int a, int b, int n) {\n+        if (n < 10) {\n+            a += 1;\n+        } else {\n+            b += 2;\n+        }\n+        return a + b;\n+    }\n+\n+    @Test\n+    public void testIfelse() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelse\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 1), ifelse(0, 0, 1));\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 11), ifelse(0, 0, 11));\n+    }\n+\n+    @CodeReflection\n+    static int ifelseNested(int a, int b, int c, int d, int n) {\n+        if (n < 20) {\n+            if (n < 10) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (n > 20) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @Test\n+    public void testIfelseNested() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"ifelseNested\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        for (int i : new int[]{1, 11, 20, 21}) {\n+            Assert.assertEquals((int) Interpreter.invoke(lf, 0, 0, 0, 0, i), ifelseNested(0, 0, 0, 0, i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + i;\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testLoop() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"loop\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 10), loop(10));\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int n) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testNestedLoop() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"nestedLoop\");\n+\n+        CoreOps.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(lf, 10), nestedLoop(10));\n+    }\n+\n+    static CoreOps.FuncOp generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+        return lf;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSSA.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTraverse\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CodeElement;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestTraverse {\n+\n+    @CodeReflection\n+    private static int f(String s, int i, List<Object> acc) {\n+        char c = s.charAt(i);\n+        int d = (c - '0');\n+        int n = s.length();\n+        while (++i < n) {\n+            c = s.charAt(i);\n+            if (c >= '0' && c <= '9') {\n+                d = d * 10 + (c - '0');\n+                continue;\n+            }\n+            break;\n+        }\n+        acc.add(d);\n+        return i;\n+    }\n+\n+    @Test\n+    public void test() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        testTraverse(f);\n+\n+        f = f.transform((b, o) -> {\n+            if (o instanceof Op.Lowerable l) {\n+                return l.lower(b);\n+            } else {\n+                b.op(o);\n+                return b;\n+            }\n+        });\n+        testTraverse(f);\n+\n+        f = SSA.transform(f);\n+        testTraverse(f);\n+    }\n+\n+    void testTraverse(Op op) {\n+        List<CodeElement<?, ?>> tl = op.traverse(new ArrayList<>(), (l, e) -> {\n+            l.add(e);\n+            return l;\n+        });\n+        Assert.assertEquals(op.elements().toList(), tl);\n+\n+        Assert.assertEquals(op.elements().limit(2).toList(), tl.subList(0, 2));\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTraverse.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTraverse.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTry\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTry {\n+\n+    @CodeReflection\n+    public static void catching(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatching() {\n+        CoreOps.FuncOp f = getFuncOp(\"catching\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTry::catching);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new NullPointerException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchThrowable(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (Throwable e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrowable() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrowable\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTry::catchThrowable);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchNested(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            try {\n+                c.accept(1);\n+                c.accept(-1);\n+            } catch (IllegalStateException e) {\n+                consume(e);\n+                c.accept(2);\n+                c.accept(-1);\n+            }\n+            c.accept(3);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(4);\n+            c.accept(-1);\n+        }\n+        c.accept(5);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchNested() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchNested\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTry::catchNested);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+            if (i == 4) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 5) throw new RuntimeException();\n+        });\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static void consume(Throwable e) {\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTry.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinally\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTryFinally {\n+\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::tryCatchFinally\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            return;\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testTryReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryReturn\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::tryReturn\n+                );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchThrow(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+            throw e;\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrow() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrow\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::catchThrow\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void finallyReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+            return;\n+        }\n+    }\n+\n+    @Test\n+    public void finallyReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"finallyReturn\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinally::finallyReturn\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    static void test(Consumer<IntConsumer> test) {\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinally.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"},{"patch":"@@ -0,0 +1,382 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinallyNested\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+public class TestTryFinallyNested {\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c, int i) {\n+        try {\n+            try {\n+                if (i == 0) {\n+                    return;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    return;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    return;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                return;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                return;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                return;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryCatchFinally(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea < 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryCatchFinallyBreak(IntConsumer c, int i) {\n+        a: try {\n+            try {\n+                if (i == 0) {\n+                    break a;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    break a;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    break a;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                break a;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                break a;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                break a;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinallyBreak() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinallyBreak\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryCatchFinallyBreak(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea < 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryForLoop(IntConsumer c) {\n+        for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            try {\n+                if (i == 4) {\n+                    continue;\n+                } else if (i == 5) {\n+                    break;\n+                }\n+                c.accept(1);\n+            } finally {\n+                c.accept(2);\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testTryForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryForLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinallyNested::tryForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLabeledForLoop(IntConsumer c) {\n+        a: for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            b: {\n+                try {\n+                    if (i == 4) {\n+                        continue a;\n+                    } else if (i == 5) {\n+                        break b;\n+                    } else if (i == 6) {\n+                        break a;\n+                    }\n+                    c.accept(1);\n+                } finally {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            }\n+            c.accept(4);\n+        }\n+        c.accept(5);\n+    }\n+\n+    @Test\n+    public void testTryLabeledForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                c -> Interpreter.invoke(MethodHandles.lookup(), lf, c),\n+                TestTryFinallyNested::tryLabeledForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLambda(IntConsumer c, int i) {\n+        try {\n+            c.accept(0);\n+            Runnable r = () -> {\n+                if (i == 0) {\n+                    c.accept(1);\n+                    return;\n+                } else {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            };\n+            r.run();\n+            c.accept(4);\n+        } finally {\n+            c.accept(5);\n+        }\n+    }\n+\n+    @Test\n+    public void testTryLambda() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryLambda\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        for (int ra = 0; ra < 2; ra++) {\n+            final int fra = ra;\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> Interpreter.invoke(MethodHandles.lookup(), lf, c, fra),\n+                    c -> tryLambda(c, fra)\n+            );\n+            test.accept(i -> { });\n+        }\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTryFinallyNested.java","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestUsesDependsOn\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+public class TestUsesDependsOn {\n+\n+    static final String OP = \"\"\"\n+            func @\"f\" (%0 : int, %1 : int)int -> {\n+                %2 : int = add %0 %1;\n+                %3 : boolean = lt %0 %1;\n+                %4 : void = cbranch %3 ^b1(%2, %2) ^b2(%0, %1);\n+\n+              ^b1(%5 : int, %6 : int):\n+                %7 : void = return %5;\n+\n+              ^b2(%8 : int, %9 : int):\n+                %10 : void = return %8;\n+            };\n+            \"\"\";\n+\n+    @Test\n+    public void testDependsOn() {\n+        Op f = OpParser.fromStringOfFuncOp(OP);\n+\n+        Map<String, List<String>> dependsUpon = computeValueMap(f, Value::dependsOn);\n+\n+        var expected = Map.ofEntries(\n+                Map.entry(\"0\", List.of()),\n+                Map.entry(\"1\", List.of()),\n+                Map.entry(\"2\", List.of(\"0\", \"1\")),\n+                Map.entry(\"3\", List.of(\"0\", \"1\")),\n+                Map.entry(\"4\", List.of(\"3\", \"2\", \"0\", \"1\")),\n+                Map.entry(\"5\", List.of()),\n+                Map.entry(\"6\", List.of()),\n+                Map.entry(\"7\", List.of(\"5\")),\n+                Map.entry(\"8\", List.of()),\n+                Map.entry(\"9\", List.of()),\n+                Map.entry(\"10\", List.of(\"8\"))\n+        );\n+\n+        Assert.assertEquals(dependsUpon, expected);\n+    }\n+\n+\n+    @Test\n+    public void testUses() {\n+        Op f = OpParser.fromStringOfFuncOp(OP);\n+        f.writeTo(System.out);\n+\n+        Map<String, List<String>> uses = computeValueMap(f, Value::uses);\n+\n+        var expected = Map.ofEntries(\n+                Map.entry(\"0\", List.of(\"2\", \"3\", \"4\")),\n+                Map.entry(\"1\", List.of(\"2\", \"3\", \"4\")),\n+                Map.entry(\"2\", List.of(\"4\")),\n+                Map.entry(\"3\", List.of(\"4\")),\n+                Map.entry(\"4\", List.of()),\n+                Map.entry(\"5\", List.of(\"7\")),\n+                Map.entry(\"6\", List.of()),\n+                Map.entry(\"7\", List.of()),\n+                Map.entry(\"8\", List.of(\"10\")),\n+                Map.entry(\"9\", List.of()),\n+                Map.entry(\"10\", List.of())\n+        );\n+        System.out.println(uses.toString());\n+        System.out.println(expected);\n+\n+        Assert.assertEquals(uses, expected);\n+    }\n+\n+    static Map<String, List<String>> computeValueMap(Op op, Function<Value, Set<? extends Value>> f) {\n+        AtomicInteger ai = new AtomicInteger();\n+\n+        Map<Value, String> valueNameMap = computeValues(op, new HashMap<>(), (v, m) -> {\n+            String name = Integer.toString(ai.getAndIncrement());\n+            m.put(v, name);\n+        });\n+\n+        return computeValues(op, new HashMap<>(), (v, m) -> {\n+            m.put(valueNameMap.get(v), f.apply(v).stream().map(valueNameMap::get).toList());\n+        });\n+    }\n+\n+    static <T> T computeValues(Op op, T t, BiConsumer<Value, T> c) {\n+        return op.traverse(t, (m, codeElement) -> {\n+            return switch (codeElement) {\n+                case Block b -> {\n+                    for (var a : b.parameters()) {\n+                        c.accept(a, m);\n+                    }\n+\n+                    yield m;\n+                }\n+                case Op o -> {\n+                    if (o.result() != null) {\n+                        c.accept(o.result(), m);\n+                    }\n+\n+                    yield m;\n+                }\n+                default -> m;\n+            };\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestUsesDependsOn.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestWhileOp\n+ *\/\n+\n+public class TestWhileOp {\n+\n+    @CodeReflection\n+    public static int whileLoop() {\n+        int i = 0;\n+        while (i < 10) {\n+            i++;\n+        }\n+        return i;\n+    }\n+\n+    @Test\n+    public void testWhileLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"whileLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), whileLoop());\n+    }\n+\n+    @CodeReflection\n+    public static int doWhileLoop() {\n+        int i = 0;\n+        do {\n+            i++;\n+        } while (i < 10);\n+        return i;\n+    }\n+\n+    @Test\n+    public void testDpWhileLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"doWhileLoop\");\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(lf), doWhileLoop());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestWhileOp.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestWhileOp.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.*;\n+\n+public final class ActiveSet {\n+\n+    private ActiveSet() {\n+    }\n+\n+    \/\/ Create active value set, in order, starting from the given block parameter\n+    \/\/ following its users and following through block arguments\n+    \/\/ to block parameters, and so on until the graph is traversed.\n+\n+    public static Set<Value> activeSet(CoreOps.FuncOp f, Block.Parameter fv) {\n+        if (!f.body().blocks().get(0).parameters().contains(fv)) {\n+            throw new IllegalArgumentException(\"Arg is not defined by function\");\n+        }\n+        Deque<Value> q = new ArrayDeque<>();\n+        q.push(fv);\n+\n+        Set<Value> active = new TreeSet<>();\n+        while (!q.isEmpty()) {\n+            Value v = q.pop();\n+            if (active.contains(v)) {\n+                continue;\n+            }\n+            active.add(v);\n+\n+            \/\/ @@@ assume uses are declared in order?\n+            \/\/     if so can push to queue in reverse order\n+            for (Op.Result or : v.uses()) {\n+                q.push(or);\n+                Op op = or.op();\n+\n+                if (op instanceof Op.Terminating) {\n+                    for (Block.Reference s : op.successors()) {\n+                        for (int i = 0; i < s.arguments().size(); i++) {\n+                            if (v == s.arguments().get(i)) {\n+                                Block b = s.targetBlock();\n+                                Block.Parameter ba = b.parameters().get(i);\n+\n+                                \/\/ Processing of block arguments may result in out of order\n+                                \/\/ production of uses if two or more block arguments are added\n+                                \/\/ for the same successor argument\n+                                q.push(ba);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Ensure non-active block arguments of successors are added to the\n+        \/\/ active set for blocks with corresponding active parameters\n+        \/\/ Backtracking is not performed on the values as they are not strictly\n+        \/\/ active set but may be required for initialization purposes.\n+        Set<Value> bactive = new LinkedHashSet<>();\n+        for (Value v : active) {\n+            if (v instanceof Block.Parameter ba) {\n+                Block b = ba.declaringBlock();\n+                int i = b.parameters().indexOf(ba);\n+\n+                for (Block p : b.predecessors()) {\n+                    Op to = p.terminatingOp();\n+                    for (Block.Reference s : to.successors()) {\n+                        if (s.targetBlock() == b) {\n+                            Value arg = s.arguments().get(i);\n+                            if (!active.contains(arg)) {\n+                                bactive.add(arg);\n+                                bactive.add(to.result());\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        active.addAll(bactive);\n+\n+        return active;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ActiveSet.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+\n+import static java.lang.reflect.code.op.CoreOps.sub;\n+import static java.lang.reflect.code.analysis.Patterns.*;\n+\n+public final class ExpressionElimination {\n+    private ExpressionElimination() {\n+    }\n+\n+    static final JavaType J_L_MATH = JavaType.type(Math.class);\n+\n+    static OpPattern negP(Pattern operand) {\n+        return opP(CoreOps.NegOp.class, operand);\n+    }\n+\n+    static OpPattern addP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.AddOp.class, lhs, rhs);\n+    }\n+\n+    static OpPattern mulP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.MulOp.class, lhs, rhs);\n+    }\n+\n+    public static <T extends Op> T eliminate(T f) {\n+        \/\/ Note expression elimination and other forms of analysis is simplified if first of all expressions\n+        \/\/ are normalized e.g. when they have an operand that is a constant expression\n+        \/\/ and the operation is associative such as add(0, x) -> add(x, 0)\n+\n+        var actions = multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n+                .pattern(mulP(_P(), valueP(constantP(0.0d))))\n+                .pattern(mulP(valueP(constantP(0.0d)), _P()))\n+                .pattern(addP(valueP(), constantP(0.0d)))\n+                .pattern(addP(constantP(0.0d), valueP()))\n+                .pattern(mulP(constantP(1.0d), valueP()))\n+                .pattern(mulP(valueP(), constantP(1.0d)))\n+                .target((ms, as) -> {\n+                    Value a = ms.matchedOperands().get(0);\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        cc.mapValue(ms.op().result(), cc.getValue(a));\n+                    });\n+                    return as;\n+                })\n+                \/\/ add(neg(x), y) -> sub(y, x)\n+                .pattern(addP(negP(valueP()), valueP()))\n+                .target((ms, as) -> {\n+                    Value x = ms.matchedOperands().get(0);\n+                    Value y = ms.matchedOperands().get(1);\n+\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        Op.Result r = block.op(sub(cc.getValue(y), cc.getValue(x)));\n+                        cc.mapValue(ms.op().result(), r);\n+                    });\n+                    return as;\n+                })\n+                .matchThenApply();\n+\n+        \/\/ Eliminate\n+        Op ef = f.transform(CopyContext.create(), (block, op) -> {\n+            BiConsumer<Block.Builder, Op> a = actions.get(op.result());\n+            if (a != null) {\n+                a.accept(block, op);\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+\n+        Predicate<Op> testPure = op -> {\n+            if (op instanceof Op.Pure) {\n+                return true;\n+            } else {\n+                return op instanceof CoreOps.InvokeOp c && c.invokeDescriptor().refType().equals(J_L_MATH);\n+            }\n+        };\n+\n+        while (true) {\n+            Set<Op> unused = matchUnusedPureOps(ef, testPure);\n+            if (unused.isEmpty()) {\n+                break;\n+            }\n+            \/\/ Remove unused ops\n+            ef = ef.transform(CopyContext.create(), (block, op) -> {\n+                if (!unused.contains(op)) {\n+                    block.op(op);\n+                }\n+                return block;\n+            });\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T t = (T) ef;\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ExpressionElimination.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.JavaType.DOUBLE;\n+\n+public final class ForwardDifferentiation {\n+    \/\/ The function to differentiate\n+    final FuncOp fcm;\n+    \/\/ The independent variable\n+    final Block.Parameter ind;\n+    \/\/ The active set for the independent variable\n+    final Set<Value> activeSet;\n+    \/\/ The map of input value to it's (output) differentiated value\n+    final Map<Value, Value> diffValueMapping;\n+\n+    \/\/ The constant value 0.0d\n+    \/\/ Declared in the (output) function's entry block\n+    Value zero;\n+\n+    private ForwardDifferentiation(FuncOp fcm, Block.Parameter ind) {\n+        int indI = fcm.body().entryBlock().parameters().indexOf(ind);\n+        if (indI == -1) {\n+            throw new IllegalArgumentException(\"Independent argument not defined by function\");\n+        }\n+        this.fcm = fcm;\n+        this.ind = ind;\n+\n+        \/\/ Calculate the active set of dependent values for the independent value\n+        this.activeSet = ActiveSet.activeSet(fcm, ind);\n+        \/\/ A mapping of input values to their (output) differentiated values\n+        this.diffValueMapping = new HashMap<>();\n+    }\n+\n+    public static FuncOp partialDiff(FuncOp fcm, Block.Parameter ind) {\n+        return new ForwardDifferentiation(fcm, ind).partialDiff();\n+    }\n+\n+    FuncOp partialDiff() {\n+        int indI = fcm.body().entryBlock().parameters().indexOf(ind);\n+\n+        AtomicBoolean first = new AtomicBoolean(true);\n+        FuncOp dfcm = fcm.transform(String.format(\"d%s_darg%d\", fcm.funcName(), indI),\n+                (block, op) -> {\n+                    if (first.getAndSet(false)) {\n+                        \/\/ Initialize\n+                        processBlocks(block);\n+                    }\n+\n+                    \/\/ If the result of the operation is in the active set,\n+                    \/\/ then differentiate it, otherwise copy it\n+                    if (activeSet.contains(op.result())) {\n+                        Value dor = diffOp(block, op);\n+                        \/\/ Map the input result to its (output) differentiated result\n+                        \/\/ so that it can be used when differentiating subsequent operations\n+                        diffValueMapping.put(op.result(), dor);\n+                    } else {\n+                        block.apply(op);\n+                    }\n+                    return block;\n+                });\n+\n+        return dfcm;\n+    }\n+\n+    void processBlocks(Block.Builder block) {\n+        \/\/ Declare constants at start\n+        zero = block.op(constant(ind.type(), 0.0d));\n+        \/\/ The differential of ind is 1\n+        Value one = block.op(constant(ind.type(), 1.0d));\n+        diffValueMapping.put(ind, one);\n+\n+        \/\/ Append differential block parameters to blocks\n+        for (Value v : activeSet) {\n+            if (v instanceof Block.Parameter ba) {\n+                if (ba != ind) {\n+                    \/\/ Get the output block builder for the input (declaring) block\n+                    Block.Builder b = block.context().getBlock(ba.declaringBlock());\n+                    \/\/ Add a new block parameter for differential parameter\n+                    Block.Parameter dba = b.parameter(ba.type());\n+                    \/\/ Place in mapping\n+                    diffValueMapping.put(ba, dba);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    static final JavaType J_L_MATH = JavaType.type(Math.class);\n+    static final FunctionType D_D = FunctionType.functionType(DOUBLE, DOUBLE);\n+    static final MethodRef J_L_MATH_SIN = MethodRef.method(J_L_MATH, \"sin\", D_D);\n+    static final MethodRef J_L_MATH_COS = MethodRef.method(J_L_MATH, \"cos\", D_D);\n+\n+    Value diffOp(Block.Builder block, Op op) {\n+        \/\/ Switch on the op, using pattern matching\n+        return switch (op) {\n+            case CoreOps.NegOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+\n+                \/\/ -diff(expr)\n+                Value a = op.operands().get(0);\n+                Value da = diffValueMapping.getOrDefault(a, zero);\n+                yield block.op(neg(da));\n+            }\n+            case CoreOps.AddOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+\n+                \/\/ diff(l) + diff(r)\n+                Value lhs = op.operands().get(0);\n+                Value rhs = op.operands().get(1);\n+                Value dlhs = diffValueMapping.getOrDefault(lhs, zero);\n+                Value drhs = diffValueMapping.getOrDefault(rhs, zero);\n+                yield block.op(add(dlhs, drhs));\n+            }\n+            case CoreOps.MulOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+\n+                \/\/ Product rule\n+                \/\/ diff(l) * r + l * diff(r)\n+                Value lhs = op.operands().get(0);\n+                Value rhs = op.operands().get(1);\n+                Value dlhs = diffValueMapping.getOrDefault(lhs, zero);\n+                Value drhs = diffValueMapping.getOrDefault(rhs, zero);\n+                Value outputLhs = block.context().getValue(lhs);\n+                Value outputRhs = block.context().getValue(rhs);\n+                yield block.op(add(\n+                        block.op(mul(dlhs, outputRhs)),\n+                        block.op(mul(outputLhs, drhs))));\n+            }\n+            case CoreOps.ConstantOp _ -> {\n+                \/\/ Copy input operation\n+                block.op(op);\n+                \/\/ Differential of constant is zero\n+                yield zero;\n+            }\n+            case CoreOps.InvokeOp c -> {\n+                MethodRef md = c.invokeDescriptor();\n+                String operationName = null;\n+                if (md.refType().equals(J_L_MATH)) {\n+                    operationName = md.name();\n+                }\n+                \/\/ Differentiate sin(x)\n+                if (\"sin\".equals(operationName)) {\n+                    \/\/ Copy input operation\n+                    block.op(op);\n+\n+                    \/\/ Chain rule\n+                    \/\/ cos(expr) * diff(expr)\n+                    Value a = op.operands().get(0);\n+                    Value da = diffValueMapping.getOrDefault(a, zero);\n+                    Value outputA = block.context().getValue(a);\n+                    Op.Result cosx = block.op(invoke(J_L_MATH_COS, outputA));\n+                    yield block.op(mul(cosx, da));\n+                } else {\n+                    throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+                }\n+            }\n+            case CoreOps.ReturnOp _ -> {\n+                \/\/ Replace with return of differentiated value\n+                Value a = op.operands().get(0);\n+                Value da = diffValueMapping.getOrDefault(a, zero);\n+                yield block.op(_return(da));\n+            }\n+            case Op.BlockTerminating _ -> {\n+                \/\/ Update with differentiated block arguments\n+                op.successors().forEach(s -> adaptSuccessor(block.context(), s));\n+                yield block.op(op);\n+            }\n+            default -> throw new UnsupportedOperationException(\"Operation not supported: \" + op.opName());\n+        };\n+    }\n+\n+    void adaptSuccessor(CopyContext cc, Block.Reference from) {\n+        List<Value> as = from.arguments().stream()\n+                .filter(activeSet::contains)\n+                .toList();\n+        if (!as.isEmpty()) {\n+            \/\/ Get the successor arguments\n+            List<Value> outputArgs = cc.getValues(from.arguments());\n+            \/\/ Append the differential arguments, if any\n+            for (Value a : as) {\n+                Value da = diffValueMapping.get(a);\n+                outputArgs.add(da);\n+            }\n+\n+            \/\/ Map successor with appended arguments\n+            Block.Reference to = cc.getBlock(from.targetBlock()).successor(outputArgs);\n+            cc.mapSuccessor(from, to);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/ForwardDifferentiation.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestForwardAutoDiff\n+ *\/\n+\n+public class TestForwardAutoDiff {\n+    static final double PI_4 = Math.PI \/ 4;\n+\n+    @Test\n+    public void testExpression() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+        f.writeTo(System.out);\n+\n+        f = SSA.transform(f);\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 0.0, 1.0), f(0.0, 1.0));\n+        Assert.assertEquals(Interpreter.invoke(f, PI_4, PI_4), f(PI_4, PI_4));\n+\n+        Block.Parameter x = f.body().entryBlock().parameters().get(0);\n+        Block.Parameter y = f.body().entryBlock().parameters().get(1);\n+\n+        CoreOps.FuncOp dff_dx = ExpressionElimination.eliminate(ForwardDifferentiation.partialDiff(f, x));\n+        dff_dx.writeTo(System.out);\n+        MethodHandle dff_dx_mh = generate(dff_dx);\n+        Assert.assertEquals((double) dff_dx_mh.invoke(0.0, 1.0), df_dx(0.0, 1.0));\n+        Assert.assertEquals((double) dff_dx_mh.invoke(PI_4, PI_4), df_dx(PI_4, PI_4));\n+\n+        CoreOps.FuncOp dff_dy = ExpressionElimination.eliminate(ForwardDifferentiation.partialDiff(f, y));\n+        dff_dy.writeTo(System.out);\n+        MethodHandle dff_dy_mh = generate(dff_dy);\n+        Assert.assertEquals((double) dff_dy_mh.invoke(0.0, 1.0), df_dy(0.0, 1.0));\n+        Assert.assertEquals((double) dff_dy_mh.invoke(PI_4, PI_4), df_dy(PI_4, PI_4));\n+    }\n+\n+    @CodeReflection\n+    static double f(double x, double y) {\n+        return x * (-Math.sin(x * y) + y) * 4.0d;\n+    }\n+\n+    static double df_dx(double x, double y) {\n+        return (-Math.sin(x * y) + y - x * Math.cos(x * y) * y) * 4.0d;\n+    }\n+\n+    static double df_dy(double x, double y) {\n+        return x * (1 - Math.cos(x * y) * x) * 4.0d;\n+    }\n+\n+    @Test\n+    public void testControlFlow() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"fcf\");\n+        f.writeTo(System.out);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        f = SSA.transform(f);\n+        f.writeTo(System.out);\n+\n+        Assert.assertEquals(Interpreter.invoke(f, 2.0, 6), fcf(2.0, 6));\n+        Assert.assertEquals(Interpreter.invoke(f, 2.0, 5), fcf(2.0, 5));\n+        Assert.assertEquals(Interpreter.invoke(f, 2.0, 4), fcf(2.0, 4));\n+\n+        Block.Parameter x = f.body().entryBlock().parameters().get(0);\n+\n+        CoreOps.FuncOp df_dx = ForwardDifferentiation.partialDiff(f, x);\n+        df_dx.writeTo(System.out);\n+        MethodHandle df_dx_mh = generate(df_dx);\n+\n+        Assert.assertEquals((double) df_dx_mh.invoke(2.0, 6), dfcf_dx(2.0, 6));\n+        Assert.assertEquals((double) df_dx_mh.invoke(2.0, 5), dfcf_dx(2.0, 5));\n+        Assert.assertEquals((double) df_dx_mh.invoke(2.0, 4), dfcf_dx(2.0, 4));\n+    }\n+\n+    @CodeReflection\n+    static double fcf(\/* independent *\/ double x, int y) {\n+        \/* dependent *\/\n+        double o = 1.0;\n+        for (int i = 0; i < y; i = i + 1) {\n+            if (i > 1) {\n+                if (i < 5) {\n+                    o = o * x;\n+                }\n+            }\n+        }\n+        return o;\n+    }\n+\n+    static double dfcf_dx(\/* independent *\/ double x, int y) {\n+        double d_o = 0.0;\n+        double o = 1.0;\n+        for (int i = 0; i < y; i = i + 1) {\n+            if (i > 1) {\n+                if (i < 5) {\n+                    d_o = d_o * x + o * 1.0;\n+                    o = o * x;\n+                }\n+            }\n+        }\n+        return d_o;\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestForwardAutoDiff.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/internal\/jimage\/TEST.properties","status":"copied"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCreation\n+ *\/\n+\n+public class TestArrayCreation {\n+    @CodeReflection\n+    public static String[] f() {\n+        return new String[10];\n+    }\n+\n+    @Test\n+    public void testf() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[]) mh.invoke(), f());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f2() {\n+        return new String[10][];\n+    }\n+\n+    @Test\n+    public void testf2() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[][]) mh.invoke(), f2());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f3() {\n+        return new String[10][10];\n+    }\n+\n+    @Test\n+    public void testf3() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[][]) mh.invoke(), f3());\n+    }\n+\n+    @CodeReflection\n+    public static String[][] f4() {\n+        return new String[][]{{\"one\", \"two\"}, {\"three\"}};\n+    }\n+\n+    @Test\n+    public void testf4() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f4\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals((String[][]) mh.invoke(), f4());\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestArrayCreation.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.components.ClassPrinter;\n+import static java.lang.classfile.Opcode.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.code.bytecode.BranchCompactor;\n+import java.util.List;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestBranchCompactor\n+ *\/\n+public class TestBranchCompactor {\n+\n+    @Test\n+    public void testBranchCompactor() {\n+        var cc = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        var clm = cc.parse(cc.build(ClassDesc.of(\"c\"), clb -> clb.withMethodBody(\"m\", ConstantDescs.MTD_void, 0,\n+                cb -> cb.transforming(new BranchCompactor(), cob -> {\n+                    var l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .lineNumber(1)\n+                       .labelBinding(l)\n+                       .nop();\n+\n+                    l = cob.newLabel();\n+                    cob.goto_w(l) \/\/compact\n+                       .lineNumber(2)\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .labelBinding(l);\n+\n+                    cob.iconst_0();\n+                    l = cob.newLabel();\n+                    cob.ifeq(l) \/\/do not compact\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/do not compact\n+                       .nop()\n+                       .labelBinding(l)\n+                       .return_();\n+                }))));\n+        var code = clm.methods().get(0).code().get();\n+        ClassPrinter.toYaml(code, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        Assert.assertEquals(\n+                code.elementList().stream().mapMulti((e, ec) -> {if (e instanceof Instruction i) ec.accept(i.opcode());}).toList(),\n+                List.of(NOP, ICONST_0, IFEQ, GOTO, NOP, RETURN));\n+        Assert.assertEquals(code.findAttribute(Attributes.LINE_NUMBER_TABLE).get().lineNumbers().size(), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,598 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.components.ClassPrinter;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import org.testng.Assert;\n+import org.testng.SkipException;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.TypeElement;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.runtime.CodeReflection;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ *\/\n+\n+public class TestBytecode {\n+\n+    @CodeReflection\n+    static int intNumOps(int i, int j, int k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static byte byteNumOps(byte i, byte j, byte k) {\n+        k++;\n+        i = (byte) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static short shortNumOps(short i, short j, short k) {\n+        k++;\n+        i = (short) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static char charNumOps(char i, char j, char k) {\n+        k++;\n+        i = (char) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static long longNumOps(long i, long j, long k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static float floatNumOps(float i, float j, float k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static double doubleNumOps(double i, double j, double k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int intBitOps(int i, int j, int k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static byte byteBitOps(byte i, byte j, byte k) {\n+        return (byte) (i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static short shortBitOps(short i, short j, short k) {\n+        return (short) (i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static char charBitOps(char i, char j, char k) {\n+        return (char) (i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static long longBitOps(long i, long j, long k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static boolean boolBitOps(boolean i, boolean j, boolean k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int intShiftOps(int i, int j, int k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static byte byteShiftOps(byte i, byte j, byte k) {\n+        return (byte) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static short shortShiftOps(short i, short j, short k) {\n+        return (short) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static char charShiftOps(char i, char j, char k) {\n+        return (char) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static long longShiftOps(long i, long j, long k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static Object[] boxingAndUnboxing(int i, byte b, short s, char c, Integer ii, Byte bb, Short ss, Character cc) {\n+        ii += i; ii += b; ii += s; ii += c;\n+        i += ii; i += bb; i += ss; i += cc;\n+        b += ii; b += bb; b += ss; b += cc;\n+        s += ii; s += bb; s += ss; s += cc;\n+        c += ii; c += bb; c += ss; c += cc;\n+        return new Object[]{i, b, s, c};\n+    }\n+\n+    @CodeReflection\n+    static String constructor(String s, int i, int j) {\n+        return new String(s.getBytes(), i, j);\n+    }\n+\n+    @CodeReflection\n+    static Class<?> classArray(int i, int j) {\n+        Class<?>[] ifaces = new Class[1 + i + j];\n+        ifaces[0] = Function.class;\n+        return ifaces[0];\n+    }\n+\n+    @CodeReflection\n+    static String[] stringArray(int i, int j) {\n+        return new String[i];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArray2(int i, int j) {\n+        return new String[i][];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArrayMulti(int i, int j) {\n+        return new String[i][j];\n+    }\n+\n+    @CodeReflection\n+    static int[][] initializedIntArray(int i, int j) {\n+        return new int[][]{{i, j}, {i + j}};\n+    }\n+\n+    @CodeReflection\n+    static int ifElseCompare(int i, int j) {\n+        if (i < 3) {\n+            i += 1;\n+        } else {\n+            j += 2;\n+        }\n+        return i + j;\n+    }\n+\n+    @CodeReflection\n+    static int ifElseEquality(int i, int j) {\n+        if (j != 0) {\n+            if (i != 0) {\n+                i += 1;\n+            } else {\n+                i += 2;\n+            }\n+        } else {\n+            if (j != 0) {\n+                i += 3;\n+            } else {\n+                i += 4;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int conditionalExpr(int i, int j) {\n+        return ((i - 1 >= 0) ? i - 1 : j - 1);\n+    }\n+\n+    @CodeReflection\n+    static int nestedConditionalExpr(int i, int j) {\n+        return (i < 2) ? (j < 3) ? i : j : i + j;\n+    }\n+\n+    @CodeReflection\n+    static int tryFinally(int i, int j) {\n+        try {\n+            i = i + j;\n+        } finally {\n+            i = i + j;\n+        }\n+        return i;\n+    }\n+\n+    public record A(String s) {}\n+\n+    @CodeReflection\n+    static A newWithArgs(int i, int j) {\n+        return new A(\"hello world\".substring(i, i + j));\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n, int j) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + j;\n+        }\n+        return sum;\n+    }\n+\n+\n+    @CodeReflection\n+    static int ifElseNested(int a, int b) {\n+        int c = a + b;\n+        int d = 10 - a + b;\n+        if (b < 3) {\n+            if (a < 3) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (a > 2) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @CodeReflection\n+    static int methodCall(int a, int b) {\n+        int i = Math.max(a, b);\n+        return Math.negateExact(i);\n+    }\n+\n+    @CodeReflection\n+    static int[] primitiveArray(int i, int j) {\n+        int[] ia = new int[i + 1];\n+        ia[0] = j;\n+        return ia;\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static boolean notCompare(int i, int j) {\n+        boolean b = i < j;\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static int mod(int i, int j) {\n+        return i % (j + 1);\n+    }\n+\n+    @CodeReflection\n+    static int xor(int i, int j) {\n+        return i ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int whileLoop(int i, int n) { int\n+        counter = 0;\n+        while (i < n && counter < 3) {\n+            counter++;\n+            if (counter == 4) {\n+                break;\n+            }\n+            i++;\n+        }\n+        return counter;\n+    }\n+\n+    public interface Func {\n+        int apply(int a);\n+    }\n+\n+    public interface QuotableFunc extends Quotable {\n+        int apply(int a);\n+    }\n+\n+    static int consume(int i, Func f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    static int consumeQuotable(int i, QuotableFunc f) {\n+        Assert.assertNotNull(f.quoted());\n+        Assert.assertNotNull(f.quoted().op());\n+        Assert.assertTrue(f.quoted().op() instanceof CoreOps.LambdaOp);\n+        return f.apply(i + 1);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int lambda(int i) {\n+        return consume(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int quotableLambda(int i) {\n+        return consumeQuotable(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int lambdaWithCapture(int i, String s) {\n+        return consume(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int quotableLambdaWithCapture(int i, String s) {\n+        return consumeQuotable(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consume(i, a -> consume(a, b -> a + b + j) + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j) + s.length());\n+    }\n+\n+    @CodeReflection\n+    @SkipLift\n+    static int methodHandle(int i) {\n+        return consume(i, Math::negateExact);\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface SkipLift {}\n+\n+    record TestData(Method testMethod) {\n+        @Override\n+        public String toString() {\n+            String s = testMethod.getName() + Arrays.stream(testMethod.getParameterTypes())\n+                    .map(Class::getSimpleName).collect(Collectors.joining(\",\", \"(\", \")\"));\n+            if (s.length() > 30) s = s.substring(0, 27) + \"...\";\n+            return s;\n+        }\n+    }\n+\n+    @DataProvider(name = \"testMethods\")\n+    public static TestData[]testMethods() {\n+        return Stream.of(TestBytecode.class.getDeclaredMethods())\n+                .filter(m -> m.isAnnotationPresent(CodeReflection.class))\n+                .map(TestData::new).toArray(TestData[]::new);\n+    }\n+\n+    private static byte[] CLASS_DATA;\n+    private static ClassModel CLASS_MODEL;\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        CLASS_DATA = TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes();\n+        CLASS_MODEL = ClassFile.of().parse(CLASS_DATA);\n+    }\n+\n+    private static MethodTypeDesc toMethodTypeDesc(Method m) {\n+        return MethodTypeDesc.of(\n+                m.getReturnType().describeConstable().orElseThrow(),\n+                Arrays.stream(m.getParameterTypes())\n+                        .map(cls -> cls.describeConstable().orElseThrow()).toList());\n+    }\n+\n+\n+    private static final Map<Class<?>, Object[]> TEST_ARGS = new IdentityHashMap<>();\n+    private static Object[] values(Object... values) {\n+        return values;\n+    }\n+    private static void initTestArgs(Object[] values, Class<?>... argTypes) {\n+        for (var argType : argTypes) TEST_ARGS.put(argType, values);\n+    }\n+    static {\n+        initTestArgs(values(1, 2, 3, 4), int.class, Integer.class);\n+        initTestArgs(values((byte)1, (byte)2, (byte)3, (byte)4), byte.class, Byte.class);\n+        initTestArgs(values((short)1, (short)2, (short)3, (short)4), short.class, Short.class);\n+        initTestArgs(values((char)1, (char)2, (char)3, (char)4), char.class, Character.class);\n+        initTestArgs(values(false, true), boolean.class, Boolean.class);\n+        initTestArgs(values(\"Hello World\"), String.class);\n+        initTestArgs(values(1l, 2l, 3l, 4l), long.class, Long.class);\n+        initTestArgs(values(1f, 2f, 3f, 4f), float.class, Float.class);\n+        initTestArgs(values(1d, 2d, 3d, 4d), double.class, Double.class);\n+    }\n+\n+    interface Executor {\n+        void execute(Object[] args) throws Throwable;\n+    }\n+\n+    private static void permutateAllArgs(Class<?>[] argTypes, Executor executor) throws Throwable {\n+        final int argn = argTypes.length;\n+        Object[][] argValues = new Object[argn][];\n+        for (int i = 0; i < argn; i++) {\n+            argValues[i] = TEST_ARGS.get(argTypes[i]);\n+        }\n+        int[] argIndexes = new int[argn];\n+        Object[] args = new Object[argn];\n+        while (true) {\n+            for (int i = 0; i < argn; i++) {\n+                args[i] = argValues[i][argIndexes[i]];\n+            }\n+            executor.execute(args);\n+            int i = argn - 1;\n+            while (i >= 0 && argIndexes[i] == argValues[i].length - 1) i--;\n+            if (i < 0) return;\n+            argIndexes[i++]++;\n+            while (i < argn) argIndexes[i++] = 0;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testLift(TestData d) throws Throwable {\n+        if (d.testMethod.getAnnotation(SkipLift.class) != null) {\n+            throw new SkipException(\"skipped\");\n+        }\n+        CoreOps.FuncOp flift;\n+        try {\n+            flift = BytecodeLift.lift(CLASS_DATA, d.testMethod.getName(), toMethodTypeDesc(d.testMethod));\n+        } catch (Throwable e) {\n+            System.out.println(\"Lift failed, expected:\");\n+            d.testMethod.getCodeModel().ifPresent(f -> f.writeTo(System.out));\n+            throw e;\n+        }\n+        try {\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                Assert.assertEquals(invokeAndConvert(flift, args), d.testMethod.invoke(null, args)));\n+        } catch (Throwable e) {\n+            flift.writeTo(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    private static Object invokeAndConvert(CoreOps.FuncOp func, Object[] args) {\n+        Object ret = Interpreter.invoke(func, args);\n+        if (ret instanceof Integer i) {\n+            TypeElement rt = func.invokableType().returnType();\n+            if (rt.equals(JavaType.BOOLEAN)) {\n+                return i != 0;\n+            } else if (rt.equals(JavaType.BYTE)) {\n+                return i.byteValue();\n+            } else if (rt.equals(JavaType.CHAR)) {\n+                return (short)i.intValue();\n+            } else if (rt.equals(JavaType.SHORT)) {\n+                return i.shortValue();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testGenerate(TestData d) throws Throwable {\n+        CoreOps.FuncOp func = d.testMethod.getCodeModel().get();\n+\n+        CoreOps.FuncOp lfunc = func.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        try {\n+            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lfunc);\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                    Assert.assertEquals(mh.invokeWithArguments(args), d.testMethod.invoke(null, args)));\n+        } catch (Throwable e) {\n+            func.writeTo(System.out);\n+            lfunc.writeTo(System.out);\n+            String methodName = d.testMethod().getName();\n+            for (var mm : CLASS_MODEL.methods()) {\n+                if (mm.methodName().equalsString(methodName)\n+                        || mm.methodName().stringValue().startsWith(\"lambda$\" + methodName + \"$\")) {\n+                    ClassPrinter.toYaml(mm,\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                }\n+            }\n+            Files.list(Path.of(\"DUMP_CLASS_FILES\")).forEach(p -> {\n+                if (p.getFileName().toString().matches(methodName + \"\\\\..+\\\\.class\")) try {\n+                    ClassPrinter.toYaml(ClassFile.of().parse(p),\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                } catch (IOException ignore) {}\n+            });\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":598,"deletions":0,"binary":false,"changes":598,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Label;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLiftCustomBytecode\n+ *\/\n+\n+public class TestLiftCustomBytecode {\n+\n+    @Test\n+    public void testBackJumps() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(ClassFile.of().build(ClassDesc.of(\"BackJumps\"), clb ->\n+                clb.withMethodBody(\"backJumps\", MethodTypeDesc.of(ConstantDescs.CD_int, ConstantDescs.CD_int), ClassFile.ACC_STATIC, cob -> {\n+                    Label l1 = cob.newLabel();\n+                    Label l2 = cob.newLabel();\n+                    Label l3 = cob.newLabel();\n+                    Label l4 = cob.newLabel();\n+                    \/\/ Code wrapped in back jumps requires multiple passes and block skipping\n+                    cob.goto_(l1)\n+                       .labelBinding(l2)\n+                       .goto_(l3)\n+                       .labelBinding(l4)\n+                       .iload(0)\n+                       .ireturn()\n+                       .labelBinding(l1)\n+                       .goto_(l2)\n+                       .labelBinding(l3)\n+                       .goto_(l4);\n+                })), \"backJumps\");\n+\n+        Assert.assertEquals((int) Interpreter.invoke(f, 42), 42);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(byte[] classdata, String method) {\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, method);\n+        flift.writeTo(System.out);\n+        return flift;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftCustomBytecode.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Proxy;\n+import java.net.URL;\n+import java.util.function.Function;\n+\n+\/*\n+ * @test\n+ * @run testng TestLiftExample\n+ *\/\n+\n+public class TestLiftExample {\n+\n+    public static <T, R> Function<T, R> proxy(Function<T, R> f) {\n+        @SuppressWarnings(\"unchecked\")\n+        Function<T, R> pf = (Function<T, R>) Proxy.newProxyInstance(\n+                TestLiftExample.class.getClassLoader(),\n+                new Class[]{Function.class},\n+                \/\/ @@@ Change to lambda\n+                handler(f));\n+        return pf;\n+    }\n+\n+    static InvocationHandler handler(Function<?, ?> f) {\n+        return (proxy, method, args) -> {\n+            if (method.getName().equals(\"apply\")) {\n+                int r = (int) method.invoke(f, args);\n+                return r + 1;\n+            } else {\n+                return method.invoke(f, args);\n+            }\n+        };\n+    }\n+\n+    @Test\n+    public void testF() throws Throwable {\n+        URL resource = TestLiftExample.class.getClassLoader().getResource(TestLiftExample.class.getName().replace('.', '\/') + \".class\");\n+        byte[] classdata = resource.openStream().readAllBytes();\n+        CoreOps.FuncOp flift = BytecodeLift.lift(classdata, \"proxy\");\n+        flift.writeTo(System.out);\n+\n+        Function<Integer, Integer> f = i -> i;\n+        @SuppressWarnings(\"unchecked\")\n+        Function<Integer, Integer> pf = (Function<Integer, Integer>) Interpreter.invoke(MethodHandles.lookup(),\n+                flift, f);\n+\n+        Assert.assertEquals((int) pf.apply(1), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftExample.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.IntBinaryOperator;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestQuoted\n+ *\/\n+\n+public class TestQuoted {\n+\n+    @Test\n+    public void testQuoted() throws Throwable {\n+        Quoted q = (int i, int j) -> {\n+            i = i + j;\n+            return i;\n+        };\n+        CoreOps.ClosureOp cop = (CoreOps.ClosureOp) q.op();\n+\n+        MethodHandle mh = generate(cop);\n+\n+        Assert.assertEquals(3, (int) mh.invoke(1, 2));\n+    }\n+\n+    static <O extends Op & Op.Invokable> MethodHandle generate(O f) {\n+        f.writeTo(System.out);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        O lf = (O) f.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestQuoted.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestSlots\n+ *\/\n+\n+public class TestSlots {\n+    @CodeReflection\n+    static double f(double i, double j) {\n+        i = i + j;\n+\n+        double k = 4.0;\n+        k += i;\n+        return k;\n+    }\n+\n+    @Test\n+    public void testF() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals(f(1.0d, 2.0d), (double) mh.invoke(1.0d, 2.0d));\n+    }\n+\n+    @CodeReflection\n+    static double f2(double x, double y) {\n+        return x * (-Math.sin(x * y) + y) * 4.0d;\n+    }\n+\n+    @Test\n+    public void testF2() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f2\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Assert.assertEquals(f2(1.0d, 2.0d), (double) mh.invoke(1.0d, 2.0d));\n+    }\n+\n+    @CodeReflection\n+    static double f3(\/* independent *\/ double x, int y) {\n+        \/* dependent *\/\n+        double o = 1.0;\n+        for (int i = 0; i < y; i = i + 1) {\n+            if (i > 1) {\n+                if (i < 5) {\n+                    o = o * x;\n+                }\n+            }\n+        }\n+        return o;\n+    }\n+\n+    @Test\n+    public void testF3() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f3\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        for (int i = 0; i < 7; i++) {\n+            Assert.assertEquals(f3(2.0d, i), (double) mh.invoke(2.0d, i));\n+        }\n+    }\n+\n+    @CodeReflection\n+    static int f4(\/* Unused *\/ int a, int b) {\n+        return b;\n+    }\n+\n+    @Test\n+    public void testF4() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f4\");\n+\n+        MethodHandle mh;\n+        try {\n+            mh = generate(f);\n+        } catch (VerifyError e) {\n+            Assert.fail(\"invalid class file generated\", e);\n+            return;\n+        }\n+\n+        Assert.assertEquals(f4(1, 2), (int) mh.invoke(1, 2));\n+    }\n+\n+    @CodeReflection\n+    static double f5(\/* Unused *\/ double a, double b) {\n+        return b;\n+    }\n+\n+    @Test\n+    public void testF5() throws Throwable {\n+        CoreOps.FuncOp f = getFuncOp(\"f5\");\n+\n+        MethodHandle mh;\n+        try {\n+            mh = generate(f);\n+        } catch (VerifyError e) {\n+            Assert.fail(\"invalid class file generated\", e);\n+            return;\n+        }\n+\n+        Assert.assertEquals(f5(1.0, 2.0), (double) mh.invoke(1.0, 2.0));\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestSlots.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.instruction.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.bytecode.BytecodeLift;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.Assert;\n+import org.testng.annotations.Ignore;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestSmallCorpus\n+ *\/\n+public class TestSmallCorpus {\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final ClassFile CF = ClassFile.of(ClassFile.DebugElementsOption.DROP_DEBUG,\n+                                                     ClassFile.LineNumbersOption.DROP_LINE_NUMBERS);\n+    private static final int COLUMN_WIDTH = 150;\n+\n+    private int passed, notMatching;\n+    private Map<String, Map<String, Integer>> errorStats;\n+\n+    @Ignore\n+    @Test\n+    public void testDoubleRoundtripStability() throws Exception {\n+        passed = 0;\n+        notMatching = 0;\n+        errorStats = new LinkedHashMap<>();\n+        for (Path p : Files.walk(JRT.getPath(\"modules\/java.base\/java\"))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".class\"))\n+                .toList()) {\n+            testDoubleRoundtripStability(p);\n+        }\n+\n+        for (var stats : errorStats.entrySet()) {\n+            System.out.println(String.format(\"\"\"\n+\n+            %s errors:\n+            -----------------------------------------------------\n+            \"\"\", stats.getKey()));\n+            stats.getValue().entrySet().stream().sorted((e1, e2) -> Integer.compare(e2.getValue(), e1.getValue())).forEach(e -> System.out.println(e.getValue() +\"x \" + e.getKey() + \"\\n\"));\n+        }\n+\n+        \/\/ @@@ There is still several failing cases and a lot of errors\n+        Assert.assertTrue(notMatching < 31 && passed > 5400, String.format(\"\"\"\n+\n+                    passed: %d\n+                    not matching: %d\n+                    %s\n+                \"\"\",\n+                passed,\n+                notMatching,\n+                errorStats.entrySet().stream().map(e -> e.getKey() +\n+                        \" errors: \"\n+                        + e.getValue().values().stream().mapToInt(Integer::intValue).sum()).collect(Collectors.joining(\"\\n    \"))\n+                ));\n+    }\n+\n+    private void testDoubleRoundtripStability(Path path) throws Exception {\n+        var clm = CF.parse(path);\n+        for (var originalModel : clm.methods()) {\n+            if (originalModel.flags().has(AccessFlag.STATIC) && originalModel.code().isPresent()) try {\n+                CoreOps.FuncOp firstLift = lift(originalModel);\n+                try {\n+                    CoreOps.FuncOp firstTransform = transform(firstLift);\n+                    try {\n+                        MethodModel firstModel = lower(firstTransform);\n+                        try {\n+                            CoreOps.FuncOp secondLift = lift(firstModel);\n+                            try {\n+                                CoreOps.FuncOp secondTransform = transform(secondLift);\n+                                try {\n+                                    MethodModel secondModel = lower(secondTransform);\n+\n+                                    \/\/ testing only methods passing through\n+                                    var firstNormalized = normalize(firstModel);\n+                                    var secondNormalized = normalize(secondModel);\n+                                    if (!firstNormalized.equals(secondNormalized)) {\n+                                        notMatching++;\n+                                        System.out.println(clm.thisClass().asInternalName() + \"::\" + originalModel.methodName().stringValue() + originalModel.methodTypeSymbol().displayDescriptor());\n+                                        printInColumns(firstLift, secondLift);\n+                                        printInColumns(firstTransform, secondTransform);\n+                                        printInColumns(firstNormalized, secondNormalized);\n+                                        System.out.println();\n+                                    } else {\n+                                        passed++;\n+                                    }\n+                                } catch (Exception e) {\n+                                    error(\"second lower\", e);\n+                                }\n+                            } catch (Exception e) {\n+                                error(\"second transform\", e);\n+                            }\n+                        } catch (Exception e) {\n+                            error(\"second lift\", e);\n+                        }\n+                    } catch (Exception e) {\n+                        error(\"first lower\", e);\n+                    }\n+                } catch (Exception e) {\n+                    error(\"first transform\", e);\n+                }\n+            } catch (Exception e) {\n+                error(\"first lift\", e);\n+            }\n+        }\n+    }\n+    private static void printInColumns(CoreOps.FuncOp first, CoreOps.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n+\n+    private static CoreOps.FuncOp lift(MethodModel mm) {\n+        return BytecodeLift.lift(mm);\n+    }\n+\n+    private static CoreOps.FuncOp transform(CoreOps.FuncOp func) {\n+        return SSA.transform(func.transform((block, op) -> {\n+                    if (op instanceof Op.Lowerable lop) {\n+                        return lop.lower(block);\n+                    } else {\n+                        block.op(op);\n+                        return block;\n+                    }\n+                }));\n+    }\n+\n+    private static MethodModel lower(CoreOps.FuncOp func) {\n+        return CF.parse(BytecodeGenerator.generateClassData(\n+                MethodHandles.lookup(),\n+                func)).methods().get(0);\n+    }\n+\n+\n+    public static List<String> normalize(MethodModel mm) {\n+        record El(int index, String format, Label... targets) {\n+            public El(int index, Instruction i, Object format, Label... targets) {\n+                this(index, trim(i.opcode()) + \" \" + format, targets);\n+            }\n+            public String toString(Map<Label, Integer> targetsMap) {\n+                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n+            }\n+        }\n+\n+        Map<Label, Integer> targetsMap = new HashMap<>();\n+        List<El> elements = new ArrayList<>();\n+        Label lastLabel = null;\n+        int i = 0;\n+        for (var e : mm.code().orElseThrow()) {\n+            var er = switch (e) {\n+                case LabelTarget lt -> {\n+                    lastLabel = lt.label();\n+                    yield null;\n+                }\n+                case ExceptionCatch ec ->\n+                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n+                case BranchInstruction ins ->\n+                    new El(i++, ins, \"@%d\", ins.target());\n+                case ConstantInstruction ins ->\n+                    new El(i++, \"LDC \" + ins.constantValue());\n+                case FieldInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n+                case InvokeDynamicInstruction ins ->\n+                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n+                case InvokeInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n+                case LoadInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case StoreInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case IncrementInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n+                case LookupSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case NewMultiArrayInstruction ins ->\n+                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n+                case NewObjectInstruction ins ->\n+                    new El(i++, ins, ins.className().asInternalName());\n+                case NewPrimitiveArrayInstruction ins ->\n+                    new El(i++, ins, ins.typeKind());\n+                case NewReferenceArrayInstruction ins ->\n+                    new El(i++, ins, ins.componentType().asInternalName());\n+                case TableSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case TypeCheckInstruction ins ->\n+                    new El(i++, ins, ins.type().asInternalName());\n+                case Instruction ins ->\n+                    new El(i++, ins, \"\");\n+                default -> null;\n+            };\n+            if (er != null) {\n+                if (lastLabel != null) {\n+                    targetsMap.put(lastLabel, elements.size());\n+                    lastLabel = null;\n+                }\n+                elements.add(er);\n+            }\n+        }\n+        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n+    }\n+\n+    private static String trim(Opcode opcode) {\n+        var name = opcode.toString();\n+        int i = name.indexOf('_');\n+        return i > 2 ? name.substring(0, i) : name;\n+    }\n+\n+    private void error(String category, Exception e) {\n+        StringWriter sw = new StringWriter();\n+        e.printStackTrace(new PrintWriter(sw));\n+        errorStats.computeIfAbsent(category, _ -> new HashMap<>())\n+                  .compute(sw.toString(), (_, i) -> i == null ? 1 : i + 1);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestTry\n+ *\/\n+\n+public class TestTry {\n+\n+    @CodeReflection\n+    public static void catching(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatching() {\n+        CoreOps.FuncOp f = getFuncOp(\"catching\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTry::catching);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new NullPointerException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+    @CodeReflection\n+    public static void catchThrowable(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            consume(e);\n+            c.accept(1);\n+            c.accept(-1);\n+        } catch (Throwable e) {\n+            consume(e);\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrowable() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrowable\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTry::catchThrowable);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalStateException();\n+        });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchNested(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            try {\n+                c.accept(1);\n+                c.accept(-1);\n+            } catch (IllegalStateException e) {\n+                consume(e);\n+                c.accept(2);\n+                c.accept(-1);\n+            }\n+            c.accept(3);\n+            c.accept(-1);\n+        } catch (IllegalArgumentException e) {\n+            consume(e);\n+            c.accept(4);\n+            c.accept(-1);\n+        }\n+        c.accept(5);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchNested() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchNested\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTry::catchNested);\n+\n+        test.accept(i -> {\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 1) throw new IllegalStateException();\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new IllegalArgumentException();\n+            if (i == 4) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 5) throw new RuntimeException();\n+        });\n+    }\n+\n+\n+    static void consume(Throwable e) {\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+\n+    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n+        return c -> {\n+            try {\n+                mh.invoke(c);\n+            } catch (Throwable e) {\n+                throw erase(e);\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTry.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinally\n+ *\/\n+\n+public class TestTryFinally {\n+\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::tryCatchFinally\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+            return;\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testTryReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryReturn\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::tryReturn\n+                );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void catchThrow(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+            throw e;\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+        }\n+        c.accept(3);\n+        c.accept(-1);\n+    }\n+\n+    @Test\n+    public void testCatchThrow() {\n+        CoreOps.FuncOp f = getFuncOp(\"catchThrow\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::catchThrow\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    @CodeReflection\n+    public static void finallyReturn(IntConsumer c) {\n+        try {\n+            c.accept(0);\n+            c.accept(-1);\n+        } catch (IllegalStateException e) {\n+            c.accept(1);\n+            c.accept(-1);\n+        } finally {\n+            c.accept(2);\n+            c.accept(-1);\n+            return;\n+        }\n+    }\n+\n+    @Test\n+    public void finallyReturn() {\n+        CoreOps.FuncOp f = getFuncOp(\"finallyReturn\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinally::finallyReturn\n+        );\n+\n+        test(test);\n+    }\n+\n+\n+    static void test(Consumer<IntConsumer> test) {\n+        test.accept(i -> {});\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 2) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 0) throw new IllegalStateException();\n+            if (i == 1) throw new RuntimeException();\n+        });\n+        test.accept(i -> {\n+            if (i == 3) throw new RuntimeException();\n+        });\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+\n+    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n+        return c -> {\n+            try {\n+                mh.invoke(c);\n+            } catch (Throwable e) {\n+                throw erase(e);\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinally.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.bytecode.BytecodeGenerator;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.IntConsumer;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestTryFinallyNested\n+ *\/\n+\n+public class TestTryFinallyNested {\n+    @CodeReflection\n+    public static void tryCatchFinally(IntConsumer c, int i) {\n+        try {\n+            try {\n+                if (i == 0) {\n+                    return;\n+                }\n+                c.accept(0);\n+            } catch (IllegalStateException e) {\n+                if (i == 1) {\n+                    return;\n+                }\n+                c.accept(1);\n+            } finally {\n+                if (i == 2) {\n+                    return;\n+                }\n+                c.accept(2);\n+            }\n+            if (i == 3) {\n+                return;\n+            }\n+            c.accept(3);\n+        } catch (IllegalStateException e) {\n+            if (i == 4) {\n+                return;\n+            }\n+            c.accept(4);\n+        } finally {\n+            if (i == 5) {\n+                return;\n+            }\n+            c.accept(5);\n+        }\n+        c.accept(6);\n+    }\n+\n+    @Test\n+    public void testCatchFinally() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryCatchFinally\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        for (int ra = -1; ra < 6; ra++) {\n+            int fra = ra;\n+\n+            Consumer<IntConsumer> test = testConsumer(\n+                    c -> invoke(mh, c, fra),\n+                    c -> tryCatchFinally(c, fra)\n+            );\n+\n+            test.accept(i -> {});\n+            for (int ea = 0; ea < 6; ea++) {\n+                int fea = ea;\n+                test.accept(i -> {\n+                    if (i == fea) throw new IllegalStateException();\n+                });\n+                test.accept(i -> {\n+                    if (i == fea) throw new RuntimeException();\n+                });\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void tryForLoop(IntConsumer c) {\n+        for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            try {\n+                if (i == 4) {\n+                    continue;\n+                } else if (i == 5) {\n+                    break;\n+                }\n+                c.accept(1);\n+            } finally {\n+                c.accept(2);\n+            }\n+            c.accept(3);\n+        }\n+        c.accept(4);\n+    }\n+\n+    @Test\n+    public void testTryForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryForLoop\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinallyNested::tryForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    @CodeReflection\n+    public static void tryLabeledForLoop(IntConsumer c) {\n+        a: for (int i = 0; i < 8; i++) {\n+            c.accept(0);\n+            b: {\n+                try {\n+                    if (i == 4) {\n+                        continue a;\n+                    } else if (i == 5) {\n+                        break b;\n+                    } else if (i == 6) {\n+                        break a;\n+                    }\n+                    c.accept(1);\n+                } finally {\n+                    c.accept(2);\n+                }\n+                c.accept(3);\n+            }\n+            c.accept(4);\n+        }\n+        c.accept(5);\n+    }\n+\n+    @Test\n+    public void testTryLabeledForLoop() {\n+        CoreOps.FuncOp f = getFuncOp(\"tryLabeledForLoop\");\n+\n+        MethodHandle mh = generate(f);\n+\n+        Consumer<IntConsumer> test = testConsumer(\n+                asConsumer(mh),\n+                TestTryFinallyNested::tryLabeledForLoop\n+        );\n+\n+        test.accept(i -> { });\n+    }\n+\n+\n+    static Consumer<IntConsumer> testConsumer(Consumer<IntConsumer> actualR, Consumer<IntConsumer> expectedR) {\n+        return c -> {\n+            List<Integer> actual = new ArrayList<>();\n+            IntConsumer actualC = actual::add;\n+            Throwable actualT = null;\n+            try {\n+                actualR.accept(actualC.andThen(c));\n+            } catch (Interpreter.InterpreterException e) {\n+                throw e;\n+            } catch (Throwable t) {\n+                actualT = t;\n+                if (t instanceof AssertionError) {\n+                    t.printStackTrace();\n+                }\n+            }\n+\n+            List<Integer> expected = new ArrayList<>();\n+            IntConsumer expectedC = expected::add;\n+            Throwable expectedT = null;\n+            try {\n+                expectedR.accept(expectedC.andThen(c));\n+            } catch (Throwable t) {\n+                expectedT = t;\n+            }\n+\n+            Assert.assertEquals(\n+                    actualT != null ? actualT.getClass() : null,\n+                    expectedT != null ? expectedT.getClass() : null);\n+            Assert.assertEquals(actual, expected);\n+        };\n+    }\n+\n+    static MethodHandle generate(CoreOps.FuncOp f) {\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n+    }\n+\n+    static <T> Consumer<T> asConsumer(MethodHandle mh) {\n+        return c -> {\n+            try {\n+                mh.invoke(c);\n+            } catch (Throwable e) {\n+                throw erase(e);\n+            }\n+        };\n+    }\n+\n+    static void invoke(MethodHandle mh, IntConsumer c, int i) {\n+        try {\n+            mh.invoke(c, i);\n+        } catch (Throwable e) {\n+            throw erase(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> E erase(Throwable e) throws E {\n+        return (E) e;\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestTryFinallyNested.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.HashMap;\n+import java.util.function.BiConsumer;\n+\n+import static java.lang.reflect.code.op.CoreOps.sub;\n+import static java.lang.reflect.code.analysis.Patterns.*;\n+\n+public final class ExpressionElimination {\n+    private ExpressionElimination() {\n+    }\n+\n+    static OpPattern negP(Pattern operand) {\n+        return opP(CoreOps.NegOp.class, operand);\n+    }\n+\n+    static OpPattern addP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.AddOp.class, lhs, rhs);\n+    }\n+\n+    static OpPattern mulP(Pattern lhs, Pattern rhs) {\n+        return opP(CoreOps.MulOp.class, lhs, rhs);\n+    }\n+\n+    public static <T extends Op> T eliminate(T f) {\n+        \/\/ Note expression elimination and other forms of analysis is simplified if first of all expressions\n+        \/\/ are normalized e.g. when they have an operand that is a constant expression\n+        \/\/ and the operation is associative such as add(0, x) -> add(x, 0)\n+\n+        var actions = multiMatch(new HashMap<Op.Result, BiConsumer<Block.Builder, Op>>(), f)\n+                .pattern(mulP(_P(), valueP(constantP(0.0d))))\n+                .pattern(mulP(valueP(constantP(0.0d)), _P()))\n+                .pattern(addP(valueP(), constantP(0.0d)))\n+                .pattern(addP(constantP(0.0d), valueP()))\n+                .pattern(mulP(constantP(1.0d), valueP()))\n+                .pattern(mulP(valueP(), constantP(1.0d)))\n+                .target((ms, as) -> {\n+                    Value a = ms.matchedOperands().get(0);\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        cc.mapValue(ms.op().result(), cc.getValue(a));\n+                    });\n+                    return as;\n+                })\n+                \/\/ add(neg(x), y) -> sub(y, x)\n+                .pattern(addP(negP(valueP()), valueP()))\n+                .target((ms, as) -> {\n+                    Value x = ms.matchedOperands().get(0);\n+                    Value y = ms.matchedOperands().get(1);\n+\n+                    as.put(ms.op().result(), (block, op) -> {\n+                        CopyContext cc = block.context();\n+                        Op.Result r = block.op(sub(cc.getValue(y), cc.getValue(x)));\n+                        cc.mapValue(ms.op().result(), r);\n+                    });\n+                    return as;\n+                })\n+                .matchThenApply();\n+\n+        \/\/ Eliminate\n+        Op ef = f.transform(CopyContext.create(), (block, op) -> {\n+            BiConsumer<Block.Builder, Op> a = actions.get(op.result());\n+            if (a != null) {\n+                a.accept(block, op);\n+            } else {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+\n+        \/\/ Remove dead ops\n+        ef = ef.transform(CopyContext.create(), (block, op) -> {\n+            if (!(op instanceof Op.Pure) ||\n+                    !op.result().uses().isEmpty()) {\n+                block.op(op);\n+            }\n+            return block;\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T t = (T) ef;\n+        return t;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/ExpressionElimination.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+\n+\/*\n+ * @test\n+ * @run testng TestExpressionElimination\n+ *\/\n+\n+public class TestExpressionElimination {\n+\n+    @Test\n+    public void testAddZero() {\n+        CoreOps.ClosureOp lf = generate((double a) -> a + 0.0);\n+\n+        Assert.assertEquals((double) Interpreter.invoke(lf, 1.0d), 1.0d);\n+    }\n+\n+    @Test\n+    public void testF() {\n+        CoreOps.ClosureOp lf = generate((double a, double b) -> -a + b);\n+\n+        Assert.assertEquals((double) Interpreter.invoke(lf, 1.0d, 1.0d), 0.0d);\n+    }\n+\n+    static CoreOps.ClosureOp generate(Quoted q) {\n+        return generateF((CoreOps.ClosureOp) q.op());\n+    }\n+\n+    static <T extends Op & Op.Invokable> T generateF(T f) {\n+        f.writeTo(System.out);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T lf = (T) f.transform(CopyContext.create(), (block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        lf.writeTo(System.out);\n+\n+        lf = SSA.transform(lf);\n+        lf.writeTo(System.out);\n+\n+        lf = ExpressionElimination.eliminate(lf);\n+        lf.writeTo(System.out);\n+        return lf;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/expression\/TestExpressionElimination.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.lang.reflect.code.Op;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.runtime.CodeReflection;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -ea TestAssert\n+ *\/\n+public class TestAssert {\n+\n+    public static final String FAILURESTRING = \"failure\";\n+    public static final char FAILURECHAR = 'o';\n+\n+    public static final float FAILUREFLOAT = -1.0f;\n+    public static final double FAILUREDOUBLE = -1.0d;\n+    public static final byte FAILUREBYTE = -1;\n+    public static final short FAILURESHORT = -1;\n+    public static final int FAILUREINT = -1;\n+\n+    public static final long FAILURELONG = -1;\n+\n+    public static final String FAILUREOBJECTMSG = \"FAILURE OBJECT\";\n+\n+    public static final Object FAILUREOBJECT = new FailureObject();\n+\n+\n+    @Test\n+    public void testAssertThrows(){\n+        testThrows(\"assertThrow\");\n+    }\n+\n+    @Test\n+    public void testAssertString(){\n+        AssertionError ae = testThrows(\"assertThrowWithMessage\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(FAILURESTRING)) {\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertChar() {\n+        AssertionError ae = testThrows(\"assertChar\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILURECHAR))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertFloat() {\n+        AssertionError ae = testThrows(\"assertFloat\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREFLOAT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertDouble() {\n+        AssertionError ae = testThrows(\"assertDouble\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREDOUBLE))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertByte() {\n+        AssertionError ae = testThrows(\"assertByte\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREBYTE))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertShort() {\n+        AssertionError ae = testThrows(\"assertShort\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILURESHORT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertInt() {\n+        AssertionError ae = testThrows(\"assertInt\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREINT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertLong() {\n+        AssertionError ae = testThrows(\"assertLong\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILURELONG))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertObject() {\n+        AssertionError ae = testThrows(\"assertObject\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREOBJECT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertExpr1() {\n+        AssertionError ae = testThrows(\"assertExpr1\");\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREINT + FAILURELONG))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertExpr2() {\n+        AssertionError ae = testThrows(\"assertExpr2\", List.of(int.class), 52);\n+        if (ae.getMessage() == null || !ae.getMessage().equals(String.valueOf(FAILUREINT))){\n+            Assert.fail(\"Assertion failure messages do not match.\");\n+        }\n+    }\n+\n+    @Test\n+    public void testAssertExpr3() {\n+         testRun(\"assertExpr3\", List.of(int.class), 52);\n+    }\n+\n+    private static AssertionError testThrows(String methodName) {\n+        return testThrows(methodName, List.of());\n+    }\n+    private static void testRun(String methodName, List<Class<?>> params, Object...args) {\n+        try {\n+            Class<TestAssert> clazz = TestAssert.class;\n+            Method method = clazz.getDeclaredMethod(methodName,params.toArray(new Class[params.size()]));\n+            CoreOps.FuncOp f = method.getCodeModel().orElseThrow();\n+\n+            \/\/Ensure we're fully lowered before testing.\n+            final var fz = f.transform((b, o) -> {\n+                if (o instanceof Op.Lowerable l) {\n+                    b = l.lower(b);\n+                } else {\n+                    b.op(o);\n+                }\n+                return b;\n+            });\n+\n+            Interpreter.invoke(MethodHandles.lookup(), fz ,args);\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static AssertionError testThrows(String methodName, List<Class<?>> params, Object...args) {\n+        try {\n+            Class<TestAssert> clazz = TestAssert.class;\n+            Method method = clazz.getDeclaredMethod(methodName,params.toArray(new Class[params.size()]));\n+            CoreOps.FuncOp f = method.getCodeModel().orElseThrow();\n+\n+            \/\/Ensure we're fully lowered before testing.\n+            final var fz = f.transform((b, o) -> {\n+                if (o instanceof Op.Lowerable l) {\n+                    b = l.lower(b);\n+                } else {\n+                    b.op(o);\n+                }\n+                return b;\n+            });\n+\n+\n+            AssertionError ae = (AssertionError) retCatch(() -> Interpreter.invoke(MethodHandles.lookup(), fz ,args));\n+            Assert.assertNotNull(ae);\n+            return ae;\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static Throwable retCatch(Runnable r) {\n+        try {\n+            r.run();\n+        } catch (Throwable t) {\n+            return t;\n+        }\n+        return null;\n+    }\n+\n+\n+\n+    @CodeReflection\n+    public static void assertThrow() {\n+        assert false;\n+    }\n+\n+    @CodeReflection\n+    public static void assertThrowWithMessage() {\n+        assert false : FAILURESTRING;\n+    }\n+\n+    @CodeReflection\n+    public static void assertChar() {\n+        char c = FAILURECHAR;\n+        assert false : c;\n+    }\n+\n+    @CodeReflection\n+    public static void assertFloat() {\n+        float f = FAILUREFLOAT;\n+        assert false : f;\n+    }\n+\n+    @CodeReflection\n+    public static void assertDouble() {\n+        double d = FAILUREDOUBLE;\n+        assert false : d;\n+    }\n+\n+    @CodeReflection\n+    public static void assertByte() {\n+        byte b = FAILUREBYTE;\n+        assert false : b;\n+    }\n+\n+    @CodeReflection\n+    public static void assertShort() {\n+        short s = FAILURESHORT;\n+        assert false : s;\n+    }\n+\n+    @CodeReflection\n+    public static void assertInt() {\n+        int i = FAILUREINT;\n+        assert false : i;\n+    }\n+\n+    @CodeReflection\n+    public static void assertLong() {\n+        long l = FAILURELONG;\n+        assert false : l;\n+    }\n+\n+    @CodeReflection\n+    public static void assertObject() {\n+        Object o = FAILUREOBJECT;\n+        assert false : o;\n+    }\n+\n+    @CodeReflection\n+    public static void assertExpr1() {\n+        int i = FAILUREINT;\n+        long l = FAILURELONG;\n+        assert false : i + l;\n+        String y = \"test\";\n+    }\n+\n+    @CodeReflection\n+    public static void assertExpr2(int iz) {\n+        int i = FAILUREINT;\n+        long l = FAILURELONG;\n+        assert false : (i > iz) ? i + l : i;\n+        String s = \"\";\n+    }\n+\n+    @CodeReflection\n+    public static void assertExpr3(int iz) {\n+        int i = FAILUREINT;\n+        long l = FAILURELONG;\n+        assert true : (i > iz) ? i + l : i;\n+        String s = \"\";\n+    }\n+\n+    static class FailureObject {\n+        @Override\n+        public String toString(){\n+           return FAILUREOBJECTMSG;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestAssert.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.runtime.CodeReflection;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @run testng TestThrowing\n+ *\/\n+\n+public class TestThrowing {\n+\n+    @Test(dataProvider = \"methods-exceptions\")\n+    public void testThrowsCorrectException(String methodName, Class<? extends Throwable> expectedExceptionType) throws NoSuchMethodException {\n+        Method method = TestThrowing.class.getDeclaredMethod(methodName);\n+        Assert.assertThrows(expectedExceptionType, () -> Interpreter.invoke(MethodHandles.lookup(), method.getCodeModel().orElseThrow()));\n+    }\n+\n+    @DataProvider(name = \"methods-exceptions\")\n+    static Object[][] testData() throws NoSuchMethodException {\n+        return new Object[][]{\n+                {\"throwsError\", TestError.class},\n+                {\"throwsRuntimeException\", TestRuntimeException.class},\n+                {\"throwsCheckedException\", TestCheckedException.class},\n+        };\n+    }\n+\n+    public static class TestError extends Error {\n+\n+    }\n+\n+    public static class TestRuntimeException extends RuntimeException {\n+\n+    }\n+\n+    public static class TestCheckedException extends Exception {\n+\n+    }\n+\n+    @CodeReflection\n+    static void throwsError() {\n+        throw new TestError();\n+    }\n+\n+    @CodeReflection\n+    static void throwsRuntimeException() {\n+        throw new TestRuntimeException();\n+    }\n+\n+    @CodeReflection\n+    static void throwsCheckedException() throws TestCheckedException {\n+        throw new TestCheckedException();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/interpreter\/TestThrowing.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public abstract class QueryProvider {\n+    public abstract <T> Queryable<T> query(Class<T> elementType);\n+\n+    protected abstract Queryable<?> createQuery(JavaType elementType, CoreOps.FuncOp queryExpression);\n+\n+    protected abstract QueryResult<?> createQueryResult(JavaType resultType, CoreOps.FuncOp expression);\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryProvider.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.JavaType;\n+\n+public interface QueryResult<T> {\n+    JavaType TYPE = JavaType.type(QueryResult.class);\n+\n+    \/\/ T\n+    JavaType resultType();\n+\n+    \/\/ Queryable<T> -> QueryResult<T>\n+    CoreOps.FuncOp expression();\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QueryResult.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.type.MethodRef.method;\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public interface Queryable<T> {\n+    JavaType TYPE = type(Queryable.class);\n+\n+    QueryProvider provider();\n+\n+    \/\/ T\n+    JavaType elementType();\n+\n+    \/\/ Queryable<T> -> Queryable<U>\n+    FuncOp expression();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default Queryable<T> where(QuotablePredicate<T> f) {\n+        LambdaOp l = (LambdaOp) f.quoted().op();\n+        return (Queryable<T>) insertQuery(elementType(), \"where\", l);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default <R> Queryable<R> select(QuotableFunction<T, R> f) {\n+        LambdaOp l = (LambdaOp) f.quoted().op();\n+        return (Queryable<R>) insertQuery((JavaType) l.invokableType().returnType(), \"select\", l);\n+    }\n+\n+    private Queryable<?> insertQuery(JavaType elementType, String methodName, LambdaOp lambdaOp) {\n+        \/\/ Copy function expression, replacing return operation\n+        FuncOp queryExpression = expression();\n+        JavaType queryableType = type(Queryable.TYPE, elementType);\n+        FuncOp nextQueryExpression = func(\"query\",\n+                functionType(queryableType, queryExpression.invokableType().parameterTypes()))\n+                .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                    Op.Result fi = block.op(lambdaOp);\n+\n+                    MethodRef md = method(Queryable.TYPE, methodName,\n+                            functionType(Queryable.TYPE, ((ClassType) lambdaOp.functionalInterface()).rawType()));\n+                    Op.Result queryable = block.op(invoke(queryableType, md, query, fi));\n+\n+                    block.op(_return(queryable));\n+                }));\n+\n+        return provider().createQuery(elementType, nextQueryExpression);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default QueryResult<Stream<T>> elements() {\n+        JavaType resultType = type(type(Stream.class), elementType());\n+        return (QueryResult<Stream<T>>) insertQueryResult(resultType, \"elements\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default QueryResult<Long> count() {\n+        JavaType resultType = JavaType.LONG;\n+        return (QueryResult<Long>) insertQueryResult(resultType, \"count\");\n+    }\n+\n+    private QueryResult<?> insertQueryResult(JavaType resultType, String methodName) {\n+        \/\/ Copy function expression, replacing return operation\n+        FuncOp queryExpression = expression();\n+        JavaType queryResultType = JavaType.type(QueryResult.TYPE, resultType);\n+        FuncOp queryResultExpression = func(\"queryResult\",\n+                functionType(queryResultType, queryExpression.invokableType().parameterTypes()))\n+                .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                    MethodRef md = method(Queryable.TYPE, methodName,\n+                            functionType(QueryResult.TYPE));\n+                    Op.Result queryResult = block.op(invoke(queryResultType, md, query));\n+\n+                    block.op(_return(queryResult));\n+                }));\n+\n+        return provider().createQueryResult(resultType, queryResultExpression);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.util.function.Function;\n+\n+@FunctionalInterface\n+public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotableFunction.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.util.function.Predicate;\n+\n+@FunctionalInterface\n+public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/QuotablePredicate.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLinq\n+ *\/\n+\n+public class TestLinq {\n+\n+    \/\/ A record modeling a table with three columns, one for each component\n+    record Customer(String contactName, String phone, String city) {\n+    }\n+\n+    @Test\n+    public void testSimpleQuery() {\n+        QueryProvider qp = new TestQueryProvider();\n+\n+        \/\/ Query all customers based in London, and return their names\n+        QueryResult<Stream<String>> qr = qp.query(Customer.class)\n+                .where(c -> c.city.equals(\"London\"))\n+                .select(c -> c.contactName)\n+                .elements();\n+\n+        System.out.println(qr.expression().toText());\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QueryResult<Stream<String>> qr2 = (QueryResult<Stream<String>>) Interpreter.invoke(MethodHandles.lookup(),\n+                qr.expression(), qp.query(Customer.class));\n+        System.out.println(qr2.expression().toText());\n+\n+        Assert.assertEquals(qr.expression().toText(), qr2.expression().toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestLinq.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.JavaType;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public final class TestQueryProvider extends QueryProvider {\n+    public TestQueryProvider() {\n+    }\n+\n+    @Override\n+    public <T> Queryable<T> query(Class<T> elementType) {\n+        return new TestQueryable<>(elementType, this);\n+    }\n+\n+    @Override\n+    protected Queryable<?> createQuery(JavaType elementType, CoreOps.FuncOp expression) {\n+        return new TestQueryable<>(elementType, this, expression);\n+    }\n+\n+    @Override\n+    protected QueryResult<?> createQueryResult(JavaType resultType, CoreOps.FuncOp expression) {\n+        return new TestQueryResult<>(resultType, expression);\n+    }\n+\n+    static final class TestQueryable<T> implements Queryable<T> {\n+        final JavaType elementType;\n+        final TestQueryProvider provider;\n+        final CoreOps.FuncOp expression;\n+\n+        TestQueryable(Class<T> tableClass, TestQueryProvider qp) {\n+            this.elementType = type(tableClass);\n+            this.provider = qp;\n+\n+            JavaType queryableType = type(Queryable.TYPE, elementType);\n+            \/\/ Initial expression is an identity function\n+            var funType = functionType(queryableType, queryableType);\n+            this.expression = func(\"query\", funType)\n+                    .body(b -> b.op(_return(b.parameters().get(0))));\n+        }\n+\n+        TestQueryable(JavaType elementType, TestQueryProvider provider, CoreOps.FuncOp expression) {\n+            this.elementType = elementType;\n+            this.provider = provider;\n+            this.expression = expression;\n+        }\n+\n+        @Override\n+        public QueryProvider provider() {\n+            return provider;\n+        }\n+\n+        @Override\n+        public JavaType elementType() {\n+            return elementType;\n+        }\n+\n+        @Override\n+        public CoreOps.FuncOp expression() {\n+            return expression;\n+        }\n+    }\n+\n+    record TestQueryResult<T>(JavaType resultType, CoreOps.FuncOp expression) implements QueryResult<T> {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class ClassWithReflectedMethod {\n+    @CodeReflection       \/\/ 27\n+    static String f() {   \/\/ 28\n+        String a = \"29\";  \/\/ 29\n+        String b = \"30\";  \/\/ 30\n+        m(\"31\");       \/\/ 31\n+        return \"32\";      \/\/ 32\n+    }                     \/\/ 33\n+\n+    static void m(String s) {}\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/ClassWithReflectedMethod.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestLocation\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Location;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestLocation {\n+    @Test\n+    public void testLocation() {\n+        CoreOps.FuncOp f = getFuncOp(ClassWithReflectedMethod.class, \"f\");\n+        f.traverse(null, (o, ce) -> {\n+            if (ce instanceof CoreOps.ConstantOp cop) {\n+                Location loc = cop.location();\n+                Assert.assertNotNull(loc);\n+\n+                int actualLine = loc.line();\n+                int expectedLine = Integer.parseInt((String) cop.value());\n+                Assert.assertEquals(actualLine, expectedLine);\n+            }\n+            return null;\n+        });\n+    }\n+\n+    @CodeReflection\n+    static int f(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum++;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void dropLocationTransform() {\n+        CoreOps.FuncOp f = getFuncOp(TestLocation.class, \"f\");\n+\n+        CoreOps.FuncOp tf = f.transform(OpTransformer.DROP_LOCATION_TRANSFORMER);\n+        tf.setLocation(Location.NO_LOCATION);\n+        testNoLocations(tf);\n+\n+        CoreOps.FuncOp tlf = lower(f).transform(OpTransformer.DROP_LOCATION_TRANSFORMER);\n+        tlf.setLocation(Location.NO_LOCATION);\n+        testNoLocations(tlf);\n+    }\n+\n+    @Test\n+    public void dropLocationWriter() {\n+        CoreOps.FuncOp f = getFuncOp(TestLocation.class, \"f\");\n+\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, f, OpWriter.LocationOption.DROP_LOCATION);\n+        String tfText = w.toString();\n+        CoreOps.FuncOp tf = (CoreOps.FuncOp) OpParser.fromString(ExtendedOps.FACTORY, tfText).getFirst();\n+        testNoLocations(tf);\n+    }\n+\n+    static CoreOps.FuncOp lower(CoreOps.FuncOp f) {\n+        return f.transform((b, op) -> {\n+            if (op instanceof Op.Lowerable l) {\n+                return l.lower(b);\n+            } else {\n+                b.op(op);\n+                return b;\n+            }\n+        });\n+    }\n+\n+    static void testNoLocations(Op op) {\n+        boolean noLocations = op.elements().filter(ce -> ce instanceof Op)\n+                .allMatch(ce -> ((Op) ce).location() == Location.NO_LOCATION);\n+        Assert.assertTrue(noLocations);\n+    }\n+\n+\n+    static CoreOps.FuncOp getFuncOp(Class<?> c, String name) {\n+        Optional<Method> om = Stream.of(c.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/location\/TestLocation.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.StringWriter;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+\n+public class CodeReflectionTester {\n+\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: CodeReflectionTester <classname>\");\n+            System.exit(1);\n+        }\n+        Class<?> clazz = Class.forName(args[0]);\n+        for (Method m : clazz.getDeclaredMethods()) {\n+            check(m);\n+        }\n+    }\n+\n+    static void check(Method method) throws ReflectiveOperationException {\n+        if (!method.isAnnotationPresent(CodeReflection.class)) {\n+            return;\n+        }\n+\n+        LoweredModel lma = method.getAnnotation(LoweredModel.class);\n+        if (lma == null) {\n+            throw new AssertionError(\"No @IR annotation found on reflective method\");\n+        }\n+\n+        CoreOps.FuncOp f = method.getCodeModel().orElseThrow(() ->\n+                new AssertionError(\"No code model for reflective method\"));\n+        f = lower(f, lma.ssa());\n+\n+        String actual = canonicalizeModel(method, f);\n+        String expected = canonicalizeModel(method, lma.value());\n+        if (!actual.equals(expected)) {\n+            throw new AssertionError(String.format(\"Bad code model\\nFound:\\n%s\\n\\nExpected:\\n%s\", actual, expected));\n+        }\n+    }\n+\n+    static CoreOps.FuncOp lower(CoreOps.FuncOp f, boolean ssa) {\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        f.writeTo(System.out);\n+\n+        if (ssa) {\n+            f = SSA.transform(f);\n+            f.writeTo(System.out);\n+        }\n+\n+        return f;\n+    }\n+\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, Op o) {\n+        return canonicalizeModel(m, serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, String d) {\n+        Op o;\n+        try {\n+            o = OpParser.fromString(ExtendedOps.FACTORY, d).get(0);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(m.toString(), e);\n+        }\n+        return serialize(o);\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/CodeReflectionTester.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.*;\n+\n+@Target({ElementType.METHOD, ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface LoweredModel {\n+    String value();\n+    boolean ssa() default false;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/LoweredModel.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary test lowering of loops\n+ * @build TestLoop\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester TestLoop\n+ *\/\n+\n+public class TestLoop {\n+    @CodeReflection\n+    @LoweredModel(value = \"\"\"\n+            func @\"testFor\" (%0 : int[])int -> {\n+                %1 : Var<int[]> = var %0 @\"a\";\n+                %2 : int = constant @\"0\";\n+                %3 : Var<int> = var %2 @\"sum\";\n+                %4 : int = constant @\"0\";\n+                %5 : Var<int> = var %4 @\"i\";\n+                branch ^block_0;\n+\n+              ^block_0:\n+                %6 : int = var.load %5;\n+                %7 : int[] = var.load %1;\n+                %8 : int = array.length %7;\n+                %9 : boolean = lt %6 %8;\n+                cbranch %9 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %10 : int = var.load %3;\n+                %11 : int[] = var.load %1;\n+                %12 : int = var.load %5;\n+                %13 : int = array.load %11 %12;\n+                %14 : int = add %10 %13;\n+                var.store %3 %14;\n+                branch ^block_3;\n+\n+              ^block_3:\n+                %15 : int = var.load %5;\n+                %16 : int = constant @\"1\";\n+                %17 : int = add %15 %16;\n+                var.store %5 %17;\n+                branch ^block_0;\n+\n+              ^block_2:\n+                %18 : int = var.load %3;\n+                return %18;\n+            };\n+            \"\"\", ssa = false)\n+    static int testFor(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+\n+    @CodeReflection\n+    @LoweredModel(value = \"\"\"\n+            func @\"testForSSA\" (%0 : int[])int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : int = constant @\"0\";\n+                branch ^block_0(%1, %2);\n+\n+              ^block_0(%3 : int, %4 : int):\n+                %5 : int = array.length %0;\n+                %6 : boolean = lt %4 %5;\n+                cbranch %6 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %7 : int = array.load %0 %4;\n+                %8 : int = add %3 %7;\n+                branch ^block_3;\n+\n+              ^block_3:\n+                %9 : int = constant @\"1\";\n+                %10 : int = add %4 %9;\n+                branch ^block_0(%8, %10);\n+\n+              ^block_2:\n+                return %3;\n+            };\n+            \"\"\", ssa = true)\n+    static int testForSSA(int[] a) {\n+        int sum = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            sum += a[i];\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/lower\/TestLoop.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/java.lang.reflect.code.parser\n+ * @run testng TestParse\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Block;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.util.List;\n+import java.util.function.IntUnaryOperator;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.add;\n+import static java.lang.reflect.code.op.CoreOps.constant;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.op.CoreOps.lambda;\n+import static java.lang.reflect.code.type.FunctionType.functionType;\n+import static java.lang.reflect.code.type.JavaType.INT;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public class TestParse {\n+\n+    static final MethodRef INT_UNARY_OPERATOR_METHOD = MethodRef.method(\n+            IntUnaryOperator.class, \"applyAsInt\",\n+            int.class, int.class);\n+\n+    @Test\n+    public void testParseLambdaOp() {\n+        \/\/ functional type = (int)int\n+        CoreOps.FuncOp f = func(\"f\", functionType(INT, INT))\n+                .body(block -> {\n+                    Block.Parameter i = block.parameters().get(0);\n+\n+                    \/\/ functional type = (int)int\n+                    \/\/ op type = ()IntUnaryOperator\n+                    \/\/   captures i\n+                    CoreOps.LambdaOp lambda = lambda(block.parentBody(),\n+                            functionType(INT, INT), type(IntUnaryOperator.class))\n+                            .body(lbody -> {\n+                                Block.Builder lblock = lbody.entryBlock();\n+                                Block.Parameter li = lblock.parameters().get(0);\n+\n+                                lblock.op(_return(\n+                                        lblock.op(add(i, li))));\n+                            });\n+\n+                    Op.Result fi = block.op(lambda);\n+                    Op.Result fortyTwo = block.op(constant(INT, 42));\n+                    Op.Result or = block.op(CoreOps.invoke(INT_UNARY_OPERATOR_METHOD, fi, fortyTwo));\n+                    block.op(_return(or));\n+                });\n+\n+        List<Op> ops = OpParser.fromString(CoreOps.FACTORY, f.toText());\n+        assertTextEquals(f, ops.get(0));\n+    }\n+\n+\n+    static final String NAMED_BODY = \"\"\"\n+            func @\"test\" ^body1(%0 : int, %1 : int)int -> {\n+                %2 : int = constant @\"5\";\n+                %3 : int = constant @\"2\";\n+                branch ^b1(%2, %3);\n+\n+              ^b1(%0 : int, %1 : int):\n+                return %0;\n+            };\n+            \"\"\";\n+    @Test\n+    void testParseNamedBody() {\n+        Op opE = OpParser.fromString(CoreOps.FACTORY, NAMED_BODY).get(0);\n+        Op opA = OpParser.fromString(CoreOps.FACTORY, opE.toText()).get(0);\n+        assertTextEquals(opA, opE);\n+    }\n+\n+\n+    static final String ESCAPED_STRING = \"\"\"\n+            func @\"test\" ()String -> {\n+                %0 : java.lang.String = constant @\"\\\\b \\\\f \\\\n \\\\r \\\\t \\\\' \\\\\" \\\\\\\\\";\n+                return %0;\n+            };\n+            \"\"\";\n+    @Test\n+    void testEscapedString() {\n+        Op opE = OpParser.fromString(CoreOps.FACTORY, ESCAPED_STRING).get(0);\n+        Op opA = OpParser.fromString(CoreOps.FACTORY, opE.toText()).get(0);\n+        assertTextEquals(opA, opE);\n+\n+        CoreOps.ConstantOp cop = (CoreOps.ConstantOp) opE.bodies().get(0).entryBlock().firstOp();\n+        String v = (String) cop.value();\n+        Assert.assertEquals(v, \"\\b \\f \\n \\r \\t \\' \\\" \\\\\");\n+    }\n+\n+    static void assertTextEquals(Op a, Op b) {\n+        Assert.assertEquals(a.toText(), b.toText());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestParse.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.parser.impl.Scanner;\n+import java.lang.reflect.code.parser.impl.Tokens;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.reflect.code.parser.impl.Tokens.TokenKind.*;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/java.lang.reflect.code.parser.impl\n+ * @run testng TestScanner\n+ *\/\n+\n+public class TestScanner {\n+\n+    @DataProvider\n+    Object[][] data() {\n+        return new Object[][] {\n+                {\"java.lang.Integer\", List.of(IDENTIFIER, DOT, IDENTIFIER, DOT, IDENTIFIER)},\n+                {\"java.lang.Integer\", List.of(\"java\", DOT, \"lang\", DOT, \"Integer\")},\n+                {\"a<a<a, a>,a<a, a>>\", List.of(\"a\", LT,\n+                        \"a\", LT, \"a\", COMMA, \"a\", GT,\n+                        COMMA,\n+                        \"a\", LT, \"a\", COMMA, \"a\", GT,\n+                        GT)},\n+                {\"_->(){}[],.=><?:;+-&^@\", List.of(\n+                        UNDERSCORE,\n+                        ARROW,\n+                        LPAREN,\n+                        RPAREN,\n+                        LBRACE,\n+                        RBRACE,\n+                        LBRACKET,\n+                        RBRACKET,\n+                        COMMA,\n+                        DOT,\n+                        EQ,\n+                        GT,\n+                        LT,\n+                        QUES,\n+                        COLON,\n+                        SEMI,\n+                        PLUS,\n+                        SUB,\n+                        AMP,\n+                        CARET,\n+                        MONKEYS_AT\n+                        )},\n+                {\"%1 %a %_1\", List.of(VALUE_IDENTIFIER, VALUE_IDENTIFIER, VALUE_IDENTIFIER)},\n+                {\"%1 %a %_1\", List.of(\"%1\", \"%a\", \"%_1\")},\n+                {\"\\\"abc\\\\n\\\"\", List.of(STRINGLITERAL)},\n+                {\"\\\"abc \\\\b \\\\f \\\\n \\\\r \\\\t \\\\' \\\\\\\" \\\\\\\\\\\"\", List.of(\"abc \\b \\f \\n \\r \\t \\' \\\" \\\\\")},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"data\")\n+    public void test(String content, List<Object> expectedTokens) {\n+        Scanner.Factory factory = Scanner.factory();\n+\n+        Scanner s = factory.newScanner(content);\n+        s.nextToken();\n+        List<Tokens.Token> actualTokens = new ArrayList<>();\n+        while (s.token().kind != EOF) {\n+            actualTokens.add(s.token());\n+            s.nextToken();\n+        }\n+\n+        Assert.assertEquals(actualTokens.size(), expectedTokens.size());\n+        for (int i = 0; i < expectedTokens.size(); i++) {\n+            Object e = expectedTokens.get(i);\n+            Tokens.Token a = actualTokens.get(i);\n+            if (e instanceof Tokens.TokenKind t) {\n+                Assert.assertEquals(a.kind, t);\n+            } else if (e instanceof String v) {\n+                String as = switch (a.kind.tag) {\n+                    case NAMED -> a.name();\n+                    case STRING, NUMERIC -> a.stringVal();\n+                    case DEFAULT -> a.kind.name;\n+                };\n+                Assert.assertEquals(as, v);\n+            } else {\n+                assert false;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/parser\/TestScanner.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps.JavaEnhancedForOp;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.op.ExtendedOps._continue;\n+import static java.lang.reflect.code.op.ExtendedOps.enhancedFor;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public final class StreamFuser {\n+\n+    StreamFuser() {}\n+\n+    public static StreamExprBuilder fromList(JavaType elementType) {\n+        \/\/ java.util.List<E>\n+        JavaType listType = type(type(List.class), elementType);\n+        return new StreamExprBuilder(listType, elementType,\n+                (b, v) -> StreamExprBuilder.enhancedForLoop(b, elementType, v)::body);\n+    }\n+\n+    public static class StreamExprBuilder {\n+        static class StreamOp {\n+            final Quoted quotedClosure;\n+\n+            StreamOp(Quoted quotedClosure) {\n+                if (!(quotedClosure.op() instanceof CoreOps.ClosureOp)) {\n+                    throw new IllegalArgumentException(\"Quoted operation is not closure operation\");\n+                }\n+                this.quotedClosure = quotedClosure;\n+            }\n+\n+            CoreOps.ClosureOp op() {\n+                return (CoreOps.ClosureOp) quotedClosure.op();\n+            }\n+        }\n+\n+        static class MapStreamOp extends StreamOp {\n+            public MapStreamOp(Quoted quotedClosure) {\n+                super(quotedClosure);\n+                \/\/ @@@ Check closure signature\n+            }\n+        }\n+\n+        static class FlatMapStreamOp extends StreamOp {\n+            public FlatMapStreamOp(Quoted quotedClosure) {\n+                super(quotedClosure);\n+                \/\/ @@@ Check closure signature\n+            }\n+        }\n+\n+        static class FilterStreamOp extends StreamOp {\n+            public FilterStreamOp(Quoted quotedClosure) {\n+                super(quotedClosure);\n+                \/\/ @@@ Check closure signature\n+            }\n+        }\n+\n+        final JavaType sourceType;\n+        final JavaType sourceElementType;\n+        final BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier;\n+        final List<StreamOp> streamOps;\n+\n+        StreamExprBuilder(JavaType sourceType, JavaType sourceElementType,\n+                          BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier) {\n+            this.sourceType = sourceType;\n+            this.sourceElementType = sourceElementType;\n+            this.loopSupplier = loopSupplier;\n+            this.streamOps = new ArrayList<>();\n+        }\n+\n+        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, JavaType elementType,\n+                                                             Value iterable) {\n+            return enhancedFor(ancestorBody, iterable.type(), elementType)\n+                    .expression(b -> {\n+                        b.op(_yield(iterable));\n+                    })\n+                    .definition(b -> {\n+                        b.op(_yield(b.parameters().get(0)));\n+                    });\n+        }\n+\n+        public StreamExprBuilder map(Quoted f) {\n+            streamOps.add(new MapStreamOp(f));\n+            return this;\n+        }\n+\n+        public StreamExprBuilder flatMap(Quoted f) {\n+            streamOps.add(new FlatMapStreamOp(f));\n+            return this;\n+        }\n+\n+        public StreamExprBuilder filter(Quoted f) {\n+            streamOps.add(new FilterStreamOp(f));\n+            return this;\n+        }\n+\n+        void fuseIntermediateOperations(Block.Builder body, BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            fuseIntermediateOperation(0, body, body.parameters().get(0), null, terminalConsumer);\n+        }\n+\n+        void fuseIntermediateOperation(int i, Block.Builder body, Value element, Block.Builder continueBlock,\n+                                       BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            if (i == streamOps.size()) {\n+                terminalConsumer.accept(body, element);\n+                return;\n+            }\n+\n+            StreamOp sop = streamOps.get(i);\n+            if (sop instanceof MapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, value) -> {\n+                    fuseIntermediateOperation(i + 1, block, value, continueBlock, terminalConsumer);\n+                });\n+            } else if (sop instanceof FilterStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, p) -> {\n+                    Block.Builder _if = block.block();\n+                    Block.Builder _else = continueBlock;\n+                    if (continueBlock == null) {\n+                        _else = block.block();\n+                        _else.op(_continue());\n+                    }\n+\n+                    block.op(conditionalBranch(p, _if.successor(), _else.successor()));\n+\n+                    fuseIntermediateOperation(i + 1, _if, element, _else, terminalConsumer);\n+                });\n+            } else if (sop instanceof FlatMapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, iterable) -> {\n+                    JavaEnhancedForOp forOp = enhancedFor(block.parentBody(),\n+                            iterable.type(), ((ClassType) iterable.type()).typeArguments().get(0))\n+                            .expression(b -> {\n+                                b.op(_yield(iterable));\n+                            })\n+                            .definition(b -> {\n+                                b.op(_yield(b.parameters().get(0)));\n+                            })\n+                            .body(b -> {\n+                                fuseIntermediateOperation(i + 1,\n+                                        b,\n+                                        b.parameters().get(0),\n+                                        null, terminalConsumer);\n+                            });\n+\n+                    block.op(forOp);\n+                    block.op(_continue());\n+                });\n+            }\n+        }\n+\n+        public FuncOp forEach(Quoted quotedConsumer) {\n+            if (!(quotedConsumer.op() instanceof CoreOps.ClosureOp consumer)) {\n+                throw new IllegalArgumentException(\"Quoted consumer is not closure operation\");\n+            }\n+\n+            return func(\"fused.forEach\", FunctionType.functionType(JavaType.VOID, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        Op sourceLoop = loopSupplier.apply(b.parentBody(), source)\n+                                .apply(loopBlock -> {\n+                                    fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                        terminalBlock.inline(consumer, List.of(resultValue),\n+                                                (_, _) -> {\n+                                                });\n+                                        terminalBlock.op(_continue());\n+                                    });\n+\n+                                });\n+                        b.op(sourceLoop);\n+                        b.op(_return());\n+                    });\n+        }\n+\n+        \/\/ Supplier<C> supplier, BiConsumer<C, T> accumulator\n+        public FuncOp collect(Quoted quotedSupplier, Quoted quotedAccumulator) {\n+            if (!(quotedSupplier.op() instanceof CoreOps.ClosureOp supplier)) {\n+                throw new IllegalArgumentException(\"Quoted supplier is not closure operation\");\n+            }\n+            if (!(quotedAccumulator.op() instanceof CoreOps.ClosureOp accumulator)) {\n+                throw new IllegalArgumentException(\"Quoted accumulator is not closure operation\");\n+            }\n+\n+            JavaType collectType = (JavaType) supplier.invokableType().returnType();\n+            return func(\"fused.collect\", FunctionType.functionType(collectType, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        b.inline(supplier, List.of(), (block, collect) -> {\n+                            Op sourceLoop = loopSupplier.apply(block.parentBody(), source)\n+                                    .apply(loopBlock -> {\n+                                        fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                            terminalBlock.inline(accumulator, List.of(collect, resultValue),\n+                                                    (_, _) -> {\n+                                                    });\n+                                            terminalBlock.op(_continue());\n+                                        });\n+                                    });\n+                            block.op(sourceLoop);\n+                            block.op(_return(collect));\n+                        });\n+                    });\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.ExtendedOps.JavaEnhancedForOp;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.*;\n+\n+import static java.lang.reflect.code.op.CoreOps.*;\n+import static java.lang.reflect.code.op.ExtendedOps._continue;\n+import static java.lang.reflect.code.op.ExtendedOps.enhancedFor;\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public final class StreamFuserUsingQuotable {\n+\n+    \/\/ Quotable functional interfaces\n+\n+    public interface QuotablePredicate<T> extends Quotable, Predicate<T> {\n+    }\n+\n+    public interface QuotableFunction<T, R> extends Quotable, Function<T, R> {\n+    }\n+\n+    public interface QuotableSupplier<T> extends Quotable, Supplier<T> {\n+    }\n+\n+    public interface QuotableConsumer<T> extends Quotable, Consumer<T> {\n+    }\n+\n+    public interface QuotableBiConsumer<T, U> extends Quotable, BiConsumer<T, U> {\n+    }\n+\n+\n+    StreamFuserUsingQuotable() {}\n+\n+    public static <T> StreamExprBuilder<T> fromList(Class<T> elementClass) {\n+        JavaType elementType = type(elementClass);\n+        \/\/ java.util.List<E>\n+        JavaType listType = type(type(List.class), elementType);\n+        return new StreamExprBuilder<>(listType, elementType,\n+                (b, v) -> StreamExprBuilder.enhancedForLoop(b, elementType, v)::body);\n+    }\n+\n+    public static class StreamExprBuilder<T> {\n+        static class StreamOp {\n+            final LambdaOp lambdaOp;\n+\n+            StreamOp(Quotable quotedLambda) {\n+                if (!(quotedLambda.quoted().op() instanceof LambdaOp lambdaOp)) {\n+                    throw new IllegalArgumentException(\"Quotable operation is not lambda operation\");\n+                }\n+                if (!(quotedLambda.quoted().capturedValues().isEmpty())) {\n+                    throw new IllegalArgumentException(\"Quotable operation captures values\");\n+                }\n+                this.lambdaOp = lambdaOp;\n+            }\n+\n+            LambdaOp op() {\n+                return lambdaOp;\n+            }\n+        }\n+\n+        static class MapStreamOp extends StreamOp {\n+            public MapStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n+            }\n+        }\n+\n+        static class FlatMapStreamOp extends StreamOp {\n+            public FlatMapStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n+            }\n+        }\n+\n+        static class FilterStreamOp extends StreamOp {\n+            public FilterStreamOp(Quotable quotedLambda) {\n+                super(quotedLambda);\n+            }\n+        }\n+\n+        final JavaType sourceType;\n+        final JavaType sourceElementType;\n+        final BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier;\n+        final List<StreamOp> streamOps;\n+\n+        StreamExprBuilder(JavaType sourceType, JavaType sourceElementType,\n+                          BiFunction<Body.Builder, Value, Function<Consumer<Block.Builder>, Op>> loopSupplier) {\n+            this.sourceType = sourceType;\n+            this.sourceElementType = sourceElementType;\n+            this.loopSupplier = loopSupplier;\n+            this.streamOps = new ArrayList<>();\n+        }\n+\n+        static JavaEnhancedForOp.BodyBuilder enhancedForLoop(Body.Builder ancestorBody, JavaType elementType,\n+                                                             Value iterable) {\n+            return enhancedFor(ancestorBody, iterable.type(), elementType)\n+                    .expression(b -> {\n+                        b.op(_yield(iterable));\n+                    })\n+                    .definition(b -> {\n+                        b.op(_yield(b.parameters().get(0)));\n+                    });\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <R> StreamExprBuilder<R> map(QuotableFunction<T, R> f) {\n+            streamOps.add(new MapStreamOp(f));\n+            return (StreamExprBuilder<R>) this;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public <R> StreamExprBuilder<R> flatMap(QuotableFunction<T, Iterable<R>> f) {\n+            streamOps.add(new FlatMapStreamOp(f));\n+            return (StreamExprBuilder<R>) this;\n+        }\n+\n+        public StreamExprBuilder<T> filter(QuotablePredicate<T> f) {\n+            streamOps.add(new FilterStreamOp(f));\n+            return this;\n+        }\n+\n+        void fuseIntermediateOperations(Block.Builder body, BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            fuseIntermediateOperation(0, body, body.parameters().get(0), null, terminalConsumer);\n+        }\n+\n+        void fuseIntermediateOperation(int i, Block.Builder body, Value element, Block.Builder continueBlock,\n+                                       BiConsumer<Block.Builder, Value> terminalConsumer) {\n+            if (i == streamOps.size()) {\n+                terminalConsumer.accept(body, element);\n+                return;\n+            }\n+\n+            StreamOp sop = streamOps.get(i);\n+            if (sop instanceof MapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, value) -> {\n+                    fuseIntermediateOperation(i + 1, block, value, continueBlock, terminalConsumer);\n+                });\n+            } else if (sop instanceof FilterStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, p) -> {\n+                    Block.Builder _if = block.block();\n+                    Block.Builder _else = continueBlock;\n+                    if (continueBlock == null) {\n+                        _else = block.block();\n+                        _else.op(_continue());\n+                    }\n+\n+                    block.op(conditionalBranch(p, _if.successor(), _else.successor()));\n+\n+                    fuseIntermediateOperation(i + 1, _if, element, _else, terminalConsumer);\n+                });\n+            } else if (sop instanceof FlatMapStreamOp) {\n+                body.inline(sop.op(), List.of(element), (block, iterable) -> {\n+                    JavaEnhancedForOp forOp = enhancedFor(block.parentBody(),\n+                            iterable.type(), ((ClassType) iterable.type()).typeArguments().get(0))\n+                            .expression(b -> {\n+                                b.op(_yield(iterable));\n+                            })\n+                            .definition(b -> {\n+                                b.op(_yield(b.parameters().get(0)));\n+                            })\n+                            .body(b -> {\n+                                fuseIntermediateOperation(i + 1,\n+                                        b,\n+                                        b.parameters().get(0),\n+                                        null, terminalConsumer);\n+                            });\n+\n+                    block.op(forOp);\n+                    block.op(_continue());\n+                });\n+            }\n+        }\n+\n+        public FuncOp forEach(QuotableConsumer<T> quotableConsumer) {\n+            if (!(quotableConsumer.quoted().op() instanceof LambdaOp consumer)) {\n+                throw new IllegalArgumentException(\"Quotable consumer is not lambda operation\");\n+            }\n+            if (!(quotableConsumer.quoted().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable consumer captures values\");\n+            }\n+\n+            return func(\"fused.forEach\", FunctionType.functionType(JavaType.VOID, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        Op sourceLoop = loopSupplier.apply(b.parentBody(), source)\n+                                .apply(loopBlock -> {\n+                                    fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                        terminalBlock.inline(consumer, List.of(resultValue),\n+                                                (_, _) -> {\n+                                                });\n+                                        terminalBlock.op(_continue());\n+                                    });\n+\n+                                });\n+                        b.op(sourceLoop);\n+                        b.op(_return());\n+                    });\n+        }\n+\n+        public <C> FuncOp collect(QuotableSupplier<C> quotableSupplier, QuotableBiConsumer<C, T> quotableAccumulator) {\n+            if (!(quotableSupplier.quoted().op() instanceof LambdaOp supplier)) {\n+                throw new IllegalArgumentException(\"Quotable supplier is not lambda operation\");\n+            }\n+            if (!(quotableSupplier.quoted().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable supplier captures values\");\n+            }\n+            if (!(quotableAccumulator.quoted().op() instanceof LambdaOp accumulator)) {\n+                throw new IllegalArgumentException(\"Quotable accumulator is not lambda operation\");\n+            }\n+            if (!(quotableAccumulator.quoted().capturedValues().isEmpty())) {\n+                throw new IllegalArgumentException(\"Quotable accumulator captures values\");\n+            }\n+\n+            JavaType collectType = (JavaType) supplier.invokableType().returnType();\n+            return func(\"fused.collect\", FunctionType.functionType(collectType, sourceType))\n+                    .body(b -> {\n+                        Value source = b.parameters().get(0);\n+\n+                        b.inline(supplier, List.of(), (block, collect) -> {\n+                            Op sourceLoop = loopSupplier.apply(block.parentBody(), source)\n+                                    .apply(loopBlock -> {\n+                                        fuseIntermediateOperations(loopBlock, (terminalBlock, resultValue) -> {\n+                                            terminalBlock.inline(accumulator, List.of(collect, resultValue),\n+                                                    (_, _) -> {\n+                                                    });\n+                                            terminalBlock.op(_continue());\n+                                        });\n+                                    });\n+                            block.op(sourceLoop);\n+                            block.op(_return(collect));\n+                        });\n+                    });\n+        }\n+\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestStream\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.reflect.code.type.JavaType.type;\n+\n+public class TestStream {\n+\n+    @Test\n+    public void testMapFilterForEach() {\n+        CoreOps.FuncOp f = StreamFuser.fromList(type(Integer.class))\n+                .map((Integer i) -> i.toString())\n+                .filter((String s) -> s.length() < 10)\n+                .map((String s) -> s.concat(\"_XXX\"))\n+                .filter((String s) -> s.length() < 10)\n+                .forEach((String s) -> System.out.println(s));\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Interpreter.invoke(lf, List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n+    }\n+\n+    @Test\n+    public void testMapFlatMapFilterCollect() {\n+        CoreOps.FuncOp f = StreamFuser.fromList(type(Integer.class))\n+                .map((Integer i) -> i.toString())\n+                .flatMap((String s) -> List.of(s, s))\n+                .filter((String s) -> s.length() < 10)\n+                .map((String s) -> s.concat(\"_XXX\"))\n+                .filter((String s) -> s.length() < 10)\n+                .collect(() -> new ArrayList<String>(), (List<String> l, String e) -> l.add(e));\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        List<Integer> source = List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 20);\n+\n+        List<String> expected = source.stream()\n+                .map(Object::toString)\n+                .flatMap(s -> Stream.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .toList();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> actual = (List<String>) Interpreter.invoke(lf, List.of(source));\n+\n+        Assert.assertEquals(expected, actual);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStream.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestStreamUsingQuotable\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class TestStreamUsingQuotable {\n+\n+    @Test\n+    public void testMapFilterForEach() {\n+        CoreOps.FuncOp f = StreamFuserUsingQuotable.fromList(Integer.class)\n+                .map(Object::toString)\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                \/\/ Cannot use method reference since it captures the result of the expression \"System.out\"\n+                .forEach(s -> System.out.println(s));\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        Interpreter.invoke(lf, List.of(List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 100_000, 20)));\n+    }\n+\n+    @Test\n+    public void testMapFlatMapFilterCollect() {\n+        CoreOps.FuncOp f = StreamFuserUsingQuotable.fromList(Integer.class)\n+                .map(Object::toString)\n+                .flatMap(s -> List.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .collect(ArrayList::new, ArrayList::add);\n+\n+        f.writeTo(System.out);\n+\n+        CoreOps.FuncOp lf = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        lf.writeTo(System.out);\n+\n+        List<Integer> source = List.of(1, 2, 3, 4, 5, 100_000_000, 10_000, 20);\n+\n+        List<String> expected = source.stream()\n+                .map(Object::toString)\n+                .flatMap(s -> Stream.of(s, s))\n+                .filter(s -> s.length() < 10)\n+                .map(s -> s.concat(\"_XXX\"))\n+                .filter(s -> s.length() < 10)\n+                .toList();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> actual = (List<String>) Interpreter.invoke(lf, List.of(source));\n+\n+        Assert.assertEquals(expected, actual);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/TestStreamUsingQuotable.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.stream.Stream;\n+\n+\n+\/*\n+ * @test\n+ * @run testng TestJavaType\n+ *\/\n+\n+public class TestJavaType {\n+\n+    @DataProvider\n+    public Object[][] JavaTypes() {\n+        return new Object[][]{\n+                {\"boolean\", \"Z\"},\n+                {\"byte\", \"B\"},\n+                {\"char\", \"C\"},\n+                {\"short\", \"S\"},\n+                {\"int\", \"I\"},\n+                {\"long\", \"J\"},\n+                {\"float\", \"F\"},\n+                {\"double\", \"D\"},\n+                {\"void\", \"V\"},\n+                {\"int[]\", \"[I\"},\n+                {\"int[][][][]\", \"[[[[I\"},\n+                {\"java.lang.String\", \"Ljava\/lang\/String;\"},\n+                {\"java.lang.String[][]\", \"[[Ljava\/lang\/String;\"},\n+                {\"a.b.C$D\", \"La\/b\/C$D;\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"JavaTypes\")\n+    public void testJavaType(String tds, String bcd) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+        Assert.assertEquals(jt.toNominalDescriptorString(), bcd);\n+        Assert.assertEquals(jt, JavaType.ofNominalDescriptorString(bcd));\n+    }\n+\n+    @DataProvider\n+    public Object[][] classDescriptors() {\n+        return new Object[][]{\n+                {\"java.lang.String\", \"java.lang.String\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"classDescriptors\")\n+    public void classDescriptor(String tds, String bcd) {\n+        ClassType jt = (ClassType)JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+        Assert.assertEquals(jt.toClassName(), bcd);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] basicJavaTypes() {\n+        return new Object[][]{\n+                {\"boolean\", \"int\"},\n+                {\"byte\", \"int\"},\n+                {\"char\", \"int\"},\n+                {\"short\", \"int\"},\n+                {\"int\", \"int\"},\n+                {\"long\", \"long\"},\n+                {\"float\", \"float\"},\n+                {\"double\", \"double\"},\n+                {\"void\", \"void\"},\n+                {\"int[]\", \"java.lang.Object\"},\n+                {\"int[][][][]\", \"java.lang.Object\"},\n+                {\"java.lang.String\", \"java.lang.Object\"},\n+                {\"java.lang.String[][]\", \"java.lang.Object\"},\n+                {\"a.b.C$D\", \"java.lang.Object\"},\n+                {\"java.util.List<T>\", \"java.lang.Object\"},\n+                {\"java.util.List<T>[]\", \"java.lang.Object\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"basicJavaTypes\")\n+    public void testBasicJavaType(String tds, String btds) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+        Assert.assertEquals(jt.toBasicType().toString(), btds);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] argumentJavaTypes() {\n+        return new Object[][]{\n+                {\"java.util.List<T>\", \"T\"},\n+                {\"java.util.List<T>[]\", \"T\"},\n+                {\"java.util.List<java.util.function.Supplier<T>>\", \"java.util.function.Supplier<T>\"},\n+                {\"java.util.List<java.util.function.Supplier<T>>[][]\", \"java.util.function.Supplier<T>\"},\n+                {\"java.util.Map<K, V>\", \"K\", \"V\"},\n+                {\"ab<cd<S<T, V>, N>>\", \"cd<S<T, V>, N>\"},\n+                {\"java.util.Consumer<java.util.Function<String, Number>>\", \"java.util.Function<String, Number>\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"argumentJavaTypes\")\n+    public void testArgumentJavaType(String tds, String... argTypes) {\n+        JavaType jt = JavaType.ofString(tds);\n+        Assert.assertEquals(jt.toString(), tds);\n+\n+        while (jt instanceof ArrayType) {\n+            jt = ((ArrayType)jt).componentType();\n+        }\n+        ClassType ct = (ClassType)jt;\n+\n+        Assert.assertEquals(argTypes.length, ct.typeArguments().size());\n+\n+        Assert.assertEquals(ct.typeArguments(), Stream.of(argTypes).map(JavaType::ofString).toList());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.type.FieldRef;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.lang.reflect.code.type.RecordTypeRef;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+\n+\/*\n+ * @test\n+ * @run testng TestReferences\n+ *\/\n+\n+public class TestReferences {\n+\n+    @DataProvider\n+    public Object[][] methodRefs() {\n+        return new Object[][]{\n+                {\"a::b()void\", \"a\", \"b\"},\n+                {\"a.b::c(int)int\", \"a.b\", \"c\"},\n+                {\"a.b.c::d(int, int)int\", \"a.b.c\", \"d\"},\n+                {\"a::b(Func<String, Number>, Entry<List<String>, val>, int, long)void\", \"a\", \"b\"},\n+                {\"java.io.PrintStream::println(java.lang.String)void\", \"java.io.PrintStream\", \"println\"},\n+                {\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\", \"MethodReferenceTest$A\", \"m\"},\n+                {\"MethodReferenceTest$X::<new>(int)MethodReferenceTest$X\", \"MethodReferenceTest$X\", \"<new>\"},\n+                {\"MethodReferenceTest$A[]::<new>(int)MethodReferenceTest$A[]\", \"MethodReferenceTest$A[]\", \"<new>\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"methodRefs\")\n+    public void testMethodRef(String mds, String refType, String name) {\n+        MethodRef mr = MethodRef.ofString(mds);\n+        Assert.assertEquals(mr.toString(), mds);\n+        Assert.assertEquals(mr.refType().toString(), refType);\n+        Assert.assertEquals(mr.name(), name);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] fieldRefs() {\n+        return new Object[][]{\n+                {\"a.b::c()int\", \"a.b\", \"c\", \"int\"},\n+                {\"a.b.c::d()int\", \"a.b.c\", \"d\", \"int\"},\n+                {\"java.lang.System::out()java.io.PrintStream\", \"java.lang.System\", \"out\", \"java.io.PrintStream\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"fieldRefs\")\n+    public void testFieldRef(String fds, String refType, String name, String type) {\n+        FieldRef fr = FieldRef.ofString(fds);\n+        Assert.assertEquals(fr.toString(), fds);\n+        Assert.assertEquals(fr.refType().toString(), refType);\n+        Assert.assertEquals(fr.name(), name);\n+        Assert.assertEquals(fr.type().toString(), type);\n+    }\n+\n+\n+    @DataProvider\n+    public Object[][] recordTypeRefs() {\n+        return new Object[][]{\n+                {\"()A\"},\n+                {\"(B b)A\"},\n+                {\"(B b, C c)A\"},\n+                {\"(p.Func<String, Number> f, Entry<List<String>, val> e, int i, long l)p.A<R>\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"recordTypeRefs\")\n+    public void testRecordTypeRef(String rtds) {\n+        RecordTypeRef rtr = RecordTypeRef.ofString(rtds);\n+        Assert.assertEquals(rtr.toString(), rtds);\n+    }\n+\n+\n+    @CodeReflection\n+    static void x() {}\n+\n+    @Test\n+    public void testAccessCodeModel() throws ReflectiveOperationException {\n+        MethodRef xr = MethodRef.method(TestReferences.class, \"x\", void.class);\n+        Optional<CoreOps.FuncOp> m = xr.codeModel(MethodHandles.lookup());\n+        Assert.assertTrue(m.isPresent());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.type.CoreTypeFactory;\n+import java.lang.reflect.code.writer.OpBuilder;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @run testng TestCodeBuilder\n+ *\/\n+\n+public class TestCodeBuilder {\n+\n+    @CodeReflection\n+    static void constants() {\n+        boolean bool = false;\n+        byte b = 1;\n+        char c = 'a';\n+        short s = 1;\n+        int i = 1;\n+        long l = 1L;\n+        float f = 1.0f;\n+        double d = 1.0;\n+        String str = \"1\";\n+        Object obj = null;\n+        Class<?> klass = Object.class;\n+    }\n+\n+    @Test\n+    public void testConstants() {\n+        testWithTransforms(getFuncOp(\"constants\"));\n+    }\n+\n+    static record X(int f) {\n+        void m() {}\n+    }\n+\n+    @CodeReflection\n+    static void reflect() {\n+        X x = new X(1);\n+        int i = x.f;\n+        x.m();\n+        X[] ax = new X[1];\n+        int l = ax.length;\n+        x = ax[0];\n+\n+        Object o = x;\n+        x = (X) o;\n+        if (o instanceof X) {\n+            return;\n+        }\n+        if (o instanceof X(var a)) {\n+            return;\n+        }\n+    }\n+\n+    @Test\n+    public void testReflect() {\n+        testWithTransforms(getFuncOp(\"reflect\"));\n+    }\n+\n+    @CodeReflection\n+    static int bodies(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum += i + j;\n+            }\n+        }\n+        return m > 10 ? sum : 0;\n+    }\n+\n+    @Test\n+    public void testBodies() {\n+        testWithTransforms(getFuncOp(\"bodies\"));\n+    }\n+\n+    public void testWithTransforms(CoreOps.FuncOp f) {\n+        test(f);\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable l) {\n+                return l.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+        test(f);\n+\n+        f = SSA.transform(f);\n+        test(f);\n+    }\n+\n+    static void test(CoreOps.FuncOp fExpected) {\n+        CoreOps.FuncOp fb = OpBuilder.createBuilderFunction(fExpected);\n+        CoreOps.FuncOp fActual = (CoreOps.FuncOp) Interpreter.invoke(MethodHandles.lookup(),\n+                fb, ExtendedOps.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+        Assert.assertEquals(fActual.toText(), fExpected.toText());\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestCodeBuilder.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestNaming\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.StringWriter;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CodeItem;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOps;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+public class TestNaming {\n+\n+    @CodeReflection\n+    static int f(int n, int m) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum += i;\n+                sum += j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Test\n+    public void testHigh() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        testModel(f);\n+    }\n+\n+    @Test\n+    public void testLow() {\n+        CoreOps.FuncOp f = getFuncOp(\"f\");\n+\n+        f = f.transform((block, op) -> {\n+            if (op instanceof Op.Lowerable lop) {\n+                return lop.lower(block);\n+            } else {\n+                block.op(op);\n+                return block;\n+            }\n+        });\n+\n+        f = SSA.transform(f);\n+\n+        testModel(f);\n+    }\n+\n+    static void testModel(Op op) {\n+        Map<CodeItem, String> cNamer = OpWriter.computeGlobalNames(op);\n+\n+        StringWriter w = new StringWriter();\n+        new OpWriter(w, OpWriter.CodeItemNamerOption.of(cNamer::get)).writeOp(op);\n+        w.write(\"\\n\");\n+        String actual = w.toString();\n+\n+        String expected = op.toText();\n+\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    static CoreOps.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TestNaming.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestNaming.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -214,0 +214,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,339 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with array access.\n+ * @build ArrayAccessTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ArrayAccessTest\n+ *\/\n+\n+public class ArrayAccessTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ArrayAccessTest, %1 : int[])int -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                return %5;\n+            };\n+            \"\"\")\n+    int test1(int[] ia) {\n+        return ia[0];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)int -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int = array.load %5 %8;\n+                return %9;\n+            };\n+            \"\"\")\n+    int test2(int[] ia, int i) {\n+        return ia[i + 1];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = constant @\"1\";\n+                array.store %3 %4 %5;\n+                return;\n+            };\n+            \"\"\")\n+    void test3(int[] ia) {\n+        ia[0] = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int = constant @\"1\";\n+                array.store %5 %8 %9;\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int[] ia, int i) {\n+        ia[i + 1] = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : ArrayAccessTest, %1 : int[][], %2 : int)int -> {\n+                %3 : Var<int[][]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[][] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int[] = array.load %5 %8;\n+                %10 : int = var.load %4;\n+                %11 : int = constant @\"2\";\n+                %12 : int = add %10 %11;\n+                %13 : int = array.load %9 %12;\n+                return %13;\n+            };\n+            \"\"\")\n+    int test5(int[][] ia, int i) {\n+        return ia[i + 1][i + 2];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : ArrayAccessTest, %1 : int[][], %2 : int)void -> {\n+                %3 : Var<int[][]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[][] = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                %9 : int[] = array.load %5 %8;\n+                %10 : int = var.load %4;\n+                %11 : int = constant @\"2\";\n+                %12 : int = add %10 %11;\n+                %13 : int = constant @\"1\";\n+                array.store %9 %12 %13;\n+                return;\n+            };\n+            \"\"\")\n+    void test6(int[][] ia, int i) {\n+        ia[i + 1][i + 2] = 1;\n+    }\n+\n+    int[] ia;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : ArrayAccessTest)int -> {\n+                %1 : int[] = field.load %0 @\"ArrayAccessTest::ia()int[]\";\n+                %2 : int = constant @\"0\";\n+                %3 : int = array.load %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test7() {\n+        return ia[0];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : ArrayAccessTest)int -> {\n+                %1 : int[] = field.load %0 @\"ArrayAccessTest::ia()int[]\";\n+                %2 : int = constant @\"0\";\n+                %3 : int = array.load %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test8() {\n+        return this.ia[0];\n+    }\n+\n+    static class A {\n+        int i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : ArrayAccessTest, %1 : ArrayAccessTest$A[])int -> {\n+                %2 : Var<ArrayAccessTest$A[]> = var %1 @\"aa\";\n+                %3 : ArrayAccessTest$A[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : ArrayAccessTest$A = array.load %3 %4;\n+                %6 : int = field.load %5 @\"ArrayAccessTest$A::i()int\";\n+                return %6;\n+            };\n+            \"\"\")\n+    int test9(A[] aa) {\n+        return aa[0].i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : ArrayAccessTest, %1 : ArrayAccessTest$A[])void -> {\n+                %2 : Var<ArrayAccessTest$A[]> = var %1 @\"aa\";\n+                %3 : ArrayAccessTest$A[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : ArrayAccessTest$A = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                field.store %5 %6 @\"ArrayAccessTest$A::i()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10(A[] aa) {\n+        aa[0].i = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                %7 : int = add %5 %6;\n+                array.store %3 %4 %7;\n+                return;\n+            };\n+            \"\"\")\n+    void test11(int[] ia) {\n+        ia[0] += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = constant @\"1\";\n+                %7 : int[] = var.load %3;\n+                %8 : int = var.load %4;\n+                %9 : int = constant @\"2\";\n+                %10 : int = add %8 %9;\n+                %11 : int = array.load %7 %10;\n+                %12 : int = constant @\"1\";\n+                %13 : int = add %11 %12;\n+                array.store %7 %10 %13;\n+                array.store %5 %6 %13;\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int[] ia, int i) {\n+        ia[1] = ia[i + 2] += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : ArrayAccessTest, %1 : int[], %2 : int)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<int> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = constant @\"1\";\n+                %7 : int = array.load %5 %6;\n+                %8 : int[] = var.load %3;\n+                %9 : int = var.load %4;\n+                %10 : int = constant @\"2\";\n+                %11 : int = add %9 %10;\n+                %12 : int = array.load %8 %11;\n+                %13 : int = constant @\"1\";\n+                %14 : int = add %12 %13;\n+                array.store %8 %11 %14;\n+                %15 : int = add %7 %14;\n+                array.store %5 %6 %15;\n+                return;\n+            };\n+            \"\"\")\n+    void test13(int[] ia, int i) {\n+        ia[1] += ia[i + 2] += 1;\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                %7 : int = add %5 %6;\n+                array.store %3 %4 %7;\n+                %8 : Var<int> = var %5 @\"x\";\n+                %9 : int[] = var.load %2;\n+                %10 : int = constant @\"0\";\n+                %11 : int = array.load %9 %10;\n+                %12 : int = constant @\"1\";\n+                %13 : int = sub %11 %12;\n+                array.store %9 %10 %13;\n+                %14 : Var<int> = var %11 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14(int[] ia) {\n+        int x = ia[0]++;\n+        int y = ia[0]--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : ArrayAccessTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : int = array.load %3 %4;\n+                %6 : int = constant @\"1\";\n+                %7 : int = add %5 %6;\n+                array.store %3 %4 %7;\n+                %8 : Var<int> = var %7 @\"x\";\n+                %9 : int[] = var.load %2;\n+                %10 : int = constant @\"0\";\n+                %11 : int = array.load %9 %10;\n+                %12 : int = constant @\"1\";\n+                %13 : int = sub %11 %12;\n+                array.store %9 %10 %13;\n+                %14 : Var<int> = var %13 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int[] ia) {\n+        int x = ++ia[0];\n+        int y = --ia[0];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : ArrayAccessTest, %1 : int[])int -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                %3 : int[] = var.load %2;\n+                %4 : int = array.length %3;\n+                %5 : int[] = var.load %2;\n+                %6 : int = invoke %5 @\"java.lang.Object::hashCode()int\";\n+                %7 : int = add %4 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test16(int[] ia) {\n+        return ia.length + ia.hashCode();\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ArrayAccessTest.java","additions":339,"deletions":0,"binary":false,"changes":339,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with array access.\n+ * @build AssertTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester AssertTest\n+ *\/\n+public class AssertTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+              func @\"assertTest\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"i\";\n+                  assert\n+                      ()boolean -> {\n+                          %2 : int = var.load %1;\n+                          %3 : int = constant @\"1\";\n+                          %4 : boolean = eq %2 %3;\n+                          yield %4;\n+                      }\n+                      ()java.lang.String -> {\n+                          %5 : java.lang.String = constant @\"i does not equal 1\";\n+                          yield %5;\n+                      };\n+                  return;\n+              };\n+            \"\"\")\n+    public static void assertTest(int i) {\n+        assert (i == 1) : \"i does not equal 1\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"assertTest2\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"i\";\n+                  assert ()boolean -> {\n+                      %2 : int = var.load %1;\n+                      %3 : int = constant @\"1\";\n+                      %4 : boolean = eq %2 %3;\n+                      yield %4;\n+                  };\n+                  return;\n+              };\n+            \"\"\")\n+    public static void assertTest2(int i) {\n+        assert (i == 1);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/AssertTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with binary operations.\n+ * @build BinopTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BinopTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class BinopTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"5\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = constant @\"4\";\n+                %4 : int = mul %2 %3;\n+                %5 : int = add %1 %4;\n+                %6 : int = constant @\"3\";\n+                %7 : int = sub %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test() {\n+        return 5 + 2 * 4 - 3;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = constant @\"3\";\n+                %4 : int = constant @\"4\";\n+                %5 : int = add %3 %4;\n+                %6 : int = add %2 %5;\n+                %7 : int = add %1 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test2() {\n+        return 1 + (2 + (3 + 4));\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = add %1 %2;\n+                %4 : int = constant @\"3\";\n+                %5 : int = add %3 %4;\n+                %6 : int = constant @\"4\";\n+                %7 : int = add %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test3() {\n+        return ((1 + 2) + 3) + 4;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BinopTest, %1 : int)int -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : int = var.load %2;\n+                %7 : int = constant @\"1\";\n+                %8 : int = mul %6 %7;\n+                var.store %2 %8;\n+                %9 : int = add %5 %8;\n+                %10 : int = var.load %2;\n+                %11 : int = constant @\"1\";\n+                %12 : int = div %10 %11;\n+                var.store %2 %12;\n+                %13 : int = add %9 %12;\n+                %14 : int = var.load %2;\n+                %15 : int = constant @\"1\";\n+                %16 : int = sub %14 %15;\n+                var.store %2 %16;\n+                %17 : int = add %13 %16;\n+                %18 : int = var.load %2;\n+                %19 : int = constant @\"1\";\n+                %20 : int = mod %18 %19;\n+                var.store %2 %20;\n+                %21 : int = add %17 %20;\n+                return %21;\n+            };\n+            \"\"\")\n+    int test4(int i) {\n+        return (i += 1) + (i *= 1) + (i \/= 1) + (i -= 1) + (i %= 1);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : BinopTest, %1 : int)boolean -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : boolean = eq %3 %4;\n+                %6 : boolean = not %5;\n+                return %6;\n+            };\n+            \"\"\")\n+    boolean test5(int i) {\n+        return !(i == 0);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : BinopTest)int -> {\n+                %1 : int = constant @\"5\";\n+                %2 : int = constant @\"2\";\n+                %3 : int = mod %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test6() {\n+        return 5 % 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : BinopTest, %1 : double)void -> {\n+                %2 : Var<double> = var %1 @\"d\";\n+                %3 : double = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : double = conv %4;\n+                %6 : double = add %3 %5;\n+                var.store %2 %6;\n+                %7 : long = constant @\"1\";\n+                %8 : double = conv %7;\n+                %9 : double = var.load %2;\n+                %10 : double = add %8 %9;\n+                var.store %2 %10;\n+                %11 : double = var.load %2;\n+                %12 : long = constant @\"1\";\n+                %13 : double = conv %12;\n+                %14 : double = sub %11 %13;\n+                var.store %2 %14;\n+                %15 : int = constant @\"1\";\n+                %16 : double = conv %15;\n+                %17 : double = var.load %2;\n+                %18 : double = sub %16 %17;\n+                var.store %2 %18;\n+                %19 : double = var.load %2;\n+                %20 : int = constant @\"1\";\n+                %21 : double = conv %20;\n+                %22 : double = mul %19 %21;\n+                var.store %2 %22;\n+                %23 : long = constant @\"1\";\n+                %24 : double = conv %23;\n+                %25 : double = var.load %2;\n+                %26 : double = mul %24 %25;\n+                var.store %2 %26;\n+                %27 : double = var.load %2;\n+                %28 : long = constant @\"1\";\n+                %29 : double = conv %28;\n+                %30 : double = div %27 %29;\n+                var.store %2 %30;\n+                %31 : int = constant @\"1\";\n+                %32 : double = conv %31;\n+                %33 : double = var.load %2;\n+                %34 : double = div %32 %33;\n+                var.store %2 %34;\n+                %35 : double = var.load %2;\n+                %36 : int = constant @\"1\";\n+                %37 : double = conv %36;\n+                %38 : double = mod %35 %37;\n+                var.store %2 %38;\n+                %39 : long = constant @\"1\";\n+                %40 : double = conv %39;\n+                %41 : double = var.load %2;\n+                %42 : double = mod %40 %41;\n+                var.store %2 %42;\n+                %43 : int = constant @\"-1\";\n+                %44 : double = conv %43;\n+                var.store %2 %44;\n+                return;\n+            };\n+            \"\"\")\n+    void test7(double d) {\n+        d = d + 1;\n+        d = 1L + d;\n+\n+        d = d - 1L;\n+        d = 1 - d;\n+\n+        d = d * 1;\n+        d = 1L * d;\n+\n+        d = d \/ 1L;\n+        d = 1 \/ d;\n+\n+        d = d % 1;\n+        d = 1L % d;\n+\n+        d = -1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : BinopTest, %1 : double)void -> {\n+                %2 : Var<double> = var %1 @\"d\";\n+                %3 : double = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : double = conv %4;\n+                %6 : double = add %3 %5;\n+                var.store %2 %6;\n+                %7 : double = var.load %2;\n+                %8 : long = constant @\"1\";\n+                %9 : double = conv %8;\n+                %10 : double = sub %7 %9;\n+                var.store %2 %10;\n+                %11 : double = var.load %2;\n+                %12 : int = constant @\"1\";\n+                %13 : double = conv %12;\n+                %14 : double = mul %11 %13;\n+                var.store %2 %14;\n+                %15 : double = var.load %2;\n+                %16 : long = constant @\"1\";\n+                %17 : double = conv %16;\n+                %18 : double = div %15 %17;\n+                var.store %2 %18;\n+                %19 : double = var.load %2;\n+                %20 : int = constant @\"1\";\n+                %21 : double = conv %20;\n+                %22 : double = mod %19 %21;\n+                var.store %2 %22;\n+                return;\n+            };\n+            \"\"\")\n+    void test8(double d) {\n+        d += 1;\n+\n+        d -= 1L;\n+\n+        d *= 1;\n+\n+        d \/= 1L;\n+\n+        d %= 1;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BinopTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with blocks.\n+ * @build BlockTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BlockTest\n+ *\/\n+\n+public class BlockTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : BlockTest)void -> {\n+                java.block ()void -> {\n+                    %1 : int = constant @\"0\";\n+                    %2 : Var<int> = var %1 @\"i\";\n+                    yield;\n+                };\n+                java.block ()void -> {\n+                    %3 : int = constant @\"1\";\n+                    %4 : Var<int> = var %3 @\"i\";\n+                    java.block ()void -> {\n+                        %5 : int = constant @\"2\";\n+                        %6 : Var<int> = var %5 @\"j\";\n+                        yield;\n+                    };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        {\n+            int i = 0;\n+        }\n+\n+        {\n+            int i = 1;\n+\n+            {\n+                int j = 2;\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BlockTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        java.block ()void -> {\n+                            %6 : int = var.load %2;\n+                            %7 : int = constant @\"1\";\n+                            %8 : int = add %6 %7;\n+                            var.store %2 %8;\n+                            yield;\n+                        };\n+                        yield;\n+                    }\n+                    ^else_if()boolean -> {\n+                        %9 : int = var.load %2;\n+                        %10 : int = constant @\"2\";\n+                        %11 : boolean = lt %9 %10;\n+                        yield %11;\n+                    }\n+                    ^then()void -> {\n+                        java.block ()void -> {\n+                            %12 : int = var.load %2;\n+                            %13 : int = constant @\"2\";\n+                            %14 : int = add %12 %13;\n+                            var.store %2 %14;\n+                            yield;\n+                        };\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        java.block ()void -> {\n+                            %15 : int = var.load %2;\n+                            %16 : int = constant @\"3\";\n+                            %17 : int = add %15 %16;\n+                            var.store %2 %17;\n+                            yield;\n+                        };\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int i) {\n+        if (i < 1) {\n+            {\n+                i += 1;\n+            }\n+        } else if (i < 2) {\n+            {\n+                i += 2;\n+            }\n+        } else {\n+            {\n+                i += 3;\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BlockTest)void -> {\n+                java.for\n+                    ^init()void -> {\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %1 : boolean = constant @\"true\";\n+                        yield %1;\n+                    }\n+                    ^update()void -> {\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        java.block ()void -> {\n+                            %2 : int = constant @\"0\";\n+                            %3 : Var<int> = var %2 @\"i\";\n+                            yield;\n+                        };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        for (;;) {\n+            {\n+                int i = 0;\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BlockTest, %1 : int[])void -> {\n+                %2 : Var<int[]> = var %1 @\"ia\";\n+                java.enhancedFor\n+                    ^expr()int[] -> {\n+                        %3 : int[] = var.load %2;\n+                        yield %3;\n+                    }\n+                    ^def(%4 : int)Var<int> -> {\n+                        %5 : Var<int> = var %4 @\"i\";\n+                        yield %5;\n+                    }\n+                    ^body(%6 : Var<int>)void -> {\n+                        java.block ()void -> {\n+                            %7 : int = var.load %6;\n+                            %8 : int = constant @\"1\";\n+                            %9 : int = add %7 %8;\n+                            var.store %6 %9;\n+                            yield;\n+                        };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int[] ia) {\n+        for (int i : ia) {\n+            {\n+                i++;\n+            }\n+        }\n+   }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : BlockTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"s\";\n+                    java.block ()void -> {\n+                        %4 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %5 : java.lang.String = var.load %3;\n+                        invoke %4 %5 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                    return;\n+                };\n+                %6 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+   void test5() {\n+        Consumer<String> c = s -> {\n+            {\n+                System.out.println(s);\n+            }\n+        };\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : BlockTest)void -> {\n+                 java.if\n+                     ()boolean -> {\n+                         %1 : boolean = constant @\"true\";\n+                         yield %1;\n+                     }\n+                     ^then()void -> {\n+                         java.block ()void -> {\n+                             return;\n+                         };\n+                         yield;\n+                     }\n+                     ^else()void -> {\n+                         yield;\n+                     };\n+                 java.if\n+                     ()boolean -> {\n+                         %2 : boolean = constant @\"true\";\n+                         yield %2;\n+                     }\n+                     ^then()void -> {\n+                         java.block ()void -> {\n+                             %3 : java.lang.RuntimeException = new @\"func<java.lang.RuntimeException>\";\n+                             throw %3;\n+                         };\n+                         yield;\n+                     }\n+                     ^else()void -> {\n+                         yield;\n+                     };\n+                 return;\n+             };\n+             \"\"\")\n+    void test6() {\n+        if (true) {\n+            {\n+                return;\n+            }\n+        }\n+\n+        if (true) {\n+            {\n+                throw new RuntimeException();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BlockTest.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,713 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with boxing conversions.\n+ * @build BoxingConversionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BoxingConversionTest\n+ *\/\n+\n+public class BoxingConversionTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : BoxingConversionTest)void -> {\n+                  %1 : long = constant @\"1\";\n+                  %2 : java.lang.Long = invoke %1 @\"java.lang.Long::valueOf(long)java.lang.Long\";\n+                  %3 : Var<java.lang.Long> = var %2 @\"x\";\n+                  return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        Long x = 1L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BoxingConversionTest, %1 : java.lang.Long)void -> {\n+                %2 : Var<java.lang.Long> = var %1 @\"L\";\n+                %3 : java.lang.Long = var.load %2;\n+                %4 : long = invoke %3 @\"java.lang.Long::longValue()long\";\n+                %5 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(Long L) {\n+        long l = L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BoxingConversionTest)void -> {\n+                %1 : long = constant @\"0\";\n+                %2 : java.lang.Long = invoke %1 @\"java.lang.Long::valueOf(long)java.lang.Long\";\n+                %3 : Var<java.lang.Object> = var %2 @\"o\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        Object o = 0L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BoxingConversionTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.lang.Long = cast %3 @\"java.lang.Long\";\n+                %5 : long = invoke %4 @\"java.lang.Long::longValue()long\";\n+                %6 : Var<long> = var %5 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4(Object o) {\n+        long l = (long)o;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : BoxingConversionTest, %1 : java.lang.Integer)void -> {\n+                %2 : Var<java.lang.Integer> = var %1 @\"i2\";\n+                %3 : java.lang.Integer = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = invoke %3 @\"java.lang.Integer::intValue()int\";\n+                %6 : int = add %5 %4;\n+                %7 : java.lang.Integer = invoke %6 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                var.store %2 %7;\n+                return;\n+            };\n+            \"\"\")\n+    void test5(Integer i2) {\n+        i2++;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : BoxingConversionTest, %1 : java.lang.Integer)void -> {\n+                %2 : Var<java.lang.Integer> = var %1 @\"i2\";\n+                %3 : java.lang.Integer = var.load %2;\n+                %4 : int = constant @\"3\";\n+                %5 : int = invoke %3 @\"java.lang.Integer::intValue()int\";\n+                %6 : int = add %5 %4;\n+                %7 : java.lang.Integer = invoke %6 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                var.store %2 %7;\n+                return;\n+            };\n+            \"\"\")\n+    void test6(Integer i2) {\n+        i2 += 3;\n+    }\n+\n+    static class Box {\n+        Integer i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : BoxingConversionTest)void -> {\n+                %1 : BoxingConversionTest$Box = new @\"func<BoxingConversionTest$Box>\";\n+                %2 : java.lang.Integer = field.load %1 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                %3 : int = constant @\"1\";\n+                %4 : int = invoke %2 @\"java.lang.Integer::intValue()int\";\n+                %5 : int = add %4 %3;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                field.store %1 %6 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        new Box().i++;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : BoxingConversionTest)void -> {\n+                %1 : BoxingConversionTest$Box = new @\"func<BoxingConversionTest$Box>\";\n+                %2 : java.lang.Integer = field.load %1 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                %3 : int = constant @\"3\";\n+                %4 : int = invoke %2 @\"java.lang.Integer::intValue()int\";\n+                %5 : int = add %4 %3;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                field.store %1 %6 @\"BoxingConversionTest$Box::i()java.lang.Integer\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        new Box().i += 3;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : BoxingConversionTest, %1 : int[], %2 : java.lang.Integer)void -> {\n+                %3 : Var<int[]> = var %1 @\"ia\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"i\";\n+                %5 : int[] = var.load %3;\n+                %6 : int = constant @\"0\";\n+                %7 : int = array.load %5 %6;\n+                %8 : java.lang.Integer = var.load %4;\n+                %9 : int = invoke %8 @\"java.lang.Integer::intValue()int\";\n+                %10 : int = add %7 %9;\n+                array.store %5 %6 %10;\n+                return;\n+            };\n+            \"\"\")\n+    void test9(int[] ia, Integer i) {\n+        ia[0] += i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : BoxingConversionTest, %1 : boolean, %2 : java.lang.Integer)void -> {\n+                %3 : Var<boolean> = var %1 @\"cond\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = java.cexpression\n+                    ^cond()boolean -> {\n+                        %6 : boolean = var.load %3;\n+                        yield %6;\n+                    }\n+                    ^truepart()int -> {\n+                        %7 : java.lang.Integer = var.load %4;\n+                        %8 : int = invoke %7 @\"java.lang.Integer::intValue()int\";\n+                        yield %8;\n+                    }\n+                    ^falsepart()int -> {\n+                        %9 : int = constant @\"2\";\n+                        yield %9;\n+                    };\n+                %10 : Var<int> = var %5 @\"res\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10(boolean cond, Integer I) {\n+        int res = cond ? I : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : BoxingConversionTest, %1 : boolean, %2 : java.lang.Integer)void -> {\n+                %3 : Var<boolean> = var %1 @\"cond\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = java.cexpression\n+                    ^cond()boolean -> {\n+                        %6 : boolean = var.load %3;\n+                        yield %6;\n+                    }\n+                    ^truepart()int -> {\n+                        %7 : int = constant @\"2\";\n+                        yield %7;\n+                    }\n+                    ^falsepart()int -> {\n+                        %8 : java.lang.Integer = var.load %4;\n+                        %9 : int = invoke %8 @\"java.lang.Integer::intValue()int\";\n+                        yield %9;\n+                    };\n+                %10 : Var<int> = var %5 @\"res\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(boolean cond, Integer I) {\n+        int res = cond ? 2 : I;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : BoxingConversionTest, %1 : boolean)void -> {\n+                 %2 : Var<boolean> = var %1 @\"cond\";\n+                 %3 : int = java.cexpression\n+                     ^cond()boolean -> {\n+                         %4 : boolean = var.load %2;\n+                         yield %4;\n+                     }\n+                     ^truepart()int -> {\n+                         %5 : int = constant @\"1\";\n+                         yield %5;\n+                     }\n+                     ^falsepart()int -> {\n+                         %6 : int = constant @\"2\";\n+                         yield %6;\n+                     };\n+                 %7 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                 %8 : Var<java.lang.Integer> = var %7 @\"x\";\n+                 return;\n+             };\n+             \"\"\")\n+    void test12(boolean cond) {\n+        Integer x = cond ? 1 : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : BoxingConversionTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : java.lang.Integer = invoke %2 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.Supplier<java.lang.Integer>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13() {\n+        Supplier<Integer> s = () -> { return 1; };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : BoxingConversionTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : java.lang.Integer = invoke %2 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.Supplier<java.lang.Integer>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14() {\n+        Supplier<Integer> s = () -> 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : java.lang.Integer = var.load %4;\n+                        %11 : int = invoke %10 @\"java.lang.Integer::intValue()int\";\n+                        yield %11;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %12 : int = constant @\"0\";\n+                        yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> I;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : int = constant @\"1\";\n+                        yield %10;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %11 : java.lang.Integer = var.load %4;\n+                        %12 : int = invoke %11 @\"java.lang.Integer::intValue()int\";\n+                        yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> 1;\n+            default -> I;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : java.lang.Integer = invoke %8 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        yield %11;\n+                    };\n+                %12 : Var<java.lang.Integer> = var %4 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17(int i) {\n+        Integer x = switch (i) {\n+            case 1 -> 1;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : java.lang.Integer = var.load %4;\n+                        %11 : int = invoke %10 @\"java.lang.Integer::intValue()int\";\n+                        java.yield %11;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %12 : int = constant @\"0\";\n+                        java.yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> { yield I; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test19\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : int = java.switch.expression %5\n+                    ^constantCaseLabel(%7 : int)boolean -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : boolean = eq %7 %8;\n+                        yield %9;\n+                    }\n+                    ()int -> {\n+                        %10 : int = constant @\"1\";\n+                        java.yield %10;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()int -> {\n+                        %11 : java.lang.Integer = var.load %4;\n+                        %12 : int = invoke %11 @\"java.lang.Integer::intValue()int\";\n+                        java.yield %12;\n+                    };\n+                %13 : Var<int> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test19(int i, Integer I) {\n+        int x = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield I; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : java.lang.Integer = invoke %8 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        java.yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Integer -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : java.lang.Integer = invoke %10 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        java.yield %11;\n+                    };\n+                %12 : Var<java.lang.Integer> = var %4 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test20(int i) {\n+        Integer x = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0 : BoxingConversionTest, %1 : int, %2 : java.lang.Integer)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<java.lang.Integer> = var %2 @\"I\";\n+                %5 : int = var.load %3;\n+                %6 : java.lang.Integer = var.load %4;\n+                %7 : int = invoke %6 @\"java.lang.Integer::intValue()int\";\n+                %8 : int = add %5 %7;\n+                %9 : Var<int> = var %8 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21(int i, Integer I) {\n+        int l = i + I;\n+    }\n+\n+    void m(Integer I) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test22\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                invoke %0 %4 @\"BoxingConversionTest::m(java.lang.Integer)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test22(int i) {\n+        m(i);\n+    }\n+\n+    void m(int i1, int i2, Integer... I) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test23\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                invoke %0 %3 %4 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test23(int i) {\n+        m(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test24\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                invoke %0 %3 %4 %6 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test24(int i) {\n+        m(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test25\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %7 : int = var.load %2;\n+                %8 : java.lang.Integer = invoke %7 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                invoke %0 %3 %4 %6 %8 @\"BoxingConversionTest::m(int, int, java.lang.Integer[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test25(int i) {\n+        m(i, i, i, i);\n+    }\n+\n+    static class Box2 {\n+        Box2(Integer I) { }\n+        Box2(int i1, int i2, Integer... Is) { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test26\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %5 : BoxingConversionTest$Box2 = new %4 @\"func<BoxingConversionTest$Box2, java.lang.Integer>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test26(int i) {\n+        new Box2(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test27\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : BoxingConversionTest$Box2 = new %3 %4 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test27(int i) {\n+        new Box2(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test28\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %7 : BoxingConversionTest$Box2 = new %3 %4 %6 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test28(int i) {\n+        new Box2(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test29\" (%0 : BoxingConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : java.lang.Integer = invoke %5 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %7 : int = var.load %2;\n+                %8 : java.lang.Integer = invoke %7 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                %9 : BoxingConversionTest$Box2 = new %3 %4 %6 %8 @\"func<BoxingConversionTest$Box2, int, int, java.lang.Integer[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test29(int i) {\n+        new Box2(i, i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test30\" (%0 : java.lang.Integer)void -> {\n+                  %1 : Var<java.lang.Integer> = var %0 @\"i\";\n+                  %2 : java.lang.Integer = var.load %1;\n+                  %3 : int = invoke %2 @\"java.lang.Integer::intValue()int\";\n+                  %4 : int = neg %3;\n+                  %5 : Var<int> = var %4 @\"j\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test30(Integer i) {\n+        int j = -i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test31\" (%0 : int)void -> {\n+                  %1 : Var<int> = var %0 @\"i\";\n+                  %2 : int = var.load %1;\n+                  %3 : int = neg %2;\n+                  %4 : java.lang.Integer = invoke %3 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                  %5 : Var<java.lang.Integer> = var %4 @\"j\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test31(int i) {\n+        Integer j = -i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test32\" (%0 : boolean)void -> {\n+                  %1 : Var<boolean> = var %0 @\"i\";\n+                  %2 : boolean = var.load %1;\n+                  %3 : boolean = not %2;\n+                  %4 : java.lang.Boolean = invoke %3 @\"java.lang.Boolean::valueOf(boolean)java.lang.Boolean\";\n+                  %5 : Var<java.lang.Boolean> = var %4 @\"j\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test32(boolean i) {\n+        Boolean j = !i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test33\" (%0 : java.lang.Boolean)void -> {\n+                  %1 : Var<java.lang.Boolean> = var %0 @\"i\";\n+                  %2 : java.lang.Boolean = var.load %1;\n+                  %3 : boolean = invoke %2 @\"java.lang.Boolean::booleanValue()boolean\";\n+                  %4 : boolean = not %3;\n+                  %5 : Var<boolean> = var %4 @\"j\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test33(Boolean i) {\n+        boolean j = !i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BoxingConversionTest.java","additions":713,"deletions":0,"binary":false,"changes":713,"status":"added"},{"patch":"@@ -0,0 +1,400 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with for loops.\n+ * @build BreakContinueTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester BreakContinueTest\n+ *\/\n+\n+\n+public class BreakContinueTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : BreakContinueTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        java.if\n+                            ()boolean -> {\n+                                %12 : boolean = constant @\"true\";\n+                                yield %12;\n+                            }\n+                            ^then()void -> {\n+                                java.continue;\n+                            }\n+                            ^else()void -> {\n+                                yield;\n+                            };\n+                        java.if\n+                            ()boolean -> {\n+                                %13 : boolean = constant @\"true\";\n+                                yield %13;\n+                            }\n+                            ^then()void -> {\n+                                java.break;\n+                            }\n+                            ^else()void -> {\n+                                yield;\n+                            };\n+                        java.for\n+                            ^init()Var<int> -> {\n+                                %14 : int = constant @\"0\";\n+                                %15 : Var<int> = var %14 @\"j\";\n+                                yield %15;\n+                            }\n+                            ^cond(%16 : Var<int>)boolean -> {\n+                                %17 : int = var.load %16;\n+                                %18 : int = constant @\"10\";\n+                                %19 : boolean = lt %17 %18;\n+                                yield %19;\n+                            }\n+                            ^update(%20 : Var<int>)void -> {\n+                                %21 : int = var.load %20;\n+                                %22 : int = constant @\"1\";\n+                                %23 : int = add %21 %22;\n+                                var.store %20 %23;\n+                                yield;\n+                            }\n+                            ^body(%24 : Var<int>)void -> {\n+                                java.if\n+                                    ()boolean -> {\n+                                        %25 : boolean = constant @\"true\";\n+                                        yield %25;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.continue;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                java.if\n+                                    ()boolean -> {\n+                                        %26 : boolean = constant @\"true\";\n+                                        yield %26;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.break;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                java.continue;\n+                            };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        for (int i = 0; i < 10; i++) {\n+            if (true) {\n+                continue;\n+            }\n+            if (true) {\n+                break;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+                if (true) {\n+                    continue;\n+                }\n+                if (true) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : BreakContinueTest)void -> {\n+                java.labeled ()void -> {\n+                    %1 : java.lang.String = constant @\"outer\";\n+                    java.for\n+                        ^init()Var<int> -> {\n+                            %2 : int = constant @\"0\";\n+                            %3 : Var<int> = var %2 @\"i\";\n+                            yield %3;\n+                        }\n+                        ^cond(%4 : Var<int>)boolean -> {\n+                            %5 : int = var.load %4;\n+                            %6 : int = constant @\"10\";\n+                            %7 : boolean = lt %5 %6;\n+                            yield %7;\n+                        }\n+                        ^update(%8 : Var<int>)void -> {\n+                            %9 : int = var.load %8;\n+                            %10 : int = constant @\"1\";\n+                            %11 : int = add %9 %10;\n+                            var.store %8 %11;\n+                            yield;\n+                        }\n+                        ^body(%12 : Var<int>)void -> {\n+                            java.if\n+                                ()boolean -> {\n+                                    %13 : boolean = constant @\"true\";\n+                                    yield %13;\n+                                }\n+                                ^then()void -> {\n+                                    java.continue %1;\n+                                }\n+                                ^else()void -> {\n+                                    yield;\n+                                };\n+                            java.if\n+                                ()boolean -> {\n+                                    %14 : boolean = constant @\"true\";\n+                                    yield %14;\n+                                }\n+                                ^then()void -> {\n+                                    java.break %1;\n+                                }\n+                                ^else()void -> {\n+                                    yield;\n+                                };\n+                            java.labeled ()void -> {\n+                                %15 : java.lang.String = constant @\"inner\";\n+                                java.for\n+                                    ^init()Var<int> -> {\n+                                        %16 : int = constant @\"0\";\n+                                        %17 : Var<int> = var %16 @\"j\";\n+                                        yield %17;\n+                                    }\n+                                    ^cond(%18 : Var<int>)boolean -> {\n+                                        %19 : int = var.load %18;\n+                                        %20 : int = constant @\"10\";\n+                                        %21 : boolean = lt %19 %20;\n+                                        yield %21;\n+                                    }\n+                                    ^update(%22 : Var<int>)void -> {\n+                                        %23 : int = var.load %22;\n+                                        %24 : int = constant @\"1\";\n+                                        %25 : int = add %23 %24;\n+                                        var.store %22 %25;\n+                                        yield;\n+                                    }\n+                                    ^body(%26 : Var<int>)void -> {\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %27 : boolean = constant @\"true\";\n+                                                yield %27;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.continue;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %28 : boolean = constant @\"true\";\n+                                                yield %28;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.break;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %29 : boolean = constant @\"true\";\n+                                                yield %29;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.continue %1;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.if\n+                                            ()boolean -> {\n+                                                %30 : boolean = constant @\"true\";\n+                                                yield %30;\n+                                            }\n+                                            ^then()void -> {\n+                                                java.break %1;\n+                                            }\n+                                            ^else()void -> {\n+                                                yield;\n+                                            };\n+                                        java.continue;\n+                                    };\n+                                yield;\n+                            };\n+                            java.continue;\n+                        };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        outer:\n+        for (int i = 0; i < 10; i++) {\n+            if (true) {\n+                continue outer;\n+            }\n+            if (true) {\n+                break outer;\n+            }\n+            inner:\n+            for (int j = 0; j < 10; j++) {\n+                if (true) {\n+                    continue;\n+                }\n+                if (true) {\n+                    break;\n+                }\n+                if (true) {\n+                    continue outer;\n+                }\n+                if (true) {\n+                    break outer;\n+                }\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : BreakContinueTest)void -> {\n+                java.labeled ()void -> {\n+                    %1 : java.lang.String = constant @\"b1\";\n+                    java.block ()void -> {\n+                        java.labeled ()void -> {\n+                            %2 : java.lang.String = constant @\"b2\";\n+                            java.block ()void -> {\n+                                java.if\n+                                    ()boolean -> {\n+                                        %3 : boolean = constant @\"true\";\n+                                        yield %3;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.break %1;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                java.if\n+                                    ()boolean -> {\n+                                        %4 : boolean = constant @\"true\";\n+                                        yield %4;\n+                                    }\n+                                    ^then()void -> {\n+                                        java.break %2;\n+                                    }\n+                                    ^else()void -> {\n+                                        yield;\n+                                    };\n+                                yield;\n+                            };\n+                            yield;\n+                        };\n+                        yield;\n+                    };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        b1:\n+        {\n+            b2:\n+            {\n+                if (true) {\n+                    break b1;\n+                }\n+                if (true) {\n+                    break b2;\n+                }\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : BreakContinueTest)void -> {\n+                java.labeled ()void -> {\n+                    %1 : java.lang.String = constant @\"b\";\n+                    java.break %1;\n+                };\n+                %2 : int = constant @\"0\";\n+                %3 : Var<int> = var %2 @\"i\";\n+                java.labeled ()void -> {\n+                    %4 : java.lang.String = constant @\"b\";\n+                    %5 : int = var.load %3;\n+                    %6 : int = constant @\"1\";\n+                    %7 : int = add %5 %6;\n+                    var.store %3 %7;\n+                    yield;\n+                };\n+                java.labeled ()void -> {\n+                    %8 : java.lang.String = constant @\"a\";\n+                    java.labeled ()void -> {\n+                        %9 : java.lang.String = constant @\"b\";\n+                        java.block ()void -> {\n+                            yield;\n+                        };\n+                        yield;\n+                    };\n+                    yield;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        b:\n+        break b;\n+\n+        int i = 0;\n+        b:\n+        i++;\n+\n+        a: b: {\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/BreakContinueTest.java","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with cast expressions.\n+ * @build CastInstanceOfTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester CastInstanceOfTest\n+ *\/\n+\n+public class CastInstanceOfTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : CastInstanceOfTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.lang.String = cast %3 @\"java.lang.String\";\n+                %5 : Var<java.lang.String> = var %4 @\"s\";\n+                %6 : java.lang.String = var.load %5;\n+                %7 : Var<java.lang.String> = var %6 @\"ss\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1(Object o) {\n+        String s = (String) o;\n+        String ss = (String) s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : CastInstanceOfTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.util.List<java.lang.String> = cast %3 @\"java.util.List\";\n+                %5 : Var<java.util.List<java.lang.String>> = var %4 @\"l\";\n+                %6 : java.util.List<java.lang.String> = var.load %5;\n+                %7 : Var<java.util.Collection<java.lang.String>> = var %6 @\"c1\";\n+                %8 : java.util.List<java.lang.String> = var.load %5;\n+                %9 : Var<java.util.Collection<java.lang.String>> = var %8 @\"c2\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(Object o) {\n+        List<String> l = (List<String>) o;\n+        Collection<String> c1 = (List<String>) l;\n+        Collection<String> c2 = (Collection) l;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : CastInstanceOfTest, %1 : java.util.List<java.lang.String>)void -> {\n+                %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+                %3 : java.util.List<java.lang.String> = var.load %2;\n+                %4 : Var<java.util.List> = var %3 @\"raw\";\n+                %5 : java.util.List = var.load %4;\n+                %6 : Var<java.util.List<java.lang.Number>> = var %5 @\"ln\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3(List<String> l) {\n+        List raw = l;\n+        List<Number> ln = raw;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : CastInstanceOfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                %5 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int i) {\n+        long l = (int) i;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : CastInstanceOfTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : boolean = instanceof %3 @\"java.lang.String\";\n+                %5 : Var<boolean> = var %4 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5(Object o) {\n+        boolean b = o instanceof String;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : CastInstanceOfTest, %1 : java.util.List<java.lang.Object>)void -> {\n+                %2 : Var<java.util.List<java.lang.Object>> = var %1 @\"l\";\n+                %3 : java.util.List<java.lang.Object> = var.load %2;\n+                %4 : int = constant @\"0\";\n+                %5 : java.lang.Object = invoke %3 %4 @\"java.util.List::get(int)java.lang.Object\";\n+                %6 : boolean = instanceof %5 @\"java.lang.String\";\n+                %7 : Var<boolean> = var %6 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6(List<Object> l) {\n+        boolean b = l.get(0) instanceof String;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/CastInstanceOfTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Method;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @summary test that invoking Method::getCodeModel returns the same instance.\n+ * @run testng CodeModelSameInstanceTest\n+ *\/\n+public class CodeModelSameInstanceTest {\n+\n+    @CodeReflection\n+    static int add(int a, int b) {\n+        return a + b;\n+    }\n+\n+    @Test\n+    void test() {\n+        Optional<Method> om = Arrays.stream(this.getClass().getDeclaredMethods()).filter(m -> m.getName().equals(\"add\"))\n+                .findFirst();\n+        Method m = om.get();\n+        Object[] codeModels = IntStream.range(0, 1024).mapToObj(_ -> m.getCodeModel()).toArray();\n+        for (int i = 1; i < codeModels.length; i++) {\n+            Assert.assertSame(codeModels[i], codeModels[i-1]);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeModelSameInstanceTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.StringWriter;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.reflect.code.op.CoreOps._return;\n+import static java.lang.reflect.code.op.CoreOps.func;\n+import static java.lang.reflect.code.type.FunctionType.VOID;\n+\n+public class CodeReflectionTester {\n+\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: CodeReflectionTester <classname>\");\n+            System.exit(1);\n+        }\n+        Class<?> clazz = Class.forName(args[0]);\n+        for (Method m : clazz.getDeclaredMethods()) {\n+            check(m);\n+        }\n+        for (Field f : clazz.getDeclaredFields()) {\n+            check(f);\n+        }\n+    }\n+\n+    static void check(Method method) throws ReflectiveOperationException {\n+        if (!method.isAnnotationPresent(CodeReflection.class)) return;\n+        Field field = method.getDeclaringClass().getDeclaredField(method.getName() + \"$op\");\n+        String found = canonicalizeModel(method, (String) field.get(null));\n+        IR ir = method.getAnnotation(IR.class);\n+        if (ir == null) {\n+            throw new AssertionError(\"No @IR annotation found on reflective method\");\n+        }\n+        String expected = canonicalizeModel(method, ir.value());\n+        if (!found.equals(expected)) {\n+            throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+        }\n+    }\n+\n+    static void check(Field field) throws ReflectiveOperationException {\n+        IR ir = field.getAnnotation(IR.class);\n+        if (ir == null) return;\n+        if (field.getType().equals(Quoted.class)) {\n+            \/\/ transitional\n+            Quoted quoted = (Quoted) field.get(null);\n+            String found = canonicalizeModel(field, getModelOfQuotedOp(quoted));\n+            String expected = canonicalizeModel(field, ir.value());\n+            if (!found.equals(expected)) {\n+                throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+            }\n+        } else if (Quotable.class.isAssignableFrom(field.getType())) {\n+            Quotable quotable = (Quotable) field.get(null);\n+            String found = canonicalizeModel(field, getModelOfQuotedOp(quotable.quoted()));\n+            String expected = canonicalizeModel(field, ir.value());\n+            if (!found.equals(expected)) {\n+                throw new AssertionError(String.format(\"Bad IR\\nFound:\\n%s\\n\\nExpected:\\n%s\", found, expected));\n+            }\n+        } else {\n+            throw new AssertionError(\"Field annotated with @IR should be of a quotable type (Quoted\/Quotable)\");\n+        }\n+    }\n+\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, Op o) {\n+        return canonicalizeModel(m, serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, String d) {\n+        Op o;\n+        try {\n+            o = OpParser.fromString(ExtendedOps.FACTORY, d).get(0);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(m.toString(), e);\n+        }\n+        return serialize(o);\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n+    }\n+\n+    static Op getModelOfQuotedOp(Quoted quoted) {\n+        return func(\"f\", VOID).body(fblock -> {\n+            CopyContext cc = fblock.context();\n+            for (Value cv : quoted.capturedValues().keySet()) {\n+                Block.Parameter p = fblock.parameter(cv.type());\n+                cc.mapValue(cv, p);\n+            }\n+\n+            Op qOp = quoted.op();\n+            \/\/ Associate the quoted ops ancestor body's entry block\n+            \/\/ with the function's entry block, thereby ensuring that\n+            \/\/ captured values mapped to the function's parameters\n+            \/\/ are reachable\n+            cc.mapBlock(qOp.ancestorBody().entryBlock(), fblock);\n+            fblock.op(qOp);\n+\n+            fblock.op(_return());\n+        });\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/CodeReflectionTester.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with conditional and\/or expressions.\n+ * @build ConditionalAndOrTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ConditionalAndOrTest\n+ *\/\n+\n+public class ConditionalAndOrTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ConditionalAndOrTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : boolean = java.cand\n+                    ()boolean -> {\n+                        %4 : int = var.load %2;\n+                        %5 : int = constant @\"1\";\n+                        %6 : boolean = gt %4 %5;\n+                        yield %6;\n+                    }\n+                    ()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"10\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    };\n+                %10 : Var<boolean> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1(int i) {\n+        boolean b = i > 1 && i < 10;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ConditionalAndOrTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : boolean = java.cor\n+                    ()boolean -> {\n+                        %4 : int = var.load %2;\n+                        %5 : int = constant @\"1\";\n+                        %6 : boolean = gt %4 %5;\n+                        yield %6;\n+                    }\n+                    ()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"10\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    };\n+                %10 : Var<boolean> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int i) {\n+        boolean b = i > 1 || i < 10;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ConditionalAndOrTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : boolean = java.cor\n+                    ()boolean -> {\n+                        %4 : boolean = java.cand\n+                            ()boolean -> {\n+                                %5 : int = var.load %2;\n+                                %6 : int = constant @\"1\";\n+                                %7 : boolean = gt %5 %6;\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : int = var.load %2;\n+                                %9 : int = constant @\"10\";\n+                                %10 : boolean = lt %8 %9;\n+                                yield %10;\n+                            };\n+                        yield %4;\n+                    }\n+                    ()boolean -> {\n+                        %11 : int = var.load %2;\n+                        %12 : int = constant @\"100\";\n+                        %13 : boolean = eq %11 %12;\n+                        yield %13;\n+                    };\n+                %14 : Var<boolean> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3(int i) {\n+        boolean b = i > 1 && i < 10 || i == 100;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalAndOrTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with conditional expressions.\n+ * @build ConditionalExpressionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ConditionalExpressionTest\n+ *\/\n+\n+public class ConditionalExpressionTest {\n+\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : int, %3 : int)void -> {\n+                %4 : Var<boolean> = var %1 @\"b\";\n+                %5 : Var<int> = var %2 @\"x\";\n+                %6 : Var<int> = var %3 @\"y\";\n+                %7 : int = java.cexpression\n+                    ^cond()boolean -> {\n+                        %8 : boolean = var.load %4;\n+                        yield %8;\n+                    }\n+                    ^truepart()int -> {\n+                        %9 : int = var.load %5;\n+                        yield %9;\n+                    }\n+                    ^falsepart()int -> {\n+                        %10 : int = var.load %6;\n+                        yield %10;\n+                    };\n+                %11 : Var<int> = var %7 @\"z\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test1(boolean b, int x, int y) {\n+        int z = b ? x : y;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : int, %3 : double)void -> {\n+                %4 : Var<boolean> = var %1 @\"b\";\n+                %5 : Var<int> = var %2 @\"x\";\n+                %6 : Var<double> = var %3 @\"y\";\n+                %7 : double = java.cexpression\n+                    ^cond()boolean -> {\n+                        %8 : boolean = var.load %4;\n+                        %9 : boolean = not %8;\n+                        yield %9;\n+                    }\n+                    ^truepart()double -> {\n+                        %10 : int = var.load %5;\n+                        %11 : double = conv %10;\n+                        yield %11;\n+                    }\n+                    ^falsepart()double -> {\n+                        %12 : double = var.load %6;\n+                        yield %12;\n+                    };\n+                %13 : Var<double> = var %7 @\"z\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test2(boolean b, int x, double y) {\n+        double z = !b ? x : y;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : int, %3 : double)void -> {\n+                %4 : Var<boolean> = var %1 @\"b\";\n+                %5 : Var<int> = var %2 @\"x\";\n+                %6 : Var<double> = var %3 @\"y\";\n+                %7 : java.util.function.Supplier<java.lang.Double> = java.cexpression\n+                    ^cond()boolean -> {\n+                        %8 : boolean = var.load %4;\n+                        yield %8;\n+                    }\n+                    ^truepart()java.util.function.Supplier<java.lang.Double> -> {\n+                        %9 : java.util.function.Supplier<java.lang.Double> = lambda ()java.lang.Double -> {\n+                            %10 : int = var.load %5;\n+                            %11 : double = conv %10;\n+                            %12 : java.lang.Double = invoke %11 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                            return %12;\n+                        };\n+                        yield %9;\n+                    }\n+                    ^falsepart()java.util.function.Supplier<java.lang.Double> -> {\n+                        %13 : java.util.function.Supplier<java.lang.Double> = lambda ()java.lang.Double -> {\n+                            %14 : double = var.load %6;\n+                            %15 : java.lang.Double = invoke %14 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                            return %15;\n+                        };\n+                        yield %13;\n+                    };\n+                %16 : Var<java.util.function.Supplier<java.lang.Double>> = var %7 @\"z\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test3(boolean b, int x, double y) {\n+        Supplier<Double> z = b ? () -> (double) x : () -> y;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ConditionalExpressionTest, %1 : boolean, %2 : boolean, %3 : int, %4 : double, %5 : double)void -> {\n+                %6 : Var<boolean> = var %1 @\"b1\";\n+                %7 : Var<boolean> = var %2 @\"b2\";\n+                %8 : Var<int> = var %3 @\"x\";\n+                %9 : Var<double> = var %4 @\"y\";\n+                %10 : Var<double> = var %5 @\"z\";\n+                %11 : double = java.cexpression\n+                    ^cond()boolean -> {\n+                        %12 : boolean = var.load %6;\n+                        yield %12;\n+                    }\n+                    ^truepart()double -> {\n+                        %13 : double = java.cexpression\n+                            ^cond()boolean -> {\n+                                %14 : boolean = var.load %7;\n+                                yield %14;\n+                            }\n+                            ^truepart()double -> {\n+                                %15 : int = var.load %8;\n+                                %16 : double = conv %15;\n+                                yield %16;\n+                            }\n+                            ^falsepart()double -> {\n+                                %17 : double = var.load %9;\n+                                yield %17;\n+                            };\n+                        yield %13;\n+                    }\n+                    ^falsepart()double -> {\n+                        %18 : double = var.load %10;\n+                        yield %18;\n+                    };\n+                %19 : Var<double> = var %11 @\"r\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test4(boolean b1, boolean b2, int x, double y, double z) {\n+        double r = b1 ? (b2 ? x : y) : z;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConditionalExpressionTest.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with constant values.\n+ * @build ConstantsTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ConstantsTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Function;\n+\n+public class ConstantsTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.String = constant @\"\";\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        String s = \"\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.String = constant @\"Hello World\";\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        String s = \"Hello World\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        String s = null;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"java.util.function.Function\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test4() {\n+        Class<?> s = Function.class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : ConstantsTest)void -> {\n+                %1 : int = constant @\"42\";\n+                %2 : byte = conv %1;\n+                %3 : Var<byte> = var %2 @\"v\";\n+                %4 : int = constant @\"-42\";\n+                %5 : byte = conv %4;\n+                var.store %3 %5;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test5() {\n+        byte v = 42;\n+        v = -42;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : ConstantsTest)void -> {\n+                %1 : int = constant @\"42\";\n+                %2 : short = conv %1;\n+                %3 : Var<short> = var %2 @\"v\";\n+                %4 : int = constant @\"-42\";\n+                %5 : short = conv %4;\n+                var.store %3 %5;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test6() {\n+        short v = 42;\n+        v = -42;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : ConstantsTest)void -> {\n+                %1 : int = constant @\"42\";\n+                %2 : Var<int> = var %1 @\"v\";\n+                %3 : int = constant @\"-42\";\n+                var.store %2 %3;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test7() {\n+        int v = 42;\n+        v = -42;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : ConstantsTest)void -> {\n+                %1 : long = constant @\"42\";\n+                %2 : Var<long> = var %1 @\"v\";\n+                %3 : long = constant @\"-42\";\n+                var.store %2 %3;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test8() {\n+        long v = 42L;\n+        v = -42L;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : ConstantsTest)void -> {\n+                %1 : float = constant @\"42.0\";\n+                %2 : Var<float> = var %1 @\"v\";\n+                %3 : float = constant @\"42.0\";\n+                %4 : float = neg %3;\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test9() {\n+        float v = 42.0f;\n+        v = -42.0f;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : ConstantsTest)void -> {\n+                %1 : double = constant @\"42.0\";\n+                %2 : Var<double> = var %1 @\"v\";\n+                %3 : double = constant @\"42.0\";\n+                %4 : double = neg %3;\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test10() {\n+        double v = 42.0;\n+        v = -42.0;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : ConstantsTest)void -> {\n+                %1 : char = constant @\"a\";\n+                %2 : Var<char> = var %1 @\"v\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test11() {\n+        char v = 'a';\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : ConstantsTest)void -> {\n+                %1 : boolean = constant @\"true\";\n+                %2 : Var<boolean> = var %1 @\"b\";\n+                %3 : boolean = constant @\"false\";\n+                var.store %2 %3;\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test12() {\n+        boolean b = true;\n+        b = false;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"float\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test13() {\n+        Class<?> s = float.class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"java.lang.String[]\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test14() {\n+        Class<?> s = String[].class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"java.lang.String[][]\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test15() {\n+        Class<?> s = String[][].class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"java.lang.String[][][]\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test16() {\n+        Class<?> s = String[][][].class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"boolean[]\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test17() {\n+        Class<?> s = boolean[].class;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : ConstantsTest)void -> {\n+                %1 : java.lang.Class = constant @\"boolean[][][]\";\n+                %2 : Var<java.lang.Class<+<java.lang.Object>>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    void test18() {\n+        Class<?> s = boolean[][][].class;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ConstantsTest.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for non-denotable types in IR type descriptors\n+ * @build DenotableTypesTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester DenotableTypesTest\n+ *\/\n+\n+public class DenotableTypesTest {\n+    static <X extends Number & Runnable> X m1(X x) { return null; }\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" ()void -> {\n+                  %0 : java.lang.Number = constant @null;\n+                  %1 : java.lang.Number = invoke %0 @\"DenotableTypesTest::m1(java.lang.Number)java.lang.Number\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test1() {\n+        m1(null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" ()void -> {\n+                  %0 : int = constant @\"1\";\n+                  %1 : java.lang.Integer = invoke %0 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                  %2 : double = constant @\"3.0\";\n+                  %3 : java.lang.Double = invoke %2 @\"java.lang.Double::valueOf(double)java.lang.Double\";\n+                  %4 : java.util.List<+<java.lang.Number>> = invoke %1 %3 @\"java.util.List::of(java.lang.Object, java.lang.Object)java.util.List\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test2() {\n+        List.of(1, 3d); \/\/ infinite type! (List<Object & Serializable & Comparable<...>>)\n+    }\n+\n+    static <X extends Throwable> X m2(X x) throws X { return null; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" ()void -> {\n+                %0 : java.lang.RuntimeException = constant @null;\n+                %1 : java.lang.RuntimeException = invoke %0 @\"DenotableTypesTest::m2(java.lang.Throwable)java.lang.Throwable\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test3() { \/\/ @@@ cast?\n+        m2(null);\n+    }\n+\n+    interface A { }\n+    interface B { }\n+    static class C implements A, B { }\n+    static class D implements A, B { }\n+\n+    static <Z> Z pick(Z z1, Z z2) { return null; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" ()void -> {\n+                  %0 : java.lang.Object = constant @null;\n+                  %1 : DenotableTypesTest$C = cast %0 @\"DenotableTypesTest$C\";\n+                  %2 : java.lang.Object = constant @null;\n+                  %3 : DenotableTypesTest$D = cast %2 @\"DenotableTypesTest$D\";\n+                  %4 : DenotableTypesTest$A = invoke %1 %3 @\"DenotableTypesTest::pick(java.lang.Object, java.lang.Object)java.lang.Object\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test4() { \/\/ @@@ cast?\n+        pick((C)null, (D)null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" ()void -> {\n+                  %0 : java.util.List<+<java.lang.Number>> = constant @null;\n+                  %1 : Var<java.util.List<+<java.lang.Number>>> = var %0 @\"l\";\n+                  %2 : java.util.List<+<java.lang.Number>> = var.load %1;\n+                  %3 : int = constant @\"0\";\n+                  %4 : java.lang.Number = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test5() { \/\/ @@@ cast?\n+        List<? extends Number> l = null;\n+        l.get(0);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" ()void -> {\n+                  %0 : java.util.List<-<java.lang.Number>> = constant @null;\n+                  %1 : Var<java.util.List<-<java.lang.Number>>> = var %0 @\"l\";\n+                  %2 : java.util.List<-<java.lang.Number>> = var.load %1;\n+                  %3 : int = constant @\"0\";\n+                  %4 : java.lang.Object = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test6() {\n+        List<? super Number> l = null;\n+        l.get(0);\n+    }\n+\n+    static void consume(Runnable r) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" ()void -> {\n+                  %0 : #DenotableTypesTest::test7()void::X<java.lang.Object> = constant @null;\n+                  %1 : Var<#DenotableTypesTest::test7()void::X<java.lang.Object>> = var %0 @\"x\";\n+                  %2 : #DenotableTypesTest::test7()void::X<java.lang.Object> = var.load %1;\n+                  %3 : java.lang.Runnable = cast %2 @\"java.lang.Runnable\";\n+                  invoke %3 @\"DenotableTypesTest::consume(java.lang.Runnable)void\";\n+                  return;\n+            };\n+            \"\"\")\n+    static <X extends Object & Runnable> void test7() {\n+        X x = null;\n+        consume(x);\n+    }\n+\n+    interface Adder<X> {\n+        void add(Adder<X> adder);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>>)void -> {\n+                  %1 : Var<java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>>> = var %0 @\"list\";\n+                  %2 : java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>> = var.load %1;\n+                  %3 : int = constant @\"0\";\n+                  %4 : DenotableTypesTest$Adder<java.lang.Integer> = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  %5 : java.util.List<+<DenotableTypesTest$Adder<java.lang.Integer>>> = var.load %1;\n+                  %6 : int = constant @\"1\";\n+                  %7 : DenotableTypesTest$Adder<java.lang.Integer> = invoke %5 %6 @\"java.util.List::get(int)java.lang.Object\";\n+                  invoke %4 %7 @\"DenotableTypesTest$Adder::add(DenotableTypesTest$Adder)void\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test8(List<? extends Adder<Integer>> list) {\n+        list.get(0).add(list.get(1));\n+    }\n+\n+    static class Box<X> {\n+        X x;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : java.util.List<+<DenotableTypesTest$Box<java.lang.Integer>>>)void -> {\n+                  %1 : Var<java.util.List<+<DenotableTypesTest$Box<java.lang.Integer>>>> = var %0 @\"list\";\n+                  %2 : java.util.List<+<DenotableTypesTest$Box<java.lang.Integer>>> = var.load %1;\n+                  %3 : int = constant @\"0\";\n+                  %4 : DenotableTypesTest$Box<java.lang.Integer> = invoke %2 %3 @\"java.util.List::get(int)java.lang.Object\";\n+                  %5 : java.lang.Integer = field.load %4 @\"DenotableTypesTest$Box::x()java.lang.Object\";\n+                  %6 : Var<java.lang.Integer> = var %5 @\"i\";\n+                  return;\n+            };\n+            \"\"\")\n+    static void test9(List<? extends Box<Integer>> list) {\n+        Integer i = list.get(0).x;\n+    }\n+\n+    interface E {\n+        void m();\n+    }\n+\n+    static class XA extends Exception implements E {\n+        public void m() { }\n+    }\n+\n+    static class XB extends Exception implements E {\n+        public void m() { }\n+    }\n+\n+    static void g() throws XA, XB { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" ()void -> {\n+                  java.try\n+                      ()void -> {\n+                          invoke @\"DenotableTypesTest::g()void\";\n+                          yield;\n+                      }\n+                      (%0 : java.lang.Exception)void -> {\n+                          %1 : Var<java.lang.Exception> = var %0 @\"x\";\n+                          %2 : java.lang.Exception = var.load %1;\n+                          %3 : DenotableTypesTest$E = cast %2 @\"DenotableTypesTest$E\";\n+                          invoke %3 @\"DenotableTypesTest$E::m()void\";\n+                          yield;\n+                      };\n+                  return;\n+            };\n+            \"\"\")\n+    static void test10() {\n+        try {\n+            g();\n+        } catch (XA | XB x) {\n+            x.m();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.runtime.CodeReflection;\n+\n+import static java.lang.constant.DirectMethodHandleDesc.Kind;\n+import static java.lang.constant.DirectMethodHandleDesc.Kind.VIRTUAL;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with enum access.\n+ * @build EnumAccessTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester EnumAccessTest\n+ *\/\n+\n+public class EnumAccessTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : EnumAccessTest)java.lang.constant.DirectMethodHandleDesc$Kind -> {\n+                %1 : java.lang.constant.DirectMethodHandleDesc$Kind = field.load @\"java.lang.constant.DirectMethodHandleDesc$Kind::VIRTUAL()java.lang.constant.DirectMethodHandleDesc$Kind\";\n+                return %1;\n+            };\n+            \"\"\")\n+    DirectMethodHandleDesc.Kind test1() {\n+        return DirectMethodHandleDesc.Kind.VIRTUAL;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : EnumAccessTest)java.lang.constant.DirectMethodHandleDesc$Kind -> {\n+                %1 : java.lang.constant.DirectMethodHandleDesc$Kind = field.load @\"java.lang.constant.DirectMethodHandleDesc$Kind::VIRTUAL()java.lang.constant.DirectMethodHandleDesc$Kind\";\n+                return %1;\n+            };\n+            \"\"\")\n+    DirectMethodHandleDesc.Kind test2() {\n+        return Kind.VIRTUAL;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : EnumAccessTest)java.lang.constant.DirectMethodHandleDesc$Kind -> {\n+                %1 : java.lang.constant.DirectMethodHandleDesc$Kind = field.load @\"java.lang.constant.DirectMethodHandleDesc$Kind::VIRTUAL()java.lang.constant.DirectMethodHandleDesc$Kind\";\n+                return %1;\n+            };\n+            \"\"\")\n+    DirectMethodHandleDesc.Kind test3() {\n+        return VIRTUAL;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/EnumAccessTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,666 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.lang.runtime.CodeReflection;\n+import java.util.Spliterator;\n+import java.util.Spliterator.OfInt;\n+\n+import static java.lang.System.out;\n+import static java.util.Spliterator.OfInt.*;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with field access.\n+ * @build FieldAccessTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester FieldAccessTest\n+ *\/\n+\n+public class FieldAccessTest {\n+    static int s_f;\n+    int f;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %1 @\"FieldAccessTest::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                field.store %0 %2 @\"FieldAccessTest::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        s_f = 1;\n+        f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1_1\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %6 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1_1() {\n+        f += 1;\n+        s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %0 %1 @\"FieldAccessTest::f()int\";\n+                field.store %1 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        s_f = f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_1\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %0 %1 @\"FieldAccessTest::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2_1() {\n+        this.f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_2\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test2_2() {\n+        return this.f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %2 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %3 : int = add %1 %2;\n+                return %3;\n+            };\n+            \"\"\")\n+    int test3() {\n+        return s_f + f;\n+    }\n+\n+    static class A {\n+        B b;\n+    }\n+\n+    static class B {\n+        C c;\n+    }\n+\n+    static class C {\n+        int f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : FieldAccessTest, %1 : FieldAccessTest$A)void -> {\n+                %2 : Var<FieldAccessTest$A> = var %1 @\"a\";\n+                %3 : FieldAccessTest$A = var.load %2;\n+                %4 : FieldAccessTest$B = field.load %3 @\"FieldAccessTest$A::b()FieldAccessTest$B\";\n+                %5 : FieldAccessTest$C = field.load %4 @\"FieldAccessTest$B::c()FieldAccessTest$C\";\n+                %6 : int = constant @\"1\";\n+                field.store %5 %6 @\"FieldAccessTest$C::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4(A a) {\n+        a.b.c.f = 1;\n+    }\n+\n+    static class X {\n+        int f;\n+        static int s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : FieldAccessTest)int -> {\n+                %1 : int = field.load @\"FieldAccessTest$X::s_f()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test5() {\n+        return X.s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = constant @\"1\";\n+                field.store %1 @\"FieldAccessTest$X::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        X.s_f = 1;\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %6 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        f += 1;\n+        s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %6 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        this.f += 1;\n+        this.s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"FieldAccessTest$X::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %3 @\"FieldAccessTest$X::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9() {\n+        X.s_f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                field.store %3 @\"FieldAccessTest::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10() {\n+        s_f = f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : FieldAccessTest, %1 : FieldAccessTest$A)void -> {\n+                %2 : Var<FieldAccessTest$A> = var %1 @\"a\";\n+                %3 : FieldAccessTest$A = var.load %2;\n+                %4 : FieldAccessTest$B = field.load %3 @\"FieldAccessTest$A::b()FieldAccessTest$B\";\n+                %5 : FieldAccessTest$C = field.load %4 @\"FieldAccessTest$B::c()FieldAccessTest$C\";\n+                %6 : int = field.load %5 @\"FieldAccessTest$C::f()int\";\n+                %7 : int = constant @\"1\";\n+                %8 : int = add %6 %7;\n+                field.store %5 %8 @\"FieldAccessTest$C::f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(A a) {\n+        a.b.c.f += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %1 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %5 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test12() {\n+        int x = f++;\n+        int y = f--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %1 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %5 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13() {\n+        int x = this.f++;\n+        int y = this.f--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %3 @\"FieldAccessTest::s_f()int\";\n+                %4 : Var<int> = var %1 @\"x\";\n+                %5 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %7 @\"FieldAccessTest::s_f()int\";\n+                %8 : Var<int> = var %5 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14() {\n+        int x = s_f++;\n+        int y = s_f--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : FieldAccessTest, %1 : FieldAccessTest$X)void -> {\n+                %2 : Var<FieldAccessTest$X> = var %1 @\"h\";\n+                %3 : FieldAccessTest$X = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$X::f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %3 %6 @\"FieldAccessTest$X::f()int\";\n+                %7 : Var<int> = var %4 @\"x\";\n+                %8 : FieldAccessTest$X = var.load %2;\n+                %9 : int = field.load %8 @\"FieldAccessTest$X::f()int\";\n+                %10 : int = constant @\"1\";\n+                %11 : int = sub %9 %10;\n+                field.store %8 %11 @\"FieldAccessTest$X::f()int\";\n+                %12 : Var<int> = var %9 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(X h) {\n+        int x = h.f++;\n+        int y = h.f--;\n+    }\n+\n+\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %3 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16() {\n+        int x = ++f;\n+        int y = --f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %0 %3 @\"FieldAccessTest::f()int\";\n+                %4 : Var<int> = var %3 @\"x\";\n+                %5 : int = field.load %0 @\"FieldAccessTest::f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %0 %7 @\"FieldAccessTest::f()int\";\n+                %8 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17() {\n+        int x = ++this.f;\n+        int y = --this.f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %2 : int = constant @\"1\";\n+                %3 : int = add %1 %2;\n+                field.store %3 @\"FieldAccessTest::s_f()int\";\n+                %4 : Var<int> = var %3 @\"x\";\n+                %5 : int = field.load @\"FieldAccessTest::s_f()int\";\n+                %6 : int = constant @\"1\";\n+                %7 : int = sub %5 %6;\n+                field.store %7 @\"FieldAccessTest::s_f()int\";\n+                %8 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18() {\n+        int x = ++s_f;\n+        int y = --s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test19\" (%0 : FieldAccessTest, %1 : FieldAccessTest$X)void -> {\n+                %2 : Var<FieldAccessTest$X> = var %1 @\"h\";\n+                %3 : FieldAccessTest$X = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$X::f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %3 %6 @\"FieldAccessTest$X::f()int\";\n+                %7 : Var<int> = var %6 @\"x\";\n+                %8 : FieldAccessTest$X = var.load %2;\n+                %9 : int = field.load %8 @\"FieldAccessTest$X::f()int\";\n+                %10 : int = constant @\"1\";\n+                %11 : int = sub %9 %10;\n+                field.store %8 %11 @\"FieldAccessTest$X::f()int\";\n+                %12 : Var<int> = var %11 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test19(X h) {\n+        int x = ++h.f;\n+        int y = --h.f;\n+    }\n+\n+    static class Y extends X {\n+        int yf;\n+        static int s_yf;\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test\" (%0 : FieldAccessTest$Y)void -> {\n+                    %1 : int = field.load %0 @\"FieldAccessTest$Y::f()int\";\n+                    %2 : Var<int> = var %1 @\"x\";\n+                    %3 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                    var.store %2 %3;\n+                    return;\n+                };\n+                \"\"\")\n+        void test() {\n+            int x = f;\n+            x = s_f;\n+        }\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test2\" (%0 : FieldAccessTest$Y)void -> {\n+                    %1 : int = constant @\"1\";\n+                    field.store %0 %1 @\"FieldAccessTest$Y::f()int\";\n+                    %2 : int = constant @\"1\";\n+                    field.store %2 @\"FieldAccessTest$Y::s_f()int\";\n+                    return;\n+                };\n+                \"\"\")\n+        void test2() {\n+            f = 1;\n+            s_f = 1;\n+        }\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test3\" (%0 : FieldAccessTest$Y)void -> {\n+                    %1 : int = field.load %0 @\"FieldAccessTest$Y::f()int\";\n+                    %2 : int = constant @\"1\";\n+                    %3 : int = add %1 %2;\n+                    field.store %0 %3 @\"FieldAccessTest$Y::f()int\";\n+                    %4 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                    %5 : int = constant @\"1\";\n+                    %6 : int = add %4 %5;\n+                    field.store %6 @\"FieldAccessTest$Y::s_f()int\";\n+                    return;\n+                };\n+                \"\"\")\n+        void test3() {\n+            f++;\n+            s_f++;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0 : FieldAccessTest, %1 : FieldAccessTest$Y)void -> {\n+                %2 : Var<FieldAccessTest$Y> = var %1 @\"y\";\n+                %3 : FieldAccessTest$Y = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$Y::f()int\";\n+                %5 : Var<int> = var %4 @\"x\";\n+                %6 : FieldAccessTest$Y = var.load %2;\n+                %7 : int = field.load %6 @\"FieldAccessTest$Y::yf()int\";\n+                var.store %5 %7;\n+                %8 : FieldAccessTest$Y = var.load %2;\n+                %9 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                var.store %5 %9;\n+                %10 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                var.store %5 %10;\n+                %11 : FieldAccessTest$Y = var.load %2;\n+                %12 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                var.store %5 %12;\n+                %13 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                var.store %5 %13;\n+                return;\n+            };\n+            \"\"\")\n+    void test20(Y y) {\n+        int x = y.f;\n+        x = y.yf;\n+        x = y.s_yf;\n+        x = Y.s_yf;\n+        x = y.s_f;\n+        x = Y.s_f;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0 : FieldAccessTest, %1 : FieldAccessTest$Y)void -> {\n+                %2 : Var<FieldAccessTest$Y> = var %1 @\"y\";\n+                %3 : FieldAccessTest$Y = var.load %2;\n+                %4 : int = constant @\"1\";\n+                field.store %3 %4 @\"FieldAccessTest$Y::f()int\";\n+                %5 : FieldAccessTest$Y = var.load %2;\n+                %6 : int = constant @\"1\";\n+                field.store %5 %6 @\"FieldAccessTest$Y::yf()int\";\n+                %7 : FieldAccessTest$Y = var.load %2;\n+                %8 : int = constant @\"1\";\n+                field.store %8 @\"FieldAccessTest$Y::s_yf()int\";\n+                %9 : int = constant @\"1\";\n+                field.store %9 @\"FieldAccessTest$Y::s_yf()int\";\n+                %10 : FieldAccessTest$Y = var.load %2;\n+                %11 : int = constant @\"1\";\n+                field.store %11 @\"FieldAccessTest$Y::s_f()int\";\n+                %12 : int = constant @\"1\";\n+                field.store %12 @\"FieldAccessTest$Y::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21(Y y) {\n+        y.f = 1;\n+        y.yf = 1;\n+        y.s_yf = 1;\n+        Y.s_yf = 1;\n+        y.s_f = 1;\n+        Y.s_f = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+          func @\"test22\" (%0 : FieldAccessTest, %1 : FieldAccessTest$Y)void -> {\n+                %2 : Var<FieldAccessTest$Y> = var %1 @\"y\";\n+                %3 : FieldAccessTest$Y = var.load %2;\n+                %4 : int = field.load %3 @\"FieldAccessTest$Y::f()int\";\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                field.store %3 %6 @\"FieldAccessTest$Y::f()int\";\n+                %7 : FieldAccessTest$Y = var.load %2;\n+                %8 : int = field.load %7 @\"FieldAccessTest$Y::yf()int\";\n+                %9 : int = constant @\"1\";\n+                %10 : int = add %8 %9;\n+                field.store %7 %10 @\"FieldAccessTest$Y::yf()int\";\n+                %11 : FieldAccessTest$Y = var.load %2;\n+                %12 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                %13 : int = constant @\"1\";\n+                %14 : int = add %12 %13;\n+                field.store %14 @\"FieldAccessTest$Y::s_yf()int\";\n+                %15 : int = field.load @\"FieldAccessTest$Y::s_yf()int\";\n+                %16 : int = constant @\"1\";\n+                %17 : int = add %15 %16;\n+                field.store %17 @\"FieldAccessTest$Y::s_yf()int\";\n+                %18 : FieldAccessTest$Y = var.load %2;\n+                %19 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                %20 : int = constant @\"1\";\n+                %21 : int = add %19 %20;\n+                field.store %21 @\"FieldAccessTest$Y::s_f()int\";\n+                %22 : int = field.load @\"FieldAccessTest$Y::s_f()int\";\n+                %23 : int = constant @\"1\";\n+                %24 : int = add %22 %23;\n+                field.store %24 @\"FieldAccessTest$Y::s_f()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test22(Y y) {\n+        y.f++;\n+        y.yf++;\n+        y.s_yf++;\n+        Y.s_yf++;\n+        y.s_f++;\n+        Y.s_f++;\n+    }\n+\n+    \/\/ @@@ Should propagate as constant value?\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test23\" (%0 : FieldAccessTest)void -> {\n+                %1 : int = field.load @\"java.util.Spliterator$OfInt::CONCURRENT()int\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = field.load @\"java.util.Spliterator$OfInt::CONCURRENT()int\";\n+                var.store %2 %3;\n+                %4 : int = field.load @\"java.util.Spliterator$OfInt::CONCURRENT()int\";\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    void test23() {\n+        int x = Spliterator.OfInt.CONCURRENT;\n+        x = OfInt.CONCURRENT;\n+        x = CONCURRENT;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test24\" (%0 : FieldAccessTest)void -> {\n+                %1 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %2 : Var<java.io.PrintStream> = var %1 @\"ps\";\n+                return;\n+            };\n+            \"\"\")\n+    void test24() {\n+        PrintStream ps = out;\n+    }\n+\n+    static class Box<T> {\n+        public T v;\n+\n+        public Box(T v) {\n+            this.v = v;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test25\" ()void -> {\n+                    %0 : java.lang.String = constant @\"abc\";\n+                    %1 : FieldAccessTest$Box<java.lang.String> = new %0 @\"func<FieldAccessTest$Box, java.lang.Object>\";\n+                    %2 : Var<FieldAccessTest$Box<java.lang.String>> = var %1 @\"b\";\n+                    %3 : FieldAccessTest$Box<java.lang.String> = var.load %2;\n+                    %4 : java.lang.String = field.load %3 @\"FieldAccessTest$Box::v()java.lang.Object\";\n+                    %5 : Var<java.lang.String> = var %4 @\"s\";\n+                    return;\n+            };\n+            \"\"\")\n+    static void test25() {\n+        Box<String> b = new Box<>(\"abc\");\n+        String s = b.v;\n+    }\n+\n+    \/\/@@@ unqualified access to field of generic type needs to be tested\n+    \/\/ waiting for a new way of modeling types, so that type variables are captured in the IR\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/FieldAccessTest.java","additions":666,"deletions":0,"binary":false,"changes":666,"status":"added"},{"patch":"@@ -0,0 +1,600 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with for loops.\n+ * @build ForLoopTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ForLoopTest\n+ *\/\n+\n+public class ForLoopTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ForLoopTest, %1 : java.util.List<java.util.List<java.lang.String>>)void -> {\n+              %2 : Var<java.util.List<java.util.List<java.lang.String>>> = var %1 @\"ll\";\n+              java.enhancedFor\n+                  ^expr()java.util.List<java.util.List<java.lang.String>> -> {\n+                      %3 : java.util.List<java.util.List<java.lang.String>> = var.load %2;\n+                      yield %3;\n+                  }\n+                  ^def(%4 : java.util.List<java.lang.String>)Var<java.util.List<java.lang.String>> -> {\n+                      %5 : Var<java.util.List<java.lang.String>> = var %4 @\"l\";\n+                      yield %5;\n+                  }\n+                  ^body(%6 : Var<java.util.List<java.lang.String>>)void -> {\n+                      java.enhancedFor\n+                          ^expr()java.util.List<java.lang.String> -> {\n+                              %7 : java.util.List<java.lang.String> = var.load %6;\n+                              yield %7;\n+                          }\n+                          ^def(%8 : java.lang.String)Var<java.lang.String> -> {\n+                              %9 : Var<java.lang.String> = var %8 @\"s\";\n+                              yield %9;\n+                          }\n+                          ^body(%10 : Var<java.lang.String>)void -> {\n+                              %11 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                              %12 : java.lang.String = var.load %10;\n+                              invoke %11 %12 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                              java.continue;\n+                          };\n+                      java.continue;\n+                  };\n+              return;\n+            };\n+            \"\"\")\n+    void test1(List<List<String>> ll) {\n+        for (List<String> l : ll) {\n+            for (String s : l) {\n+                System.out.println(s);\n+            }\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : ForLoopTest, %1 : java.util.List<java.lang.String>)void -> {\n+                %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+                java.enhancedFor\n+                    ^expr()java.util.List<java.lang.String> -> {\n+                        %3 : java.util.List<java.lang.String> = var.load %2;\n+                        %4 : java.util.stream.Stream<java.lang.String> = invoke %3 @\"java.util.List::stream()java.util.stream.Stream\";\n+                        %5 : java.util.function.Predicate<java.lang.String> = lambda (%6 : java.lang.String)boolean -> {\n+                            %7 : Var<java.lang.String> = var %6 @\"s\";\n+                            %8 : java.lang.String = var.load %7;\n+                            %9 : int = invoke %8 @\"java.lang.String::length()int\";\n+                            %10 : int = constant @\"10\";\n+                            %11 : boolean = lt %9 %10;\n+                            return %11;\n+                        };\n+                        %12 : java.util.stream.Stream<java.lang.String> = invoke %4 %5 @\"java.util.stream.Stream::filter(java.util.function.Predicate)java.util.stream.Stream\";\n+                        %13 : java.util.List<java.lang.String> = invoke %12 @\"java.util.stream.Stream::toList()java.util.List\";\n+                        yield %13;\n+                    }\n+                    ^def(%14 : java.lang.String)Var<java.lang.String> -> {\n+                        %15 : Var<java.lang.String> = var %14 @\"s\";\n+                        yield %15;\n+                    }\n+                    ^body(%16 : Var<java.lang.String>)void -> {\n+                        %17 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %18 : java.lang.String = var.load %16;\n+                        invoke %17 %18 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2(List<String> l) {\n+        for (String s : l.stream().filter(s -> s.length() < 10).toList()) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_1\" (%0 : ForLoopTest, %1 : java.util.List<java.lang.String>)void -> {\n+              %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+              java.enhancedFor\n+                  ^expr()java.util.List<java.lang.String> -> {\n+                      %3 : java.util.List<java.lang.String> = var.load %2;\n+                      yield %3;\n+                  }\n+                  ^def(%4 : java.lang.String)Var<java.lang.String> -> {\n+                      %5 : Var<java.lang.String> = var %4 @\"s\";\n+                      yield %5;\n+                  }\n+                  ^body(%6 : Var<java.lang.String>)void -> {\n+                      java.continue;\n+                  };\n+              return;\n+            };\n+            \"\"\")\n+    void test2_1(List<String> l) {\n+        for (String s : l);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2_2\" (%0 : ForLoopTest, %1 : java.util.List<java.lang.String>)java.lang.String -> {\n+              %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+              java.enhancedFor\n+                  ^expr()java.util.List<java.lang.String> -> {\n+                      %3 : java.util.List<java.lang.String> = var.load %2;\n+                      yield %3;\n+                  }\n+                  ^def(%4 : java.lang.String)Var<java.lang.String> -> {\n+                      %5 : Var<java.lang.String> = var %4 @\"s\";\n+                      yield %5;\n+                  }\n+                  ^body(%6 : Var<java.lang.String>)void -> {\n+                      %7 : java.lang.String = var.load %6;\n+                      return %7;\n+                  };\n+              %8 : java.lang.String = constant @\"\";\n+              return %8;\n+            };\n+            \"\"\")\n+    String test2_2(List<String> l) {\n+        for (String s : l) {\n+            return s;\n+        }\n+        return \"\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : int = var.load %11;\n+                        invoke %12 %13 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        for (int i = 0; i < 10; i++) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3_1\" (%0 : ForLoopTest)int -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        %12 : int = var.load %11;\n+                        return %12;\n+                    };\n+                %13 : int = constant @\"-1\";\n+                return %13;\n+            };\n+            \"\"\")\n+    int test3_1() {\n+        for (int i = 0; i < 10; i++) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : int = var.load %11;\n+                        invoke %12 %13 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        for (int i = 0; i < 10; i = i + 1)\n+            System.out.println(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : int = var.load %3;\n+                        %5 : int = constant @\"10\";\n+                        %6 : boolean = lt %4 %5;\n+                        yield %6;\n+                    }\n+                    ^update(%7 : Var<int>)void -> {\n+                        %8 : int = var.load %7;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %7 %10;\n+                        yield;\n+                    }\n+                    ^body(%11 : Var<int>)void -> {\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        for (int i = 0; i < 10; i = i + 1);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : ForLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.for\n+                    ^init()void -> {\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"10\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^update()void -> {\n+                        %6 : int = var.load %2;\n+                        %7 : int = constant @\"1\";\n+                        %8 : int = add %6 %7;\n+                        var.store %2 %8;\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        %9 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %10 : int = var.load %2;\n+                        invoke %9 %10 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        int i = 0;\n+        for (; i < 10; i = i + 1) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : ForLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.for\n+                    ^init()void -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : int = add %3 %4;\n+                        var.store %2 %5;\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %6 : int = var.load %2;\n+                        %7 : int = constant @\"10\";\n+                        %8 : boolean = lt %6 %7;\n+                        yield %8;\n+                    }\n+                    ^update()void -> {\n+                        %9 : int = var.load %2;\n+                        %10 : int = constant @\"1\";\n+                        %11 : int = add %9 %10;\n+                        var.store %2 %11;\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        %12 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %13 : int = var.load %2;\n+                        invoke %12 %13 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        int i = 0;\n+        for (i = i + 1; i < 10; i = i + 1) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : boolean = constant @\"true\";\n+                        yield %4;\n+                    }\n+                    ^update(%5 : Var<int>)void -> {\n+                        %6 : int = var.load %5;\n+                        %7 : int = constant @\"1\";\n+                        %8 : int = add %6 %7;\n+                        var.store %5 %8;\n+                        yield;\n+                    }\n+                    ^body(%9 : Var<int>)void -> {\n+                        %10 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %11 : int = var.load %9;\n+                        invoke %10 %11 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        for (int i = 0; ; i = i + 1) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        yield %2;\n+                    }\n+                    ^cond(%3 : Var<int>)boolean -> {\n+                        %4 : boolean = constant @\"true\";\n+                        yield %4;\n+                    }\n+                    ^update(%5 : Var<int>)void -> {\n+                        yield;\n+                    }\n+                    ^body(%6 : Var<int>)void -> {\n+                        %7 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %8 : int = var.load %6;\n+                        invoke %7 %8 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test9() {\n+        for (int i = 0; ; ) {\n+            System.out.println(i);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()void -> {\n+                        yield;\n+                    }\n+                    ^cond()boolean -> {\n+                        %1 : boolean = constant @\"true\";\n+                        yield %1;\n+                    }\n+                    ^update()void -> {\n+                        yield;\n+                    }\n+                    ^body()void -> {\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test10() {\n+        for (; ; ) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : ForLoopTest)void -> {\n+                java.for\n+                    ^init()Tuple<Var<int>, Var<int>> -> {\n+                        %1 : int = constant @\"0\";\n+                        %2 : Var<int> = var %1 @\"i\";\n+                        %3 : int = constant @\"0\";\n+                        %4 : Var<int> = var %3 @\"j\";\n+                        %5 : Tuple<Var<int>, Var<int>> = tuple %2 %4;\n+                        yield %5;\n+                    }\n+                    ^cond(%6 : Var<int>, %7 : Var<int>)boolean -> {\n+                        %8 : boolean = java.cand\n+                            ()boolean -> {\n+                                %9 : int = var.load %6;\n+                                %10 : int = constant @\"10\";\n+                                %11 : boolean = lt %9 %10;\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %12 : int = var.load %7;\n+                                %13 : int = constant @\"20\";\n+                                %14 : boolean = lt %12 %13;\n+                                yield %14;\n+                            };\n+                        yield %8;\n+                    }\n+                    ^update(%15 : Var<int>, %16 : Var<int>)void -> {\n+                        %17 : int = var.load %15;\n+                        %18 : int = constant @\"1\";\n+                        %19 : int = add %17 %18;\n+                        var.store %15 %19;\n+                        %20 : int = var.load %16;\n+                        %21 : int = constant @\"2\";\n+                        %22 : int = add %20 %21;\n+                        var.store %16 %22;\n+                        yield;\n+                    }\n+                    ^body(%23 : Var<int>, %24 : Var<int>)void -> {\n+                        %25 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %26 : int = var.load %23;\n+                        invoke %25 %26 @\"java.io.PrintStream::println(int)void\";\n+                        %27 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %28 : int = var.load %24;\n+                        invoke %27 %28 @\"java.io.PrintStream::println(int)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test11() {\n+        for (int i = 0, j = 0; i < 10 && j < 20; i = i + 1, j = j + 2) {\n+            System.out.println(i);\n+            System.out.println(j);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : ForLoopTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"r\";\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %3 : int = constant @\"0\";\n+                        %4 : Var<int> = var %3 @\"i\";\n+                        yield %4;\n+                    }\n+                    ^cond(%5 : Var<int>)boolean -> {\n+                        %6 : int = var.load %5;\n+                        %7 : int = constant @\"10\";\n+                        %8 : boolean = lt %6 %7;\n+                        yield %8;\n+                    }\n+                    ^update(%9 : Var<int>)void -> {\n+                        %10 : int = var.load %9;\n+                        %11 : int = constant @\"1\";\n+                        %12 : int = add %10 %11;\n+                        var.store %9 %12;\n+                        yield;\n+                    }\n+                    ^body(%13 : Var<int>)void -> {\n+                        java.if\n+                            ()boolean -> {\n+                                %14 : int = var.load %2;\n+                                %15 : int = constant @\"0\";\n+                                %16 : boolean = eq %14 %15;\n+                                yield %16;\n+                            }\n+                            ^then()void -> {\n+                                java.break;\n+                            }\n+                            ^else_if()boolean -> {\n+                                %17 : int = var.load %2;\n+                                %18 : int = constant @\"1\";\n+                                %19 : boolean = eq %17 %18;\n+                                yield %19;\n+                            }\n+                            ^then()void -> {\n+                                java.continue;\n+                            }\n+                            ^else()void -> {\n+                                yield;\n+                            };\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int r) {\n+        for (int i = 0; i < 10; i++) {\n+            if (r == 0) {\n+                break;\n+            } else if (r == 1) {\n+                continue;\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ForLoopTest.java","additions":600,"deletions":0,"binary":false,"changes":600,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.*;\n+\n+@Target({ElementType.METHOD, ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface IR {\n+    String value();\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/IR.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with if statements.\n+ * @build IfTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester IfTest\n+ *\/\n+\n+public class IfTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        %7 : int = constant @\"2\";\n+                        var.store %2 %7;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        } else {\n+            i = 2;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else_if()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"2\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    }\n+                    ^then()void -> {\n+                        %10 : int = constant @\"2\";\n+                        var.store %2 %10;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        } else if (i < 2) {\n+            i = 2;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : IfTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.if\n+                    ()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"1\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^then()void -> {\n+                        %6 : int = constant @\"1\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^else_if()boolean -> {\n+                        %7 : int = var.load %2;\n+                        %8 : int = constant @\"2\";\n+                        %9 : boolean = lt %7 %8;\n+                        yield %9;\n+                    }\n+                    ^then()void -> {\n+                        %10 : int = constant @\"2\";\n+                        var.store %2 %10;\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        %11 : int = constant @\"3\";\n+                        var.store %2 %11;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4(int i) {\n+        if (i < 1) {\n+            i = 1;\n+        } else if (i < 2) {\n+            i = 2;\n+        } else {\n+            i = 3;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : IfTest, %1 : int)int -> {\n+              %2 : Var<int> = var %1 @\"i\";\n+              java.if\n+                  ()boolean -> {\n+                      %3 : int = var.load %2;\n+                      %4 : int = constant @\"1\";\n+                      %5 : boolean = lt %3 %4;\n+                      yield %5;\n+                  }\n+                  ^then()void -> {\n+                      %6 : int = constant @\"1\";\n+                      return %6;\n+                  }\n+                  ^else_if()boolean -> {\n+                      %7 : int = var.load %2;\n+                      %8 : int = constant @\"2\";\n+                      %9 : boolean = lt %7 %8;\n+                      yield %9;\n+                  }\n+                  ^then()void -> {\n+                      %10 : int = constant @\"2\";\n+                      return %10;\n+                  }\n+                  ^else()void -> {\n+                      %11 : int = constant @\"3\";\n+                      return %11;\n+                  };\n+              return;\n+            };\n+            \"\"\")\n+    @CodeReflection\n+    int test5(int i) {\n+        if (i < 1) {\n+            return 1;\n+        } else if (i < 2) {\n+            return 2;\n+        } else {\n+            return 3;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/IfTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,570 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.LongSupplier;\n+\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with implicit conversions.\n+ * @enablePreview\n+ * @build ImplicitConversionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ImplicitConversionTest\n+ *\/\n+\n+public class ImplicitConversionTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0: ImplicitConversionTest)void -> {\n+                %1 : int = constant @\"1\";\n+                %2 : long = conv %1;\n+                %3 : Var<long> = var %2 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        long x = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0: ImplicitConversionTest)void -> {\n+                %1 : long = constant @\"0\";\n+                %2 : Var<long> = var %1 @\"x\";\n+                %3 : int = constant @\"1\";\n+                %4 : long = conv %3;\n+                var.store %2 %4;\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        long x;\n+        x = 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0: ImplicitConversionTest)void -> {\n+                %1 : long = constant @\"0\";\n+                %2 : Var<long> = var %1 @\"x\";\n+                %3 : long = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : long = conv %4;\n+                %6 : long = add %3 %5;\n+                var.store %2 %6;\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        long x = 0L;\n+        x += 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0: ImplicitConversionTest, %1 : boolean)void -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : long = constant @\"0\";\n+                %4 : Var<long> = var %3 @\"x\";\n+                %5 : long = java.cexpression\n+                    ^cond()boolean -> {\n+                        %6 : boolean = var.load %2;\n+                        yield %6;\n+                    }\n+                    ^truepart()long -> {\n+                        %7 : long = constant @\"1\";\n+                        yield %7;\n+                    }\n+                    ^falsepart()long -> {\n+                        %8 : int = constant @\"2\";\n+                        %9 : long = conv %8;\n+                        yield %9;\n+                    };\n+                var.store %4 %5;\n+                return;\n+            };\n+            \"\"\")\n+    void test4(boolean cond) {\n+        long x;\n+        x = cond ? 1L : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test5\" (%0: ImplicitConversionTest, %1 : boolean)void -> {\n+               %2 : Var<boolean> = var %1 @\"cond\";\n+               %3 : long = constant @\"0\";\n+               %4 : Var<long> = var %3 @\"x\";\n+               %5 : long = java.cexpression\n+                   ^cond()boolean -> {\n+                       %6 : boolean = var.load %2;\n+                       yield %6;\n+                   }\n+                   ^truepart()long -> {\n+                       %7 : int = constant @\"1\";\n+                       %8 : long = conv %7;\n+                       yield %8;\n+                   }\n+                   ^falsepart()long -> {\n+                       %9 : long = constant @\"2\";\n+                       yield %9;\n+                   };\n+               var.store %4 %5;\n+               return;\n+           };\n+           \"\"\")\n+    void test5(boolean cond) {\n+        long x;\n+        x = cond ? 1 : 2L;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test6\" (%0: ImplicitConversionTest, %1 : boolean)void -> {\n+               %2 : Var<boolean> = var %1 @\"cond\";\n+               %3 : long = constant @\"0\";\n+               %4 : Var<long> = var %3 @\"x\";\n+               %5 : int = java.cexpression\n+                   ^cond()boolean -> {\n+                       %6 : boolean = var.load %2;\n+                       yield %6;\n+                   }\n+                   ^truepart()int -> {\n+                       %7 : int = constant @\"1\";\n+                       yield %7;\n+                   }\n+                   ^falsepart()int -> {\n+                       %8 : int = constant @\"2\";\n+                       yield %8;\n+                   };\n+               %9 : long = conv %5;\n+               var.store %4 %9;\n+               return;\n+           };\n+           \"\"\")\n+    void test6(boolean cond) {\n+        long x;\n+        x = cond ? 1 : 2;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0: ImplicitConversionTest)long -> {\n+                %1 : int = constant @\"1\";\n+                %2 : long = conv %1;\n+                return %2;\n+            };\n+            \"\"\")\n+    long test7() {\n+        return 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0: ImplicitConversionTest)void -> {\n+                %1 : java.util.function.LongSupplier = lambda ()long -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : long = conv %2;\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.LongSupplier> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        LongSupplier s = () -> { return 1; };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0: ImplicitConversionTest)void -> {\n+                %1 : java.util.function.LongSupplier = lambda ()long -> {\n+                    %2 : int = constant @\"1\";\n+                    %3 : long = conv %2;\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.LongSupplier> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9() {\n+        LongSupplier s = () -> 1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : long = constant @\"1\";\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %9 : int = constant @\"0\";\n+                        %10 : long = conv %9;\n+                        yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10(int i) {\n+        long l = switch (i) {\n+            case 1 -> 1L;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : long = constant @\"0\";\n+                        yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(int i) {\n+        long l = switch (i) {\n+            case 1 -> 1;\n+            default -> 0L;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : long = conv %10;\n+                        yield %11;\n+                    };\n+                %12 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test12(int i) {\n+        long l = switch (i) {\n+            case 1 -> 1;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : long = constant @\"1\";\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %9 : int = constant @\"0\";\n+                        %10 : long = conv %9;\n+                        java.yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test13(int i) {\n+        long l = switch (i) {\n+            case 1 -> { yield 1L; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        java.yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : long = constant @\"0\";\n+                        java.yield %10;\n+                    };\n+                %11 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test14(int i) {\n+        long l = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield 0L; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()long -> {\n+                        %8 : int = constant @\"1\";\n+                        %9 : long = conv %8;\n+                        java.yield %9;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()long -> {\n+                        %10 : int = constant @\"0\";\n+                        %11 : long = conv %10;\n+                        java.yield %11;\n+                    };\n+                %12 : Var<long> = var %4 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test15(int i) {\n+        long l = switch (i) {\n+            case 1 -> { yield 1; }\n+            default -> { yield 0; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                %5 : long = constant @\"2\";\n+                %6 : long = add %4 %5;\n+                %7 : Var<long> = var %6 @\"l\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16(int i) {\n+        long l = i + 2L;\n+    }\n+\n+    void m(long l) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                invoke %0 %4 @\"ImplicitConversionTest::m(long)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17(int i) {\n+        m(i);\n+    }\n+\n+    void m(int i1, int i2, long... l) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                invoke %0 %3 %4 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18(int i) {\n+        m(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test19\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : long = conv %5;\n+                invoke %0 %3 %4 %6 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                return;\n+           };\n+           \"\"\")\n+    void test19(int i) {\n+        m(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : long = conv %5;\n+                %7 : int = var.load %2;\n+                %8 : long = conv %7;\n+                invoke %0 %3 %4 %6 %8 @\"ImplicitConversionTest::m(int, int, long[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test20(int i) {\n+        m(i, i, i, i);\n+    }\n+\n+    static class Box {\n+        Box(long l) { }\n+        Box(int i1, int i2, long... longs) { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : long = conv %3;\n+                %5 : ImplicitConversionTest$Box = new %4 @\"func<ImplicitConversionTest$Box, long>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21(int i) {\n+        new Box(i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test22\" (%0: ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : ImplicitConversionTest$Box = new %3 %4 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test22(int i) {\n+        new Box(i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+           func @\"test23\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+               %2 : Var<int> = var %1 @\"i\";\n+               %3 : int = var.load %2;\n+               %4 : int = var.load %2;\n+               %5 : int = var.load %2;\n+               %6 : long = conv %5;\n+               %7 : ImplicitConversionTest$Box = new %3 %4 %6 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+               return;\n+           };\n+           \"\"\")\n+    void test23(int i) {\n+        new Box(i, i, i);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test24\" (%0 : ImplicitConversionTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = var.load %2;\n+                %6 : long = conv %5;\n+                %7 : int = var.load %2;\n+                %8 : long = conv %7;\n+                %9 : ImplicitConversionTest$Box = new %3 %4 %6 %8 @\"func<ImplicitConversionTest$Box, int, int, long[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test24(int i) {\n+        new Box(i, i, i, i);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ImplicitConversionTest.java","additions":570,"deletions":0,"binary":false,"changes":570,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with intersection type conversions.\n+ * @build IntersectionTypeTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester IntersectionTypeTest\n+ *\/\n+\n+class IntersectionTypeTest {\n+    interface A {\n+        Object f_A = 5;\n+        void m_A();\n+    }\n+\n+    interface B {\n+        Object f_B = 5;\n+        void m_B();\n+    }\n+\n+    interface C {\n+        Object f_C = 5;\n+        void m_C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  invoke %2 @\"IntersectionTypeTest$A::m_A()void\";\n+                  %3 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                  invoke %4 @\"IntersectionTypeTest$B::m_B()void\";\n+                  %5 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                  invoke %6 @\"IntersectionTypeTest$C::m_C()void\";\n+                  return;\n+            };\n+            \"\"\")\n+    static <X extends A & B & C> void test1(X x) {\n+        x.m_A();\n+        x.m_B();\n+        x.m_C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %3 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n+                  %4 : Var<java.lang.Object> = var %3 @\"oA\";\n+                  %5 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %6 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n+                  %7 : Var<java.lang.Object> = var %6 @\"oB\";\n+                  %8 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %9 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n+                  %10 : Var<java.lang.Object> = var %9 @\"oC\";\n+                  return;\n+            };\n+            \"\"\")\n+    static <X extends A & B & C> void test2(X x) {\n+        Object oA = x.f_A;\n+        Object oB = x.f_B;\n+        Object oC = x.f_C;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %3 : Var<IntersectionTypeTest$A> = var %2 @\"rec$\";\n+                  %4 : java.lang.Runnable = lambda ()void -> {\n+                      %5 : IntersectionTypeTest$A = var.load %3;\n+                      invoke %5 @\"IntersectionTypeTest$A::m_A()void\";\n+                      return;\n+                  };\n+                  %6 : Var<java.lang.Runnable> = var %4 @\"rA\";\n+                  %7 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %8 : IntersectionTypeTest$B = cast %7 @\"IntersectionTypeTest$B\";\n+                  %9 : Var<IntersectionTypeTest$B> = var %8 @\"rec$\";\n+                  %10 : java.lang.Runnable = lambda ()void -> {\n+                      %11 : IntersectionTypeTest$B = var.load %9;\n+                      invoke %11 @\"IntersectionTypeTest$B::m_B()void\";\n+                      return;\n+                  };\n+                  %12 : Var<java.lang.Runnable> = var %10 @\"rB\";\n+                  %13 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %14 : IntersectionTypeTest$C = cast %13 @\"IntersectionTypeTest$C\";\n+                  %15 : Var<IntersectionTypeTest$C> = var %14 @\"rec$\";\n+                  %16 : java.lang.Runnable = lambda ()void -> {\n+                      %17 : IntersectionTypeTest$C = var.load %15;\n+                      invoke %17 @\"IntersectionTypeTest$C::m_C()void\";\n+                      return;\n+                  };\n+                  %18 : Var<java.lang.Runnable> = var %16 @\"rC\";\n+                  return;\n+            };\n+            \"\"\")\n+    static <X extends A & B & C> void test3(X x) {\n+        Runnable rA = x::m_A;\n+        Runnable rB = x::m_B;\n+        Runnable rC = x::m_C;\n+    }\n+\n+    static void g_A(A a) { }\n+    static void g_B(B a) { }\n+    static void g_C(C a) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n+                %1 : Var<#IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n+                %2 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                invoke %2 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                %3 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %4 : IntersectionTypeTest$B = cast %3 @\"IntersectionTypeTest$B\";\n+                invoke %4 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                %5 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %6 : IntersectionTypeTest$C = cast %5 @\"IntersectionTypeTest$C\";\n+                invoke %6 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                return;\n+            };\n+            \"\"\")\n+    static <X extends A & B & C> void test4(X x) {\n+        g_A(x);\n+        g_B(x);\n+        g_C(x);\n+    }\n+\n+    static <X extends A & B & C> X makeIntersection(X x1, X x2) {\n+        return null;\n+    }\n+\n+    class E1 implements A, B, C {\n+        @Override\n+        public void m_A() { }\n+        @Override\n+        public void m_B() { }\n+        @Override\n+        public void m_C() { }\n+    }\n+\n+    class E2 implements A, B, C {\n+        @Override\n+        public void m_A() { }\n+        @Override\n+        public void m_B() { }\n+        @Override\n+        public void m_C() { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                invoke %8 @\"IntersectionTypeTest$A::m_A()void\";\n+                %9 : IntersectionTypeTest$A = var.load %7;\n+                %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                invoke %10 @\"IntersectionTypeTest$B::m_B()void\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                invoke %12 @\"IntersectionTypeTest$C::m_C()void\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test5(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        x.m_A();\n+        x.m_B();\n+        x.m_C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                %9 : java.lang.Object = field.load @\"IntersectionTypeTest$A::f_A()java.lang.Object\";\n+                %10 : Var<java.lang.Object> = var %9 @\"oA\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : java.lang.Object = field.load @\"IntersectionTypeTest$B::f_B()java.lang.Object\";\n+                %13 : Var<java.lang.Object> = var %12 @\"oB\";\n+                %14 : IntersectionTypeTest$A = var.load %7;\n+                %15 : java.lang.Object = field.load @\"IntersectionTypeTest$C::f_C()java.lang.Object\";\n+                %16 : Var<java.lang.Object> = var %15 @\"oC\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test6(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        Object oA = x.f_A;\n+        Object oB = x.f_B;\n+        Object oC = x.f_C;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                %9 : Var<IntersectionTypeTest$A> = var %8 @\"rec$\";\n+                %10 : java.lang.Runnable = lambda ()void -> {\n+                    %11 : IntersectionTypeTest$A = var.load %9;\n+                    invoke %11 @\"IntersectionTypeTest$A::m_A()void\";\n+                    return;\n+                };\n+                %12 : Var<java.lang.Runnable> = var %10 @\"rA\";\n+                %13 : IntersectionTypeTest$A = var.load %7;\n+                %14 : IntersectionTypeTest$B = cast %13 @\"IntersectionTypeTest$B\";\n+                %15 : Var<IntersectionTypeTest$B> = var %14 @\"rec$\";\n+                %16 : java.lang.Runnable = lambda ()void -> {\n+                    %17 : IntersectionTypeTest$B = var.load %15;\n+                    invoke %17 @\"IntersectionTypeTest$B::m_B()void\";\n+                    return;\n+                };\n+                %18 : Var<java.lang.Runnable> = var %16 @\"rB\";\n+                %19 : IntersectionTypeTest$A = var.load %7;\n+                %20 : IntersectionTypeTest$C = cast %19 @\"IntersectionTypeTest$C\";\n+                %21 : Var<IntersectionTypeTest$C> = var %20 @\"rec$\";\n+                %22 : java.lang.Runnable = lambda ()void -> {\n+                    %23 : IntersectionTypeTest$C = var.load %21;\n+                    invoke %23 @\"IntersectionTypeTest$C::m_C()void\";\n+                    return;\n+                };\n+                %24 : Var<java.lang.Runnable> = var %22 @\"rC\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test7(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        Runnable rA = x::m_A;\n+        Runnable rB = x::m_B;\n+        Runnable rC = x::m_C;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : IntersectionTypeTest$E1, %1 : IntersectionTypeTest$E2)void -> {\n+                %2 : Var<IntersectionTypeTest$E1> = var %0 @\"e1\";\n+                %3 : Var<IntersectionTypeTest$E2> = var %1 @\"e2\";\n+                %4 : IntersectionTypeTest$E1 = var.load %2;\n+                %5 : IntersectionTypeTest$E2 = var.load %3;\n+                %6 : IntersectionTypeTest$A = invoke %4 %5 @\"IntersectionTypeTest::makeIntersection(IntersectionTypeTest$A, IntersectionTypeTest$A)IntersectionTypeTest$A\";\n+                %7 : Var<IntersectionTypeTest$A> = var %6 @\"x\";\n+                %8 : IntersectionTypeTest$A = var.load %7;\n+                invoke %8 @\"IntersectionTypeTest::g_A(IntersectionTypeTest$A)void\";\n+                %9 : IntersectionTypeTest$A = var.load %7;\n+                %10 : IntersectionTypeTest$B = cast %9 @\"IntersectionTypeTest$B\";\n+                invoke %10 @\"IntersectionTypeTest::g_B(IntersectionTypeTest$B)void\";\n+                %11 : IntersectionTypeTest$A = var.load %7;\n+                %12 : IntersectionTypeTest$C = cast %11 @\"IntersectionTypeTest$C\";\n+                invoke %12 @\"IntersectionTypeTest::g_C(IntersectionTypeTest$C)void\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test8(E1 e1, E2 e2) {\n+        var x = makeIntersection(e1, e2);\n+        g_A(x);\n+        g_B(x);\n+        g_C(x);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with lambda expressions.\n+ * @build LambdaTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester LambdaTest\n+ *\/\n+\n+public class LambdaTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"s\";\n+                    %4 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                    %5 : java.lang.String = var.load %3;\n+                    invoke %4 %5 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                    return;\n+                };\n+                %6 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                %7 : java.util.function.Consumer<java.lang.String> = var.load %6;\n+                %8 : java.lang.String = constant @\"Hello World\";\n+                invoke %7 %8 @\"java.util.function.Consumer::accept(java.lang.Object)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        Consumer<String> c = s -> {\n+            System.out.println(s);\n+        };\n+        c.accept(\"Hello World\");\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = constant @\"Hello World\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<java.lang.String>> = var %1 @\"c\";\n+                %4 : java.util.function.Supplier<java.lang.String> = var.load %3;\n+                %5 : java.lang.String = invoke %4 @\"java.util.function.Supplier::get()java.lang.Object\";\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        Supplier<String> c = () -> {\n+            return \"Hello World\";\n+        };\n+        String s = c.get();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = constant @\"Hello World\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        Supplier<String> c = () -> \"Hello World\";\n+    }\n+\n+    String s_f;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = field.load %0 @\"LambdaTest::s_f()java.lang.String\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        Supplier<String> c = () -> {\n+            return s_f;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : LambdaTest, %1 : int, %2 : int)void -> {\n+                %3 : Var<int> = var %1 @\"i\";\n+                %4 : Var<int> = var %2 @\"j\";\n+                %5 : int = constant @\"3\";\n+                %6 : Var<int> = var %5 @\"k\";\n+                %7 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %8 : int = constant @\"4\";\n+                    %9 : Var<int> = var %8 @\"l\";\n+                    %10 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                        %11 : int = var.load %4;\n+                        %12 : int = var.load %6;\n+                        %13 : int = add %11 %12;\n+                        %14 : int = var.load %9;\n+                        %15 : int = add %13 %14;\n+                        %16 : Var<int> = var %15 @\"r\";\n+                        %17 : int = var.load %16;\n+                        %18 : java.lang.Integer = invoke %17 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                        return %18;\n+                    };\n+                    %19 : Var<java.util.function.Supplier<java.lang.Integer>> = var %10 @\"sInner\";\n+                    %20 : int = var.load %3;\n+                    %21 : java.util.function.Supplier<java.lang.Integer> = var.load %19;\n+                    %22 : java.lang.Integer = invoke %21 @\"java.util.function.Supplier::get()java.lang.Object\";\n+                    %23 : int = invoke %22 @\"java.lang.Integer::intValue()int\";\n+                    %24 : int = add %20 %23;\n+                    %25 : Var<int> = var %24 @\"r\";\n+                    %26 : int = var.load %25;\n+                    %27 : java.lang.Integer = invoke %26 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %27;\n+                };\n+                %28 : Var<java.util.function.Supplier<java.lang.Integer>> = var %7 @\"sOuter\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5(int i, int j) {\n+        int k = 3;\n+        Supplier<Integer> sOuter = () -> {\n+            int l = 4;\n+            Supplier<Integer> sInner = () -> {\n+                int r = j + k + l;\n+                return r;\n+            };\n+\n+            int r = i + sInner.get();\n+            return r;\n+        };\n+    }\n+\n+    int f;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : LambdaTest)void -> {\n+                %1 : java.util.function.Supplier<java.lang.Integer> = lambda ()java.lang.Integer -> {\n+                    %2 : int = field.load %0 @\"LambdaTest::f()int\";\n+                    %3 : java.lang.Integer = invoke %2 @\"java.lang.Integer::valueOf(int)java.lang.Integer\";\n+                    return %3;\n+                };\n+                %4 : Var<java.util.function.Supplier<java.lang.Integer>> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        Supplier<Integer> s = () -> f;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LambdaTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with local variables.\n+ * @build LocalVarTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester LocalVarTest\n+ *\/\n+\n+public class LocalVarTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = constant @\"2\";\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = var.load %2;\n+                %6 : int = var.load %4;\n+                %7 : int = add %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test1() {\n+        int x = 1;\n+        int y = 2;\n+        return x + y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : LocalVarTest, %1 : int, %2 : int)int -> {\n+                %3 : Var<int> = var %1 @\"x\";\n+                %4 : Var<int> = var %2 @\"y\";\n+                %5 : int = var.load %3;\n+                %6 : int = var.load %4;\n+                %7 : int = add %5 %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test2(int x, int y) {\n+        return x + y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = constant @\"0\";\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = constant @\"1\";\n+                var.store %2 %5;\n+                %6 : int = constant @\"2\";\n+                var.store %4 %6;\n+                %7 : int = var.load %2;\n+                %8 : int = var.load %4;\n+                %9 : int = add %7 %8;\n+                return %9;\n+            };\n+            \"\"\")\n+    int test3() {\n+        int x;\n+        int y;\n+        x = 1;\n+        y = 2;\n+        return x + y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                %6 : Var<int> = var %5 @\"y\";\n+                %7 : int = var.load %6;\n+                return %7;\n+            };\n+            \"\"\")\n+    int test4() {\n+        int x = 1;\n+        int y = x + 1;\n+        return y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = var.load %2;\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = var.load %4;\n+                return %5;\n+            };\n+            \"\"\")\n+    int test5() {\n+        int x = 1;\n+        int y = x;\n+        return y;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = constant @\"1\";\n+                %4 : Var<int> = var %3 @\"y\";\n+                %5 : int = constant @\"1\";\n+                %6 : Var<int> = var %5 @\"z\";\n+                %7 : int = var.load %2;\n+                var.store %4 %7;\n+                var.store %6 %7;\n+                %8 : int = var.load %6;\n+                return %8;\n+            };\n+            \"\"\")\n+    int test6() {\n+        int x = 1;\n+        int y = 1;\n+        int z = 1;\n+        z = y = x;\n+        return z;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : LocalVarTest)int -> {\n+                %1 : int = constant @\"1\";\n+                %2 : Var<int> = var %1 @\"x\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"2\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : Var<int> = var %5 @\"y\";\n+                %7 : int = var.load %6;\n+                %8 : int = constant @\"3\";\n+                %9 : int = add %7 %8;\n+                var.store %6 %9;\n+                %10 : int = var.load %2;\n+                %11 : int = constant @\"4\";\n+                %12 : int = add %10 %11;\n+                var.store %2 %12;\n+                %13 : int = add %9 %12;\n+                return %13;\n+            };\n+            \"\"\")\n+    int test7() {\n+        int x = 1;\n+        int y = x += 2;\n+        return (y += 3) + (x += 4);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : LocalVarTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : Var<int> = var %3 @\"x\";\n+                %7 : int = var.load %2;\n+                %8 : int = constant @\"1\";\n+                %9 : int = sub %7 %8;\n+                var.store %2 %9;\n+                %10 : Var<int> = var %7 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8(int i) {\n+        int x = i++;\n+        int y = i--;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : LocalVarTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"1\";\n+                %5 : int = add %3 %4;\n+                var.store %2 %5;\n+                %6 : Var<int> = var %5 @\"x\";\n+                %7 : int = var.load %2;\n+                %8 : int = constant @\"1\";\n+                %9 : int = sub %7 %8;\n+                var.store %2 %9;\n+                %10 : Var<int> = var %9 @\"y\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9(int i) {\n+        int x = ++i;\n+        int y = --i;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/LocalVarTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with method calls.\n+ * @build MethodCallTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester MethodCallTest\n+ *\/\n+\n+public class MethodCallTest {\n+\n+    void m() {\n+    }\n+\n+    int m_int() {\n+        return 0;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : MethodCallTest)void -> {\n+                invoke %0 @\"MethodCallTest::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : MethodCallTest)void -> {\n+                invoke %0 @\"MethodCallTest::m()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        this.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : MethodCallTest)int -> {\n+                %1 : int = invoke %0 @\"MethodCallTest::m_int()int\";\n+                return %1;\n+            };\n+            \"\"\")\n+    int test3() {\n+        return m_int();\n+    }\n+\n+\n+    static void ms() {\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : MethodCallTest)void -> {\n+                invoke @\"MethodCallTest::ms()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        ms();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4_1\" (%0 : MethodCallTest)void -> {\n+                invoke @\"MethodCallTest::ms()void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4_1() {\n+        MethodCallTest.ms();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4_2\" (%0 : MethodCallTest)java.util.List<java.lang.String> -> {\n+                %1 : java.util.List<java.lang.String> = invoke @\"java.util.List::of()java.util.List\";\n+                return %1;\n+            };\n+            \"\"\")\n+    List<String> test4_2() {\n+        return List.of();\n+    }\n+\n+    String m(int i, String s, List<Number> l) {\n+        return s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : MethodCallTest, %1 : java.util.List<java.lang.Number>)void -> {\n+                %2 : Var<java.util.List<java.lang.Number>> = var %1 @\"l\";\n+                %3 : int = constant @\"1\";\n+                %4 : java.lang.String = constant @\"1\";\n+                %5 : java.util.List<java.lang.Number> = var.load %2;\n+                %6 : java.lang.String = invoke %0 %3 %4 %5 @\"MethodCallTest::m(int, java.lang.String, java.util.List)java.lang.String\";\n+                %7 : Var<java.lang.String> = var %6 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5(List<Number> l) {\n+        String s = m(1, \"1\", l);\n+    }\n+\n+\n+    static class A {\n+        B b;\n+\n+        B m() {\n+            return null;\n+        }\n+    }\n+\n+    static class B {\n+        C m() {\n+            return null;\n+        }\n+    }\n+\n+    static class C {\n+        int m() {\n+            return 0;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : MethodCallTest, %1 : MethodCallTest$A)void -> {\n+                %2 : Var<MethodCallTest$A> = var %1 @\"a\";\n+                %3 : MethodCallTest$A = var.load %2;\n+                %4 : MethodCallTest$B = invoke %3 @\"MethodCallTest$A::m()MethodCallTest$B\";\n+                %5 : MethodCallTest$C = invoke %4 @\"MethodCallTest$B::m()MethodCallTest$C\";\n+                %6 : int = invoke %5 @\"MethodCallTest$C::m()int\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6(A a) {\n+        a.m().m().m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : MethodCallTest, %1 : MethodCallTest$A)void -> {\n+                %2 : Var<MethodCallTest$A> = var %1 @\"a\";\n+                %3 : MethodCallTest$A = var.load %2;\n+                %4 : MethodCallTest$B = field.load %3 @\"MethodCallTest$A::b()MethodCallTest$B\";\n+                %5 : MethodCallTest$C = invoke %4 @\"MethodCallTest$B::m()MethodCallTest$C\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7(A a) {\n+        a.b.m();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : MethodCallTest, %1 : java.lang.String)void -> {\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                %3 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %4 : java.lang.String = var.load %2;\n+                invoke %3 %4 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8(String s) {\n+        System.out.println(s);\n+    }\n+\n+    static class X {\n+        int x;\n+        void x() {}\n+\n+        static void sx() {}\n+    }\n+\n+    static class Y extends X {\n+        void y() {}\n+        static void sy() {}\n+\n+        @CodeReflection\n+        @IR(\"\"\"\n+                func @\"test\" (%0 : MethodCallTest$Y)void -> {\n+                    invoke %0 @\"MethodCallTest$Y::x()void\";\n+                    invoke %0 @\"MethodCallTest$Y::y()void\";\n+                    invoke @\"MethodCallTest$Y::sx()void\";\n+                    invoke @\"MethodCallTest$Y::sy()void\";\n+                    invoke @\"MethodCallTest$Y::sx()void\";\n+                    invoke @\"MethodCallTest$Y::sy()void\";\n+                    return;\n+                };\n+                \"\"\")\n+        void test() {\n+            x();\n+            y();\n+\n+            sx();\n+            sy();\n+\n+            Y.sx();\n+            Y.sy();\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : MethodCallTest$Y)void -> {\n+                %1 : Var<MethodCallTest$Y> = var %0 @\"y\";\n+                %2 : MethodCallTest$Y = var.load %1;\n+                invoke %2 @\"MethodCallTest$Y::x()void\";\n+                %3 : MethodCallTest$Y = var.load %1;\n+                invoke %3 @\"MethodCallTest$Y::y()void\";\n+                %4 : MethodCallTest$Y = var.load %1;\n+                invoke @\"MethodCallTest$Y::sx()void\";\n+                %5 : MethodCallTest$Y = var.load %1;\n+                invoke @\"MethodCallTest$Y::sy()void\";\n+                invoke @\"MethodCallTest$Y::sx()void\";\n+                invoke @\"MethodCallTest$Y::sy()void\";\n+                return;\n+            };\n+            \"\"\")\n+    static void test9(Y y) {\n+        y.x();\n+        y.y();\n+\n+        y.sx();\n+        y.sy();\n+\n+        Y.sx();\n+        Y.sy();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : java.util.ArrayList<java.lang.String>)void -> {\n+                %1 : Var<java.util.ArrayList<java.lang.String>> = var %0 @\"al\";\n+                %2 : java.util.ArrayList<java.lang.String> = var.load %1;\n+                %3 : int = constant @\"0\";\n+                %4 : java.lang.String = invoke %2 %3 @\"java.util.ArrayList::get(int)java.lang.Object\";\n+                %5 : Var<java.lang.String> = var %4 @\"s\";\n+                %6 : java.util.ArrayList<java.lang.String> = var.load %1;\n+                %7 : Var<java.util.List<java.lang.String>> = var %6 @\"l\";\n+                %8 : java.util.List<java.lang.String> = var.load %7;\n+                %9 : int = constant @\"0\";\n+                %10 : java.lang.String = invoke %8 %9 @\"java.util.List::get(int)java.lang.Object\";\n+                var.store %5 %10;\n+                return;\n+            };\n+            \"\"\")\n+    static void test10(ArrayList<String> al) {\n+        String s = al.get(0);\n+        List<String> l = al;\n+        s = l.get(0);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodCallTest.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with method reference expressions.\n+ * @build MethodReferenceTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester MethodReferenceTest\n+ *\/\n+\n+public class MethodReferenceTest {\n+\n+    static void m_s(String s) {}\n+\n+    void m(String s) {}\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"x$0\";\n+                    %4 : java.lang.String = var.load %3;\n+                    invoke %4 @\"MethodReferenceTest::m_s(java.lang.String)void\";\n+                    return;\n+                };\n+                %5 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        Consumer<String> c = MethodReferenceTest::m_s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.BiConsumer<MethodReferenceTest, java.lang.String> = lambda (%2 : MethodReferenceTest, %3 : java.lang.String)void -> {\n+                    %4 : Var<MethodReferenceTest> = var %2 @\"rec$\";\n+                    %5 : Var<java.lang.String> = var %3 @\"x$0\";\n+                    %6 : MethodReferenceTest = var.load %4;\n+                    %7 : java.lang.String = var.load %5;\n+                    invoke %6 %7 @\"MethodReferenceTest::m(java.lang.String)void\";\n+                    return;\n+                };\n+                %8 : Var<java.util.function.BiConsumer<MethodReferenceTest, java.lang.String>> = var %1 @\"bc\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        BiConsumer<MethodReferenceTest, String> bc = MethodReferenceTest::m;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Consumer<java.lang.String> = lambda (%2 : java.lang.String)void -> {\n+                    %3 : Var<java.lang.String> = var %2 @\"x$0\";\n+                    %4 : java.lang.String = var.load %3;\n+                    invoke %0 %4 @\"MethodReferenceTest::m(java.lang.String)void\";\n+                    return;\n+                };\n+                %5 : Var<java.util.function.Consumer<java.lang.String>> = var %1 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        Consumer<String> c = this::m;\n+    }\n+\n+    class A<T> {\n+        T m(T t) { return t; }\n+    }\n+\n+    <T> A<T> a(T t) { return null; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.lang.String = constant @\"s\";\n+                %2 : MethodReferenceTest$A<java.lang.String> = invoke %0 %1 @\"MethodReferenceTest::a(java.lang.Object)MethodReferenceTest$A\";\n+                %3 : Var<MethodReferenceTest$A<java.lang.String>> = var %2 @\"rec$\";\n+                %4 : java.util.function.Function<java.lang.String, java.lang.String> = lambda (%5 : java.lang.String)java.lang.String -> {\n+                    %6 : Var<java.lang.String> = var %5 @\"x$0\";\n+                    %7 : MethodReferenceTest$A<java.lang.String> = var.load %3;\n+                    %8 : java.lang.String = var.load %6;\n+                    %9 : java.lang.String = invoke %7 %8 @\"MethodReferenceTest$A::m(java.lang.Object)java.lang.Object\";\n+                    return %9;\n+                };\n+                %10 : Var<java.util.function.Function<java.lang.String, java.lang.String>> = var %4 @\"f\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        Function<String, String> f = a(\"s\")::m;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %2 : Var<java.io.PrintStream> = var %1 @\"rec$\";\n+                %3 : java.util.function.Consumer<java.lang.String> = lambda (%4 : java.lang.String)void -> {\n+                    %5 : Var<java.lang.String> = var %4 @\"x$0\";\n+                    %6 : java.io.PrintStream = var.load %2;\n+                    %7 : java.lang.String = var.load %5;\n+                    invoke %6 %7 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                    return;\n+                };\n+                %8 : Var<java.util.function.Consumer<java.lang.String>> = var %3 @\"c3\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        Consumer<String> c3 = System.out::println;\n+    }\n+\n+    static class X {\n+        X(int i) {}\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Function<java.lang.Integer, MethodReferenceTest$X> = lambda (%2 : java.lang.Integer)MethodReferenceTest$X -> {\n+                    %3 : Var<java.lang.Integer> = var %2 @\"x$0\";\n+                    %4 : java.lang.Integer = var.load %3;\n+                    %5 : int = invoke %4 @\"java.lang.Integer::intValue()int\";\n+                    %6 : MethodReferenceTest$X = new %5 @\"func<MethodReferenceTest$X, int>\";\n+                    return %6;\n+                };\n+                %7 : Var<java.util.function.Function<java.lang.Integer, MethodReferenceTest$X>> = var %1 @\"xNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        Function<Integer, X> xNew = X::new;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.Supplier<MethodReferenceTest$A<java.lang.String>> = lambda ()MethodReferenceTest$A<java.lang.String> -> {\n+                    %2 : MethodReferenceTest$A<java.lang.String> = new %0 @\"func<MethodReferenceTest$A>\";\n+                    return %2;\n+                };\n+                %3 : Var<java.util.function.Supplier<MethodReferenceTest$A<java.lang.String>>> = var %1 @\"aNew\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        Supplier<A<String>> aNew = A::new;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : MethodReferenceTest)void -> {\n+                %1 : java.util.function.IntFunction<MethodReferenceTest$A<java.lang.String>[]> = lambda (%2 : int)MethodReferenceTest$A<java.lang.String>[] -> {\n+                    %3 : Var<int> = var %2 @\"x$0\";\n+                    %4 : int = var.load %3;\n+                    %5 : MethodReferenceTest$A[] = new %4 @\"func<MethodReferenceTest$A[], int>\";\n+                    return %5;\n+                };\n+                %6 : Var<java.util.function.IntFunction<MethodReferenceTest$A<java.lang.String>[]>> = var %1 @\"aNewArray\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8() {\n+        IntFunction<A<String>[]> aNewArray = A[]::new;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/MethodReferenceTest.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with constant values.\n+ * @build NewArrayTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester NewArrayTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Function;\n+\n+public class NewArrayTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : int[] = new %1 @\"func<int[], int>\";\n+                %3 : Var<int[]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        int[] a = new int[10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : NewArrayTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"l\";\n+                %3 : int = var.load %2;\n+                %4 : int = constant @\"10\";\n+                %5 : int = add %3 %4;\n+                %6 : int[] = new %5 @\"func<int[], int>\";\n+                %7 : Var<int[]> = var %6 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2(int l) {\n+        int[] a = new int[l + 10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : java.lang.String[] = new %1 @\"func<java.lang.String[], int>\";\n+                %3 : Var<java.lang.String[]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        String[] a = new String[10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n+                %3 : Var<java.lang.String[][]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        String[][] a = new String[10][];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : int = constant @\"10\";\n+                %3 : java.lang.String[][] = new %1 %2 @\"func<java.lang.String[][], int, int>\";\n+                %4 : Var<java.lang.String[][]> = var %3 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        String[][] a = new String[10][10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"3\";\n+                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n+                %3 : int = constant @\"2\";\n+                %4 : java.lang.String[] = new %3 @\"func<java.lang.String[], int>\";\n+                %5 : java.lang.String = constant @\"one\";\n+                %6 : int = constant @\"0\";\n+                array.store %4 %6 %5;\n+                %7 : java.lang.String = constant @\"two\";\n+                %8 : int = constant @\"1\";\n+                array.store %4 %8 %7;\n+                %9 : int = constant @\"0\";\n+                array.store %2 %9 %4;\n+                %10 : int = constant @\"1\";\n+                %11 : java.lang.String[] = new %10 @\"func<java.lang.String[], int>\";\n+                %12 : java.lang.String = constant @\"three\";\n+                %13 : int = constant @\"0\";\n+                array.store %11 %13 %12;\n+                %14 : int = constant @\"1\";\n+                array.store %2 %14 %11;\n+                %15 : java.lang.String[] = constant @null;\n+                %16 : int = constant @\"2\";\n+                array.store %2 %16 %15;\n+                %17 : Var<java.lang.String[][]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        String[][] a = { { \"one\", \"two\" }, { \"three\" }, null };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : NewArrayTest)void -> {\n+                %1 : int = constant @\"3\";\n+                %2 : java.lang.String[][] = new %1 @\"func<java.lang.String[][], int>\";\n+                %3 : int = constant @\"2\";\n+                %4 : java.lang.String[] = new %3 @\"func<java.lang.String[], int>\";\n+                %5 : java.lang.String = constant @\"one\";\n+                %6 : int = constant @\"0\";\n+                array.store %4 %6 %5;\n+                %7 : java.lang.String = constant @\"two\";\n+                %8 : int = constant @\"1\";\n+                array.store %4 %8 %7;\n+                %9 : int = constant @\"0\";\n+                array.store %2 %9 %4;\n+                %10 : int = constant @\"1\";\n+                %11 : java.lang.String[] = new %10 @\"func<java.lang.String[], int>\";\n+                %12 : java.lang.String = constant @\"three\";\n+                %13 : int = constant @\"0\";\n+                array.store %11 %13 %12;\n+                %14 : int = constant @\"1\";\n+                array.store %2 %14 %11;\n+                %15 : java.lang.String[] = constant @null;\n+                %16 : int = constant @\"2\";\n+                array.store %2 %16 %15;\n+                %17 : Var<java.lang.String[][]> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        String[][] a = new String[][] { { \"one\", \"two\" }, { \"three\" }, null };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewArrayTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with new expressions.\n+ * @build NewTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester NewTest\n+ *\/\n+\n+public class NewTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test0\" (%0 : NewTest)void -> {\n+                %1 : java.lang.String = constant @\"1\";\n+                %2 : java.math.BigDecimal = new %1 @\"func<java.math.BigDecimal, java.lang.String>\";\n+                %3 : Var<java.math.BigDecimal> = var %2 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test0() {\n+        BigDecimal a = new BigDecimal(\"1\");\n+    }\n+\n+    static class A {\n+        A() {}\n+\n+        A(int i, int j) {}\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : NewTest)void -> {\n+                %1 : NewTest$A = new @\"func<NewTest$A>\";\n+                %2 : Var<NewTest$A> = var %1 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        A a = new A();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : NewTest)void -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : NewTest$A = new %1 %2 @\"func<NewTest$A, int, int>\";\n+                %4 : Var<NewTest$A> = var %3 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        A a = new A(1, 2);\n+    }\n+\n+    class B {\n+        B() {}\n+\n+        B(int i, int j) {}\n+\n+        class C {\n+        }\n+    }\n+\n+    B f;\n+\n+    B b() { return f; }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = new %0 @\"func<NewTest$B>\";\n+                %2 : Var<NewTest$B> = var %1 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        B b = new B();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : NewTest)void -> {\n+                %1 : int = constant @\"1\";\n+                %2 : int = constant @\"2\";\n+                %3 : NewTest$B = new %0 %1 %2 @\"func<NewTest$B, int, int>\";\n+                %4 : Var<NewTest$B> = var %3 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test4() {\n+        B b = new B(1, 2);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = new %0 @\"func<NewTest$B>\";\n+                %2 : Var<NewTest$B> = var %1 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        B b = this.new B();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = field.load %0 @\"NewTest::f()NewTest$B\";\n+                %2 : NewTest$B$C = new %1 @\"func<NewTest$B$C>\";\n+                %3 : Var<NewTest$B$C> = var %2 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        B.C c = f.new C();\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : NewTest)void -> {\n+                %1 : NewTest$B = invoke %0 @\"NewTest::b()NewTest$B\";\n+                %2 : NewTest$B$C = new %1 @\"func<NewTest$B$C>\";\n+                %3 : Var<NewTest$B$C> = var %2 @\"c\";\n+                return;\n+            };\n+            \"\"\")\n+    void test7() {\n+        B.C c = b().new C();\n+    }\n+\n+    static class AG<T> {\n+        AG(List<T> l) {}\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : NewTest, %1 : java.util.List<java.lang.String>)void -> {\n+                %2 : Var<java.util.List<java.lang.String>> = var %1 @\"l\";\n+                %3 : java.util.List<java.lang.String> = var.load %2;\n+                %4 : NewTest$AG<java.lang.String> = new %3 @\"func<NewTest$AG, java.util.List>\";\n+                %5 : Var<NewTest$AG<java.lang.String>> = var %4 @\"a\";\n+                return;\n+            };\n+            \"\"\")\n+    void test8(List<String> l) {\n+        AG<String> a = new AG<>(l);\n+    }\n+\n+    class BG<T> {\n+        BG(List<T> l) {}\n+\n+        class CG<U> {\n+            CG(List<U> l) {}\n+        }\n+    }\n+\n+    \/\/ @@@ This produces incorrect type descriptors for generic inner classes\n+    \/\/ the type argument for type BG is not preserved\n+\/\/    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : NewTest, %1 : java.util.List<java.lang.String>, %2 : java.util.List<java.lang.Number>)void -> {\n+                %3 : Var<java.util.List<java.lang.String>> = var %1 @\"l1\";\n+                %4 : Var<java.util.List<java.lang.Number>> = var %2 @\"l2\";\n+                %5 : java.util.List<java.lang.String> = var.load %3;\n+                %6 : NewTest$BG<java.lang.String> = new %0 %5 @\"func<NewTest$BG, java.util.List>\";\n+                %7 : java.util.List<java.lang.Number> = var.load %4;\n+                %8 : NewTest$BG$CG<java.lang.Number> = new %6 %7 @\"func<NewTest$BG$CG, java.util.List>\";\n+                %9 : Var<NewTest$BG$CG<java.lang.Number>> = var %8 @\"numberCG\";\n+                return;\n+            };\n+            \"\"\")\n+    void test9(List<String> l1, List<Number> l2) {\n+        BG<String>.CG<Number> numberCG = new BG<String>(l1).new CG<Number>(l2);\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : NewTest)void -> {\n+                %1 : int = constant @\"10\";\n+                %2 : int[] = new %1 @\"func<int[], int>\";\n+                %3 : Var<int[]> = var %2 @\"i\";\n+                return;\n+            };\n+            \"\"\")\n+    void test10() {\n+        int[] i = new int[10];\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : NewTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"i\";\n+                %3 : int = var.load %2;\n+                %4 : int = var.load %2;\n+                %5 : int = constant @\"1\";\n+                %6 : int = add %4 %5;\n+                %7 : int = var.load %2;\n+                %8 : int = constant @\"2\";\n+                %9 : int = add %7 %8;\n+                %10 : java.lang.String[][][] = new %3 %6 %9 @\"func<java.lang.String[][][], int, int, int>\";\n+                %11 : Var<java.lang.String[][][]> = var %10 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test11(int i) {\n+        String[][][] s = new String[i][i + 1][i + 2];\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/NewTest.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,516 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Supplier;\n+\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with null constants.\n+ * @enablePreview\n+ * @build NullTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester NullTest\n+ *\/\n+\n+public class NullTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : Var<java.lang.String> = var %1 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        String s = null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : NullTest)void -> {\n+                %1 : java.lang.Object = constant @null;\n+                %2 : java.lang.String = cast %1 @\"java.lang.String\";\n+                %3 : Var<java.lang.String> = var %2 @\"s\";\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        String s = (String)null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.String = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.String -> {\n+                        %5 : java.lang.String = constant @null;\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.String -> {\n+                        %6 : java.lang.String = constant @\"\";\n+                        yield %6;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    String test3(boolean cond) {\n+        return cond ? null : \"\";\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.String = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.String -> {\n+                        %5 : java.lang.String = constant @\"\";\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.String -> {\n+                        %6 : java.lang.String = constant @null;\n+                        yield %6;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    String test4(boolean cond) {\n+        return cond ? \"\" : null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.String = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.String -> {\n+                        %5 : java.lang.String = constant @null;\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.String -> {\n+                        %6 : java.lang.String = constant @null;\n+                        yield %6;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    String test5(boolean cond) {\n+        return cond ? null : null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : NullTest, %1 : boolean)java.lang.String -> {\n+                %2 : Var<boolean> = var %1 @\"cond\";\n+                %3 : java.lang.Object = java.cexpression\n+                    ^cond()boolean -> {\n+                        %4 : boolean = var.load %2;\n+                        yield %4;\n+                    }\n+                    ^truepart()java.lang.Object -> {\n+                        %5 : java.lang.Object = constant @null;\n+                        yield %5;\n+                    }\n+                    ^falsepart()java.lang.Object -> {\n+                        %6 : java.lang.Object = constant @null;\n+                        yield %6;\n+                    };\n+                %7 : java.lang.String = cast %3 @\"java.lang.String\";\n+                return %7;\n+            };\n+            \"\"\")\n+    String test6(boolean cond) {\n+        return (String)(cond ? null : null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"\";\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test7(int cond) {\n+        return switch(cond) {\n+            case 1  -> \"\";\n+            default -> null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test8\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"\";\n+                        yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test8(int cond) {\n+        return switch(cond) {\n+            case 1  -> null;\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test9\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test9(int cond) {\n+        return switch(cond) {\n+            case 1  -> null;\n+            default -> null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test10\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Object = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %8 : java.lang.Object = constant @null;\n+                        yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %9 : java.lang.Object = constant @null;\n+                        yield %9;\n+                    };\n+                %10 : java.lang.String = cast %4 @\"java.lang.String\";\n+                return %10;\n+            };\n+            \"\"\")\n+    String test10(int cond) {\n+        return (String)switch(cond) {\n+            case 1  -> null;\n+            default -> null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test11\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @\"\";\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        java.yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test11(int cond) {\n+        return switch(cond) {\n+            case 1  -> { yield \"\"; }\n+            default -> { yield null; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test12\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @\"\";\n+                        java.yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test12(int cond) {\n+        return switch(cond) {\n+            case 1  -> { yield null; }\n+            default -> { yield \"\"; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test13\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.String = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.String -> {\n+                        %8 : java.lang.String = constant @null;\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.String -> {\n+                        %9 : java.lang.String = constant @null;\n+                        java.yield %9;\n+                    };\n+                return %4;\n+            };\n+            \"\"\")\n+    String test13(int cond) {\n+        return switch(cond) {\n+            case 1  -> { yield null; }\n+            default -> { yield null; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test14\" (%0 : NullTest, %1 : int)java.lang.String -> {\n+                %2 : Var<int> = var %1 @\"cond\";\n+                %3 : int = var.load %2;\n+                %4 : java.lang.Object = java.switch.expression %3\n+                    ^constantCaseLabel(%5 : int)boolean -> {\n+                        %6 : int = constant @\"1\";\n+                        %7 : boolean = eq %5 %6;\n+                        yield %7;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %8 : java.lang.Object = constant @null;\n+                        java.yield %8;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %9 : java.lang.Object = constant @null;\n+                        java.yield %9;\n+                    };\n+                %10 : java.lang.String = cast %4 @\"java.lang.String\";\n+                return %10;\n+            };\n+            \"\"\")\n+    String test14(int cond) {\n+        return (String)switch(cond) {\n+            case 1  -> { yield null; }\n+            default -> { yield null; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test15\" (%0 : NullTest)java.util.function.Supplier<java.lang.String> -> {\n+                %1 : java.util.function.Supplier<java.lang.String> = lambda ()java.lang.String -> {\n+                    %2 : java.lang.String = constant @null;\n+                    return %2;\n+                };\n+                return %1;\n+            };\n+            \"\"\")\n+    Supplier<String> test15() {\n+        return () -> null;\n+    }\n+\n+    static void m(String s, String... ss) { }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test16\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                invoke %1 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test16() {\n+        m(null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test17\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String[] = constant @null;\n+                invoke %1 %2 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test17() {\n+        m(null, null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test18\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String = constant @null;\n+                %3 : java.lang.String = constant @null;\n+                invoke %1 %2 %3 @\"NullTest::m(java.lang.String, java.lang.String[])void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test18() {\n+        m(null, null, null);\n+    }\n+\n+    static class Box {\n+        Box(String s, String... ss) { }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test19\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : NullTest$Box = new %1 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test19() {\n+        new Box(null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test20\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String[] = constant @null;\n+                %3 : NullTest$Box = new %1 %2 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test20() {\n+        new Box(null, null);\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test21\" (%0 : NullTest)void -> {\n+                %1 : java.lang.String = constant @null;\n+                %2 : java.lang.String = constant @null;\n+                %3 : java.lang.String = constant @null;\n+                %4 : NullTest$Box = new %1 %2 %3 @\"func<NullTest$Box, java.lang.String, java.lang.String[]>\";\n+                return;\n+            };\n+            \"\"\")\n+    void test21() {\n+        new Box(null, null, null);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/NullTest.java","additions":516,"deletions":0,"binary":false,"changes":516,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with patterns.\n+ * @enablePreview\n+ * @build PatternsTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester PatternsTest\n+ *\/\n+\n+public class PatternsTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Object = var.load %2;\n+                %4 : java.lang.String = constant @null;\n+                %5 : Var<java.lang.String> = var %4 @\"s\";\n+                %6 : boolean = pattern.match %3\n+                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                        %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                        yield %7;\n+                    }\n+                    ^match(%8 : java.lang.String)void -> {\n+                        var.store %5 %8;\n+                        yield;\n+                    };\n+                %9 : Var<boolean> = var %6 @\"x\";\n+                return;\n+            };\n+            \"\"\")\n+    void test1(Object o) {\n+        boolean x = o instanceof String s;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : PatternsTest, %1 : java.lang.Object)java.lang.String -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.if\n+                    ()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        yield %6;\n+                    }\n+                    ^then()void -> {\n+                        %9 : java.lang.String = var.load %4;\n+                        return %9;\n+                    }\n+                    ^else()void -> {\n+                        %10 : java.lang.String = constant @\"\";\n+                        return %10;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    String test2(Object o) {\n+        if (o instanceof String s) {\n+            return s;\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : PatternsTest, %1 : java.lang.Object)java.lang.String -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.if\n+                    ()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        %9 : boolean = not %6;\n+                        yield %9;\n+                    }\n+                    ^then()void -> {\n+                        %10 : java.lang.String = constant @\"\";\n+                        return %10;\n+                    }\n+                    ^else()void -> {\n+                        yield;\n+                    };\n+                %11 : java.lang.String = var.load %4;\n+                return %11;\n+            };\n+            \"\"\")\n+    String test3(Object o) {\n+        if (!(o instanceof String s)) {\n+            return \"\";\n+        }\n+        return s;\n+    }\n+\n+    interface Point {\n+    }\n+\n+    record ConcretePoint(int x, int y) implements Point {\n+    }\n+\n+    enum Color {RED, GREEN, BLUE}\n+\n+    record ColoredPoint(ConcretePoint p, Color c) implements Point {\n+    }\n+\n+    record Rectangle(Point upperLeft, Point lowerRight) {\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : PatternsTest, %1 : PatternsTest$Rectangle)void -> {\n+                %2 : Var<PatternsTest$Rectangle> = var %1 @\"r\";\n+                %3 : PatternsTest$ConcretePoint = constant @null;\n+                %4 : Var<PatternsTest$ConcretePoint> = var %3 @\"p\";\n+                %5 : PatternsTest$Color = constant @null;\n+                %6 : Var<PatternsTest$Color> = var %5 @\"c\";\n+                %7 : PatternsTest$ColoredPoint = constant @null;\n+                %8 : Var<PatternsTest$ColoredPoint> = var %7 @\"lr\";\n+                java.if\n+                    ()boolean -> {\n+                        %9 : PatternsTest$Rectangle = var.load %2;\n+                        %10 : boolean = pattern.match %9\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Record<PatternsTest$Rectangle> -> {\n+                                %11 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<PatternsTest$ConcretePoint> = pattern.binding @\"p\";\n+                                %12 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<PatternsTest$Color> = pattern.binding @\"c\";\n+                                %13 : java.lang.reflect.code.ExtendedOps$Pattern$Record<PatternsTest$ColoredPoint> = pattern.record %11 %12 @\"(PatternsTest$ConcretePoint p, PatternsTest$Color c)PatternsTest$ColoredPoint\";\n+                                %14 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<PatternsTest$ColoredPoint> = pattern.binding @\"lr\";\n+                                %15 : java.lang.reflect.code.ExtendedOps$Pattern$Record<PatternsTest$Rectangle> = pattern.record %13 %14 @\"(PatternsTest$Point upperLeft, PatternsTest$Point lowerRight)PatternsTest$Rectangle\";\n+                                yield %15;\n+                            }\n+                            ^match(%16 : PatternsTest$ConcretePoint, %17 : PatternsTest$Color, %18 : PatternsTest$ColoredPoint)void -> {\n+                                var.store %4 %16;\n+                                var.store %6 %17;\n+                                var.store %8 %18;\n+                                yield;\n+                            };\n+                        yield %10;\n+                    }\n+                    ^then()void -> {\n+                        %19 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %20 : PatternsTest$ConcretePoint = var.load %4;\n+                        invoke %19 %20 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        %21 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %22 : PatternsTest$Color = var.load %6;\n+                        invoke %21 %22 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        %23 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %24 : PatternsTest$ColoredPoint = var.load %8;\n+                        invoke %23 %24 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        yield;\n+                    }\n+                    ^else()void -> {\n+                        %25 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %26 : java.lang.String = constant @\"NO MATCH\";\n+                        invoke %25 %26 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4(Rectangle r) {\n+        if (r instanceof Rectangle(\n+                ColoredPoint(ConcretePoint p, Color c),\n+                ColoredPoint lr)){\n+            System.out.println(p);\n+            System.out.println(c);\n+            System.out.println(lr);\n+        }\n+        else {\n+            System.out.println(\"NO MATCH\");\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.while\n+                    ^cond()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        yield %6;\n+                    }\n+                    ^body()void -> {\n+                        %9 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %10 : java.lang.String = var.load %4;\n+                        invoke %9 %10 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test5(Object o) {\n+        while (o instanceof String s) {\n+            System.out.println(s);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.String = constant @null;\n+                %4 : Var<java.lang.String> = var %3 @\"s\";\n+                java.do.while\n+                    ^body()void -> {\n+                        java.continue;\n+                    }\n+                    ^cond()boolean -> {\n+                        %5 : java.lang.Object = var.load %2;\n+                        %6 : boolean = pattern.match %5\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %7 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %7;\n+                            }\n+                            ^match(%8 : java.lang.String)void -> {\n+                                var.store %4 %8;\n+                                yield;\n+                            };\n+                        %9 : boolean = not %6;\n+                        yield %9;\n+                    };\n+                %10 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                %11 : java.lang.String = var.load %4;\n+                invoke %10 %11 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                return;\n+            };\n+            \"\"\")\n+    void test6(Object o) {\n+        do {\n+        } while (!(o instanceof String s));\n+        System.out.println(s);\n+    }\n+\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test7\" (%0 : PatternsTest, %1 : java.lang.Object)void -> {\n+                %2 : Var<java.lang.Object> = var %1 @\"o\";\n+                %3 : java.lang.Number = constant @null;\n+                %4 : Var<java.lang.Number> = var %3 @\"n\";\n+                java.for\n+                    ^init()Var<int> -> {\n+                        %5 : int = constant @\"0\";\n+                        %6 : Var<int> = var %5 @\"i\";\n+                        yield %6;\n+                    }\n+                    ^cond(%7 : Var<int>)boolean -> {\n+                        %8 : boolean = java.cand\n+                            ()boolean -> {\n+                                %9 : int = var.load %7;\n+                                %10 : int = constant @\"10\";\n+                                %11 : boolean = lt %9 %10;\n+                                yield %11;\n+                            }\n+                            ()boolean -> {\n+                                %12 : java.lang.Object = var.load %2;\n+                                %13 : boolean = pattern.match %12\n+                                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> -> {\n+                                        %14 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                        yield %14;\n+                                    }\n+                                    ^match(%15 : java.lang.Number)void -> {\n+                                        var.store %4 %15;\n+                                        yield;\n+                                    };\n+                                yield %13;\n+                            };\n+                        yield %8;\n+                    }\n+                    ^update(%16 : Var<int>)void -> {\n+                        %17 : int = var.load %16;\n+                        %18 : java.lang.Number = var.load %4;\n+                        %19 : int = invoke %18 @\"java.lang.Number::intValue()int\";\n+                        %20 : int = add %17 %19;\n+                        var.store %16 %20;\n+                        yield;\n+                    }\n+                    ^body(%21 : Var<int>)void -> {\n+                        %22 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %23 : java.lang.Number = var.load %4;\n+                        invoke %22 %23 @\"java.io.PrintStream::println(java.lang.Object)void\";\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test7(Object o) {\n+        for (int i = 0;\n+             i < 10 && o instanceof Number n; i += n.intValue()) {\n+            System.out.println(n);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternsTest.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,301 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with primitive casts.\n+ * @build PrimitiveCastTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester PrimitiveCastTest\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+public class PrimitiveCastTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromDouble\" (%0 : PrimitiveCastTest, %1 : double)void -> {\n+                %2 : Var<double> = var %1 @\"v\";\n+                %3 : double = var.load %2;\n+                %4 : Var<double> = var %3 @\"d\";\n+                %5 : double = var.load %2;\n+                %6 : float = conv %5;\n+                %7 : Var<float> = var %6 @\"f\";\n+                %8 : double = var.load %2;\n+                %9 : long = conv %8;\n+                %10 : Var<long> = var %9 @\"l\";\n+                %11 : double = var.load %2;\n+                %12 : int = conv %11;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : double = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : double = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : double = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromDouble(double v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromFloat\" (%0 : PrimitiveCastTest, %1 : float)void -> {\n+                %2 : Var<float> = var %1 @\"v\";\n+                %3 : float = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : float = var.load %2;\n+                %7 : Var<float> = var %6 @\"f\";\n+                %8 : float = var.load %2;\n+                %9 : long = conv %8;\n+                %10 : Var<long> = var %9 @\"l\";\n+                %11 : float = var.load %2;\n+                %12 : int = conv %11;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : float = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : float = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : float = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromFloat(float v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromLong\" (%0 : PrimitiveCastTest, %1 : long)void -> {\n+                %2 : Var<long> = var %1 @\"v\";\n+                %3 : long = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : long = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : long = var.load %2;\n+                %10 : Var<long> = var %9 @\"l\";\n+                %11 : long = var.load %2;\n+                %12 : int = conv %11;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : long = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : long = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : long = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromLong(long v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromInt\" (%0 : PrimitiveCastTest, %1 : int)void -> {\n+                %2 : Var<int> = var %1 @\"v\";\n+                %3 : int = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : int = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : int = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : int = var.load %2;\n+                %13 : Var<int> = var %12 @\"i\";\n+                %14 : int = var.load %2;\n+                %15 : short = conv %14;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : int = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : int = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromInt(int v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromShort\" (%0 : PrimitiveCastTest, %1 : short)void -> {\n+                %2 : Var<short> = var %1 @\"v\";\n+                %3 : short = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : short = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : short = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : short = var.load %2;\n+                %13 : int = conv %12;\n+                %14 : Var<int> = var %13 @\"i\";\n+                %15 : short = var.load %2;\n+                %16 : Var<short> = var %15 @\"s\";\n+                %17 : short = var.load %2;\n+                %18 : char = conv %17;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : short = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromShort(short v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromChar\" (%0 : PrimitiveCastTest, %1 : char)void -> {\n+                %2 : Var<char> = var %1 @\"v\";\n+                %3 : char = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : char = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : char = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : char = var.load %2;\n+                %13 : int = conv %12;\n+                %14 : Var<int> = var %13 @\"i\";\n+                %15 : char = var.load %2;\n+                %16 : short = conv %15;\n+                %17 : Var<short> = var %16 @\"s\";\n+                %18 : char = var.load %2;\n+                %19 : Var<char> = var %18 @\"c\";\n+                %20 : char = var.load %2;\n+                %21 : byte = conv %20;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromChar(char v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"testFromByte\" (%0 : PrimitiveCastTest, %1 : byte)void -> {\n+                %2 : Var<byte> = var %1 @\"v\";\n+                %3 : byte = var.load %2;\n+                %4 : double = conv %3;\n+                %5 : Var<double> = var %4 @\"d\";\n+                %6 : byte = var.load %2;\n+                %7 : float = conv %6;\n+                %8 : Var<float> = var %7 @\"f\";\n+                %9 : byte = var.load %2;\n+                %10 : long = conv %9;\n+                %11 : Var<long> = var %10 @\"l\";\n+                %12 : byte = var.load %2;\n+                %13 : int = conv %12;\n+                %14 : Var<int> = var %13 @\"i\";\n+                %15 : byte = var.load %2;\n+                %16 : short = conv %15;\n+                %17 : Var<short> = var %16 @\"s\";\n+                %18 : byte = var.load %2;\n+                %19 : char = conv %18;\n+                %20 : Var<char> = var %19 @\"c\";\n+                %21 : byte = var.load %2;\n+                %22 : Var<byte> = var %21 @\"b\";\n+                return;\n+            };\n+            \"\"\")\n+    @SuppressWarnings(\"cast\")\n+    void testFromByte(byte v) {\n+        double d = (double) v;\n+        float f = (float) v;\n+        long l = (long) v;\n+        int i = (int) v;\n+        short s = (short) v;\n+        char c = (char) v;\n+        byte b = (byte) v;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/PrimitiveCastTest.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with quotable lambdas.\n+ * @build QuotableIntersectionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester QuotableIntersectionTest\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+\n+public class QuotableIntersectionTest {\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_NO_PARAM_VOID = (Quotable & Runnable) () -> {\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda ()int -> {\n+                    %2 : int = constant @\"1\";\n+                    return %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_NO_PARAM_CONST = (Quotable & IntSupplier) () -> 1;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int -> {\n+                      %2 : Var<int> = var %1 @\"x\";\n+                      %3 : int = var.load %2;\n+                      return %3;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_ID = (Quotable & IntUnaryOperator) x -> x;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda (%1 : int, %2 : int)int -> {\n+                    %3 : Var<int> = var %1 @\"x\";\n+                    %4 : Var<int> = var %2 @\"y\";\n+                    %5 : int = var.load %3;\n+                    %6 : int = var.load %4;\n+                    %7 : int = add %5 %6;\n+                    return %7;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_PLUS = (Quotable & IntBinaryOperator) (x, y) -> x + y;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                    %1 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n+                    throw %1;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_THROW_NO_PARAM = (Quotable & Runnable) () -> {\n+        throw new AssertionError();\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%1 : Var<int>)void -> {\n+                %2 : java.lang.reflect.code.Quotable = lambda (%4 : int)int -> {\n+                    %5 : Var<int> = var %4 @\"y\";\n+                    %6 : int = var.load %1;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_CAPTURE_PARAM = new Object() {\n+        Quotable captureContext(int x) {\n+            return (Quotable & IntUnaryOperator) y -> x + y;\n+        }\n+    }.captureContext(42);\n+\n+    static class Context {\n+        int x, y;\n+\n+        Quotable capture() {\n+            return (Quotable & IntUnaryOperator) z -> x + y + z;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableIntersectionTest$Context)void -> {\n+                %1 : java.lang.reflect.code.Quotable = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"z\";\n+                    %5 : int = field.load %0 @\"QuotableIntersectionTest$Context::x()int\";\n+                    %6 : int = field.load %0 @\"QuotableIntersectionTest$Context::y()int\";\n+                    %7 : int = add %5 %6;\n+                    %8 : int = var.load %4;\n+                    %9 : int = add %7 %8;\n+                    return %9;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_CAPTURE_FIELD = new Context().capture();\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureParam\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"x\";\n+                %2 : java.util.function.IntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"y\";\n+                    %5 : int = var.load %1;\n+                    %6 : int = var.load %4;\n+                    %7 : int = add %5 %6;\n+                    return %7;\n+                };\n+                %8 : Var<java.util.function.IntUnaryOperator> = var %2 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    static void captureParam(int x) {\n+        IntUnaryOperator op = (IntUnaryOperator & Quotable) y -> x + y;\n+    }\n+\n+    int x, y;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureField\" (%0 : QuotableIntersectionTest)void -> {\n+                %1 : java.util.function.IntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"z\";\n+                    %4 : int = field.load %0 @\"QuotableIntersectionTest::x()int\";\n+                    %5 : int = field.load %0 @\"QuotableIntersectionTest::y()int\";\n+                    %6 : int = add %4 %5;\n+                    %7 : int = var.load %3;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                %9 : Var<java.util.function.IntUnaryOperator> = var %1 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    void captureField() {\n+        IntUnaryOperator op = (IntUnaryOperator & Quotable) z -> x + y + z;\n+    }\n+\n+    static void m() {\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda ()void -> {\n+                      invoke @\"QuotableIntersectionTest::m()void\";\n+                      return;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_NO_PARAM_VOID_REF = (Quotable & Runnable) QuotableIntersectionTest::m;\n+\n+    static int g(int i) {\n+        return i;\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                  %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int -> {\n+                      %2 : Var<int> = var %1 @\"x$0\";\n+                      %3 : int = var.load %2;\n+                      %4 : int = invoke %3 @\"QuotableIntersectionTest::g(int)int\";\n+                      return %4;\n+                  };\n+                  return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_INT_PARAM_INT_RET_REF = (Quotable & IntUnaryOperator) QuotableIntersectionTest::g;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.Quotable = lambda (%1 : int)int[] -> {\n+                    %2 : Var<int> = var %1 @\"x$0\";\n+                    %3 : int = var.load %2;\n+                    %4 : int[] = new %3 @\"func<int[], int>\";\n+                    return %4;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_INT_PARAM_ARR_RET_REF = (Quotable & IntFunction<int[]>) int[]::new;\n+\n+    static class ContextRef {\n+        int g(int i) {\n+            return i;\n+        }\n+\n+        Quotable capture() {\n+            return (Quotable & IntUnaryOperator) this::g;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableIntersectionTest$ContextRef)void -> {\n+                %1 : java.lang.reflect.code.Quotable = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"x$0\";\n+                    %5 : int = var.load %4;\n+                    %6 : int = invoke %0 %5 @\"QuotableIntersectionTest$ContextRef::g(int)int\";\n+                    return %6;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quotable QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableIntersectionTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with quotable lambdas.\n+ * @build QuotableSubtypeTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester QuotableSubtypeTest\n+ *\/\n+\n+import java.lang.reflect.code.Quotable;\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.IntBinaryOperator;\n+import java.util.function.IntFunction;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+\n+public class QuotableSubtypeTest {\n+\n+    interface QuotableRunnable extends Runnable, Quotable { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableRunnable = lambda ()void -> {\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableRunnable QUOTED_NO_PARAM_VOID = () -> { };\n+\n+    interface QuotableIntSupplier extends IntSupplier, Quotable { }\n+\n+    @IR(\"\"\"\n+           func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntSupplier = lambda ()int -> {\n+                    %2 : int = constant @\"1\";\n+                    return %2;\n+                };\n+                return;\n+           };\n+            \"\"\")\n+    static final QuotableIntSupplier QUOTED_NO_PARAM_CONST = () -> 1;\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"x\";\n+                    %4 : int = var.load %3;\n+                    return %4;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_ID = x -> x;\n+\n+    interface QuotableIntBinaryOperator extends IntBinaryOperator, Quotable { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntBinaryOperator = lambda (%2 : int, %3 : int)int -> {\n+                    %4 : Var<int> = var %2 @\"x\";\n+                    %5 : Var<int> = var %3 @\"y\";\n+                    %6 : int = var.load %4;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntBinaryOperator QUOTED_PLUS = (x, y) -> x + y;\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableRunnable = lambda ()void -> {\n+                    %2 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n+                    throw %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableRunnable QUOTED_THROW_NO_PARAM = () -> { throw new AssertionError(); };\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%1 : Var<int>)void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%4 : int)int -> {\n+                    %5 : Var<int> = var %4 @\"y\";\n+                    %6 : int = var.load %1;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_CAPTURE_PARAM = new Object() {\n+        QuotableIntUnaryOperator captureContext(int x) {\n+            return y -> x + y;\n+        }\n+    }.captureContext(42);\n+\n+    static class Context {\n+        int x, y;\n+\n+        QuotableIntUnaryOperator capture() {\n+            return z -> x + y + z;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableSubtypeTest$Context)void -> {\n+                %1 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"z\";\n+                    %5 : int = field.load %0 @\"QuotableSubtypeTest$Context::x()int\";\n+                    %6 : int = field.load %0 @\"QuotableSubtypeTest$Context::y()int\";\n+                    %7 : int = add %5 %6;\n+                    %8 : int = var.load %4;\n+                    %9 : int = add %7 %8;\n+                    return %9;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_CAPTURE_FIELD = new Context().capture();\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureParam\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"x\";\n+                %2 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"y\";\n+                    %5 : int = var.load %1;\n+                    %6 : int = var.load %4;\n+                    %7 : int = add %5 %6;\n+                    return %7;\n+                };\n+                %8 : Var<QuotableSubtypeTest$QuotableIntUnaryOperator> = var %2 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    static void captureParam(int x) {\n+        QuotableIntUnaryOperator op = y -> x + y;\n+    }\n+\n+    int x, y;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureField\" (%0 : QuotableSubtypeTest)void -> {\n+                %1 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"z\";\n+                    %4 : int = field.load %0 @\"QuotableSubtypeTest::x()int\";\n+                    %5 : int = field.load %0 @\"QuotableSubtypeTest::y()int\";\n+                    %6 : int = add %4 %5;\n+                    %7 : int = var.load %3;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                %9 : Var<QuotableSubtypeTest$QuotableIntUnaryOperator> = var %1 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    void captureField() {\n+        QuotableIntUnaryOperator op = z -> x + y + z;\n+    }\n+\n+    static void m() { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableRunnable = lambda ()void -> {\n+                    invoke @\"QuotableSubtypeTest::m()void\";\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableRunnable QUOTED_NO_PARAM_VOID_REF = QuotableSubtypeTest::m;\n+\n+    static int g(int i) { return i; }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"x$0\";\n+                    %4 : int = var.load %3;\n+                    %5 : int = invoke %4 @\"QuotableSubtypeTest::g(int)int\";\n+                    return %5;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_INT_PARAM_INT_RET_REF = QuotableSubtypeTest::g;\n+\n+    interface QuotableIntFunction<A> extends Quotable, IntFunction<A> { }\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : QuotableSubtypeTest$QuotableIntFunction<int[]> = lambda (%2 : int)int[] -> {\n+                    %3 : Var<int> = var %2 @\"x$0\";\n+                    %4 : int = var.load %3;\n+                    %5 : int[] = new %4 @\"func<int[], int>\";\n+                    return %5;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntFunction<int[]> QUOTED_INT_PARAM_ARR_RET_REF = int[]::new;\n+\n+    static class ContextRef {\n+        int g(int i) { return i; }\n+\n+        QuotableIntUnaryOperator capture() {\n+            return this::g;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotableSubtypeTest$ContextRef)void -> {\n+                %1 : QuotableSubtypeTest$QuotableIntUnaryOperator = lambda (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"x$0\";\n+                    %5 : int = var.load %4;\n+                    %6 : int = invoke %0 %5 @\"QuotableSubtypeTest$ContextRef::g(int)int\";\n+                    return %6;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final QuotableIntUnaryOperator QUOTED_CAPTURE_THIS_REF = new ContextRef().capture();\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotableSubtypeTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.code.Quotable;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.IntStream;\n+\n+\/*\n+ * @test\n+ * @summary test that invoking Quotable#quoted returns the same instance\n+ * @run testng QuotedSameInstanceTest\n+ *\/\n+\n+public class QuotedSameInstanceTest {\n+\n+    private static final Quotable q1 = (Quotable & Runnable) () -> {\n+    };\n+\n+    @Test\n+    void testWithOneThread() {\n+        Assert.assertSame(q1.quoted(), q1.quoted());\n+    }\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable { }\n+    private static final QuotableIntUnaryOperator q2 = x -> x;\n+\n+    @Test\n+    void testWithMultiThreads() {\n+        Object[] quotedObjects = IntStream.range(0, 1024).parallel().mapToObj(__ -> q2.quoted()).toArray();\n+        for (int i = 1; i < quotedObjects.length; i++) {\n+            Assert.assertSame(quotedObjects[i], quotedObjects[i - 1]);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedSameInstanceTest.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with quoted lambdas.\n+ * @build QuotedTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester QuotedTest\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+import java.lang.runtime.CodeReflection;\n+\n+public class QuotedTest {\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                 %0 : java.lang.reflect.code.CoreOps$Closure<void> = closure ()void -> {\n+                    return;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_NO_PARAM_VOID = () -> {\n+    };\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int> = closure ()int -> {\n+                    %2 : int = constant @\"1\";\n+                    return %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_NO_PARAM_CONST = () -> 1;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%2 : int)int -> {\n+                    %3 : Var<int> = var %2 @\"x\";\n+                    %4 : int = var.load %3;\n+                    return %4;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_ID = (int x) -> x;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int, int, int> = closure (%2 : int, %3 : int)int -> {\n+                    %4 : Var<int> = var %2 @\"x\";\n+                    %5 : Var<int> = var %3 @\"y\";\n+                    %6 : int = var.load %4;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_PLUS = (int x, int y) -> x + y;\n+\n+    @IR(\"\"\"\n+            func @\"f\" ()void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<java.lang.Object> = closure ()java.lang.Object -> {\n+                    %2 : java.lang.AssertionError = new @\"func<java.lang.AssertionError>\";\n+                    throw %2;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_THROW_NO_PARAM = () -> {\n+        throw new AssertionError();\n+    };\n+\n+    \/\/ can we write out the root op then extract the closure ?\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%1: Var<int>)void -> {\n+                %0 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%4 : int)int -> {\n+                    %5 : Var<int> = var %4 @\"y\";\n+                    %6 : int = var.load %1;\n+                    %7 : int = var.load %5;\n+                    %8 : int = add %6 %7;\n+                    return %8;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_CAPTURE_PARAM = new Object() {\n+        Quoted captureContext(int x) {\n+            return (int y) -> x + y;\n+        }\n+    }.captureContext(42);\n+\n+    static class Context {\n+        int x, y;\n+\n+        Quoted capture() {\n+            return (int z) -> x + y + z;\n+        }\n+    }\n+\n+    @IR(\"\"\"\n+            func @\"f\" (%0 : QuotedTest$Context)void -> {\n+                %1 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%3 : int)int -> {\n+                    %4 : Var<int> = var %3 @\"z\";\n+                    %5 : int = field.load %0 @\"QuotedTest$Context::x()int\";\n+                    %6 : int = field.load %0 @\"QuotedTest$Context::y()int\";\n+                    %7 : int = add %5 %6;\n+                    %8 : int = var.load %4;\n+                    %9 : int = add %7 %8;\n+                    return %9;\n+                };\n+                return;\n+            };\n+            \"\"\")\n+    static final Quoted QUOTED_CAPTURE_FIELD = new Context().capture();\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureParam\" (%0 : int)void -> {\n+                %1 : Var<int> = var %0 @\"x\";\n+                %2 : java.lang.reflect.code.Quoted = quoted ()void -> {\n+                    %3 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%4 : int)int -> {\n+                        %5 : Var<int> = var %4 @\"y\";\n+                        %6 : int = var.load %1;\n+                        %7 : int = var.load %5;\n+                        %8 : int = add %6 %7;\n+                        return %8;\n+                    };\n+                    yield %3;\n+                };\n+                %9 : Var<java.lang.reflect.code.Quoted> = var %2 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    static void captureParam(int x) {\n+        Quoted op = (int y) -> x + y;\n+    }\n+\n+    int x, y;\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"captureField\" (%0 : QuotedTest)void -> {\n+                %1 : java.lang.reflect.code.Quoted = quoted ()void -> {\n+                    %2 : java.lang.reflect.code.CoreOps$Closure<int, int> = closure (%3 : int)int -> {\n+                        %4 : Var<int> = var %3 @\"z\";\n+                        %5 : int = field.load %0 @\"QuotedTest::x()int\";\n+                        %6 : int = field.load %0 @\"QuotedTest::y()int\";\n+                        %7 : int = add %5 %6;\n+                        %8 : int = var.load %4;\n+                        %9 : int = add %7 %8;\n+                        return %9;\n+                    };\n+                    yield %2;\n+                };\n+                %10 : Var<java.lang.reflect.code.Quoted> = var %1 @\"op\";\n+                return;\n+            };\n+            \"\"\")\n+    void captureField() {\n+        Quoted op = (int z) -> x + y + z;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/QuotedTest.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,504 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with switch expressions.\n+ * @enablePreview\n+ * @build SwitchExpressionTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester SwitchExpressionTest\n+ *\/\n+\n+public class SwitchExpressionTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelRule\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %7 : java.lang.String = constant @\"FOO\";\n+                        yield %7;\n+                    }\n+                    ^constantCaseLabel(%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %11 : java.lang.String = constant @\"FOO\";\n+                        yield %11;\n+                    }\n+                    ^constantCaseLabel(%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        yield %15;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelRule(String r) {\n+        return switch (r) {\n+            case \"FOO\" -> \"FOO\";\n+            case \"BAR\" -> \"FOO\";\n+            case \"BAZ\" -> \"FOO\";\n+            default -> \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelsRule\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : boolean = java.cor\n+                            ()boolean -> {\n+                                %6 : java.lang.String = constant @\"FOO\";\n+                                %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : java.lang.String = constant @\"BAR\";\n+                                %9 : boolean = invoke %4 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : java.lang.String = constant @\"BAZ\";\n+                                %11 : boolean = invoke %4 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %11;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %12 : java.lang.String = constant @\"FOO\";\n+                        yield %12;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %13 : java.lang.String = constant @\"\";\n+                        java.yield %13;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelsRule(String r) {\n+        return switch (r) {\n+            case \"FOO\", \"BAR\", \"BAZ\" -> \"FOO\";\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelStatement\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %7 : java.lang.String = constant @\"FOO\";\n+                        java.yield %7;\n+                    }\n+                    ^constantCaseLabel(%8 : java.lang.String)boolean -> {\n+                        %9 : java.lang.String = constant @\"BAR\";\n+                        %10 : boolean = invoke %8 %9 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %10;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %11 : java.lang.String = constant @\"FOO\";\n+                        java.yield %11;\n+                    }\n+                    ^constantCaseLabel(%12 : java.lang.String)boolean -> {\n+                        %13 : java.lang.String = constant @\"BAZ\";\n+                        %14 : boolean = invoke %12 %13 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %14;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %15 : java.lang.String = constant @\"FOO\";\n+                        java.yield %15;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %16 : java.lang.String = constant @\"\";\n+                        java.yield %16;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelStatement(String r) {\n+        return switch (r) {\n+            case \"FOO\" : yield \"FOO\";\n+            case \"BAR\" : yield \"FOO\";\n+            case \"BAZ\" : yield \"FOO\";\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelsStatement\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : boolean = java.cor\n+                            ()boolean -> {\n+                                %6 : java.lang.String = constant @\"FOO\";\n+                                %7 : boolean = invoke %4 %6 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %7;\n+                            }\n+                            ()boolean -> {\n+                                %8 : java.lang.String = constant @\"BAR\";\n+                                %9 : boolean = invoke %4 %8 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %9;\n+                            }\n+                            ()boolean -> {\n+                                %10 : java.lang.String = constant @\"BAZ\";\n+                                %11 : boolean = invoke %4 %10 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                                yield %11;\n+                            };\n+                        yield %5;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %12 : java.lang.String = constant @\"FOO\";\n+                        java.yield %12;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        java.block ()void -> {\n+                            %13 : java.lang.String = constant @\"\";\n+                            java.yield %13;\n+                        };\n+                        unreachable;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelsStatement(String r) {\n+        return switch (r) {\n+            case \"FOO\", \"BAR\", \"BAZ\" : yield \"FOO\";\n+            default : { yield \"\"; }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelStatements\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        java.block ()void -> {\n+                            %7 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                            %8 : java.lang.String = constant @\"FOO\";\n+                            invoke %7 %8 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                            yield;\n+                        };\n+                        java.block ()void -> {\n+                            %9 : java.lang.String = constant @\"FOO\";\n+                            java.yield %9;\n+                        };\n+                        unreachable;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %10 : java.lang.String = constant @\"\";\n+                        java.yield %10;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelStatements(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+                System.out.println(\"FOO\");\n+            }\n+            {\n+                yield \"FOO\";\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"constantCaseLabelFallthrough\" (%0 : java.lang.String)java.lang.Object -> {\n+                %1 : Var<java.lang.String> = var %0 @\"r\";\n+                %2 : java.lang.String = var.load %1;\n+                %3 : java.lang.Object = java.switch.expression %2\n+                    ^constantCaseLabel(%4 : java.lang.String)boolean -> {\n+                        %5 : java.lang.String = constant @\"FOO\";\n+                        %6 : boolean = invoke %4 %5 @\"java.util.Objects::equals(java.lang.Object, java.lang.Object)boolean\";\n+                        yield %6;\n+                    }\n+                    ()java.lang.Object -> {\n+                        java.block ()void -> {\n+                            %7 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                            %8 : java.lang.String = constant @\"FOO\";\n+                            invoke %7 %8 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                            yield;\n+                        };\n+                        java.switch.fallthrough;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %9 : java.lang.String = constant @\"\";\n+                        java.yield %9;\n+                    };\n+                return %3;\n+            };\n+            \"\"\")\n+    public static Object constantCaseLabelFallthrough(String r) {\n+        return switch (r) {\n+            case \"FOO\" : {\n+                System.out.println(\"FOO\");\n+            }\n+            default : yield \"\";\n+        };\n+    }\n+\n+    record A(Number n) {\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"patternCaseLabel\" (%0 : java.lang.Object)java.lang.Object -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"r\";\n+                %2 : java.lang.Object = var.load %1;\n+                %3 : java.lang.Number = constant @null;\n+                %4 : Var<java.lang.Number> = var %3 @\"n\";\n+                %5 : java.lang.String = constant @null;\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                %7 : java.lang.Object = java.switch.expression %2\n+                    ^patternCaseLabel(%8 : java.lang.Object)boolean -> {\n+                        %9 : boolean = pattern.match %8\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> -> {\n+                                %10 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                %11 : java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> = pattern.record %10 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                                yield %11;\n+                            }\n+                            ^match(%12 : java.lang.Number)void -> {\n+                                var.store %4 %12;\n+                                yield;\n+                            };\n+                        yield %9;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %13 : java.lang.Number = var.load %4;\n+                        java.yield %13;\n+                    }\n+                    ^patternCaseLabel(%14 : java.lang.Object)boolean -> {\n+                        %15 : boolean = pattern.match %14\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                %16 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                yield %16;\n+                            }\n+                            ^match(%17 : java.lang.String)void -> {\n+                                var.store %6 %17;\n+                                yield;\n+                            };\n+                        yield %15;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %18 : java.lang.String = var.load %6;\n+                        java.yield %18;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %19 : java.lang.String = constant @\"\";\n+                        java.yield %19;\n+                    };\n+                return %7;\n+            };\n+            \"\"\")\n+    public static Object patternCaseLabel(Object r) {\n+        return switch (r) {\n+            case A(Number n) -> {\n+                yield n;\n+            }\n+            case String s -> {\n+                yield s;\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"patternCaseLabelGuard\" (%0 : java.lang.Object)java.lang.Object -> {\n+                %1 : Var<java.lang.Object> = var %0 @\"r\";\n+                %2 : java.lang.Object = var.load %1;\n+                %3 : java.lang.Number = constant @null;\n+                %4 : Var<java.lang.Number> = var %3 @\"n\";\n+                %5 : java.lang.String = constant @null;\n+                %6 : Var<java.lang.String> = var %5 @\"s\";\n+                %7 : java.lang.String = constant @null;\n+                %8 : Var<java.lang.String> = var %7 @\"s\";\n+                %9 : java.lang.Object = java.switch.expression %2\n+                    ^patternCaseLabel(%10 : java.lang.Object)boolean -> {\n+                        %11 : boolean = pattern.match %10\n+                            ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> -> {\n+                                %12 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.Number> = pattern.binding @\"n\";\n+                                %13 : java.lang.reflect.code.ExtendedOps$Pattern$Record<SwitchExpressionTest$A> = pattern.record %12 @\"(java.lang.Number n)SwitchExpressionTest$A\";\n+                                yield %13;\n+                            }\n+                            ^match(%14 : java.lang.Number)void -> {\n+                                var.store %4 %14;\n+                                yield;\n+                            };\n+                        yield %11;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %15 : java.lang.Number = var.load %4;\n+                        java.yield %15;\n+                    }\n+                    ^patternCaseLabel(%16 : java.lang.Object)boolean -> {\n+                        %17 : boolean = java.cand\n+                            ()boolean -> {\n+                                %18 : boolean = pattern.match %16\n+                                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                        %19 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                        yield %19;\n+                                    }\n+                                    ^match(%20 : java.lang.String)void -> {\n+                                        var.store %6 %20;\n+                                        yield;\n+                                    };\n+                                yield %18;\n+                            }\n+                            ()boolean -> {\n+                                %21 : java.lang.String = var.load %6;\n+                                %22 : int = invoke %21 @\"java.lang.String::length()int\";\n+                                %23 : int = constant @\"5\";\n+                                %24 : boolean = lt %22 %23;\n+                                yield %24;\n+                            };\n+                        yield %17;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %25 : java.lang.String = var.load %6;\n+                        java.yield %25;\n+                    }\n+                    ^patternCaseLabel(%26 : java.lang.Object)boolean -> {\n+                        %27 : boolean = java.cand\n+                            ()boolean -> {\n+                                %28 : boolean = pattern.match %26\n+                                    ^pattern()java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> -> {\n+                                        %29 : java.lang.reflect.code.ExtendedOps$Pattern$Binding<java.lang.String> = pattern.binding @\"s\";\n+                                        yield %29;\n+                                    }\n+                                    ^match(%30 : java.lang.String)void -> {\n+                                        var.store %8 %30;\n+                                        yield;\n+                                    };\n+                                yield %28;\n+                            }\n+                            ()boolean -> {\n+                                %31 : java.lang.String = var.load %8;\n+                                %32 : int = invoke %31 @\"java.lang.String::length()int\";\n+                                %33 : int = constant @\"10\";\n+                                %34 : boolean = lt %32 %33;\n+                                yield %34;\n+                            };\n+                        yield %27;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %35 : java.lang.String = var.load %8;\n+                        java.yield %35;\n+                    }\n+                    ^defaultCaseLabel()void -> {\n+                        yield;\n+                    }\n+                    ()java.lang.Object -> {\n+                        %36 : java.lang.String = constant @\"\";\n+                        java.yield %36;\n+                    };\n+                return %9;\n+            };\n+            \"\"\")\n+    public static Object patternCaseLabelGuard(Object r) {\n+        return switch (r) {\n+            case A(Number n) -> {\n+                yield n;\n+            }\n+            case String s when s.length() < 5 -> {\n+                yield s;\n+            }\n+            case String s when s.length() < 10 -> {\n+                yield s;\n+            }\n+            default -> {\n+                yield \"\";\n+            }\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/SwitchExpressionTest.java","additions":504,"deletions":0,"binary":false,"changes":504,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ * @summary Smoke test for accessing IR from annotation processors\n+ * @run main TestIRFromAnnotation\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.op.CoreOps.FuncOp;\n+import java.lang.reflect.code.op.ExtendedOps;\n+import java.lang.reflect.code.parser.OpParser;\n+import java.lang.reflect.code.writer.OpWriter;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.*;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class TestIRFromAnnotation {\n+\n+    public static void main(String... args) throws Exception {\n+        String testSrc = System.getProperty(\"test.src\");\n+        File baseDir = Path.of(testSrc).toFile();\n+        new TestIRFromAnnotation().run(baseDir);\n+    }\n+\n+    void run(File baseDir) throws Exception {\n+        for (File file : getAllFiles(List.of(baseDir))) {\n+            if (!file.exists() || !file.getName().endsWith(\".java\")) {\n+                continue;\n+            }\n+            analyze(file);\n+        }\n+    }\n+\n+    void analyze(File source) {\n+        try {\n+            JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+            JavaFileManager fileManager = compiler.getStandardFileManager(null, null, Charset.defaultCharset());\n+            JavacTask task = (JavacTask)compiler.getTask(null, fileManager, null,\n+                    List.of(\"-proc:only\",\n+                            \"--enable-preview\",\n+                            \"--source\", Integer.toString(SourceVersion.latest().runtimeVersion().feature())),\n+                    null, List.of(new SourceFile(source)));\n+            task.setProcessors(List.of(new Processor()));\n+            task.analyze();\n+        } catch (Throwable ex) {\n+            throw new AssertionError(\"Unexpected exception when analyzing: \" + source, ex);\n+        }\n+    }\n+\n+    File[] getAllFiles(List<File> roots) throws IOException {\n+        long now = System.currentTimeMillis();\n+        ArrayList<File> buf = new ArrayList<>();\n+        for (File file : roots) {\n+            Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    buf.add(file.toFile());\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        long delta = System.currentTimeMillis() - now;\n+        System.err.println(\"All files = \" + buf.size() + \" \" + delta);\n+        return buf.toArray(new File[buf.size()]);\n+    }\n+\n+    static class SourceFile extends SimpleJavaFileObject {\n+\n+        private final File file;\n+        protected SourceFile(File file) {\n+            super(file.toURI(), Kind.SOURCE);\n+            this.file = file;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+            return Files.readString(file.toPath());\n+        }\n+    }\n+\n+    public static class Processor extends JavacTestingAbstractProcessor {\n+\n+        public boolean process(Set<? extends TypeElement> annotations,\n+                               RoundEnvironment roundEnvironment) {\n+            class Scan extends ElementScanner<Void,Void> {\n+                @Override\n+                public Void visitExecutable(ExecutableElement e, Void p) {\n+                    IR ir = e.getAnnotation(IR.class);\n+                    if (ir == null) {\n+                        return null; \/\/ skip\n+                    }\n+                    Optional<Object> body = elements.getBody(e);\n+                    if (!body.isPresent()) {\n+                        throw new AssertionError(String.format(\"No body found in method %s annotated with @IR\",\n+                                toMethodString(e)));\n+                    }\n+                    String actualOp = canonicalizeModel((FuncOp)body.get());\n+                    String expectedOp = canonicalizeModel(ir.value());\n+                    if (!actualOp.equals(expectedOp)) {\n+                        throw new AssertionError(String.format(\"Bad IR found in %s:\\n%s\\nExpected:\\n%s\",\n+                                toMethodString(e), actualOp, expectedOp));\n+                    }\n+                    return null;\n+                }\n+            }\n+            Scan scan = new Scan();\n+            for (Element e : roundEnvironment.getRootElements()) {\n+                scan.scan(e);\n+            }\n+            return true;\n+        }\n+    }\n+\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Op o) {\n+        return canonicalizeModel(serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n+    static String canonicalizeModel(String d) {\n+        return serialize(OpParser.fromString(ExtendedOps.FACTORY, d).get(0));\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n+    }\n+\n+    static String toMethodString(ExecutableElement e) {\n+        return e.getEnclosingElement() + \".\" + e;\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestIRFromAnnotation.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with throw statements.\n+ * @build ThrowTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester ThrowTest\n+ *\/\n+\n+public class ThrowTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : ThrowTest)void -> {\n+                %1 : java.lang.RuntimeException = new @\"func<java.lang.RuntimeException>\";\n+                throw %1;\n+            };\n+            \"\"\")\n+    void test1() {\n+        throw new RuntimeException();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/ThrowTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with try statements.\n+ * @build TryTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester TryTest\n+ *\/\n+\n+public class TryTest {\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^catch(%4 : java.lang.Exception)void -> {\n+                        %5 : Var<java.lang.Exception> = var %4 @\"e\";\n+                        %6 : int = constant @\"2\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^finally()void -> {\n+                        %7 : int = constant @\"3\";\n+                        var.store %2 %7;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } catch (Exception e) {\n+            i = 2;\n+        } finally {\n+            i = 3;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^finally()void -> {\n+                        %4 : int = constant @\"3\";\n+                        var.store %2 %4;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test2() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } finally {\n+            i = 3;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^catch(%4 : java.lang.Exception)void -> {\n+                        %5 : Var<java.lang.Exception> = var %4 @\"e\";\n+                        %6 : java.lang.Exception = var.load %5;\n+                        invoke %6 @\"java.lang.Exception::printStackTrace()void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+\n+    static class A implements AutoCloseable {\n+        final B b;\n+\n+        public A() {\n+            this.b = null;\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+\n+        }\n+    }\n+\n+    static class B implements AutoCloseable {\n+        C c;\n+\n+        @Override\n+        public void close() throws Exception {\n+\n+        }\n+    }\n+\n+    static class C implements AutoCloseable {\n+        @Override\n+        public void close() throws Exception {\n+\n+        }\n+    }\n+\n+    A a() {\n+        return null;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test4\" (%0 : TryTest)void -> {\n+                java.try\n+                    ^resources()Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> -> {\n+                        %1 : TryTest$A = invoke %0 @\"TryTest::a()TryTest$A\";\n+                        %2 : Var<TryTest$A> = var %1 @\"a\";\n+                        %3 : TryTest$A = var.load %2;\n+                        %4 : TryTest$B = field.load %3 @\"TryTest$A::b()TryTest$B\";\n+                        %5 : TryTest$A = var.load %2;\n+                        %6 : TryTest$B = field.load %5 @\"TryTest$A::b()TryTest$B\";\n+                        %7 : TryTest$C = field.load %6 @\"TryTest$B::c()TryTest$C\";\n+                        %8 : Var<TryTest$C> = var %7 @\"c\";\n+                        %9 : Tuple<Var<TryTest$A>, TryTest$B, Var<TryTest$C>> = tuple %2 %4 %8;\n+                        yield %9;\n+                    }\n+                    (%10 : Var<TryTest$A>, %11 : Var<TryTest$C>)void -> {\n+                        %12 : TryTest$A = var.load %10;\n+                        %13 : Var<TryTest$A> = var %12 @\"_a\";\n+                        %14 : TryTest$C = var.load %11;\n+                        %15 : Var<TryTest$C> = var %14 @\"_c\";\n+                        yield;\n+                    }\n+                    ^catch(%16 : java.lang.Throwable)void -> {\n+                        %17 : Var<java.lang.Throwable> = var %16 @\"t\";\n+                        %18 : java.lang.Throwable = var.load %17;\n+                        invoke %18 @\"java.lang.Throwable::printStackTrace()void\";\n+                        yield;\n+                    }\n+                    ^finally()void -> {\n+                        %19 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %20 : java.lang.String = constant @\"F\";\n+                        invoke %19 %20 @\"java.io.PrintStream::println(java.lang.String)void\";\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test4() throws Exception {\n+        try (A a = a(); a.b; C c = a.b.c) {\n+            A _a = a;\n+            C _c = c;\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        } finally {\n+            System.out.println(\"F\");\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test5\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        %3 : int = constant @\"1\";\n+                        var.store %2 %3;\n+                        yield;\n+                    }\n+                    ^catch(%4 : java.lang.NullPointerException)void -> {\n+                        %5 : Var<java.lang.NullPointerException> = var %4 @\"e\";\n+                        %6 : int = constant @\"2\";\n+                        var.store %2 %6;\n+                        yield;\n+                    }\n+                    ^catch(%7 : java.lang.OutOfMemoryError)void -> {\n+                        %8 : Var<java.lang.OutOfMemoryError> = var %7 @\"e\";\n+                        %9 : int = constant @\"3\";\n+                        var.store %2 %9;\n+                        yield;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test5() {\n+        int i = 0;\n+        try {\n+            i = 1;\n+        } catch (NullPointerException e) {\n+            i = 2;\n+        } catch (OutOfMemoryError e) {\n+            i = 3;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test6\" (%0 : TryTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.try\n+                    ()void -> {\n+                        return;\n+                    }\n+                    ^catch(%3 : java.lang.Exception)void -> {\n+                        %4 : Var<java.lang.Exception> = var %3 @\"e\";\n+                        %5 : java.lang.Exception = var.load %4;\n+                        throw %5;\n+                    }\n+                    ^finally()void -> {\n+                        return;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test6() {\n+        int i = 0;\n+        try {\n+            return;\n+        } catch (Exception e) {\n+            throw e;\n+        } finally {\n+            return;\n+        }\n+     }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/TryTest.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.runtime.CodeReflection;\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for code reflection with while loops.\n+ * @build WhileLoopTest\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester WhileLoopTest\n+ *\/\n+\n+public class WhileLoopTest {\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test1\" (%0 : WhileLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.while\n+                    ^cond()boolean -> {\n+                        %3 : int = var.load %2;\n+                        %4 : int = constant @\"10\";\n+                        %5 : boolean = lt %3 %4;\n+                        yield %5;\n+                    }\n+                    ^body()void -> {\n+                        %6 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %7 : int = var.load %2;\n+                        invoke %6 %7 @\"java.io.PrintStream::println(int)void\";\n+                        %8 : int = var.load %2;\n+                        %9 : int = constant @\"1\";\n+                        %10 : int = add %8 %9;\n+                        var.store %2 %10;\n+                        java.continue;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test1() {\n+        int i = 0;\n+        while (i < 10) {\n+            System.out.println(i);\n+            i = i + 1;\n+        }\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test2\" (%0 : WhileLoopTest)int -> {\n+              %1 : int = constant @\"0\";\n+              %2 : Var<int> = var %1 @\"i\";\n+              java.while\n+                  ^cond()boolean -> {\n+                      %3 : int = var.load %2;\n+                      %4 : int = constant @\"10\";\n+                      %5 : boolean = lt %3 %4;\n+                      yield %5;\n+                  }\n+                  ^body()void -> {\n+                      %6 : int = var.load %2;\n+                      return %6;\n+                  };\n+              %7 : int = constant @\"-1\";\n+              return %7;\n+            };\n+            \"\"\")\n+    int test2() {\n+        int i = 0;\n+        while (i < 10) {\n+            return i;\n+        }\n+        return -1;\n+    }\n+\n+    @CodeReflection\n+    @IR(\"\"\"\n+            func @\"test3\" (%0 : WhileLoopTest)void -> {\n+                %1 : int = constant @\"0\";\n+                %2 : Var<int> = var %1 @\"i\";\n+                java.do.while\n+                    ^body()void -> {\n+                        %3 : java.io.PrintStream = field.load @\"java.lang.System::out()java.io.PrintStream\";\n+                        %4 : int = var.load %2;\n+                        invoke %3 %4 @\"java.io.PrintStream::println(int)void\";\n+                        %5 : int = var.load %2;\n+                        %6 : int = constant @\"1\";\n+                        %7 : int = add %5 %6;\n+                        var.store %2 %7;\n+                        java.continue;\n+                    }\n+                    ^cond()boolean -> {\n+                        %8 : int = var.load %2;\n+                        %9 : int = constant @\"10\";\n+                        %10 : boolean = lt %8 %9;\n+                        yield %10;\n+                    };\n+                return;\n+            };\n+            \"\"\")\n+    void test3() {\n+        int i = 0;\n+        do {\n+            System.out.println(i);\n+            i = i + 1;\n+        } while (i < 10);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/WhileLoopTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestAssignment.out -XDrawDiagnostics TestAssignment.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+class TestAssignment {\n+    void test(boolean cond) {\n+        Quoted f_NoRet = () -> {};\n+        Quoted fiS_NoRet = (int i) -> \"\"; \/\/ ok (int->String)\n+        Quoted fiS_Ret = (int i) -> { return \"\"; }; \/\/ ok (int->String)\n+        Quoted fiV_NoRet = (int i) -> { }; \/\/ ok (int->V)\n+        Quoted fiV_Ret = (int i) -> { return; }; \/\/ ok (int->V)\n+        Quoted fiV_RetRet = (int i) -> { if (cond) return; else return; }; \/\/ ok (int->V)\n+        Quoted fiS_RetRet = (int i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ ok (int->String)\n+    }\n+\n+    void testImplicit(boolean cond) {\n+        Quoted fiS_NoRet = (i) -> \"\"; \/\/ error - no parameter types\n+        Quoted fiS_Ret = (i) -> { return \"\"; }; \/\/ error - no parameter types\n+        Quoted fiV_NoRet = (i) -> { }; \/\/ error - no parameter types\n+        Quoted fiV_Ret = (i) -> { return; }; \/\/ error - no parameter types\n+        Quoted fiV_RetRet = (i) -> { if (cond) return; else return; }; \/\/ error - no parameter types\n+        Quoted fiS_RetRet = (i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ error - no parameter types\n+    }\n+\n+    void testImplicitVar(boolean cond) {\n+        Quoted fiS_NoRet = (var i) -> \"\"; \/\/ error - no parameter types\n+        Quoted fiS_Ret = (var i) -> { return \"\"; }; \/\/ error - no parameter types\n+        Quoted fiV_NoRet = (var i) -> { }; \/\/ error - no parameter types\n+        Quoted fiV_Ret = (var i) -> { return; }; \/\/ error - no parameter types\n+        Quoted fiV_RetRet = (var i) -> { if (cond) return; else return; }; \/\/ error - no parameter types\n+        Quoted fiS_RetRet = (var i) -> { if (cond) return \"1\"; else return \"2\"; }; \/\/ error - no parameter types\n+    }\n+\n+    void testBadInferredReturn(boolean cond) {\n+        Quoted fi_RetVRetS = (int i) -> { if (cond) return; else return \"\"; }; \/\/ error - only one branch returns\n+        Quoted fi_RetS = (int i) -> { if (cond) { return \"2\"; } }; \/\/ error - one return, but body completes normally\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+TestAssignment.java:43:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:44:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:45:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:46:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:47:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:48:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:52:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:53:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:54:28: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:55:26: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:56:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:57:29: compiler.err.quoted.lambda.must.be.explicit\n+TestAssignment.java:61:41: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestAssignment.java:62:37: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestAssignment.out","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for captured values in quotable lambdas.\n+ * @run testng TestCaptureQuotable\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.reflect.code.op.CoreOps.Var;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quotable;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.function.IntSupplier;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.ToIntFunction;\n+import java.util.stream.IntStream;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestCaptureQuotable {\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntParam(int x) {\n+        Quotable quotable = (Quotable & IntUnaryOperator)y -> x + y;\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(((Var)quoted.capturedValues().values().iterator().next()).value(), x);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @Test\n+    public void testCaptureRefAndIntConstant() {\n+        final int x = 100;\n+        String hello = \"hello\";\n+        Quotable quotable = (Quotable & ToIntFunction<Number>)y -> y.intValue() + hello.length() + x;\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(quoted.capturedValues().size(), 2);\n+        Iterator<Object> it = quoted.capturedValues().values().iterator();\n+        assertEquals(((Var)it.next()).value(), hello);\n+        assertEquals(((Var)it.next()).value(), x);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1 + hello.length());\n+    }\n+\n+    @Test\n+    public void testCaptureMany() {\n+        int[] ia = new int[8];\n+        int i1 = ia[0] = 0;\n+        int i2 = ia[1] = 1;\n+        int i3 = ia[2] = 2;\n+        int i4 = ia[3] = 3;\n+        int i5 = ia[4] = 4;\n+        int i6 = ia[5] = 5;\n+        int i7 = ia[6] = 6;\n+        int i8 = ia[7] = 7;\n+\n+        Quotable quotable = (Quotable & IntSupplier) () -> i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8;\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(quoted.capturedValues().size(), ia.length);\n+        assertEquals(quoted.op().capturedValues(), new ArrayList<>(quoted.capturedValues().keySet()));\n+        Iterator<Object> it = quoted.capturedValues().values().iterator();\n+        int i = 0;\n+        while (it.hasNext()) {\n+            int actual = (int) ((Var)it.next()).value();\n+            assertEquals(actual, ia[i++]);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntField(int x) {\n+        class Context {\n+            final int x;\n+\n+            Context(int x) {\n+                this.x = x;\n+            }\n+\n+            Quotable quotable() {\n+                return (Quotable & IntUnaryOperator) y -> x + y;\n+            }\n+        }\n+        Context context = new Context(x);\n+        Quotable quotable = context.quotable();\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(quoted.capturedValues().values().iterator().next(), context);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @DataProvider(name = \"ints\")\n+    public Object[][] ints() {\n+        return IntStream.range(0, 50)\n+                .mapToObj(i -> new Object[] { i })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureReferenceReceiver(int i) {\n+        int prevCount = Box.count;\n+        Quotable quotable = (Quotable & IntUnaryOperator)new Box(i)::add;\n+        Quoted quoted = quotable.quoted();\n+        assertEquals(Box.count, prevCount + 1); \/\/ no duplicate receiver computation!\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(((Box)((Var)quoted.capturedValues().values().iterator().next()).value()).i, i);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, i + 1);\n+    }\n+\n+    record Box(int i) {\n+\n+        static int count = 0;\n+\n+        Box {\n+           count++; \/\/ keep track of side-effects\n+        }\n+\n+        int add(int i) {\n+            return i + this.i;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuotable.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Smoke test for captured values in quoted lambdas.\n+ * @run testng TestCaptureQuoted\n+ *\/\n+\n+import java.lang.reflect.code.op.CoreOps.Var;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Quoted;\n+import java.lang.reflect.code.interpreter.Interpreter;\n+import java.lang.invoke.MethodHandles;\n+import java.util.stream.IntStream;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestCaptureQuoted {\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntParam(int x) {\n+        Quoted quoted = (int y) -> x + y;\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(((Var)quoted.capturedValues().values().iterator().next()).value(), x);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @Test(dataProvider = \"ints\")\n+    public void testCaptureIntField(int x) {\n+        class Context {\n+            final int x;\n+\n+            Context(int x) {\n+                this.x = x;\n+            }\n+\n+            Quoted quoted() {\n+                return (int y) -> x + y;\n+            }\n+        }\n+        Context context = new Context(x);\n+        Quoted quoted = context.quoted();\n+        assertEquals(quoted.capturedValues().size(), 1);\n+        assertEquals(quoted.capturedValues().values().iterator().next(), context);\n+        int res = (int)Interpreter.invoke(MethodHandles.lookup(), (Op & Op.Invokable) quoted.op(),\n+                quoted.capturedValues(), 1);\n+        assertEquals(res, x + 1);\n+    }\n+\n+    @DataProvider(name = \"ints\")\n+    public Object[][] ints() {\n+        return IntStream.range(0, 50)\n+                .mapToObj(i -> new Object[] { i })\n+                .toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestCaptureQuoted.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestGenericMethodCall.out -XDrawDiagnostics TestGenericMethodCall.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+public class TestGenericMethodCall {\n+    void test(boolean cond) {\n+        apply(Quoted.class, () -> {});\n+        apply(Quoted.class, (int i) -> \"\"); \/\/ ok (int->String)\n+        apply(Quoted.class, (int i) -> { return \"\"; }); \/\/ ok (int->String)\n+        apply(Quoted.class, (int i) -> { }); \/\/ ok (int->V)\n+        apply(Quoted.class, (int i) -> { return; }); \/\/ ok (int->V)\n+        apply(Quoted.class, (int i) -> { if (cond) return; else return; }); \/\/ ok (int->V)\n+        apply(Quoted.class, (int i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ ok (int->String)\n+    }\n+\n+    void testImplicit(boolean cond) {\n+        apply(Quoted.class, (i) -> \"\"); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testImplicitVar(boolean cond) {\n+        apply(Quoted.class, (var i) -> \"\"); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply(Quoted.class, (var i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testBadInferredReturn(boolean cond) {\n+        apply(Quoted.class, (int i) -> { if (cond) return; else return \"\"; }); \/\/ error - only one branch returns\n+        apply(Quoted.class, (int i) -> { if (cond) { return \"2\"; } }); \/\/ error - one return, but body completes normally\n+    }\n+\n+    <Z> void apply(Class<Z> clazz, Z quoted) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+TestGenericMethodCall.java:43:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:44:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:45:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:46:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:47:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:48:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:52:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:53:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:54:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:55:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:56:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:57:29: compiler.err.quoted.lambda.must.be.explicit\n+TestGenericMethodCall.java:61:40: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestGenericMethodCall.java:62:40: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestGenericMethodCall.out","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestMethodCall.out -XDrawDiagnostics TestMethodCall.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+public class TestMethodCall {\n+    void test(boolean cond) {\n+        apply(() -> {});\n+        apply((int i) -> \"\"); \/\/ ok (int->String)\n+        apply((int i) -> { return \"\"; }); \/\/ ok (int->String)\n+        apply((int i) -> { }); \/\/ ok (int->V)\n+        apply((int i) -> { return; }); \/\/ ok (int->V)\n+        apply((int i) -> { if (cond) return; else return; }); \/\/ ok (int->V)\n+        apply((int i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ ok (int->String)\n+    }\n+\n+    void testImplicit(boolean cond) {\n+        apply((i) -> \"\"); \/\/ error - no parameter types\n+        apply((i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply((i) -> { }); \/\/ error - no parameter types\n+        apply((i) -> { return; }); \/\/ error - no parameter types\n+        apply((i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply((i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testImplicitVar(boolean cond) {\n+        apply((var i) -> \"\"); \/\/ error - no parameter types\n+        apply((var i) -> { return \"\"; }); \/\/ error - no parameter types\n+        apply((var i) -> { }); \/\/ error - no parameter types\n+        apply((var i) -> { return; }); \/\/ error - no parameter types\n+        apply((var i) -> { if (cond) return; else return; }); \/\/ error - no parameter types\n+        apply((var i) -> { if (cond) return \"1\"; else return \"2\"; }); \/\/ error - no parameter types\n+    }\n+\n+    void testBadInferredReturn(boolean cond) {\n+        apply((int i) -> { if (cond) return; else return \"\"; }); \/\/ error - only one branch returns\n+        apply((int i) -> { if (cond) { return \"2\"; } }); \/\/ error - one return, but body completes normally\n+    }\n+\n+    void apply(Quoted quoted) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+TestMethodCall.java:43:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:44:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:45:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:46:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:47:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:48:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:52:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:53:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:54:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:55:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:56:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:57:15: compiler.err.quoted.lambda.must.be.explicit\n+TestMethodCall.java:61:26: compiler.err.cant.infer.quoted.lambda.return.type: void,java.lang.String\n+TestMethodCall.java:62:26: compiler.err.cant.infer.quoted.lambda.return.type: java.lang.String,void\n+14 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestMethodCall.out","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @compile\/fail\/ref=TestRecovery.out -XDrawDiagnostics TestRecovery.java\n+ *\/\n+\n+import java.lang.reflect.code.Quoted;\n+\n+public class TestRecovery {\n+    void testRecoveryInAssignment() {\n+        Quoted res = (x) -> { System.out.println(nonExistent); };\n+    }\n+\n+    void testRecoveryInMethodCall() {\n+        apply((x) -> { System.out.println(nonExistent); });\n+    }\n+\n+    void testRecoveryInGenericMethodCall() {\n+        apply(Quoted.class, (x) -> { System.out.println(nonExistent); });\n+    }\n+\n+    void apply(Quoted quoted) { }\n+    <Z> void apply(Class<Z> clazz, Z quoted) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+TestRecovery.java:33:22: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:33:50: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:37:15: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:37:43: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+TestRecovery.java:41:29: compiler.err.quoted.lambda.must.be.explicit\n+TestRecovery.java:41:57: compiler.err.cant.resolve.location: kindname.variable, nonExistent, , , (compiler.misc.location: kindname.class, TestRecovery, null)\n+6 errors\n","filename":"test\/langtools\/tools\/javac\/reflect\/quoted\/TestRecovery.out","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"}]}