{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.code.op.CoreOps.*;\n@@ -36,0 +37,11 @@\n+import java.lang.classfile.CodeBuilder.BlockCodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import static java.lang.classfile.TypeKind.DoubleType;\n+import static java.lang.classfile.TypeKind.FloatType;\n+import static java.lang.classfile.TypeKind.LongType;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n@@ -37,0 +49,4 @@\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n@@ -44,0 +60,6 @@\n+import java.lang.reflect.code.Block.Reference;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.analysis.Liveness;\n+import java.lang.reflect.code.descriptor.FieldDesc;\n+import java.lang.reflect.code.descriptor.MethodDesc;\n+import java.lang.reflect.code.descriptor.TypeDesc;\n@@ -45,0 +67,3 @@\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collections;\n@@ -47,0 +72,2 @@\n+import java.util.HashSet;\n+import java.util.Iterator;\n@@ -49,0 +76,2 @@\n+import java.util.Set;\n+import java.util.function.Consumer;\n@@ -90,2 +119,18 @@\n-    public static byte[] generateClassData(MethodHandles.Lookup l, CoreOps.FuncOp fop) {\n-        String packageName = l.lookupClass().getPackageName();\n+    private static class DebugTransform implements CodeTransform {\n+        private int bci = 0;\n+\n+        @Override\n+        public void accept(CodeBuilder cob, CodeElement coe) {\n+            cob.accept(coe);\n+            switch (coe) {\n+                case LabelTarget lt -> System.out.println(bci + \": \" + lt + \" (\" + lt.label().hashCode() + \")\");\n+                case BranchInstruction bi -> System.out.println(bci + \": \" + bi + \" (\" + bi.target().hashCode() + \")\");\n+                default -> System.out.println(bci + \": \" + coe);\n+            }\n+            if (coe instanceof Instruction ins) bci += ins.sizeInBytes();\n+        }\n+\n+    }\n+\n+    public static byte[] generateClassData(MethodHandles.Lookup lookup, CoreOps.FuncOp fop) {\n+        String packageName = lookup.lookupClass().getPackageName();\n@@ -95,11 +140,10 @@\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(className),\n-                clb -> {\n-                    clb.withMethodBody(\n-                            fop.funcName(),\n-                            fop.funcDescriptor().toNominalDescriptor(),\n-                            ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                            cob -> {\n-                                ConversionContext c = new ConversionContext(cob);\n-                                generateMethodBody(fop, cob, c);\n-                            });\n-                });\n+        Liveness liveness = new Liveness(fop);\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(className), clb ->\n+                clb.withMethodBody(\n+                        fop.funcName(),\n+                        fop.funcDescriptor().toNominalDescriptor(),\n+                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                        cb -> cb.transforming(new DebugTransform(), cob -> {\n+                            ConversionContext c = new ConversionContext(lookup, liveness, cob);\n+                            generateBody(fop.body(), cob, c);\n+                        })));\n@@ -118,0 +162,2 @@\n+        final MethodHandles.Lookup lookup;\n+        final Liveness liveness;\n@@ -121,0 +167,4 @@\n+        final Map<Block, LiveSlotSet> liveSet;\n+        Block current;\n+        final Set<Block> catchingBlocks;\n+        final Map<Block, ExceptionRegionNode> coveredBlocks;\n@@ -122,1 +172,3 @@\n-        public ConversionContext(CodeBuilder cb) {\n+        public ConversionContext(MethodHandles.Lookup lookup, Liveness liveness, CodeBuilder cb) {\n+            this.lookup = lookup;\n+            this.liveness = liveness;\n@@ -126,0 +178,3 @@\n+            this.liveSet = new HashMap<>();\n+            this.catchingBlocks = new HashSet<>();\n+            this.coveredBlocks = new HashMap<>();\n@@ -137,0 +192,224 @@\n+\n+        void setCurrentBlock(Block current) {\n+            this.current = current;\n+            liveSet.computeIfAbsent(current, b -> new LiveSlotSet());\n+        }\n+\n+        LiveSlotSet liveSlotSet(Block b) {\n+            return liveSet.computeIfAbsent(b, _b -> new LiveSlotSet());\n+        }\n+\n+        LiveSlotSet liveSlotSet() {\n+            return liveSet.get(current);\n+        }\n+\n+        int getSlot(Value v) {\n+            return liveSlotSet().getSlot(v);\n+        }\n+\n+\n+        int getOrAssignSlot(Value v, boolean assignIfUnused) {\n+            return liveSlotSet().getOrAssignSlot(v, assignIfUnused);\n+        }\n+\n+        int getOrAssignSlot(Value v) {\n+            return getOrAssignSlot(v, false);\n+        }\n+\n+        int assignSlot(Value v) {\n+            return liveSlotSet().assignSlot(v);\n+        }\n+\n+        void freeSlot(Value v) {\n+            liveSlotSet().freeSlot(v);\n+        }\n+\n+        boolean isLastUse(Value v, Op op) {\n+            return liveness.isLastUse(v, op);\n+        }\n+\n+        void freeSlotsOfOp(Op op) {\n+            for (Value v : op.operands()) {\n+                if (isLastUse(v, op)) {\n+                    freeSlot(v);\n+                }\n+            }\n+\n+            for (Block.Reference s : op.successors()) {\n+                for (Value v : s.arguments()) {\n+                    if (isLastUse(v, op)) {\n+                        freeSlot(v);\n+                    }\n+                }\n+            }\n+        }\n+\n+        void transitionLiveSlotSetTo(Block successor) {\n+            liveSlotSet(successor).transitionLiveSlotSetFrom(liveSlotSet());\n+        }\n+    }\n+\n+    private static void processOperands(CodeBuilder cob,\n+                                        ConversionContext c,\n+                                        Op op,\n+                                        boolean isLastOpResultOnStack) {\n+        for (int i = isLastOpResultOnStack ? 1 : 0; i < op.operands().size(); i++) {\n+            Value operand = op.operands().get(i);\n+            if (operand instanceof Op.Result or &&\n+                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                cob.constantInstruction(fromValue(constantOp.value()));\n+            } else {\n+                int slot = c.getSlot(operand);\n+                cob.loadInstruction(toTypeKind(operand.type()), slot);\n+            }\n+        }\n+    }\n+\n+    private static ConstantDesc fromValue(Object value) {\n+        return switch (value) {\n+            case ConstantDesc cd -> cd;\n+            case TypeDesc td -> td.toNominalDescriptor();\n+            default -> throw new IllegalArgumentException(\"Unsupported constant value: \" + value);\n+        };\n+    }\n+\n+    \/\/ Determines if the operation result used only by the next operation as the first operand\n+    private static boolean isResultOnlyUse(Op.Result opr) {\n+        Set<Op.Result> uses = opr.uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+\n+        \/\/ Pass over constant operations\n+        Op.Result use = uses.iterator().next();\n+        Op nextOp = opr.op();\n+        do {\n+            nextOp = opr.declaringBlock().nextOp(nextOp);\n+        } while (nextOp instanceof CoreOps.ConstantOp);\n+\n+        if (nextOp == null || use != nextOp.result()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : nextOp.successors()) {\n+            if (s.arguments().contains(opr)) {\n+                return false;\n+            }\n+        }\n+\n+        List<Value> operands = nextOp.operands();\n+        return !operands.isEmpty() && opr == operands.get(0);\n+    }\n+\n+    private static boolean isConditionForCondBrOp(CoreOps.BinaryTestOp op) {\n+        \/\/ Result of op has one use as the operand of a CondBrOp op,\n+        \/\/ and both ops are in the same block\n+\n+        Set<Op.Result> uses = op.result().uses();\n+        if (uses.size() != 1) {\n+            return false;\n+        }\n+        Op.Result use = uses.iterator().next();\n+\n+        if (use.declaringBlock() != op.parentBlock()) {\n+            return false;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : use.op().successors()) {\n+            if (s.arguments().contains(op.result())) {\n+                return false;\n+            }\n+        }\n+\n+        return use.op() instanceof CoreOps.ConditionalBranchOp;\n+    }\n+\n+    private static TypeKind toTypeKind(TypeDesc t) {\n+        TypeDesc rbt = t.toBasicType();\n+\n+        if (rbt.equals(TypeDesc.INT)) {\n+            return TypeKind.IntType;\n+        } else if (rbt.equals(TypeDesc.LONG)) {\n+            return TypeKind.LongType;\n+        } else if (rbt.equals(TypeDesc.FLOAT)) {\n+            return TypeKind.FloatType;\n+        } else if (rbt.equals(TypeDesc.DOUBLE)) {\n+            return TypeKind.DoubleType;\n+        } else if (rbt.equals(TypeDesc.J_L_OBJECT)) {\n+            return TypeKind.ReferenceType;\n+        } else {\n+            throw new IllegalArgumentException(\"Bad type: \" + t);\n+        }\n+    }\n+\n+    record ExceptionRegionNode(CoreOps.ExceptionRegionEnter ere, int size, ExceptionRegionNode next) {\n+    }\n+\n+    static final ExceptionRegionNode NIL = new ExceptionRegionNode(null, 0, null);\n+\n+    private static void computeExceptionRegionMembership(Body r, ConversionContext c) {\n+        Set<Block> visited = new HashSet<>();\n+        Deque<Block> stack = new ArrayDeque<>();\n+        stack.push(r.entryBlock());\n+\n+        \/\/ Set of catching blocks\n+        Set<Block> catchingBlocks = c.catchingBlocks;\n+        \/\/ Map of block to stack of covered exception regions\n+        Map<Block, ExceptionRegionNode> coveredBlocks = c.coveredBlocks;\n+        \/\/ Compute exception region membership\n+        while (!stack.isEmpty()) {\n+            Block b = stack.pop();\n+            if (!visited.add(b)) {\n+                continue;\n+            }\n+\n+            Op top = b.terminatingOp();\n+            ExceptionRegionNode bRegions = coveredBlocks.get(b);\n+            if (top instanceof CoreOps.BranchOp bop) {\n+                if (bRegions != null) {\n+                    coveredBlocks.put(bop.branch().targetBlock(), bRegions);\n+                }\n+\n+                stack.push(bop.branch().targetBlock());\n+            } else if (top instanceof CoreOps.ConditionalBranchOp cop) {\n+                if (bRegions != null) {\n+                    coveredBlocks.put(cop.falseBranch().targetBlock(), bRegions);\n+                    coveredBlocks.put(cop.trueBranch().targetBlock(), bRegions);\n+                }\n+\n+                stack.push(cop.falseBranch().targetBlock());\n+                stack.push(cop.trueBranch().targetBlock());\n+            } else if (top instanceof CoreOps.ExceptionRegionEnter er) {\n+                ArrayList<Block.Reference> catchBlocks = new ArrayList<>(er.catchBlocks());\n+                Collections.reverse(catchBlocks);\n+                for (Block.Reference catchBlock : catchBlocks) {\n+                    catchingBlocks.add(catchBlock.targetBlock());\n+                    if (bRegions != null) {\n+                        coveredBlocks.put(catchBlock.targetBlock(), bRegions);\n+                    }\n+\n+                    stack.push(catchBlock.targetBlock());\n+                }\n+\n+                ExceptionRegionNode n;\n+                if (bRegions != null) {\n+                    n = new ExceptionRegionNode(er, bRegions.size + 1, bRegions);\n+                } else {\n+                    n = new ExceptionRegionNode(er, 1, NIL);\n+                }\n+                coveredBlocks.put(er.start().targetBlock(), n);\n+\n+                stack.push(er.start().targetBlock());\n+            } else if (top instanceof CoreOps.ExceptionRegionExit er) {\n+                assert bRegions != null;\n+\n+                if (bRegions.size() > 1) {\n+                    coveredBlocks.put(er.end().targetBlock(), bRegions.next());\n+                }\n+\n+                stack.push(er.end().targetBlock());\n+            }\n+        }\n@@ -139,3 +418,8 @@\n-    private static void generateMethodBody(CoreOps.FuncOp fop, CodeBuilder mv, ConversionContext c) {\n-        Body r = fop.body();\n-        generateFromBody(r, mv, c);\n+    private static void branch(CodeBuilder cob, ConversionContext c, List<Block> blocks, Block source, Block target) {\n+        int bi = blocks.indexOf(source);\n+        int si = blocks.indexOf(target);\n+        \/\/ If successor occurs immediately after this block,\n+        \/\/ then no need for goto instruction\n+        if (bi != si - 1) {\n+            cob.goto_(c.getLabel(target));\n+        }\n@@ -144,1 +428,3 @@\n-    private static void generateFromBody(Body body, CodeBuilder mv, ConversionContext c) {\n+    private static void generateBody(Body body, CodeBuilder cob, ConversionContext c) {\n+        computeExceptionRegionMembership(body, c);\n+\n@@ -157,0 +443,1 @@\n+            c.setCurrentBlock(b);\n@@ -158,1 +445,1 @@\n-            mv.labelBinding(blockLabel);\n+            cob.labelBinding(blockLabel);\n@@ -160,7 +447,14 @@\n-            List<Op> ops = b.ops();\n-            for (int i = 0; i < ops.size() - 1; i++) {\n-                Op op = ops.get(i);\n-                if (op instanceof BytecodeInstructionOps.InstructionOp inst) {\n-                    inst.apply(mv, c);\n-                } else if (op instanceof BytecodeInstructionOps.ControlInstructionOp inst) {\n-                    inst.apply(mv, c);\n+            \/\/ If b is the entry block then all its parameters conservatively require slots\n+            \/\/ Some unused parameters might be declared before others that are used\n+            b.parameters().forEach(p -> c.getOrAssignSlot(p, b.isEntryBlock()));\n+\n+            \/\/ If b is a catch block then the exception argument will be represented on the stack\n+            if (c.catchingBlocks.contains(b)) {\n+                \/\/ Retain block argument for exception table generation\n+                Block.Parameter ex = b.parameters().get(0);\n+\/\/                clb.parameter(ex.type());\n+\n+                \/\/ Store in slot if used, otherwise pop\n+                if (!ex.uses().isEmpty()) {\n+                    int slot = c.getSlot(ex);\n+                    cob.storeInstruction(toTypeKind(ex.type()), slot);\n@@ -168,1 +462,1 @@\n-                    throw new UnsupportedOperationException(\"Unsupported operation: \" + op);\n+                    cob.pop();\n@@ -172,0 +466,257 @@\n+            List<Op> ops = b.ops();\n+            \/\/ True if the last result is retained on the stack for use as first operand of current operation\n+            boolean isLastOpResultOnStack = false;\n+            Op.Result oprOnStack = null;\n+            for (int i = 0; i < ops.size() - 1; i++) {\n+                Op o = ops.get(i);\n+                TypeDesc oprType = o.resultType();\n+                TypeKind rvt = oprType.equals(TypeDesc.VOID) ? null : toTypeKind(oprType);\n+                switch (o) {\n+                    case ConstantOp op -> {\n+                        if (op.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                            \/\/ Loading a class constant may throw an exception so it cannot be deferred\n+                            cob.ldc(fromValue(op.value()));\n+                        } else {\n+                          \/\/ Defer process to use, where constants are inlined\n+                          \/\/ This applies to both operands and successor arguments\n+                          rvt = null;\n+                        }\n+                    }\n+                    case VarOp op -> {\n+                        \/\/     %1 : Var<int> = var %0 @\"i\";\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        isLastOpResultOnStack = false;\n+                        \/\/ Use slot of variable result\n+                        int slot = c.assignSlot(op.result());\n+                        cob.storeInstruction(toTypeKind(op.varType()), slot);\n+                        \/\/ Ignore result\n+                        rvt = null;\n+                    }\n+                    case VarAccessOp.VarLoadOp op -> {\n+                        \/\/ Use slot of variable result\n+                        int slot = c.getSlot(op.operands().get(0));\n+                        CoreOps.VarOp vop = op.varOp();\n+                        cob.loadInstruction(toTypeKind(vop.varType()), slot);\n+                    }\n+                    case VarAccessOp.VarStoreOp op -> {\n+                        if (!isLastOpResultOnStack) {\n+                            Value operand = op.operands().get(1);\n+                            if (operand instanceof Op.Result or &&\n+                                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                                cob.constantInstruction(fromValue(constantOp.value()));\n+                            } else {\n+                                int slot = c.getSlot(operand);\n+                                cob.loadInstruction(toTypeKind(operand.type()), slot);\n+                            }\n+                            isLastOpResultOnStack = false;\n+                        }\n+                        \/\/ Use slot of variable result\n+                        int slot = c.getSlot(op.operands().get(0));\n+                        CoreOps.VarOp vop = op.varOp();\n+                        cob.storeInstruction(toTypeKind(vop.varType()), slot);\n+                    }\n+                    case NegOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::neg(TypeKind)\n+                            case IntType -> cob.ineg();\n+                            case LongType -> cob.lneg();\n+                            case FloatType -> cob.fneg();\n+                            case DoubleType -> cob.dneg();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case NotOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.ifThenElse(CodeBuilder::iconst_0, CodeBuilder::iconst_1);\n+                    }\n+                    case AddOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::add(TypeKind)\n+                            case IntType -> cob.iadd();\n+                            case LongType -> cob.ladd();\n+                            case FloatType -> cob.fadd();\n+                            case DoubleType -> cob.dadd();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case SubOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::sub(TypeKind)\n+                            case IntType -> cob.isub();\n+                            case LongType -> cob.lsub();\n+                            case FloatType -> cob.fsub();\n+                            case DoubleType -> cob.dsub();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case MulOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::mul(TypeKind)\n+                            case IntType -> cob.imul();\n+                            case LongType -> cob.lmul();\n+                            case FloatType -> cob.fmul();\n+                            case DoubleType -> cob.dmul();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case DivOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::div(TypeKind)\n+                            case IntType -> cob.idiv();\n+                            case LongType -> cob.ldiv();\n+                            case FloatType -> cob.fdiv();\n+                            case DoubleType -> cob.ddiv();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case ModOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        switch (rvt) { \/\/this can be moved to CodeBuilder::rem(TypeKind)\n+                            case IntType -> cob.irem();\n+                            case LongType -> cob.lrem();\n+                            case FloatType -> cob.frem();\n+                            case DoubleType -> cob.drem();\n+                            default -> throw new IllegalArgumentException(\"Bad type: \" + op.resultType());\n+                        }\n+                    }\n+                    case ArrayAccessOp.ArrayLoadOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.arrayLoadInstruction(rvt);\n+                    }\n+                    case ArrayAccessOp.ArrayStoreOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        TypeKind evt = toTypeKind(op.operands().get(2).type());\n+                        cob.arrayStoreInstruction(evt);\n+                    }\n+                    case ArrayLengthOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.arraylength();\n+                    }\n+                    case BinaryTestOp op -> {\n+                        if (!isConditionForCondBrOp(op)) {\n+                            processOperands(cob, c, op, isLastOpResultOnStack);\n+                            conditionalBranch(cob, op, CodeBuilder::iconst_1, CodeBuilder::iconst_0);\n+                        } else {\n+                            \/\/ Processing is deferred to the CondBrOp, do not process the op result\n+                            rvt = null;\n+                        }\n+                    }\n+                    case NewOp op -> {\n+                        TypeDesc t = op.constructorDescriptor().returnType();\n+                        switch (t.dimensions()) {\n+                            case 0 -> {\n+                                if (isLastOpResultOnStack) {\n+                                    int slot = c.assignSlot(oprOnStack);\n+                                    cob.storeInstruction(rvt, slot);\n+                                    isLastOpResultOnStack = false;\n+                                    oprOnStack = null;\n+                                }\n+                                cob.new_(t.toNominalDescriptor())\n+                                   .dup();\n+                                processOperands(cob, c, op, false);\n+                                cob.invokespecial(\n+                                        op.resultType().toNominalDescriptor(),\n+                                        ConstantDescs.INIT_NAME,\n+                                        op.constructorDescriptor().toNominalDescriptor().changeReturnType(ConstantDescs.CD_void));\n+                            }\n+                            case 1 -> {\n+                                processOperands(cob, c, op, isLastOpResultOnStack);\n+                                ClassDesc ctd = t.componentType().toNominalDescriptor();\n+                                if (ctd.isPrimitive()) {\n+                                    cob.newarray(TypeKind.from(ctd));\n+                                } else {\n+                                    cob.anewarray(ctd);\n+                                }\n+                            }\n+                            default -> {\n+                                processOperands(cob, c, op, isLastOpResultOnStack);\n+                                cob.multianewarray(t.toNominalDescriptor(), op.operands().size());\n+                            }\n+                        }\n+                    }\n+                    case InvokeOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        \/\/ @@@ Enhance method descriptor to include how the method is to be invoked\n+                        \/\/ Example result of DirectMethodHandleDesc.toString()\n+                        \/\/   INTERFACE_VIRTUAL\/IntBinaryOperator::applyAsInt(IntBinaryOperator,int,int)int\n+                        \/\/ This will avoid the need to reflectively operate on the descriptor\n+                        \/\/ which may be insufficient in certain cases.\n+                        DirectMethodHandleDesc.Kind descKind;\n+                        try {\n+                            descKind = resolveToMethodHandleDesc(c.lookup, op.invokeDescriptor()).kind();\n+                        } catch (ReflectiveOperationException e) {\n+                            \/\/ @@@ Approximate fallback\n+                            if (op.hasReceiver()) {\n+                                descKind = DirectMethodHandleDesc.Kind.VIRTUAL;\n+                            } else {\n+                                descKind = DirectMethodHandleDesc.Kind.STATIC;\n+                            }\n+                        }\n+                        MethodDesc md = op.invokeDescriptor();\n+                        cob.invokeInstruction(\n+                                switch (descKind) {\n+                                    case STATIC, INTERFACE_STATIC   -> Opcode.INVOKESTATIC;\n+                                    case VIRTUAL                    -> Opcode.INVOKEVIRTUAL;\n+                                    case INTERFACE_VIRTUAL          -> Opcode.INVOKEINTERFACE;\n+                                    case SPECIAL, INTERFACE_SPECIAL -> Opcode.INVOKESPECIAL;\n+                                    default ->\n+                                        throw new IllegalStateException(\"Bad method descriptor resolution: \" + op.descriptor() + \" > \" + op.invokeDescriptor());\n+                                },\n+                                md.refType().toNominalDescriptor(),\n+                                md.name(),\n+                                md.type().toNominalDescriptor(),\n+                                switch (descKind) {\n+                                    case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> true;\n+                                    default -> false;\n+                                });\n+\n+                        if (op.resultType().equals(TypeDesc.VOID) && !op.operands().isEmpty()) {\n+                            isLastOpResultOnStack = false;\n+                        }\n+                    }\n+                    case FieldAccessOp.FieldLoadOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        FieldDesc fd = op.fieldDescriptor();\n+                        if (op.operands().isEmpty()) {\n+                            cob.getstatic(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                        } else {\n+                            cob.getfield(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                        }\n+                    }\n+                    case FieldAccessOp.FieldStoreOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        isLastOpResultOnStack = false;\n+                        FieldDesc fd = op.fieldDescriptor();\n+                        if (op.operands().size() == 1) {\n+                            cob.putstatic(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                        } else {\n+                            cob.putfield(fd.refType().toNominalDescriptor(), fd.name(), fd.type().toNominalDescriptor());\n+                        }\n+                    }\n+                    case InstanceOfOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.instanceof_(op.type().toNominalDescriptor());\n+                    }\n+                    case CastOp op -> {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.checkcast(op.type().toNominalDescriptor());\n+                    }\n+                    default ->\n+                        throw new UnsupportedOperationException(\"Unsupported operation: \" + ops.get(i));\n+                }\n+                \/\/ Free up slots for values that are no longer live\n+                c.freeSlotsOfOp(o);\n+                \/\/ Assign slot to operation result\n+                if (rvt != null) {\n+                    if (!isResultOnlyUse(o.result())) {\n+                        isLastOpResultOnStack = false;\n+                        oprOnStack = null;\n+                        int slot = c.assignSlot(o.result());\n+                        cob.storeInstruction(rvt, slot);\n+                    } else {\n+                        isLastOpResultOnStack = true;\n+                        oprOnStack = o.result();\n+                    }\n+                }\n+            }\n@@ -173,13 +724,316 @@\n-            if (top instanceof BytecodeInstructionOps.GotoInstructionOp inst) {\n-                Block s = inst.successors().get(0).targetBlock();\n-                int bi = blocks.indexOf(b);\n-                int si = blocks.indexOf(s);\n-                \/\/ If successor occurs immediately after this block,\n-                \/\/ then no need for goto instruction\n-                if (bi != si - 1) {\n-                    inst.apply(mv, c);\n-                }\n-            } else if (top instanceof BytecodeInstructionOps.TerminatingInstructionOp inst) {\n-                inst.apply(mv, c);\n-            } else if (top instanceof BytecodeInstructionOps.ControlInstructionOp inst) {\n-                inst.apply(mv, c);\n+            c.freeSlotsOfOp(top);\n+            switch (top) {\n+                case CoreOps.ReturnOp op -> {\n+                    Value a = op.returnValue();\n+                    if (a == null) {\n+                        cob.return_();\n+                    } else {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.returnInstruction(toTypeKind(a.type()));\n+                    }\n+                }\n+                case ThrowOp op -> {\n+                    processOperands(cob, c, op, isLastOpResultOnStack);\n+                    cob.athrow();\n+                }\n+                case BranchOp op -> {\n+                    assignBlockArguments(op, op.branch(), cob, c);\n+                    branch(cob, c, blocks, b, op.branch().targetBlock());\n+                }\n+                case ConditionalBranchOp op -> {\n+                    if (getConditionForCondBrOp(op) instanceof CoreOps.BinaryTestOp btop) {\n+                        \/\/ Processing of the BinaryTestOp was deferred, so it can be merged with CondBrOp\n+                        processOperands(cob, c, btop, isLastOpResultOnStack);\n+                        conditionalBranch(cob, btop,\n+                                trueBuilder -> {\n+                                    assignBlockArguments(btop, op.trueBranch(), trueBuilder, c);\n+                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                },\n+                                falseBuilder -> {\n+                                    assignBlockArguments(btop, op.falseBranch(), falseBuilder, c);\n+                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                });\n+                    } else {\n+                        processOperands(cob, c, op, isLastOpResultOnStack);\n+                        cob.ifThenElse(\n+                                trueBuilder -> {\n+                                    assignBlockArguments(op, op.trueBranch(), trueBuilder, c);\n+                                    branch(trueBuilder, c, blocks, b, op.trueBranch().targetBlock());\n+                                },\n+                                falseBuilder -> {\n+                                    assignBlockArguments(op, op.falseBranch(), falseBuilder, c);\n+                                    branch(falseBuilder, c, blocks, b, op.falseBranch().targetBlock());\n+                                });\n+                    }\n+                }\n+                case ExceptionRegionEnter op -> {\n+                    assignBlockArguments(op, op.start(), cob, c);\n+                    for (Block.Reference catchBlock : op.catchBlocks()) {\n+                        c.transitionLiveSlotSetTo(catchBlock.targetBlock());\n+                    }\n+                }\n+                case ExceptionRegionExit op -> {\n+                    assignBlockArguments(op, op.end(), cob, c);\n+                    ExceptionRegionEnter enterOp = op.regionStart();\n+                    Label start = c.getLabel(enterOp.start().targetBlock());\n+                    Label end = cob.newBoundLabel();\n+                    for (Reference cbr : enterOp.catchBlocks()) {\n+                        Block cb = cbr.targetBlock();\n+                        if (!cb.parameters().isEmpty()) {\n+                            ClassDesc type = cb.parameters().get(0).type().toNominalDescriptor();\n+                            cob.exceptionCatch(start, end, c.getLabel(cb), type);\n+                        } else {\n+                            cob.exceptionCatchAll(start, end, c.getLabel(cb));\n+                        }\n+                    }\n+                    branch(cob, c, blocks, b, op.end().targetBlock());\n+                }\n+                default ->\n+                    throw new UnsupportedOperationException(\"Terminating operation not supported: \" + top);\n+            }\n+        }\n+    }\n+\n+    static final class LiveSlotSet {\n+        final Map<Value, Integer> liveSet;\n+        final BitSet freeSlots;\n+\n+        public LiveSlotSet() {\n+            this.liveSet = new HashMap<>();\n+            this.freeSlots = new BitSet();\n+        }\n+\n+        void transitionLiveSlotSetFrom(LiveSlotSet that) {\n+            freeSlots.or(that.freeSlots);\n+\n+            \/\/ Filter dead values, those whose slots have been freed\n+            Iterator<Map.Entry<Value, Integer>> slots = that.liveSet.entrySet().iterator();\n+            while (slots.hasNext()) {\n+                var slot = slots.next();\n+                if (!freeSlots.get(slot.getValue())) {\n+                    liveSet.put(slot.getKey(), slot.getValue());\n+                }\n+            }\n+        }\n+\n+        int getSlot(Value v) {\n+            Integer slot = liveSet.get(v);\n+            if (slot == null) {\n+                throw new IllegalArgumentException(\"Value is not assigned a slot\");\n+            }\n+\n+            return slot;\n+        }\n+\n+        int assignSlot(Value v) {\n+            if (liveSet.containsKey(v)) {\n+                throw new IllegalArgumentException(\"Value is assigned a slot\");\n+            }\n+\n+            \/\/ If no uses then no slot is assigned\n+            Set<Op.Result> uses = v.uses();\n+            if (uses.isEmpty()) {\n+                \/\/ @@@\n+                return -1;\n+            }\n+\n+            \/\/ Find a free slot\n+            int slot = findSlot(slotsPerValue(v));\n+\n+            liveSet.put(v, slot);\n+            return slot;\n+        }\n+\n+        int getOrAssignSlot(Value v) {\n+            return getOrAssignSlot(v, false);\n+        }\n+\n+        int getOrAssignSlot(Value v, boolean assignIfUnused) {\n+            \/\/ If value is already active return slot\n+            Integer slotBox = liveSet.get(v);\n+            if (slotBox != null) {\n+                \/\/ Remove any free slot if present for reassignment\n+                freeSlots.clear(slotBox);\n+                if (slotsPerValue(v) == 2) {\n+                    freeSlots.clear(slotBox + 1);\n+                }\n+                return slotBox;\n+            }\n+\n+            \/\/ If no users then no slot is assigned\n+            Set<Op.Result> users = v.uses();\n+            if (!assignIfUnused && users.isEmpty()) {\n+                \/\/ @@@\n+                return -1;\n+            }\n+\n+            \/\/ Find a free slot\n+            int slot = findSlot(slotsPerValue(v));\n+\n+            liveSet.put(v, slot);\n+            return slot;\n+        }\n+\n+        private int findSlot(int nSlots) {\n+            if (freeSlots.isEmpty()) {\n+                return createNewSlot();\n+            } else if (nSlots == 1) {\n+                int slot = freeSlots.nextSetBit(0);\n+                freeSlots.clear(slot);\n+                return slot;\n+            } else {\n+                assert nSlots == 2;\n+                \/\/ Find first 2 contiguous slots\n+                int slot = 0;\n+                slot = freeSlots.nextSetBit(slot);\n+                while (slot != -1) {\n+                    int next = freeSlots.nextSetBit(slot + 1);\n+                    if (next - slot == 1) {\n+                        freeSlots.clear(slot);\n+                        freeSlots.clear(next);\n+                        return slot;\n+                    }\n+\n+                    slot = next;\n+                }\n+                return createNewSlot();\n+            }\n+        }\n+\n+        private int createNewSlot() {\n+            int slot = 0;\n+            if (!liveSet.isEmpty()) {\n+                \/\/ @@@ this is inefficient, track mox slot value\n+                Map.Entry<Value, Integer> e = liveSet.entrySet().stream().reduce((e1, e2) -> {\n+                    return e1.getValue() >= e2.getValue()\n+                            ? e1 : e2;\n+                }).get();\n+                slot = e.getValue() + slotsPerValue(e.getKey());\n+            }\n+            return slot;\n+        }\n+\n+        void freeSlot(Value v) {\n+            \/\/ Add the value's slot to the free list, if present\n+            \/\/ The value and slot are still preserved in the live set,\n+            \/\/ so slots can still be queried, but no slots should be assigned\n+            \/\/ to new values until it is safe to do so\n+            Integer slot = liveSet.get(v);\n+            if (slot != null) {\n+                freeSlots.set(slot);\n+                if (slotsPerValue(v) == 2) {\n+                    freeSlots.set(slot + 1);\n+                }\n+            }\n+        }\n+\n+        static int slotsPerValue(Value x) {\n+            return x.type().equals(TypeDesc.DOUBLE) || x.type().equals(TypeDesc.LONG)\n+                    ? 2\n+                    : 1;\n+        }\n+    }\n+\n+    private static Op getConditionForCondBrOp(CoreOps.ConditionalBranchOp op) {\n+        Value p = op.predicate();\n+        if (p.uses().size() != 1) {\n+            return null;\n+        }\n+\n+        if (p.declaringBlock() != op.parentBlock()) {\n+            return null;\n+        }\n+\n+        \/\/ Check if used in successor\n+        for (Block.Reference s : op.successors()) {\n+            if (s.arguments().contains(p)) {\n+                return null;\n+            }\n+        }\n+\n+        if (p instanceof Op.Result or) {\n+            return or.op();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void conditionalBranch(CodeBuilder cob, BinaryTestOp op,\n+                                          Consumer<BlockCodeBuilder> trueBlock, Consumer<BlockCodeBuilder> falseBlock) {\n+        TypeKind vt = toTypeKind(op.operands().get(0).type());\n+        if (vt == TypeKind.IntType) {\n+            cob.ifThenElse(switch (op) {\n+                case EqOp _ -> Opcode.IF_ICMPEQ;\n+                case NeqOp _ -> Opcode.IF_ICMPNE;\n+                case GtOp _ -> Opcode.IF_ICMPGT;\n+                case GeOp _ -> Opcode.IF_ICMPGE;\n+                case LtOp _ -> Opcode.IF_ICMPLT;\n+                case LeOp _ -> Opcode.IF_ICMPLE;\n+                default ->\n+                    throw new UnsupportedOperationException(op.opName());\n+            }, trueBlock, falseBlock);\n+        } else {\n+            switch (vt) {\n+                case FloatType -> cob.fcmpg(); \/\/ FCMPL?\n+                case LongType -> cob.lcmp();\n+                case DoubleType -> cob.dcmpg(); \/\/CMPL?\n+                default ->\n+                    throw new UnsupportedOperationException(op.opName() + \" on \" + vt);\n+            }\n+            cob.ifThenElse(switch (op) {\n+                case EqOp _ -> Opcode.IFEQ;\n+                case NeqOp _ -> Opcode.IFNE;\n+                case GtOp _ -> Opcode.IFGT;\n+                case GeOp _ -> Opcode.IFGE;\n+                case LtOp _ -> Opcode.IFLT;\n+                case LeOp _ -> Opcode.IFLE;\n+                default ->\n+                    throw new UnsupportedOperationException(op.opName());\n+            }, trueBlock, falseBlock);\n+        }\n+    }\n+\n+    private static void assignBlockArguments(Op op, Block.Reference s, CodeBuilder cob, ConversionContext c) {\n+        List<Value> sargs = s.arguments();\n+        List<Block.Parameter> bargs = s.targetBlock().parameters();\n+\n+        \/\/ Transition over live-out to successor block\n+        \/\/ All predecessors of successor will have the same live-out set so it does not\n+        \/\/ matter which predecessor performs this action\n+        c.transitionLiveSlotSetTo(s.targetBlock());\n+\n+        \/\/ First push successor arguments on the stack, then pop and assign\n+        \/\/ so as not to overwrite slots that are reused slots at different argument positions\n+\n+        \/\/ Push successor values on the stack\n+        for (int i = 0; i < bargs.size(); i++) {\n+            Block.Parameter barg = bargs.get(i);\n+            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n+\n+            Value value = sargs.get(i);\n+            if (value instanceof Op.Result or &&\n+                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                cob.constantInstruction(fromValue(constantOp.value()));\n+            } else {\n+                int sslot = c.getSlot(value);\n+\n+                \/\/ Assignment only required if slots differ\n+                if (sslot != bslot) {\n+                    TypeKind vt = toTypeKind(barg.type());\n+                    cob.loadInstruction(vt, sslot);\n+                }\n+            }\n+        }\n+\n+        \/\/ Pop successor arguments on the stack assigning to block argument slots if necessary\n+        for (int i = bargs.size() - 1; i >= 0; i--) {\n+            Block.Parameter barg = bargs.get(i);\n+            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n+\n+            Value value = sargs.get(i);\n+            if (value instanceof Op.Result or &&\n+                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n+                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n+                TypeKind vt = toTypeKind(barg.type());\n+                cob.storeInstruction(vt, bslot);\n@@ -187,1 +1041,7 @@\n-                throw new UnsupportedOperationException(\"Unsupported operation: \" + top.opName());\n+                int sslot = c.getSlot(value);\n+\n+                \/\/ Assignment only required if slots differ\n+                if (sslot != bslot) {\n+                    TypeKind vt = toTypeKind(barg.type());\n+                    cob.storeInstruction(vt, bslot);\n+                }\n@@ -191,0 +1051,15 @@\n+\n+    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l, MethodDesc d) throws ReflectiveOperationException {\n+        MethodHandle mh = d.resolve(l);\n+\n+        if (mh.describeConstable().isEmpty()) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        MethodHandleDesc mhd = mh.describeConstable().get();\n+        if (!(mhd instanceof DirectMethodHandleDesc dmhd)) {\n+            throw new NoSuchMethodException();\n+        }\n+\n+        return dmhd;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":916,"deletions":41,"binary":false,"changes":957,"status":"modified"},{"patch":"@@ -1,1019 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.reflect.code.bytecode;\n-\n-import java.lang.classfile.TypeKind;\n-\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.reflect.code.Block;\n-import java.lang.reflect.code.Body;\n-import java.lang.reflect.code.op.CoreOps;\n-import java.lang.reflect.code.analysis.Liveness;\n-import java.lang.reflect.code.bytecode.BytecodeLower.ConditionalBranchConsumer;\n-import java.lang.reflect.code.bytecode.BytecodeLower.ExceptionRegionNode;\n-import java.lang.reflect.code.bytecode.BytecodeLower.LiveSlotSet;\n-import java.lang.reflect.code.bytecode.BytecodeLower.LoweringContext;\n-import java.lang.reflect.code.Op;\n-import java.lang.reflect.code.Value;\n-import java.lang.reflect.code.descriptor.MethodDesc;\n-import java.lang.reflect.code.descriptor.TypeDesc;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.BitSet;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-public class BytecodeLower {\n-    private BytecodeLower() {\n-    }\n-\n-    public static CoreOps.FuncOp lowerToBytecodeDialect(CoreOps.FuncOp f) {\n-        return lowerToBytecodeDialect(MethodHandles.publicLookup(), f);\n-    }\n-\n-    public static CoreOps.FuncOp lowerToBytecodeDialect(MethodHandles.Lookup l, CoreOps.FuncOp f) {\n-        return lowerToBytecodeDialect(l, f, false);\n-    }\n-\n-    public static CoreOps.FuncOp lowerToBytecodeDialect(MethodHandles.Lookup lookup, CoreOps.FuncOp f, boolean neverFreeSlots) {\n-        CoreOps.FuncOp lf = CoreOps.func(f.funcName(), f.funcDescriptor()).body(block -> {\n-            Liveness l = new Liveness(f);\n-            LoweringContext c = new LoweringContext(lookup, l, neverFreeSlots);\n-            lowerBodyToBytecodeDialect(f.body(), block, c);\n-        });\n-        return lf;\n-    }\n-\n-    static final class LiveSlotSet {\n-        final boolean neverFreeSlots;\n-        final Map<Value, Integer> liveSet;\n-        final BitSet freeSlots;\n-\n-        public LiveSlotSet(boolean neverFreeSlots) {\n-            this.neverFreeSlots = neverFreeSlots;\n-            this.liveSet = new HashMap<>();\n-            this.freeSlots = new BitSet();\n-        }\n-\n-        void transitionLiveSlotSetFrom(LiveSlotSet that) {\n-            freeSlots.or(that.freeSlots);\n-\n-            \/\/ Filter dead values, those whose slots have been freed\n-            Iterator<Map.Entry<Value, Integer>> slots = that.liveSet.entrySet().iterator();\n-            while (slots.hasNext()) {\n-                var slot = slots.next();\n-                if (!freeSlots.get(slot.getValue())) {\n-                    liveSet.put(slot.getKey(), slot.getValue());\n-                }\n-            }\n-        }\n-\n-        int getSlot(Value v) {\n-            Integer slot = liveSet.get(v);\n-            if (slot == null) {\n-                throw new IllegalArgumentException(\"Value is not assigned a slot\");\n-            }\n-\n-            return slot;\n-        }\n-\n-        int assignSlot(Value v) {\n-            if (liveSet.containsKey(v)) {\n-                throw new IllegalArgumentException(\"Value is assigned a slot\");\n-            }\n-\n-            \/\/ If no uses then no slot is assigned\n-            Set<Op.Result> uses = v.uses();\n-            if (uses.isEmpty()) {\n-                \/\/ @@@\n-                return -1;\n-            }\n-\n-            \/\/ Find a free slot\n-            int slot = findSlot(slotsPerValue(v));\n-\n-            liveSet.put(v, slot);\n-            return slot;\n-        }\n-\n-        int getOrAssignSlot(Value v) {\n-            return getOrAssignSlot(v, false);\n-        }\n-\n-        int getOrAssignSlot(Value v, boolean assignIfUnused) {\n-            \/\/ If value is already active return slot\n-            Integer slotBox = liveSet.get(v);\n-            if (slotBox != null) {\n-                \/\/ Remove any free slot if present for reassignment\n-                freeSlots.clear(slotBox);\n-                if (slotsPerValue(v) == 2) {\n-                    freeSlots.clear(slotBox + 1);\n-                }\n-                return slotBox;\n-            }\n-\n-            \/\/ If no users then no slot is assigned\n-            Set<Op.Result> users = v.uses();\n-            if (!assignIfUnused && users.isEmpty()) {\n-                \/\/ @@@\n-                return -1;\n-            }\n-\n-            \/\/ Find a free slot\n-            int slot = findSlot(slotsPerValue(v));\n-\n-            liveSet.put(v, slot);\n-            return slot;\n-        }\n-\n-        private int findSlot(int nSlots) {\n-            if (freeSlots.isEmpty()) {\n-                return createNewSlot();\n-            } else if (nSlots == 1) {\n-                int slot = freeSlots.nextSetBit(0);\n-                freeSlots.clear(slot);\n-                return slot;\n-            } else {\n-                assert nSlots == 2;\n-                \/\/ Find first 2 contiguous slots\n-                int slot = 0;\n-                slot = freeSlots.nextSetBit(slot);\n-                while (slot != -1) {\n-                    int next = freeSlots.nextSetBit(slot + 1);\n-                    if (next - slot == 1) {\n-                        freeSlots.clear(slot);\n-                        freeSlots.clear(next);\n-                        return slot;\n-                    }\n-\n-                    slot = next;\n-                }\n-                return createNewSlot();\n-            }\n-        }\n-\n-        private int createNewSlot() {\n-            int slot = 0;\n-            if (!liveSet.isEmpty()) {\n-                \/\/ @@@ this is inefficient, track mox slot value\n-                Map.Entry<Value, Integer> e = liveSet.entrySet().stream().reduce((e1, e2) -> {\n-                    return e1.getValue() >= e2.getValue()\n-                            ? e1 : e2;\n-                }).get();\n-                slot = e.getValue() + slotsPerValue(e.getKey());\n-            }\n-            return slot;\n-        }\n-\n-        void freeSlot(Value v) {\n-            if (neverFreeSlots) {\n-                return;\n-            }\n-\n-            \/\/ Add the value's slot to the free list, if present\n-            \/\/ The value and slot are still preserved in the live set,\n-            \/\/ so slots can still be queried, but no slots should be assigned\n-            \/\/ to new values until it is safe to do so\n-            Integer slot = liveSet.get(v);\n-            if (slot != null) {\n-                freeSlots.set(slot);\n-                if (slotsPerValue(v) == 2) {\n-                    freeSlots.set(slot + 1);\n-                }\n-            }\n-        }\n-\n-        static int slotsPerValue(Value x) {\n-            return x.type().equals(TypeDesc.DOUBLE) || x.type().equals(TypeDesc.LONG)\n-                    ? 2\n-                    : 1;\n-        }\n-    }\n-\n-    static final class LoweringContext {\n-        final MethodHandles.Lookup lookup;\n-        final boolean neverFreeSlots;\n-        final Liveness liveness;\n-        final Map<Block, LiveSlotSet> liveSet;\n-        final Map<Block, Block.Builder> blockMap;\n-        final Set<Block> catchingBlocks;\n-        final Map<Block, ExceptionRegionNode> coveredBlocks;\n-\n-        Block current;\n-\n-        LoweringContext(MethodHandles.Lookup lookup, Liveness liveness, boolean neverFreeSlots) {\n-            this.lookup = lookup;\n-            this.neverFreeSlots = neverFreeSlots;\n-            this.liveness = liveness;\n-            this.liveSet = new HashMap<>();\n-            this.blockMap = new HashMap<>();\n-            this.catchingBlocks = new HashSet<>();\n-            this.coveredBlocks = new HashMap<>();\n-        }\n-\n-        void setCurrentBlock(Block current) {\n-            this.current = current;\n-            liveSet.computeIfAbsent(current, b -> new LiveSlotSet(neverFreeSlots));\n-        }\n-\n-        LiveSlotSet liveSlotSet(Block b) {\n-            return liveSet.computeIfAbsent(b, _b -> new LiveSlotSet(neverFreeSlots));\n-        }\n-\n-        LiveSlotSet liveSlotSet() {\n-            return liveSet.get(current);\n-        }\n-\n-        int getSlot(Value v) {\n-            return liveSlotSet().getSlot(v);\n-        }\n-\n-        int assignSlot(Value v) {\n-            return liveSlotSet().assignSlot(v);\n-        }\n-\n-        int getOrAssignSlot(Value v, boolean assignIfUnused) {\n-            return liveSlotSet().getOrAssignSlot(v, assignIfUnused);\n-        }\n-\n-        int getOrAssignSlot(Value v) {\n-            return getOrAssignSlot(v, false);\n-        }\n-\n-        void freeSlot(Value v) {\n-            liveSlotSet().freeSlot(v);\n-        }\n-\n-        void freeSlotsOfOp(Op op) {\n-            for (Value v : op.operands()) {\n-                if (isLastUse(v, op)) {\n-                    freeSlot(v);\n-                }\n-            }\n-\n-            for (Block.Reference s : op.successors()) {\n-                for (Value v : s.arguments()) {\n-                    if (isLastUse(v, op)) {\n-                        freeSlot(v);\n-                    }\n-                }\n-            }\n-        }\n-\n-        void transitionLiveSlotSetTo(Block successor) {\n-            liveSlotSet(successor).transitionLiveSlotSetFrom(liveSlotSet());\n-        }\n-\n-        boolean isLastUse(Value v, Op op) {\n-            return liveness.isLastUse(v, op);\n-        }\n-\n-        public void mapBlock(Block b, Block.Builder lb) {\n-            blockMap.put(b, lb);\n-        }\n-\n-        public Block.Builder getLoweredBlock(Block b) {\n-            return blockMap.get(b);\n-        }\n-    }\n-\n-    private static TypeKind toTypeKind(TypeDesc t) {\n-        TypeDesc rbt = t.toBasicType();\n-\n-        if (rbt.equals(TypeDesc.INT)) {\n-            return TypeKind.IntType;\n-        } else if (rbt.equals(TypeDesc.LONG)) {\n-            return TypeKind.LongType;\n-        } else if (rbt.equals(TypeDesc.FLOAT)) {\n-            return TypeKind.FloatType;\n-        } else if (rbt.equals(TypeDesc.DOUBLE)) {\n-            return TypeKind.DoubleType;\n-        } else if (rbt.equals(TypeDesc.J_L_OBJECT)) {\n-            return TypeKind.ReferenceType;\n-        } else {\n-            throw new IllegalArgumentException(\"Bad type: \" + t);\n-        }\n-    }\n-\n-    private static BytecodeInstructionOps.Comparison toComparisonType(CoreOps.BinaryTestOp op) {\n-        if (op instanceof CoreOps.EqOp) {\n-            return BytecodeInstructionOps.Comparison.EQ;\n-        } else if (op instanceof CoreOps.GtOp) {\n-            return BytecodeInstructionOps.Comparison.GT;\n-        } else if (op instanceof CoreOps.LtOp) {\n-            return BytecodeInstructionOps.Comparison.LT;\n-        } else {\n-            throw new UnsupportedOperationException(op.opName());\n-        }\n-    }\n-\n-    record ExceptionRegionNode(CoreOps.ExceptionRegionEnter ere, int size, ExceptionRegionNode next) {\n-    }\n-\n-    static final ExceptionRegionNode NIL = new ExceptionRegionNode(null, 0, null);\n-\n-    private static void computeExceptionRegionMembership(Body r, LoweringContext c) {\n-        Set<Block> visited = new HashSet<>();\n-        Deque<Block> stack = new ArrayDeque<>();\n-        stack.push(r.entryBlock());\n-\n-        \/\/ Set of catching blocks\n-        Set<Block> catchingBlocks = c.catchingBlocks;\n-        \/\/ Map of block to stack of covered exception regions\n-        Map<Block, ExceptionRegionNode> coveredBlocks = c.coveredBlocks;\n-        \/\/ Compute exception region membership\n-        while (!stack.isEmpty()) {\n-            Block b = stack.pop();\n-            if (!visited.add(b)) {\n-                continue;\n-            }\n-\n-            Op top = b.terminatingOp();\n-            ExceptionRegionNode bRegions = coveredBlocks.get(b);\n-            if (top instanceof CoreOps.BranchOp bop) {\n-                if (bRegions != null) {\n-                    coveredBlocks.put(bop.branch().targetBlock(), bRegions);\n-                }\n-\n-                stack.push(bop.branch().targetBlock());\n-            } else if (top instanceof CoreOps.ConditionalBranchOp cop) {\n-                if (bRegions != null) {\n-                    coveredBlocks.put(cop.falseBranch().targetBlock(), bRegions);\n-                    coveredBlocks.put(cop.trueBranch().targetBlock(), bRegions);\n-                }\n-\n-                stack.push(cop.falseBranch().targetBlock());\n-                stack.push(cop.trueBranch().targetBlock());\n-            } else if (top instanceof CoreOps.ExceptionRegionEnter er) {\n-                ArrayList<Block.Reference> catchBlocks = new ArrayList<>(er.catchBlocks());\n-                Collections.reverse(catchBlocks);\n-                for (Block.Reference catchBlock : catchBlocks) {\n-                    catchingBlocks.add(catchBlock.targetBlock());\n-                    if (bRegions != null) {\n-                        coveredBlocks.put(catchBlock.targetBlock(), bRegions);\n-                    }\n-\n-                    stack.push(catchBlock.targetBlock());\n-                }\n-\n-                ExceptionRegionNode n;\n-                if (bRegions != null) {\n-                    n = new ExceptionRegionNode(er, bRegions.size + 1, bRegions);\n-                } else {\n-                    n = new ExceptionRegionNode(er, 1, NIL);\n-                }\n-                coveredBlocks.put(er.start().targetBlock(), n);\n-\n-                stack.push(er.start().targetBlock());\n-            } else if (top instanceof CoreOps.ExceptionRegionExit er) {\n-                assert bRegions != null;\n-\n-                if (bRegions.size() > 1) {\n-                    coveredBlocks.put(er.end().targetBlock(), bRegions.next());\n-                }\n-\n-                stack.push(er.end().targetBlock());\n-            }\n-        }\n-    }\n-\n-    private static void lowerBodyToBytecodeDialect(Body r, Block.Builder entryBlock, LoweringContext c) {\n-        computeExceptionRegionMembership(r, c);\n-\n-        \/\/ Copy blocks, preserving topological order\n-        \/\/ Lowered blocks have no arguments\n-        c.mapBlock(r.entryBlock(), entryBlock);\n-        List<Block> blocks = r.blocks();\n-        for (Block b : blocks.subList(1, blocks.size())) {\n-            Block.Builder lb;\n-            lb = entryBlock.block();\n-            c.mapBlock(b, lb);\n-        }\n-\n-        \/\/ Process blocks in topological order\n-        for (int bi = 0; bi < blocks.size(); bi++) {\n-            \/\/ Previous block in topological order\n-            Block pb = bi > 0 ? blocks.get(bi - 1) : null;\n-\n-            Block b = blocks.get(bi);\n-            c.setCurrentBlock(b);\n-            Block.Builder lb = c.getLoweredBlock(b);\n-            Block.Builder clb = lb;\n-\n-            \/\/ @@@ Generate linear exception ranges when generating bytecode?\n-\n-            \/\/ If disjoint adjacent blocks, then may need to insert linear exception region enter and exit operations\n-            if (pb != null && !b.predecessors().contains(pb)) {\n-                ExceptionRegionNode pbRegions = c.coveredBlocks.getOrDefault(pb, NIL);\n-                ExceptionRegionNode bRegions = c.coveredBlocks.getOrDefault(b, NIL);\n-                if (pbRegions.size() < bRegions.size()) {\n-                    \/\/ 1. pb < b\n-                    \/\/    A. enter regions in b up to that covered by pb\n-                    \/\/ @@@ is pbRegions always empty ?\n-\n-                    \/\/ Enter regions in reverse order\n-                    Deque<CoreOps.ExceptionRegionEnter> regions = new ArrayDeque<>();\n-                    while (pbRegions != bRegions && bRegions != NIL) {\n-                        regions.push(bRegions.ere);\n-                        bRegions = bRegions.next();\n-                    }\n-\n-                    for (CoreOps.ExceptionRegionEnter region : regions) {\n-                        Block.Builder exRegionEnter = lb.block();\n-                        lb.op(BytecodeInstructionOps.exceptionTableStart(\n-                                exRegionEnter.successor(),\n-                                region.catchBlocks().stream().map(b1 -> c.getLoweredBlock(b1.targetBlock()).successor()).toList()));\n-                        lb = exRegionEnter;\n-                    }\n-                } else if (pbRegions.size() > bRegions.size()) {\n-                    \/\/ 2. pb > b\n-                    \/\/    2.1 pb.exit\n-                    \/\/      2.1.1 pb.exit.target == b\n-                    \/\/        A. Nothing\n-                    \/\/      2.1.2 Otherwise,\n-                    \/\/        A. ??? Can this occur ???\n-                    \/\/    2.2 Otherwise,\n-                    \/\/      A. exit regions in pb up to that covered by b\n-                    if (!(pb.terminatingOp() instanceof CoreOps.ExceptionRegionExit ere)) {\n-                        lb.op(BytecodeInstructionOps.exceptionTableEnd());\n-                    } else {\n-                        ExceptionRegionNode tRegions = c.coveredBlocks.getOrDefault(ere.end().targetBlock(), NIL);\n-                        if (tRegions == bRegions) {\n-                        } else {\n-                            \/\/ @@@ Can this case occur?\n-                            throw new UnsupportedOperationException();\n-                        }\n-                    }\n-                } else if (pb.terminatingOp() instanceof CoreOps.ExceptionRegionExit) {\n-                    \/\/ 3. pb == b\n-                    \/\/    3.1 pb.exit\n-                    \/\/      A. enter pb.exit region in b\n-                    \/\/         or replace pb.exit.target with pb.branch.target\n-                    \/\/    3.2 Otherwise,\n-                    \/\/      A. Nothing\n-                    Block.Builder exRegionEnter = lb.block();\n-                    lb.op(BytecodeInstructionOps.exceptionTableStart(\n-                            exRegionEnter.successor(),\n-                            bRegions.ere().catchBlocks().stream().map(b1 -> c.getLoweredBlock(b1.targetBlock()).successor()).toList()));\n-                    lb = exRegionEnter;\n-                }\n-            }\n-\n-            \/\/ If b is the entry block then all its parameters conservatively require slots\n-            \/\/ Some unused parameters might be declared before others that are used\n-            b.parameters().forEach(p -> c.getOrAssignSlot(p, pb == null));\n-\n-            \/\/ If b is a catch block then the exception argument will be represented on the stack\n-            if (c.catchingBlocks.contains(b)) {\n-                \/\/ Retain block argument for exception table generation\n-                Block.Parameter ex = b.parameters().get(0);\n-                clb.parameter(ex.type());\n-\n-                \/\/ Store in slot if used, otherwise pop\n-                if (!ex.uses().isEmpty()) {\n-                    int slot = c.getSlot(ex);\n-                    lb.op(BytecodeInstructionOps.store(toTypeKind(ex.type()), slot));\n-                } else {\n-                    lb.op(BytecodeInstructionOps.pop());\n-                }\n-            }\n-\n-            List<Op> ops = b.ops();\n-            \/\/ True if the last result is retained on the stack for use as first operand of current operation\n-            boolean isLastOpResultOnStack = false;\n-            Op.Result oprOnStack = null;\n-            for (int i = 0; i < ops.size() - 1; i++) {\n-                Op op = ops.get(i);\n-                Op.Result opr = op.result();\n-                TypeDesc oprType = opr.type();\n-                TypeKind rvt = oprType.equals(TypeDesc.VOID) ? null : toTypeKind(oprType);\n-\n-                if (op instanceof CoreOps.ConstantOp constantOp) {\n-                    if (constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n-                        \/\/ Loading a class constant may throw an exception so it cannot be deferred\n-                        lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n-                    } else {\n-                        \/\/ Defer process to use, where constants are inlined\n-                        \/\/ This applies to both operands and successor arguments\n-                        rvt = null;\n-                    }\n-                } else if (op instanceof CoreOps.VarOp vop) {\n-                    \/\/     %1 : Var<int> = var %0 @\"i\";\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-                    isLastOpResultOnStack = false;\n-\n-                    \/\/ Use slot of variable result\n-                    int slot = c.assignSlot(opr);\n-                    lb.op(BytecodeInstructionOps.store(toTypeKind(vop.varType()), slot));\n-\n-                    \/\/ Ignore result\n-                    rvt = null;\n-                } else if (op instanceof CoreOps.VarAccessOp.VarLoadOp vaop) {\n-                    \/\/ Use slot of variable result\n-                    int slot = c.getSlot(op.operands().get(0));\n-\n-                    CoreOps.VarOp vop = vaop.varOp();\n-                    lb.op(BytecodeInstructionOps.load(toTypeKind(vop.varType()), slot));\n-                } else if (op instanceof CoreOps.VarAccessOp.VarStoreOp vaop) {\n-                    if (!isLastOpResultOnStack) {\n-                        Value operand = op.operands().get(1);\n-                        if (operand instanceof Op.Result or &&\n-                                or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                                !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n-                            lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n-                        } else {\n-                            int slot = c.getSlot(operand);\n-                            lb.op(BytecodeInstructionOps.load(toTypeKind(operand.type()), slot));\n-                        }\n-                        isLastOpResultOnStack = false;\n-                    }\n-\n-                    \/\/ Use slot of variable result\n-                    int slot = c.getSlot(op.operands().get(0));\n-\n-                    CoreOps.VarOp vop = vaop.varOp();\n-                    lb.op(BytecodeInstructionOps.store(toTypeKind(vop.varType()), slot));\n-                } else if (op instanceof CoreOps.NegOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.neg(rvt));\n-                } else if (op instanceof CoreOps.NotOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    \/\/ True block\n-                    Block.Builder ctBlock = lb.block();\n-                    \/\/ False block\n-                    Block.Builder cfBlock = lb.block();\n-                    \/\/ Merge block\n-                    Block.Builder mergeBlock = lb.block();\n-\n-                    lb.op(BytecodeInstructionOps._if(BytecodeInstructionOps.Comparison.NE, ctBlock.successor(), cfBlock.successor()));\n-\n-                    ctBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 0));\n-                    ctBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n-\n-                    cfBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 1));\n-                    cfBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n-\n-                    lb = mergeBlock;\n-                } else if (op instanceof CoreOps.AddOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.add(rvt));\n-                } else if (op instanceof CoreOps.SubOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.sub(rvt));\n-                } else if (op instanceof CoreOps.MulOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.mul(rvt));\n-                } else if (op instanceof CoreOps.DivOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.div(rvt));\n-                } else if (op instanceof CoreOps.ModOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.rem(rvt));\n-                } else if (op instanceof CoreOps.ArrayAccessOp.ArrayLoadOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.aload(rvt));\n-                } else if (op instanceof CoreOps.ArrayAccessOp.ArrayStoreOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    TypeKind evt = toTypeKind(op.operands().get(2).type());\n-                    lb.op(BytecodeInstructionOps.astore(evt));\n-                } else if (op instanceof CoreOps.ArrayLengthOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.arraylength());\n-                } else if (op instanceof CoreOps.BinaryTestOp btop) {\n-                    if (!isConditionForCondBrOp(btop)) {\n-                        lb = comparison(lb, op, toComparisonType(btop),\n-                                c, isLastOpResultOnStack);\n-                    } else {\n-                        \/\/ Processing is deferred to the CondBrOp, do not process the op result\n-                        rvt = null;\n-                    }\n-                } else if (op instanceof CoreOps.NewOp newOp) {\n-                    TypeDesc t = newOp.constructorDescriptor().returnType();\n-                    if (t.dimensions() > 0) {\n-                        processOperands(lb, op, c, isLastOpResultOnStack);\n-                        if (t.dimensions() == 1) {\n-                            lb.op(BytecodeInstructionOps.newarray(t.componentType()));\n-                        } else {\n-                            lb.op(BytecodeInstructionOps.multinewarray(t, op.operands().size()));\n-                        }\n-                    } else {\n-                        if (isLastOpResultOnStack) {\n-                            int slot = c.assignSlot(oprOnStack);\n-                            lb.op(BytecodeInstructionOps.store(rvt, slot));\n-                            isLastOpResultOnStack = false;\n-                            oprOnStack = null;\n-                        }\n-\n-                        lb.op(BytecodeInstructionOps._new(t));\n-                        lb.op(BytecodeInstructionOps.dup());\n-\n-                        processOperands(lb, op, c, false);\n-                        lb.op(BytecodeInstructionOps.invoke(BytecodeInstructionOps.InvokeKind.SPECIAL, MethodDesc.initMethod(newOp.constructorDescriptor())));\n-                    }\n-                } else if (op instanceof CoreOps.InvokeOp invokeOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    \/\/ @@@ Enhance method descriptor to include how the method is to be invoked\n-                    \/\/ Example result of DirectMethodHandleDesc.toString()\n-                    \/\/   INTERFACE_VIRTUAL\/IntBinaryOperator::applyAsInt(IntBinaryOperator,int,int)int\n-                    \/\/ This will avoid the need to reflectively operate on the descriptor\n-                    \/\/ which may be insufficient in certain cases.\n-                    DirectMethodHandleDesc.Kind descKind;\n-                    try {\n-                        descKind = resolveToMethodHandleDesc(c.lookup, invokeOp.invokeDescriptor()).kind();\n-                    } catch (ReflectiveOperationException e) {\n-                        \/\/ @@@ Approximate fallback\n-                        if (invokeOp.hasReceiver()) {\n-                            descKind = DirectMethodHandleDesc.Kind.VIRTUAL;\n-                        } else {\n-                            descKind = DirectMethodHandleDesc.Kind.STATIC;\n-                        }\n-                    }\n-\n-                    BytecodeInstructionOps.InvokeKind ik = switch (descKind) {\n-                        case STATIC, INTERFACE_STATIC -> BytecodeInstructionOps.InvokeKind.STATIC;\n-                        case VIRTUAL -> BytecodeInstructionOps.InvokeKind.VIRTUAL;\n-                        case INTERFACE_VIRTUAL -> BytecodeInstructionOps.InvokeKind.INTERFACE;\n-                        case SPECIAL, INTERFACE_SPECIAL -> BytecodeInstructionOps.InvokeKind.SPECIAL;\n-                        default -> throw new IllegalStateException(\"Bad method descriptor resolution: \" +\n-                                invokeOp.descriptor() + \" > \" + invokeOp.invokeDescriptor());\n-                    };\n-                    boolean isInterface = switch (descKind) {\n-                        case INTERFACE_STATIC, INTERFACE_VIRTUAL, INTERFACE_SPECIAL -> true;\n-                        default -> false;\n-                    };\n-                    lb.op(BytecodeInstructionOps.invoke(ik, invokeOp.invokeDescriptor(), isInterface));\n-\n-                    if (rvt == null && !op.operands().isEmpty()) {\n-                        isLastOpResultOnStack = false;\n-                    }\n-                } else if (op instanceof CoreOps.FieldAccessOp.FieldLoadOp fieldOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    if (fieldOp.operands().isEmpty()) {\n-                        lb.op(BytecodeInstructionOps.getField(BytecodeInstructionOps.FieldKind.STATIC, fieldOp.fieldDescriptor()));\n-                    } else {\n-                        lb.op(BytecodeInstructionOps.getField(BytecodeInstructionOps.FieldKind.INSTANCE, fieldOp.fieldDescriptor()));\n-                    }\n-                } else if (op instanceof CoreOps.FieldAccessOp.FieldStoreOp fieldOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-                    isLastOpResultOnStack = false;\n-\n-                    if (fieldOp.operands().size() == 1) {\n-                        lb.op(BytecodeInstructionOps.putField(BytecodeInstructionOps.FieldKind.STATIC, fieldOp.fieldDescriptor()));\n-                    } else {\n-                        lb.op(BytecodeInstructionOps.putField(BytecodeInstructionOps.FieldKind.INSTANCE, fieldOp.fieldDescriptor()));\n-                    }\n-                } else if (op instanceof CoreOps.InstanceOfOp instOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.instanceOf(instOp.type()));\n-                } else if (op instanceof CoreOps.CastOp castOp) {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    lb.op(BytecodeInstructionOps.checkCast(castOp.type()));\n-                } else {\n-                    throw new UnsupportedOperationException(\"Operation not supported: \" + op);\n-                }\n-\n-                \/\/ Free up slots for values that are no longer live\n-                c.freeSlotsOfOp(op);\n-\n-                \/\/ Assign slot to operation result\n-                if (rvt != null) {\n-                    if (!isResultOnlyUse(opr)) {\n-                        isLastOpResultOnStack = false;\n-                        oprOnStack = null;\n-                        int slot = c.assignSlot(opr);\n-                        lb.op(BytecodeInstructionOps.store(rvt, slot));\n-                    } else {\n-                        isLastOpResultOnStack = true;\n-                        oprOnStack = opr;\n-                    }\n-                }\n-            }\n-\n-            Op top = b.terminatingOp();\n-            c.freeSlotsOfOp(top);\n-            if (top instanceof CoreOps.ReturnOp op) {\n-                Value a = op.returnValue();\n-                if (a == null) {\n-                    lb.op(BytecodeInstructionOps._return());\n-                } else {\n-                    processOperands(lb, op, c, isLastOpResultOnStack);\n-\n-                    TypeKind vt = toTypeKind(a.type());\n-                    lb.op(BytecodeInstructionOps._return(vt));\n-                }\n-            } else if (top instanceof CoreOps.YieldOp op) {\n-                processOperands(lb, op, c, isLastOpResultOnStack);\n-                lb.op(CoreOps._yield());\n-            } else if (top instanceof CoreOps.ThrowOp _throw) {\n-                processOperands(lb, _throw, c, isLastOpResultOnStack);\n-\n-                lb.op(BytecodeInstructionOps.athrow());\n-            } else if (top instanceof CoreOps.BranchOp op) {\n-                assignBlockArguments(op, op.branch(), lb, c);\n-                lb.op(BytecodeInstructionOps._goto(c.getLoweredBlock(op.branch().targetBlock()).successor()));\n-            } else if (top instanceof CoreOps.ConditionalBranchOp cop) {\n-                if (getConditionForCondBrOp(cop) instanceof CoreOps.BinaryTestOp btop) {\n-                    \/\/ Processing of the BinaryTestOp was deferred, so it can be merged with CondBrOp\n-                    conditionalBranch(lb, btop, cop, c, isLastOpResultOnStack,\n-                            (_lb, tBlock, fBlock) -> {\n-                                \/\/ Inverse condition and ensure true block is the immediate successor, in sequence, of lb\n-                                var vt = toTypeKind(btop.operands().get(0).type());\n-                                var cond = toComparisonType(btop).inverse();\n-                                if (vt == TypeKind.IntType) {\n-                                    _lb.op(BytecodeInstructionOps.if_cmp(TypeKind.IntType, cond, fBlock.successor(), tBlock.successor()));\n-                                } else {\n-                                    _lb.op(BytecodeInstructionOps.cmp(vt));\n-                                    _lb.op(BytecodeInstructionOps._if(cond, fBlock.successor(), tBlock.successor()));\n-                                }\n-                            });\n-\n-                } else {\n-                    conditionalBranch(lb, cop, cop, c, isLastOpResultOnStack,\n-                            (_lb, tBlock, fBlock) -> {\n-                                _lb.op(BytecodeInstructionOps._if(BytecodeInstructionOps.Comparison.EQ, fBlock.successor(), tBlock.successor()));\n-                            });\n-                }\n-            } else if (top instanceof CoreOps.ExceptionRegionEnter er) {\n-                assignBlockArguments(er, er.start(), lb, c);\n-                lb.op(BytecodeInstructionOps.exceptionTableStart(c.getLoweredBlock(er.start().targetBlock()).successor(),\n-                        er.catchBlocks().stream().map(b1 -> c.getLoweredBlock(b1.targetBlock()).successor()).toList()));\n-\n-                for (Block.Reference catchBlock : er.catchBlocks()) {\n-                    c.transitionLiveSlotSetTo(catchBlock.targetBlock());\n-                }\n-            } else if (top instanceof CoreOps.ExceptionRegionExit er) {\n-                assignBlockArguments(er, er.end(), lb, c);\n-                lb.op(BytecodeInstructionOps.exceptionTableEnd());\n-                lb.op(BytecodeInstructionOps._goto(c.getLoweredBlock(er.end().targetBlock()).successor()));\n-            } else {\n-                throw new UnsupportedOperationException(\"Terminating operation not supported: \" + top);\n-            }\n-        }\n-    }\n-\n-    private static void processOperands(Block.Builder lb,\n-                                        Op op,\n-                                        LoweringContext c,\n-                                        boolean isLastOpResultOnStack) {\n-        for (int i = isLastOpResultOnStack ? 1 : 0; i < op.operands().size(); i++) {\n-            Value operand = op.operands().get(i);\n-            if (operand instanceof Op.Result or &&\n-                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n-                lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n-            } else {\n-                int slot = c.getSlot(operand);\n-                lb.op(BytecodeInstructionOps.load(toTypeKind(operand.type()), slot));\n-            }\n-        }\n-    }\n-\n-    \/\/ Determines if the operation result used only by the next operation as the first operand\n-    private static boolean isResultOnlyUse(Op.Result opr) {\n-        Set<Op.Result> uses = opr.uses();\n-        if (uses.size() != 1) {\n-            return false;\n-        }\n-\n-        \/\/ Pass over constant operations\n-        Op.Result use = uses.iterator().next();\n-        Op nextOp = opr.op();\n-        do {\n-            nextOp = opr.declaringBlock().nextOp(nextOp);\n-        } while (nextOp instanceof CoreOps.ConstantOp);\n-\n-        if (nextOp == null || use != nextOp.result()) {\n-            return false;\n-        }\n-\n-        \/\/ Check if used in successor\n-        for (Block.Reference s : nextOp.successors()) {\n-            if (s.arguments().contains(opr)) {\n-                return false;\n-            }\n-        }\n-\n-        List<Value> operands = nextOp.operands();\n-        return operands.size() > 0 && opr == operands.get(0);\n-    }\n-\n-    private static boolean isConditionForCondBrOp(CoreOps.BinaryTestOp op) {\n-        \/\/ Result of op has one use as the operand of a CondBrOp op,\n-        \/\/ and both ops are in the same block\n-\n-        Set<Op.Result> uses = op.result().uses();\n-        if (uses.size() != 1) {\n-            return false;\n-        }\n-        Op.Result use = uses.iterator().next();\n-\n-        if (use.declaringBlock() != op.parentBlock()) {\n-            return false;\n-        }\n-\n-        \/\/ Check if used in successor\n-        for (Block.Reference s : use.op().successors()) {\n-            if (s.arguments().contains(op.result())) {\n-                return false;\n-            }\n-        }\n-\n-        return use.op() instanceof CoreOps.ConditionalBranchOp;\n-    }\n-\n-    private static Op getConditionForCondBrOp(CoreOps.ConditionalBranchOp op) {\n-        Value p = op.predicate();\n-        if (p.uses().size() != 1) {\n-            return null;\n-        }\n-\n-        if (p.declaringBlock() != op.parentBlock()) {\n-            return null;\n-        }\n-\n-        \/\/ Check if used in successor\n-        for (Block.Reference s : op.successors()) {\n-            if (s.arguments().contains(p)) {\n-                return null;\n-            }\n-        }\n-\n-        if (p instanceof Op.Result or) {\n-            return or.op();\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    private static Block.Builder comparison(Block.Builder lb,\n-                                            Op btop,\n-                                            BytecodeInstructionOps.Comparison cond, LoweringContext c,\n-                                            boolean isLastOpResultOnStack) {\n-        processOperands(lb, btop, c, isLastOpResultOnStack);\n-\n-        TypeKind vt = toTypeKind(btop.operands().get(0).type());\n-\n-        \/\/ Inverse condition and ensure true block is the immediate successor, in sequence, of lb\n-        cond = cond.inverse();\n-        \/\/ True block\n-        Block.Builder ctBlock = lb.block();\n-        \/\/ False block\n-        Block.Builder cfBlock = lb.block();\n-        \/\/ Merge block\n-        Block.Builder mergeBlock = lb.block();\n-        if (vt == TypeKind.IntType) {\n-            lb.op(BytecodeInstructionOps.if_cmp(TypeKind.IntType, cond, cfBlock.successor(), ctBlock.successor()));\n-        } else {\n-            lb.op(BytecodeInstructionOps.cmp(vt));\n-            lb.op(BytecodeInstructionOps._if(cond, cfBlock.successor(), ctBlock.successor()));\n-        }\n-\n-        ctBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 1));\n-        ctBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n-\n-        cfBlock.op(BytecodeInstructionOps._const(TypeKind.IntType, 0));\n-        cfBlock.op(BytecodeInstructionOps._goto(mergeBlock.successor()));\n-\n-        return mergeBlock;\n-    }\n-\n-    interface ConditionalBranchConsumer {\n-        void accept(Block.Builder lb, Block.Builder tBlock, Block.Builder fBlock);\n-    }\n-\n-    private static void conditionalBranch(Block.Builder lb,\n-                                          Op operandOp, CoreOps.ConditionalBranchOp cop,\n-                                          LoweringContext c,\n-                                          boolean isLastOpResultOnStack,\n-                                          ConditionalBranchConsumer cbc) {\n-        processOperands(lb, operandOp, c, isLastOpResultOnStack);\n-\n-        Block.Builder tBlock = lb.block();\n-        Block.Builder fBlock = lb.block();\n-\n-        cbc.accept(lb, tBlock, fBlock);\n-\n-        assignBlockArguments(cop, cop.trueBranch(), tBlock, c);\n-        tBlock.op(BytecodeInstructionOps._goto(c.getLoweredBlock(cop.trueBranch().targetBlock()).successor()));\n-\n-        assignBlockArguments(cop, cop.falseBranch(), fBlock, c);\n-        fBlock.op(BytecodeInstructionOps._goto(c.getLoweredBlock(cop.falseBranch().targetBlock()).successor()));\n-    }\n-\n-    private static void assignBlockArguments(Op op, Block.Reference s, Block.Builder lb, LoweringContext c) {\n-        List<Value> sargs = s.arguments();\n-        List<Block.Parameter> bargs = s.targetBlock().parameters();\n-\n-        \/\/ Transition over live-out to successor block\n-        \/\/ All predecessors of successor will have the same live-out set so it does not\n-        \/\/ matter which predecessor performs this action\n-        c.transitionLiveSlotSetTo(s.targetBlock());\n-\n-        \/\/ First push successor arguments on the stack, then pop and assign\n-        \/\/ so as not to overwrite slots that are reused slots at different argument positions\n-\n-        \/\/ Push successor values on the stack\n-        for (int i = 0; i < bargs.size(); i++) {\n-            Block.Parameter barg = bargs.get(i);\n-            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n-\n-            Value value = sargs.get(i);\n-            if (value instanceof Op.Result or &&\n-                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n-                lb.op(BytecodeInstructionOps.ldc(constantOp.resultType(), constantOp.value()));\n-            } else {\n-                int sslot = c.getSlot(value);\n-\n-                \/\/ Assignment only required if slots differ\n-                if (sslot != bslot) {\n-                    TypeKind vt = toTypeKind(barg.type());\n-                    lb.op(BytecodeInstructionOps.load(vt, sslot));\n-                }\n-            }\n-        }\n-\n-        \/\/ Pop successor arguments on the stack assigning to block argument slots if necessary\n-        for (int i = bargs.size() - 1; i >= 0; i--) {\n-            Block.Parameter barg = bargs.get(i);\n-            int bslot = c.liveSlotSet(s.targetBlock()).getOrAssignSlot(barg);\n-\n-            Value value = sargs.get(i);\n-            if (value instanceof Op.Result or &&\n-                    or.op() instanceof CoreOps.ConstantOp constantOp &&\n-                    !constantOp.resultType().equals(TypeDesc.J_L_CLASS)) {\n-                TypeKind vt = toTypeKind(barg.type());\n-                lb.op(BytecodeInstructionOps.store(vt, bslot));\n-            } else {\n-                int sslot = c.getSlot(value);\n-\n-                \/\/ Assignment only required if slots differ\n-                if (sslot != bslot) {\n-                    TypeKind vt = toTypeKind(barg.type());\n-                    lb.op(BytecodeInstructionOps.store(vt, bslot));\n-                }\n-            }\n-        }\n-    }\n-\n-    static DirectMethodHandleDesc resolveToMethodHandleDesc(MethodHandles.Lookup l, MethodDesc d) throws ReflectiveOperationException {\n-        MethodHandle mh = d.resolve(l);\n-\n-        if (mh.describeConstable().isEmpty()) {\n-            throw new NoSuchMethodException();\n-        }\n-\n-        MethodHandleDesc mhd = mh.describeConstable().get();\n-        if (!(mhd instanceof DirectMethodHandleDesc dmhd)) {\n-            throw new NoSuchMethodException();\n-        }\n-\n-        return dmhd;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLower.java","additions":0,"deletions":1019,"binary":false,"changes":1019,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -152,4 +151,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(f);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), f);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/ad\/TestForwardAutoDiff.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -117,4 +116,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestArrayCreation.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -134,4 +133,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftArrayCreation.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -103,4 +102,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generateClassData(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestLiftSimple.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,4 +84,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestNew.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -249,4 +249,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSimple.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -158,4 +157,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSlots.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -276,4 +276,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(MethodHandles.lookup(), lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTry.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-    @Test\n+    @Test(enabled = false)\n+    \/\/finalizer in exception handler is invalid (missing exception.region.exit)\n@@ -212,4 +213,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(MethodHandles.lookup(), lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinally.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-    @Test\n+    @Test(enabled = false)\n+    \/\/finalizer in exception handler is invalid (missing exception.region.exit)\n@@ -235,4 +236,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(MethodHandles.lookup(), lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestTryFinallyNested.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.reflect.code.bytecode.BytecodeLower;\n@@ -85,4 +84,1 @@\n-        CoreOps.FuncOp bcf = BytecodeLower.lowerToBytecodeDialect(lf);\n-        bcf.writeTo(System.out);\n-\n-        return BytecodeGenerator.generate(MethodHandles.lookup(), bcf);\n+        return BytecodeGenerator.generate(MethodHandles.lookup(), lf);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestWhile.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}