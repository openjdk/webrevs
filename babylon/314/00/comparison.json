{"files":[{"patch":"@@ -1,1 +1,1 @@\n-package nbody;\n+package hat.backend.jextracted;\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/CLWrap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.backend.jextracted;\n+\n+public class SoWeCanBuild {\n+}\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/SoWeCanBuild.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -81,0 +81,1 @@\n+    var wrapsDir = dir.existingDir(\"wrap\");\n@@ -103,0 +104,5 @@\n+    var wrap= jar(jar -> jar\n+         .jarFile(buildDir.jarFile(\"wrap.jar\"))\n+         .maven_style_root(wrapsDir.dir(\"wrap\"))\n+         .javac(javac -> javac.current_source())\n+    );\n@@ -120,0 +126,5 @@\n+            jar(jar -> jar\n+               .jarFile(buildDir.jarFile(\"clwrap.jar\"))\n+               .maven_style_root(wrapsDir.dir(\"clwrap\"))\n+               .javac(javac -> javac.current_source().class_path(wrap, openclCapability.jarFile(buildDir)))\n+            );\n@@ -138,0 +149,10 @@\n+            jar(jar -> jar\n+               .jarFile(buildDir.jarFile(\"glwrap.jar\"))\n+               .maven_style_root(wrapsDir.dir(\"glwrap\"))\n+               .javac(javac -> javac\n+                  .current_source()\n+                  .exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLCallbackEventHandler\\\\.java$\"))\n+                  \/\/.exclude(javaSrc -> javaSrc.matches(\"^.*\/wrap\/glwrap\/GLFuncEventHandler\\\\.java$\"))\n+                  .class_path(wrap, openglCapability.jarFile(buildDir))\n+               )\n+            );\n@@ -168,1 +189,1 @@\n-    \/\/ Here we create all backend jars.\n+    \/\/ Here we create all ffi-backend jars.\n@@ -183,0 +204,25 @@\n+    \/\/ Here we create jextracted-backend jars.\n+    var jextractedBackends = backends.existingDir(\"jextracted\");\n+    var jextractedBackendSharedDir = jextractedBackends.dir(\"shared\");\n+    out.println(\"Shared jextracted \"+jextractedBackendSharedDir.path());\n+    var jextractedBackendSharedResult = jar(hatJarOptions, jar -> jar\n+          .jarFile(buildDir.jarFile(\"hat-backend-jextracted-shared-1.0.jar\"))\n+          .maven_style_root(jextractedBackendSharedDir)\n+          .javac(hatJavacOpts, javac -> javac.verbose(true)\n+              .class_path(hatJarFile)\n+          )\n+    ); \n+\n+    if (openclCapability.available()){\n+       var jextractedBackendOpenCLDir = jextractedBackends.dir(\"opencl\");\n+       out.println(\"OpenCL jextracted \"+jextractedBackendOpenCLDir.path());\n+       var jextractedOpenCLBackendOpenCLResult = jar(hatJarOptions, jar -> jar\n+          .jarFile(buildDir.jarFile(\"hat-backend-jextracted-opencl-1.0.jar\"))\n+          .maven_style_root(jextractedBackendOpenCLDir)\n+          .javac(hatJavacOpts, javac -> javac.verbose(true)\n+              .class_path(hatJarFile, openclCapability.jarFile(buildDir), jextractedBackendSharedResult )\n+          )\n+       );\n+   }\n+\n+\n","filename":"hat\/bld","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -5,0 +5,3 @@\n+    <excludeFromCompile>\n+      <file url=\"file:\/\/$PROJECT_DIR$\/..\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLCallbackEventHandler.java\" \/>\n+    <\/excludeFromCompile>\n@@ -9,0 +12,1 @@\n+      <module name=\"glwrap\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n","filename":"hat\/intellij\/.idea\/compiler.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,0 +5,4 @@\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/wrap.iml\" filepath=\"$PROJECT_DIR$\/wrap.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/glwrap.iml\" filepath=\"$PROJECT_DIR$\/glwrap.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/clwrap.iml\" filepath=\"$PROJECT_DIR$\/clwrap.iml\" \/>\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/cuwrap.iml\" filepath=\"$PROJECT_DIR$\/cuwrap.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+    <orderEntry type=\"module\" module-name=\"clwrap\" \/>\n","filename":"hat\/intellij\/backend_jextracted_opencl.iml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/clwrap\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/clwrap\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/clwrap\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n+    <orderEntry type=\"module-library\">\n+      <library>\n+        <CLASSES>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opencl.jar!\/\" \/>\n+        <\/CLASSES>\n+        <JAVADOC \/>\n+        <SOURCES \/>\n+      <\/library>\n+    <\/orderEntry>\n+  <\/component>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/clwrap.iml","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/cuwrap\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/cuwrap\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/cuwrap\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/cuwrap.iml","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/glwrap\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/glwrap\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/glwrap\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+    <orderEntry type=\"module\" module-name=\"wrap\" \/>\n+    <orderEntry type=\"module-library\">\n+      <library>\n+        <CLASSES>\n+          <root url=\"jar:\/\/$MODULE_DIR$\/..\/build\/opengl.jar!\/\" \/>\n+        <\/CLASSES>\n+        <JAVADOC \/>\n+        <SOURCES \/>\n+      <\/library>\n+    <\/orderEntry>\n+  <\/component>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/glwrap.iml","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/wrap\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/wrap\/src\/main\/java\" isTestSource=\"false\" \/>\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/wrap\/wrap\/src\/main\/resources\" type=\"java-resource\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/wrap.iml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-    .filter(dir -> dir.matches(\"^.*(hat|examples|backends|docs|bldr)$\"))\n+    .filter(dir -> dir.matches(\"^.*(hat|wrap|examples|backends|docs|bldr)$\"))\n","filename":"hat\/sanity","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.clwrap;\n+\n+import opencl.opencl_h;\n+import wrap.ArenaHolder;\n+import wrap.Wrap;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.foreign.MemorySegment.NULL;\n+import static opencl.opencl_h.*;\n+\n+\/\/ https:\/\/streamhpc.com\/blog\/2013-04-28\/opencl-error-codes\/\n+public class CLPlatform implements ArenaHolder {\n+    public static List<CLPlatform> platforms(Arena arena) {\n+        var arenaWrapper = ArenaHolder.wrap(arena);\n+        List<CLPlatform> platforms = new ArrayList<>();\n+        var platformc = arenaWrapper.intPtr( 0);\n+        if ((opencl_h.clGetPlatformIDs(0, NULL, platformc.ptr())) != CL_SUCCESS()) {\n+            System.out.println(\"Failed to get opencl platforms\");\n+        } else {\n+            var platformIds = arenaWrapper.ptrArr( platformc.get());\n+            if ((opencl_h.clGetPlatformIDs(platformc.get(), platformIds.ptr(), NULL)) != CL_SUCCESS()) {\n+                System.out.println(\"Failed getting platform ids\");\n+            } else {\n+                for (int i = 0; i < platformc.get(); i++) {\n+                    platforms.add(new CLPlatform(arena, platformIds.get(i)));\n+                }\n+            }\n+        }\n+        return platforms;\n+    }\n+\n+    public static class CLDevice implements ArenaHolder {\n+        final CLPlatform platform;\n+        final MemorySegment deviceId;\n+\n+        @Override\n+        public Arena arena() {\n+            return platform.arena();\n+        }\n+\n+        int intDeviceInfo(int query) {\n+            var value = intPtr(0);\n+            if ((opencl_h.clGetDeviceInfo(deviceId, query, value.sizeof(), value.ptr(), NULL)) != CL_SUCCESS()) {\n+                throw new RuntimeException(\"Failed to get query \" + query);\n+            }\n+            return value.get();\n+        }\n+\n+        String strDeviceInfo(int query) {\n+            var value = cstr(2048);\n+            if ((opencl_h.clGetDeviceInfo(deviceId, query, value.len(), value.ptr(), NULL)) != CL_SUCCESS()) {\n+                throw new RuntimeException(\"Failed to get query \" + query);\n+            }\n+            return value.get();\n+        }\n+\n+        public int computeUnits() {\n+            return intDeviceInfo(CL_DEVICE_MAX_COMPUTE_UNITS());\n+        }\n+\n+        public String deviceName() {\n+            return strDeviceInfo(CL_DEVICE_NAME());\n+        }\n+        public String deviceVendor() {\n+            return strDeviceInfo(CL_DEVICE_VENDOR());\n+        }\n+\n+        public String builtInKernels() {\n+            return strDeviceInfo(CL_DEVICE_BUILT_IN_KERNELS());\n+        }\n+\n+        CLDevice(CLPlatform platform, MemorySegment deviceId) {\n+            this.platform = platform;\n+            this.deviceId = deviceId;\n+        }\n+\n+        public static class CLContext implements ArenaHolder {\n+            CLDevice device;\n+            MemorySegment context;\n+            MemorySegment queue;\n+\n+            @Override\n+            public Arena arena() {\n+                return device.arena();\n+            }\n+\n+            CLContext(CLDevice device, MemorySegment context) {\n+                this.device = device;\n+                this.context = context;\n+                var status = device.platform.status;\n+\n+                var queue_props = CL_QUEUE_PROFILING_ENABLE();\n+                if ((this.queue = opencl_h.clCreateCommandQueue(context, device.deviceId, queue_props, status.ptr())) == NULL) {\n+                    opencl_h.clReleaseContext(context);\n+                } else {\n+                    if (!status.isOK()) {\n+                        opencl_h.clReleaseContext(context);\n+                    }\n+                }\n+            }\n+\n+            static public class CLProgram implements ArenaHolder {\n+                CLContext context;\n+                String source;\n+                MemorySegment program;\n+                String log;\n+\n+                @Override\n+                public Arena arena() {\n+                    return context.arena();\n+                }\n+\n+                CLProgram(CLContext context, String source) {\n+                    this.context = context;\n+                    this.source = source;\n+                    var sourceList = ptrArr(source);\n+                    var status = context.device.platform.status;\n+                    if ((program = opencl_h.clCreateProgramWithSource(context.context, 1, sourceList.ptr(), NULL, status.ptr())) == NULL) {\n+                        if (!status.isOK()) {\n+                            throw new RuntimeException(\"failed to createProgram \" + status.get());\n+                        }\n+                        throw new RuntimeException(\"failed to createProgram\");\n+                    } else {\n+                        var deviceIdList = ptrArr(context.device.deviceId);\n+                        if ((status.set(opencl_h.clBuildProgram(program, 1, deviceIdList.ptr(), NULL, NULL, NULL))) != CL_SUCCESS()) {\n+                            System.out.println(\"failed to build\" + status);\n+                        }\n+                        var logLen = longPtr(1L);\n+                        if ((status.set(opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), 0, NULL, logLen.ptr()))) != CL_SUCCESS()) {\n+                            System.out.println(\"failed to get log build \" + status.get());\n+                        } else {\n+                            var logPtr = cstr(1 + logLen.get());\n+                            if ((status.set(opencl_h.clGetProgramBuildInfo(program, context.device.deviceId, opencl_h.CL_PROGRAM_BUILD_LOG(), logLen.get(), logPtr.ptr(), NULL))) != opencl_h.CL_SUCCESS()) {\n+                                System.out.println(\"clGetBuildInfo (getting log) failed\");\n+                            } else {\n+                                log = logPtr.get();\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                public static class CLKernel implements ArenaHolder {\n+                    CLProgram program;\n+                    MemorySegment kernel;\n+                    String kernelName;\n+\n+                    @Override\n+                    public Arena arena() {\n+                        return program.arena();\n+                    }\n+\n+                    public CLKernel(CLProgram program, String kernelName) {\n+                        this.program = program;\n+                        this.kernelName = kernelName;\n+                        var kernelNameCStr = this.cstr(kernelName);\n+                        var status = program.context.device.platform.status;\n+                        kernel = opencl_h.clCreateKernel(program.program, kernelNameCStr.ptr(), status.ptr());\n+                        if (!status.isOK()) {\n+                            System.out.println(\"failed to create kernel \" + status);\n+                        }\n+                    }\n+\n+\n+                    public void run(ComputeContext computeContext, int range, Object... args) {\n+                        var status = CLStatusPtr.of(arena());\n+                        for (int i = 0; i < args.length; i++) {\n+                            if (args[i] instanceof ComputeContext.MemorySegmentState memorySegmentState) {\n+                                if (memorySegmentState.clMemPtr == null) {\n+                                    memorySegmentState.clMemPtr = ComputeContext.ClMemPtr.of(arena(),opencl_h.clCreateBuffer(program.context.context,\n+                                            CL_MEM_USE_HOST_PTR() | CL_MEM_READ_WRITE(),\n+                                            memorySegmentState.memorySegment.byteSize(),\n+                                            memorySegmentState.memorySegment,\n+                                            status.ptr()));\n+                                    if (!status.isOK()) {\n+                                        throw new RuntimeException(\"failed to create memory buffer \" + status.get());\n+                                    }\n+                                      }\n+                                if (memorySegmentState.copyToDevice) {\n+                                    status.set(opencl_h.clEnqueueWriteBuffer(program.context.queue,\n+                                            memorySegmentState.clMemPtr.get(),\n+                                            computeContext.blockInt(),\n+                                            0,\n+                                            memorySegmentState.memorySegment.byteSize(),\n+                                            memorySegmentState.memorySegment,\n+                                            computeContext.eventc(),\n+                                            computeContext.eventsPtr(),\n+                                            computeContext.nextEventPtrSlot()\n+                                    ));\n+                                    if (!status.isOK()) {\n+                                        System.out.println(\"failed to enqueue write \" + status);\n+                                    }\n+                                }\n+\n+                                status.set(opencl_h.clSetKernelArg(kernel, i, memorySegmentState.clMemPtr.sizeof(), memorySegmentState.clMemPtr.ptr()));\n+                                if (!status.isOK()) {\n+                                    System.out.println(\"failed to set arg \" + status);\n+                                }\n+                            } else {\n+                                Wrap.Ptr ptr = switch (args[i]) {\n+                                    case Integer intArg -> intPtr(intArg);\n+                                    case Float floatArg -> floatPtr(floatArg);\n+                                    default -> throw new IllegalStateException(\"Unexpected value: \" + args[i]);\n+                                };\n+                                status.set(opencl_h.clSetKernelArg(kernel, i, ptr.sizeof(), ptr.ptr()));\n+                                if (!status.isOK()) {\n+                                    System.out.println(\"failed to set arg \" + status);\n+                                }\n+\n+                            }\n+                        }\n+\n+                        \/\/ We need to store x,y,z sizes so this is a kind of int3\n+                        var globalSize = this.ofInts(range, 0, 0);\n+                        status.set(opencl_h.clEnqueueNDRangeKernel(\n+                                        program.context.queue,\n+                                        kernel,\n+                                        1, \/\/ this must match the # of dims we are using in this case 1 of 3\n+                                        NULL,\n+                                        globalSize.ptr(),\n+                                        NULL,\n+                                        computeContext.eventc(),\n+                                        computeContext.eventsPtr(),\n+                                        computeContext.nextEventPtrSlot()\n+                                )\n+                        );\n+                        if (!status.isOK()) {\n+                            System.out.println(\"failed to enqueue NDRange \" + status);\n+                        }\n+\n+                        if (computeContext.alwaysBlock) {\n+                            opencl_h.clFlush(program.context.queue);\n+                        }\n+\n+                        for (int i = 0; i < args.length; i++) {\n+                            if (args[i] instanceof ComputeContext.MemorySegmentState memorySegmentState) {\n+                                if (memorySegmentState.copyFromDevice) {\n+                                    status.set(opencl_h.clEnqueueReadBuffer(program.context.queue,\n+                                            memorySegmentState.clMemPtr.get(),\n+                                            computeContext.blockInt(),\n+                                            0,\n+                                            memorySegmentState.memorySegment.byteSize(),\n+                                            memorySegmentState.memorySegment,\n+                                            computeContext.eventc(),\n+                                            computeContext.eventsPtr(),\n+                                            computeContext.nextEventPtrSlot()\n+                                    ));\n+                                    if (!status.isOK()) {\n+                                        System.out.println(\"failed to enqueue read \" + status);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        \/\/ if (!computeContext.alwaysBlock) {\n+                        computeContext.waitForEvents();\n+                        \/\/  }\n+                    }\n+                }\n+\n+                public CLKernel getKernel(String kernelName) {\n+                    return new CLKernel(this, kernelName);\n+                }\n+            }\n+\n+            public CLProgram buildProgram(String source) {\n+                var program = new CLProgram(this, source);\n+                return program;\n+            }\n+        }\n+\n+        public CLContext createContext() {\n+            var status = platform.status;\n+            MemorySegment context;\n+            var deviceIds = ptrArr(this.deviceId);\n+            if ((context = opencl_h.clCreateContext(NULL, 1, deviceIds.ptr(), NULL, NULL, status.ptr())) == NULL) {\n+                System.out.println(\"Failed to get context  \");\n+                return null;\n+            } else {\n+                if (!status.isOK()) {\n+                    System.out.println(\"failed to get context  \" + status);\n+                }\n+                return new CLContext(this, context);\n+            }\n+        }\n+    }\n+\n+    int intPlatformInfo(int query) {\n+        var value = intPtr(0);\n+        if ((opencl_h.clGetPlatformInfo(platformId, query, value.sizeof(), value.ptr(), NULL)) != opencl_h.CL_SUCCESS()) {\n+            throw new RuntimeException(\"Failed to get query \" + query);\n+        }\n+        return value.get();\n+    }\n+\n+    String strPlatformInfo(int query) {\n+\n+        var value = cstr(2048);\n+        int status;\n+        if ((status = opencl_h.clGetPlatformInfo(platformId, query, value.len(), value.ptr(), NULL)) != opencl_h.CL_SUCCESS()) {\n+            throw new RuntimeException(\"Failed to get query \" + query);\n+        }\n+        return value.get();\n+    }\n+\n+    private Arena secretarena;\n+    MemorySegment platformId;\n+    public List<CLDevice> devices = new ArrayList<>();\n+    final CLStatusPtr status;\n+\n+    public String platformName() {\n+        return strPlatformInfo(opencl_h.CL_PLATFORM_NAME());\n+    }\n+\n+    String vendorName() {\n+        return strPlatformInfo(opencl_h.CL_PLATFORM_VENDOR());\n+    }\n+\n+    String version() {\n+        return strPlatformInfo(opencl_h.CL_PLATFORM_VERSION());\n+    }\n+\n+    @Override\n+    public Arena arena() {\n+        return secretarena;\n+    }\n+\n+    public CLPlatform(Arena arena, MemorySegment platformId) {\n+        this.secretarena = arena;\n+        this.platformId = platformId;\n+        this.status = CLStatusPtr.of(arena());\n+        var devicec = intPtr( 0);\n+        if ((status.set(opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicec.ptr()))) != opencl_h.CL_SUCCESS()) {\n+            System.err.println(\"Failed getting devicec for platform 0 \");\n+        } else {\n+            \/\/  System.out.println(\"platform 0 has \" + devicec + \" device\" + ((devicec > 1) ? \"s\" : \"\"));\n+            var deviceIdList = ptrArr(devicec.get());\n+            if ((status.set(opencl_h.clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec.get(), deviceIdList.ptr(), devicec.ptr()))) != opencl_h.CL_SUCCESS()) {\n+                System.err.println(\"Failed getting deviceids  for platform 0 \");\n+            } else {\n+                \/\/ System.out.println(\"We have \"+devicec+\" device ids\");\n+                for (int i = 0; i < devicec.get(); i++) {\n+                    devices.add(new CLDevice(this, deviceIdList.get(i)));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLPlatform.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.clwrap;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opencl.opencl_h.*;\n+\n+public record CLStatusPtr(MemorySegment ptr) {\n+    public static CLStatusPtr of(Arena arena) {\n+        return new CLStatusPtr(arena.allocateFrom(JAVA_INT, CL_SUCCESS()));\n+    }\n+\n+    public int set(int value) {\n+        ptr.set(JAVA_INT, 0, value);\n+        return value;\n+    }\n+\n+    public int get() {\n+        return ptr.get(JAVA_INT, 0);\n+    }\n+\n+    public boolean isOK() {\n+        return get() == CL_SUCCESS();\n+    }\n+\n+    public long sizeof() {\n+        return JAVA_INT.byteSize();\n+    }\n+}\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLStatusPtr.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.clwrap;\n+\n+import opencl.opencl_h;\n+import wrap.Wrap;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.lang.foreign.MemorySegment.NULL;\n+\n+public class ComputeContext {\n+\n+    public MemorySegmentState register(MemorySegment segment) {\n+        return memorySegmentToStateMap.computeIfAbsent(segment, MemorySegmentState::new);\n+    }\n+\n+    public MemorySegmentState getState(MemorySegment memorySegment) {\n+        return memorySegmentToStateMap.get(memorySegment);\n+    }\n+\n+    public int incEventc() {\n+        eventc++;\n+        return eventc;\n+    }\n+\n+    public int eventc() {\n+        return alwaysBlock ? 0 : eventc;\n+    }\n+\n+    public MemorySegment eventsPtr() {\n+        return (alwaysBlock || eventc == 0) ? NULL : eventsPtr;\n+    }\n+\n+    public MemorySegment nextEventPtrSlot() {\n+        if (alwaysBlock) {\n+            return NULL;\n+        } else {\n+            var seg = eventsPtr.asSlice(eventc * opencl_h.cl_event.byteSize(), opencl_h.cl_event);\n+            incEventc();\n+            return seg;\n+        }\n+    }\n+\n+    public void resetEventc() {\n+        eventc = 0;\n+    }\n+\n+    public void waitForEvents() {\n+        if (!alwaysBlock) {\n+            CLStatusPtr status = CLStatusPtr.of(arena);\n+            status.set(opencl_h.clWaitForEvents(eventc(), eventsPtr));\n+            if (!status.isOK()) {\n+                System.out.println(\"failed to wait for events \" + status);\n+            }\n+            resetEventc();\n+        }\n+    }\n+\n+    public int blockInt() {\n+        return alwaysBlock ? opencl_h.CL_TRUE() : opencl_h.CL_FALSE();\n+    }\n+\n+    public record ClMemPtr(MemorySegment ptr) implements Wrap.Ptr {\n+        public static ClMemPtr of(Arena arena, MemorySegment clmem){\n+            return new ClMemPtr(arena.allocateFrom(AddressLayout.ADDRESS,clmem));\n+        }\n+        MemorySegment get(){\n+            return ptr.get(ValueLayout.ADDRESS,0);\n+        }\n+        @Override\n+        public long sizeof() {\n+            return AddressLayout.ADDRESS.byteSize();\n+        }\n+    }\n+    public static class MemorySegmentState {\n+        public final MemorySegment memorySegment;\n+        public ClMemPtr clMemPtr;\n+        public boolean copyToDevice;\n+        public boolean copyFromDevice;\n+\n+        MemorySegmentState(MemorySegment memorySegment) {\n+            this.memorySegment = memorySegment;\n+            this.copyToDevice = true;\n+            this.copyFromDevice = true;\n+        }\n+    }\n+\n+    final int maxEvents;\n+    private int eventc;\n+    final MemorySegment eventsPtr;\n+    final boolean alwaysBlock;\n+    final Arena arena;\n+\n+    public ComputeContext(Arena arena, int maxEvents) {\n+        this.arena = arena;\n+        this.maxEvents = maxEvents;\n+        this.eventc = 0;\n+        this.eventsPtr = arena.allocate(opencl_h.cl_event, maxEvents);\n+        this.alwaysBlock = false;\n+    }\n+\n+    private final Map<MemorySegment, MemorySegmentState> memorySegmentToStateMap = new HashMap<>();\n+}\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/ComputeContext.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.clwrap;\n+\n+import wrap.Wrap;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+\n+public class Squares {\n+\n+\n+    public static void main(String[] args) throws IOException {\n+        try (var arena = Arena.ofConfined()) {\n+            CLPlatform.CLDevice[] selectedDevice = new CLPlatform.CLDevice[1];\n+            CLPlatform.platforms(arena).forEach(platform -> {\n+                System.out.println(\"Platform Name \" + platform.platformName());\n+                platform.devices.forEach(device -> {\n+                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                    System.out.println(\"   Device Name       \" + device.deviceName());\n+                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+                    selectedDevice[0] = device;\n+                });\n+            });\n+            var context = selectedDevice[0].createContext();\n+            var program = context.buildProgram(\"\"\"\n+                    __kernel void squares(__global int* in,__global int* out ){\n+                        int gid = get_global_id(0);\n+                        out[gid] = in[gid]*in[gid];\n+                    }\n+                    \"\"\");\n+            var kernel = program.getKernel(\"squares\");\n+            var in = Wrap.IntArr.of(arena,512);\n+            var out = Wrap.IntArr.of(arena,512);\n+            for (int i = 0; i < 512; i++) {\n+                in.set(i,i);\n+            }\n+            ComputeContext computeContext = new ComputeContext(arena,20);\n+            var inMem = computeContext.register(in.ptr());\n+            var outMem = computeContext.register(out.ptr());\n+\n+            kernel.run(computeContext,512, inMem, outMem);\n+            for (int i = 0; i < 512; i++) {\n+                System.out.println(i + \" \" + out.get(i));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/Squares.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static opengl.opengl_h.*;\n+\n+public class Fonts {\n+    static class FontsWindow extends GLWindow {\n+        public FontsWindow( Arena arena, int width, int height, String name, int mode, GLTexture... textures) {\n+            super( arena, width, height, name, mode, textures);\n+        }\n+\n+        @Override\n+        public void reshape(int w, int h) {\n+            width = w;\n+            height = h;\n+            System.out.println(\"reshaped \" + w + \", \" + h);\n+            double size;\n+            double aspect;\n+            glViewport(0, 0, w, h);\n+            glMatrixMode(GL_PROJECTION());\n+            glLoadIdentity();\n+            size = (double) ((w >= h) ? w : h) \/ 2.0;\n+            if (w <= h) {\n+                aspect = (double) h \/ (double) w;\n+                glOrtho(-size, size, -size * aspect, size * aspect, -100000.0, 100000.0);\n+            } else {\n+                aspect = (double) w \/ (double) h;\n+                glOrtho(-size * aspect, size * aspect, -size, size, -100000.0, 100000.0);\n+            }\n+            glScaled(aspect, aspect, 1.0);\n+            glMatrixMode(GL_MODELVIEW());\n+        }\n+\n+        @Override\n+        public void display() {\n+            glClearColor(0f, 0f, 0f, 0f);\n+            glPushMatrix1(() -> {\n+                float x = -225.0f;\n+                float y = 70.0f;\n+                float ystep = 10.0f;\n+                boolean stroke = true;\n+                if (stroke) {\n+                    float stroke_scale = 0.2f;\n+                    glTranslatef(x, y, 0.0f);\n+                    MemorySegment font = glutStrokeRoman$segment();\n+                    for (int j = 0; j < 4; j++) {\n+                        glPushMatrix1(() -> {\n+                            glScalef(stroke_scale, stroke_scale, stroke_scale);\n+                            for (int c : \"This text stroked\".getBytes()) {\n+                                glutStrokeCharacter(font, c);\n+                            }\n+                        });\n+                        glTranslatef(0f, -ystep * 10 + j, 0.0f);\n+                    }\n+                } else {\n+                    glColor3f(0.0f, 1.0f, 0.0f);\n+                    var font = glutBitmapTimesRoman24$segment();\n+                    for (int j = 0; j < 4; j++) {\n+                        glRasterPos2f(10f, 10f + ystep * j * 10);\n+                        for (int c : \"This text \".getBytes()) {\n+                            glutBitmapCharacter(font, c);\n+                        }\n+                    }\n+                }\n+            });\n+            glutSwapBuffers();\n+        }\n+\n+\n+        @Override\n+        public void onIdle() {\n+            super.onIdle();\n+        }\n+    }\n+    public static void main(String[] args) throws IOException {\n+\n+        try (var arena = Arena.ofConfined()) {\n+       \/\/     var particleTexture = new GLTexture(arena, Fonts.class.getResourceAsStream(\"\/particle.png\"));\n+\n+            new FontsWindow( arena, 1000, 1000, \"Fonts\", GLUT_RGB() | GLUT_DOUBLE() \/*particleTexture  particleTexture *\/).bindEvents().mainLoop();\n+        }\n+    }\n+}\n+\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/Fonts.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+import java.lang.foreign.Arena;\n+\n+import static opengl.opengl_h.*;\n+\n+\n+public  class GLCallbackEventHandler implements GLEventHandler {\n+    @Override\n+    public void addEvents(Arena arena,GLWindow glWindow) {\n+        glutDisplayFunc(opengl.glutDisplayFunc$callback.allocate(glWindow::display, arena));\n+        glutIdleFunc(opengl.glutIdleFunc$callback.allocate(glWindow::onIdle, arena));\n+\n+        glutKeyboardFunc(opengl.glutKeyboardFunc$callback.allocate(glWindow::keyboard, arena));\n+        glutMouseFunc(opengl.glutMouseFunc$callback.allocate(glWindow::mouse, arena));\n+        glutMotionFunc(opengl.glutMotionFunc$callback.allocate(glWindow::mouseMotion, arena));\n+        glutPassiveMotionFunc(opengl.glutPassiveMotionFunc$callback.allocate(glWindow::mousePassiveMotion, arena));\n+\n+    }\n+}\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLCallbackEventHandler.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+import java.lang.foreign.Arena;\n+\n+\n+public interface  GLEventHandler  {\n+\n+    void addEvents(Arena arena, GLWindow glWindow);\n+}\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLEventHandler.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+import opengl.glutDisplayFunc$func;\n+import opengl.glutIdleFunc$func;\n+import opengl.glutKeyboardFunc$func;\n+import opengl.glutMotionFunc$func;\n+import opengl.glutMouseFunc$func;\n+import opengl.glutPassiveMotionFunc$func;\n+import opengl.glutReshapeFunc$func;\n+\n+import java.lang.foreign.Arena;\n+\n+import static opengl.opengl_h.glutDisplayFunc;\n+import static opengl.opengl_h.glutIdleFunc;\n+import static opengl.opengl_h.glutKeyboardFunc;\n+import static opengl.opengl_h.glutMotionFunc;\n+import static opengl.opengl_h.glutMouseFunc;\n+import static opengl.opengl_h.glutPassiveMotionFunc;\n+import static opengl.opengl_h.glutReshapeFunc;\n+\n+\n+public  class GLFuncEventHandler implements GLEventHandler {\n+    @Override\n+    public void addEvents(Arena arena, GLWindow glWindow) {\n+        glutReshapeFunc(glutReshapeFunc$func.allocate(glWindow::reshape, arena));\n+        glutDisplayFunc(glutDisplayFunc$func.allocate(glWindow::display, arena));\n+        glutIdleFunc(glutIdleFunc$func.allocate(glWindow::onIdle, arena));\n+        glutKeyboardFunc(glutKeyboardFunc$func.allocate(glWindow::keyboard, arena));\n+        glutMouseFunc(glutMouseFunc$func.allocate(glWindow::mouse, arena));\n+        glutMotionFunc(glutMotionFunc$func.allocate(glWindow::mouseMotion, arena));\n+        glutPassiveMotionFunc(glutPassiveMotionFunc$func.allocate(glWindow::mousePassiveMotion, arena));\n+\n+    }\n+}\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLFuncEventHandler.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opengl.opengl_h.*;\n+\n+\n+public record GLStatusPtr(MemorySegment ptr) {\n+    public static GLStatusPtr of(Arena arena) {\n+        return new GLStatusPtr(arena.allocateFrom(JAVA_INT, GL_TRUE()));\n+    }\n+\n+    public int set(int value) {\n+        ptr.set(JAVA_INT, 0, value);\n+        return value;\n+    }\n+\n+    public int get() {\n+        return ptr.get(JAVA_INT, 0);\n+    }\n+\n+    public boolean isOK() {\n+        return get() == GL_TRUE();\n+    }\n+\n+    public long sizeof() {\n+        return JAVA_INT.byteSize();\n+    }\n+}\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLStatusPtr.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferByte;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+\n+public class GLTexture {\n+    public final Arena arena;\n+    public final MemorySegment data;\n+    public final int width;\n+    public final int height;\n+    public int idx;\n+\n+    public GLTexture(Arena arena, InputStream textureStream) {\n+        this.arena = arena;\n+        BufferedImage img = null;\n+        try {\n+            img = ImageIO.read(textureStream);\n+            this.width = img.getWidth();\n+            this.height = img.getHeight();\n+            BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_4BYTE_ABGR_PRE);\n+            image.getGraphics().drawImage(img, 0, 0, null);\n+            var raster = image.getRaster();\n+            var dataBuffer = raster.getDataBuffer();\n+            data = arena.allocateFrom(ValueLayout.JAVA_BYTE, ((DataBufferByte) dataBuffer).getData());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLTexture.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap.glwrap;\n+\n+\n+import wrap.ArenaHolder;\n+import wrap.Wrap;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+\n+import static java.lang.foreign.MemorySegment.NULL;\n+import static opengl.opengl_h.*;\n+\n+public abstract class GLWindow implements ArenaHolder {\n+\n+    public record key(byte key, int x, int y) {\n+        @Override\n+        public String toString() {\n+            return \"keyboard: \" + key + \" x: \" + x + \" y: \" + y;\n+        }\n+    }\n+\n+    public record mouse(int button, int state, int x, int y) {\n+        @Override\n+        public String toString() {\n+            return \"mouse: \" + button + \" state: \" + state + \" x: \" + x + \" y: \" + y;\n+        }\n+    }\n+\n+    public record mouseMotion(int x, int y) {\n+        @Override\n+        public String toString() {\n+            return \"mouse motion:  x: \" + x + \" y: \" + y;\n+        }\n+    }\n+\n+    public record mousePassiveMotion(int x, int y) {\n+        @Override\n+        public String toString() {\n+            return \"mouse passive motion:  x: \" + x + \" y: \" + y;\n+        }\n+    }\n+\n+    protected key lastKey = null;\n+    protected mouse lastMouse = null;\n+    protected mouseMotion lastMouseMotion = null;\n+    protected mousePassiveMotion lastPassiveMouseMotion;\n+\n+    public void keyboard(byte key, int x, int y) {\n+        lastKey = new key(key, x, y);\n+        \/\/ System.out.println(lastKey);\n+    }\n+\n+    public void mouse(int button, int state, int x, int y) {\n+        lastMouse = new mouse(button, state, x, y);\n+        \/\/   System.out.println(lastMouse);\n+    }\n+\n+    public void mouseMotion(int x, int y) {\n+        lastMouseMotion = new mouseMotion(x, y);\n+        \/\/  System.out.println(lastMouseMotion);\n+    }\n+\n+    public void mousePassiveMotion(int x, int y) {\n+        lastPassiveMouseMotion = new mousePassiveMotion(x, y);\n+        \/\/  System.out.println(lastPassiveMouseMotion);\n+    }\n+\n+    public Arena arena;\n+    @Override public Arena arena(){\n+        return arena;\n+    }\n+    public int width;\n+    public int height;\n+    public String name;\n+    public GLTexture[] textures;\n+    public Wrap.IntArr textureBuf;\n+\n+\n+\n+    public GLWindow( Arena arena, int width, int height, String name, int mode,\n+                    GLTexture... textures) {\n+        this.arena = arena;\n+        this.width = width;\n+        this.height = height;\n+        this.name = name;\n+        this.textures = textures;\n+\n+        var useLighting = false;\n+\n+        var argc = intPtr(0);\n+        var argv = ptrArr( NULL);\n+        glutInit(argc.ptr(), argv.ptr());\n+        glutInitDisplayMode(mode);\n+        glutInitWindowSize(width, height);\n+        var windowName = cstr(name);\n+        glutCreateWindow(windowName.ptr());\n+        System.out.println(\"GL_VENDOR                    : \"+ cstr(glGetString(GL_VENDOR())));\n+        System.out.println(\"GL_RENDERER                  : \"+ cstr(glGetString(GL_RENDERER())));\n+        System.out.println(\"GL_VERSION                   : \"+ cstr(glGetString(GL_VERSION())));\n+        System.out.println(\"GL_SHADING_LANGUAGE_VERSION  : \"+ cstr(glGetString(GL_SHADING_LANGUAGE_VERSION())));\n+\n+\n+        glShadeModel(GL_SMOOTH());\n+        glEnable(GL_BLEND());\n+        glBlendFunc(GL_SRC_ALPHA(), GL_ONE());\n+\n+        if (textures != null && textures.length > 0 && textures[0] != null) {\n+            \/\/  glEnable(GL_TEXTURE_2D());\n+            textureBuf = ofInts(textures.length);\n+            glGenTextures(textures.length, textureBuf.ptr());\n+            int[] count = {0};\n+            Arrays.stream(textures).forEach(texture -> {\n+                texture.idx = count[0]++;\n+                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(texture.idx));\n+                glTexImage2D(GL_TEXTURE_2D(), 0, GL_RGBA(), texture.width,\n+                        texture.height, 0, GL_RGBA(), GL_UNSIGNED_BYTE(), texture.data);\n+                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MAG_FILTER(), GL_LINEAR());\n+                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MIN_FILTER(), GL_NEAREST());\n+            });\n+        }\n+\n+        \/\/ Setup Lighting see  https:\/\/www.khronos.org\/opengl\/wiki\/How_lighting_works\n+\n+        if (useLighting) {\n+            glEnable(GL_LIGHTING());\n+            var light = GL_LIGHT0(); \/\/ .... LIGHT_0 .. -> 7\n+            glLightfv(light, GL_POSITION(), ofFloats(0.0f, 15.0f, -15.0f, 0).ptr());\n+            glLightfv(light, GL_AMBIENT(), ofFloats(1f, 0.0f, 0.0f, 0.0f).ptr());\n+            glLightfv(light, GL_DIFFUSE(), ofFloats(1f, 1f, 1f, 0.0f).ptr());\n+            glLightfv(light, GL_SPECULAR(), ofFloats(1.0f, 1.0f, 0.0f, 0.0f).ptr());\n+\n+            var shini = floatPtr(113);\n+            glMaterialfv(GL_FRONT(), GL_SHININESS(), shini.ptr());\n+\n+            var useColorMaterials = false;\n+            if (useColorMaterials) {\n+                glEnable(GL_COLOR_MATERIAL());\n+            } else {\n+                glDisable(GL_COLOR_MATERIAL());\n+            }\n+            glEnable(light);\n+            glEnable(GL_DEPTH_TEST());\n+        } else {\n+            glDisable(GL_LIGHTING());\n+        }\n+\n+\n+    }\n+\n+    public GLWindow bindEvents(String... eventHandleClassNames){\n+        for (String eventHandleClassName : eventHandleClassNames) {\n+            try {\n+                var clazz = Class.forName(eventHandleClassName);\n+                if (clazz.getDeclaredConstructor().newInstance() instanceof GLEventHandler handler){\n+                    handler.addEvents(arena(),this);\n+                }\n+\n+            } catch (ClassNotFoundException | InvocationTargetException\n+                     | InstantiationException | IllegalAccessException |\n+                     NoSuchMethodException e) {\n+                \/\/ ok\n+            }\n+\n+        }\n+        return this;\n+\n+    }\n+    public GLWindow bindEvents(){\n+        return bindEvents(\n+                \"wrap.glwrap.GLCallbackEventHandler\",\n+                \"wrap.glwrap.GLFuncEventHandler\"\n+        );\n+    }\n+\n+\n+    public void glQuads(Runnable r) {\n+        glBegin(GL_QUADS());\n+        r.run();\n+        glEnd();\n+    }\n+\n+    public void glPushMatrix1( Runnable r) {\n+        glPushMatrix();\n+        r.run();\n+        glPopMatrix();\n+    }\n+\n+    public abstract void display();\n+\n+    public  void reshape(int w, int h){}\n+\n+    public void onIdle() {\n+        glutPostRedisplay();\n+    }\n+\n+    public void mainLoop() {\n+        glutMainLoop();\n+    }\n+\n+\n+}\n","filename":"hat\/wrap\/glwrap\/src\/main\/java\/wrap\/glwrap\/GLWindow.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+public interface ArenaHolder {\n+    public static ArenaHolder wrap(Arena arena) {\n+        return ()-> arena;\n+    }\n+\n+    Arena arena();\n+\n+    default Wrap.IntPtr intPtr(int value){\n+        return Wrap.IntPtr.of(arena(), value);\n+    }\n+    default Wrap.LongPtr longPtr(long value){\n+        return Wrap.LongPtr.of(arena(), value);\n+    }\n+    default Wrap.FloatPtr floatPtr(float value){\n+        return Wrap.FloatPtr.of(arena(), value);\n+    }\n+    default Wrap.IntArr ofInts(int ...values){\n+        return  Wrap.IntArr.of(arena(), values);\n+    }\n+    default Wrap.FloatArr ofFloats(float ...values){\n+        return  Wrap.FloatArr.of(arena(), values);\n+    }\n+    default Wrap.CStrPtr cstr(MemorySegment segment){\n+        return Wrap.CStrPtr.of( segment);\n+    }\n+\n+    default Wrap.CStrPtr cstr(String s){\n+        return Wrap.CStrPtr.of(arena(), s);\n+    }\n+    default Wrap.CStrPtr cstr(long size){\n+        return Wrap.CStrPtr.of(arena(), (int)size);\n+    }\n+    default Wrap.CStrPtr cstr(int size){\n+        return Wrap.CStrPtr.of(arena(), size);\n+    }\n+    default Wrap.PtrArr ptrArr(MemorySegment ... memorySegments) {\n+        return Wrap.PtrArr.of(arena(), memorySegments);\n+    }\n+    default Wrap.PtrArr ptrArr(Wrap.Ptr ...ptrs) {\n+        return Wrap.PtrArr.of(arena(), ptrs);\n+    }\n+    default Wrap.PtrArr ptrArr(int len) {\n+        return Wrap.PtrArr.of(arena(), len);\n+    }\n+\n+    default Wrap.PtrArr ptrArr(String ...strings) {\n+        return Wrap.PtrArr.of(arena(), strings);\n+    }\n+}\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/ArenaHolder.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.MemoryLayout.structLayout;\n+import static java.lang.foreign.MemoryLayout.unionLayout;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n+public class LayoutBuilder {\n+    \/\/String name;\n+    List<MemoryLayout> layouts = new ArrayList<>();\n+\n+    \/\/ final public MemoryLayout memoryLayout;\n+    LayoutBuilder() {\n+        \/\/this.memoryLayout = memoryLayout;\n+    }\n+\n+    LayoutBuilder struct(String name, Consumer<LayoutBuilder> consumer) {\n+        LayoutBuilder lb = new LayoutBuilder();\n+        consumer.accept(lb);\n+        MemoryLayout layout = structLayout(lb.layouts.toArray(new MemoryLayout[0]));\n+        if (name != null) {\n+            layout.withName(name);\n+        }\n+        layouts.add(layout);\n+        return this;\n+    }\n+\n+    LayoutBuilder union(String name, Consumer<LayoutBuilder> consumer) {\n+        LayoutBuilder lb = new LayoutBuilder();\n+        consumer.accept(lb);\n+        MemoryLayout layout = unionLayout(lb.layouts.toArray(new MemoryLayout[0]));\n+        if (name != null) {\n+            layout.withName(name);\n+        }\n+        layouts.add(layout);\n+        return this;\n+    }\n+\n+    public LayoutBuilder i32(String name) {\n+        layouts.add(JAVA_INT.withName(name));\n+        return this;\n+    }\n+    public LayoutBuilder i64(String name) {\n+        layouts.add(JAVA_LONG.withName(name));\n+        return this;\n+    }\n+\n+    public MemoryLayout memoryLayout(){\n+        return layouts.getFirst();\n+    }\n+\n+    public LayoutBuilder i8Seq(String name, long elementCount) {\n+        layouts.add(MemoryLayout.sequenceLayout(elementCount, ValueLayout.JAVA_BYTE).withName(name));\n+        return this;\n+    }\n+    public static LayoutBuilder structBuilder(String name, Consumer<LayoutBuilder> consumer) {\n+        return new LayoutBuilder().struct(name, consumer);\n+    }\n+    public static GroupLayout structOf(String name, Consumer<LayoutBuilder> consumer) {\n+        return (GroupLayout) structBuilder(name, consumer).memoryLayout();\n+    }\n+}\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/LayoutBuilder.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.VarHandle;\n+\n+public record Scalar(String name, MemorySegment memorySegment,\n+                     VarHandle varHandle) {\n+\n+    public static Scalar of(MemorySegment memorySegment, MemoryLayout memoryLayout, String name) {\n+        return of(memorySegment, memoryLayout, MemoryLayout.PathElement.groupElement(name));\n+    }\n+\n+    public static Scalar of(MemorySegment memorySegment, MemoryLayout memoryLayout, String name, Object initial) {\n+        return of(memorySegment, memoryLayout, name).set(initial);\n+    }\n+\n+    public static Scalar of(MemorySegment memorySegment, MemoryLayout memoryLayout,\n+                            MemoryLayout.PathElement... pathElements) {\n+        VarHandle vh = memoryLayout.varHandle(pathElements);\n+        String name = null;\n+        for (int i = 0; i < pathElements.length; i++) {\n+            MemoryLayout.PathElement pathElement = pathElements[i];\n+            \/\/ Why can't I access LayoutPath?\n+            if (pathElement.toString().isEmpty()) {\n+                name = pathElement.toString();\n+            }\n+        }\n+        return new Scalar(name, memorySegment, vh);\n+\n+    }\n+\n+    public Scalar set(Object o) {\n+        varHandle.set(memorySegment, 0, o);\n+        return this;\n+    }\n+\n+    public Object get() {\n+        return varHandle.get(memorySegment, 0);\n+    }\n+\n+    public int i32() {\n+        return (int) get();\n+    }\n+\n+    public long i64() {\n+        return (long) get();\n+    }\n+\n+    public float f32() {\n+        return (float) get();\n+    }\n+\n+    public double f64() {\n+        return (double) get();\n+    }\n+}\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/Scalar.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.VarHandle;\n+\n+public record Sequence(String name, MemorySegment memorySegment,\n+                VarHandle varHandle) {\n+\n+    public static Sequence of(MemorySegment memorySegment, MemoryLayout memoryLayout, String name) {\n+        return of(memorySegment, memoryLayout,\n+                MemoryLayout.PathElement.groupElement(name), MemoryLayout.PathElement.sequenceElement());\n+    }\n+\n+    public static Sequence of(MemorySegment memorySegment, MemoryLayout memoryLayout,\n+                              MemoryLayout.PathElement... pathElements) {\n+        VarHandle vh = memoryLayout.varHandle(pathElements);\n+        String name = null;\n+        for (int i = 0; i < pathElements.length; i++) {\n+            MemoryLayout.PathElement pathElement = pathElements[i];\n+            \/\/ Why can't I access LayoutPath?\n+            if (pathElement.toString().isEmpty()) {\n+                name = pathElement.toString();\n+            }\n+        }\n+        return new Sequence(name, memorySegment, vh);\n+\n+    }\n+\n+    public Object get(int idx) {\n+        return varHandle.get(memorySegment, 0, (long) idx);\n+    }\n+\n+    public byte i8(int idx) {\n+        return (byte) get(idx);\n+    }\n+\n+    public short i16(int idx) {\n+        return (short) get(idx);\n+    }\n+\n+    public int i32(int idx) {\n+        return (int) get(idx);\n+    }\n+\n+    public long i64(int idx) {\n+        return (long) get(idx);\n+    }\n+\n+    public float f32(int idx) {\n+        return (float) get(idx);\n+    }\n+\n+    public double f64(int idx) {\n+        return (double) get(idx);\n+    }\n+\n+    public Sequence set(int idx, byte v) {\n+        varHandle.set(memorySegment, 0, (long) idx, v);\n+        return this;\n+    }\n+}\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/Sequence.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,353 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package wrap;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n+public class Wrap {\n+    public interface Ptr{\n+        MemorySegment ptr();\n+        long sizeof();\n+    }\n+    public interface Arr extends Ptr{\n+        default long length(){\n+            return sizeof()\/elementSize();\n+        }\n+        long elementSize();\n+    }\n+    public  record IntPtr(MemorySegment ptr) implements Ptr {\n+        public static IntPtr of(Arena arena, int value) {\n+            return new IntPtr(arena.allocateFrom(JAVA_INT, value));\n+        }\n+\n+        public int set(int value) {\n+            ptr.set(JAVA_INT, 0, value);\n+            return value;\n+        }\n+\n+        public int get() {\n+            return ptr.get(JAVA_INT, 0);\n+        }\n+\n+        @Override public long sizeof(){\n+            return JAVA_INT.byteSize();\n+        }\n+    }\n+\n+    public  record LongPtr(MemorySegment ptr)  implements Ptr{\n+        public static LongPtr of(Arena arena, long value) {\n+            return new LongPtr(arena.allocateFrom(JAVA_LONG, value));\n+        }\n+\n+        public long set(long value) {\n+            ptr.set(JAVA_LONG, 0, value);\n+            return value;\n+        }\n+\n+        public long get() {\n+            return ptr.get(JAVA_LONG, 0);\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return JAVA_LONG.byteSize();\n+        }\n+    }\n+\n+    public  record PtrArr(MemorySegment ptr)  implements Arr{\n+        public static PtrArr of(Arena arena, int size) {\n+            return new PtrArr(arena.allocate(ADDRESS, size));\n+        }\n+        public static PtrArr of(Arena arena, MemorySegment ...memorySegments) {\n+            var ptrArray=  new PtrArr(arena.allocate(ADDRESS, memorySegments.length));\n+            for (int i = 0; i < memorySegments.length; i++) {\n+                ptrArray.set(i, memorySegments[i]);\n+            }\n+            return ptrArray;\n+        }\n+\n+        public static PtrArr of(Arena arena, Ptr ...ptrs) {\n+            var ptrArray=  new PtrArr(arena.allocate(ADDRESS, ptrs.length));\n+            for (int i = 0; i < ptrs.length; i++) {\n+                ptrArray.set(i, ptrs[i].ptr());\n+            }\n+            return ptrArray;\n+        }\n+        public static PtrArr of(Arena arena, String ...strings) {\n+            var ptrArray=  new PtrArr(arena.allocate(ADDRESS, strings.length));\n+            for (int i = 0; i < strings.length; i++) {\n+                ptrArray.set(i, CStrPtr.of(arena,strings[i]).ptr());\n+            }\n+            return ptrArray;\n+        }\n+\n+\n+        public MemorySegment set(int idx, MemorySegment value) {\n+            ptr.set(AddressLayout.ADDRESS, idx* ADDRESS.byteSize(), value);\n+            return value;\n+        }\n+\n+        public MemorySegment get(int idx) {\n+            return ptr.get(AddressLayout.ADDRESS, idx* ADDRESS.byteSize());\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return ptr.byteSize();\n+        }\n+        @Override public  long elementSize(){\n+            return AddressLayout.ADDRESS.byteSize();\n+        }\n+    }\n+\n+    public  record CStrPtr(MemorySegment ptr, int len)  implements Ptr{\n+        public static CStrPtr of(Arena arena, int len) {\n+            return new CStrPtr(arena.allocate(JAVA_BYTE, len), len);\n+        }\n+        public static CStrPtr of(Arena arena, String str) {\n+            return new CStrPtr(arena.allocateFrom( str), str.length());\n+        }\n+        public static CStrPtr of( MemorySegment str) {\n+            return new CStrPtr(str, (int)str.byteSize());\n+        }\n+\n+        public String get() {\n+            return ptr.getString(0);\n+        }\n+        @Override\n+        public long sizeof(){\n+            return JAVA_BYTE.byteSize();\n+        }\n+\n+        @Override public String toString(){\n+            return get();\n+        }\n+    }\n+\n+    public record FloatPtr(MemorySegment ptr)  implements Ptr{\n+        public static FloatPtr of(Arena arena, float value) {\n+            return new FloatPtr(arena.allocateFrom(JAVA_FLOAT, value));\n+        }\n+\n+        public float set(float value) {\n+            ptr.set(JAVA_FLOAT, 0, value);\n+            return value;\n+        }\n+\n+        public float get() {\n+            return ptr.get(JAVA_FLOAT, 0);\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return JAVA_FLOAT.byteSize();\n+        }\n+    }\n+\n+    public record FloatArr(MemorySegment ptr)  implements Arr{\n+        public static FloatArr of(Arena arena, int length) {\n+            return new FloatArr(arena.allocate(JAVA_FLOAT, length));\n+        }\n+        public static FloatArr of(Arena arena, float[] floats) {\n+            return new FloatArr(arena.allocateFrom(JAVA_FLOAT, floats));\n+        }\n+\n+        public float set(int idx, float value) {\n+            ptr.set(JAVA_FLOAT, idx*JAVA_FLOAT.byteSize(), value);\n+            return value;\n+        }\n+\n+        public float get(int idx) {\n+            return ptr.get(JAVA_FLOAT, JAVA_FLOAT.byteSize()*idx);\n+        }\n+\n+\n+        @Override public  long elementSize(){\n+            return JAVA_FLOAT.byteSize();\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return ptr.byteSize();\n+        }\n+    }\n+\n+    public record IntArr(MemorySegment ptr)  implements Arr{\n+        public static IntArr of(Arena arena, int length) {\n+            return new IntArr(arena.allocate(JAVA_INT, length));\n+        }\n+        public static IntArr ofValues(Arena arena, int ...values ) {\n+            return of(arena, values);\n+        }\n+        public static IntArr of(Arena arena, int[] floats) {\n+            return new IntArr(arena.allocateFrom(JAVA_INT, floats));\n+        }\n+\n+        public int set(int idx, int value) {\n+            ptr.set(JAVA_INT, idx*JAVA_INT.byteSize(), value);\n+            return value;\n+        }\n+\n+        public int get(int idx) {\n+            return ptr.get(JAVA_INT, JAVA_INT.byteSize()*idx);\n+        }\n+\n+        @Override public  long elementSize(){\n+            return JAVA_INT.byteSize();\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return ptr.byteSize();\n+        }\n+    }\n+\n+    public record Float4Arr(MemorySegment ptr)  implements Arr{\n+        public record float4(float x, float y, float z, float w ) {\n+            public static float4 of(float x, float y, float z, float w) {\n+                return new float4(x, y, z, w);\n+            }\n+            static public  final float4 zero = new float4(0.f, 0.f, 0.f, 0.f);\n+            public static float4 of() {\n+                return zero;\n+            }\n+            public float4 sub(float4 rhs){\n+                return of(x-rhs.x,y-rhs.y,z-rhs.z,w-rhs.w);\n+            }\n+            public float4 add(float4 rhs){\n+                return of(x+rhs.x,y+rhs.y,z+rhs.z,w+rhs.w);\n+            }\n+\n+            public float4 mul(float rhs) {\n+                return of(x*rhs,y*rhs,z*rhs,w*rhs);\n+            }\n+            public float4 mul(float4 rhs) {\n+                return of(x* rhs.x,y* rhs.y,z* rhs.z,w*rhs.w);\n+            }\n+        }\n+\n+\n+        public static Float4Arr of(Arena arena, int length) {\n+            return new Float4Arr(arena.allocate(JAVA_FLOAT, length*JAVA_FLOAT.byteSize()));\n+        }\n+        public static Float4Arr of(Arena arena, float[] floats) {\n+            return new Float4Arr(arena.allocateFrom(JAVA_FLOAT, floats));\n+        }\n+\n+        public float4 get(int idx){\n+            return float4.of(\n+                    ptr.get(JAVA_FLOAT, elementSize()*idx),\n+                    ptr.get(JAVA_FLOAT, elementSize()*idx+JAVA_FLOAT.byteSize()),\n+                    ptr.get(JAVA_FLOAT, elementSize()*idx+JAVA_FLOAT.byteSize()*2),\n+                    ptr.get(JAVA_FLOAT, elementSize()*idx+JAVA_FLOAT.byteSize()*3));\n+\n+        }\n+        public void set(int idx, float4 f4) {\n+            ptr.set(JAVA_FLOAT, idx*elementSize(), f4.x());\n+            ptr.set(JAVA_FLOAT, idx*elementSize()+JAVA_FLOAT.byteSize(), f4.y());\n+            ptr.set(JAVA_FLOAT, idx*elementSize()+JAVA_FLOAT.byteSize()*2, f4.z());\n+            ptr.set(JAVA_FLOAT, idx*elementSize()+JAVA_FLOAT.byteSize()*3, f4.w());\n+        }\n+        public float setx(int idx, float value) {\n+            ptr.set(JAVA_FLOAT, idx*elementSize(), value);\n+            return value;\n+        }\n+        public float sety(int idx, float value) {\n+            ptr.set(JAVA_FLOAT, idx*elementSize()+JAVA_FLOAT.byteSize(), value);\n+            return value;\n+        }\n+        public float setz(int idx, float value) {\n+            ptr.set(JAVA_FLOAT, idx*elementSize()+JAVA_FLOAT.byteSize()*2, value);\n+            return value;\n+        }\n+        public float setw(int idx, float value) {\n+            ptr.set(JAVA_FLOAT, idx*elementSize()+JAVA_FLOAT.byteSize()*3, value);\n+            return value;\n+        }\n+\n+        public float getx(int idx) {\n+            return ptr.get(JAVA_FLOAT, elementSize()*idx);\n+        }\n+        public float gety(int idx) {\n+            return ptr.get(JAVA_FLOAT, elementSize()*idx+JAVA_FLOAT.byteSize());\n+        }\n+        public float getz(int idx) {\n+            return ptr.get(JAVA_FLOAT, elementSize()*idx+JAVA_FLOAT.byteSize()*2);\n+        }\n+        public float getw(int idx) {\n+            return ptr.get(JAVA_FLOAT, elementSize()*idx+JAVA_FLOAT.byteSize()*3);\n+        }\n+\n+        @Override public  long elementSize(){\n+            return JAVA_FLOAT.byteSize()*4;\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return ptr.byteSize();\n+        }\n+    }\n+\n+    public static void dump(MemorySegment s, int bytes){\n+        char[] chars = new char[16];\n+        boolean end=false;\n+        for (int i = 0; !end && i < bytes; i++) {\n+            int signed = s.get(ValueLayout.JAVA_BYTE, i);\n+            int unsigned =  ((signed<0)?signed+256:signed)&0xff;\n+            chars[i%16] = (char)unsigned;\n+\n+            System.out.printf(\"%02x \", unsigned);\n+            if (unsigned == 0){\n+                end=true;\n+            }\n+            if (i>0 && i%16==0){\n+                System.out.print(\" | \");\n+                for (int c=0; c<16; c++){\n+                    if (chars[c]<32){\n+                        System.out.print(switch (chars[c]){\n+                            case '\\0'->\"\\\\0\";\n+                            case '\\n'->\"\\\\n\";\n+                            case '\\r'->\"\\\\r\";\n+                            default -> chars[c]+\"\";\n+                        });\n+\n+                    }else {\n+                        System.out.print(chars[c]);\n+                    }\n+                }\n+                System.out.println();\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/Wrap.java","additions":353,"deletions":0,"binary":false,"changes":353,"status":"added"}]}