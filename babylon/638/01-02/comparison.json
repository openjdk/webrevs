{"files":[{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package oracle.code.onnx.lift;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.lang.reflect.Method;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.SequencedMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeItem;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+import oracle.code.onnx.OnnxOperators;\n+import oracle.code.onnx.Tensor;\n+import oracle.code.onnx.ir.OnnxOp;\n+import oracle.code.onnx.ir.OnnxType;\n+import oracle.code.onnx.proto.OnnxModel;\n+\n+final class JavaTemplate {\n+\n+    private static final String WEIGHT_FIELD_TEMPLATE = \"\"\"\n+            final %s %s = load(\"%2$s\", %s%s);\n+        \"\"\";\n+\n+    private static final String TEMPLATE = \"\"\"\n+        import java.io.IOException;\n+        import java.io.RandomAccessFile;\n+        import foreign.Arena;\n+        import foreign.MemorySegment;\n+        import java.nio.channels.FileChannel;\n+        import jdk.incubator.code.CodeReflection;\n+        import oracle.code.onnx.Tensor;\n+\n+        import static Optional.*;\n+        import static oracle.code.onnx.OnnxOperators.*;\n+        import static oracle.code.onnx.Tensor.ElementType.*;\n+\n+        public class Model {\n+\n+            final Arena arena = Arena.ofAuto();\n+\n+            MemorySegment mmap(String pathname) {\n+                try (var f = new RandomAccessFile(pathname, \"r\")) {\n+                    return f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+\n+            <T> Tensor<T> load(String path, Tensor.ElementType type, long... shape) {\n+                return new Tensor<>(arena, mmap(path), type, shape);\n+            }\n+\n+        %s\n+            @CodeReflection\n+            public Object mainGraph(\n+        %s) {%s\n+            }\n+        }\n+        \"\"\";\n+\n+    static String toJava(OnnxLift.LiftedModelWrapper model) {\n+        Block entryBlock = model.func().bodies().getFirst().entryBlock();\n+        List<Block.Parameter> parameters = entryBlock.parameters();\n+        Function<CodeItem, String> namer = OnnxLift.namer(model.names());\n+        parameters.forEach(namer::apply); \/\/ initialize namer with all parameters first\n+\n+        return TEMPLATE.formatted(\n+                weightFields(namer, parameters, model.weights()),\n+                parameters(namer, parameters, model.weights()),\n+                body(namer, entryBlock.ops()));\n+    }\n+\n+    private static String weightFields(Function<CodeItem, String> namer, List<Block.Parameter> parameters, List<OnnxModel.TensorProto> weights) {\n+        StringBuilder out = new StringBuilder();\n+        List<jdk.incubator.code.Block.Parameter> weightParams = parameters.subList(parameters.size() - weights.size(), parameters.size());\n+        Map<String, oracle.code.onnx.proto.OnnxModel.TensorProto> wMap = weights.stream().collect(Collectors.toUnmodifiableMap(OnnxModel.TensorProto::name, Function.identity()));\n+        for (int i = 0; i < weightParams.size(); i++) {\n+            Block.Parameter wp = weightParams.get(i);\n+            OnnxModel.TensorProto w = wMap.get(namer.apply(wp));\n+            String name = OnnxLift.toJavaName(w.name());\n+            long[] dims = OnnxLift.joinLongArray(w.dims());\n+            out.append(WEIGHT_FIELD_TEMPLATE.formatted(toJavaType(wp.type()), name, Tensor.ElementType.fromOnnxId(w.dataType()).name(), dims.length > 0 ? (\", \" + longJoin(dims)) : \"\"));\n+        }\n+        return out.toString();\n+    }\n+\n+    private static String parameters(Function<CodeItem, String> namer, List<Block.Parameter> parameters, List<OnnxModel.TensorProto> weights) {\n+        StringBuilder out = new StringBuilder();\n+        int realParamsSize = parameters.size() - weights.size();\n+        for (int i = 0; i < realParamsSize; i++) {\n+            if (i > 0) {\n+                out.append(\",\\n\");\n+            }\n+            Block.Parameter param = parameters.get(i);\n+            out.append(\"            \").append(toJavaType(param.type())).append(' ').append(OnnxLift.toJavaName(namer.apply(param)));\n+        }\n+        return out.toString();\n+    }\n+\n+    private static String body(Function<CodeItem, String> namer, List<Op> ops) {\n+        StringBuilder out = new StringBuilder();\n+        for (jdk.incubator.code.Op op : ops) {\n+            if (!(op instanceof CoreOp.TupleLoadOp)) {\n+                \/\/ lazy tupple loads\n+                out.append(\"\\n        \");\n+                if (!op.resultType().equals(JavaType.VOID)) {\n+                    out.append(toJavaType(op.resultType())).append(' ').append(OnnxLift.toJavaName(namer.apply(op.result()))).append(\" = \");\n+                }\n+                switch (op) {\n+                    case OnnxOp oo -> {\n+                        String opName = op.externalizeOpName();\n+                        out.append(opName.substring(opName.lastIndexOf('.') + 1)).append('(');\n+                        OnnxOp.OnnxSchema schema = getSchema(oo);\n+                        SequencedMap<OnnxOp.OnnxParameter, Object> inputs = oo.onnxInputs();\n+                        boolean first = true;\n+                        for (OnnxOp.OnnxParameter oi : schema.inputs()) {\n+                            if (first) {\n+                                first = false;\n+                            } else {\n+                                out.append(\", \");\n+                            }\n+                            out.append(toJava(namer, inputs.get(oi)));\n+                        }\n+                        Map<String, Object> attrs = oo.onnxAttributes();\n+                        for (OnnxOp.OnnxAttribute oa : schema.attributes()) {\n+                            if (first) {\n+                                first = false;\n+                            } else {\n+                                out.append(\", \");\n+                            }\n+                            Object a = attrs.get(oa.name());\n+                            if (a == null) {\n+                                out.append(\"empty()\");\n+                            } else if (oa.isOptional()) {\n+                                out.append(\"of(\").append(toString(a)).append(')');\n+                            } else {\n+                                out.append(toString(a));\n+                            }\n+                        }\n+                        out.append(\");\");\n+                    }\n+                    case CoreOp.TupleOp to -> {\n+                        out.append(\"List.of(\");\n+                        boolean first = true;\n+                        for (jdk.incubator.code.Value te : to.operands()) {\n+                            if (first) {\n+                                first = false;\n+                            } else {\n+                                out.append(\", \");\n+                            }\n+                            out.append(toJava(namer, te));\n+                        }\n+                        out.append(\");\");\n+                    }\n+                    case CoreOp.ReturnOp ro -> {\n+                        out.append(\"return \").append(toJava(namer, ro.operands().getFirst())).append(';');\n+                    }\n+                    default -> throw new UnsupportedOperationException(op.toText());\n+                }\n+            } else {\n+                namer.apply(op.result());\n+            }\n+        }\n+        return out.toString();\n+    }\n+\n+    private static String toString(Object o) {\n+        return switch (o) {\n+            case long[] la -> newArray(la);\n+            case float[] fa -> newArray(fa);\n+            case Long l -> l.toString() + \"L\";\n+            case Float f -> f.toString() + \"F\";\n+            case String s -> \"\\\"\" + s + \"\\\"\";\n+            case Tensor t when t.shape().length == 0 && t.elementType() == Tensor.ElementType.BOOL -> \"Tensor.ofScalar(\" + t.data().get(ValueLayout.JAVA_BOOLEAN, 0) + \")\";\n+            case Tensor t when t.shape().length == 0 && t.elementType() == Tensor.ElementType.INT8 -> \"Tensor.ofScalar((byte)\" + t.data().get(ValueLayout.JAVA_BYTE, 0) + \")\";\n+            case Tensor t -> \"Tensor.ofShape(\" + toString(t.shape()) + \", \" + switch (t.elementType()) {\n+                case FLOAT -> toString(t.data().toArray(ValueLayout.JAVA_FLOAT));\n+                case INT64 -> toString(t.data().toArray(ValueLayout.JAVA_LONG));\n+                default -> \"HexFormat.of().parseHex(\\\"\" + HexFormat.of().formatHex(t.data().toArray(ValueLayout.JAVA_BYTE)) + \"\\\"), \" + t.elementType().name();\n+            } + \")\";\n+            default -> o.toString();\n+        };\n+    }\n+\n+    private static String newArray(long[] la) {\n+        for (long l : la) {\n+            if (l != 0l) {\n+                return \"new long[] {\" + longJoin(la) + \"}\";\n+            }\n+        }\n+        return \"new long[\" + la.length + \"]\";\n+    }\n+\n+    private static String longJoin(long[] la) {\n+        return LongStream.of(la).mapToObj(d -> String.valueOf(d) + \"L\").collect(Collectors.joining(\", \"));\n+    }\n+\n+    private static String newArray(float[] fa) {\n+        for (float f : fa) {\n+            if (f != 0f) {\n+                return IntStream.range(0, fa.length).mapToObj(i -> String.valueOf(fa[i]) + \"F\").collect(Collectors.joining(\", \", \"new float[] {\", \"}\"));\n+            }\n+        }\n+        return \"new float[\" + fa.length + \"]\";\n+    }\n+\n+    private static String tupleAccessor(Value tuple, int componentIndex) {\n+        if (tuple instanceof Op.Result or && or.op() instanceof OnnxOp oo) {\n+            String mName = oo.externalizeOpName();\n+            mName = mName.substring(mName.lastIndexOf('.') + 1);\n+            for (Method m : OnnxOperators.class.getMethods()) {\n+                if (m.getName().equals(mName)) {\n+                    return m.getReturnType().getRecordComponents()[componentIndex].getAccessor().getName() + \"()\";\n+                }\n+            }\n+            throw new IllegalStateException(mName);\n+        }\n+        return \"get(\" + componentIndex + \")\"; \/\/ fallback to List\n+    }\n+\n+    private static String toJava(Function<CodeItem, String> namer, Object value) {\n+        return switch (value) {\n+            case Optional o when o.isEmpty() -> \"empty()\";\n+            case Optional o -> \"of(\" + toJava(namer, o.get()) + \")\";\n+            case List l -> \"List.of(\" + l.stream().map(le -> toJava(namer, le)).collect(Collectors.joining(\", \")) + \")\";\n+            case Op.Result or when or.op() instanceof CoreOp.TupleLoadOp tlo -> OnnxLift.toJavaName(namer.apply(tlo.operands().getFirst())) + '.' + tupleAccessor(tlo.operands().getFirst(), tlo.index());\n+            case Value v -> OnnxLift.toJavaName(namer.apply(v));\n+            default -> throw new UnsupportedOperationException(value.toString());\n+        };\n+    }\n+\n+    private static OnnxOp.OnnxSchema getSchema(OnnxOp oo) {\n+        try {\n+            return (OnnxOp.OnnxSchema) oo.getClass().getDeclaredField(\"SCHEMA\").get(null);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static String toJavaType(TypeElement t) {\n+        return switch (t) {\n+            case OnnxType.TensorType tt ->\n+                \"Tensor<\" + switch (tt.eType()) {\n+                    case OnnxType.Float32Type _ -> \"Float\";\n+                    case OnnxType.Int64Type _ -> \"Long\";\n+                    case OnnxType.Int32Type _ -> \"Integer\";\n+                    case OnnxType.UInt8Type _ -> \"Byte\";\n+                    case OnnxType.BoolType _ -> \"Boolean\";\n+                    default -> throw new UnsupportedOperationException(t.toString());\n+                } + \">\";\n+            default -> \"var\";\n+        };\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/lift\/JavaTemplate.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Method;\n@@ -41,1 +40,0 @@\n-import java.util.HexFormat;\n@@ -46,1 +44,0 @@\n-import java.util.Optional;\n@@ -51,2 +48,0 @@\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n@@ -62,1 +57,0 @@\n-import jdk.incubator.code.dialect.java.JavaType;\n@@ -66,1 +60,0 @@\n-import oracle.code.onnx.OnnxOperators;\n@@ -79,1 +72,1 @@\n-public class OnnxLift {\n+public final class OnnxLift {\n@@ -81,199 +74,2 @@\n-    record LiftedModelWrapper(CoreOp.FuncOp func, List<String> names, List<OnnxModel.TensorProto> weights) {\n-\n-        private Function<CodeItem, String> namer() {\n-            var defNamer = OpWriter.CodeItemNamerOption.defaultValue().namer();\n-            var namer = new HashMap<Value, Integer>();\n-            return ci -> ci instanceof Value v ? names.get(namer.computeIfAbsent(v, _ -> namer.size())) : defNamer.apply(ci);\n-        }\n-\n-        public String toText() {\n-            return OpWriter.toText(func, OpWriter.CodeItemNamerOption.of(namer()));\n-        }\n-\n-        public String toJava() {\n-            var out = new StringBuilder();\n-            var namer = namer();\n-            var entryBlock = func.bodies().getFirst().entryBlock();\n-            entryBlock.parameters().forEach(namer::apply);\n-            out.append(\"\"\"\n-                    import java.io.IOException;\n-                    import java.io.RandomAccessFile;\n-                    import java.lang.foreign.Arena;\n-                    import java.lang.foreign.MemorySegment;\n-                    import java.nio.channels.FileChannel;\n-                    import jdk.incubator.code.CodeReflection;\n-                    import oracle.code.onnx.Tensor;\n-\n-                    import static java.util.Optional.*;\n-                    import static oracle.code.onnx.OnnxOperators.*;\n-                    import static oracle.code.onnx.Tensor.ElementType.*;\n-\n-                    public class Model {\n-\n-                        final Arena arena = Arena.ofAuto();\n-\n-                        MemorySegment mmap(String pathname) {\n-                            try (var f = new RandomAccessFile(pathname, \"r\")) {\n-                                return f.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, f.length(), arena);\n-                            } catch (IOException e) {\n-                                throw new RuntimeException(e);\n-                            }\n-                        }\n-\n-                        <T> Tensor<T> load(String path, Tensor.ElementType type, long... shape) {\n-                            return new Tensor<>(arena, mmap(path), type, shape);\n-                        }\n-\n-                    \"\"\");\n-            int pSize = entryBlock.parameters().size();\n-            int realParamsSize = pSize - weights().size();\n-            var weightParams = entryBlock.parameters().subList(realParamsSize, pSize);\n-            var wMap = weights.stream().collect(Collectors.toUnmodifiableMap(OnnxModel.TensorProto::name, Function.identity()));\n-            for (int i = 0; i < weightParams.size(); i++) {\n-                Block.Parameter wp = weightParams.get(i);\n-                OnnxModel.TensorProto w = wMap.get(namer.apply(wp));\n-                String name = toJavaName(w.name());\n-                long[] dims = OnnxLift.joinLongArray(w.dims());\n-                out.append(\"    final \" + toJavaType(wp.type()) + \" \" + name + \" = load(\\\"\"\n-                        + name + \"\\\", \"\n-                        + Tensor.ElementType.fromOnnxId(w.dataType()).name()\n-                        + (dims.length > 0 ? (\", \" + longJoin(dims)) : \"\") + \");\\n\");\n-            }\n-            out.append(\"\"\"\n-\n-                        @CodeReflection\n-                        public Object mainGraph(\n-                    \"\"\");\n-            for (int i = 0; i < realParamsSize; i++) {\n-                if (i > 0) {\n-                    out.append(\",\\n\");\n-                }\n-                var param = entryBlock.parameters().get(i);\n-                out.append(\"            \").append(toJavaType(param.type())).append(' ').append(toJavaName(namer.apply(param)));\n-            }\n-            out.append(\") {\\n\");\n-            for (var op : entryBlock.ops()) {\n-                if (!(op instanceof CoreOp.TupleLoadOp)) { \/\/ lazy tupple loads\n-                    out.append(\"        \");\n-                    if (!op.resultType().equals(JavaType.VOID)) {\n-                        out.append(toJavaType(op.resultType())).append(' ').append(toJavaName(namer.apply(op.result()))).append(\" = \");\n-                    }\n-\n-                    switch (op) {\n-                        case OnnxOp oo -> {\n-                            String opName = op.externalizeOpName();\n-                            out.append(opName.substring(opName.lastIndexOf('.') + 1)).append('(');\n-                            var schema = getSchema(oo);\n-                            var inputs = oo.onnxInputs();\n-                            boolean first = true;\n-                            for (var oi : schema.inputs()) {\n-                                if (first) {\n-                                    first = false;\n-                                } else {\n-                                    out.append(\", \");\n-                                }\n-                                out.append(toJava(namer, inputs.get(oi)));\n-                            }\n-                            var attrs = oo.onnxAttributes();\n-                            for (var oa : schema.attributes()) {\n-                                if (first) {\n-                                    first = false;\n-                                } else {\n-                                    out.append(\", \");\n-                                }\n-                                var a = attrs.get(oa.name());\n-                                if (a == null) {\n-                                    out.append(\"empty()\");\n-                                } else if (oa.isOptional()) {\n-                                    out.append(\"of(\").append(toString(a)).append(')');\n-                                } else {\n-                                    out.append(toString(a));\n-                                }\n-                            }\n-                            out.append(\");\\n\");\n-                        }\n-                        case CoreOp.TupleOp to -> {\n-                            out.append(\"List.of(\");\n-                            boolean first = true;\n-                            for (var te : to.operands()) {\n-                                if (first) {\n-                                    first = false;\n-                                } else {\n-                                    out.append(\", \");\n-                                }\n-                                out.append(toJava(namer, te));\n-                            }\n-                            out.append(\");\\n\");\n-                        }\n-                        case CoreOp.ReturnOp ro -> {\n-                            out.append(\"return \").append(toJava(namer, ro.operands().getFirst())).append(\";\\n\");\n-                        }\n-                        default -> throw new UnsupportedOperationException(op.toText());\n-                    }\n-                } else {\n-                    namer.apply(op.result());\n-                }\n-            }\n-            out.append(\"    }\\n}\\n\");\n-            return out.toString();\n-        }\n-\n-        private static String toString(Object o) {\n-            return switch (o) {\n-                case long[] la -> newArray(la);\n-                case float[] fa -> newArray(fa);\n-                case Long l -> l.toString() + \"L\";\n-                case Float f -> f.toString() + \"F\";\n-                case String s -> \"\\\"\" + s + \"\\\"\";\n-                case Tensor t when t.shape().length == 0 && t.elementType() == Tensor.ElementType.BOOL ->\n-                        \"Tensor.ofScalar(\" + t.data().get(ValueLayout.JAVA_BOOLEAN, 0) + \")\";\n-                case Tensor t when t.shape().length == 0 && t.elementType() == Tensor.ElementType.INT8 ->\n-                        \"Tensor.ofScalar((byte)\" + t.data().get(ValueLayout.JAVA_BYTE, 0) + \")\";\n-                case Tensor t -> \"Tensor.ofShape(\" + toString(t.shape()) + \", \"\n-                    + switch (t.elementType()) {\n-                        case FLOAT -> toString(t.data().toArray(ValueLayout.JAVA_FLOAT));\n-                        case INT64 -> toString(t.data().toArray(ValueLayout.JAVA_LONG));\n-                        default -> \"HexFormat.of().parseHex(\\\"\" + HexFormat.of().formatHex(t.data().toArray(ValueLayout.JAVA_BYTE))\n-                                                            + \"\\\"), \" + t.elementType().name();\n-                    } + \")\";\n-                default -> o.toString();\n-            };\n-        }\n-\n-        private static String newArray(long[] la) {\n-            for (long l : la) {\n-                if (l != 0l) {\n-                    return \"new long[] {\" + longJoin(la) + \"}\";\n-                }\n-            }\n-            return \"new long[\" + la.length + \"]\";\n-        }\n-\n-        private static String longJoin(long[] la) {\n-            return LongStream.of(la).mapToObj(d -> String.valueOf(d) + \"L\")\n-                                     .collect(Collectors.joining(\", \"));\n-        }\n-\n-        private static String newArray(float[] fa) {\n-            for (float f : fa) {\n-                if (f != 0f) {\n-                    return IntStream.range(0, fa.length).mapToObj(i -> String.valueOf(fa[i]) + \"F\")\n-                                    .collect(Collectors.joining(\", \",  \"new float[] {\", \"}\"));\n-                }\n-            }\n-            return \"new float[\" + fa.length + \"]\";\n-        }\n-\n-        private static String tupleAccessor(Value tuple, int componentIndex) {\n-            if (tuple instanceof Op.Result or && or.op() instanceof OnnxOp oo) {\n-                String mName = oo.externalizeOpName();\n-                mName = mName.substring(mName.lastIndexOf('.') + 1);\n-                for (Method m : OnnxOperators.class.getMethods()) {\n-                    if (m.getName().equals(mName)) {\n-                        return m.getReturnType().getRecordComponents()[componentIndex].getAccessor().getName() + \"()\";\n-                    }\n-                }\n-                throw new IllegalStateException(mName);\n-            }\n-            return \"get(\" + componentIndex + \")\"; \/\/ fallback to List\n-        }\n+    private static final OpFactory ONNX_OP_FACTORY =\n+            OpFactoryHelper.OP_FACTORY.get(ExplicitOnnxOps.class).andThen(OpFactoryHelper.OP_FACTORY.get(OnnxOps.class));\n@@ -281,35 +77,2 @@\n-        private static String toJava(Function<CodeItem, String> namer, Object value) {\n-            return switch (value) {\n-                case Optional o when o.isEmpty() -> \"empty()\";\n-                case Optional o -> \"of(\" + toJava(namer, o.get()) + \")\";\n-                case List l -> \"List.of(\" + l.stream().map(le -> toJava(namer, le)).collect(Collectors.joining(\", \")) + \")\";\n-                case Op.Result or when or.op() instanceof CoreOp.TupleLoadOp tlo ->\n-                    toJavaName(namer.apply(tlo.operands().getFirst())) + '.' + tupleAccessor(tlo.operands().getFirst(), tlo.index());\n-                case Value v -> toJavaName(namer.apply(v));\n-                default -> throw new UnsupportedOperationException(value.toString());\n-            };\n-        }\n-\n-        private static OnnxOp.OnnxSchema getSchema(OnnxOp oo) {\n-            try {\n-                return (OnnxOp.OnnxSchema) oo.getClass().getDeclaredField(\"SCHEMA\").get(null);\n-            } catch (ReflectiveOperationException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-\n-        private static String toJavaType(TypeElement t) {\n-            return switch (t) {\n-                case OnnxType.TensorType tt ->\n-                    \"Tensor<\" + switch (tt.eType()) {\n-                        case OnnxType.Float32Type _ -> \"Float\";\n-                        case OnnxType.Int64Type _ -> \"Long\";\n-                        case OnnxType.Int32Type _ -> \"Integer\";\n-                        case OnnxType.UInt8Type _ -> \"Byte\";\n-                        case OnnxType.BoolType _ -> \"Boolean\";\n-                        default -> throw new UnsupportedOperationException(t.toString());\n-                    } + \">\";\n-                default -> \"var\";\n-            };\n-        }\n-    }\n+    private static final Map<String, OnnxOp.OnnxSchema> ONNX_SCHEMA_REGISTRY =\n+            collectSchemas(ExplicitOnnxOps.class, OnnxOps.class);\n@@ -317,1 +80,1 @@\n-    static OnnxType toOnnxType(OnnxModel.TypeProto tp) {\n+    private static OnnxType toOnnxType(OnnxModel.TypeProto tp) {\n@@ -332,1 +95,1 @@\n-    static FunctionType toFunctionType(OnnxModel.GraphProto g) {\n+    private static FunctionType toFunctionType(OnnxModel.GraphProto g) {\n@@ -352,1 +115,1 @@\n-    static OnnxType toKeyType(int kt) {\n+    private static OnnxType toKeyType(int kt) {\n@@ -367,1 +130,1 @@\n-    static OnnxType.TensorType toTensorType(int tt) {\n+    private static OnnxType.TensorType toTensorType(int tt) {\n@@ -396,5 +159,1 @@\n-    static final OpFactory ONNX_OP_FACTORY = OpFactoryHelper.OP_FACTORY.get(ExplicitOnnxOps.class).andThen(OpFactoryHelper.OP_FACTORY.get(OnnxOps.class));\n-\n-    static final Map<String, OnnxOp.OnnxSchema> ONNX_SCHEMA_REGISTRY = collectSchemas(ExplicitOnnxOps.class, OnnxOps.class);\n-\n-    static Map<String, OnnxOp.OnnxSchema> collectSchemas(Class<?>... cls) {\n+    private static Map<String, OnnxOp.OnnxSchema> collectSchemas(Class<?>... cls) {\n@@ -417,1 +176,96 @@\n-    static LiftedModelWrapper lift(OnnxModel.GraphProto g) {\n+    private static OnnxType inferTypeVariableType(OnnxType type, OnnxOp op, OnnxModel.NodeProto n) {\n+        if (type instanceof OnnxType.TypeVariable tv) {\n+            if (tv.types().size() == 1) {\n+                return tv.types().getFirst();\n+            }\n+            \/\/ search for the same type variable across inputs\n+            for (var ie : op.onnxInputs().entrySet()) {\n+                if (ie.getKey().type().equals(tv)) {\n+                    if (ie.getValue() instanceof Value v && v.type() instanceof OnnxType ot) {\n+                        return ot;\n+                    } else if (ie.getValue() instanceof List l && !l.isEmpty() && l.getFirst() instanceof Value v && v.type() instanceof OnnxType ot) {\n+                        return ot;\n+                    }\n+                }\n+            }\n+\n+            \/\/ special cases\n+            return switch (op) {\n+                case OnnxOps.Cast c ->\n+                    toTensorType((int)c.to());\n+                case OnnxOps.ConstantOfShape _, OnnxOps.Constant _-> \/\/ get tensor type from tensor attribute\n+                    n.attribute() != null\n+                    && !n.attribute().isEmpty()\n+                    && n.attribute().getFirst().t() instanceof OnnxModel.TensorProto tp\n+                            ? toTensorType(tp.dataType())\n+                            : OnnxType.TENSOR_FLOAT32; \/\/ default\n+                default ->\n+                    throw new IllegalArgumentException(\"Could not infer op type for: \" + op.toText());\n+            };\n+        }\n+        return type;\n+    }\n+\n+    private static Object toAttributeValue(OnnxModel.AttributeProto a) {\n+        return switch (a.type()) {\n+            case FLOAT -> a.f();\n+            case INT -> a.i();\n+            case STRING -> new String(a.s());\n+            case TENSOR -> toTensor(a.t());\n+\/\/    GRAPH = 5;\n+\/\/    SPARSE_TENSOR = 11;\n+\/\/    TYPE_PROTO = 13;\n+            case FLOATS -> joinFloatArray(a.floats());\n+            case INTS -> joinLongArray(a.ints());\n+            case STRINGS -> a.strings();\n+            case TENSORS -> a.tensors().stream().map(OnnxLift::toTensor).toArray(Tensor[]::new);\n+\/\/    GRAPHS = 10;\n+\/\/    SPARSE_TENSORS = 12;\n+\/\/    TYPE_PROTOS = 14;\n+            default -> throw new UnsupportedOperationException(\"Unsupported \" + a.type());\n+        };\n+    }\n+\n+    private static Tensor toTensor(OnnxModel.TensorProto tensorProto) {\n+        \/\/ @@@ floatData, longData, stringData...\n+        \/\/ @@@ externalData\n+        \/\/ @@@ segments\n+        return Tensor.ofShape(joinLongArray(tensorProto.dims()), tensorProto.rawData(), Tensor.ElementType.fromOnnxId(tensorProto.dataType()));\n+    }\n+\n+    private static float[] joinFloatArray(List<float[]> floats) {\n+        if (floats == null) return new float[0];\n+        float[] join = new float[floats.stream().mapToInt(f -> f.length).sum()];\n+        int i = 0;\n+        for (float[] f : floats) {\n+            System.arraycopy(f, 0, join, i, f.length);\n+            i += f.length;\n+        }\n+        return join;\n+    }\n+\n+    static long[] joinLongArray(List<long[]> longs) {\n+        if (longs == null) return new long[0];\n+        long[] join = new long[longs.stream().mapToInt(f -> f.length).sum()];\n+        int i = 0;\n+        for (long[] f : longs) {\n+            System.arraycopy(f, 0, join, i, f.length);\n+            i += f.length;\n+        }\n+        return join;\n+    }\n+\n+    static Function<CodeItem, String> namer(List<String> names) {\n+        var defNamer = OpWriter.CodeItemNamerOption.defaultValue().namer();\n+        var namer = new HashMap<Value, Integer>();\n+        return ci -> ci instanceof Value v ? names.get(namer.computeIfAbsent(v, _ -> namer.size())) : defNamer.apply(ci);\n+    }\n+\n+    record LiftedModelWrapper(CoreOp.FuncOp func, List<String> names, List<OnnxModel.TensorProto> weights) {\n+\n+        String toText() {\n+            return OpWriter.toText(func, OpWriter.CodeItemNamerOption.of(namer(names)));\n+        }\n+    }\n+\n+    private static LiftedModelWrapper lift(OnnxModel.GraphProto g) {\n@@ -564,82 +418,0 @@\n-    static OnnxType inferTypeVariableType(OnnxType type, OnnxOp op, OnnxModel.NodeProto n) {\n-        if (type instanceof OnnxType.TypeVariable tv) {\n-            if (tv.types().size() == 1) {\n-                return tv.types().getFirst();\n-            }\n-            \/\/ search for the same type variable across inputs\n-            for (var ie : op.onnxInputs().entrySet()) {\n-                if (ie.getKey().type().equals(tv)) {\n-                    if (ie.getValue() instanceof Value v && v.type() instanceof OnnxType ot) {\n-                        return ot;\n-                    } else if (ie.getValue() instanceof List l && !l.isEmpty() && l.getFirst() instanceof Value v && v.type() instanceof OnnxType ot) {\n-                        return ot;\n-                    }\n-                }\n-            }\n-\n-            \/\/ special cases\n-            return switch (op) {\n-                case OnnxOps.Cast c ->\n-                    toTensorType((int)c.to());\n-                case OnnxOps.ConstantOfShape _, OnnxOps.Constant _-> \/\/ get tensor type from tensor attribute\n-                    n.attribute() != null\n-                    && !n.attribute().isEmpty()\n-                    && n.attribute().getFirst().t() instanceof OnnxModel.TensorProto tp\n-                            ? toTensorType(tp.dataType())\n-                            : OnnxType.TENSOR_FLOAT32; \/\/ default\n-                default ->\n-                    throw new IllegalArgumentException(\"Could not infer op type for: \" + op.toText());\n-            };\n-        }\n-        return type;\n-    }\n-\n-    static Object toAttributeValue(OnnxModel.AttributeProto a) {\n-        return switch (a.type()) {\n-            case FLOAT -> a.f();\n-            case INT -> a.i();\n-            case STRING -> new String(a.s());\n-            case TENSOR -> toTensor(a.t());\n-\/\/    GRAPH = 5;\n-\/\/    SPARSE_TENSOR = 11;\n-\/\/    TYPE_PROTO = 13;\n-            case FLOATS -> joinFloatArray(a.floats());\n-            case INTS -> joinLongArray(a.ints());\n-            case STRINGS -> a.strings();\n-            case TENSORS -> a.tensors().stream().map(OnnxLift::toTensor).toArray(Tensor[]::new);\n-\/\/    GRAPHS = 10;\n-\/\/    SPARSE_TENSORS = 12;\n-\/\/    TYPE_PROTOS = 14;\n-            default -> throw new UnsupportedOperationException(\"Unsupported \" + a.type());\n-        };\n-    }\n-\n-    static Tensor toTensor(OnnxModel.TensorProto tensorProto) {\n-        \/\/ @@@ floatData, longData, stringData...\n-        \/\/ @@@ externalData\n-        \/\/ @@@ segments\n-        return Tensor.ofShape(joinLongArray(tensorProto.dims()), tensorProto.rawData(), Tensor.ElementType.fromOnnxId(tensorProto.dataType()));\n-    }\n-\n-    static float[] joinFloatArray(List<float[]> floats) {\n-        if (floats == null) return new float[0];\n-        float[] join = new float[floats.stream().mapToInt(f -> f.length).sum()];\n-        int i = 0;\n-        for (float[] f : floats) {\n-            System.arraycopy(f, 0, join, i, f.length);\n-            i += f.length;\n-        }\n-        return join;\n-    }\n-\n-    static long[] joinLongArray(List<long[]> longs) {\n-        if (longs == null) return new long[0];\n-        long[] join = new long[longs.stream().mapToInt(f -> f.length).sum()];\n-        int i = 0;\n-        for (long[] f : longs) {\n-            System.arraycopy(f, 0, join, i, f.length);\n-            i += f.length;\n-        }\n-        return join;\n-    }\n-\n@@ -652,1 +424,1 @@\n-    static String colorModelToANSI(String codeModel) {\n+    private static String colorModelToANSI(String codeModel) {\n@@ -660,1 +432,1 @@\n-    static void extractWeights(OnnxModel.ModelProto model, Path sourceFolder, Path targetFolder) throws IOException {\n+    private static void extractWeights(OnnxModel.ModelProto model, Path sourceFolder, Path targetFolder) throws IOException {\n@@ -712,1 +484,1 @@\n-                Files.writeString(java, liftedModel.toJava());\n+                Files.writeString(java, JavaTemplate.toJava(liftedModel));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/lift\/OnnxLift.java","additions":109,"deletions":337,"binary":false,"changes":446,"status":"modified"}]}