{"files":[{"patch":"@@ -100,2 +100,2 @@\n-            public static ExternalizedTypeElement ofString(String s) {\n-        return jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(s);\n+        public static ExternalizedTypeElement ofString(String s) {\n+            return jdk.incubator.code.parser.impl.DescParser.parseExTypeElem(s);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/TypeElement.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        if (l.token().kind == TokenKind.HASH) {\n+        if (l.token().kind == TokenKind.HASH || l.token().kind == TokenKind.AMP) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/parser\/impl\/DescParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    FunctionType type();\n+\n@@ -49,2 +51,0 @@\n-    FunctionType type();\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/ConstructorRef.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+        \/\/ Returns JavaType or JavaRef\n@@ -95,1 +96,1 @@\n-        public JavaType constructType(TypeElement.ExternalizedTypeElement tree) {\n+        public TypeElement constructType(TypeElement.ExternalizedTypeElement tree) {\n@@ -108,1 +109,1 @@\n-                JavaType elemType = constructType(tree.arguments().getFirst());\n+                JavaType elemType = (JavaType) constructType(tree.arguments().getFirst());\n@@ -121,1 +122,1 @@\n-                if (tree.arguments().size() != 1) {\n+                if (tree.arguments().size() != 2) {\n@@ -124,16 +125,7 @@\n-                String[] parts = identifier.substring(1).split(\"::\");\n-                if (parts.length == 2) {\n-                    \/\/ class type-var\n-                    return JavaType.typeVarRef(parts[1],\n-                            (ClassType)constructType(parseExTypeElem(parts[0])),\n-                            constructTypeArgument(tree, 0, NO_WILDCARDS));\n-                } else if (parts.length == 3) {\n-                    \/\/ method or constructor type-var\n-                    String desc = String.format(\"%s::%s\", parts[0], parts[1]);\n-                    TypeVarRef.Owner owner = parts[1].startsWith(\"<new>\") ?\n-                            parseConstructorRef(desc) :\n-                            parseMethodRef(String.format(\"%s::%s\", parts[0], parts[1]));\n-                            return JavaType.typeVarRef(parts[2],\n-                                    owner,\n-                                    constructTypeArgument(tree, 0, NO_WILDCARDS));\n-                } else {\n+\n+                String name = tree.identifier().substring(1);\n+                if (name.isEmpty()) {\n+                    throw badType(tree, \"type variable\");\n+                }\n+\n+                if (!(constructType(tree.arguments().get(0)) instanceof TypeVarRef.Owner owner)) {\n@@ -142,0 +134,64 @@\n+\n+                return JavaType.typeVarRef(name,\n+                        owner,\n+                        constructTypeArgument(tree, 1, NO_WILDCARDS));\n+            } else if (identifier.startsWith(\"&\")) {\n+                if (identifier.equals(\"&m\")) {\n+                    if (tree.arguments().size() != 3) {\n+                        throw badType(tree, \"method reference\");\n+                    }\n+\n+                    ExternalizedTypeElement name = tree.arguments().get(1);\n+                    if (!name.arguments().isEmpty()) {\n+                        throw badType(tree, \"method reference\");\n+                    }\n+                    if (!(CORE_TYPE_FACTORY.constructType(tree.arguments().get(2)) instanceof FunctionType type)) {\n+                        throw badType(tree, \"method reference\");\n+                    }\n+                    return MethodRef.method(\n+                            constructType(tree.arguments().get(0)),\n+                            name.identifier(),\n+                            type\n+                    );\n+                } else if (identifier.startsWith(\"&c\")) {\n+                    if (tree.arguments().size() != 1) {\n+                        throw badType(tree, \"constructor reference\");\n+                    }\n+\n+                    if (!(CORE_TYPE_FACTORY.constructType(tree.arguments().get(0)) instanceof FunctionType type)) {\n+                        throw badType(tree, \"method reference\");\n+                    }\n+                    return ConstructorRef.constructor(type);\n+                } else if (identifier.startsWith(\"&f\")) {\n+                    if (tree.arguments().size() != 3) {\n+                        throw badType(tree, \"field reference\");\n+                    }\n+\n+                    ExternalizedTypeElement name = tree.arguments().get(1);\n+                    if (!name.arguments().isEmpty()) {\n+                        throw badType(tree, \"field reference\");\n+                    }\n+                    return FieldRef.field(\n+                            constructType(tree.arguments().get(0)),\n+                            name.identifier(),\n+                            constructType(tree.arguments().get(2))\n+                            );\n+                } else if (identifier.startsWith(\"&r\")) {\n+                    if (tree.arguments().isEmpty()) {\n+                        throw badType(tree, \"record reference\");\n+                    }\n+\n+                    List<RecordTypeRef.ComponentRef> cs = new ArrayList<>();\n+                    for (int i = 1; i < tree.arguments().size(); i += 2) {\n+                        ExternalizedTypeElement cname = tree.arguments().get(i + 1);\n+                        if (!cname.arguments().isEmpty()) {\n+                            throw badType(tree, \"record reference\");\n+                        }\n+                        cs.add(new RecordTypeRef.ComponentRef(\n+                                constructType(tree.arguments().get(i)),\n+                                cname.identifier()));\n+                    }\n+                    return RecordTypeRef.recordType(constructType(tree.arguments().get(0)), cs);\n+                } else {\n+                    throw badType(tree, \"unknown reference\");\n+                }\n@@ -175,1 +231,1 @@\n-                            tree.arguments().stream().map(this::constructType).toList());\n+                            tree.arguments().stream().map(ete -> (JavaType) constructType(ete)).toList());\n@@ -188,1 +244,1 @@\n-            JavaType type = constructType(arg);\n+            JavaType type = (JavaType) constructType(arg);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/CoreTypeFactory.java","additions":77,"deletions":21,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+import jdk.incubator.code.TypeElement;\n+\n@@ -4,2 +6,3 @@\n- * A symbolic reference to a Java class member or type, commonly containing\n- * symbolic names together with {@link JavaType symbolic descriptions} of Java types.\n+ * A symbolic reference to a Java class member or a Java type including members,\n+ * commonly containing symbolic names together with {@link JavaType symbolic descriptions}\n+ * of Java types.\n@@ -11,1 +14,1 @@\n-public sealed interface JavaRef\n+public sealed interface JavaRef extends TypeElement\n@@ -13,8 +16,0 @@\n-    \/\/ @@@ Extend from TypeElement\n-    \/\/     - Uniform externalization of Java types and Java refs,\n-    \/\/       therefore we don't require specific string representations\n-    \/\/       and parser implementations. (Human readability of Java types\n-    \/\/       and refs is a separate issue.)\n-    \/\/       e.g., the description of a type-variable reference Java type\n-    \/\/       (TypeVarRef) contains an owner, a description of Java class\n-    \/\/       or a symbolic reference to a Java method or constructor.\n@@ -24,3 +19,3 @@\n-    \/\/ @@@ Make RecordTypeRef.ComponentRef implement JavaRef\n-    \/\/     - resolve to accessor method\n-    \/\/     - (RecordTypeRef resolves to Class.)\n+    \/\/ @@@ Make RecordTypeRef.ComponentRef implement JavaRef?\n+    \/\/     - resolve to RecordComponent\n+    \/\/     - (RecordTypeRef resolves to Type.)\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/JavaRef.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.code.TypeElement;\n+\n@@ -103,2 +105,7 @@\n-        return new ExternalizedTypeElement(String.format(\"#%s::%s\", owner, name),\n-                List.of(bound.externalize()));\n+        ExternalizedTypeElement eOwner = switch (owner) {\n+            \/\/ @@@ Should be able to use single case matching TypeElement\n+            case JavaRef ref -> ref.externalize();\n+            case ClassType classType -> classType.externalize();\n+        };\n+        return new ExternalizedTypeElement(\"#\" + name,\n+                List.of(eOwner, bound.externalize()));\n@@ -109,0 +116,1 @@\n+        \/\/ @@@ required to pass TestJavaType.java\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/TypeVarRef.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import java.util.List;\n+import java.util.Objects;\n@@ -45,0 +47,2 @@\n+    static final String NAME = \"&c\";\n+\n@@ -46,1 +50,0 @@\n-    final TypeElement refType;\n@@ -62,6 +65,0 @@\n-        this.refType = functionType.returnType();\n-    }\n-\n-    @Override\n-    public TypeElement refType() {\n-        return refType;\n@@ -83,2 +80,2 @@\n-        Class<?> refC = resolve(l, refType);\n-        if (refType instanceof ArrayType at) {\n+        Class<?> refC = resolve(l, type.returnType());\n+        if (type.returnType() instanceof ArrayType at) {\n@@ -114,0 +111,6 @@\n+    @Override\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME,\n+                List.of(type.externalize()));\n+    }\n+\n@@ -116,1 +119,1 @@\n-        return refType.externalize() + \"::<new>\" +\n+        return type.returnType().externalize() + \"::<new>\" +\n@@ -123,7 +126,2 @@\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-\n-        ConstructorRefImpl that = (ConstructorRefImpl) o;\n-\n-        if (!refType.equals(that.refType)) return false;\n-        return type.equals(that.type);\n+        if (!(o instanceof ConstructorRefImpl that)) return false;\n+        return Objects.equals(type, that.type);\n@@ -134,3 +132,1 @@\n-        int result = refType.hashCode();\n-        result = 31 * result + type.hashCode();\n-        return result;\n+        return Objects.hashCode(type);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/ConstructorRefImpl.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.util.List;\n+\n@@ -36,0 +38,2 @@\n+    static final String NAME = \"&f\";\n+\n@@ -114,0 +118,6 @@\n+    @Override\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME,\n+                List.of(refType.externalize(), ExternalizedTypeElement.ofString(name), type.externalize()));\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/FieldRefImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+    static final String NAME = \"&m\";\n+\n@@ -140,0 +142,6 @@\n+    @Override\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME,\n+                List.of(refType.externalize(), new ExternalizedTypeElement(name, List.of()), type.externalize()));\n+    }\n+\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/MethodRefImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -36,0 +38,2 @@\n+    static final String NAME = \"&r\";\n+\n@@ -64,0 +68,10 @@\n+    @Override\n+    public ExternalizedTypeElement externalize() {\n+        return new ExternalizedTypeElement(NAME,\n+                Stream.concat(\n+                        Stream.of(recordType.externalize()),\n+                        components.stream().flatMap(cr ->\n+                                Stream.of(cr.type().externalize(), new ExternalizedTypeElement(cr.name(), List.of())))\n+                ).toList());\n+    }\n+\n@@ -72,0 +86,10 @@\n+    @Override\n+    public boolean equals(Object o) {\n+        if (!(o instanceof RecordTypeRefImpl that)) return false;\n+        return Objects.equals(recordType, that.recordType) && Objects.equals(components, that.components);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(recordType, components);\n+    }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/type\/impl\/RecordTypeRefImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import jdk.incubator.code.type.ConstructorRef;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.type.*;\n@@ -31,3 +32,0 @@\n-import jdk.incubator.code.type.FieldRef;\n-import jdk.incubator.code.type.MethodRef;\n-import jdk.incubator.code.type.RecordTypeRef;\n@@ -54,1 +52,1 @@\n-                {\"R<#R::T<java.lang.Number>>::n()#R::T<java.lang.Number>\", \"R<#R::T<java.lang.Number>>\", \"n\"}\n+                {\"R<#T<R, java.lang.Number>>::n()#T<R, java.lang.Number>\", \"R<#T<R, java.lang.Number>>\", \"n\"}\n@@ -66,0 +64,24 @@\n+\n+    @DataProvider\n+    public Object[][] externalizedMethodRefs() {\n+        return new Object[][]{\n+                {\"&m<a, b, func<void>>\", \"a\", \"b\"},\n+                {\"&m<a.b, c, func<int, int>>\", \"a.b\", \"c\"},\n+                {\"&m<a.b.c, d, func<int, int, int>>\", \"a.b.c\", \"d\"},\n+                {\"&m<a, b, func<void, Func<String, Number>, Entry<List<String>, val>, int, long>>\", \"a\", \"b\"},\n+                {\"&m<java.io.PrintStream, println, func<void, java.lang.String>>\", \"java.io.PrintStream\", \"println\"},\n+                {\"&m<MethodReferenceTest$A, m, func<java.lang.Object, java.lang.Object>>\", \"MethodReferenceTest$A\", \"m\"},\n+                {\"&m<R<#T<R, java.lang.Number>>, n, func<#T<R, java.lang.Number>>>\", \"R<#T<R, java.lang.Number>>\", \"n\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"externalizedMethodRefs\")\n+    public void testExternalizedMethodRef(String mds, String refType, String name) {\n+        TypeElement.ExternalizedTypeElement emr = TypeElement.ExternalizedTypeElement.ofString(mds);\n+        MethodRef mr = (MethodRef) CoreTypeFactory.CORE_TYPE_FACTORY.constructType(emr);\n+        Assert.assertEquals(mr.externalize().toString(), mds);\n+        Assert.assertEquals(mr.refType().externalize().toString(), refType);\n+        Assert.assertEquals(mr.name(), name);\n+    }\n+\n+\n@@ -81,0 +103,18 @@\n+    @DataProvider\n+    public Object[][] externalizedConstructorRefs() {\n+        return new Object[][]{\n+                {\"&c<func<MethodReferenceTest$X, int>>\", \"MethodReferenceTest$X\"},\n+                {\"&c<func<MethodReferenceTest$A[], int>>\", \"MethodReferenceTest$A[]\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"externalizedConstructorRefs\")\n+    public void testExternalizedConstructorRef(String crs, String refType) {\n+        TypeElement.ExternalizedTypeElement ecr = TypeElement.ExternalizedTypeElement.ofString(crs);\n+        ConstructorRef cr = (ConstructorRef) CoreTypeFactory.CORE_TYPE_FACTORY.constructType(ecr);\n+\n+        Assert.assertEquals(cr.externalize().toString(), crs);\n+        Assert.assertEquals(cr.refType().externalize().toString(), refType);\n+    }\n+\n+\n@@ -87,1 +127,1 @@\n-                {\"R<#R::T<java.lang.Number>>::n()#R::T<java.lang.Number>\", \"R<#R::T<java.lang.Number>>\", \"n\", \"#R::T<java.lang.Number>\"}\n+                {\"R<#T<R, java.lang.Number>>::n()#T<R, java.lang.Number>\", \"R<#T<R, java.lang.Number>>\", \"n\", \"#T<R, java.lang.Number>\"}\n@@ -100,0 +140,21 @@\n+    @DataProvider\n+    public Object[][] externalizedFieldRefs() {\n+        return new Object[][]{\n+                {\"&f<a.b, c, int>\", \"a.b\", \"c\", \"int\"},\n+                {\"&f<a.b.c, d, int>\", \"a.b.c\", \"d\", \"int\"},\n+                {\"&f<java.lang.System, out, java.io.PrintStream>\", \"java.lang.System\", \"out\", \"java.io.PrintStream\"},\n+                {\"&f<R<#T<R, java.lang.Number>>, n, #T<R, java.lang.Number>>\", \"R<#T<R, java.lang.Number>>\", \"n\", \"#T<R, java.lang.Number>\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"externalizedFieldRefs\")\n+    public void testExternalizedFieldRef(String frs, String refType, String name, String type) {\n+        TypeElement.ExternalizedTypeElement efr = TypeElement.ExternalizedTypeElement.ofString(frs);\n+        FieldRef fr = (FieldRef) CoreTypeFactory.CORE_TYPE_FACTORY.constructType(efr);\n+\n+        Assert.assertEquals(fr.externalize().toString(), frs);\n+        Assert.assertEquals(fr.refType().externalize().toString(), refType);\n+        Assert.assertEquals(fr.name(), name);\n+        Assert.assertEquals(fr.type().externalize().toString(), type);\n+    }\n+\n@@ -108,1 +169,1 @@\n-                {\"(#R::T<java.lang.Number> n)R<#R::T<java.lang.Number>>\"}\n+                {\"(#T<R, java.lang.Number> n)R<#T<R, java.lang.Number>>\"}\n@@ -117,0 +178,19 @@\n+\n+    @DataProvider\n+    public Object[][] externalizedRecordTypeRefs() {\n+        return new Object[][]{\n+                {\"&r<A>\"},\n+                {\"&r<A, B, b>\"},\n+                {\"&r<A, B, b, C, c>\"},\n+                {\"&r<p.A<R>, p.Func<String, Number>, f, Entry<List<String>, val>, e, int, i, long, l>\"},\n+                \/\/ @@@ Fails because of externalize().toString()\n+                {\"&r<R<#T<R, java.lang.Number>>, #T<R, java.lang.Number>, n>\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"externalizedRecordTypeRefs\")\n+    public void testExternalizedRecordTypeRef(String rtds) {\n+        TypeElement.ExternalizedTypeElement ertr = TypeElement.ExternalizedTypeElement.ofString(rtds);\n+        RecordTypeRef rtr = (RecordTypeRef) CoreTypeFactory.CORE_TYPE_FACTORY.constructType(ertr);\n+        Assert.assertEquals(rtr.externalize().toString(), rtds);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":87,"deletions":7,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -138,3 +138,3 @@\n-                  %0 : #DenotableTypesTest::test7()void::X<java.lang.Object> = constant @null;\n-                  %1 : Var<#DenotableTypesTest::test7()void::X<java.lang.Object>> = var %0 @\"x\";\n-                  %2 : #DenotableTypesTest::test7()void::X<java.lang.Object> = var.load %1;\n+                  %0 : #X<&m<DenotableTypesTest, test7, func<void>>, java.lang.Object> = constant @null;\n+                  %1 : Var<#X<&m<DenotableTypesTest, test7, func<void>>, java.lang.Object>> = var %0 @\"x\";\n+                  %2 : #X<&m<DenotableTypesTest, test7, func<void>>, java.lang.Object> = var.load %1;\n","filename":"test\/langtools\/tools\/javac\/reflect\/DenotableTypesTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,3 +53,3 @@\n-            func @\"test1\" (%0 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n-                  %1 : Var<#IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                  %2 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+            func @\"test1\" (%0 : #X<&m<IntersectionTypeTest, test1, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#X<&m<IntersectionTypeTest, test1, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #X<&m<IntersectionTypeTest, test1, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -57,1 +57,1 @@\n-                  %3 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %3 : #X<&m<IntersectionTypeTest, test1, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -60,1 +60,1 @@\n-                  %5 : #IntersectionTypeTest::test1(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %5 : #X<&m<IntersectionTypeTest, test1, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -72,0 +72,2 @@\n+    \/\/ #X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>\n+    \/\/ #X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>, IntersectionTypeTest$A>\n@@ -74,3 +76,3 @@\n-            func @\"test2\" (%0 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n-                  %1 : Var<#IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                  %2 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+            func @\"test2\" (%0 : #X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -79,1 +81,1 @@\n-                  %5 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %5 : #X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -82,1 +84,1 @@\n-                  %8 : #IntersectionTypeTest::test2(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %8 : #X<&m<IntersectionTypeTest, test2, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -96,3 +98,3 @@\n-            func @\"test3\" (%0 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n-                  %1 : Var<#IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                  %2 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+            func @\"test3\" (%0 : #X<&m<IntersectionTypeTest, test3, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>)void -> {\n+                  %1 : Var<#X<&m<IntersectionTypeTest, test3, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>> = var %0 @\"x\";\n+                  %2 : #X<&m<IntersectionTypeTest, test3, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -106,1 +108,1 @@\n-                  %7 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %7 : #X<&m<IntersectionTypeTest, test3, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -115,1 +117,1 @@\n-                  %13 : #IntersectionTypeTest::test3(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                  %13 : #X<&m<IntersectionTypeTest, test3, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -139,3 +141,3 @@\n-            func @\"test4\" (%0 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>)void -> {\n-                %1 : Var<#IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A>> = var %0 @\"x\";\n-                %2 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+            func @\"test4\" (%0 : #X<&m<IntersectionTypeTest, test4, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>)void -> {\n+                %1 : Var<#X<&m<IntersectionTypeTest, test4, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A>> = var %0 @\"x\";\n+                %2 : #X<&m<IntersectionTypeTest, test4, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -143,1 +145,1 @@\n-                %3 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %3 : #X<&m<IntersectionTypeTest, test4, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n@@ -146,1 +148,1 @@\n-                %5 : #IntersectionTypeTest::test4(IntersectionTypeTest$A)void::X<IntersectionTypeTest$A> = var.load %1;\n+                %5 : #X<&m<IntersectionTypeTest, test4, func<void, IntersectionTypeTest$A>>, IntersectionTypeTest$A> = var.load %1;\n","filename":"test\/langtools\/tools\/javac\/reflect\/IntersectionTypeTest.java","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -20,1 +20,1 @@\n-                    ()jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> -> {\n+                    ()jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<#T<PatternTest2$R, java.lang.Number>>> -> {\n@@ -22,1 +22,1 @@\n-                        %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>> = pattern.record %6 @\"(#PatternTest2$R::T<java.lang.Number> n)PatternTest2$R<#PatternTest2$R::T<java.lang.Number>>\";\n+                        %7 : jdk.incubator.code.op.ExtendedOp$Pattern$Record<PatternTest2$R<#T<PatternTest2$R, java.lang.Number>>> = pattern.record %6 @\"(#T<PatternTest2$R, java.lang.Number> n)PatternTest2$R<#T<PatternTest2$R, java.lang.Number>>\";\n","filename":"test\/langtools\/tools\/javac\/reflect\/PatternTest2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}