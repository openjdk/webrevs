{"files":[{"patch":"@@ -61,1 +61,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -433,6 +432,0 @@\n-                    \/\/ load arguments to quotableOpGetter: ExtendedOp.FACTORY and CORE_TYPE_FACTORY\n-                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.JAVA_OP_CLASS.describeConstable().get(),\n-                            \"FACTORY\", CodeReflectionSupport.OP_FACTORY_CLASS.describeConstable().get());\n-                    cob.fieldAccess(Opcode.GETSTATIC, CodeReflectionSupport.CORE_TYPE_FACTORY_CLASS.describeConstable().get(),\n-                            \"CORE_TYPE_FACTORY\",\n-                            CodeReflectionSupport.TYPE_ELEMENT_FACTORY_CLASS.describeConstable().get());\n@@ -510,4 +503,0 @@\n-        static final Class<?> JAVA_OP_CLASS;\n-        static final Class<?> OP_FACTORY_CLASS;\n-        static final Class<?> CORE_TYPE_FACTORY_CLASS;\n-        static final Class<?> TYPE_ELEMENT_FACTORY_CLASS;\n@@ -527,4 +516,0 @@\n-                JAVA_OP_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.java.JavaOp\");\n-                OP_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.OpFactory\");\n-                CORE_TYPE_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.core.CoreTypeFactory\");\n-                TYPE_ELEMENT_FACTORY_CLASS = cl.loadClass(\"jdk.incubator.code.dialect.TypeElementFactory\");\n@@ -617,1 +602,1 @@\n-        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PRIVATE + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -43,3 +43,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.OpFactory;\n-import jdk.incubator.code.dialect.core.CoreTypeFactory;\n@@ -48,1 +45,0 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -487,5 +483,8 @@\n-     * Returns the code model of the Quotable passed in.\n-     * @param q the Quotable we want to get its code model.\n-     * @return the code model of the Quotable passed in.\n-     * @apiNote If the Quotable instance is a proxy instance, then the quoted code model is inaccessible and this method\n-     * returns an empty optional.\n+     * Returns the quoted code model of the given quotable reference, if present.\n+     *\n+     * @param q the quotable reference.\n+     * @return the quoted code model or an empty optional if the\n+     *         quoted code model is unavailable.\n+     * @apiNote If the quotable reference is a proxy instance, then the\n+     *          quoted code model is unavailable and this method\n+     *          returns an empty optional.\n@@ -497,0 +496,3 @@\n+            \/\/ @@@ The interpreter implements interpretation of\n+            \/\/ lambdas using a proxy whose invocation handler\n+            \/\/ supports the internal protocol to access the quoted instance\n@@ -502,1 +504,1 @@\n-            method = oq.getClass().getMethod(\"__internal_quoted\");\n+            method = oq.getClass().getDeclaredMethod(\"__internal_quoted\");\n@@ -518,1 +520,3 @@\n-     * Returns the code model of the method body, if present.\n+     * Returns the code model of the given method's body, if present.\n+     *\n+     * @param method the method.\n@@ -542,2 +546,1 @@\n-            opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName, OpFactory.class,\n-                    TypeElementFactory.class);\n+            opMethod = method.getDeclaringClass().getDeclaredMethod(opMethodName);\n@@ -549,1 +552,1 @@\n-            FuncOp funcOp = (FuncOp) opMethod.invoke(null, JavaOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+            FuncOp funcOp = (FuncOp) opMethod.invoke(null);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import jdk.incubator.code.dialect.OpFactory;\n@@ -60,1 +59,0 @@\n-import jdk.incubator.code.dialect.TypeElementFactory;\n@@ -93,2 +91,2 @@\n-    private static final MethodTypeDesc opMethodDesc = MethodTypeDesc.of(Op.class.describeConstable().get(),\n-            OpFactory.class.describeConstable().get(), TypeElementFactory.class.describeConstable().get());\n+\n+    private static final MethodTypeDesc OP_METHOD_DESC = MethodTypeDesc.of(Op.class.describeConstable().get());\n@@ -168,2 +166,2 @@\n-                    clb.withMethod(\"op$lambda$\" + i, opMethodDesc,\n-                        ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n+                    clb.withMethod(\"op$lambda$\" + i, OP_METHOD_DESC,\n+                        ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC | ClassFile.ACC_SYNTHETIC, mb -> mb.withCode(cb -> cb\n@@ -903,1 +901,1 @@\n-                                                opMethodDesc)));\n+                                                OP_METHOD_DESC)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/bytecode\/BytecodeGenerator.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+package jdk.incubator.code.dialect;\n+\n+\/**\n+ * A dialect factory for constructing a dialect's operations and type elements from their\n+ * externalized form.\n+ *\n+ * @param opFactory the operation factory.\n+ * @param typeElementFactory the type element factory.\n+ *\/\n+public record DialectFactory(OpFactory opFactory, TypeElementFactory typeElementFactory) {\n+\n+    \/\/ OpFactory\n+    \/\/ OpDeclaration\n+    \/\/ TypeElementFactory\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/DialectFactory.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -30,1 +30,2 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.DialectFactory;\n+import jdk.incubator.code.dialect.core.*;\n@@ -33,3 +34,0 @@\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.core.TupleType;\n-import jdk.incubator.code.dialect.core.VarType;\n@@ -5299,0 +5297,3 @@\n+    public static final DialectFactory DIALECT_FACTORY = new DialectFactory(\n+            FACTORY,\n+            CoreTypeFactory.CORE_TYPE_FACTORY);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,4 @@\n+    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n+            Op.Result.class, Op.class);\n+    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n+            Block.Parameter.class, TypeElement.class);\n@@ -32,4 +36,0 @@\n-    private final Symbol.ClassSymbol currClassSym;\n-    private final CodeReflectionSymbols crSym;\n-    private Symbol.MethodSymbol ms;\n-    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n@@ -37,4 +37,1 @@\n-    private static final MethodRef M_BLOCK_BUILDER_OP = MethodRef.method(Block.Builder.class, \"op\",\n-            Op.Result.class, Op.class);\n-    private static final MethodRef M_BLOCK_BUILDER_PARAM = MethodRef.method(Block.Builder.class, \"parameter\",\n-            Block.Parameter.class, TypeElement.class);\n+    private int localVarCount = 0; \/\/ used to name variables we introduce in the AST\n@@ -43,1 +40,1 @@\n-                          Types types, Env<AttrContext> attrEnv, CodeReflectionSymbols crSym) {\n+                          Types types, Env<AttrContext> attrEnv) {\n@@ -50,2 +47,0 @@\n-        this.currClassSym = attrEnv.enclClass.sym;\n-        this.crSym = crSym;\n@@ -112,1 +107,2 @@\n-    public JCTree.JCMethodDecl transformFuncOpToAST(CoreOp.FuncOp funcOp, Name methodName) {\n+    public JCTree.JCStatement transformFuncOpToAST(CoreOp.FuncOp funcOp, MethodSymbol ms) {\n+        Assert.check(funcOp.parameters().isEmpty());\n@@ -115,9 +111,0 @@\n-        var paramTypes = List.of(crSym.opFactoryType, crSym.typeElementFactoryType);\n-        var mt = new Type.MethodType(paramTypes, crSym.opType, List.nil(), syms.methodClass);\n-        ms = new Symbol.MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currClassSym);\n-        currClassSym.members().enter(ms);\n-\n-        for (int i = 0; i < funcOp.parameters().size(); i++) {\n-            valueToTree.put(funcOp.parameters().get(i), treeMaker.Ident(ms.params().get(i)));\n-        }\n-\n@@ -133,1 +120,1 @@\n-                l.add(((Op)ce).result());\n+                l.add(((Op) ce).result());\n@@ -154,1 +141,1 @@\n-        return treeMaker.MethodDef(ms, mb);\n+        return mb;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeModelToAST.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.code.Symbol;\n@@ -51,7 +50,0 @@\n-    public final Type funcOpType;\n-    public final Type opFactoryType;\n-    public final Type typeElementFactoryType;\n-    public final Type javaOpType;\n-    public final Type coreTypeFactoryType;\n-    public final Symbol.VarSymbol javaOpFactorySym;\n-    public final Symbol.VarSymbol coreTypeFactorySym;\n@@ -68,1 +60,0 @@\n-        funcOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreOp$FuncOp\");\n@@ -87,8 +78,0 @@\n-        opFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.OpFactory\");\n-        typeElementFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.TypeElementFactory\");\n-        javaOpType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.java.JavaOp\");\n-        coreTypeFactoryType = syms.enterClass(jdk_incubator_code, \"jdk.incubator.code.dialect.core.CoreTypeFactory\");\n-        javaOpFactorySym = new Symbol.VarSymbol(PUBLIC | STATIC, names.fromString(\"FACTORY\"), opFactoryType,\n-                javaOpType.tsym);\n-        coreTypeFactorySym = new Symbol.VarSymbol(PUBLIC | STATIC, names.fromString(\"CORE_TYPE_FACTORY\"), typeElementFactoryType,\n-                coreTypeFactoryType.tsym);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/CodeReflectionSymbols.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -105,5 +106,1 @@\n-import static com.sun.tools.javac.code.Flags.NOOUTERTHIS;\n-import static com.sun.tools.javac.code.Flags.PARAMETER;\n-import static com.sun.tools.javac.code.Flags.PUBLIC;\n-import static com.sun.tools.javac.code.Flags.STATIC;\n-import static com.sun.tools.javac.code.Flags.SYNTHETIC;\n+import static com.sun.tools.javac.code.Flags.*;\n@@ -278,5 +275,1 @@\n-                        JCFieldAccess opFactory = make.Select(make.Ident(crSyms.javaOpType.tsym),\n-                                crSyms.javaOpFactorySym);\n-                        JCFieldAccess typeFactory = make.Select(make.Ident(crSyms.coreTypeFactoryType.tsym),\n-                                crSyms.coreTypeFactorySym);\n-                        JCMethodInvocation op = make.App(opMethodId, com.sun.tools.javac.util.List.of(opFactory, typeFactory));\n+                        JCMethodInvocation op = make.App(opMethodId);\n@@ -414,1 +407,8 @@\n-        switch (codeModelStorageOption) {\n+        \/\/ Create the method that constructs the code model stored in the class file\n+        var mt = new MethodType(com.sun.tools.javac.util.List.nil(), crSyms.opType,\n+                com.sun.tools.javac.util.List.nil(), syms.methodClass);\n+        var ms = new MethodSymbol(PRIVATE | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n+        currentClassSym.members().enter(ms);\n+\n+        \/\/ Create the method body\n+        var body = switch (codeModelStorageOption) {\n@@ -416,5 +416,2 @@\n-                var paramTypes = com.sun.tools.javac.util.List.of(crSyms.opFactoryType, crSyms.typeElementFactoryType);\n-                var mt = new MethodType(paramTypes, crSyms.opType,\n-                        com.sun.tools.javac.util.List.nil(), syms.methodClass);\n-                var ms = new MethodSymbol(PUBLIC | STATIC | SYNTHETIC, methodName, mt, currentClassSym);\n-                currentClassSym.members().enter(ms);\n+                \/\/ Code model is stored in textual form as a constant string\n+                \/\/ and is constructed by parsing the string\n@@ -423,3 +420,1 @@\n-                var ret = make.Return(opFromStr);\n-                var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(ret)));\n-                return md;\n+                yield make.Return(opFromStr);\n@@ -428,3 +423,7 @@\n-                var opBuilder = OpBuilder.createBuilderFunction(op);\n-                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym), crSyms);\n-                return cmToASTTransformer.transformFuncOpToAST(opBuilder, methodName);\n+                \/\/ Code model is stored as code that builds the code model\n+                \/\/ using the builder API and public APIs\n+                var opBuilder = OpBuilder.createBuilderFunction(op,\n+                        b -> b.op(JavaOp.fieldLoad(\n+                                FieldRef.field(JavaOp.class, \"DIALECT_FACTORY\", DialectFactory.class))));\n+                var cmToASTTransformer = new CodeModelToAST(make, names, syms, resolve, types, typeEnvs.get(currentClassSym));\n+                yield cmToASTTransformer.transformFuncOpToAST(opBuilder, ms);\n@@ -432,3 +431,4 @@\n-            case null, default ->\n-                    throw new IllegalStateException(\"unknown code model storage option: \" + codeModelStorageOption);\n-        }\n+        };\n+\n+        var md = make.MethodDef(ms, make.Block(0, com.sun.tools.javac.util.List.of(body)));\n+        return md;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-                            public Quoted __internal_quoted() {\n+                            private Quoted __internal_quoted() {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n@@ -36,0 +37,1 @@\n+import java.util.function.Function;\n@@ -53,0 +55,6 @@\n+    static final MethodRef DIALECT_FACTORY_OP_FACTORY = MethodRef.method(DialectFactory.class, \"opFactory\",\n+            OpFactory.class);\n+\n+    static final MethodRef DIALECT_FACTORY_TYPE_ELEMENT_FACTORY = MethodRef.method(DialectFactory.class, \"typeElementFactory\",\n+            TypeElementFactory.class);\n+\n@@ -115,3 +123,1 @@\n-    static final FunctionType BUILDER_F_TYPE = functionType(type(Op.class),\n-            type(OpFactory.class),\n-            type(TypeElementFactory.class));\n+    static final FunctionType BUILDER_F_TYPE = functionType(type(Op.class));\n@@ -120,1 +126,1 @@\n-    Map<Value, Value> valueMap;\n+    final Map<Value, Value> valueMap;\n@@ -122,1 +128,1 @@\n-    Map<Block, Value> blockMap;\n+    final Map<Block, Value> blockMap;\n@@ -124,1 +130,1 @@\n-    Map<ExternalizedTypeElement, Value> exTypeElementMap;\n+    final Map<ExternalizedTypeElement, Value> exTypeElementMap;\n@@ -126,1 +132,1 @@\n-    Map<TypeElement, Value> typeElementMap;\n+    final Map<TypeElement, Value> typeElementMap;\n@@ -128,1 +134,1 @@\n-    Block.Builder builder;\n+    final Block.Builder builder;\n@@ -130,1 +136,1 @@\n-    Value opFactory;\n+    final Value dialectFactory;\n@@ -132,1 +138,3 @@\n-    Value typeElementFactory;\n+    final Value opFactory;\n+\n+    final Value typeElementFactory;\n@@ -136,0 +144,5 @@\n+     * <p>\n+     * This method initially applies the function {@code dialectFactoryF} to\n+     * the block builder that is used to build resulting code model. The result\n+     * is a dialect factory value which is subsequently used to build operations\n+     * that construct type elements and operations present in the given code model.\n@@ -137,1 +150,2 @@\n-     * @param op the code model\n+     * @param op the code model.\n+     * @param dialectFactoryF a function that builds code items to produce a dialect factory value.\n@@ -140,2 +154,2 @@\n-    public static FuncOp createBuilderFunction(Op op) {\n-        return new OpBuilder().build(op);\n+    public static FuncOp createBuilderFunction(Op op, Function<Block.Builder, Value> dialectFactoryF) {\n+        return new OpBuilder(dialectFactoryF).build(op);\n@@ -144,1 +158,1 @@\n-    OpBuilder() {\n+    OpBuilder(Function<Block.Builder, Value> dialectFactoryF) {\n@@ -149,1 +163,0 @@\n-    }\n@@ -151,1 +164,0 @@\n-    FuncOp build(Op op) {\n@@ -153,0 +165,5 @@\n+        this.builder = body.entryBlock();\n+        this.dialectFactory = dialectFactoryF.apply(builder);\n+        this.opFactory = builder.op(invoke(DIALECT_FACTORY_OP_FACTORY, dialectFactory));\n+        this.typeElementFactory = builder.op(invoke(DIALECT_FACTORY_TYPE_ELEMENT_FACTORY, dialectFactory));\n+    }\n@@ -154,4 +171,1 @@\n-        builder = body.entryBlock();\n-        opFactory = builder.parameters().get(0);\n-        typeElementFactory = builder.parameters().get(1);\n-\n+    FuncOp build(Op op) {\n@@ -162,1 +176,1 @@\n-        return func(\"builder.\" + op.opName(), body);\n+        return func(\"builder.\" + op.opName(), builder.parentBody());\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/writer\/OpBuilder.java","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import jdk.incubator.code.dialect.DialectFactory;\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -124,1 +126,2 @@\n-        CoreOp.FuncOp fb = OpBuilder.createBuilderFunction(fExpected);\n+        CoreOp.FuncOp fb = OpBuilder.createBuilderFunction(fExpected,\n+                b -> b.parameter(JavaType.type(DialectFactory.class)));\n@@ -126,1 +129,1 @@\n-                fb, JavaOp.FACTORY, CoreTypeFactory.CORE_TYPE_FACTORY);\n+                fb, JavaOp.DIALECT_FACTORY);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/writer\/TestCodeBuilder.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}