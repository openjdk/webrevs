{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.code.CodeTransformer;\n@@ -312,1 +313,1 @@\n-                IO.println(OpTkl.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n+                IO.println(kernelCallGraph.entrypoint.funcOp().transform(CodeTransformer.LOWERING_TRANSFORMER).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-        var here = CallSite.of(C99JExtractedBackend.class, \"createCode\");\n-        builder.defines().types();\n+         builder.defines().types();\n@@ -100,4 +99,0 @@\n-        \/\/ Sorting by rank ensures we don't need forward declarations\n-     \/\/   kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-       \/\/         .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(buildContext,kernelReachableResolvedMethod.funcOp()).nl());\n-\n@@ -106,5 +101,0 @@\n-        System.out.println(\"Original\");\n-        System.out.println(kernelCallGraph.entrypoint.funcOp().toText());\n-        System.out.println(\"Lowered\");\n-        System.out.println(OpTkl.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n-\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import optkl.ifacemapper.AccessType;\n-import optkl.util.CallSite;\n@@ -33,0 +31,1 @@\n+import optkl.ifacemapper.AccessType;\n@@ -39,0 +38,1 @@\n+import optkl.util.CallSite;\n@@ -47,0 +47,1 @@\n+import static optkl.OpTkl.transform;\n@@ -84,2 +85,2 @@\n-                    CoreOp.FuncOp ssaInline =SSA.transform(inline.transform(CodeTransformer.LOWERING_TRANSFORMER));\n-                    Block.Builder exit = Inliner.inline(\n+                    var ssaInline =SSA.transform(inline.transform(CodeTransformer.LOWERING_TRANSFORMER));\n+                    var exitBlockBuilder = Inliner.inline(\n@@ -97,2 +98,2 @@\n-                    if (!exit.parameters().isEmpty()) {\n-                        blockbuilder.context().mapValue(invoke.op().result(), exit.parameters().getFirst());\n+                    if (!exitBlockBuilder.parameters().isEmpty()) {\n+                        blockbuilder.context().mapValue(invoke.op().result(), exitBlockBuilder.parameters().getFirst());\n@@ -101,1 +102,1 @@\n-                    return exit.rebind(blockbuilder.context(), blockbuilder.transformer());\n+                    return exitBlockBuilder.rebind(blockbuilder.context(), blockbuilder.transformer());\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -329,2 +330,0 @@\n-\n-      \/\/  private final TypeElement elementType;\n@@ -334,3 +333,2 @@\n-        public HATVectorSelectStoreOp(String varName, TypeElement resultType, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n-            super(varName, resultType, resultType, -1, operands);\n-          \/\/  this.elementType = typeElement;\n+        public HATVectorSelectStoreOp(String varName,  int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n+            super(varName, JavaType.VOID, JavaType.VOID, -1, operands);\n@@ -343,1 +341,0 @@\n-         \/\/   this.elementType = that.elementType;\n@@ -352,6 +349,0 @@\n-\n-      \/\/  @Override\n-        \/\/public TypeElement resultType() {\n-          \/\/  return elementType;\n-       \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorOp.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -85,6 +85,0 @@\n-    \/\/recursive\n-    private static boolean isOperandF32(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return isOperandF32(varLoadOp.operands().getFirst());\n-    }\n-\n-    \/\/recursive\n@@ -93,1 +87,1 @@\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> isOperandF32(varLoadOp); \/\/recurse\n+            case CoreOp.VarAccessOp varLoadOp -> varLoadOp.varType().valueType() ==JavaType.FLOAT; \/\/recurse\n@@ -190,1 +184,1 @@\n-        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().getFirst());\n+        boolean isFirstOperandReference = findReference(lookup(),invokeOp.operands().get(0));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFP16Phase.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n@@ -35,2 +38,1 @@\n-import optkl.util.CallSite;\n-import optkl.util.Regex;\n+import optkl.OpTkl;\n@@ -39,2 +41,0 @@\n-import java.util.HashSet;\n-import java.util.List;\n@@ -42,1 +42,0 @@\n-import java.util.Set;\n@@ -46,1 +45,0 @@\n-import static optkl.OpTkl.transform;\n@@ -51,61 +49,30 @@\n-    int laneIdxOrThrow(String fieldName) {\n-        return \"xyzw\".indexOf(fieldName.charAt(0));\n-     \/*   return switch (fieldName) {\n-            case \"x\" -> 0;\n-            case \"y\" -> 1;\n-            case \"z\" -> 2;\n-            case \"w\" -> 3;\n-            default -> throw new RuntimeException(\"fieldName not x,y,z,w\");\n-        };*\/\n-    }\n-\n-    \/\/ recursive\n-    private String vectorNameOrThrow(Value v) {\n-       return switch (asOpFromResultOrNull(v)){\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->vectorNameOrThrow(varLoadOp.operands().getFirst()); \/\/ recurse\n-            case HATVectorOp vectorOp ->vectorOp.varName();\n-            default -> throw new IllegalStateException(\"failed to find vector name\");\n-        };\n-    }\n-\n-\n-    \/\/recursive\n-    private CoreOp.VarOp findVarOpOrNull(Value v) {\n-        return switch (asOpFromResultOrNull(v)){\n-            case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->findVarOpOrNull(varLoadOp.operands().getFirst()); \/\/recurse\n-            case CoreOp.VarOp varOp->varOp;\n-            default ->  null;\n-        };\n-    }\n-\n-    \/\/ Code Model Pattern:\n-    \/\/  %16 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"63:28\";\n-    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.types.Float4::x():float\";\n-    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n-        var here = CallSite.of(this.getClass(), \"vloadSelectPhase\");\n-        before(here, funcOp);\n-        Set<CoreOp.VarAccessOp.VarLoadOp> varLoadOps =new HashSet<>();\n-        Map<JavaOp.InvokeOp, String> invokeToVectorName = new HashMap<>();\n-        Invoke.stream(lookup(),funcOp)\n-                .filter(invoke -> !invoke.returnsVoid() && invoke.named(\"x\",\"y\",\"z\",\"w\") && invoke.refIs(_V.class))\n-                .forEach(invoke -> {\n-                    var varLoadOp = invoke.varLoadOpFromFirstOperandAsResultOrThrow();\n-                    invokeToVectorName.put(invoke.op(), vectorNameOrThrow(varLoadOp.operands().getFirst()));\n-                    varLoadOps.add(varLoadOp);\n-                });\n-\n-        funcOp = transform(here, funcOp\n-                ,ce-> (varLoadOps.contains(ce)||invokeToVectorName.containsKey(ce)),\n-                (blockBuilder, op) -> {\n-            if (invokeOpHelper(lookup(), op) instanceof Invoke invoke) {\n-                blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(\n-                        copyLocation(invoke.op(), new HATVectorOp.HATVectorSelectLoadOp(\n-                                        invokeToVectorName.get(invoke.op()),\n-                                        invoke.returnType(),\n-                                        laneIdxOrThrow(invoke.name()),\n-                                        blockBuilder.context().getValues(invoke.op().operands())\n-                                )\n-                        )\n-                ));\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                blockBuilder.context().mapValue(varLoadOp.result(), blockBuilder.context().getValue(varLoadOp.operands().getFirst()));\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n+        record InvokeVar(JavaOp.InvokeOp invokeOp, CoreOp.VarAccessOp.VarLoadOp varLoadOp){\n+            \/\/ recursive\n+            static String vectorNameOrThrow(Value v) {\n+                return switch (asOpFromResultOrNull(v)){\n+                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->vectorNameOrThrow(varLoadOp.operands().getFirst()); \/\/ recurse\n+                    case HATVectorOp vectorOp ->vectorOp.varName();\n+                    default -> throw new IllegalStateException(\"failed to find vector name\");\n+                };\n+            }\n+            String name(){\n+                return vectorNameOrThrow(varLoadOp.operands().getFirst());\n+            }\n+            \/\/recursive\n+            private CoreOp.VarOp findVarOpOrNull(Value v) {\n+                return switch (asOpFromResultOrNull(v)){\n+                    case CoreOp.VarAccessOp.VarLoadOp varLoadOp ->findVarOpOrNull(varLoadOp.operands().getFirst()); \/\/recurse\n+                    case CoreOp.VarOp varOp->varOp;\n+                    default ->  null;\n+                };\n+            }\n+            public CoreOp.VarOp varOpFromOperand(int idx){\n+                return findVarOpOrNull(invokeOp.operands().get(idx));\n+            }\n+            public TypeElement returnType() {\n+                return invokeOp.resultType();\n+            }\n+            int laneIdx() {\n+                return \"xyzw\".indexOf(invokeOp.invokeDescriptor().name().charAt(0));\n@@ -113,2 +80,0 @@\n-            return blockBuilder;\n-        });\n@@ -116,3 +81,1 @@\n-        after(here, funcOp);\n-        return funcOp;\n-    }\n+        }\n@@ -120,9 +83,1 @@\n-    \/\/ Pattern from the code mode:\n-    \/\/ %20 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"64:13\";\n-    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n-    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.types.Float4::x(float):void\";\n-    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n-        var here = CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n-        before(here, funcOp);\n-        Set<CoreOp.VarAccessOp.VarLoadOp> varLoads = new HashSet<>();\n-        Map<JavaOp.InvokeOp, CoreOp.VarAccessOp.VarLoadOp> invokeToVarLoadOp  = new HashMap<>();\n+        Map<CodeElement<?,?>, InvokeVar> ceToInvokeVar = new HashMap<>();\n@@ -130,5 +85,10 @@\n-                .filter($ -> $.named(\"x\",\"y\",\"z\",\"w\") && $.returnsVoid() &&  $.refIs(_V.class))\n-                .forEach($ ->{\n-                    var varLoadOp = $.varLoadOpFromFirstOperandAsResultOrThrow();\n-                    invokeToVarLoadOp.put($.op(),varLoadOp);\n-                    varLoads.add(varLoadOp);\n+                .filter(invoke ->\n+                        invoke.named(\"x\",\"y\",\"z\",\"w\")\n+                                && invoke.refIs(_V.class)\n+                                && invoke.opFromFirstOperandAsResultOrThrow() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                .map(invoke ->\n+                        new InvokeVar(invoke.op(),invoke.varLoadOpFromFirstOperandAsResultOrNull())\n+                )\n+                .forEach(invokeVar ->{\n+                    ceToInvokeVar.put(invokeVar.invokeOp,invokeVar);\n+                    ceToInvokeVar.put(invokeVar.varLoadOp,invokeVar);\n@@ -137,3 +97,1 @@\n-        funcOp = transform(here, funcOp,\n-                ce->varLoads.contains(ce)||invokeToVarLoadOp.containsKey(ce), \/\/ only the nodes we mapped\/selected\n-                (blockBuilder, op) -> {\n+        funcOp = OpTkl.transform( funcOp, ceToInvokeVar::containsKey,(blockBuilder, op) -> {\n@@ -141,10 +99,13 @@\n-            if (invokeOpHelper(lookup(),op) instanceof Invoke invoke) {\n-                List<Value> outputOperandsInvokeOp = context.getValues( invoke.op().operands());\n-                context.mapValue(invoke.op().result(), blockBuilder.op(copyLocation(invoke.op(), new HATVectorOp.HATVectorSelectStoreOp(\n-                                vectorNameOrThrow(invokeToVarLoadOp.get(invoke.op()).operands().getFirst()),\n-                                invoke.returnType(),\n-                                laneIdxOrThrow(invoke.name()),\n-                                \/\/ The operand 1 in the store is the address (lane)\n-                                \/\/ The operand 1 in the store is the storeValue\n-                                findVarOpOrNull(outputOperandsInvokeOp.get(1)),\n-                                outputOperandsInvokeOp\n+            if (invokeOpHelper(lookup(),op) instanceof Invoke invoke\n+                    && ceToInvokeVar.get(invoke.op()) instanceof InvokeVar invokeVar) {\n+                Op newOp = invoke.returnsVoid()\n+                        ?\n+                        \/\/ Code Model Pattern:\n+                        \/\/  %16 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"63:28\";\n+                        \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.types.Float4::x():float\";\n+\n+                        new HATVectorOp.HATVectorSelectStoreOp(\n+                                invokeVar.name(),\n+                                invokeVar.laneIdx(),\n+                                invokeVar.varOpFromOperand(1),\n+                                context.getValues(invokeVar.invokeOp.operands())\n@@ -152,1 +113,14 @@\n-                )));\n+                        :\n+                        \/\/ Pattern from the code mode:\n+                        \/\/ %20 : java.type:\"hat.types.Float4\" = var.load %15 @loc=\"64:13\";\n+                        \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n+                        \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.types.Float4::x(float):void\";\n+                        new HATVectorOp.HATVectorSelectLoadOp(\n+                                invokeVar.name(),\n+                                invokeVar.returnType(),\n+                                invokeVar.laneIdx(),\n+                                context.getValues(invokeVar.invokeOp.operands())\n+                        );\n+\n+                context.mapValue(invokeVar.invokeOp.result(), blockBuilder.op(\n+                        copyLocation(invokeVar.invokeOp, newOp)));\n@@ -159,8 +133,0 @@\n-        after(here, funcOp);\n-        return funcOp;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp apply(CoreOp.FuncOp funcOp) {\n-        funcOp = vloadSelectPhase(funcOp);\n-        funcOp = vstoreSelectPhase(funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorSelectPhase.java","additions":74,"deletions":108,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import optkl.OpTkl;\n@@ -50,1 +51,0 @@\n-import static optkl.OpTkl.transform;\n@@ -83,2 +83,0 @@\n-\n-\n@@ -87,6 +85,1 @@\n-        var here = CallSite.of(this.getClass(), \"apply\");\n-        String vectorOperation = switch (this) {\n-            case Float2StorePhase _ -> \"storeFloat2View\";\n-            case Float4StorePhase _ -> \"storeFloat4View\";\n-        };\n-        before(here,funcOp);\n+\n@@ -97,1 +90,5 @@\n-                            && invoke.named(vectorOperation)\n+                            && invoke.named(\n+                            switch (HATVectorStorePhase.this) {\n+                               case Float2StorePhase _ -> \"storeFloat2View\";\n+                               case Float4StorePhase _ -> \"storeFloat4View\";\n+                            })\n@@ -106,1 +103,1 @@\n-           funcOp = transform(here, funcOp,_->true, (blockBuilder, op) -> {\n+           funcOp = OpTkl.transform(CallSite.of(this.getClass()), funcOp, _->true, (blockBuilder, op) -> {\n@@ -129,1 +126,0 @@\n-        after(here, funcOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATVectorStorePhase.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-       \/\/ try {\n@@ -55,13 +54,0 @@\n-          \/*  var basicType = javaType.toBasicType();\n-            var resolveType = basicType.resolve(lookup());\n-            var isit2 = resolveType.getTypeName().equals(clazz.getName());\n-            var resolveTypeClass = resolveType.getClass();\n-            var isit3 = clazz.isAssignableFrom(resolveTypeClass);\n-            var isit4 = resolveTypeClass.isAssignableFrom(clazz);\n-            \/\/ System.out.println(\"isit1=\"+isit1+\",isit2=\"+isit2+\",isit3=\"+isit3+\",isit4=\"+isit4);\n-            return  isit1;*\/\n-\n-        \/\/} catch (ReflectiveOperationException e) {\n-          \/\/  System.out.println(\"Hmm\");\n-            \/\/throw new RuntimeException(e);\n-       \/\/ }\n@@ -109,7 +95,0 @@\n-    default CoreOp.VarAccessOp.VarLoadOp varLoadOpFromFirstOperandAsResultOrThrow() {\n-        if (varLoadOpFromFirstOperandAsResultOrNull() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return varLoadOp;\n-        } else {\n-            throw new IllegalStateException(\"Expecting first operand to be a result which yields an VarLoadOp \");\n-        }\n-    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -277,6 +277,0 @@\n-    static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n-        if (callSite.tracing()) {\n-            System.out.println(callSite);\n-        }\n-        return funcOp.transform(CodeTransformer.LOWERING_TRANSFORMER);\n-    }\n@@ -302,2 +296,2 @@\n-    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n-        if (callSite.tracing()) {\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<CodeElement<?,?>> predicate, CodeTransformer codeTransformer) {\n+        if (callSite!= null && callSite.tracing()) {\n@@ -308,1 +302,1 @@\n-                var builder = CodeTransformer.acceptOp(blockBuilder, op);\n+                var builder = codeTransformer.acceptOp(blockBuilder, op);\n@@ -318,0 +312,3 @@\n+    static CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Predicate<CodeElement<?,?>> predicate, CodeTransformer codeTransformer) {\n+       return OpTkl.transform(null, funcOp,predicate,codeTransformer);\n+    }\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpTkl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"}]}