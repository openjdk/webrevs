{"files":[{"patch":"@@ -33,0 +33,6 @@\n+      class MockQueue : public Backend::Queue {\n+        public :\n+         MockQueue():Backend::Queue(){}\n+         virtual ~MockQueue(){}\n+        };\n+\n@@ -68,2 +74,2 @@\n-    MockBackend(MockConfig *mockConfig, int mockConfigSchemeLen, char *mockBackendSchema)\n-            : Backend(mockConfig, mockConfigSchemeLen, mockBackendSchema) {\n+    MockBackend(MockConfig *mockConfig, int mockConfigSchemeLen, char *mockBackendSchema, MockQueue *mockQueue)\n+            : Backend(mockConfig, mockConfigSchemeLen, mockBackendSchema, mockQueue) {\n@@ -102,1 +108,2 @@\n-    return (long) new MockBackend(mockConfig, configSchemaLen, configSchema);\n+    MockBackend::MockQueue *mockQueue = (MockBackend::MockQueue *) new MockBackend::MockQueue();\n+    return (long) new MockBackend(mockConfig, configSchemaLen, configSchema, mockQueue);\n","filename":"hat\/backends\/ffi\/mock\/cpp\/mock_backend.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,1 +46,12 @@\n-    arg->value.buffer.vendorPtr = static_cast<void *>(this);\n+\n+    BufferState_s * bufferState = BufferState_s::of(\n+      arg->value.buffer.memorySegment,\n+      arg->value.buffer.sizeInBytes\n+      );\n+    if (INFO){\n+       bufferState->dump(\"on allocation before assign\");\n+    }\n+    bufferState->vendorPtr =  static_cast<void *>(this);\n+    if (INFO){\n+        bufferState->dump(\"after assign \");\n+    }\n@@ -61,1 +72,1 @@\n-    cl_int status = clEnqueueWriteBuffer(openclBackend->command_queue,\n+    cl_int status = clEnqueueWriteBuffer( dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->command_queue,\n@@ -67,3 +78,3 @@\n-                                         openclKernel->eventc,\n-                                         ((openclKernel->eventc == 0) ? NULL : openclKernel->events),\n-                                         &(openclKernel->events[openclKernel->eventc]));\n+                                         dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc,\n+                                         ((dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc == 0) ? NULL : dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events),\n+                                         &(dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events[dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc]));\n@@ -79,1 +90,1 @@\n-    openclKernel->eventc++;\n+    dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc++;\n@@ -88,1 +99,1 @@\n-    cl_int status = clEnqueueReadBuffer(openclBackend->command_queue,\n+    cl_int status = clEnqueueReadBuffer( dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->command_queue,\n@@ -94,3 +105,3 @@\n-                                        openclKernel->eventc,\n-                                        ((openclKernel->eventc == 0) ? NULL : openclKernel->events),\n-                                        &(openclKernel->events[openclKernel->eventc]));\n+                                        dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc,\n+                                        ((dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc == 0) ? NULL : dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events),\n+                                        &(dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->events[dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc]));\n@@ -102,1 +113,1 @@\n-    openclKernel->eventc++;\n+    dynamic_cast<OpenCLQueue *>(openclKernel->program->backend->queue)->eventc++;\n@@ -113,2 +124,1 @@\n-        : Backend::Program::Kernel(program, name), kernel(kernel), eventMax(0), events(nullptr),\n-          eventc(0) {\n+        : Backend::Program::Kernel(program, name), kernel(kernel){\n@@ -127,6 +137,7 @@\n-    if (events != nullptr || eventc != 0) {\n-        std::cerr << \"opencl issue, we might have leaked events!\" << std::endl;\n-    }\n-    eventMax = argSled.argc() * 4 + 1;\n-    eventc = 0;\n-    events = new cl_event[eventMax];\n+   \/\/ if (events != nullptr || eventc != 0) {\n+     \/\/   std::cerr << \"opencl issue, we might have leaked events!\" << std::endl;\n+    \/\/}\n+   \/\/ eventMax = argSled.argc() * 4 + 1;\n+    \/\/eventc = 0;\n+   \/\/ events = new cl_event[eventMax];\n+    OpenCLQueue *openclQueue = dynamic_cast<OpenCLQueue *>(program->backend->queue);\n@@ -141,27 +152,0 @@\n-                }else{\n-                   IfaceBufferBits_s *ifacebufferbitz = IfaceBufferBits_s::of(\n-                      arg->value.buffer.memorySegment,\n-                      arg->value.buffer.sizeInBytes\n-                   );\n-                   if (ifacebufferbitz->ok()){\n-                      if (INFO){\n-                         if (ifacebufferbitz->isJavaDirty()){\n-                             printf(\" java dirty (javaDirty:%08x)\\n\", ifacebufferbitz->payload.javaDirty);\n-                         }else{\n-                            printf(\" NOT java dirty (javaDirty:%08x)\\n\", ifacebufferbitz->payload.javaDirty);\n-                         }\n-                         if (ifacebufferbitz->isGpuDirty()){\n-                            printf(\" gpu dirty (gpuDirty:%08x)\\n\", ifacebufferbitz->payload.gpuDirty);\n-                         }else{\n-                            printf(\" NOT gpu dirty (gpuDirty:%08x)\\n\", ifacebufferbitz->payload.gpuDirty);\n-                         }\n-                      }\n-                   }else{\n-                      printf(\"bad magic \\n\");\n-                      printf(\"(magic1:%016lx,\", ifacebufferbitz->magic1);\n-                      printf(\"javaDirty:%08x,\", ifacebufferbitz->payload.javaDirty);\n-                      printf(\"gpuDirty:%08x,\", ifacebufferbitz->payload.gpuDirty);\n-                      printf(\"unused[0]:%08x,\", ifacebufferbitz->payload.unused[0]);\n-                      printf(\"unused[1]:%08x,\", ifacebufferbitz->payload.unused[1]);\n-                      printf(\"magic2:%016lx)\\n\", ifacebufferbitz->magic2);\n-                   }\n@@ -217,1 +201,1 @@\n-                std::cerr << \"unexpected variant \" << (char) arg->variant << std::endl;\n+                std::cerr << \"unexpected variant (ndrange) \" << (char) arg->variant << std::endl;\n@@ -229,1 +213,1 @@\n-            dynamic_cast<OpenCLBackend *>(program->backend)->command_queue,\n+            openclQueue->command_queue,\n@@ -235,3 +219,3 @@\n-            eventc,\n-            ((eventc == 0) ? nullptr : events),\n-            &(events[eventc]));\n+            openclQueue->eventc,\n+            (openclQueue->eventc == 0) ? nullptr : openclQueue->events,\n+            &(openclQueue->events[openclQueue->eventc]));\n@@ -247,1 +231,1 @@\n-    eventc++;\n+    openclQueue->eventc++;\n@@ -251,1 +235,9 @@\n-            static_cast<OpenCLBuffer *>(arg->value.buffer.vendorPtr)->copyFromDevice();\n+            BufferState_s * bufferState = BufferState_s::of(\n+              arg->value.buffer.memorySegment,\n+              arg->value.buffer.sizeInBytes\n+              );\n+            static_cast<OpenCLBuffer *>(bufferState->vendorPtr)->copyFromDevice();\n+            if (INFO){\n+               bufferState->dump(\"After copy from device\");\n+            }\n+\n@@ -254,1 +246,1 @@\n-    status = clWaitForEvents(eventc, events);\n+    status = clWaitForEvents(openclQueue->eventc, openclQueue->events);\n@@ -259,2 +251,2 @@\n-    for (int i = 0; i < eventc; i++) {\n-        status = clReleaseEvent(events[i]);\n+    for (int i = 0; i < openclQueue->eventc; i++) {\n+        status = clReleaseEvent(openclQueue->events[i]);\n@@ -266,4 +258,4 @@\n-    delete[] events;\n-    eventMax = 0;\n-    eventc = 0;\n-    events = nullptr;\n+   \/\/ delete[] events;\n+    \/\/eventMax = 0;\n+   openclQueue->eventc = 0;\n+    \/\/events = nullptr;\n@@ -273,2 +265,9 @@\n-            delete static_cast<OpenCLBuffer *>(arg->value.buffer.vendorPtr);\n-            arg->value.buffer.vendorPtr = nullptr;\n+            BufferState_s * bufferState = BufferState_s::of(\n+                      arg->value.buffer.memorySegment,\n+                      arg->value.buffer.sizeInBytes\n+                      );\n+            delete static_cast<OpenCLBuffer *>(bufferState->vendorPtr);\n+            bufferState->vendorPtr = nullptr;\n+            if (INFO){\n+               bufferState->dump(\"After deleting buffer \");\n+            }\n@@ -300,1 +299,1 @@\n-        : Backend((Backend::Config *) openclConfig, configSchemaLen, configSchema) {\n+        : Backend((Backend::Config *) openclConfig,  configSchemaLen, configSchema, (Backend::Queue *) new OpenCLQueue()) {\n@@ -349,1 +348,1 @@\n-    if ((command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL ||\n+    if ((dynamic_cast<OpenCLQueue *>(queue)->command_queue = clCreateCommandQueue(context, device_ids[0], queue_props, &status)) == NULL ||\n@@ -356,0 +355,1 @@\n+\n@@ -368,1 +368,1 @@\n-    clReleaseCommandQueue(command_queue);\n+    clReleaseCommandQueue(dynamic_cast<OpenCLQueue *>(queue)->command_queue);\n@@ -372,1 +372,2 @@\n-    cl_ulong *samples = new cl_ulong[4 * eventc]; \/\/ queued, submit, start, end\n+    OpenCLQueue * openclQueue =  dynamic_cast<OpenCLQueue *>(program->backend->queue);\n+    cl_ulong *samples = new cl_ulong[4 * openclQueue->eventc]; \/\/ queued, submit, start, end\n@@ -376,1 +377,1 @@\n-    for (int event = 0; event < eventc; event++) {\n+    for (int event = 0; event < openclQueue->eventc; event++) {\n@@ -394,1 +395,1 @@\n-            if ((clGetEventProfilingInfo(events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n+            if ((clGetEventProfilingInfo(openclQueue->events[event], info, sizeof(samples[sample]), &samples[sample], NULL)) !=\n@@ -417,1 +418,1 @@\n-    for (int event = 0; event < eventc; event++) {\n+    for (int event = 0; event < openclQueue->eventc; event++) {\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":70,"deletions":69,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -65,0 +65,10 @@\n+    class OpenCLQueue : public Backend::Queue {\n+    public:\n+       size_t eventMax;\n+       cl_event *events;\n+       size_t eventc;\n+       cl_command_queue command_queue;\n+       OpenCLQueue():Backend::Queue(), eventMax(256), events(new cl_event[eventMax]), eventc(0){\n+       }\n+       virtual ~OpenCLQueue(){}\n+    };\n@@ -72,1 +82,0 @@\n-\n@@ -74,1 +83,0 @@\n-\n@@ -76,1 +84,0 @@\n-\n@@ -78,1 +85,0 @@\n-\n@@ -84,3 +90,0 @@\n-            size_t eventMax;\n-            cl_event *events;\n-            size_t eventc;\n@@ -113,1 +116,0 @@\n-    cl_command_queue command_queue;\n@@ -115,2 +117,0 @@\n-\n-\n@@ -118,1 +118,0 @@\n-\n@@ -120,1 +119,0 @@\n-\n@@ -122,1 +120,0 @@\n-\n@@ -124,1 +121,0 @@\n-\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-                std::cerr << \"unexpected variant '\" << (char) arg->variant << \"'\" << std::endl;\n+                std::cerr << \"unexpected variant (shared.cpp) '\" << (char) arg->variant << \"'\" << std::endl;\n","filename":"hat\/backends\/ffi\/shared\/cpp\/shared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,7 +77,0 @@\n-\n- struct IfaceBufferPayload_s{\n-     int javaDirty;\n-     int gpuDirty;\n-     int unused[2];\n- };\n-\n@@ -87,1 +80,0 @@\n- #define MAGIC 0x4a71facebffab175\n@@ -89,1 +81,10 @@\n- struct IfaceBufferBits_s{\n+\n+ struct BufferState_s{\n+   static const long  MAGIC =0x4a71facebffab175;\n+   static const int   BIT_HOST_NEW =0x0004;\n+   static const int   BIT_GPU_NEW =0x0008;\n+   static const int   BIT_HOST_DIRTY =0x0001;\n+   static const int   BIT_GPU_DIRTY =0x0002;\n+   static const int   MODE_ALWAYS_COPY_OUT =0x0001;\n+   static const int   MODE_ALWAYS_COPY_IN  =0x0002;\n+   static const int   MODE_ALWAYS_COPY_IN_AND_OUT=(MODE_ALWAYS_COPY_IN | MODE_ALWAYS_COPY_OUT);\n@@ -91,1 +92,3 @@\n-   IfaceBufferPayload_s payload;\n+   int bits;\n+   int mode;\n+   void *vendorPtr;\n@@ -94,1 +97,1 @@\n-      return magic1 == MAGIC && magic2 == MAGIC;\n+      return ((magic1 == MAGIC) && (magic2 == MAGIC));\n@@ -96,2 +99,5 @@\n-   bool isJavaDirty(){\n-      return payload.javaDirty != 0;\n+   bool isHostDirty(){\n+      return  (bits&BIT_HOST_DIRTY)==BIT_HOST_DIRTY;\n+   }\n+   bool isHostNew(){\n+      return  (bits&BIT_HOST_NEW)==BIT_HOST_NEW;\n@@ -100,1 +106,7 @@\n-      return payload.gpuDirty != 0;\n+      return (bits&BIT_GPU_DIRTY)==BIT_GPU_DIRTY;\n+   }\n+   bool isModeAlwaysCopyInAndOut(){\n+      return (mode&MODE_ALWAYS_COPY_IN_AND_OUT)==MODE_ALWAYS_COPY_IN_AND_OUT;\n+   }\n+   bool isModeAlwaysCopyIn(){\n+      return (mode&MODE_ALWAYS_COPY_IN)==MODE_ALWAYS_COPY_IN;\n@@ -102,2 +114,16 @@\n-   static IfaceBufferBits_s* of(void *ptr, size_t sizeInBytes){\n-      return (IfaceBufferBits_s*) (((char*)ptr)+sizeInBytes-sizeof(IfaceBufferBits_s));\n+   bool isModeAlwaysCopyOut(){\n+      return (mode&MODE_ALWAYS_COPY_OUT)==MODE_ALWAYS_COPY_OUT;\n+   }\n+\n+   void dump(const char *msg){\n+     if (ok()){\n+        printf(\"{%s, bits:%08x, mode:%08x, vendorPtr:%016lx}\\n\", msg, bits, mode, (long)vendorPtr);\n+     }else{\n+        printf(\"%s bad magic \\n\", msg);\n+        printf(\"(magic1:%016lx,\", magic1);\n+        printf(\"{%s, bits:%08x, mode:%08x, vendorPtr:%016lx}\", msg, bits, mode, (long)vendorPtr);\n+        printf(\"magic2:%016lx)\\n\", magic2);\n+     }\n+   }\n+   static BufferState_s* of(void *ptr, size_t sizeInBytes){\n+      return (BufferState_s*) (((char*)ptr)+sizeInBytes-sizeof(BufferState_s));\n@@ -110,1 +136,0 @@\n-    void *vendorPtr;       \/\/ The vendor side can reference vendor into\n@@ -112,1 +137,0 @@\n-  \/\/  u8_t state;           \/\/ 0=UNKNOWN\/1=GPUDIRTY\/2=JAVADIRTY\n@@ -200,1 +224,1 @@\n-    void *vendorPtrPtr() {\n+    void *afterArgsPtrPtr() {\n@@ -203,1 +227,1 @@\n-    }\n+   }\n@@ -206,1 +230,1 @@\n-        int *schemaLenP = (int *) ((char *) vendorPtrPtr() + sizeof(void *));\n+        int *schemaLenP = (int *) ((char *) afterArgsPtrPtr() \/*+ sizeof(void *) *\/);\n@@ -215,1 +239,1 @@\n-        int *schemaLenP = ((int *) ((char *) vendorPtrPtr() + sizeof(void *)) + 1);\n+        int *schemaLenP = ((int *) ((char *) afterArgsPtrPtr() \/*+ sizeof(void *)*\/) + 1);\n@@ -286,0 +310,4 @@\n+    class Queue {\n+       public:\n+       virtual ~Queue() {}\n+    };\n@@ -353,0 +381,1 @@\n+    Queue *queue;\n@@ -354,2 +383,2 @@\n-    Backend(Config *config, int configSchemaLen, char *configSchema)\n-            : config(config), configSchemaLen(configSchemaLen), configSchema(configSchema) {}\n+    Backend(Config *config, int configSchemaLen, char *configSchema, Queue* queue)\n+            : config(config),  configSchemaLen(configSchemaLen), configSchema(configSchema),queue(queue) {}\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":53,"deletions":24,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+      class SpirvQueue : public Backend::Queue {\n+        public :\n+           SpirvQueue():Backend::Queue(){}\n+                 virtual ~SpirvQueue(){}\n+        };\n@@ -68,2 +73,2 @@\n-    SpirvBackend(SpirvConfig *spirvConfig, int spirvConfigSchemeLen, char *spirvBackendSchema)\n-            : Backend(spirvConfig, spirvConfigSchemeLen, spirvBackendSchema) {\n+    SpirvBackend(SpirvConfig *spirvConfig, int spirvConfigSchemeLen, char *spirvBackendSchema, SpirvQueue *spirvQueue )\n+            : Backend(spirvConfig, spirvConfigSchemeLen, spirvBackendSchema, spirvQueue) {\n@@ -102,1 +107,2 @@\n-    return (long) new SpirvBackend(spirvConfig, configSchemaLen, configSchema);\n+    SpirvBackend::SpirvQueue *spirvQueue = new SpirvBackend::SpirvQueue();\n+    return (long) new SpirvBackend(spirvConfig, configSchemaLen, configSchema, spirvQueue);\n","filename":"hat\/backends\/ffi\/spirv\/cpp\/spirv_backend.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -135,3 +135,0 @@\n- \/\/  void featureCount(int featureCount);\n-\n-\n@@ -142,3 +139,0 @@\n-  \/\/  void stageCount(int stageCount);\n-\n-\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ifaces\/Cascade.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,11 +158,0 @@\n-   \/\/ public void clearRuntimeInfo() {\n-     \/\/   runtimeInfo = new RuntimeInfo();\n-   \/\/ }\n-\n-  \/\/  public static class RuntimeInfo {\n-      \/\/  public Set<Buffer> javaDirty = new HashSet<>();\n-       \/\/ Set<Buffer> gpuDirty = new HashSet<>();\n-  \/\/  }\n-\n-  \/\/  public RuntimeInfo runtimeInfo = null;\n-\n@@ -171,3 +160,0 @@\n-       \/\/ if (runtimeInfo.gpuDirty.contains(b)) {\n-          \/\/  throw new IllegalStateException(\"We want to mutate a buffer on the java side but it is marked as gpu dirty.\");\n-       \/\/ }\n@@ -178,1 +164,0 @@\n-       \/\/ runtimeInfo.javaDirty.add(b);\n@@ -183,3 +168,0 @@\n-      \/\/  if (runtimeInfo.gpuDirty.contains(b)) {\n-        \/\/    throw new IllegalStateException(\"We want to access a buffer on the java side but it is marked as gpu dirty.\");\n-       \/\/ }\n@@ -194,3 +176,1 @@\n-       \/\/ if (runtimeInfo.gpuDirty.contains(b)) {\n-           \/\/ throw new IllegalStateException(\"We called a method which escapes a buffer on the java side but it is marked as gpu dirty.\");\n-      \/\/  }\n+\n@@ -201,1 +181,0 @@\n-      \/\/  runtimeInfo.javaDirty.add(b);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-                MemorySegment vendorPtr();\n-                void vendorPtr(MemorySegment vendorPtr);\n@@ -49,1 +47,0 @@\n-\n@@ -215,2 +212,2 @@\n-    MemorySegment vendorPtr();\n-    void vendorPtr(MemorySegment vendorPtr);\n+    \/\/MemorySegment vendorPtr();\n+    \/\/void vendorPtr(MemorySegment vendorPtr);\n@@ -230,1 +227,1 @@\n-                                                            .fields(\"address\",\"bytes\",\"vendorPtr\",\"access\")\n+                                                            .fields(\"address\",\"bytes\",\/*\"vendorPtr\",*\/\"access\")\n@@ -235,1 +232,1 @@\n-            .field(\"vendorPtr\")\n+         \/\/   .field(\"vendorPtr\")\n@@ -290,2 +287,0 @@\n-        final byte javaDirty = 1;\n-        final byte javaClean = 0;\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.VarHandle;\n@@ -41,1 +39,0 @@\n-import static hat.ifacemapper.SegmentMapper.MAGIC;\n@@ -59,1 +56,1 @@\n-    static <T extends Buffer> BoundSchema getBoundSchema(T buffer) {\n+    static <T extends Buffer> BoundSchema<?> getBoundSchema(T buffer) {\n@@ -82,80 +79,0 @@\n-\n-    \/*\n-     * A hack for accessing the tailbits from a memory segment.  Hopefully I can get this from\n-     * ifacemapper\n-     * See SegmentMapper allocate and backend_ffi_shared\/include\/shared.h\n-\n-        struct ifacebufferpayload_t{\n-          int javaDirty;\n-          int gpuDirty;\n-          int unused[2];\n-        };\n-\n-        struct ifacebufferbitz_t{\n-           long magic1; \/\/ MAGIC\n-           ifacebufferpayload_t payload;\n-           long magic2; \/\/ MAGIC\n-        }\n-     *\/\n-\n-    record Tail(Buffer buffer, MemorySegment segment, long offset ) implements MappableIface {\n-\n-        public static final long tailLength = 4 * ValueLayout.JAVA_LONG.byteSize();\n-        public static final long magic1Offset =0;\n-        public static final long magic2Offset =3 * ValueLayout.JAVA_LONG.byteSize();\n-        public static final long javaDirtyOffset =ValueLayout.JAVA_LONG.byteSize();\n-        public static final long gpuDirtyOffset =ValueLayout.JAVA_LONG.byteSize()+ValueLayout.JAVA_INT.byteSize();\n-\n-        public static Tail of(Buffer buffer) {\n-            MemorySegment segment = getMemorySegment(buffer);\n-            return new Tail(buffer, segment, segment.byteSize() - tailLength);\n-        }\n-        public long magic1(){\n-            return segment.get(ValueLayout.JAVA_LONG, offset +magic1Offset);\n-        }\n-        public int javaDirty(){\n-            return segment.get(ValueLayout.JAVA_INT, offset +javaDirtyOffset);\n-        }\n-        public boolean isJavaDirty(){\n-            return javaDirty()!=0;\n-        }\n-        public int gpuDirty(){\n-            return segment.get(ValueLayout.JAVA_INT, offset +gpuDirtyOffset);\n-        }\n-        public boolean isGpuDirty(){\n-            return gpuDirty()!=0;\n-        }\n-\n-        public long magic2(){\n-            return segment.get(ValueLayout.JAVA_LONG, offset+ magic2Offset);\n-        }\n-        public boolean isOK() {\n-            if (magic1() != MAGIC) {\n-                System.out.println(\"magic1=\" + magic1()+ \" != \" + MAGIC);\n-                return false;\n-            }\n-            if (magic2() != MAGIC) {\n-                System.out.println(\"magic2=\" + magic2() + \" != \" + MAGIC);\n-                return false;\n-            }\n-            return true;\n-        }\n-    }\n-\n-\n-    default boolean isJavaDirty(){\n-        var seg = getMemorySegment(this);\n-        if (seg != null){\n-            long sizeInBytes = seg.byteSize();\n-            long magic1 = seg.get(ValueLayout.JAVA_LONG, sizeInBytes-4*ValueLayout.JAVA_LONG.byteSize());\n-\n-            if (magic1 != MAGIC){\n-                System.out.println(\"magic1=\" + magic1+\" != \"+MAGIC);\n-            }else{\n-                System.out.println(\"magic1=\" + magic1+\" != \"+MAGIC);\n-            }\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":1,"deletions":84,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.annotation.Annotation;\n@@ -58,1 +59,1 @@\n-\n+        public CallGraph<?> callGraph;\n@@ -61,1 +62,1 @@\n-        public CallGraph<?> callGraph;\n+        private final Annotation[][] annotatedParameters;\n@@ -65,1 +66,0 @@\n-\n@@ -74,0 +74,10 @@\n+            this.annotatedParameters= method.getParameterAnnotations();\n+            for (int i = 0; i < annotatedParameters.length; i++) {\n+                Annotation[] annotations = annotatedParameters[i];\n+                if (annotations.length != 0) {\n+                    for (int a = 0; a < annotations.length; a++) {\n+                        Annotation annotation = annotations[a];\n+                        \/\/System.out.println(\"annotation: \" + annotation);\n+                    }\n+                }\n+            }\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import jdk.incubator.code.type.ClassType;\n-import jdk.incubator.code.type.JavaType;\n@@ -35,3 +33,0 @@\n-import jdk.incubator.code.type.PrimitiveType;\n-\n-import java.lang.invoke.MethodHandles;\n@@ -39,1 +34,0 @@\n-import java.lang.reflect.Type;\n@@ -44,0 +38,2 @@\n+    public final ComputeCallGraph computeCallGraph;\n+\n@@ -72,2 +68,0 @@\n-    public final ComputeCallGraph computeCallGraph;\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -335,2 +336,2 @@\n-     *                                   associated with the provided segment is not\n-     *                                   {@linkplain MemorySegment.Scope#isAlive() alive}\n+     * associated with the provided segment is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}\n@@ -338,1 +339,1 @@\n-     *                                   such that {@code isAccessibleBy(T) == false}\n+     * such that {@code isAccessibleBy(T) == false}\n@@ -340,2 +341,2 @@\n-     *                                   <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n-     *                                   of the {@link #layout()}\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     * of the {@link #layout()}\n@@ -343,1 +344,1 @@\n-     *                                   {@code layout().byteSize() > segment.byteSize()}\n+     * {@code layout().byteSize() > segment.byteSize()}\n@@ -345,8 +346,2 @@\n-    static final long MAGIC =0x4a71facebffab175L;\n-    default T allocate(Arena arena, BoundSchema<?> boundSchema) {\n-        if (boundSchema == null) {\n-            throw new IllegalStateException(\"we must have a bound schema\");\n-         }\n-        \/\/ hat iface buffer bits\n-        \/\/ hat iface bffa   bits\n-        \/\/ 4a7 1face bffa   b175\n+\n+\n@@ -355,1 +350,1 @@\n-         We adjust size to next 16 byte boundary and then add sizeof ifacebufferbitz bytes\n+\n@@ -359,5 +354,6 @@\n-        struct ifacebufferpayload_t{\n-          int javaDirty;\n-          int gpuDirty;\n-          int unused[2];\n-        };\n+         Make sure the final static values below match the #defines\n+          \/\/ hat iface buffer bitz\n+        \/\/ hat iface bffa   bitz\n+        \/\/ 4a7 1face bffa   b175\n+\n+\n@@ -365,1 +361,1 @@\n-        struct ifacebufferbitz_t{\n+        struct state{\n@@ -367,1 +363,3 @@\n-           ifacebufferpayload_t payload;\n+           int bits;\n+           int mode;\n+           void * vendorPtr; \/\/ In OpenCL this points to native OpenCL::Buffer\n@@ -371,5 +369,92 @@\n-        long byteSize = layout().byteSize();\n-        long extendedByteSize = byteSize+16;\n-        long byteSizePad = extendedByteSize%16;\n-        if (byteSizePad != 0){\n-            byteSizePad = 16-byteSizePad;\n+\n+    record State(MemorySegment segment, long paddedSize) {\n+        public static final long alignment = ValueLayout.JAVA_LONG.byteSize();\n+        \/\/ hat iface buffer bitz\n+        \/\/ hat iface bffa   bitz\n+        \/\/ 4a7 1face bffa   b175\n+        public static final long MAGIC = 0x4a71facebffab175L;\n+        public static int BIT_HOST_NEW = 0b0000_0000_0000_0100;\n+        public static int BIT_GPU_NEW = 0b0000_0000_0000_1000;\n+        public static int BIT_HOST_DIRTY = 0b0000_0000_0000_0001;\n+        public static int BIT_GPU_DIRTY = 0b0000_0000_0000_0010;\n+        public static int MODE_ALWAYS_COPY_OUT = 0b0000_0000_0000_0001;\n+        public static int MODE_ALWAYS_COPY_IN = 0b0000_0000_0000_0010;\n+        public static int MODE_ALWAYS_COPY_IN_AND_OUT = MODE_ALWAYS_COPY_IN | MODE_ALWAYS_COPY_OUT;\n+        static final MemoryLayout stateMemoryLayout = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_LONG.withName(\"magic1\"),\n+                        ValueLayout.JAVA_INT.withName(\"bits\"),\n+                        ValueLayout.JAVA_INT.withName(\"mode\"),\n+                        ValueLayout.ADDRESS.withName(\"vendorPtr\"),\n+                ValueLayout.JAVA_LONG.withName(\"magic2\")\n+        ).withName(\"state\");\n+\n+        static long byteSize(){\n+            return stateMemoryLayout.byteSize();\n+        }\n+\n+        static final VarHandle magic1 = stateMemoryLayout.varHandle(\n+                MemoryLayout.PathElement.groupElement(\"magic1\")\n+        );\n+        static final VarHandle bits = stateMemoryLayout.varHandle(\n+                MemoryLayout.PathElement.groupElement(\"bits\")\n+        );\n+        static final VarHandle mode = stateMemoryLayout.varHandle(\n+                MemoryLayout.PathElement.groupElement(\"mode\")\n+        );\n+        static final VarHandle magic2 = stateMemoryLayout.varHandle(\n+                MemoryLayout.PathElement.groupElement(\"magic2\")\n+        );\n+\n+        public static long getLayoutSizeAfterPadding(GroupLayout layout) {\n+            return layout.byteSize() +\n+                    ((layout.byteSize() % State.alignment) == 0 ? 0 : State.alignment - (layout.byteSize() % State.alignment));\n+        }\n+\n+        public static <T> State of(T t) {\n+            Buffer buffer = (Buffer) Objects.requireNonNull(t);\n+            MemorySegment s = Buffer.getMemorySegment(buffer);\n+            return new State(s,s.byteSize()- State.byteSize());\n+        }\n+\n+\n+        State setMagic(){\n+            State.magic1.set(segment, paddedSize, MAGIC);\n+            State.magic2.set(segment, paddedSize, MAGIC);\n+            return this;\n+        }\n+\n+        public State mode(int mode) {\n+            State.mode.set(segment, paddedSize, mode);\n+           return this;\n+        }\n+        public State bits(int bits) {\n+            State.bits.set(segment, paddedSize, bits);\n+            return this;\n+        }\n+        public int mode() {\n+            return (Integer) State.mode.get(segment, paddedSize);\n+        }\n+\n+        public int bits() {\n+            return (Integer) State.bits.get(segment, paddedSize);\n+        }\n+        public boolean isHostNew() {\n+            return (bits()&BIT_HOST_NEW)==BIT_HOST_NEW;\n+        }\n+        public boolean isHostDirty() {\n+            return (bits()&BIT_HOST_DIRTY)==BIT_HOST_DIRTY;\n+        }\n+        public boolean isHostNewOrDirty() {\n+            return (bits()&(BIT_HOST_NEW|BIT_HOST_DIRTY))==(BIT_HOST_NEW|BIT_HOST_DIRTY);\n+        }\n+        public boolean isGpuDirty() {\n+            return (bits()&BIT_GPU_DIRTY)==BIT_GPU_DIRTY;\n+        }\n+\n+\n+        public long magic1() {\n+            return (Long) State.magic1.get(segment, paddedSize);\n+        }\n+\n+        public long magic2() {\n+            return (Long) State.magic2.get(segment, paddedSize);\n@@ -377,4 +462,0 @@\n-        long extendedByteSizePaddedTo16Bytes = extendedByteSize+byteSizePad;\n-        \/\/System.out.println(\"Alloc 16 byte aligned layout + 16 bytes padded to next 16 bytes \"+byteSize+\"=>\"+extendedByteSizePaddedTo16Bytes);\n-        var segment = arena.allocate(extendedByteSizePaddedTo16Bytes\n-                +ValueLayout.JAVA_LONG.byteSize()*2, 16);\n@@ -382,0 +463,4 @@\n+        public boolean ok() {\n+            return MAGIC == magic1() && MAGIC == magic2();\n+        }\n+    }\n@@ -383,5 +468,18 @@\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-2*ValueLayout.JAVA_LONG.byteSize(),  MAGIC);\/\/hatifacebffabits\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes-1*ValueLayout.JAVA_LONG.byteSize(),  0x0000000000000000L);\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes+0*ValueLayout.JAVA_LONG.byteSize(),  0x0000000000000000L);\/\/hatifacebffabits\n-        segment.set(ValueLayout.JAVA_LONG, extendedByteSizePaddedTo16Bytes+1*ValueLayout.JAVA_LONG.byteSize(),  MAGIC);\n-        return get(segment, layout(), boundSchema);\n+    default T allocate(Arena arena, BoundSchema<?> boundSchema) {\n+        if (boundSchema == null) {\n+            throw new IllegalStateException(\"No bound Schema provided\");\n+        }\n+        \/\/System.out.println(\"Alloc 16 byte aligned layout + 16 bytes padded to next 16 bytes \"+byteSize+\"=>\"+extendedByteSizePaddedTo16Bytes);\n+        var segment = arena.allocate(State.getLayoutSizeAfterPadding(layout()) + State.byteSize(), State.alignment);\n+        new State(segment, State.getLayoutSizeAfterPadding(layout())).setMagic().bits(State.BIT_HOST_NEW|State.BIT_HOST_DIRTY).mode(State.MODE_ALWAYS_COPY_IN_AND_OUT);\n+        T returnValue=  get(segment, layout(), boundSchema);\n+        \/\/ Uncomment if you want to check the State\n+        \/*\n+        State state = State.of(returnValue);\n+        if (state.ok() &&!state.isGpuDirty() &&!state.isJavaDirty()){\n+            System.out.println(\"OK\");\n+        }else{\n+            throw new IllegalArgumentException(\"BAD TAIL\");\n+        }\n+         *\/\n+        return returnValue;\n@@ -389,0 +487,1 @@\n+\n@@ -481,1 +580,1 @@\n-                    .invokeExact(segment, layout, boundSchema,offset);\n+                    .invokeExact(segment, layout, boundSchema, offset);\n@@ -558,1 +657,1 @@\n-   \/\/ default void setAtIndex(MemorySegment segment, long index, T t) {\n+    \/\/ default void setAtIndex(MemorySegment segment, long index, T t) {\n@@ -560,1 +659,1 @@\n-  \/\/  }\n+    \/\/  }\n@@ -735,1 +834,1 @@\n-        return SegmentInterfaceMapper.create(lookup,  type, layout, boundSchema);\n+        return SegmentInterfaceMapper.create(lookup, type, layout, boundSchema);\n@@ -744,1 +843,1 @@\n-       StructLayout structlayout = MemoryLayout.structLayout(elements).withName(type.getSimpleName());\n+        StructLayout structlayout = MemoryLayout.structLayout(elements).withName(type.getSimpleName());\n@@ -760,0 +859,1 @@\n+\n@@ -764,0 +864,1 @@\n+\n","filename":"hat\/hat\/src\/main\/java\/hat\/ifacemapper\/SegmentMapper.java","additions":142,"deletions":41,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -13,0 +13,1 @@\n+      <module name=\"hat\" options=\"--add-modules=jdk.incubator.code,java.desktop --add-exports=java.base\/jdk.internal.vm.annotation=ALL-UNNAMED --add-exports=java.base\/jdk.internal=ALL-UNNAMED\" \/>\n","filename":"hat\/intellij\/.idea\/compiler.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}