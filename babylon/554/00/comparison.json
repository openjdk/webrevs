{"files":[{"patch":"@@ -17,0 +17,1 @@\n+5. [`CodeReflectionProcessor`](https:\/\/github.com\/openjdk\/babylon\/blob\/code-reflection\/cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/CodeReflectionProcessor.java): A simple code model-based annotation processor\n@@ -57,1 +58,1 @@\n-java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.HelloCodeReflection\n+java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.HelloCodeReflection\n@@ -63,1 +64,1 @@\n-java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizer\n+java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizer\n@@ -69,1 +70,1 @@\n-java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.InlineExample\n+java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.InlineExample\n@@ -75,1 +76,7 @@\n-java --enable-preview -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizerWithInlining\n+java --add-modules jdk.incubator.code -cp target\/crsamples-1.0-SNAPSHOT.jar oracle.code.samples.MathOptimizerWithInlining\n+```\n+\n+##### Compile with CodeReflectionProcessor\n+\n+```bash\n+javac --add-modules jdk.incubator.code --processor-path target\/crsamples-1.0-SNAPSHOT.jar -processor oracle.code.samples.CodeReflectionProcessor <.java files to compile>\n","filename":"cr-examples\/samples\/README.md","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+package oracle.code.samples;\n+\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.dialect.core.CoreOp.FuncOp;\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp;\n+import jdk.incubator.code.dialect.java.JavaOp.ThrowOp;\n+import jdk.incubator.code.dialect.java.JavaOp.TryOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.Messager;\n+import javax.annotation.processing.ProcessingEnvironment;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.annotation.processing.SupportedSourceVersion;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.util.ElementScannerPreview;\n+import javax.tools.Diagnostic.Kind;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+\/**\n+ * This annotation processor can be used to inspect methods annotated with {@code CodeReflection},\n+ * and check if they conform to specific programming model restrictions. This provides an example on how\n+ * clients might control the contents of a code model via compile-time checks, which can be useful e.g. if said\n+ * models are meant for an <em>foreign<\/em> execution environment that might not support all the features of\n+ * a full-blown JVM.\n+ * <p>\n+ * More specifically,this annotation processor issues error messages when it detects calls to <em>complex<\/em>\n+ * system methods (such as {@link System#gc()}, or {@link Runtime#loadLibrary(String)}). It also issues errors\n+ * when encountering <em>unsupported<\/em> languages features, such as {@code try\/catch} or {@code throw}.\n+ *\/\n+@SupportedAnnotationTypes(\"jdk.incubator.code.CodeReflection\")\n+@SupportedSourceVersion(SourceVersion.RELEASE_26)\n+public class CodeReflectionProcessor extends AbstractProcessor {\n+\n+    @Override\n+    public synchronized void init(ProcessingEnvironment processingEnv) {\n+        super.init(processingEnv);\n+    }\n+\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        for (Element e : roundEnv.getElementsAnnotatedWith(CodeReflection.class)) {\n+            ReflectableMethodScanner scanner = new ReflectableMethodScanner();\n+            scanner.scan(e);\n+        }\n+        return true;\n+    }\n+\n+    class ReflectableMethodScanner extends ElementScannerPreview<Void, Void> {\n+\n+        final Messager logger = processingEnv.getMessager();\n+\n+        @Override\n+        public Void scan(Element e, Void unused) {\n+            return super.scan(e, unused);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(ExecutableElement e, Void unused) {\n+            if (e.getAnnotationsByType(CodeReflection.class) != null) {\n+                Optional<FuncOp> funcOp = Op.ofElement(processingEnv, e);\n+                funcOp.ifPresent(f -> processMethodModel(e, f));\n+            }\n+            return null;\n+        }\n+\n+        void processMethodModel(ExecutableElement element, FuncOp funcOp) {\n+            funcOp.elements().forEach(ce -> processOp(element, ce));\n+        }\n+\n+        void processOp(Element element, CodeElement<?, ?> codeElement) {\n+            switch (codeElement) {\n+                case InvokeOp invokeOp -> {\n+                    var desc = invokeOp.invokeDescriptor();\n+                    var receiverType = (JavaType) desc.refType();\n+                    String methodName = desc.name();\n+                    List<String> unsupportedMethods = UNSUPPORTED_METHODS.getOrDefault(receiverType, List.of());\n+                    for (String unsupportedMethod : unsupportedMethods) {\n+                        if (unsupportedMethod.equals(methodName)) {\n+                            String methErrString = receiverType.toNominalDescriptor().displayName() + \".\" + methodName;\n+                            logger.printMessage(Kind.ERROR,  methErrString + \" not supported in reflectable methods\", element);\n+                            break;\n+                        }\n+                    }\n+                }\n+                case Op op -> {\n+                    String unsupportedOp = UNSUPPORTED_OPS.get(op.getClass());\n+                    if (unsupportedOp != null) {\n+                        logger.printMessage(Kind.ERROR, unsupportedOp + \" not supported in reflectable methods\", element);\n+                    }\n+                }\n+                default -> {\n+                    \/\/ do nothing\n+                }\n+            }\n+        }\n+    }\n+\n+    static final Map<JavaType, List<String>> UNSUPPORTED_METHODS = Map.of(\n+            JavaType.type(System.class), List.of(\"exit\", \"gc\", \"load\", \"loadLibrary\"),\n+            JavaType.type(Runtime.class), List.of(\"load\", \"loadLibrary\"));\n+\n+    static final Map<Class<?>, String> UNSUPPORTED_OPS = Map.of(\n+            ThrowOp.class, \"throw statement\",\n+            TryOp.class, \"try\/catch statement\"\n+    );\n+}\n","filename":"cr-examples\/samples\/src\/main\/java\/oracle\/code\/samples\/CodeReflectionProcessor.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+package jdk.internal.access.code;\n+\n+public class CodeModuleLayerInit {\n+    public static void initCodeModuleLayer(ModuleLayer layer) {\n+        Module codeReflectionModule = layer.findModule(\"jdk.incubator.code\").get();\n+        Module jdkCompilerModule = CodeModuleLayerInit.class.getModule();\n+        \/\/ We need to add exports all java.base packages so that the plugin can use them\n+        for (String packageName : jdkCompilerModule.getPackages()) {\n+            jdkCompilerModule.addExports(packageName, codeReflectionModule);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/code\/CodeModuleLayerInit.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -180,0 +180,2 @@\n+    exports jdk.internal.access.code to\n+        jdk.compiler;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.JavaCompiler.CodeReflectionSupport;\n@@ -194,1 +196,3 @@\n-        ClassLoader thisClassLoader = getClass().getClassLoader();\n+        ClassLoader thisClassLoader = CodeReflectionSupport.CODE_LAYER != null ?\n+                CodeReflectionSupport.CODE_LAYER.findLoader(\"jdk.incubator.code\") :\n+                getClass().getClassLoader();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.main.JavaCompiler.CodeReflectionSupport;\n@@ -1169,2 +1171,13 @@\n-            Configuration cf = bootLayer.configuration().resolveAndBind(ModuleFinder.of(), finder, Collections.emptySet());\n-            ModuleLayer layer = bootLayer.defineModulesWithOneLoader(cf, ClassLoader.getSystemClassLoader());\n+            ModuleLayer augmentedModuleLayer;\n+            ClassLoader parentCL;\n+            if (CodeReflectionSupport.CODE_LAYER != null) {\n+                \/\/ create a layer whose parent is Babylon's code layer\n+                augmentedModuleLayer = CodeReflectionSupport.CODE_LAYER;\n+                parentCL = CodeReflectionSupport.CODE_LAYER.findLoader(\"jdk.incubator.code\");\n+            } else {\n+                augmentedModuleLayer = bootLayer;\n+                parentCL = ClassLoader.getSystemClassLoader();\n+            }\n+            Configuration cf = augmentedModuleLayer.configuration()\n+                    .resolveAndBind(ModuleFinder.of(), finder, Collections.emptySet());\n+            ModuleLayer layer = augmentedModuleLayer.defineModulesWithOneLoader(cf, parentCL);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/JavacFileManager.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Method;\n@@ -1742,2 +1743,2 @@\n-    static class CodeReflectionSupport {\n-        static final ModuleLayer CODE_LAYER;\n+    public static class CodeReflectionSupport {\n+        public static final ModuleLayer CODE_LAYER;\n@@ -1762,0 +1763,9 @@\n+                \/\/ We also need to add exports all java.base packages so that the plugin can use them\n+                \/\/ But we need to do so by calling a method in java.base reflectively\n+                try {\n+                    Class<?> codeModuleLayerInit = Class.forName(\"jdk.internal.access.code.CodeModuleLayerInit\");\n+                    Method initLayerMethod = codeModuleLayerInit.getDeclaredMethod(\"initCodeModuleLayer\", ModuleLayer.class);\n+                    initLayerMethod.invoke(null, CODE_LAYER);\n+                } catch (ReflectiveOperationException ex) {\n+                    throw new AssertionError(ex);\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -594,2 +594,9 @@\n-                    attribBlock -> reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make));\n-            return Optional.of(op);\n+                    attribBlock -> {\n+                        try {\n+                            return reflectMethods.getMethodBody(enclosingClass, methodTree, attribBlock, make);\n+                        } catch (Throwable ex) {\n+                            \/\/ this might happen if the source code contains errors\n+                            return null;\n+                        }\n+                    });\n+            return Optional.ofNullable(op);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Op.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ *  @test\n+ *  @summary check that annotation processor that depends on jdk.incubator.code can run normally\n+ *  @library \/tools\/lib\n+ *  @modules jdk.compiler\/com.sun.tools.javac.api\n+ *           jdk.compiler\/com.sun.tools.javac.main\n+ *           jdk.jlink\n+ *  @build toolbox.ToolBox toolbox.JavacTask toolbox.JarTask\n+ *  @run main\/othervm TestCodeModelProcessors\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import toolbox.JarTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestCodeModelProcessors extends TestRunner {\n+    public static void main(String... args) throws Exception {\n+        new TestCodeModelProcessors().run();\n+    }\n+\n+    TestCodeModelProcessors() {\n+        super(System.out);\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    Path pluginJar;\n+    Path classes;\n+    Path mclasses;\n+\n+    void run() throws Exception {\n+        Path src = Path.of(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                        package p;\n+\n+                        import javax.annotation.processing.*;\n+                        import jdk.incubator.code.*;\n+                        import java.util.*;\n+\n+                        public class TestProcessor extends AbstractProcessor {\n+\n+                            @Override\n+                            public void init(ProcessingEnvironment processingEnv) {\n+                                try {\n+                                    var processorClass = TestProcessor.class;\n+                                    var testMethod = processorClass.getDeclaredMethod(\"test\");\n+                                    var op = Op.ofMethod(testMethod);\n+                                    op.get(); \/\/ make sure that works\n+                                    test();\n+                                } catch (Throwable ex) {\n+                                    throw new AssertionError(ex);\n+                                }\n+                            }\n+\n+                            @Override\n+                            public boolean process(Set<? extends javax.lang.model.element.TypeElement> annotations, RoundEnvironment roundEnv) {\n+                                return true;\n+                            }\n+\n+                            @CodeReflection\n+                            void test() {\n+                                System.out.println(\"SUCCESS\");\n+                            }\n+                        }\n+                        \"\"\");\n+\n+        Path msrc = Path.of(\"msrc\");\n+        tb.writeJavaFiles(msrc,\n+                \"\"\"\n+                          module m {\n+                              requires jdk.compiler;\n+                              requires jdk.incubator.code;\n+                              provides javax.annotation.processing.Processor with p.TestProcessor;\n+                              opens p to jdk.incubator.code;\n+                          }\n+                          \"\"\");\n+\n+        classes = Files.createDirectories(Path.of(\"classes\"));\n+        new JavacTask(tb)\n+                .options(\"--add-modules\", \"jdk.incubator.code\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+        tb.writeFile(classes.resolve(\"META-INF\").resolve(\"services\").resolve(\"javax.annotation.processing.Processor\"),\n+                \"p.TestProcessor\\n\");\n+\n+        pluginJar = Path.of(\"plugin.jar\");\n+        new JarTask(tb, pluginJar)\n+                .baseDir(classes)\n+                .files(\".\")\n+                .run();\n+\n+        mclasses = Files.createDirectories(Path.of(\"mclasses\"));\n+        new JavacTask(tb)\n+                .options(\"--add-modules\", \"jdk.incubator.code\")\n+                .outdir(mclasses)\n+                .sourcepath(msrc, src)\n+                .files(tb.findJavaFiles(msrc))\n+                .run()\n+                .writeAll();\n+\n+        Path hw = Path.of(\"hw\");\n+        tb.writeJavaFiles(hw,\n+                \"\"\"\n+                        import jdk.incubator.code.*;\n+\n+                        public class HelloWorld {\n+                            @CodeReflection\n+                            void testAnnos() { }\n+                        }\n+                        \"\"\");\n+\n+        runTests(m -> new Object[] { Path.of(m.getName()), ProcessorOptions.EXPLICIT });\n+        runTests(m -> new Object[] { Path.of(m.getName()), ProcessorOptions.IMPLICIT });\n+    }\n+\n+    record ProcessorOptions(String first, String second) {\n+        static final ProcessorOptions IMPLICIT = new ProcessorOptions(\"-proc:full\", \"-proc:full\");\n+        static final ProcessorOptions EXPLICIT = new ProcessorOptions(\"-processor\", \"p.TestProcessor\");\n+    }\n+\n+    @Test\n+    public void testClassPath(Path base, ProcessorOptions processorOptions) throws Exception {\n+        var task = new JavacTask(tb)\n+                .classpath(classes)\n+                .options(\"--processor-path\", classes.toString(),\n+                         processorOptions.first, processorOptions.second,\n+                         \"--add-modules\", \"jdk.incubator.code\")\n+                .outdir(Files.createDirectories(base.resolve(\"out\")))\n+                .files(tb.findJavaFiles(Path.of(\"hw\")))\n+                .run()\n+                .writeAll();\n+        var stdout = task.getOutputLines(OutputKind.STDOUT);\n+        tb.checkEqual(stdout, List.of(\"SUCCESS\"));\n+    }\n+\n+    @Test\n+    public void testClassPathJar(Path base, ProcessorOptions processorOptions) throws Exception {\n+        List<String> stdout = new JavacTask(tb)\n+                .classpath(pluginJar)\n+                .options(processorOptions.first, processorOptions.second,\n+                        \"--add-modules\", \"jdk.incubator.code\")\n+                .outdir(Files.createDirectories(base.resolve(\"out\")))\n+                .files(tb.findJavaFiles(Path.of(\"hw\")))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+        tb.checkEqual(stdout, List.of(\"SUCCESS\"));\n+    }\n+\n+    @Test\n+    public void testModulePath(Path base, ProcessorOptions processorOptions) throws IOException {\n+        List<String> stdout = new JavacTask(tb)\n+                .options(\"--processor-module-path\", mclasses.toString(),\n+                        processorOptions.first, processorOptions.second,\n+                        \"--add-modules\", \"jdk.incubator.code\")\n+                .outdir(Files.createDirectories(base.resolve(\"out\")))\n+                .files(tb.findJavaFiles(Path.of(\"hw\")))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+        tb.checkEqual(stdout, List.of(\"SUCCESS\"));\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/reflect\/TestCodeModelProcessors.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}