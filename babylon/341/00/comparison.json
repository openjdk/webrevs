{"files":[{"patch":"@@ -38,0 +38,1 @@\n+        ${OPENCL_BACKEND}\/cpp\/opencl_backend_queue.cpp\n","filename":"hat\/backends\/ffi\/opencl\/CMakeLists.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,17 +26,0 @@\n-#ifdef __APPLE__\n-    #define LongUnsignedNewline \"%llu\\n\"\n-    #define Size_tNewline \"%lu\\n\"\n-    #define LongHexNewline \"(0x%llx)\\n\"\n- \/\/  #define alignedMalloc(size, alignment) memalign(alignment, size)\n-#else\n-    #include <malloc.h>\n-    #define LongHexNewline \"(0x%lx)\\n\"\n-    #define LongUnsignedNewline \"%lu\\n\"\n-    #define Size_tNewline \"%lu\\n\"\n-    #if defined (_WIN32)\n-        #include \"windows.h\"\n-     \/\/   #define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n-    #else\n-     \/\/  #define alignedMalloc(size, alignment) memalign(alignment, size)\n-    #endif\n-#endif\n@@ -68,132 +51,0 @@\n- OpenCLBackend::OpenCLQueue::OpenCLQueue()\n-  : eventMax(10000), events(new cl_event[eventMax]), eventc(0){\n- }\n-\n- cl_event *OpenCLBackend::OpenCLQueue::eventListPtr(){\n-   return (eventc == 0) ? nullptr : events;\n-  }\n- cl_event *OpenCLBackend::OpenCLQueue::nextEventPtr(){\n-              return &events[eventc];\n- }\n-\n-void OpenCLBackend::OpenCLQueue::showEvents(int width) {\n-    const int  SAMPLE_TYPES=4;\n-    cl_ulong *samples = new cl_ulong[SAMPLE_TYPES * eventc]; \/\/ queued, submit, start, end, complete\n-    int sample = 0;\n-    cl_ulong min;\n-    cl_ulong max;\n-    cl_profiling_info profiling_info_arr[]={CL_PROFILING_COMMAND_QUEUED,CL_PROFILING_COMMAND_SUBMIT,CL_PROFILING_COMMAND_START,CL_PROFILING_COMMAND_END} ;\n-    const char* profiling_info_name_arr[]={\"CL_PROFILING_COMMAND_QUEUED\",\"CL_PROFILING_COMMAND_SUBMIT\",\"CL_PROFILING_COMMAND_START\",\"CL_PROFILING_COMMAND_END\" } ;\n-\n-    for (int event = 0; event < eventc; event++) {\n-        for (int type = 0; type < SAMPLE_TYPES; type++) {\n-            if ((clGetEventProfilingInfo(events[event], profiling_info_arr[type], sizeof(samples[sample]), &samples[sample], NULL)) !=\n-                CL_SUCCESS) {\n-                std::cerr << \"failed to get profile info \" << profiling_info_name_arr[type] << std::endl;\n-            }\n-            if (sample == 0) {\n-                if (type == 0){\n-                   min = max = samples[sample];\n-                }\n-            } else {\n-                if (samples[sample] < min) {\n-                    min = samples[sample];\n-                }\n-                if (samples[sample] > max) {\n-                    max = samples[sample];\n-                }\n-            }\n-            sample++;\n-        }\n-    }\n-    sample = 0;\n-    int range = (max - min);\n-    int scale = range \/ width;  \/\/ range per char\n-    std::cout << \"Range: \" <<min<< \"-\" <<max<< \"(\"<< range << \"ns)\"\n-        <<  \"  (\" << scale << \"ns) per char\"\n-        << \" +:submitted, .:started, =:end  \"<< std::endl;\n-\n-    for (int event = 0; event < eventc; event++) {\n-        cl_command_type command_type;\n-        clGetEventInfo(events[event],CL_EVENT_COMMAND_TYPE,sizeof(command_type), &command_type, nullptr);\n-        switch (command_type){\n-          case CL_COMMAND_NDRANGE_KERNEL: std::cout <<   \"kernel \"; break;\n-          case CL_COMMAND_READ_BUFFER: std::cout <<    \"  read \"; break;\n-          case CL_COMMAND_WRITE_BUFFER: std::cout << \" write \"; break;\n-          default: std::cout <<                    \" other \"; break;\n-        }\n-       \/\/ long eventStart=samples[sample];\n-        cl_ulong queue = (samples[sample++] - min) \/ scale;\n-        cl_ulong submit = (samples[sample++] - min) \/ scale;\n-        cl_ulong start = (samples[sample++] - min) \/ scale;\n-      \/\/  long eventComplete=samples[sample];\n-        cl_ulong end = (samples[sample++] - min) \/ scale;\n-\n-        std::cout << std::setw(8)<< (queue-end) << \"(ns) \";\n-        for (int c = 0; c < width; c++) {\n-            char ch = ' ';\n-            if (c >= queue && c<=submit) {\n-                ch = '+';\n-            }else if (c>submit && c<start){\n-                ch = '.';\n-            }else if (c>=start && c<end){\n-                ch = '=';\n-            }\n-            std::cout << ch;\n-        }\n-        std::cout << std::endl;\n-    }\n-    delete[] samples;\n-}\n- void OpenCLBackend::OpenCLQueue::wait(){\n-     cl_int status = clWaitForEvents(eventc, events);\n-      if (status != CL_SUCCESS) {\n-        std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-        exit(1);\n-       }\n- }\n- void OpenCLBackend::OpenCLQueue::computeStart(){\n- \/* maybe\n- cl_int clEnqueueNativeKernel(\n-     cl_command_queue command_queue,\n-     void (CL_CALLBACK* user_func)(void*),\n-     void* args,\n-     size_t cb_args,\n-     cl_uint num_mem_objects,\n-     const cl_mem* mem_list,\n-     const void** args_mem_loc,\n-     cl_uint num_events_in_wait_list,\n-     const cl_event* event_wait_list,\n-     cl_event* event); *\/\n-\/\/ cl_int status = clEnqueueMarker(command_queue, cl_event* event);\n-    \/\/ openclBackend->openclQueue.eventc,\n-     \/\/   openclBackend->openclQueue.eventListPtr(),\n-      \/\/  openclBackend->openclQueue.nextEventPtr()\n-    \/\/ );\n-   \/\/  openclBackend->openclQueue.inc();\n- }\n- void OpenCLBackend::OpenCLQueue::computeEnd(){\n- }\n- void OpenCLBackend::OpenCLQueue::inc(){\n-    if (eventc+1 >= eventMax){\n-       std::cerr << \"OpenCLBackend::OpenCLQueue event list overflowed!!\" << std::endl;\n-    }\n-    eventc++;\n- }\n-\n- void OpenCLBackend::OpenCLQueue::release(){\n-     cl_int status = CL_SUCCESS;\n-     for (int i = 0; i < eventc; i++) {\n-         status = clReleaseEvent(events[i]);\n-         if (status != CL_SUCCESS) {\n-             std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n-             exit(1);\n-         }\n-     }\n-     eventc = 0;\n- }\n-\n- OpenCLBackend::OpenCLQueue::~OpenCLQueue(){\n-     clReleaseCommandQueue(command_queue);\n-     delete []events;\n- }\n@@ -244,1 +95,1 @@\n-    openclBackend->openclQueue.inc();\n+    openclBackend->openclQueue.markAsCopyToDeviceAndInc();\n@@ -270,1 +121,1 @@\n-    openclBackend->openclQueue.inc();\n+    openclBackend->openclQueue.markAsCopyFromDeviceAndInc();\n@@ -297,0 +148,1 @@\n+\n@@ -300,0 +152,1 @@\n+    openclBackend->openclQueue.marker(openclBackend->openclQueue.EnterKernelDispatchBits);\n@@ -308,0 +161,17 @@\n+               if (openclBackend->openclConfig.trace){\n+                  std::cout << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access);\n+                  switch (arg->value.buffer.access){\n+                      case RO_BYTE: std::cout << \" RO\";break;\n+                      case WO_BYTE: std::cout << \" WO\";break;\n+                      case RW_BYTE: std::cout << \" RW\";break;\n+                      default: std::cout << \"JUNK!!!!\"; break;\n+                  }\n+                  std::cout << std::endl;\n+               }\n+               if ((arg->value.buffer.access == RO_BYTE ) || (arg->value.buffer.access == RW_BYTE ) ||(arg->value.buffer.access == WO_BYTE )){\n+                 \/\/ OK\n+               }else{\n+                  std::cerr << \"arg[\"<<i<<\"] = \"<< std::hex << (int)(arg->value.buffer.access) << std::endl;\n+                  std::exit(1);\n+               }\n+\n@@ -403,1 +273,1 @@\n-    openclBackend->openclQueue.inc();\n+    openclBackend->openclQueue.markAsNDRangeAndInc();\n@@ -428,0 +298,1 @@\n+      openclBackend->openclQueue.marker(openclBackend->openclQueue.LeaveKernelDispatchBits);\n@@ -471,1 +342,1 @@\n-        : Backend(mode), openclConfig(mode), openclQueue() {\n+        : Backend(mode), openclConfig(mode), openclQueue(this) {\n@@ -617,1 +488,0 @@\n- openclQueue.wait();\n@@ -619,0 +489,2 @@\n+ openclQueue.wait();\n+\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend.cpp","additions":26,"deletions":154,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"opencl_backend.h\"\n+\/*\n+While based on OpenCL's event list, I think we need to use a MOD eventMax queue.\n+\n+So\n+*\/\n+ OpenCLBackend::OpenCLQueue::OpenCLQueue(OpenCLBackend *openclBackend)\n+    :openclBackend(openclBackend), eventMax(10000), events(new cl_event[eventMax]), eventInfoBits(new int[eventMax]), eventc(0){\n+ }\n+\n+ cl_event *OpenCLBackend::OpenCLQueue::eventListPtr(){\n+    return (eventc == 0) ? nullptr : events;\n+ }\n+ cl_event *OpenCLBackend::OpenCLQueue::nextEventPtr(){\n+    return &events[eventc];\n+ }\n+\n+void OpenCLBackend::OpenCLQueue::showEvents(int width) {\n+    const int  SAMPLE_TYPES=4;\n+    cl_ulong *samples = new cl_ulong[SAMPLE_TYPES * eventc]; \/\/ queued, submit, start, end, complete\n+    int sample = 0;\n+    cl_ulong min;\n+    cl_ulong max;\n+    cl_profiling_info profiling_info_arr[]={CL_PROFILING_COMMAND_QUEUED,CL_PROFILING_COMMAND_SUBMIT,CL_PROFILING_COMMAND_START,CL_PROFILING_COMMAND_END} ;\n+    const char* profiling_info_name_arr[]={\"CL_PROFILING_COMMAND_QUEUED\",\"CL_PROFILING_COMMAND_SUBMIT\",\"CL_PROFILING_COMMAND_START\",\"CL_PROFILING_COMMAND_END\" } ;\n+\n+    for (int event = 0; event < eventc; event++) {\n+        for (int type = 0; type < SAMPLE_TYPES; type++) {\n+            if ((clGetEventProfilingInfo(events[event], profiling_info_arr[type], sizeof(samples[sample]), &samples[sample], NULL)) !=\n+                CL_SUCCESS) {\n+                std::cerr << \"failed to get profile info \" << profiling_info_name_arr[type] << std::endl;\n+            }\n+            if (sample == 0) {\n+                if (type == 0){\n+                   min = max = samples[sample];\n+                }\n+            } else {\n+                if (samples[sample] < min) {\n+                    min = samples[sample];\n+                }\n+                if (samples[sample] > max) {\n+                    max = samples[sample];\n+                }\n+            }\n+            sample++;\n+        }\n+    }\n+    sample = 0;\n+    int range = (max - min);\n+    int scale = range \/ width;  \/\/ range per char\n+    std::cout << \"Range: \" <<min<< \"-\" <<max<< \"(\"<< range << \"ns)\"\n+        <<  \"  (\" << scale << \"ns) per char\"\n+        << \" +:submitted, .:started, =:end  \"<< std::endl;\n+\n+    for (int event = 0; event < eventc; event++) {\n+      \/*  cl_command_type command_type;\n+        clGetEventInfo(events[event],CL_EVENT_COMMAND_TYPE,sizeof(command_type), &command_type, nullptr);\n+        switch (command_type){\n+          case CL_COMMAND_MARKER:         std::cout <<   \"marker \"; break;\n+          case CL_COMMAND_USER:           std::cout <<   \"  user \"; break;\n+          case CL_COMMAND_NDRANGE_KERNEL: std::cout <<   \"kernel \"; break;\n+          case CL_COMMAND_READ_BUFFER:    std::cout <<   \"  read \"; break;\n+          case CL_COMMAND_WRITE_BUFFER:   std::cout <<   \" write \"; break;\n+          default: std::cout <<                          \" other \"; break;\n+        } *\/\n+        int bits = eventInfoBits[event];\n+        if ((bits&CopyToDeviceBits)==CopyToDeviceBits){\n+           std::cout <<   \"  write \";\n+        }\n+        if ((bits&CopyFromDeviceBits)==CopyFromDeviceBits){\n+           std::cout <<   \"   read \";\n+        }\n+        if ((bits&StartComputeBits)==StartComputeBits){\n+           std::cout <<   \"  start \";\n+        }\n+        if ((bits&EndComputeBits)==EndComputeBits){\n+           std::cout <<   \"    end \";\n+        }\n+        if ((bits&NDRangeBits)==NDRangeBits){\n+           std::cout <<   \" kernel \";\n+        }\n+        if ((bits&EnterKernelDispatchBits)==EnterKernelDispatchBits){\n+           std::cout <<   \"  enter \";\n+        }\n+        if ((bits&LeaveKernelDispatchBits)==LeaveKernelDispatchBits){\n+           std::cout <<   \"  leave \";\n+        }\n+\n+\n+        cl_ulong queue = (samples[sample++] - min) \/ scale;\n+        cl_ulong submit = (samples[sample++] - min) \/ scale;\n+        cl_ulong start = (samples[sample++] - min) \/ scale;\n+        cl_ulong end = (samples[sample++] - min) \/ scale;\n+\n+        std::cout << std::setw(20)<< (queue-end) << \"(ns) \";\n+        for (int c = 0; c < width; c++) {\n+            char ch = ' ';\n+            if (c >= queue && c<=submit) {\n+                ch = '+';\n+            }else if (c>submit && c<start){\n+                ch = '.';\n+            }else if (c>=start && c<end){\n+                ch = '=';\n+            }\n+            std::cout << ch;\n+        }\n+        std::cout << std::endl;\n+    }\n+    delete[] samples;\n+}\n+void OpenCLBackend::OpenCLQueue::wait(){\n+    if (eventc > 0){\n+       cl_int status = clWaitForEvents(eventc, events);\n+       if (status != CL_SUCCESS) {\n+          std::cerr << \"failed clWaitForEvents\" << OpenCLBackend::errorMsg(status) << std::endl;\n+          exit(1);\n+       }\n+    }\n+ }\n+ void clCallback(void *){\n+      std::cerr<<\"start of compute\"<<std::endl;\n+ }\n+  void OpenCLBackend::OpenCLQueue::marker(int bits){\n+  cl_int status = clEnqueueMarkerWithWaitList(\n+      command_queue,\n+      this->eventc, this->eventListPtr(),this->nextEventPtr()\n+      );\n+        if (status != CL_SUCCESS){\n+             std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n+             std::exit(1);\n+         }\n+      inc(bits);\n+  }\n+\n+ void OpenCLBackend::OpenCLQueue::computeStart(){\n+   wait(); \/\/ should be no-op\n+   release(); \/\/ also ;\n+   marker(StartComputeBits);\n+ }\n+\n+\n+\n+ void OpenCLBackend::OpenCLQueue::computeEnd(){\n+   marker(EndComputeBits);\n+ }\n+\n+ void OpenCLBackend::OpenCLQueue::inc(int bits){\n+    if (eventc+1 >= eventMax){\n+       std::cerr << \"OpenCLBackend::OpenCLQueue event list overflowed!!\" << std::endl;\n+    }else{\n+        eventInfoBits[eventc]=bits;\n+    }\n+    eventc++;\n+ }\n+\n+ void OpenCLBackend::OpenCLQueue::markAsEndComputeAndInc(){\n+     inc(EndComputeBits);\n+ }\n+ void OpenCLBackend::OpenCLQueue::markAsStartComputeAndInc(){\n+     inc(StartComputeBits);\n+ }\n+ void OpenCLBackend::OpenCLQueue::markAsNDRangeAndInc(){\n+     inc(NDRangeBits);\n+ }\n+ void OpenCLBackend::OpenCLQueue::markAsCopyToDeviceAndInc(){\n+     inc(CopyToDeviceBits);\n+ }\n+ void OpenCLBackend::OpenCLQueue::markAsCopyFromDeviceAndInc(){\n+     inc(CopyFromDeviceBits);\n+ }\n+ void OpenCLBackend::OpenCLQueue::markAsEnterKernelDispatchAndInc(){\n+     inc(EnterKernelDispatchBits);\n+ }\n+ void OpenCLBackend::OpenCLQueue::markAsLeaveKernelDispatchAndInc(){\n+     inc(LeaveKernelDispatchBits);\n+ }\n+\n+ void OpenCLBackend::OpenCLQueue::release(){\n+     cl_int status = CL_SUCCESS;\n+     for (int i = 0; i < eventc; i++) {\n+         status = clReleaseEvent(events[i]);\n+         if (status != CL_SUCCESS) {\n+             std::cerr << OpenCLBackend::errorMsg(status) << std::endl;\n+             exit(1);\n+         }\n+     }\n+     eventc = 0;\n+ }\n+\n+ OpenCLBackend::OpenCLQueue::~OpenCLQueue(){\n+     clReleaseCommandQueue(command_queue);\n+     delete []events;\n+     delete []eventInfoBits;\n+ }\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/opencl\/cpp\/opencl_backend_queue.cpp","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -32,0 +32,4 @@\n+   #include <malloc.h>\n+   #if defined (_WIN32)\n+       #include \"windows.h\"\n+   #endif\n@@ -68,0 +72,8 @@\n+       static const int CopyToDeviceBits= 1<<0;\n+       static const int CopyFromDeviceBits= 1<<1;\n+       static const int NDRangeBits =1<<2;\n+       static const int StartComputeBits= 1<<3;\n+       static const int EndComputeBits= 1<<4;\n+       static const int EnterKernelDispatchBits= 1<<5;\n+       static const int LeaveKernelDispatchBits= 1<<6;\n+       OpenCLBackend *openclBackend;\n@@ -69,2 +81,0 @@\n-      \/\/ cl_event start_marker_event;\n-      \/\/ cl_event end_marker_event;\n@@ -72,0 +82,1 @@\n+       int *eventInfoBits;\n@@ -74,1 +85,2 @@\n-       OpenCLQueue();\n+\n+       OpenCLQueue(OpenCLBackend *openclBackend);\n@@ -82,1 +94,9 @@\n-       void inc();\n+       void inc(int bits);\n+       void marker(int bits);\n+       void markAsCopyToDeviceAndInc();\n+       void markAsCopyFromDeviceAndInc();\n+       void markAsNDRangeAndInc();\n+       void markAsStartComputeAndInc();\n+       void markAsEndComputeAndInc();\n+        void markAsEnterKernelDispatchAndInc();\n+         void markAsLeaveKernelDispatchAndInc();\n@@ -96,1 +116,0 @@\n-\n@@ -99,1 +118,0 @@\n-\n@@ -105,1 +123,0 @@\n-\n@@ -109,1 +126,0 @@\n-\n","filename":"hat\/backends\/ffi\/opencl\/include\/opencl_backend.h","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,5 +41,1 @@\n-#define LongUnsignedNewline \"%llu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#define LongHexNewline \"(0x%llx)\\n\"\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF snprintf\n+   #define SNPRINTF snprintf\n@@ -47,14 +43,7 @@\n-\n-#include <malloc.h>\n-\n-#define LongHexNewline \"(0x%lx)\\n\"\n-#define LongUnsignedNewline \"%lu\\n\"\n-#define Size_tNewline \"%lu\\n\"\n-#if defined (_WIN32)\n-#include \"windows.h\"\n-#define alignedMalloc(size, alignment) _aligned_malloc(size, alignment)\n-#define SNPRINTF _snprintf\n-#else\n-#define alignedMalloc(size, alignment) memalign(alignment, size)\n-#define SNPRINTF  snprintf\n-#endif\n+   #include <malloc.h>\n+   #if defined (_WIN32)\n+      #include \"windows.h\"\n+      #define SNPRINTF _snprintf\n+   #else\n+      #define SNPRINTF  snprintf\n+   #endif\n@@ -62,0 +51,1 @@\n+\n@@ -81,0 +71,4 @@\n+ #define UNKNOWN_BYTE 0\n+ #define RO_BYTE (1<<1)\n+ #define WO_BYTE (1<<2)\n+ #define RW_BYTE (RO_BYTE|WO_BYTE)\n@@ -85,1 +79,1 @@\n-    u8_t access;          \/\/ 0=??\/1=RO\/2=WO\/3=RW if this is a buffer\n+    u8_t access;          \/\/ see hat\/buffer\/ArgArray.java  UNKNOWN_BYTE=0, RO_BYTE =1<<1,WO_BYTE =1<<2,RW_BYTE =RO_BYTE|WO_BYTE;\n@@ -210,1 +204,1 @@\n-     static BufferState_s* of(Arg_s *arg){\n+     static BufferState_s* of(Arg_s *arg){ \/\/ access?\n@@ -272,0 +266,1 @@\n+                          << \", char access= 0x\" << std::hex << (unsigned char) a->value.buffer.access << std::dec\n","filename":"hat\/backends\/ffi\/shared\/include\/shared.h","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -190,0 +190,2 @@\n+\n+    var backendJars = new ArrayList<bldr.Bldr.JarFile>();\n@@ -198,0 +200,1 @@\n+                backendJars.add(ffiBackendJarFile);\n@@ -210,0 +213,2 @@\n+    var jextractedSharedBackendJar=buildDir.jarFile(\"hat-backend-jextracted-shared-1.0.jar\");\n+    backendJars.add(jextractedSharedBackendJar);\n@@ -211,1 +216,1 @@\n-          .jarFile(buildDir.jarFile(\"hat-backend-jextracted-shared-1.0.jar\"))\n+          .jarFile(jextractedSharedBackendJar)\n@@ -221,0 +226,2 @@\n+       var jextractedOpenCLBackendJar = buildDir.jarFile(\"hat-backend-jextracted-opencl-1.0.jar\");\n+       backendJars.add(jextractedOpenCLBackendJar);\n@@ -222,1 +229,1 @@\n-          .jarFile(buildDir.jarFile(\"hat-backend-jextracted-opencl-1.0.jar\"))\n+          .jarFile(jextractedOpenCLBackendJar)\n@@ -236,2 +243,3 @@\n-                var backendJarFile = buildDir.jarFile(\"hat-backend-java-\" + backend.fileName() + \"-1.0.jar\");\n-                out.println(backendJarFile.fileName());\n+                var backendJavaJar = buildDir.jarFile(\"hat-backend-java-\" + backend.fileName() + \"-1.0.jar\");\n+                out.println(backendJavaJar.fileName());\n+                backendJars.add(backendJavaJar);\n@@ -239,1 +247,1 @@\n-                        .jarFile(backendJarFile)\n+                        .jarFile(backendJavaJar)\n@@ -244,0 +252,2 @@\n+    backendJars.forEach(j->out.println(\" backend \"+j.path()));\n+\n","filename":"hat\/bld","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2643,2 +2643,1 @@\n-                return DirEntry.of(\"\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX14.0.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\");\n-                \/\/ return DirEntry.of(Path.of(cmakeProbe.value(glutIncludeDirKey))+\"\/Headers\");\n+                return DirEntry.of(cmakeProbe.value(osxSysroot)+\"\/System\/Library\/Frameworks\/GLUT.framework\/Headers\");\n@@ -2651,3 +2650,0 @@\n-            \/\/ public Path frameworkLibrary(String frameworkName) {\n-            \/\/     return Path.of(appLibFrameworks()).resolve(frameworkName + \".framework\/\" + frameworkName);\n-            \/\/  }\n","filename":"hat\/bldr\/Bldr.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    # Windows?\n@@ -65,0 +66,1 @@\n+    #MIPS?\n@@ -76,2 +78,0 @@\n-    # export BABYLON_JDK_HOME=${BABYLON_JDK_HOME:-$(realpath ${PWD}\/..)}\n-\n@@ -81,0 +81,1 @@\n+       echo \"We found a babylon build here ${BABYLON_JDK_HOME}\"\n@@ -85,0 +86,26 @@\n+    if command -v jextract; then \n+       echo 'jextract in your PATH'\n+    else\n+       if [[ -z \"${JEXTRACT_HOME}\" ]]; then \n+          echo \"No user provided JEXTRACT_HOME var, we will try ~\/jextract-22\"\n+          if [[ -d ~\/jextract-22\/bin ]]; then \n+             export JEXTRACT_HOME=$(realpath ~\/jextract-22)\n+             echo \"We found jextract here ${JEXTRACT_HOME}\"\n+          fi\n+       else\n+          echo \"Using user supplied JEXTRACT_HOME ${JEXTRACT_HOME}\"\n+       fi\n+    fi\n+\n+    if [[ -d \"${JEXTRACT_HOME}\/bin\" ]]; then\n+      if echo ${PATH} | grep ${JEXTRACT_HOME} >\/dev\/null ;then\n+         echo \"PATH already contains \\${JEXTRACT_HOME}\/bin\"\n+      else\n+         export SAFE_PATH=${PATH}\n+         echo \"Adding \\${JEXTRACT_HOME}\/bin prefix to PATH, SAFE_PATH contains previous value\"\n+         export PATH=${JEXTRACT_HOME}\/bin:${PATH}\n+      fi\n+    else\n+      echo 'You will need to add jextract to your PATH to be able to build'\n+      echo 'Either add it, or JEXTRACT_HOME'\n+    fi\n@@ -87,1 +114,0 @@\n-      #echo \"\\${BABYLON_JDK_HOME}\/build seems ok!\"\n@@ -89,1 +115,0 @@\n-      #echo \"exporting JAVA_HOME=${JAVA_HOME}\"\n@@ -97,11 +122,0 @@\n-\n-      if [[ ${1} = \"clean\" ]]; then \n-         rm -rf build \n-      fi \n-\n-      if command -v jextract; then \n-         echo 'SUCCESS.. Found a valid JDK and found jextract in your PATH'\n-      else\n-         echo 'CAUTION.. Found a valid JDK, but you will need to add jextract to your PATH to be able to build'\n-      fi\n-\n","filename":"hat\/env.bash","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import static hat.ifacemapper.MappableIface.*;\n@@ -44,1 +45,1 @@\n-        public static void inc(KernelContext kc, S32Array s32Array, int len) {\n+        public static void inc(@RO KernelContext kc, @RW S32Array s32Array, int len) {\n@@ -51,1 +52,1 @@\n-        public static void multiply(ComputeContext cc, S32Array s32Array, int len, int n) {\n+        public static void multiply(ComputeContext cc, @RW S32Array s32Array, int len, int n) {\n@@ -59,1 +60,2 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),  new OpenCLBackend(of(PROFILE(), TRACE_COPIES(), GPU(),MINIMIZE_COPIES())));\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(),\n+                new OpenCLBackend(of(PROFILE(), TRACE_COPIES(), GPU(),MINIMIZE_COPIES())));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-        boolean useHat = true;\n+        boolean useHat = false;\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-\n-import nbody.opencl.NBody;\n+import nbody.opencl.OpenCLNBodyGLWindow;\n@@ -31,1 +30,0 @@\n-import java.io.IOException;\n@@ -35,1 +33,1 @@\n-    public static void main(String[] args) throws IOException {\n+    public static void main(String[] args)  {\n@@ -37,5 +35,4 @@\n-        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.HAT.toString());\n-        System.out.println(\"mode\" + mode);\n-        try (var arena = mode.equals(NBodyGLWindow.Mode.JavaMT4) || mode.equals(NBodyGLWindow.Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n-            var particleTexture = new GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n-            new NBody.CLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n+        Mode mode = Mode.of(args.length > 3 ? args[3] : Mode.OpenCL.toString());\n+        try (var arena = mode.equals(Mode.JavaMT4) || mode.equals(Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n+            var particleTexture = new GLTexture(arena, Main.class.getResourceAsStream(\"\/particle.png\"));\n+            new OpenCLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package nbody;\n+\n+public enum Mode {\n+    HAT, OpenCL, Cuda, OpenCL4, Cuda4, JavaSeq, JavaMT, JavaSeq4, JavaMT4;\n+\n+    public static Mode of(String s) {\n+        return switch (s) {\n+            case \"HAT\" -> Mode.HAT;\n+            case \"OpenCL\" -> Mode.OpenCL;\n+            case \"Cuda\" -> Mode.Cuda;\n+            case \"JavaSeq\" -> Mode.JavaSeq;\n+            case \"JavaMT\" -> Mode.JavaMT;\n+            case \"JavaSeq4\" -> Mode.JavaSeq4;\n+            case \"JavaMT4\" -> Mode.JavaMT4;\n+            case \"OpenCL4\" -> Mode.OpenCL4;\n+            case \"Cuda4\" -> Mode.Cuda4;\n+            default -> throw new IllegalStateException(\"No mode \" + s);\n+        };\n+    }\n+}\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Mode.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -58,1 +58,1 @@\n-public class NBodyGLWindow extends GLWindow {\n+public abstract class NBodyGLWindow extends GLWindow {\n@@ -182,2 +182,0 @@\n-\n-\n@@ -191,1 +189,0 @@\n-\n@@ -196,2 +193,2 @@\n-    for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n-        var bodyf4 = xyzPosFloatArr.get(bodyIdx);\n+                for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n+                    var bodyf4 = xyzPosFloatArr.get(bodyIdx);\n@@ -212,8 +209,8 @@\n-        glTexCoord2f(WEST, SOUTH);\n-        glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n-        glTexCoord2f(WEST, NORTH);\n-        glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n-        glTexCoord2f(EAST, NORTH);\n-        glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n-        glTexCoord2f(EAST, SOUTH);\n-        glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(WEST, SOUTH);\n+                    glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(WEST, NORTH);\n+                    glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(EAST, NORTH);\n+                    glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                    glTexCoord2f(EAST, SOUTH);\n+                    glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n@@ -221,1 +218,1 @@\n-}\n+                }\n@@ -224,1 +221,0 @@\n-\n@@ -226,1 +222,0 @@\n-        \/\/glUseProgram(0);\n@@ -233,5 +228,1 @@\n-            var FPS = \"Mode: \"+mode.toString()+\" Bodies \"+bodyCount+\" FPS: \"+((frameCount \/ secs));\n-          \/\/ System.out.print(\" gw \"+glutGet(GLUT_SCREEN_WIDTH())+\" gh \"+glutGet(GLUT_SCREEN_HEIGHT()));\n-           \/\/ System.out.print(\" a \"+aspect+\",s \"+size);\n-            \/\/ System.out.println(\" w \"+width+\" h\"+height);\n-\n+            var FPS = \"Mode: \" + mode.toString() + \" Bodies \" + bodyCount + \" FPS: \" + ((frameCount \/ secs));\n@@ -245,1 +236,0 @@\n-\n@@ -253,30 +243,0 @@\n-\n-\n-\n-    public enum Mode  {\n-        HAT,OpenCL, Cuda, OpenCL4, Cuda4, JavaSeq, JavaMT, JavaSeq4, JavaMT4;\n-\n-        public static Mode of(String s) {\n-            return switch (s) {\n-                case \"HAT\" -> Mode.HAT;\n-                case \"OpenCL\" -> Mode.OpenCL;\n-                case \"Cuda\" -> Mode.Cuda;\n-                case \"JavaSeq\" -> Mode.JavaSeq;\n-                case \"JavaMT\" -> Mode.JavaMT;\n-                case \"JavaSeq4\" -> Mode.JavaSeq4;\n-                case \"JavaMT4\" -> Mode.JavaMT4;\n-                case \"OpenCL4\" -> Mode.OpenCL4;\n-                case \"Cuda4\" -> Mode.Cuda4;\n-                default -> throw new IllegalStateException(\"No mode \" + s);\n-            };\n-        }\n-    }\n-    public static void main(String[] args) throws IOException {\n-        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768\/2\/2;\n-        Mode mode = Mode.of(args.length>3?args[3]: Mode.HAT.toString());\n-        System.out.println(\"mode\" + mode);\n-        try (var arena = mode.equals(Mode.JavaMT)||mode.equals(Mode.JavaMT4) ? Arena.ofShared() : Arena.ofConfined()) {\n-            var particleTexture = new GLTexture(arena, NBodyGLWindow.class.getResourceAsStream(\"\/particle.png\"));\n-            new NBodyGLWindow(arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n-        }\n-    }\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/NBodyGLWindow.java","additions":13,"deletions":53,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package nbody;\n+\n+import hat.Accelerator;\n+import hat.buffer.Buffer;\n+import hat.ifacemapper.Schema;\n+\n+public interface Universe extends Buffer {\n+    int length();\n+\n+    interface Body extends Struct {\n+        float x();\n+\n+        float y();\n+\n+        float z();\n+\n+        float vx();\n+\n+        float vy();\n+\n+        float vz();\n+\n+        void x(float x);\n+\n+        void y(float y);\n+\n+        void z(float z);\n+\n+        void vx(float vx);\n+\n+        void vy(float vy);\n+\n+        void vz(float vz);\n+    }\n+\n+    Body body(long idx);\n+\n+    \/*\n+    typedef struct Body_s{\n+        float x;\n+        float y;\n+        float y;\n+        float vx;\n+        float vy;\n+        float y;\n+    } Body_t;\n+\n+    typedef struct Universe_s{\n+       int length;\n+       Body_t body[1];\n+    }Universe_t;\n+\n+     *\/\n+    Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n+\n+            .arrayLen(\"length\").array(\"body\", array -> array\n+                    .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n+            )\n+    );\n+\n+    static Universe create(Accelerator accelerator, int length) {\n+        return schema.allocate(accelerator, length);\n+    }\n+\n+}\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/Universe.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -1,409 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nbody.opencl;\n-\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.backend.ffi.OpenCLBackend;\n-import hat.buffer.Buffer;\n-import hat.KernelContext;\n-import hat.ifacemapper.MappableIface;\n-import static hat.ifacemapper.MappableIface.*;\n-import static opengl.opengl_h.glMatrixMode;\n-import static opengl.opengl_h.glRasterPos2f;\n-import static opengl.opengl_h.glScalef;\n-import static opengl.opengl_h.glTexCoord2f;\n-import static opengl.opengl_h.glVertex3f;\n-import static opengl.opengl_h.glutBitmapCharacter;\n-import static opengl.opengl_h.glutBitmapTimesRoman24$segment;\n-import static opengl.opengl_h.glutSwapBuffers;\n-import static opengl.opengl_h_1.glBindTexture;\n-import static opengl.opengl_h_1.glClear;\n-import static opengl.opengl_h_1.glClearColor;\n-import static opengl.opengl_h_1.glColor3f;\n-import static opengl.opengl_h_1.glDisable;\n-import static opengl.opengl_h_1.glEnable;\n-import static opengl.opengl_h_2.GL_COLOR_BUFFER_BIT;\n-import static opengl.opengl_h_2.GL_DEPTH_BUFFER_BIT;\n-import static opengl.opengl_h_2.GL_MODELVIEW;\n-import static opengl.opengl_h_2.GL_TEXTURE_2D;\n-\n-import hat.ifacemapper.Schema;\n-import jdk.incubator.code.CodeReflection;\n-import nbody.NBodyGLWindow;\n-import wrap.clwrap.CLPlatform;\n-import wrap.clwrap.CLWrapComputeContext;\n-import wrap.glwrap.GLTexture;\n-\n-import java.io.IOException;\n-import java.lang.foreign.Arena;\n-import java.lang.invoke.MethodHandles;\n-\n-public class NBody {\n-    public static class CLNBodyGLWindow extends NBodyGLWindow {\n-        public interface Universe extends Buffer {\n-            int length();\n-\n-            interface Body extends Struct {\n-                float x();\n-\n-                float y();\n-\n-                float z();\n-\n-                float vx();\n-\n-                float vy();\n-\n-                float vz();\n-\n-                void x(float x);\n-\n-                void y(float y);\n-\n-                void z(float z);\n-\n-                void vx(float vx);\n-\n-                void vy(float vy);\n-\n-                void vz(float vz);\n-            }\n-\n-            Body body(long idx);\n-            \/*\n-            typedef Body_s{\n-                float x;\n-                float y;\n-                float vx;\n-                float vy;\n-            } Body_t;\n-\n-            typedef Universe_s{\n-               int length;\n-               Body body[1];\n-            }Universe_t;\n-\n-             *\/\n-            Schema<Universe> schema = Schema.of(Universe.class, resultTable -> resultTable\n-\n-                    .arrayLen(\"length\").array(\"body\", array -> array\n-                            .fields(\"x\", \"y\", \"z\", \"vx\", \"vy\", \"vz\")\n-                    )\n-            );\n-\n-            static Universe create(Accelerator accelerator, int length) {\n-                return schema.allocate(accelerator, length);\n-            }\n-\n-        }\n-\n-\n-        @CodeReflection\n-        static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n-            float accx = 0.0f;\n-            float accy = 0.0f;\n-            float accz = 0.0f;\n-            Universe.Body me = universe.body(kc.x);\n-\n-            for (int i = 0; i < kc.maxX; i++) {\n-                Universe.Body body = universe.body(i);\n-                float dx = body.x() - me.x();\n-                float dy = body.y() - me.y();\n-                float dz = body.z() - me.z();\n-                float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n-                float s = mass * invDist * invDist * invDist;\n-                accx = accx + (s * dx);\n-                accy = accy + (s * dy);\n-                accz = accz + (s * dz);\n-            }\n-            accx = accx * delT;\n-            accy = accy * delT;\n-            accz = accz * delT;\n-            me.x(me.x() + (me.vx() * delT + accx * .5f * delT));\n-            me.y(me.y() + (me.vy() * delT + accy * .5f * delT));\n-            me.z(me.z() + (me.vz() * delT + accz * .5f * delT));\n-            me.vx(me.vx() + accx);\n-            me.vy(me.vy() + accy);\n-            me.vz(me.vz() + accz);\n-        }\n-\n-        @CodeReflection\n-        public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, float mass, float delT, float espSqr) {\n-            float cmass = mass;\n-            float cdelT = delT;\n-            float cespSqr= espSqr;\n-\n-            cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n-        }\n-\n-\n-        final CLPlatform.CLDevice.CLContext.CLProgram.CLKernel kernel;\n-        final CLWrapComputeContext clWrapComputeContext;\n-        final CLWrapComputeContext.MemorySegmentState vel;\n-        final CLWrapComputeContext.MemorySegmentState pos;\n-final Accelerator accelerator;\n-final Universe universe;\n-        public CLNBodyGLWindow( Arena arena, int width, int height, GLTexture particle, int bodyCount, Mode mode) {\n-            super( arena, width, height, particle, bodyCount, mode);\n-            final float maxDist = 80f;\n-            if (mode.equals(Mode.HAT)){\n-                kernel = null;\n-                clWrapComputeContext = null;\n-                vel=null;\n-                pos=null;\n-                accelerator = new Accelerator(MethodHandles.lookup(),\n-                        new OpenCLBackend(OpenCLBackend.Mode.of(\"GPU\"))\n-                );\n-                universe = Universe.create(accelerator, bodyCount);\n-                for (int body = 0; body < bodyCount; body++) {\n-                    Universe.Body b = universe.body(body);\n-                    final float theta = (float) (Math.random() * Math.PI * 2);\n-                    final float phi = (float) (Math.random() * Math.PI * 2);\n-                    final float radius = (float) (Math.random() * maxDist);\n-\n-                    \/\/ get random 3D coordinates in sphere\n-                    b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n-                    b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n-                    b.z((float) (radius * Math.cos(phi)));\n-                }\n-\n-\n-            }else {\n-                this.universe = null;\n-                this.accelerator=null;\n-                this.clWrapComputeContext = new CLWrapComputeContext(arena, 20);\n-                this.vel = clWrapComputeContext.register(xyzVelFloatArr.ptr());\n-                this.pos = clWrapComputeContext.register(xyzPosFloatArr.ptr());\n-\n-                var platforms = CLPlatform.platforms(arena);\n-                System.out.println(\"platforms \" + platforms.size());\n-                var platform = platforms.get(0);\n-                platform.devices.forEach(device -> {\n-                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                    System.out.println(\"   Device Name       \" + device.deviceName());\n-                    System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n-                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                });\n-                var device = platform.devices.get(0);\n-                System.out.println(\"   Compute Units     \" + device.computeUnits());\n-                System.out.println(\"   Device Name       \" + device.deviceName());\n-                System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n-\n-                System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n-                var context = device.createContext();\n-                String code = switch (mode) {\n-                    case Mode.OpenCL -> \"\"\"\n-                            __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n-                                int body = get_global_id(0);\n-                                int STRIDE=4;\n-                                int Xidx=0;\n-                                int Yidx=1;\n-                                int Zidx=2;\n-                                int bodyStride = body*STRIDE;\n-                                int bodyStrideX = bodyStride+Xidx;\n-                                int bodyStrideY = bodyStride+Yidx;\n-                                int bodyStrideZ = bodyStride+Zidx;\n-\n-                                float accx = 0.0;\n-                                float accy = 0.0;\n-                                float accz = 0.0;\n-                                float myPosx = xyzPos[bodyStrideX];\n-                                float myPosy = xyzPos[bodyStrideY];\n-                                float myPosz = xyzPos[bodyStrideZ];\n-                                for (int i = 0; i < get_global_size(0); i++) {\n-                                    int iStride = i*STRIDE;\n-                                    float dx = xyzPos[iStride+Xidx] - myPosx;\n-                                    float dy = xyzPos[iStride+Yidx] - myPosy;\n-                                    float dz = xyzPos[iStride+Zidx] - myPosz;\n-                                    float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n-                                    float s = mass * invDist * invDist * invDist;\n-                                    accx = accx + (s * dx);\n-                                    accy = accy + (s * dy);\n-                                    accz = accz + (s * dz);\n-                                }\n-                                accx = accx * delT;\n-                                accy = accy * delT;\n-                                accz = accz * delT;\n-                                xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n-                                xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n-                                xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n-\n-                                xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n-                                xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n-                                xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n-\n-                            }\n-                            \"\"\";\n-                   \/* case Mode.OpenCL4 -> \"\"\"\n-                            __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n-                                float4 acc = (0.0,0.0,0.0,0.0);\n-                                float4 myPos = xyzPos[get_global_id(0)];\n-                                float4 myVel = xyzVel[get_global_id(0)];\n-                                for (int i = 0; i < get_global_size(0); i++) {\n-                                       float4 delta =  xyzPos[i] - myPos;\n-                                       float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n-                                       float s = mass * invDist * invDist * invDist;\n-                                       acc= acc + (s * delta);\n-                                }\n-                                acc = acc*delT;\n-                                myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n-                                myVel = myVel + acc;\n-                                xyzPos[get_global_id(0)] = myPos;\n-                                xyzVel[get_global_id(0)] = myVel;\n-\n-                            }\n-                            \"\"\";*\/\n-                    case Mode.OpenCL4 -> \"\"\"\n-                            __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n-                                float4 acc = (0.0,0.0,0.0,0.0);\n-                                float4 myPos = xyzPos[get_global_id(0)];\n-                                float4 myVel = xyzVel[get_global_id(0)];\n-                                for (int i = 0; i < get_global_size(0); i++) {\n-                                       float4 delta =  xyzPos[i] - myPos;\n-                                       float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n-                                       float s = mass * invDist * invDist * invDist;\n-                                       acc= acc + (s * delta);\n-                                }\n-                                acc = acc*delT;\n-                                myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n-                                myVel = myVel + acc;\n-                                xyzPos[get_global_id(0)] = myPos;\n-                                xyzVel[get_global_id(0)] = myVel;\n-\n-                            }\n-                            \"\"\";\n-                    default -> throw new IllegalStateException();\n-                };\n-                var program = context.buildProgram(code);\n-                kernel = program.getKernel(\"nbody\");\n-            }\n-        }\n-        @Override\n-        public void display() {\n-            if (mode.equals(Mode.HAT)) {\n-                moveBodies();\n-                glClearColor(0f, 0f, 0f, 0f);\n-                glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n-                glEnable(GL_TEXTURE_2D()); \/\/ Annoyingly important,\n-                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(particle.idx));\n-\n-                glPushMatrix1(() -> {\n-                    glScalef(.01f, .01f, .01f);\n-                    glColor3f(1f, 1f, 1f);\n-                    glQuads(() -> {\n-                        for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n-                            var bodyf4 = universe.body(bodyIdx);\/\/xyzPosFloatArr.get(bodyIdx);\n-\n-                            \/*\n-                             * Textures are mapped to a quad by defining the vertices in\n-                             * the order SW,NW,NE,SE\n-                             &\n-                             *   2--->3\n-                             *   ^    |\n-                             *   |    v\n-                             *   1    4\n-                             *\n-                             * Here we are describing the 'texture plane' for the body.\n-                             * Ideally we need to rotate this to point to the camera (see billboarding)\n-                             *\/\n-\n-                            glTexCoord2f(WEST, SOUTH);\n-                            glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n-                            glTexCoord2f(WEST, NORTH);\n-                            glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n-                            glTexCoord2f(EAST, NORTH);\n-                            glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n-                            glTexCoord2f(EAST, SOUTH);\n-                            glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n-\n-                        }\n-                    });\n-                });\n-\n-                glDisable(GL_TEXTURE_2D()); \/\/ Annoyingly important .. took two days to work that out\n-                \/\/glUseProgram(0);\n-                glMatrixMode(GL_MODELVIEW());\n-                glPushMatrix1(() -> {\n-                    glColor3f(0.0f, 1.0f, 0.0f);\n-                    var font = glutBitmapTimesRoman24$segment();\n-                    long elapsed = System.currentTimeMillis() - startTime;\n-                    float secs = elapsed \/ 1000f;\n-                    var FPS = \"Mode: \"+mode.toString()+\" Bodies \"+bodyCount+\" FPS: \"+((frameCount \/ secs));\n-                    \/\/ System.out.print(\" gw \"+glutGet(GLUT_SCREEN_WIDTH())+\" gh \"+glutGet(GLUT_SCREEN_HEIGHT()));\n-                    \/\/ System.out.print(\" a \"+aspect+\",s \"+size);\n-                    \/\/ System.out.println(\" w \"+width+\" h\"+height);\n-\n-                    glRasterPos2f(-.8f, .7f);\n-                    for (int c : FPS.getBytes()) {\n-                        glutBitmapCharacter(font, c);\n-                    }\n-                });\n-                glutSwapBuffers();\n-                frameCount++;\n-            }else{\n-                super.display();\n-            }\n-        }\n-\n-\n-        @Override\n-        protected void moveBodies() {\n-            if (mode.equals(Mode.HAT)) {\n-                float cmass = mass;\n-                float cdelT = delT;\n-                float cespSqr = espSqr;\n-                Universe cuniverse = universe;\n-                accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n-            }else if (mode.equals(Mode.OpenCL4) || mode.equals(Mode.OpenCL)) {\n-                if (frameCount == 0) {\n-                    vel.copyToDevice = true;\n-                    pos.copyToDevice = true;\n-                } else {\n-                    vel.copyToDevice = false;\n-                    pos.copyToDevice = false;\n-                }\n-                vel.copyFromDevice = false;\n-                pos.copyFromDevice = true;\n-\n-                kernel.run(clWrapComputeContext, bodyCount, pos, vel, mass, delT, espSqr);\n-            } else {\n-                super.moveBodies();\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768;\n-        NBodyGLWindow.Mode mode = NBodyGLWindow.Mode.of(args.length > 3 ? args[3] : NBodyGLWindow.Mode.OpenCL4.toString());\n-        System.out.println(\"mode\" + mode);\n-        try (var arena = mode.equals(NBodyGLWindow.Mode.JavaMT4) || mode.equals(NBodyGLWindow.Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n-            var particleTexture = new GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n-            new CLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n-        }\n-    }\n-}\n-\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/NBody.java","additions":0,"deletions":409,"binary":false,"changes":409,"status":"deleted"},{"patch":"@@ -0,0 +1,362 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package nbody.opencl;\n+\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.KernelContext;\n+import hat.backend.ffi.OpenCLBackend;\n+import hat.ifacemapper.SegmentMapper;\n+import jdk.incubator.code.CodeReflection;\n+import nbody.Mode;\n+import nbody.NBodyGLWindow;\n+import nbody.Universe;\n+import wrap.clwrap.CLPlatform;\n+import wrap.clwrap.CLWrapComputeContext;\n+import wrap.glwrap.GLTexture;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.invoke.MethodHandles;\n+\n+import static hat.ifacemapper.MappableIface.RO;\n+import static hat.ifacemapper.MappableIface.RW;\n+import static opengl.opengl_h.glMatrixMode;\n+import static opengl.opengl_h.glRasterPos2f;\n+import static opengl.opengl_h.glScalef;\n+import static opengl.opengl_h.glTexCoord2f;\n+import static opengl.opengl_h.glVertex3f;\n+import static opengl.opengl_h.glutBitmapCharacter;\n+import static opengl.opengl_h.glutBitmapTimesRoman24$segment;\n+import static opengl.opengl_h.glutSwapBuffers;\n+import static opengl.opengl_h_1.glBindTexture;\n+import static opengl.opengl_h_1.glClear;\n+import static opengl.opengl_h_1.glClearColor;\n+import static opengl.opengl_h_1.glColor3f;\n+import static opengl.opengl_h_1.glDisable;\n+import static opengl.opengl_h_1.glEnable;\n+import static opengl.opengl_h_2.GL_COLOR_BUFFER_BIT;\n+import static opengl.opengl_h_2.GL_DEPTH_BUFFER_BIT;\n+import static opengl.opengl_h_2.GL_MODELVIEW;\n+import static opengl.opengl_h_2.GL_TEXTURE_2D;\n+\n+\n+public class OpenCLNBodyGLWindow extends NBodyGLWindow {\n+\n+\n+    @CodeReflection\n+    static public void nbodyKernel(@RO KernelContext kc, @RW Universe universe, float mass, float delT, float espSqr) {\n+        float accx = 0.0f;\n+        float accy = 0.0f;\n+        float accz = 0.0f;\n+        Universe.Body me = universe.body(kc.x);\n+\n+        for (int i = 0; i < kc.maxX; i++) {\n+            Universe.Body otherBody = universe.body(i);\n+            float dx = otherBody.x() - me.x();\n+            float dy = otherBody.y() - me.y();\n+            float dz = otherBody.z() - me.z();\n+            float invDist = (float) (1.0f \/ Math.sqrt(((dx * dx) + (dy * dy) + (dz * dz) + espSqr)));\n+            float s = mass * invDist * invDist * invDist;\n+            accx = accx + (s * dx);\n+            accy = accy + (s * dy);\n+            accz = accz + (s * dz);\n+        }\n+        accx = accx * delT;\n+        accy = accy * delT;\n+        accz = accz * delT;\n+        me.x(me.x() + (me.vx() * delT) + accx * .5f * delT);\n+        me.y(me.y() + (me.vy() * delT) + accy * .5f * delT);\n+        me.z(me.z() + (me.vz() * delT) + accz * .5f * delT);\n+        me.vx(me.vx() + accx);\n+        me.vy(me.vy() + accy);\n+        me.vz(me.vz() + accz);\n+    }\n+\n+    @CodeReflection\n+    public static void nbodyCompute(@RO ComputeContext cc, @RW Universe universe, float mass, float delT, float espSqr) {\n+        float cmass = mass;\n+        float cdelT = delT;\n+        float cespSqr = espSqr;\n+\n+        cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n+    }\n+\n+\n+    final CLPlatform.CLDevice.CLContext.CLProgram.CLKernel kernel;\n+    final CLWrapComputeContext clWrapComputeContext;\n+   \/\/ final CLWrapComputeContext.MemorySegmentState vel;\n+   \/\/ final CLWrapComputeContext.MemorySegmentState pos;\n+    final Accelerator accelerator;\n+    final Universe universe;\n+\n+    public OpenCLNBodyGLWindow(Arena arena, int width, int height, GLTexture particle, int bodyCount, Mode mode) {\n+        super(arena, width, height, particle, bodyCount, mode);\n+        final float maxDist = 80f;\n+        accelerator = new Accelerator(MethodHandles.lookup(),\n+                new OpenCLBackend(OpenCLBackend.Mode.of(\"GPU\"))\n+        );\n+        universe = Universe.create(accelerator, bodyCount);\n+        for (int body = 0; body < bodyCount; body++) {\n+            Universe.Body b = universe.body(body);\n+            final float theta = (float) (Math.random() * Math.PI * 2);\n+            final float phi = (float) (Math.random() * Math.PI * 2);\n+            final float radius = (float) (Math.random() * maxDist);\n+\n+            \/\/ get random 3D coordinates in sphere\n+            b.x((float) (radius * Math.cos(theta) * Math.sin(phi)));\n+            b.y((float) (radius * Math.sin(theta) * Math.sin(phi)));\n+            b.z((float) (radius * Math.cos(phi)));\n+        }\n+        if (mode.equals(Mode.HAT)) {\n+            this.kernel=null;\n+            this.clWrapComputeContext=null;\n+        }else{\n+            this.clWrapComputeContext = new CLWrapComputeContext(arena, 20);\n+           \/\/ this.vel = clWrapComputeContext.register(xyzVelFloatArr.ptr());\n+           \/\/ this.pos = clWrapComputeContext.register(xyzPosFloatArr.ptr());\n+\n+            var platforms = CLPlatform.platforms(arena);\n+            System.out.println(\"platforms \" + platforms.size());\n+            var platform = platforms.get(0);\n+            platform.devices.forEach(device -> {\n+                System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                System.out.println(\"   Device Name       \" + device.deviceName());\n+                System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+                System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+            });\n+            var device = platform.devices.get(0);\n+            System.out.println(\"   Compute Units     \" + device.computeUnits());\n+            System.out.println(\"   Device Name       \" + device.deviceName());\n+            System.out.println(\"   Device Vendor       \" + device.deviceVendor());\n+\n+            System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+            var context = device.createContext();\n+            String typedefs = \"\"\"\n+                     typedef struct Body_s{\n+                          float x;\n+                          float y;\n+                          float z;\n+                          float vx;\n+                          float vy;\n+                          float vz;\n+                     } Body_t;\n+\n+                     typedef struct Universe_s{\n+                       int length;\n+                       Body_t body[0];\n+                     }Universe_t;\n+                    \"\"\";\n+            String code = switch (mode) {\n+                case Mode.OpenCL -> typedefs + \"\"\"\n+                        __kernel void nbody( __global Universe_t *universe, float mass, float delT, float espSqr ){\n+                           __global Body_t * me = universe->body+get_global_id(0);\n+                            float accx = 0.0;\n+                            float accy = 0.0;\n+                            float accz = 0.0;\n+                            for (size_t i = 0; i < get_global_size(0); i++) {\n+                               __global Body_t * otherBody = universe->body+i;\n+                                float dx = otherBody->x-me->x;\n+                                float dy = otherBody->y-me->y;\n+                                float dz = otherBody->z-me->z;\n+                                float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n+                                float s = mass * invDist * invDist * invDist;\n+                                accx = accx + (s * dx);\n+                                accy = accy + (s * dy);\n+                                accz = accz + (s * dz);\n+                            }\n+                            accx = accx * delT;\n+                            accy = accy * delT;\n+                            accz = accz * delT;\n+                            me->x = me->x+(me->vx*delT)+(accx * 0.5 * delT);\n+                            me->y = me->y+(me->vy*delT)+(accy * 0.5 * delT);\n+                            me->z = me->z+(me->vz*delT)+(accz * 0.5 * delT);\n+                            me->vx = me->vx+accx;\n+                            me->vy = me->vy+accy;\n+                            me->vz = me->vz+accz;\n+\n+                        }\n+                        \"\"\";\n+                   \/* case Mode.OpenCL4 -> \"\"\"\n+                            __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                                float4 acc = (0.0,0.0,0.0,0.0);\n+                                float4 myPos = xyzPos[get_global_id(0)];\n+                                float4 myVel = xyzVel[get_global_id(0)];\n+                                for (int i = 0; i < get_global_size(0); i++) {\n+                                       float4 delta =  xyzPos[i] - myPos;\n+                                       float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                                       float s = mass * invDist * invDist * invDist;\n+                                       acc= acc + (s * delta);\n+                                }\n+                                acc = acc*delT;\n+                                myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                                myVel = myVel + acc;\n+                                xyzPos[get_global_id(0)] = myPos;\n+                                xyzVel[get_global_id(0)] = myVel;\n+\n+                            }\n+                            \"\"\";*\/\n+                case Mode.OpenCL4 -> typedefs + \"\"\"\n+                        __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                            float4 acc = (0.0,0.0,0.0,0.0);\n+                            float4 myPos = xyzPos[get_global_id(0)];\n+                            float4 myVel = xyzVel[get_global_id(0)];\n+                            for (int i = 0; i < get_global_size(0); i++) {\n+                                   float4 delta =  xyzPos[i] - myPos;\n+                                   float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                                   float s = mass * invDist * invDist * invDist;\n+                                   acc= acc + (s * delta);\n+                            }\n+                            acc = acc*delT;\n+                            myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                            myVel = myVel + acc;\n+                            xyzPos[get_global_id(0)] = myPos;\n+                            xyzVel[get_global_id(0)] = myVel;\n+\n+                        }\n+                        \"\"\";\n+                default -> throw new IllegalStateException();\n+            };\n+            var program = context.buildProgram(code);\n+            kernel = program.getKernel(\"nbody\");\n+        }\n+    }\n+\n+    @Override\n+    public void display() {\n+        if (mode.equals(Mode.HAT) || mode.equals(Mode.OpenCL)) {\n+            moveBodies();\n+            glClearColor(0f, 0f, 0f, 0f);\n+            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+            glEnable(GL_TEXTURE_2D()); \/\/ Annoyingly important,\n+            glBindTexture(GL_TEXTURE_2D(), textureBuf.get(particle.idx));\n+\n+            glPushMatrix1(() -> {\n+                glScalef(.01f, .01f, .01f);\n+                glColor3f(1f, 1f, 1f);\n+                glQuads(() -> {\n+                    for (int bodyIdx = 0; bodyIdx < bodyCount; bodyIdx++) {\n+                        var bodyf4 = universe.body(bodyIdx);\/\/xyzPosFloatArr.get(bodyIdx);\n+\n+                            \/*\n+                             * Textures are mapped to a quad by defining the vertices in\n+                             * the order SW,NW,NE,SE\n+                             &\n+                             *   2--->3\n+                             *   ^    |\n+                             *   |    v\n+                             *   1    4\n+                             *\n+                             * Here we are describing the 'texture plane' for the body.\n+                             * Ideally we need to rotate this to point to the camera (see billboarding)\n+                             *\/\n+\n+                        glTexCoord2f(WEST, SOUTH);\n+                        glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+                        glTexCoord2f(WEST, NORTH);\n+                        glVertex3f(bodyf4.x() + WEST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                        glTexCoord2f(EAST, NORTH);\n+                        glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + NORTH + dy, bodyf4.z() + dz);\n+                        glTexCoord2f(EAST, SOUTH);\n+                        glVertex3f(bodyf4.x() + EAST + dx, bodyf4.y() + SOUTH + dy, bodyf4.z() + dz);\n+\n+                    }\n+                });\n+            });\n+\n+            glDisable(GL_TEXTURE_2D()); \/\/ Annoyingly important .. took two days to work that out\n+            \/\/glUseProgram(0);\n+            glMatrixMode(GL_MODELVIEW());\n+            glPushMatrix1(() -> {\n+                glColor3f(0.0f, 1.0f, 0.0f);\n+                var font = glutBitmapTimesRoman24$segment();\n+                long elapsed = System.currentTimeMillis() - startTime;\n+                float secs = elapsed \/ 1000f;\n+                var FPS = \"Mode: \" + mode.toString() + \" Bodies \" + bodyCount + \" FPS: \" + ((frameCount \/ secs));\n+                \/\/ System.out.print(\" gw \"+glutGet(GLUT_SCREEN_WIDTH())+\" gh \"+glutGet(GLUT_SCREEN_HEIGHT()));\n+                \/\/ System.out.print(\" a \"+aspect+\",s \"+size);\n+                \/\/ System.out.println(\" w \"+width+\" h\"+height);\n+\n+                glRasterPos2f(-.8f, .7f);\n+                for (int c : FPS.getBytes()) {\n+                    glutBitmapCharacter(font, c);\n+                }\n+            });\n+            glutSwapBuffers();\n+            frameCount++;\n+        } else {\n+            super.display();\n+        }\n+    }\n+\n+\n+    @Override\n+    protected void moveBodies() {\n+        if (frameCount == 0) {\n+            SegmentMapper.BufferState.of(universe).setHostDirty(true).setDeviceDirty(true);\n+            \/\/ vel.copyToDevice = true;\n+            \/\/ pos.copyToDevice = true;\n+        } else {\n+            SegmentMapper.BufferState.of(universe).setHostDirty(false).setDeviceDirty(true);\n+            \/\/ vel.copyToDevice = false;\n+            \/\/pos.copyToDevice = false;\n+        }\n+        if (mode.equals(Mode.HAT)) {\n+            float cmass = mass;\n+            float cdelT = delT;\n+            float cespSqr = espSqr;\n+            Universe cuniverse = universe;\n+            accelerator.compute(cc -> nbodyCompute(cc, cuniverse, cmass, cdelT, cespSqr));\n+        } else if (mode.equals(Mode.OpenCL4) || mode.equals(Mode.OpenCL)) {\n+        \/\/    if (frameCount == 0) {\n+              \/\/  SegmentMapper.BufferState.of(universe).setHostDirty(true).setDeviceDirty(true);\n+               \/\/ vel.copyToDevice = true;\n+               \/\/ pos.copyToDevice = true;\n+          \/\/  } else {\n+            \/\/    SegmentMapper.BufferState.of(universe).setHostDirty(false).setDeviceDirty(true);\n+               \/\/ vel.copyToDevice = false;\n+                \/\/pos.copyToDevice = false;\n+           \/\/ }\n+           \/\/ vel.copyFromDevice = false;\n+          \/\/  pos.copyFromDevice = true;\n+\n+            kernel.run(clWrapComputeContext, bodyCount, universe, mass, delT, espSqr);\n+        } else {\n+            super.moveBodies();\n+        }\n+    }\n+}\n+\n+   \/* public static void main(String[] args) throws IOException {\n+        int particleCount = args.length > 2 ? Integer.parseInt(args[2]) : 32768;\n+        Mode mode = Mode.of(args.length > 3 ? args[3] : Mode.OpenCL4.toString());\n+        System.out.println(\"mode\" + mode);\n+        try (var arena = mode.equals(Mode.JavaMT4) || mode.equals(Mode.JavaMT) ? Arena.ofShared() : Arena.ofConfined()) {\n+            var particleTexture = new GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n+            new CLNBodyGLWindow( arena, 1000, 1000, particleTexture, particleCount, mode).bindEvents().mainLoop();\n+        }\n+    } *\/\n+\n+\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":362,"deletions":0,"binary":false,"changes":362,"status":"added"},{"patch":"@@ -65,1 +65,3 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,  ndRangeAndArgs);\n+           \/\/ var method = kernelCallGraph.entrypoint.getMethod();\n+          \/\/  var parameterAnnotations = method.getParameterAnnotations();\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,kernelCallGraph,  ndRangeAndArgs);\n@@ -71,1 +73,1 @@\n-            ArgArray.update(argArray, args);\n+            ArgArray.update(argArray,kernelCallGraph, args);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,  ndRangeAndArgs);\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph,  ndRangeAndArgs);\n@@ -70,1 +70,1 @@\n-            ArgArray.update(argArray,  args);\n+            ArgArray.update(argArray,kernelCallGraph,  args);\n","filename":"hat\/hat\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.callgraph.KernelCallGraph;\n@@ -30,0 +31,2 @@\n+\n+import java.lang.annotation.Annotation;\n@@ -34,0 +37,2 @@\n+\n+import static hat.buffer.ArgArray.Arg.Value.Buf.UNKNOWN_BYTE;\n@@ -41,0 +46,4 @@\n+                 byte UNKNOWN_BYTE=(byte)0;\n+                 byte RO_BYTE =(byte)1<<1;\n+                 byte WO_BYTE =(byte)1<<2;\n+                 byte RW_BYTE =RO_BYTE|WO_BYTE;\n@@ -247,1 +256,1 @@\n-    static ArgArray create(Accelerator accelerator, Object... args) {\n+    static ArgArray create(Accelerator accelerator, KernelCallGraph kernelCallGraph, Object... args) {\n@@ -277,1 +286,1 @@\n-        update(argArray,args);\n+        update(argArray,kernelCallGraph,args);\n@@ -281,1 +290,2 @@\n-    static void update(ArgArray argArray,  Object... args) {\n+    static void update(ArgArray argArray, KernelCallGraph kernelCallGraph, Object... args) {\n+        Annotation[][] parameterAnnotations = kernelCallGraph.entrypoint.getMethod().getParameterAnnotations();\n@@ -284,1 +294,1 @@\n-            Arg arg = argArray.arg(i);\n+            Arg arg = argArray.arg(i); \/\/ this should be invariant, but if we are called from create it will be 0 for all\n@@ -296,0 +306,14 @@\n+                    Annotation[] annotations = parameterAnnotations[i];\n+                    byte accessByte = UNKNOWN_BYTE;\n+                    if (annotations.length > 0) {\n+                        for (Annotation annotation : annotations) {\n+                            accessByte = switch (annotation) {\n+                                case RO ro-> Arg.Value.Buf.RO_BYTE;\n+                                case RW rw -> Arg.Value.Buf.RW_BYTE;\n+                                case WO wo -> Arg.Value.Buf.WO_BYTE;\n+                                default -> throw new IllegalStateException(\"Unexpected value: \" + annotation);\n+                            };\n+                        }\n+                    }else{\n+                        throw new IllegalArgumentException(\"Argument \" + i + \" has no access annotations\");\n+                    }\n@@ -302,0 +326,1 @@\n+                    buf.access(accessByte);\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/ArgArray.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+    @Override\n+    public Method getMethod() {\n+        return  this.method;\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/ComputeEntrypoint.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,4 @@\n-public interface Entrypoint {\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Method;\n+import java.util.List;\n@@ -29,0 +32,5 @@\n+public interface Entrypoint {\n+     Method getMethod();\n+     default Annotation[][] getParamaterAnnotations(){\n+         return getMethod().getParameterAnnotations();\n+     }\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/Entrypoint.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+    @Override\n+    public Method getMethod() {\n+       return  this.method;\n+    }\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelEntrypoint.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" project-jdk-name=\"24-ea (2)\" project-jdk-type=\"JavaSDK\">\n+  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_X\" project-jdk-name=\"24-ea (3)\" project-jdk-type=\"JavaSDK\">\n","filename":"hat\/intellij\/.idea\/misc.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,3 +12,1 @@\n-    <orderEntry type=\"module\" module-name=\"backend_opencl\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_cuda\" \/>\n-    <orderEntry type=\"module\" module-name=\"backend_spirv\" \/>\n+    <orderEntry type=\"module\" module-name=\"backend_ffi_opencl\" \/>\n@@ -16,1 +14,1 @@\n-<\/module>\n+<\/module>\n\\ No newline at end of file\n","filename":"hat\/intellij\/heal.iml","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -166,1 +166,3 @@\n-                            System.out.println(\"failed to build\" + status);\n+                            System.err.println(\"failed to build program \" + status);\n+                            System.err.println(\"Source \"+source);\n+                           \/\/ System.exit(1);\n@@ -170,1 +172,2 @@\n-                            System.out.println(\"failed to get log build \" + status.get());\n+                            System.err.println(\"failed to get log build \" + status.get());\n+                            System.exit(1);\n@@ -174,1 +177,1 @@\n-                                System.out.println(\"clGetBuildInfo (getting log) failed\");\n+                                System.out.println(\"clGetBuildInfo (getting log) failed \");\n@@ -177,0 +180,1 @@\n+                                System.out.println(\"log\\n\" +log);\n@@ -199,1 +203,1 @@\n-                            System.out.println(\"failed to create kernel \" + status);\n+                            System.out.println(\"failed to create kernel '\"+kernelName+\"'\" + status);\n@@ -215,1 +219,1 @@\n-                                        throw new RuntimeException(\"failed to create memory buffer \" + status.get());\n+                                        throw new RuntimeException(\"failed to create memory buffer for arg[\"+i+\" \" + status.get());\n@@ -230,1 +234,2 @@\n-                                        System.out.println(\"failed to enqueue write \" + status);\n+                                        System.err.println(\"failed to enqueue write for arg[\"+i+\" \" + status);\n+                                        System.exit(1);\n@@ -236,1 +241,2 @@\n-                                    System.out.println(\"failed to set arg \" + status);\n+                                    System.err.println(\"failed to set arg[\"+i+\" \" + status);\n+                                    System.exit(1);\n@@ -266,1 +272,2 @@\n-                                        System.out.println(\"failed to enqueue write \" + status);\n+                                        System.err.println(\"failed to enqueue write for arg[\"+i+\" \" + status);\n+                                        System.exit(1);\n@@ -275,1 +282,2 @@\n-                                    System.out.println(\"failed to set arg \" + status);\n+                                    System.err.println(\"failed to set arg[\"+i+\"]\" + status);\n+                                    System.exit(1);\n@@ -282,0 +290,3 @@\n+                                    case Double doubleArg -> doublePtr(doubleArg);\n+                                    case Long longArg -> longPtr(longArg);\n+                                    case Short shortArg -> shortPtr(shortArg);\n@@ -286,1 +297,3 @@\n-                                    System.out.println(\"failed to set arg \" + status);\n+                                    System.err.println(\"failed to set arg[\"+i+\"] \" + status);\n+\n+                                    System.exit(1);\n","filename":"hat\/wrap\/clwrap\/src\/main\/java\/wrap\/clwrap\/CLPlatform.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    public static ArenaHolder wrap(Arena arena) {\n+    static ArenaHolder wrap(Arena arena) {\n@@ -40,0 +40,4 @@\n+    default Wrap.ShortPtr shortPtr(short value){\n+        return Wrap.ShortPtr.of(arena(), value);\n+    }\n+\n@@ -43,0 +47,3 @@\n+    default Wrap.DoublePtr doublePtr(double value){\n+        return Wrap.DoublePtr.of(arena(), value);\n+    }\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/ArenaHolder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n@@ -37,0 +38,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -87,0 +89,19 @@\n+    public  record DoublePtr(MemorySegment ptr)  implements Ptr{\n+        public static DoublePtr of(Arena arena, double value) {\n+            return new DoublePtr(arena.allocateFrom(JAVA_DOUBLE, value));\n+        }\n+\n+        public double set(double value) {\n+            ptr.set(JAVA_DOUBLE, 0, value);\n+            return value;\n+        }\n+\n+        public double get() {\n+            return ptr.get(JAVA_DOUBLE, 0);\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return JAVA_DOUBLE.byteSize();\n+        }\n+    }\n@@ -175,0 +196,19 @@\n+        }\n+    }\n+    public record ShortPtr(MemorySegment ptr)  implements Ptr{\n+        public static ShortPtr of(Arena arena, short value) {\n+            return new ShortPtr(arena.allocateFrom(JAVA_SHORT, value));\n+        }\n+\n+        public short set(short value) {\n+            ptr.set(JAVA_SHORT, 0, value);\n+            return value;\n+        }\n+\n+        public short get() {\n+            return ptr.get(JAVA_SHORT, 0);\n+        }\n+\n+        @Override\n+        public long sizeof(){\n+            return JAVA_SHORT.byteSize();\n","filename":"hat\/wrap\/wrap\/src\/main\/java\/wrap\/Wrap.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}