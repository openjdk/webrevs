{"files":[{"patch":"@@ -109,3 +109,1 @@\n-        CoreOp.FuncOp funcOp = Op.ofMethod(computeMethod).orElseThrow();\n-        this.computeCallGraph = new ComputeCallGraph(this, computeMethod, funcOp);\n-        \/\/this.computeCallGraph.close(computeCallGraph.entrypoint);\n+        this.computeCallGraph = new ComputeCallGraph(this, computeMethod, Op.ofMethod(computeMethod).orElseThrow());\n@@ -139,2 +137,1 @@\n-    \/\/ TODO: this hack simulates minimizing calls to diealectifyToHat\n-   \/\/ Map<KernelCallGraph, CallGraph> callGraphMap = new HashMap<>();\n+\n@@ -149,11 +146,1 @@\n-\n-        \/\/ TODO: this hack simulates minimizing calls to diealectifyToHat\n-       \/\/ if (!callGraphMap.containsKey(kernelCallGraph)) {\n-            kernelCallGraph.dialectifyToHat();\n-            kernelCallGraph.convertArrayView();\n-            var cacheMeIfYouCan = new CallGraph(quoted, lambdaOp, methodRef, kernelCallGraph);\n-         \/\/   callGraphMap.put(kernelCallGraph, cacheMeIfYouCan);\n-            return cacheMeIfYouCan;\n-        \/\/}else {\n-          \/\/ return callGraphMap.get(kernelCallGraph);\n-       \/\/ }\n+        return new CallGraph(quoted, lambdaOp, methodRef, kernelCallGraph);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-    public Stream<MethodCall> callStream() {\n-        return methodRefToMethodCallMap.values().stream();\n-    }\n@@ -56,0 +53,5 @@\n+\n+    public Stream<MethodCall> callStream() {\n+        return methodRefToMethodCallMap.values().stream();\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-     *\n+     *\/\n@@ -148,2 +148,0 @@\n-\n-\n@@ -176,1 +174,1 @@\n-                                    new KernelCallGraph(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod, fow).close()\n+                                    new KernelCallGraph(this, invokeOp.invokeDescriptor(), invokeWrapperCalledMethod, fow)\n@@ -219,10 +217,0 @@\n-*\/\n-   \/\/ public void close() {\n-     \/\/   closeWithModuleOp(entrypoint);\n-   \/\/ }\n-\n-\n-\n-    \/\/public void close(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n-     \/\/   setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOp(), this));\n-    \/\/}\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -87,1 +87,18 @@\n-        setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this));\n+        CoreOp.ModuleOp initialModuleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this);\n+        HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator);\n+        CoreOp.FuncOp initialEntrypointFuncOp = tier.run(entrypoint.funcOp());\n+        entrypoint.funcOp(initialEntrypointFuncOp);\n+        List<CoreOp.FuncOp> initialFuncOps = new ArrayList<>();\n+        initialModuleOp.functionTable().forEach((_, accessableFuncOp) ->\n+                initialFuncOps.add( tier.run(accessableFuncOp))\n+        );\n+        CoreOp.ModuleOp interiModuleOp = CoreOp.module(initialFuncOps);\n+        CoreOp.FuncOp interimEntrypointFuncOp = convertArrayViewForFunc(computeContext.accelerator.lookup, entrypoint.funcOp());\n+        entrypoint.funcOp(interimEntrypointFuncOp);\n+\n+\n+        List<CoreOp.FuncOp> interimFuncOps = new ArrayList<>();\n+        interiModuleOp.functionTable().forEach((_, accessableFuncOp) ->\n+            interimFuncOps.add(convertArrayViewForFunc(computeContext.accelerator.lookup, accessableFuncOp))\n+        );\n+        setModuleOp(CoreOp.module(interimFuncOps));\n@@ -98,1 +115,1 @@\n-     *\n+     *\/\n@@ -146,12 +163,1 @@\n-    }*\/\n-\n-   \/\/ KernelCallGraph close() {\n-       \/\/ oldUpdateDag(entrypoint);\n-        \/\/ now lets sort the MethodCalls into a dependency list\n-     \/\/   calls.forEach(m -> m.rank = 0);\n-       \/\/ entrypoint.rankRecurse();\n-       \/\/ throw new RuntimeException(\"is close ever called\");\n-       \/\/ return this;\n-   \/\/ }\n-\n-  \/\/  KernelCallGraph closeWithModuleOp() {\n+    }\n@@ -159,5 +165,0 @@\n-    \/\/    setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this));\n-        \/\/calls.forEach(m -> m.rank = 0);\n-        \/\/entrypoint.rankRecurse();\n-     \/\/   return this;\n-   \/\/ }\n@@ -177,2 +178,2 @@\n-\n-    public void dialectifyToHat() {\n+\/*\n+    public void nodialectifyToHat() {\n@@ -202,1 +203,1 @@\n-          \/*  kernelReachableResolvedStream().forEach((kernel) -> {\n+           kernelReachableResolvedStream().forEach((kernel) -> {\n@@ -206,1 +207,1 @@\n-            }); *\/\n+            });\n@@ -210,1 +211,1 @@\n-    public void convertArrayView() {\n+    public void noconvertArrayView() {\n@@ -228,1 +229,1 @@\n-\n+*\/\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"}]}