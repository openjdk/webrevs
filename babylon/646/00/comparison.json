{"files":[{"patch":"@@ -111,2 +111,7 @@\n-                .space().equals().space()\n-                .varName(hatVectorStoreView);\n+                .space().equals().space();\n+        \/\/ if the value to be stored is an operation, recurse on the operation\n+        if (hatVectorStoreView.operands().get(1) instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp) {\n+            recurse(buildContext, r.op());\n+        } else {\n+            varName(hatVectorStoreView);\n+        }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,4 +90,8 @@\n-                .oparen()\n-                .varName(hatVectorStoreView)\n-                .comma()\n-                .space()\n+                .oparen();\n+        \/\/ if the value to be stored is an operation, recurse on the operation\n+        if (hatVectorStoreView.operands().get(1) instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp) {\n+            recurse(buildContext, r.op());\n+        } else {\n+            varName(hatVectorStoreView);\n+        }\n+        comma().space()\n@@ -159,3 +163,6 @@\n-        identifier(hatVSelectLoadOp.varName())\n-                .dot()\n-                .identifier(hatVSelectLoadOp.mapLane());\n+        if (hatVSelectLoadOp.operands().getFirst() instanceof Op.Result res && res.op() instanceof HATVectorLoadOp vLoadOp) {\n+            recurse(buildContext, vLoadOp);\n+        } else {\n+            identifier(hatVSelectLoadOp.varName());\n+        }\n+        dot().identifier(hatVSelectLoadOp.mapLane());\n@@ -167,3 +174,6 @@\n-        identifier(hatVSelectStoreOp.varName())\n-                .dot()\n-                .identifier(hatVSelectStoreOp.mapLane())\n+        if (hatVSelectStoreOp.operands().getFirst() instanceof Op.Result res && res.op() instanceof HATVectorLoadOp vLoadOp) {\n+            recurse(buildContext, vLoadOp);\n+        } else {\n+            identifier(hatVSelectStoreOp.varName());\n+        }\n+        dot().identifier(hatVSelectStoreOp.mapLane())\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -62,4 +62,2 @@\n-    default float[] arrayView() {\n-        float[] arr = new float[this.length()];\n-        this.copyTo(arr);\n-        return arr;\n+    default Float4.MutableImpl[] float4ArrayView() {\n+        return null;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,10 +95,1 @@\n-        CoreOp.ModuleOp interiModuleOp = CoreOp.module(initialFuncOps);\n-        CoreOp.FuncOp interimEntrypointFuncOp = convertArrayViewForFunc(computeContext.accelerator.lookup, entrypoint.funcOp());\n-        entrypoint.funcOp(interimEntrypointFuncOp);\n-\n-\n-        List<CoreOp.FuncOp> interimFuncOps = new ArrayList<>();\n-        interiModuleOp.functionTable().forEach((_, accessableFuncOp) ->\n-            interimFuncOps.add(convertArrayViewForFunc(computeContext.accelerator.lookup, accessableFuncOp))\n-        );\n-        setModuleOp(CoreOp.module(interimFuncOps));\n+        setModuleOp(CoreOp.module(initialFuncOps));\n@@ -230,148 +221,0 @@\n-    public CoreOp.FuncOp convertArrayViewForFunc(MethodHandles.Lookup l, CoreOp.FuncOp entry) {\n-        if (!OpTk.isArrayView(l, entry)) return entry;\n-        usesArrayView = true;\n-        \/\/ maps a replaced result to the result it should be replaced by\n-        Map<Op.Result, Op.Result> replaced = new HashMap<>();\n-        Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n-\n-        return entry.transform(entry.funcName(), (bb, op) -> {\n-            switch (op) {\n-                case JavaOp.InvokeOp iop -> {\n-                    if (OpTk.isBufferArray(iop) &&\n-                            OpTk.firstOperand(iop) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n-                        replaced.put(iop.result(), r);\n-                        bufferVarLoads.put(((Op.Result) OpTk.firstOperand(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op()); \/\/ map buffer VarOp to its corresponding VarLoadOp\n-                        return bb;\n-                    }\n-                }\n-                case CoreOp.VarOp vop -> {\n-                    if (OpTk.isBufferInitialize(vop) &&\n-                            OpTk.firstOperand(vop) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n-                        Op bufferLoad = replaced.get(r).op(); \/\/ gets the VarLoadOp associated w\/ og buffer\n-                        replaced.put(vop.result(), (Op.Result) OpTk.firstOperand(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n-                        return bb;\n-                    }\n-                }\n-                case CoreOp.VarAccessOp.VarLoadOp vlop -> {\n-                    if (OpTk.isBufferInitialize(vlop) &&\n-                            OpTk.firstOperand(vlop) instanceof Op.Result r) {\n-                        if (r.op() instanceof CoreOp.VarOp) { \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n-                            Op.Result replacement = (OpTk.notGlobalVarOp(vlop)) ?\n-                                    (Op.Result) OpTk.firstOperand(((Op.Result) OpTk.firstOperand(r.op())).op()) :\n-                                    bufferVarLoads.get(replaced.get(r).op()).result();\n-                            replaced.put(vlop.result(), replacement);\n-                        } else { \/\/ if this is a VarLoadOp loading in the buffer\n-                            Value loaded = OpTk.getValue(bb, replaced.get(r));\n-                            Op.Result newVlop = bb.op(CoreOp.VarAccessOp.varLoad(loaded));\n-                            bb.context().mapValue(vlop.result(), newVlop);\n-                            replaced.put(vlop.result(), newVlop);\n-                        }\n-                        return bb;\n-                    }\n-                }\n-                \/\/ handles only 1D and 2D arrays\n-                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n-                    if (OpTk.isBufferArray(alop) &&\n-                            OpTk.firstOperand(alop) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.getOrDefault(r, r);\n-                        if (((ArrayType) OpTk.firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n-                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n-                                \/\/ idea: we want to calculate the idx for the buffer access\n-                                \/\/ idx = (long) (((long) rowOp.idx * (long) buffer.width()) + alop.idx)\n-                                Op.Result x = (Op.Result) OpTk.getValue(bb, rowOp.operands().getLast());\n-                                Op.Result y = (Op.Result) OpTk.getValue(bb, alop.operands().getLast());\n-                                Op.Result ogBufferLoad = replaced.get((Op.Result) OpTk.firstOperand(rowOp));\n-                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) OpTk.firstOperand(ogBufferLoad.op()), (Op.Result) OpTk.firstOperand(ogBufferLoad.op()));\n-                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(OpTk.getValue(bb, ogBuffer)));\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n-                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n-                                Op.Result width = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, bufferLoad)));\n-                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, x));\n-                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, y));\n-                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, width)));\n-                                Op.Result mul = bb.op(JavaOp.mul(OpTk.getValue(bb, longY), OpTk.getValue(bb, longWidth)));\n-                                Op.Result idx = bb.op(JavaOp.add(OpTk.getValue(bb, longX), OpTk.getValue(bb, mul)));\n-\n-                                Class<?> storedClass = OpTk.primitiveTypeToClass(alop.result().type());\n-                                MethodRef arrayMethod = MethodRef.method(c, \"array\", storedClass, long.class);\n-                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, OpTk.getValue(bb, ogBufferLoad), OpTk.getValue(bb, idx)));\n-                                bb.context().mapValue(alop.result(), invokeRes);\n-                            } else {\n-                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, alop.operands().get(1)));\n-                                Op.Result convRes = bb.op(conv);\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n-                                Class<?> storedClass = OpTk.primitiveTypeToClass(alop.result().type());\n-                                MethodRef m = MethodRef.method(c, \"array\", storedClass, long.class);\n-                                Op.Result invokeRes = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer), convRes));\n-                                bb.context().mapValue(alop.result(), invokeRes);\n-                            }\n-                        }\n-                    }\n-                    return bb;\n-                }\n-                \/\/ handles only 1D and 2D arrays\n-                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n-                    if (OpTk.isBufferArray( asop) &&\n-                            OpTk.firstOperand(asop) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.getOrDefault(r, r);\n-                        if (((ArrayType) OpTk.firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n-                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n-                                Op.Result x = (Op.Result) rowOp.operands().getLast();\n-                                Op.Result y = (Op.Result) asop.operands().get(1);\n-                                Op.Result ogBufferLoad = replaced.get((Op.Result) OpTk.firstOperand(rowOp));\n-                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) OpTk.firstOperand(ogBufferLoad.op()), (Op.Result) OpTk.firstOperand(ogBufferLoad.op()));\n-                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(OpTk.getValue(bb, ogBuffer)));\n-                                Op.Result computed = (Op.Result) asop.operands().getLast();\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n-                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n-                                Op.Result width = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, bufferLoad)));\n-                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, x)));\n-                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, y)));\n-                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, width)));\n-                                Op.Result mul = bb.op(JavaOp.mul(OpTk.getValue(bb, longY), OpTk.getValue(bb, longWidth)));\n-                                Op.Result idx = bb.op(JavaOp.add(OpTk.getValue(bb, longX), OpTk.getValue(bb, mul)));\n-\n-                                MethodRef arrayMethod = MethodRef.method(c, \"array\", void.class, long.class, int.class);\n-                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, OpTk.getValue(bb, ogBufferLoad), OpTk.getValue(bb, idx), OpTk.getValue(bb, computed)));\n-                                bb.context().mapValue(asop.result(), invokeRes);\n-                            } else {\n-                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, OpTk.getValue(bb, asop.operands().get(1))));\n-                                Value val = OpTk.getValue(bb, asop.operands().getLast());\n-\n-                                boolean noRootVlop = (buffer.op() instanceof CoreOp.VarOp);\n-                                ClassType classType = (noRootVlop) ?\n-                                        (ClassType) ((CoreOp.VarOp) buffer.op()).varValueType() :\n-                                        (ClassType) buffer.type();\n-\n-                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n-                                Class<?> storedClass = OpTk.primitiveTypeToClass(val.type());\n-                                MethodRef m = MethodRef.method(c, \"array\", void.class, long.class, storedClass);\n-                                Op.Result invokeRes = (noRootVlop) ?\n-                                        bb.op(JavaOp.invoke(m, OpTk.getValue(bb, r), idx, val)) :\n-                                        bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer), idx, val));\n-                                bb.context().mapValue(asop.result(), invokeRes);\n-                            }\n-                        }\n-                    }\n-                    return bb;\n-                }\n-                case JavaOp.ArrayLengthOp alen -> {\n-                    if (OpTk.isBufferArray(alen) &&\n-                            OpTk.firstOperand(alen) instanceof Op.Result r) {\n-                        Op.Result buffer = replaced.get(r);\n-                        Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n-                        MethodRef m = MethodRef.method(c, \"length\", int.class);\n-                        Op.Result invokeRes = bb.op(JavaOp.invoke(m, OpTk.getValue(bb, buffer)));\n-                        bb.context().mapValue(alen.result(), invokeRes);\n-                    }\n-                    return bb;\n-                }\n-                default -> {}\n-            }\n-            bb.op(op);\n-            return bb;\n-        });\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":1,"deletions":158,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -31,14 +31,1 @@\n-import hat.dialect.HATF16AddOp;\n-import hat.dialect.HATF16BinaryOp;\n-import hat.dialect.HATF16DivOp;\n-import hat.dialect.HATF16MulOp;\n-import hat.dialect.HATF16SubOp;\n-import hat.dialect.HATF16VarOp;\n-import hat.dialect.HATMemoryOp;\n-import hat.dialect.HATThreadOp;\n-import hat.dialect.HATVectorSelectLoadOp;\n-import hat.dialect.HATVectorAddOp;\n-import hat.dialect.HATVectorDivOp;\n-import hat.dialect.HATVectorMulOp;\n-import hat.dialect.HATVectorSubOp;\n-import hat.dialect.HATVectorVarOp;\n+import hat.dialect.*;\n@@ -52,1 +39,0 @@\n-import jdk.incubator.code.TypeElement;\n@@ -56,1 +42,0 @@\n-import jdk.incubator.code.dialect.java.ArrayType;\n@@ -113,65 +98,0 @@\n-    public static Value firstOperand(Op op) {\n-        return op.operands().getFirst();\n-    }\n-\n-    public static Value getValue(Block.Builder bb, Value value) {\n-        return bb.context().getValueOrDefault(value, value);\n-    }\n-\n-    public static boolean isBufferArray( Op op) {\n-        \/\/ first check if the return is an array type\n-        \/\/if (op instanceof CoreOp.VarOp vop) {\n-        \/\/    if (!(vop.varValueType() instanceof ArrayType)) return false;\n-        \/\/} else if (!(op instanceof JavaOp.ArrayAccessOp)){\n-        \/\/    if (!(op.resultType() instanceof ArrayType)) return false;\n-        \/\/}\n-\n-        \/\/ then check if returned array is from a buffer access\n-        while (!(op instanceof JavaOp.InvokeOp iop)) {\n-            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n-                op = r.op();\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        \/\/if (iop.invokeDescriptor().refType() instanceof JavaType javaType) {\n-        \/\/    return isAssignable(l, javaType, MappableIface.class);\n-        \/\/}\n-        \/\/return false;\n-        return iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\");\n-    }\n-\n-    public static boolean notGlobalVarOp( Op op) {\n-        while (!(op instanceof JavaOp.InvokeOp iop)) {\n-            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n-                op = r.op();\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        return iop.invokeDescriptor().name().toLowerCase().contains(\"local\") ||\n-                iop.invokeDescriptor().name().toLowerCase().contains(\"private\");\n-    }\n-\n-    public static boolean isBufferInitialize( Op op) {\n-        \/\/ first check if the return is an array type\n-        if (op instanceof CoreOp.VarOp vop) {\n-            if (!(vop.varValueType() instanceof ArrayType)) return false;\n-        } else if (!(op instanceof JavaOp.ArrayAccessOp)){\n-            if (!(op.resultType() instanceof ArrayType)) return false;\n-        }\n-\n-        return isBufferArray(op);\n-    }\n-\n-    public static boolean isArrayView(MethodHandles.Lookup lookup, CoreOp.FuncOp entry) {\n-        var here = CallSite.of(OpTk.class,\"isArrayView\");\n-        return elements(here,entry).anyMatch((element) -> (\n-                element instanceof JavaOp.InvokeOp iop &&\n-                        iop.resultType() instanceof ArrayType &&\n-                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n-                        isAssignable(lookup, javaType, MappableIface.class)));\n-    }\n-\n@@ -241,21 +161,0 @@\n-    public static Class<?> primitiveTypeToClass(TypeElement type) {\n-        assert type != null;\n-        class PrimitiveHolder {\n-            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n-                    JavaType.BYTE, byte.class,\n-                    JavaType.SHORT, short.class,\n-                    JavaType.INT, int.class,\n-                    JavaType.LONG, long.class,\n-                    JavaType.FLOAT, float.class,\n-                    JavaType.DOUBLE, double.class,\n-                    JavaType.CHAR, char.class,\n-                    JavaType.BOOLEAN, boolean.class\n-            );\n-        }\n-        if (type instanceof PrimitiveType primitiveType) {\n-            return PrimitiveHolder.primitiveToClass.get(primitiveType);\n-        } else {\n-            throw new RuntimeException(\"given type is not a PrimitiveType\");\n-        }\n-    }\n-\n@@ -426,0 +325,1 @@\n+            case HATVectorLoadOp o -> 0;      \/\/ same as VarLoadOp\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":2,"deletions":102,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.dialect.*;\n+import hat.ifacemapper.MappableIface;\n+import hat.optools.OpTk;\n+import hat.types._V;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.core.CoreType;\n+import jdk.incubator.code.dialect.core.VarType;\n+import jdk.incubator.code.dialect.java.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.*;\n+\n+public class HATDialectifyArrayViewPhase implements HATDialect {\n+\n+    protected final Accelerator accelerator;\n+    @Override\n+    public Accelerator accelerator() {\n+        return this.accelerator;\n+    }\n+\n+    public HATDialectifyArrayViewPhase(Accelerator accelerator) {\n+        this.accelerator = accelerator;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp apply(CoreOp.FuncOp entry) {\n+        MethodHandles.Lookup l = accelerator.lookup;\n+        if (!isArrayView(entry)) return entry;\n+\n+        Map<Op.Result, Op.Result> replaced = new HashMap<>(); \/\/ maps a result to the result it should be replaced by\n+        Map<Op, CoreOp.VarAccessOp.VarLoadOp> bufferVarLoads = new HashMap<>();\n+\n+        return entry.transform(entry.funcName(), (bb, op) -> {\n+            switch (op) {\n+                case JavaOp.InvokeOp iop -> {\n+                    \/\/ catching HATVectorBinaryOps not stored in VarOps\n+                    if (isVectorBinaryOperation(iop)) {\n+                        HATVectorBinaryOp vBinaryOp = buildVectorBinaryOp(\n+                                iop.invokeDescriptor().name(),\n+                                iop.externalizeOpName(),\n+                                iop.resultType(),\n+                                bb.context().getValues(iop.operands())\n+                        );\n+                        vBinaryOp.setLocation(iop.location());\n+                        Op.Result res = bb.op(vBinaryOp);\n+                        bb.context().mapValue(iop.result(), res);\n+                        replaced.put(iop.result(), res);\n+                        return bb;\n+                    } else if (isBufferArray(iop) &&\n+                            firstOperand(iop) instanceof Op.Result r) { \/\/ ensures we can use iop as key for replaced vvv\n+                        replaced.put(iop.result(), r);\n+                        \/\/ map buffer VarOp to its corresponding VarLoadOp\n+                        bufferVarLoads.put(((Op.Result) firstOperand(r.op())).op(), (CoreOp.VarAccessOp.VarLoadOp) r.op());\n+                        return bb;\n+                    }\n+                }\n+                case CoreOp.VarOp vop -> {\n+                    if (isBufferInitialize(vop) &&\n+                            firstOperand(vop) instanceof Op.Result r) { \/\/ makes sure we don't process a new int[] for example\n+                        Op bufferLoad = replaced.get(r).op(); \/\/ gets VarLoadOp associated w\/ og buffer\n+                        replaced.put(vop.result(), (Op.Result) firstOperand(bufferLoad)); \/\/ gets VarOp associated w\/ og buffer\n+                        return bb;\n+                    } else if (isVectorOp(vop)) {\n+                        List<Value> operands = (vop.operands().isEmpty()) ? List.of() : List.of(firstOperand(vop));\n+                        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vop.resultType().valueType());\n+                        HATVectorVarOp vVarOp = new HATVectorVarOp(\n+                                vop.varName(),\n+                                vop.resultType(),\n+                                md.vectorTypeElement(),\n+                                md.lanes(),\n+                                bb.context().getValues(operands)\n+                        );\n+                        vVarOp.setLocation(vop.location());\n+                        Op.Result res = bb.op(vVarOp);\n+                        bb.context().mapValue(vop.result(), res);\n+                        return bb;\n+                    }\n+                }\n+                case CoreOp.VarAccessOp.VarLoadOp vlop -> {\n+                    if ((isBufferInitialize(vlop)) &&\n+                            firstOperand(vlop) instanceof Op.Result r) {\n+                        if (r.op() instanceof CoreOp.VarOp) { \/\/ if this is the VarLoadOp after the .arrayView() InvokeOp\n+                            Op.Result replacement = (notGlobalVarOp(vlop)) ?\n+                                    (Op.Result) firstOperand(((Op.Result) firstOperand(r.op())).op()) :\n+                                    bufferVarLoads.get(replaced.get(r).op()).result();\n+                            replaced.put(vlop.result(), replacement);\n+                        } else { \/\/ if this is a VarLoadOp loading the buffer\n+                            Value loaded = getValue(bb, replaced.get(r));\n+                            CoreOp.VarAccessOp.VarLoadOp newVarLoad = CoreOp.VarAccessOp.varLoad(loaded);\n+                            newVarLoad.setLocation(vlop.location());\n+                            Op.Result res = bb.op(newVarLoad);\n+                            bb.context().mapValue(vlop.result(), res);\n+                            replaced.put(vlop.result(), res);\n+                        }\n+                        return bb;\n+                    }\n+                }\n+                \/\/ TODO: implement more generic array handling for any-dimension arrays\n+                case JavaOp.ArrayAccessOp.ArrayLoadOp alop -> {\n+                    if (isBufferArray(alop) &&\n+                            firstOperand(alop) instanceof Op.Result r) {\n+                        Op.Result buffer = replaced.getOrDefault(r, r);\n+                        if (isVectorOp(alop)) {\n+                            Op vop = ((Op.Result) firstOperand(buffer.op())).op();\n+                            String name = switch (vop) {\n+                                case CoreOp.VarOp varOp -> varOp.varName();\n+                                case HATLocalVarOp hatLocalVarOp -> hatLocalVarOp.varName();\n+                                case HATPrivateVarOp hatPrivateVarOp -> hatPrivateVarOp.varName();\n+                                default -> throw new IllegalStateException(\"Unexpected value: \" + vop);\n+                            };\n+                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(alop.resultType());\n+                            HATVectorLoadOp vLoadOp = new HATVectorLoadOp(\n+                                    name,\n+                                    CoreType.varType(((ArrayType) firstOperand(alop).type()).componentType()),\n+                                    md.vectorTypeElement(),\n+                                    md.lanes(),\n+                                    notGlobalVarOp(alop),\n+                                    bb.context().getValues(List.of(buffer, alop.operands().getLast()))\n+                            );\n+                            vLoadOp.setLocation(alop.location());\n+                            Op.Result res = bb.op(vLoadOp);\n+                            bb.context().mapValue(alop.result(), res);\n+                            return bb;\n+                        }\n+                        if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n+                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n+                                \/\/ idea: we want to calculate the idx for the buffer access\n+                                \/\/ idx = (long) (((long) rowOp.idx * (long) buffer.width()) + alop.idx)\n+                                Op.Result x = (Op.Result) getValue(bb, rowOp.operands().getLast());\n+                                Op.Result y = (Op.Result) getValue(bb, alop.operands().getLast());\n+                                Op.Result ogBufferLoad = replaced.get((Op.Result) firstOperand(rowOp));\n+                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) firstOperand(ogBufferLoad.op()), (Op.Result) firstOperand(ogBufferLoad.op()));\n+                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(getValue(bb, ogBuffer)));\n+\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n+                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n+                                Op.Result width = bb.op(JavaOp.invoke(m, getValue(bb, bufferLoad)));\n+                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, x));\n+                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, y));\n+                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, width)));\n+                                Op.Result mul = bb.op(JavaOp.mul(getValue(bb, longY), getValue(bb, longWidth)));\n+                                Op.Result idx = bb.op(JavaOp.add(getValue(bb, longX), getValue(bb, mul)));\n+\n+                                Class<?> storedClass = typeElementToClass(alop.result().type());\n+                                MethodRef arrayMethod = MethodRef.method(c, \"array\", storedClass, long.class);\n+                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, getValue(bb, ogBufferLoad), getValue(bb, idx)));\n+                                bb.context().mapValue(alop.result(), invokeRes);\n+                            } else {\n+                                JavaOp.ConvOp conv = JavaOp.conv(JavaType.LONG, getValue(bb, alop.operands().get(1)));\n+                                Op.Result convRes = bb.op(conv);\n+\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n+                                Class<?> storedClass = typeElementToClass(alop.result().type());\n+                                MethodRef m = MethodRef.method(c, \"array\", storedClass, long.class);\n+                                Op.Result invokeRes = bb.op(JavaOp.invoke(m, getValue(bb, buffer), convRes));\n+                                bb.context().mapValue(alop.result(), invokeRes);\n+                            }\n+                        }\n+                    }\n+                    return bb;\n+                }\n+                \/\/ handles only 1D and 2D arrays\n+                case JavaOp.ArrayAccessOp.ArrayStoreOp asop -> {\n+                    if (isBufferArray(asop) &&\n+                            firstOperand(asop) instanceof Op.Result r) {\n+                        Op.Result buffer = replaced.getOrDefault(r, r);\n+                        if (isVectorOp(asop)) {\n+                            Op varOp = findVarOpOrHATVarOP(((Op.Result) asop.operands().getLast()).op());\n+                            String name = (varOp instanceof HATVectorVarOp) ? ((HATVectorVarOp) varOp).varName() : ((CoreOp.VarOp) varOp).varName();\n+                            TypeElement resultType = (varOp instanceof HATVectorVarOp) ? (varOp).resultType() : ((CoreOp.VarOp) varOp).resultType();\n+                            ClassType classType = ((ClassType) ((ArrayType) firstOperand(asop).type()).componentType());\n+                            HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(classType);\n+                            HATVectorStoreView vStoreOp = new HATVectorStoreView(\n+                                    name,\n+                                    resultType,\n+                                    md.lanes(),\n+                                    md.vectorTypeElement(),\n+                                    notGlobalVarOp(asop),\n+                                    bb.context().getValues(List.of(buffer, asop.operands().getLast(), asop.operands().get(1)))\n+                            );\n+                            vStoreOp.setLocation(asop.location());\n+                            Op.Result res = bb.op(vStoreOp);\n+                            bb.context().mapValue(asop.result(), res);\n+                            return bb;\n+                        }\n+                        if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we ignore the first array[][] load if using 2D arrays\n+                            if (r.op() instanceof JavaOp.ArrayAccessOp.ArrayLoadOp rowOp) {\n+                                Op.Result x = (Op.Result) rowOp.operands().getLast();\n+                                Op.Result y = (Op.Result) asop.operands().get(1);\n+                                Op.Result ogBufferLoad = replaced.get((Op.Result) firstOperand(rowOp));\n+                                Op.Result ogBuffer = replaced.getOrDefault((Op.Result) firstOperand(ogBufferLoad.op()), (Op.Result) firstOperand(ogBufferLoad.op()));\n+                                Op.Result bufferLoad = bb.op(CoreOp.VarAccessOp.varLoad(getValue(bb, ogBuffer)));\n+                                Op.Result computed = (Op.Result) asop.operands().getLast();\n+\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) ((VarType) ogBuffer.type()).valueType());\n+                                MethodRef m = MethodRef.method(c, \"width\", int.class);\n+                                Op.Result width = bb.op(JavaOp.invoke(m, getValue(bb, bufferLoad)));\n+                                Op.Result longX = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, x)));\n+                                Op.Result longY = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, y)));\n+                                Op.Result longWidth = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, width)));\n+                                Op.Result mul = bb.op(JavaOp.mul(getValue(bb, longY), getValue(bb, longWidth)));\n+                                Op.Result idx = bb.op(JavaOp.add(getValue(bb, longX), getValue(bb, mul)));\n+\n+                                MethodRef arrayMethod = MethodRef.method(c, \"array\", void.class, long.class, int.class);\n+                                Op.Result invokeRes = bb.op(JavaOp.invoke(arrayMethod, getValue(bb, ogBufferLoad), getValue(bb, idx), getValue(bb, computed)));\n+                                bb.context().mapValue(asop.result(), invokeRes);\n+                            } else {\n+                                Op.Result idx = bb.op(JavaOp.conv(JavaType.LONG, getValue(bb, asop.operands().get(1))));\n+                                Value val = getValue(bb, asop.operands().getLast());\n+\n+                                boolean noRootVlop = (buffer.op() instanceof CoreOp.VarOp);\n+                                ClassType classType = (noRootVlop) ?\n+                                        (ClassType) ((CoreOp.VarOp) buffer.op()).varValueType() :\n+                                        (ClassType) buffer.type();\n+\n+                                Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, classType);\n+                                Class<?> storedClass = typeElementToClass(val.type());\n+                                MethodRef m = MethodRef.method(c, \"array\", void.class, long.class, storedClass);\n+                                Op.Result invokeRes = (noRootVlop) ?\n+                                        bb.op(JavaOp.invoke(m, getValue(bb, r), idx, val)) :\n+                                        bb.op(JavaOp.invoke(m, getValue(bb, buffer), idx, val));\n+                                bb.context().mapValue(asop.result(), invokeRes);\n+                            }\n+                        }\n+                    }\n+                    return bb;\n+                }\n+                case JavaOp.ArrayLengthOp alen -> {\n+                    if (isBufferArray(alen) &&\n+                            firstOperand(alen) instanceof Op.Result r) {\n+                        Op.Result buffer = replaced.get(r);\n+                        Class<?> c = (Class<?>) OpTk.classTypeToTypeOrThrow(l, (ClassType) buffer.type());\n+                        MethodRef m = MethodRef.method(c, \"length\", int.class);\n+                        JavaOp.InvokeOp newInvokeOp = JavaOp.invoke(m, getValue(bb, buffer));\n+                        newInvokeOp.setLocation(alen.location());\n+                        Op.Result res = bb.op(newInvokeOp);\n+                        bb.context().mapValue(alen.result(), res);\n+                    }\n+                    return bb;\n+                }\n+                case HATVectorSelectLoadOp vSelectLoad -> {\n+                    CoreOp.VarOp vop = findVarOp(((Op.Result) firstOperand(op)).op());\n+                    String name = (vop == null) ? \"\" : vop.varName();\n+                    HATVectorSelectLoadOp vSelectOp = new HATVectorSelectLoadOp(\n+                            name,\n+                            op.resultType(),\n+                            getLane(vSelectLoad.mapLane()),\n+                            bb.context().getValues(op.operands())\n+                    );\n+                    vSelectOp.setLocation(op.location());\n+                    bb.context().mapValue(vSelectLoad.result(), bb.op(vSelectOp));\n+                    return bb;\n+                }\n+                case HATVectorSelectStoreOp vSelectStore -> {\n+                    CoreOp.VarOp vop = findVarOp(((Op.Result) firstOperand(op)).op());\n+                    String name = (vop == null) ? \"\" : vop.varName();\n+                    CoreOp.VarOp resultOp =\n+                            (((Op.Result) op.operands().getLast()).op() instanceof JavaOp.ArithmeticOperation ||\n+                                    ((Op.Result) op.operands().getLast()).op() instanceof HATVectorSelectLoadOp) ?\n+                                    null : findVarOp(((Op.Result) bb.context().getValue(op.operands().get(1))).op());\n+                    HATVectorSelectStoreOp vSelectOp = new HATVectorSelectStoreOp(\n+                            name,\n+                            op.resultType(),\n+                            getLane(vSelectStore.mapLane()),\n+                            resultOp,\n+                            bb.context().getValues(op.operands())\n+                    );\n+                    vSelectOp.setLocation(op.location());\n+                    bb.context().mapValue(vSelectStore.result(), bb.op(vSelectOp));\n+                    return bb;\n+                }\n+                case HATVectorVarLoadOp vVarLoad -> {\n+                    List<Value> inputOperandsVarLoad = vVarLoad.operands();\n+                    List<Value> outputOperandsVarLoad = bb.context().getValues(inputOperandsVarLoad);\n+                    String varLoadName = findVarOp(vVarLoad).varName();\n+                    HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(vVarLoad.resultType());\n+                    HATVectorVarLoadOp newVectorVarLoadOp = new HATVectorVarLoadOp(\n+                            varLoadName,\n+                            vVarLoad.resultType(),\n+                            md.vectorTypeElement(),\n+                            md.lanes(),\n+                            outputOperandsVarLoad\n+                    );\n+                    newVectorVarLoadOp.setLocation(vVarLoad.location());\n+                    Op.Result res = bb.op(newVectorVarLoadOp);\n+                    bb.context().mapValue(vVarLoad.result(), res);\n+                    return bb;\n+                }\n+                default -> {\n+                }\n+            }\n+            bb.op(op);\n+            return bb;\n+        });\n+    }\n+\n+    \/*\n+     * Helper functions:\n+     *\/\n+\n+    int getLane(String fieldName) {\n+        return switch (fieldName) {\n+            case \"x\" -> 0;\n+            case \"y\" -> 1;\n+            case \"z\" -> 2;\n+            case \"w\" -> 3;\n+            default -> -1;\n+        };\n+    }\n+\n+    private HATVectorBinaryOp buildVectorBinaryOp(String opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n+        HATPhaseUtils.VectorMetaData md = HATPhaseUtils.getVectorTypeInfoWithCodeReflection(resultType);\n+        return switch (opType) {\n+            case \"add\" -> new HATVectorAddOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"sub\" -> new HATVectorSubOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"mul\" -> new HATVectorMulOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            case \"div\" -> new HATVectorDivOp(varName, resultType, md.vectorTypeElement(), md.lanes(), outputOperands);\n+            default -> throw new IllegalStateException(\"Unexpected value: \" + opType);\n+        };\n+    }\n+\n+    private boolean isVectorBinaryOperation(JavaOp.InvokeOp invokeOp) {\n+        TypeElement typeElement = invokeOp.resultType();\n+        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n+        return isHatVectorType\n+                && (invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"add\")\n+                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"sub\")\n+                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"mul\")\n+                || invokeOp.invokeDescriptor().name().equalsIgnoreCase(\"div\"));\n+    }\n+\n+    private Op findVarOpOrHATVarOP(Op op) {\n+        return searchForOp(op, Set.of(CoreOp.VarOp.class, HATVectorVarOp.class));\n+    }\n+\n+    private CoreOp.VarOp findVarOp(Op op) {\n+        return (CoreOp.VarOp) searchForOp(op, Set.of(CoreOp.VarOp.class));\n+    }\n+\n+    public boolean isVectorOp(Op op) {\n+        if (op.operands().isEmpty()) return false;\n+        TypeElement type = firstOperand(op).type();\n+        if (type instanceof ArrayType at) type = at.componentType();\n+        if (type instanceof ClassType ct) {\n+            try {\n+                return _V.class.isAssignableFrom((Class<?>) ct.resolve(accelerator.lookup));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Value firstOperand(Op op) {\n+        return op.operands().getFirst();\n+    }\n+\n+    public Value getValue(Block.Builder bb, Value value) {\n+        return bb.context().getValueOrDefault(value, value);\n+    }\n+\n+    public boolean isBufferArray(Op op) {\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOp(op, Set.of(JavaOp.InvokeOp.class));\n+        return iop.invokeDescriptor().name().toLowerCase().contains(\"arrayview\");\n+    }\n+\n+    public boolean notGlobalVarOp(Op op) {\n+        JavaOp.InvokeOp iop = (JavaOp.InvokeOp) searchForOp(op, Set.of(JavaOp.InvokeOp.class));\n+        return iop.invokeDescriptor().name().toLowerCase().contains(\"local\") ||\n+                iop.invokeDescriptor().name().toLowerCase().contains(\"private\");\n+    }\n+\n+    public Op searchForOp(Op op, Set<Class<?>> opClasses) {\n+        while (!(opClasses.contains(op.getClass()))) {\n+            if (!op.operands().isEmpty() && firstOperand(op) instanceof Op.Result r) {\n+                op = r.op();\n+            } else {\n+                return null;\n+            }\n+        }\n+        return op;\n+    }\n+\n+    public boolean isBufferInitialize(Op op) {\n+        \/\/ first check if the return is an array type\n+        if (op instanceof CoreOp.VarOp vop) {\n+            if (!(vop.varValueType() instanceof ArrayType)) return false;\n+        } else if (!(op instanceof JavaOp.ArrayAccessOp)) {\n+            if (!(op.resultType() instanceof ArrayType)) return false;\n+        }\n+\n+        return isBufferArray(op);\n+    }\n+\n+    public boolean isArrayView(CoreOp.FuncOp entry) {\n+        var here = OpTk.CallSite.of(HATDialectifyArrayViewPhase.class, \"isArrayView\");\n+        return OpTk.elements(here, entry).anyMatch((element) -> (\n+                element instanceof JavaOp.InvokeOp iop &&\n+                        iop.resultType() instanceof ArrayType &&\n+                        iop.invokeDescriptor().refType() instanceof JavaType javaType &&\n+                        OpTk.isAssignable(accelerator.lookup, javaType, MappableIface.class)));\n+    }\n+\n+    public Class<?> typeElementToClass(TypeElement type) {\n+        class PrimitiveHolder {\n+            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n+                    JavaType.BYTE, byte.class,\n+                    JavaType.SHORT, short.class,\n+                    JavaType.INT, int.class,\n+                    JavaType.LONG, long.class,\n+                    JavaType.FLOAT, float.class,\n+                    JavaType.DOUBLE, double.class,\n+                    JavaType.CHAR, char.class,\n+                    JavaType.BOOLEAN, boolean.class\n+            );\n+        }\n+        try {\n+            if (type instanceof PrimitiveType primitiveType) {\n+                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n+            } else if (type instanceof ClassType classType) {\n+                return ((Class<?>) classType.resolve(accelerator.lookup));\n+            } else {\n+                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"given type cannot be converted to class\");\n+        }\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -69,0 +69,2 @@\n+\n+        hatPhases.add(new HATDialectifyArrayViewPhase(accelerator));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"","filename":"hat\/examples\/arrayview\/.gitignore","additions":0,"deletions":0,"binary":false,"changes":0,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<!--Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n-DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n-This code is free software; you can redistribute it and\/or modify it\n-under the terms of the GNU General Public License version 2 only, as\n-published by the Free Software Foundation.  Oracle designates this\n-particular file as subject to the \"Classpath\" exception as provided\n-by Oracle in the LICENSE file that accompanied this code.\n-\n-This code is distributed in the hope that it will be useful, but WITHOUT\n-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-version 2 for more details (a copy is included in the LICENSE file that\n-accompanied this code).\n-\n-You should have received a copy of the GNU General Public License version\n-2 along with this work; if not, write to the Free Software Foundation,\n-Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n-Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-or visit www.oracle.com if you need additional information or have any\n-questions.\n---><project xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\" xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\">\n-    <!--Auto generated by mkpoms-->\n-    <modelVersion>4.0.0<\/modelVersion>\n-    <packaging>jar<\/packaging>\n-    <groupId>oracle.code<\/groupId>\n-    <artifactId>hat-example-arrayview<\/artifactId>\n-    <version>1.0<\/version>\n-    <parent>\n-        <groupId>oracle.code<\/groupId>\n-        <artifactId>hat-examples<\/artifactId>\n-        <version>1.0<\/version>\n-    <\/parent>\n-    <dependencies>\n-        <dependency>\n-            <groupId>oracle.code<\/groupId>\n-            <artifactId>hat-core<\/artifactId>\n-            <version>1.0<\/version>\n-        <\/dependency>\n-    <\/dependencies>\n-    <build>\n-        <plugins>\n-            <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n-        <\/plugins>\n-    <\/build>\n-<\/project>\n","filename":"hat\/examples\/arrayview\/pom.xml","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package arrayview;\n-\n-import hat.Accelerator;\n-import hat.ComputeContext;\n-import hat.KernelContext;\n-import hat.backend.Backend;\n-import hat.buffer.S32Array;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.lang.invoke.MethodHandles;\n-\n-import static hat.ifacemapper.MappableIface.RO;\n-import static hat.ifacemapper.MappableIface.RW;\n-\n-public class Main {\n-\n-    @CodeReflection\n-    public static void squareKernel(@RO  KernelContext kc, @RW S32Array s32Array) {\n-        if (kc.x<kc.maxX){\n-            int[] arr = s32Array.arrayView();\n-            arr[kc.x] *= arr[kc.x];\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void square(@RO ComputeContext cc, @RW S32Array s32Array) {\n-        cc.dispatchKernel(s32Array.length(),\n-                kc -> squareKernel(kc, s32Array)\n-        );\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n-        var arr = S32Array.create(accelerator, 32);\n-        for (int i = 0; i < arr.length(); i++) {\n-            arr.array(i, i);\n-        }\n-        accelerator.compute(\n-                cc -> square(cc, arr)  \/\/QuotableComputeContextConsumer\n-        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n-        for (int i = 0; i < arr.length(); i++) {\n-            System.out.println(i + \" \" + arr.array(i));\n-        }\n-    }\n-}\n","filename":"hat\/examples\/arrayview\/src\/main\/java\/arrayview\/Main.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -139,4 +139,1 @@\n-                ├──matmul\n-                │    ├──src\/main\/java\n-                │    └──src\/main\/resources\n-                └──arrayview\n+                └──matmul\n@@ -315,1 +312,1 @@\n-    Stream.of( \"blackscholes\", \"squares\", \"matmul\", \"arrayview\")\n+    Stream.of( \"blackscholes\", \"squares\", \"matmul\")\n","filename":"hat\/hat\/bld.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-    \/\/ simple square kernel example using S32Array's ArrayView\n+    \/*\n+     * simple square kernel example using S32Array's ArrayView\n+     *\/\n@@ -78,0 +80,32 @@\n+    \/*\n+     * making sure arrayviews aren't reliant on varOps\n+     *\/\n+    @CodeReflection\n+    public static void squareKernelNoVarOp(@RO  KernelContext kc, @RW S32Array s32Array) {\n+        if (kc.x<kc.maxX){\n+            s32Array.arrayView()[kc.x] *= s32Array.arrayView()[kc.x];\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void squareNoVarOp(@RO ComputeContext cc, @RW S32Array s32Array) {\n+        cc.dispatchKernel(s32Array.length(),\n+                kc -> squareKernelNoVarOp(kc, s32Array)\n+        );\n+    }\n+\n+    @HatTest\n+    public static void testSquareNoVarOp() {\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n+        var arr = S32Array.create(accelerator, 32);\n+        for (int i = 0; i < arr.length(); i++) {\n+            arr.array(i, i);\n+        }\n+        accelerator.compute(\n+                cc -> squareNoVarOp(cc, arr)  \/\/QuotableComputeContextConsumer\n+        );                                     \/\/   extends Quotable, Consumer<ComputeContext>\n+        for (int i = 0; i < arr.length(); i++) {\n+            HatAsserts.assertEquals(i * i, arr.array(i));\n+        }\n+    }\n+\n@@ -113,1 +147,3 @@\n-    \/\/ simplified version of Game of Life using ArrayView\n+    \/*\n+     * simplified version of Game of Life using ArrayView\n+     *\/\n@@ -307,1 +343,3 @@\n-    \/\/ simplified version of mandel using ArrayView\n+    \/*\n+     * simplified version of mandel using ArrayView\n+     *\/\n@@ -395,1 +433,3 @@\n-    \/\/ simplified version of BlackScholes using ArrayView\n+    \/*\n+     * simplified version of BlackScholes using ArrayView\n+     *\/\n@@ -508,1 +548,3 @@\n-    \/\/ basic test of local and private buffer ArrayViews\n+    \/*\n+     * basic test of local and private buffer ArrayViews\n+     *\/\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestArrayView.java","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,702 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.test;\n+\n+import hat.*;\n+import hat.backend.Backend;\n+import hat.buffer.*;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import hat.ifacemapper.Schema;\n+import hat.test.annotation.HatTest;\n+import hat.test.engine.HatAsserts;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Random;\n+\n+public class TestVectorArrayView {\n+\n+    @CodeReflection\n+    public static void vectorOps01(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vA = a.float4ArrayView();\n+            Float4[] vB = b.float4ArrayView();\n+            Float4[] vC = c.float4ArrayView();\n+            vC[index * 4] = Float4.add(vA[index * 4], vB[index * 4]);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps01WithFloat4s(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vA = a.float4ArrayView();\n+            Float4[] vB = b.float4ArrayView();\n+            Float4[] vC = c.float4ArrayView();\n+            Float4 vAFloat = vA[index * 4];\n+            Float4 vBFloat = vB[index * 4];\n+            vC[index * 4] = Float4.add(vAFloat, vBFloat);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps01WithSeparateAdd(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vA = a.float4ArrayView();\n+            Float4[] vB = b.float4ArrayView();\n+            Float4[] vC = c.float4ArrayView();\n+            Float4 res = Float4.add(vA[index * 4], vB[index * 4]);\n+            vC[index * 4] = res;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps02(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4.MutableImpl[] vArr = a.float4ArrayView();\n+            Float4.MutableImpl[] bArr = b.float4ArrayView();\n+            Float4.MutableImpl vA = vArr[index * 4];\n+            float scaleX = vA.x() * 10.0f;\n+            vA.x(scaleX);\n+            bArr[index * 4] = vA;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps03(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4.MutableImpl[] vA = a.float4ArrayView();\n+            Float4.MutableImpl[] vB = b.float4ArrayView();\n+            Float4.MutableImpl vAFloat = vA[index * 4];\n+            float scaleX = vAFloat.x() * 10.0f;\n+            float scaleY = vAFloat.y() * 20.0f;\n+            float scaleZ = vAFloat.z() * 30.0f;\n+            float scaleW = vAFloat.w() * 40.0f;\n+            vAFloat.x(scaleX);\n+            vAFloat.y(scaleY);\n+            vAFloat.z(scaleZ);\n+            vAFloat.w(scaleW);\n+            vB[index * 4] = vAFloat;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps04(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4.MutableImpl[] vA = a.float4ArrayView();\n+            Float4.MutableImpl[] vB = b.float4ArrayView();\n+            Float4.MutableImpl vAFloat = vA[index * 4];\n+            vAFloat.x(vAFloat.x() * 10.0f);\n+            vAFloat.y(vAFloat.y() * 20.0f);\n+            vAFloat.z(vAFloat.z() * 30.0f);\n+            vAFloat.w(vAFloat.w() * 40.0f);\n+            vB[index * 4] = vAFloat;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps05(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vA = a.float4ArrayView();\n+            Float4[] vB = b.float4ArrayView();\n+            Float4[] vC = c.float4ArrayView();\n+            vC[index * 4] = vA[index * 4].add(vB[index * 4]).add(vB[index * 4]);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps06(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vA = a.float4ArrayView();\n+            Float4[] vB = b.float4ArrayView();\n+            Float4[] vC = c.float4ArrayView();\n+            Float4 vD = Float4.sub(vA[index * 4], vB[index * 4]);\n+            vC[index * 4] = Float4.sub(vA[index * 4], vB[index * 4]);\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps07(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vAArray = a.float4ArrayView();\n+            Float4[] vBArray = b.float4ArrayView();\n+            Float4[] vCArray = c.float4ArrayView();\n+\n+            Float4 vA = vAArray[index * 4];\n+            Float4 vB = vBArray[index * 4];\n+            Float4 vC = vA.add(vB).sub(vB);\n+            vCArray[index * 4] = vC;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps08(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] vAArray = a.float4ArrayView();\n+            Float4[] vBArray = b.float4ArrayView();\n+            Float4[] vCArray = c.float4ArrayView();\n+\n+            Float4 vA = vAArray[index * 4];\n+            Float4 vB = vBArray[index * 4];\n+            Float4 vC = vA.add(vB).mul(vA).div(vB);\n+            vCArray[index * 4] = vC;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps09(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+        \/\/ Checking composition\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            Float4[] vAArray = a.float4ArrayView();\n+            Float4[] vBArray = b.float4ArrayView();\n+            Float4[] vCArray = c.float4ArrayView();\n+\n+            Float4 vA = vAArray[index * 4];\n+            Float4 vB = vBArray[index * 4];\n+            Float4 vC = vA.add(vA.mul(vB));\n+            vCArray[index * 4] = vC;\n+        }\n+    }\n+\n+    private interface SharedMemory extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+        Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n+                arr -> arr.array(\"array\", 1024));\n+        static SharedMemory create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+        static SharedMemory createLocal() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+        default Float4 float4View(int index) {\n+            return null;\n+        }\n+        default void storeFloat4View(Float4 float4, int index) {\n+        }\n+        default Float4.MutableImpl[] float4LocalArrayView() {\n+            return null;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps10(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+        SharedMemory sm = SharedMemory.createLocal();\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            int lix = kernelContext.lix;\n+\n+            Float4[] aArr = a.float4ArrayView();\n+            Float4[] bArr = b.float4ArrayView();\n+            Float4[] smArr = sm.float4LocalArrayView();\n+\n+            Float4 vA = aArr[index * 4];\n+            smArr[lix * 4] = vA;\n+            kernelContext.barrier();\n+            Float4 r = smArr[lix * 4];\n+            bArr[index * 4] = r;\n+        }\n+    }\n+\n+    private interface PrivateMemory extends Buffer {\n+        void array(long index, float value);\n+        float array(long index);\n+        Schema<PrivateMemory> schema = Schema.of(PrivateMemory.class,\n+                arr -> arr.array(\"array\", 4));\n+        static PrivateMemory create(Accelerator accelerator) {\n+            return schema.allocate(accelerator);\n+        }\n+        static PrivateMemory createPrivate() {\n+            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+        }\n+        default Float4 float4View(int index) {\n+            return null;\n+        }\n+        default void storeFloat4View(Float4 float4, int index) {\n+        }\n+        default Float4[] float4PrivateArrayView() {\n+            return null;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps11(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+        PrivateMemory pm = PrivateMemory.createPrivate();\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+\n+            Float4[] aArr = a.float4ArrayView();\n+            Float4[] bArr = b.float4ArrayView();\n+            Float4[] pmArr = pm.float4PrivateArrayView();\n+\n+            Float4 vA = aArr[index * 4];\n+            pmArr[0] = vA;\n+            kernelContext.barrier();\n+            Float4 r = pmArr[0];\n+            bArr[index * 4] = r;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void vectorOps12(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+        SharedMemory sm = SharedMemory.createLocal();\n+        if (kernelContext.gix < kernelContext.gsx) {\n+            int index = kernelContext.gix;\n+            int lix = kernelContext.lix;\n+            Float4.MutableImpl[] aArr = a.float4ArrayView();\n+            Float4.MutableImpl[] bArr = b.float4ArrayView();\n+            Float4.MutableImpl[] smArr = sm.float4LocalArrayView();\n+\n+            Float4.MutableImpl vA = aArr[index * 4];\n+            Float4.MutableImpl smVector = smArr[lix * 4];\n+            smVector.x(vA.x());\n+            smVector.y(vA.y());\n+            smVector.z(vA.z());\n+            smVector.w(vA.w());\n+            smArr[lix * 4] = smVector;\n+            kernelContext.barrier();\n+            Float4.MutableImpl r = smArr[lix * 4];\n+            bArr[index * 4] = r;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph01(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps01(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph01WithFloat4s(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps01WithFloat4s(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph01WithSeparateAdd(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps01WithSeparateAdd(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph02(@RO ComputeContext cc, @RW F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps02(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph03(@RO ComputeContext cc, @RO F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps03(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph04(@RO ComputeContext cc, @RO F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps04(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph05(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps05(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph06(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps06(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph07(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps07(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph08(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps08(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph09(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps09(kernelContext, a, b, c));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph10(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps10(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph11(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps11(kernelContext, a, b));\n+    }\n+\n+    @CodeReflection\n+    public static void computeGraph12(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n+        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n+        cc.dispatchKernel(computeRange, kernelContext -> vectorOps12(kernelContext, a, b));\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView01() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph01(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i++) {\n+            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView01WithFloat4s() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph01WithFloat4s(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i++) {\n+            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView01WithSeparateAdd() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph01WithSeparateAdd(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i++) {\n+            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView02() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph02(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 1)), arrayB.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 2)), arrayB.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 3)), arrayB.array(i + 3), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView03() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph03(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView04() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph04(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i += 4) {\n+            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n+            HatAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView05() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph05(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView06() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph06(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals((arrayA.array(i) - arrayB.array(i)), arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView07() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph07(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView08() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph08(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            float val = (((arrayA.array(i) + arrayB.array(i)) * arrayA.array(i)) \/ arrayB.array(i));\n+            HatAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView09() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+        var arrayC = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph09(cc, arrayA, arrayB, arrayC, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            float val = (arrayA.array(i) + (arrayB.array(i)) * arrayA.array(i));\n+            HatAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView10() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph10(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView11() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph11(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+        }\n+    }\n+\n+    @HatTest\n+    public void TestVectorArrayView12() {\n+        final int size = 1024;\n+        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        var arrayA = F32ArrayPadded.create(accelerator, size);\n+        var arrayB = F32ArrayPadded.create(accelerator, size);\n+\n+        Random r = new Random(19);\n+        for (int i = 0; i < size; i++) {\n+            arrayA.array(i, r.nextFloat());\n+            arrayB.array(i, r.nextFloat());\n+        }\n+\n+        accelerator.compute(cc -> computeGraph12(cc, arrayA, arrayB, size));\n+\n+        for (int i = 0; i < size; i ++) {\n+            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+        }\n+    }\n+}\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorArrayView.java","additions":702,"deletions":0,"binary":false,"changes":702,"status":"added"}]}