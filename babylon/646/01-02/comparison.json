{"files":[{"patch":"@@ -1,702 +1,702 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.test;\n-\n-import hat.*;\n-import hat.backend.Backend;\n-import hat.buffer.*;\n-import hat.ifacemapper.MappableIface.RO;\n-import hat.ifacemapper.MappableIface.RW;\n-import hat.ifacemapper.Schema;\n-import hat.test.annotation.HatTest;\n-import hat.test.engine.HatAsserts;\n-import jdk.incubator.code.CodeReflection;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.Random;\n-\n-public class TestVectorArrayView {\n-\n-    @CodeReflection\n-    public static void vectorOps01(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vA = a.float4ArrayView();\n-            Float4[] vB = b.float4ArrayView();\n-            Float4[] vC = c.float4ArrayView();\n-            vC[index * 4] = Float4.add(vA[index * 4], vB[index * 4]);\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps01WithFloat4s(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vA = a.float4ArrayView();\n-            Float4[] vB = b.float4ArrayView();\n-            Float4[] vC = c.float4ArrayView();\n-            Float4 vAFloat = vA[index * 4];\n-            Float4 vBFloat = vB[index * 4];\n-            vC[index * 4] = Float4.add(vAFloat, vBFloat);\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps01WithSeparateAdd(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vA = a.float4ArrayView();\n-            Float4[] vB = b.float4ArrayView();\n-            Float4[] vC = c.float4ArrayView();\n-            Float4 res = Float4.add(vA[index * 4], vB[index * 4]);\n-            vC[index * 4] = res;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps02(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4.MutableImpl[] vArr = a.float4ArrayView();\n-            Float4.MutableImpl[] bArr = b.float4ArrayView();\n-            Float4.MutableImpl vA = vArr[index * 4];\n-            float scaleX = vA.x() * 10.0f;\n-            vA.x(scaleX);\n-            bArr[index * 4] = vA;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps03(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4.MutableImpl[] vA = a.float4ArrayView();\n-            Float4.MutableImpl[] vB = b.float4ArrayView();\n-            Float4.MutableImpl vAFloat = vA[index * 4];\n-            float scaleX = vAFloat.x() * 10.0f;\n-            float scaleY = vAFloat.y() * 20.0f;\n-            float scaleZ = vAFloat.z() * 30.0f;\n-            float scaleW = vAFloat.w() * 40.0f;\n-            vAFloat.x(scaleX);\n-            vAFloat.y(scaleY);\n-            vAFloat.z(scaleZ);\n-            vAFloat.w(scaleW);\n-            vB[index * 4] = vAFloat;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps04(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4.MutableImpl[] vA = a.float4ArrayView();\n-            Float4.MutableImpl[] vB = b.float4ArrayView();\n-            Float4.MutableImpl vAFloat = vA[index * 4];\n-            vAFloat.x(vAFloat.x() * 10.0f);\n-            vAFloat.y(vAFloat.y() * 20.0f);\n-            vAFloat.z(vAFloat.z() * 30.0f);\n-            vAFloat.w(vAFloat.w() * 40.0f);\n-            vB[index * 4] = vAFloat;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps05(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vA = a.float4ArrayView();\n-            Float4[] vB = b.float4ArrayView();\n-            Float4[] vC = c.float4ArrayView();\n-            vC[index * 4] = vA[index * 4].add(vB[index * 4]).add(vB[index * 4]);\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps06(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vA = a.float4ArrayView();\n-            Float4[] vB = b.float4ArrayView();\n-            Float4[] vC = c.float4ArrayView();\n-            Float4 vD = Float4.sub(vA[index * 4], vB[index * 4]);\n-            vC[index * 4] = Float4.sub(vA[index * 4], vB[index * 4]);\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps07(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vAArray = a.float4ArrayView();\n-            Float4[] vBArray = b.float4ArrayView();\n-            Float4[] vCArray = c.float4ArrayView();\n-\n-            Float4 vA = vAArray[index * 4];\n-            Float4 vB = vBArray[index * 4];\n-            Float4 vC = vA.add(vB).sub(vB);\n-            vCArray[index * 4] = vC;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps08(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] vAArray = a.float4ArrayView();\n-            Float4[] vBArray = b.float4ArrayView();\n-            Float4[] vCArray = c.float4ArrayView();\n-\n-            Float4 vA = vAArray[index * 4];\n-            Float4 vB = vBArray[index * 4];\n-            Float4 vC = vA.add(vB).mul(vA).div(vB);\n-            vCArray[index * 4] = vC;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps09(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n-        \/\/ Checking composition\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-            Float4[] vAArray = a.float4ArrayView();\n-            Float4[] vBArray = b.float4ArrayView();\n-            Float4[] vCArray = c.float4ArrayView();\n-\n-            Float4 vA = vAArray[index * 4];\n-            Float4 vB = vBArray[index * 4];\n-            Float4 vC = vA.add(vA.mul(vB));\n-            vCArray[index * 4] = vC;\n-        }\n-    }\n-\n-    private interface SharedMemory extends Buffer {\n-        void array(long index, float value);\n-        float array(long index);\n-        Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n-                arr -> arr.array(\"array\", 1024));\n-        static SharedMemory create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n-        static SharedMemory createLocal() {\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n-        }\n-        default Float4 float4View(int index) {\n-            return null;\n-        }\n-        default void storeFloat4View(Float4 float4, int index) {\n-        }\n-        default Float4.MutableImpl[] float4LocalArrayView() {\n-            return null;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps10(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n-        SharedMemory sm = SharedMemory.createLocal();\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-            int lix = kernelContext.lix;\n-\n-            Float4[] aArr = a.float4ArrayView();\n-            Float4[] bArr = b.float4ArrayView();\n-            Float4[] smArr = sm.float4LocalArrayView();\n-\n-            Float4 vA = aArr[index * 4];\n-            smArr[lix * 4] = vA;\n-            kernelContext.barrier();\n-            Float4 r = smArr[lix * 4];\n-            bArr[index * 4] = r;\n-        }\n-    }\n-\n-    private interface PrivateMemory extends Buffer {\n-        void array(long index, float value);\n-        float array(long index);\n-        Schema<PrivateMemory> schema = Schema.of(PrivateMemory.class,\n-                arr -> arr.array(\"array\", 4));\n-        static PrivateMemory create(Accelerator accelerator) {\n-            return schema.allocate(accelerator);\n-        }\n-        static PrivateMemory createPrivate() {\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n-        }\n-        default Float4 float4View(int index) {\n-            return null;\n-        }\n-        default void storeFloat4View(Float4 float4, int index) {\n-        }\n-        default Float4[] float4PrivateArrayView() {\n-            return null;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps11(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n-        PrivateMemory pm = PrivateMemory.createPrivate();\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-\n-            Float4[] aArr = a.float4ArrayView();\n-            Float4[] bArr = b.float4ArrayView();\n-            Float4[] pmArr = pm.float4PrivateArrayView();\n-\n-            Float4 vA = aArr[index * 4];\n-            pmArr[0] = vA;\n-            kernelContext.barrier();\n-            Float4 r = pmArr[0];\n-            bArr[index * 4] = r;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void vectorOps12(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n-        SharedMemory sm = SharedMemory.createLocal();\n-        if (kernelContext.gix < kernelContext.gsx) {\n-            int index = kernelContext.gix;\n-            int lix = kernelContext.lix;\n-            Float4.MutableImpl[] aArr = a.float4ArrayView();\n-            Float4.MutableImpl[] bArr = b.float4ArrayView();\n-            Float4.MutableImpl[] smArr = sm.float4LocalArrayView();\n-\n-            Float4.MutableImpl vA = aArr[index * 4];\n-            Float4.MutableImpl smVector = smArr[lix * 4];\n-            smVector.x(vA.x());\n-            smVector.y(vA.y());\n-            smVector.z(vA.z());\n-            smVector.w(vA.w());\n-            smArr[lix * 4] = smVector;\n-            kernelContext.barrier();\n-            Float4.MutableImpl r = smArr[lix * 4];\n-            bArr[index * 4] = r;\n-        }\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph01(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps01(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph01WithFloat4s(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps01WithFloat4s(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph01WithSeparateAdd(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4), new LocalMesh1D(128));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps01WithSeparateAdd(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph02(@RO ComputeContext cc, @RW F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps02(kernelContext, a, b));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph03(@RO ComputeContext cc, @RO F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps03(kernelContext, a, b));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph04(@RO ComputeContext cc, @RO F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps04(kernelContext, a, b));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph05(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps05(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph06(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps06(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph07(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps07(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph08(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps08(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph09(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps09(kernelContext, a, b, c));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph10(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps10(kernelContext, a, b));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph11(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps11(kernelContext, a, b));\n-    }\n-\n-    @CodeReflection\n-    public static void computeGraph12(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n-        \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n-        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(size\/4));\n-        cc.dispatchKernel(computeRange, kernelContext -> vectorOps12(kernelContext, a, b));\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView01() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph01(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i++) {\n-            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n-        }\n-\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView01WithFloat4s() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph01WithFloat4s(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i++) {\n-            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n-        }\n-\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView01WithSeparateAdd() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph01WithSeparateAdd(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i++) {\n-            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n-        }\n-\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView02() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph02(cc, arrayA, arrayB, size));\n-\n-        for (int i = 0; i < size; i += 4) {\n-            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 1)), arrayB.array(i + 1), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 2)), arrayB.array(i + 2), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 3)), arrayB.array(i + 3), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView03() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph03(cc, arrayA, arrayB, size));\n-\n-        for (int i = 0; i < size; i += 4) {\n-            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView04() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph04(cc, arrayA, arrayB, size));\n-\n-        for (int i = 0; i < size; i += 4) {\n-            HatAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n-            HatAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView05() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph05(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            HatAsserts.assertEquals((arrayA.array(i) + arrayB.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView06() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph06(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            HatAsserts.assertEquals((arrayA.array(i) - arrayB.array(i)), arrayC.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView07() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph07(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            HatAsserts.assertEquals(arrayA.array(i), arrayC.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView08() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph08(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            float val = (((arrayA.array(i) + arrayB.array(i)) * arrayA.array(i)) \/ arrayB.array(i));\n-            HatAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView09() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-        var arrayC = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph09(cc, arrayA, arrayB, arrayC, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            float val = (arrayA.array(i) + (arrayB.array(i)) * arrayA.array(i));\n-            HatAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView10() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph10(cc, arrayA, arrayB, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView11() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph11(cc, arrayA, arrayB, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n-        }\n-    }\n-\n-    @HatTest\n-    public void TestVectorArrayView12() {\n-        final int size = 1024;\n-        var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-        var arrayA = F32ArrayPadded.create(accelerator, size);\n-        var arrayB = F32ArrayPadded.create(accelerator, size);\n-\n-        Random r = new Random(19);\n-        for (int i = 0; i < size; i++) {\n-            arrayA.array(i, r.nextFloat());\n-            arrayB.array(i, r.nextFloat());\n-        }\n-\n-        accelerator.compute(cc -> computeGraph12(cc, arrayA, arrayB, size));\n-\n-        for (int i = 0; i < size; i ++) {\n-            HatAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n-        }\n-    }\n-}\n+\/\/ \/*\n+\/\/  * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+\/\/  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/  *\n+\/\/  * This code is free software; you can redistribute it and\/or modify it\n+\/\/  * under the terms of the GNU General Public License version 2 only, as\n+\/\/  * published by the Free Software Foundation.  Oracle designates this\n+\/\/  * particular file as subject to the \"Classpath\" exception as provided\n+\/\/  * by Oracle in the LICENSE file that accompanied this code.\n+\/\/  *\n+\/\/  * This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/  * version 2 for more details (a copy is included in the LICENSE file that\n+\/\/  * accompanied this code).\n+\/\/  *\n+\/\/  * You should have received a copy of the GNU General Public License version\n+\/\/  * 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/  *\n+\/\/  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/  * or visit www.oracle.com if you need additional information or have any\n+\/\/  * questions.\n+\/\/  *\/\n+\/\/ package hat.test;\n+\/\/\n+\/\/ import hat.*;\n+\/\/ import hat.backend.Backend;\n+\/\/ import hat.buffer.*;\n+\/\/ import hat.ifacemapper.MappableIface.RO;\n+\/\/ import hat.ifacemapper.MappableIface.RW;\n+\/\/ import hat.ifacemapper.Schema;\n+\/\/ import hat.test.annotation.HatTest;\n+\/\/ import hat.test.engine.HATAsserts;\n+\/\/ import jdk.incubator.code.CodeReflection;\n+\/\/\n+\/\/ import java.lang.invoke.MethodHandles;\n+\/\/ import java.util.Random;\n+\/\/\n+\/\/ public class TestVectorArrayView {\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps01(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vA = a.float4ArrayView();\n+\/\/             Float4[] vB = b.float4ArrayView();\n+\/\/             Float4[] vC = c.float4ArrayView();\n+\/\/             vC[index * 4] = Float4.add(vA[index * 4], vB[index * 4]);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps01WithFloat4s(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vA = a.float4ArrayView();\n+\/\/             Float4[] vB = b.float4ArrayView();\n+\/\/             Float4[] vC = c.float4ArrayView();\n+\/\/             Float4 vAFloat = vA[index * 4];\n+\/\/             Float4 vBFloat = vB[index * 4];\n+\/\/             vC[index * 4] = Float4.add(vAFloat, vBFloat);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps01WithSeparateAdd(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vA = a.float4ArrayView();\n+\/\/             Float4[] vB = b.float4ArrayView();\n+\/\/             Float4[] vC = c.float4ArrayView();\n+\/\/             Float4 res = Float4.add(vA[index * 4], vB[index * 4]);\n+\/\/             vC[index * 4] = res;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps02(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4.MutableImpl[] vArr = a.float4ArrayView();\n+\/\/             Float4.MutableImpl[] bArr = b.float4ArrayView();\n+\/\/             Float4.MutableImpl vA = vArr[index * 4];\n+\/\/             float scaleX = vA.x() * 10.0f;\n+\/\/             vA.x(scaleX);\n+\/\/             bArr[index * 4] = vA;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps03(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4.MutableImpl[] vA = a.float4ArrayView();\n+\/\/             Float4.MutableImpl[] vB = b.float4ArrayView();\n+\/\/             Float4.MutableImpl vAFloat = vA[index * 4];\n+\/\/             float scaleX = vAFloat.x() * 10.0f;\n+\/\/             float scaleY = vAFloat.y() * 20.0f;\n+\/\/             float scaleZ = vAFloat.z() * 30.0f;\n+\/\/             float scaleW = vAFloat.w() * 40.0f;\n+\/\/             vAFloat.x(scaleX);\n+\/\/             vAFloat.y(scaleY);\n+\/\/             vAFloat.z(scaleZ);\n+\/\/             vAFloat.w(scaleW);\n+\/\/             vB[index * 4] = vAFloat;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps04(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4.MutableImpl[] vA = a.float4ArrayView();\n+\/\/             Float4.MutableImpl[] vB = b.float4ArrayView();\n+\/\/             Float4.MutableImpl vAFloat = vA[index * 4];\n+\/\/             vAFloat.x(vAFloat.x() * 10.0f);\n+\/\/             vAFloat.y(vAFloat.y() * 20.0f);\n+\/\/             vAFloat.z(vAFloat.z() * 30.0f);\n+\/\/             vAFloat.w(vAFloat.w() * 40.0f);\n+\/\/             vB[index * 4] = vAFloat;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps05(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vA = a.float4ArrayView();\n+\/\/             Float4[] vB = b.float4ArrayView();\n+\/\/             Float4[] vC = c.float4ArrayView();\n+\/\/             vC[index * 4] = vA[index * 4].add(vB[index * 4]).add(vB[index * 4]);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps06(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vA = a.float4ArrayView();\n+\/\/             Float4[] vB = b.float4ArrayView();\n+\/\/             Float4[] vC = c.float4ArrayView();\n+\/\/             Float4 vD = Float4.sub(vA[index * 4], vB[index * 4]);\n+\/\/             vC[index * 4] = Float4.sub(vA[index * 4], vB[index * 4]);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps07(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vAArray = a.float4ArrayView();\n+\/\/             Float4[] vBArray = b.float4ArrayView();\n+\/\/             Float4[] vCArray = c.float4ArrayView();\n+\/\/\n+\/\/             Float4 vA = vAArray[index * 4];\n+\/\/             Float4 vB = vBArray[index * 4];\n+\/\/             Float4 vC = vA.add(vB).sub(vB);\n+\/\/             vCArray[index * 4] = vC;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps08(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] vAArray = a.float4ArrayView();\n+\/\/             Float4[] vBArray = b.float4ArrayView();\n+\/\/             Float4[] vCArray = c.float4ArrayView();\n+\/\/\n+\/\/             Float4 vA = vAArray[index * 4];\n+\/\/             Float4 vB = vBArray[index * 4];\n+\/\/             Float4 vC = vA.add(vB).mul(vA).div(vB);\n+\/\/             vCArray[index * 4] = vC;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps09(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c) {\n+\/\/         \/\/ Checking composition\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/             Float4[] vAArray = a.float4ArrayView();\n+\/\/             Float4[] vBArray = b.float4ArrayView();\n+\/\/             Float4[] vCArray = c.float4ArrayView();\n+\/\/\n+\/\/             Float4 vA = vAArray[index * 4];\n+\/\/             Float4 vB = vBArray[index * 4];\n+\/\/             Float4 vC = vA.add(vA.mul(vB));\n+\/\/             vCArray[index * 4] = vC;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     private interface SharedMemory extends Buffer {\n+\/\/         void array(long index, float value);\n+\/\/         float array(long index);\n+\/\/         Schema<SharedMemory> schema = Schema.of(SharedMemory.class,\n+\/\/                 arr -> arr.array(\"array\", 1024));\n+\/\/         static SharedMemory create(Accelerator accelerator) {\n+\/\/             return schema.allocate(accelerator);\n+\/\/         }\n+\/\/         static SharedMemory createLocal() {\n+\/\/             return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+\/\/         }\n+\/\/         default Float4 float4View(int index) {\n+\/\/             return null;\n+\/\/         }\n+\/\/         default void storeFloat4View(Float4 float4, int index) {\n+\/\/         }\n+\/\/         default Float4.MutableImpl[] float4LocalArrayView() {\n+\/\/             return null;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps10(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+\/\/         SharedMemory sm = SharedMemory.createLocal();\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/             int lix = kernelContext.lix;\n+\/\/\n+\/\/             Float4[] aArr = a.float4ArrayView();\n+\/\/             Float4[] bArr = b.float4ArrayView();\n+\/\/             Float4[] smArr = sm.float4LocalArrayView();\n+\/\/\n+\/\/             Float4 vA = aArr[index * 4];\n+\/\/             smArr[lix * 4] = vA;\n+\/\/             kernelContext.barrier();\n+\/\/             Float4 r = smArr[lix * 4];\n+\/\/             bArr[index * 4] = r;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     private interface PrivateMemory extends Buffer {\n+\/\/         void array(long index, float value);\n+\/\/         float array(long index);\n+\/\/         Schema<PrivateMemory> schema = Schema.of(PrivateMemory.class,\n+\/\/                 arr -> arr.array(\"array\", 4));\n+\/\/         static PrivateMemory create(Accelerator accelerator) {\n+\/\/             return schema.allocate(accelerator);\n+\/\/         }\n+\/\/         static PrivateMemory createPrivate() {\n+\/\/             return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+\/\/         }\n+\/\/         default Float4 float4View(int index) {\n+\/\/             return null;\n+\/\/         }\n+\/\/         default void storeFloat4View(Float4 float4, int index) {\n+\/\/         }\n+\/\/         default Float4[] float4PrivateArrayView() {\n+\/\/             return null;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps11(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+\/\/         PrivateMemory pm = PrivateMemory.createPrivate();\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/\n+\/\/             Float4[] aArr = a.float4ArrayView();\n+\/\/             Float4[] bArr = b.float4ArrayView();\n+\/\/             Float4[] pmArr = pm.float4PrivateArrayView();\n+\/\/\n+\/\/             Float4 vA = aArr[index * 4];\n+\/\/             pmArr[0] = vA;\n+\/\/             kernelContext.barrier();\n+\/\/             Float4 r = pmArr[0];\n+\/\/             bArr[index * 4] = r;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void vectorOps12(@RO KernelContext kernelContext, @RO F32ArrayPadded a, @RW F32ArrayPadded b) {\n+\/\/         SharedMemory sm = SharedMemory.createLocal();\n+\/\/         if (kernelContext.gix < kernelContext.gsx) {\n+\/\/             int index = kernelContext.gix;\n+\/\/             int lix = kernelContext.lix;\n+\/\/             Float4.MutableImpl[] aArr = a.float4ArrayView();\n+\/\/             Float4.MutableImpl[] bArr = b.float4ArrayView();\n+\/\/             Float4.MutableImpl[] smArr = sm.float4LocalArrayView();\n+\/\/\n+\/\/             Float4.MutableImpl vA = aArr[index * 4];\n+\/\/             Float4.MutableImpl smVector = smArr[lix * 4];\n+\/\/             smVector.x(vA.x());\n+\/\/             smVector.y(vA.y());\n+\/\/             smVector.z(vA.z());\n+\/\/             smVector.w(vA.w());\n+\/\/             smArr[lix * 4] = smVector;\n+\/\/             kernelContext.barrier();\n+\/\/             Float4.MutableImpl r = smArr[lix * 4];\n+\/\/             bArr[index * 4] = r;\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph01(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4), new NDRange.Local1D(128));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps01(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph01WithFloat4s(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4), new NDRange.Local1D(128));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps01WithFloat4s(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph01WithSeparateAdd(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4), new NDRange.Local1D(128));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps01WithSeparateAdd(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph02(@RO ComputeContext cc, @RW F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps02(kernelContext, a, b));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph03(@RO ComputeContext cc, @RO F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps03(kernelContext, a, b));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph04(@RO ComputeContext cc, @RO F32ArrayPadded a, @RW F32ArrayPadded b, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps04(kernelContext, a, b));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph05(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps05(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph06(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps06(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph07(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps07(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph08(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps08(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph09(@RO ComputeContext cc, @RO F32ArrayPadded a, @RO F32ArrayPadded b, @RW F32ArrayPadded c,  int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps09(kernelContext, a, b, c));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph10(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps10(kernelContext, a, b));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph11(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps11(kernelContext, a, b));\n+\/\/     }\n+\/\/\n+\/\/     @CodeReflection\n+\/\/     public static void computeGraph12(@RO ComputeContext cc, @RO F32ArrayPadded a,  @RW F32ArrayPadded b, int size) {\n+\/\/         \/\/ Note: we need to launch N threads \/ vectorWidth -> size \/ 4 for this example\n+\/\/         NDRange ndRange = NDRange.of(new NDRange.Global1D(size\/4));\n+\/\/         cc.dispatchKernel(ndRange, kernelContext -> vectorOps12(kernelContext, a, b));\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView01() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph01(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView01WithFloat4s() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph01WithFloat4s(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView01WithSeparateAdd() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph01WithSeparateAdd(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView02() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph02(cc, arrayA, arrayB, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i += 4) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 1)), arrayB.array(i + 1), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 2)), arrayB.array(i + 2), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 3)), arrayB.array(i + 3), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView03() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph03(cc, arrayA, arrayB, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i += 4) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView04() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph04(cc, arrayA, arrayB, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i += 4) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 0) * 10.0f), arrayB.array(i + 0), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 1) * 20.0f), arrayB.array(i + 1), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 2) * 30.0f), arrayB.array(i + 2), 0.001f);\n+\/\/             HATAsserts.assertEquals((arrayA.array(i + 3) * 40.0f), arrayB.array(i + 3), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView05() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph05(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i) + arrayB.array(i) + arrayB.array(i)), arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView06() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph06(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             HATAsserts.assertEquals((arrayA.array(i) - arrayB.array(i)), arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView07() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph07(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             HATAsserts.assertEquals(arrayA.array(i), arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView08() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph08(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             float val = (((arrayA.array(i) + arrayB.array(i)) * arrayA.array(i)) \/ arrayB.array(i));\n+\/\/             HATAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView09() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayC = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph09(cc, arrayA, arrayB, arrayC, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             float val = (arrayA.array(i) + (arrayB.array(i)) * arrayA.array(i));\n+\/\/             HATAsserts.assertEquals(val, arrayC.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView10() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph10(cc, arrayA, arrayB, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             HATAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView11() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph11(cc, arrayA, arrayB, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             HATAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/\n+\/\/     @HatTest\n+\/\/     public void TestVectorArrayView12() {\n+\/\/         final int size = 1024;\n+\/\/         var accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+\/\/         var arrayA = F32ArrayPadded.create(accelerator, size);\n+\/\/         var arrayB = F32ArrayPadded.create(accelerator, size);\n+\/\/\n+\/\/         Random r = new Random(19);\n+\/\/         for (int i = 0; i < size; i++) {\n+\/\/             arrayA.array(i, r.nextFloat());\n+\/\/             arrayB.array(i, r.nextFloat());\n+\/\/         }\n+\/\/\n+\/\/         accelerator.compute(cc -> computeGraph12(cc, arrayA, arrayB, size));\n+\/\/\n+\/\/         for (int i = 0; i < size; i ++) {\n+\/\/             HATAsserts.assertEquals(arrayA.array(i), arrayB.array(i), 0.001f);\n+\/\/         }\n+\/\/     }\n+\/\/ }\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestVectorArrayView.java","additions":702,"deletions":702,"binary":false,"changes":1404,"status":"modified"}]}