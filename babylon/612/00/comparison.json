{"files":[{"patch":"@@ -401,1 +401,0 @@\n-        CoreOp.FuncOp lowered = OpTk.lower(kernelCallGraph.entrypoint.funcOp());\n@@ -411,2 +410,5 @@\n-        kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n-            CoreOp.FuncOp loweredFunc = OpTk.lower(funcOp);\n+        var here = OpTk.CallSite.of(CudaBackend.class, \"createPTX\");\n+\n+        kernelCallGraph.getModuleOp().functionTable().forEach((_, funcOp) -> {\n+            \/\/ TODO did we just trash any sidetables?\n+            CoreOp.FuncOp loweredFunc = OpTk.lower(here, funcOp);\n@@ -417,1 +419,2 @@\n-        lowered = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,lowered, argsMap, usedMathFns);\n+        CoreOp.FuncOp lowered = OpTk.lower(here, kernelCallGraph.entrypoint.funcOp());\n+        CoreOp.FuncOp loweredPtx = transformPTXPtrs(kernelCallGraph.computeContext.accelerator.lookup,lowered, argsMap, usedMathFns);\n@@ -424,1 +427,1 @@\n-        out.append(createFunction(builder.nl().nl(), lowered, true));\n+        out.append(createFunction(builder.nl().nl(), loweredPtx, true));\n@@ -433,1 +436,2 @@\n-        return func.transform((block, op) -> {\n+        var here = OpTk.CallSite.of(CudaBackend.class, \"transformPTXPtrs\");\n+        return OpTk.transform(here, func,(block, op) -> {\n@@ -464,1 +468,2 @@\n-        CoreOp.FuncOp ssa = SSA.transform(lowered);\n+        var here = OpTk.CallSite.of(CudaBackend.class, \"createFucntion\" );\n+        CoreOp.FuncOp ssa = OpTk.SSATransform(here, lowered);\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,7 +30,7 @@\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -86,1 +86,1 @@\n-    public CudaHATKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+    public CudaHATKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -118,1 +118,1 @@\n-    public CudaHATKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+    public CudaHATKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -123,1 +123,1 @@\n-        if (op1 instanceof Op.Result r && r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp1) {\n+        if (op1 instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp1) {\n@@ -131,1 +131,1 @@\n-        if (op2 instanceof Op.Result r && r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp2) {\n+        if (op2 instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp2) {\n@@ -147,1 +147,1 @@\n-                if (!(r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp1)) {\n+                if (!(r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp1)) {\n@@ -157,1 +157,1 @@\n-                if (!(r.op() instanceof HatVectorBinaryOp hatVectorBinaryOp2)) {\n+                if (!(r.op() instanceof HATVectorBinaryOp hatVectorBinaryOp2)) {\n@@ -170,1 +170,1 @@\n-    public CudaHATKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+    public CudaHATKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -199,1 +199,1 @@\n-    public CudaHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+    public CudaHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n@@ -207,1 +207,1 @@\n-    public CudaHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+    public CudaHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n@@ -226,1 +226,1 @@\n-    public CudaHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+    public CudaHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n@@ -232,1 +232,1 @@\n-        if (operand instanceof Op.Result r && r.op() instanceof HatVectorBinaryOp) {\n+        if (operand instanceof Op.Result r && r.op() instanceof HATVectorBinaryOp) {\n@@ -245,1 +245,1 @@\n-    public CudaHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+    public CudaHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import hat.dialect.HatOP;\n+import hat.dialect.HATOp;\n@@ -167,1 +167,1 @@\n-    public static class PTXPtrOp extends HatOP {\n+    public static class PTXPtrOp extends HATOp {\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/PTXHATKernelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        kernelCallGraph.moduleOp.functionTable().forEach((_, funcOp) -> {\n+        kernelCallGraph.getModuleOp().functionTable().forEach((_, funcOp) -> {\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,7 +30,7 @@\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -82,1 +82,1 @@\n-    public OpenCLHATKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+    public OpenCLHATKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -111,1 +111,1 @@\n-    public OpenCLHATKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+    public OpenCLHATKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -130,1 +130,1 @@\n-    public OpenCLHATKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+    public OpenCLHATKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -155,1 +155,1 @@\n-    public OpenCLHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLHATKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n@@ -163,1 +163,1 @@\n-    public OpenCLHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLHATKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n@@ -182,1 +182,1 @@\n-    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+    public OpenCLHATKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n@@ -196,1 +196,1 @@\n-    public OpenCLHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+    public OpenCLHATKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import hat.dialect.HatMemoryOp;\n+import hat.dialect.HATMemoryOp;\n@@ -44,3 +44,3 @@\n-import hat.phases.HatFinalDetectionPhase;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n+import hat.phases.HATFinalDetectionPhase;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.dialect.java.ClassType;\n@@ -48,1 +48,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -143,7 +142,0 @@\n-    private void updateListOfSchemas(Op op, List<String> localIfaceList) {\n-        if (Objects.requireNonNull(op) instanceof HatMemoryOp hatMemoryOp) {\n-            String klassName = hatMemoryOp.invokeType().toString();\n-            localIfaceList.add(klassName);\n-        }\n-    }\n-\n@@ -151,1 +143,1 @@\n-\n+        var here = OpTk.CallSite.of(C99FFIBackend.class, \"createCode\");\n@@ -167,22 +159,1 @@\n-        List<String> localIFaceList = new ArrayList<>();\n-        \/\/ Traverse the list of reachable functions and append the intrinsics functions found for each of the functions\n-        if (kernelCallGraph.moduleOp != null) {\n-            kernelCallGraph.moduleOp.functionTable()\n-                    .forEach((entryName, f) -> {\n-                        f.transform(CopyContext.create(), (blockBuilder, op) -> {\n-                            updateListOfSchemas(op, localIFaceList);\n-                            blockBuilder.op(op);\n-                            return blockBuilder;\n-                        });\n-                    });\n-        } else {\n-            \/\/ We take the list from all reachable methods. When we finally merge with the moduleOpWrapper,\n-            \/\/ this else-branch will be deleted.\n-            kernelCallGraph.kernelReachableResolvedStream().forEach((kernel) -> {\n-                kernel.funcOp().transform(CopyContext.create(), (blockBuilder, op) -> {\n-                    updateListOfSchemas(op, localIFaceList);\n-                    blockBuilder.op(op);\n-                    return blockBuilder;\n-                });\n-            });\n-        }\n+        List<TypeElement> localIFaceList = new ArrayList<>();\n@@ -190,7 +161,11 @@\n-        \/\/ Traverse the main kernel and append the intrinsics functions found in the main kernel\n-        kernelCallGraph.entrypoint.funcOp()\n-                .transform(CopyContext.create(), (blockBuilder, op) -> {\n-                    updateListOfSchemas(op, localIFaceList);\n-                    blockBuilder.op(op);\n-                    return blockBuilder;\n-                });\n+        kernelCallGraph.getModuleOp()\n+                .elements()\n+                .filter(c->Objects.requireNonNull(c) instanceof HATMemoryOp)\n+                .map(c->((HATMemoryOp)c).invokeType())\n+                .forEach(localIFaceList::add);\n+\n+       kernelCallGraph.entrypoint.funcOp()\n+                .elements()\n+                .filter(c->Objects.requireNonNull(c) instanceof HATMemoryOp)\n+                .map(c->((HATMemoryOp)c).invokeType())\n+                .forEach(localIFaceList::add);\n@@ -202,1 +177,1 @@\n-        for (String klassName : localIFaceList) {\n+        for (TypeElement typeElement : localIFaceList) {\n@@ -204,1 +179,0 @@\n-            Class<?> clazz;\n@@ -206,2 +180,2 @@\n-                clazz = Class.forName(klassName);\n-\n+               Class<?> clazz = (Class<?>)((ClassType)typeElement).resolve(kernelCallGraph.computeContext.accelerator.lookup);\/\/Class.forName(typeElement.toString());\n+                \/\/System.out.println(\"!!!!!!For  \"+clazz);\n@@ -222,2 +196,1 @@\n-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException |\n-                     ClassNotFoundException e) {\n+            } catch (ReflectiveOperationException e) {\n@@ -233,1 +206,1 @@\n-        kernelCallGraph.moduleOp.functionTable()\n+        kernelCallGraph.getModuleOp().functionTable()\n@@ -235,2 +208,2 @@\n-\n-                    HatFinalDetectionPhase finals = new HatFinalDetectionPhase();\n+\/\/ TODO: did we just trash the callgraph sidetables?\n+                    HATFinalDetectionPhase finals = new HATFinalDetectionPhase();\n@@ -245,1 +218,1 @@\n-        HatFinalDetectionPhase hatFinalDetectionPhase = new HatFinalDetectionPhase();\n+        HATFinalDetectionPhase hatFinalDetectionPhase = new HATFinalDetectionPhase();\n@@ -253,0 +226,2 @@\n+        }\n+        if (Config.SHOW_LOWERED_KERNEL_MODEL.isSet(config())){\n@@ -254,1 +229,1 @@\n-            IO.println(OpTk.lower(kernelCallGraph.entrypoint.funcOp()).toText());\n+            IO.println(OpTk.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":28,"deletions":53,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+        var here = OpTk.CallSite.of(FFIBackend.class, \"dispatchCompute\");\n@@ -70,1 +71,1 @@\n-                    OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n+                    OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -132,0 +133,1 @@\n+        var here = OpTk.CallSite.of(FFIBackend.class,\"injectBufferTracking\");\n@@ -139,1 +141,2 @@\n-            transformedFuncOp = computeMethod.funcOp().transform((bldr, op) -> {\n+\n+            transformedFuncOp = OpTk.transform(here, computeMethod.funcOp(),(bldr, op) -> {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import hat.NDRange;\n@@ -30,7 +29,7 @@\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -110,1 +109,1 @@\n-    public OpenCLHatKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+    public OpenCLHatKernelBuilder generateVectorStore(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -115,1 +114,1 @@\n-    public OpenCLHatKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+    public OpenCLHatKernelBuilder generateVectorBinary(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -120,1 +119,1 @@\n-    public OpenCLHatKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+    public OpenCLHatKernelBuilder generateVectorLoad(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -125,1 +124,1 @@\n-    public OpenCLHatKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+    public OpenCLHatKernelBuilder generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n@@ -130,1 +129,1 @@\n-    public OpenCLHatKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+    public OpenCLHatKernelBuilder generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n@@ -135,1 +134,1 @@\n-    public OpenCLHatKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+    public OpenCLHatKernelBuilder hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n@@ -140,1 +139,1 @@\n-    public OpenCLHatKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+    public OpenCLHatKernelBuilder hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+        var here = OpTk.CallSite.of(C99JExtractedBackend.class, \"createCode\");\n@@ -104,1 +105,1 @@\n-        System.out.println(OpTk.lower(kernelCallGraph.entrypoint.funcOp()).toText());\n+        System.out.println(OpTk.lower(here, kernelCallGraph.entrypoint.funcOp()).toText());\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+        var here = OpTk.CallSite.of(JExtractedBackend.class, \"dispatchCompuet\");\n@@ -65,1 +66,1 @@\n-                    OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n+                    OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -85,2 +86,2 @@\n-        System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n-        System.out.println(computeMethod.funcOp().toText());\n+      \/\/  System.out.println(\"COMPUTE entrypoint before injecting buffer tracking...\");\n+       \/\/ System.out.println(computeMethod.funcOp().toText());\n@@ -88,0 +89,1 @@\n+        \/\/ TODO : can't we get this from somewhere maybe it should be capturein the compute method?\n@@ -89,1 +91,2 @@\n-        var transformedFuncOp = computeMethod.funcOp().transform((bldr, op) -> {\n+        var here = OpTk.CallSite.of(JExtractedBackend.class, \"injectBufferTracking\");\n+        var transformedFuncOp = OpTk.transform(here,computeMethod.funcOp(),(bldr, op) -> {\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -90,1 +90,3 @@\n-        CoreOp.FuncOp ssaFunc = SSA.transform(f.transform(OpTransformer.LOWERING_TRANSFORMER));\n+\n+        var here = OpTk.CallSite.of(BufferTagger.class, \"inlineLoop\");\n+        CoreOp.FuncOp ssaFunc = OpTk.SSATransformLower(here, f); \/\/ do we need this nesting?\n@@ -94,1 +96,1 @@\n-            ssaFunc = ssaFunc.transform((bb, op) -> {\n+            ssaFunc = OpTk.transform(OpTk.CallSite.of(BufferTagger.class, \"inlineLoop\"),ssaFunc,(bb, op) -> {\n@@ -106,2 +108,1 @@\n-                            CoreOp.FuncOp ssaInline = SSA.transform(inline.transform(OpTransformer.LOWERING_TRANSFORMER));\n-\n+                            CoreOp.FuncOp ssaInline = OpTk.SSATransformLower(here, inline);\n@@ -111,1 +112,0 @@\n-\n@@ -130,1 +130,2 @@\n-        f.elements().filter(elem -> elem instanceof Block)\n+        var here = OpTk.CallSite.of(BufferTagger.class, \"buildAccessMap\");\n+        OpTk.elements(here, f).filter(elem -> elem instanceof Block)\n@@ -133,1 +134,1 @@\n-        f.traverse(null, (map, op) -> {\n+        OpTk.traverse(here, f, (map, op) -> {\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.dialect.HatBarrierOp;\n@@ -36,2 +35,0 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CopyContext;\n@@ -41,1 +38,0 @@\n-import jdk.incubator.code.Value;\n@@ -47,1 +43,2 @@\n-import java.util.List;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -114,1 +111,1 @@\n-        this.computeCallGraph.close();\n+        \/\/this.computeCallGraph.close(computeCallGraph.entrypoint);\n@@ -139,1 +136,0 @@\n-    \/*\n@@ -141,17 +137,0 @@\n-    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = context.getValues(inputOperands);\n-        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n-        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n-        Op.Result inputResult = invokeOp.result();\n-        context.mapValue(inputResult, outputResult);\n-    } *\/\n@@ -160,2 +139,3 @@\n-\n-    private CallGraph buildKernelCallGraph(QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+    \/\/ TODO: this hack simulates minimizing calls to diealectifyToHat\n+   \/\/ Map<KernelCallGraph, CallGraph> callGraphMap = new HashMap<>();\n+    private CallGraph getKernelCallGraph(QuotableKernelContextConsumer quotableKernelContextConsumer) {\n@@ -169,6 +149,3 @@\n-        \/\/ Analysis : dialect\n-        \/\/ NOTE: Keep the following boolean until we have the config available\/reachable\n-        \/\/ from this class\n-        boolean useDialect = true;\n-        if (useDialect) {\n-            \/\/System.out.println(\"[INFO] Using Hat Dialect?: \" + useDialect);\n+\n+        \/\/ TODO: this hack simulates minimizing calls to diealectifyToHat\n+       \/\/ if (!callGraphMap.containsKey(kernelCallGraph)) {\n@@ -176,3 +153,7 @@\n-        }\n-        kernelCallGraph.convertArrayView();\n-        return new CallGraph(quoted, lambdaOp, methodRef, kernelCallGraph);\n+            kernelCallGraph.convertArrayView();\n+            var cacheMeIfYouCan = new CallGraph(quoted, lambdaOp, methodRef, kernelCallGraph);\n+         \/\/   callGraphMap.put(kernelCallGraph, cacheMeIfYouCan);\n+            return cacheMeIfYouCan;\n+        \/\/}else {\n+          \/\/ return callGraphMap.get(kernelCallGraph);\n+       \/\/ }\n@@ -182,1 +163,1 @@\n-        CallGraph cg = buildKernelCallGraph(quotableKernelContextConsumer);\n+        CallGraph cg = getKernelCallGraph(quotableKernelContextConsumer);\n@@ -202,1 +183,1 @@\n-        CallGraph cg = buildKernelCallGraph(quotableKernelContextConsumer);\n+        CallGraph cg = getKernelCallGraph(quotableKernelContextConsumer);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":18,"deletions":37,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import hat.BufferTagger;\n@@ -61,0 +62,1 @@\n+        var here = OpTk.CallSite.of(DebugBackend.class,\"dispatchCompute\");\n@@ -62,0 +64,1 @@\n+\n@@ -72,1 +75,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -79,1 +82,1 @@\n-                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(computeContext.computeCallGraph.entrypoint.funcOp());\n+                    computeContext.computeCallGraph.entrypoint.lowered = OpTk.lower(here, computeContext.computeCallGraph.entrypoint.funcOp());\n@@ -98,0 +101,1 @@\n+        var here = OpTk.CallSite.of(DebugBackend.class, \"dispatchKernel\");\n@@ -114,1 +118,1 @@\n-                var lowered = OpTk.lower(kernelCallGraph.entrypoint.funcOp());\n+                var lowered = OpTk.lower(here, kernelCallGraph.entrypoint.funcOp());\n@@ -119,1 +123,1 @@\n-                var lowered = OpTk.lower(kernelCallGraph.entrypoint.funcOp());\n+                var lowered = OpTk.lower(here, kernelCallGraph.entrypoint.funcOp());\n@@ -136,2 +140,2 @@\n-\n-                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                System.out.println(\"TRANSFORM dispatchKernel\"+ DebugBackend.class);\n+                CoreOp.FuncOp loweredForm = OpTk.lower(here, highLevelForm);\n@@ -141,0 +145,1 @@\n+                System.out.println(\"TRANSFORM dispatchKernel\"+DebugBackend.class);\n@@ -142,1 +147,1 @@\n-                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+                CoreOp.FuncOp ssaInvokeForm = OpTk.SSATransform(here, loweredForm);\n@@ -154,1 +159,1 @@\n-                CoreOp.FuncOp loweredForm = highLevelForm.transform(OpTransformer.LOWERING_TRANSFORMER);\n+                CoreOp.FuncOp loweredForm = OpTk.lower(here, highLevelForm);\n@@ -158,1 +163,1 @@\n-                CoreOp.FuncOp ssaInvokeForm = SSA.transform(loweredForm);\n+                CoreOp.FuncOp ssaInvokeForm = OpTk.SSATransformLower(here, loweredForm);\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/DebugBackend.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    public CoreOp.ModuleOp moduleOp;\n+    private CoreOp.ModuleOp moduleOp;\n@@ -49,0 +49,3 @@\n+    public CoreOp.ModuleOp getModuleOp(){\n+        return this.moduleOp;\n+    }\n@@ -50,0 +53,3 @@\n+    public void setModuleOp(CoreOp.ModuleOp moduleOp){\n+        this.moduleOp = moduleOp;\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+        setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this));\n+        \/\/close(entrypoint);\n@@ -127,19 +129,21 @@\n-    public void updateDag(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n-        \/*\n-         * A ResolvedComputeMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n-         * <p>\n-         * 1) java calls to compute class static functions\n-         *    a) we must have the code model available for these and must be included in the dag\n-         * 2) calls to buffer based interface mappings\n-         *    a) getters (return non void)\n-         *    b) setters (return void)\n-         *    c) default helpers with @CodeReflection?\n-         * 3) calls to the compute context\n-         *    a) kernel dispatches\n-         *    b) mapped math functions?\n-         *    c) maybe we also handle range creations?\n-         * 4) calls through compute context.accelerator;\n-         *    a) range creations (maybe compute context should manage ranges?)\n-         * 5) References to the dispatched kernels\n-         *    a) We must also have the code models for these and must extend the dag to include these.\n-         *\/\n+    \/*\n+     * A ResolvedComputeMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n+     * <p>\n+     * 1) java calls to compute class static functions\n+     *    a) we must have the code model available for these and must be included in the dag\n+     * 2) calls to buffer based interface mappings\n+     *    a) getters (return non void)\n+     *    b) setters (return void)\n+     *    c) default helpers with @CodeReflection?\n+     * 3) calls to the compute context\n+     *    a) kernel dispatches\n+     *    b) mapped math functions?\n+     *    c) maybe we also handle range creations?\n+     * 4) calls through compute context.accelerator;\n+     *    a) range creations (maybe compute context should manage ranges?)\n+     * 5) References to the dispatched kernels\n+     *    a) We must also have the code models for these and must extend the dag to include these.\n+     *\n+    public void oldUpdateDag(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n+\n+\n@@ -147,1 +151,2 @@\n-        computeReachableResolvedMethodCall.funcOp().traverse(null, (map, op) -> {\n+        var here = OpTk.CallSite.of(ComputeCallGraph.class,\"updateDag\");\n+        OpTk.transform(here, computeReachableResolvedMethodCall.funcOp(),(map, op) -> {\n@@ -192,1 +197,0 @@\n-              \/\/  consumer.accept(wrap(lookup,invokeOp));\n@@ -207,1 +211,1 @@\n-                    updateDag(reachableResolvedMethodCall);\n+                    oldUpdateDag(reachableResolvedMethodCall);\n@@ -215,0 +219,4 @@\n+*\/\n+   \/\/ public void close() {\n+     \/\/   closeWithModuleOp(entrypoint);\n+   \/\/ }\n@@ -216,3 +224,0 @@\n-    public void close() {\n-        closeWithModuleOp(entrypoint);\n-    }\n@@ -220,3 +225,4 @@\n-    public void closeWithModuleOp(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n-        moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOp(), this);\n-    }\n+\n+    \/\/public void close(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n+     \/\/   setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOp(), this));\n+    \/\/}\n@@ -228,0 +234,1 @@\n+            \/\/ TODO this side effect is not good.  we should do this when we construct !\n@@ -230,1 +237,0 @@\n-                            .closeWithModuleOp()\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":35,"deletions":29,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import hat.phases.HatDialectifyTier;\n+import hat.phases.HATDialectifyTier;\n@@ -87,0 +87,1 @@\n+        setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this));\n@@ -88,0 +89,11 @@\n+    \/*\n+     * A ResolvedKernelMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n+     * <p>\n+     * 1) java calls to compute class static functions provided they follow the kernel restrictions\n+     *    a) we must have the code model available for these and must extend the dag\n+     * 2) calls to buffer based interface mappings\n+     *    a) getters (return non void)\n+     *    b) setters (return void)\n+     * 3) calls on the NDRange id\n+     *\n+    void oldUpdateDag(KernelReachableResolvedMethodCall kernelReachableResolvedMethodCall) {\n@@ -89,13 +101,2 @@\n-    void updateDag(KernelReachableResolvedMethodCall kernelReachableResolvedMethodCall) {\n-        \/*\n-         * A ResolvedKernelMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n-         * <p>\n-         * 1) java calls to compute class static functions provided they follow the kernel restrictions\n-         *    a) we must have the code model available for these and must extend the dag\n-         * 2) calls to buffer based interface mappings\n-         *    a) getters (return non void)\n-         *    b) setters (return void)\n-         * 3) calls on the NDRange id\n-         *\/\n-\n-        kernelReachableResolvedMethodCall.funcOp().traverse(null, (map, op) -> {\n+        var here = OpTk.CallSite.of(KernelCallGraph.class,\"updateDag\");\n+        OpTk.traverse(here, kernelReachableResolvedMethodCall.funcOp(), (map, op) -> {\n@@ -138,1 +139,1 @@\n-                    updateDag(reachableResolvedMethodCall);\n+                    oldUpdateDag(reachableResolvedMethodCall);\n@@ -145,1 +146,1 @@\n-    }\n+    }*\/\n@@ -147,2 +148,2 @@\n-    KernelCallGraph close() {\n-        updateDag(entrypoint);\n+   \/\/ KernelCallGraph close() {\n+       \/\/ oldUpdateDag(entrypoint);\n@@ -150,4 +151,5 @@\n-        calls.forEach(m -> m.rank = 0);\n-        entrypoint.rankRecurse();\n-        return this;\n-    }\n+     \/\/   calls.forEach(m -> m.rank = 0);\n+       \/\/ entrypoint.rankRecurse();\n+       \/\/ throw new RuntimeException(\"is close ever called\");\n+       \/\/ return this;\n+   \/\/ }\n@@ -155,4 +157,7 @@\n-    KernelCallGraph closeWithModuleOp() {\n-        moduleOp = OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this);\n-        return this;\n-    }\n+  \/\/  KernelCallGraph closeWithModuleOp() {\n+\n+    \/\/    setModuleOp(OpTk.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOp(), this));\n+        \/\/calls.forEach(m -> m.rank = 0);\n+        \/\/entrypoint.rankRecurse();\n+     \/\/   return this;\n+   \/\/ }\n@@ -163,0 +168,1 @@\n+            \/\/ TODO this side effect seems scary\n@@ -176,2 +182,3 @@\n-        {\n-            HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator.lookup);\n+        \/\/ TODO we should not need the entrypoint handles seprately. !\n+        \/\/{\n+            HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator);\n@@ -180,2 +187,1 @@\n-        }\n-\n+       \/\/ }\n@@ -183,1 +189,1 @@\n-        if (moduleOp != null) {\n+      \/\/  if (moduleOp != null) {\n@@ -185,1 +191,1 @@\n-            moduleOp.functionTable().forEach((_, kernelOp) -> {\n+            getModuleOp().functionTable().forEach((_, funcOp) -> {\n@@ -188,3 +194,3 @@\n-                HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator.lookup);\n-                CoreOp.FuncOp f = tier.run(kernelOp);\n-                funcs.add(f);\n+         \/\/       HATDialectifyTier tier = new HATDialectifyTier(computeContext.accelerator);\n+                CoreOp.FuncOp fn = tier.run(funcOp);\n+                funcs.add(fn);\n@@ -192,4 +198,6 @@\n-            moduleOp = CoreOp.module(funcs);\n-        } else {\n-            kernelReachableResolvedStream().forEach((kernel) -> {\n-                HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator.lookup);\n+            \/\/ TODO: can we just replaced moduleOp here.  What if another side table has a prev reference with non transformed funcOps?\n+             setModuleOp(CoreOp.module(funcs));\n+        \/\/} else {\n+          \/\/  throw new IllegalStateException(\"moduleOp is null\");\n+          \/*  kernelReachableResolvedStream().forEach((kernel) -> {\n+                HatDialectifyTier tier = new HatDialectifyTier(computeContext.accelerator);\n@@ -198,2 +206,2 @@\n-            });\n-        }\n+            }); *\/\n+        \/\/}\n@@ -206,1 +214,1 @@\n-        if (moduleOp != null) {\n+       \/\/ if (moduleOp != null) {\n@@ -208,1 +216,1 @@\n-            moduleOp.functionTable().forEach((_, kernelOp) -> {\n+            getModuleOp().functionTable().forEach((_, kernelOp) -> {\n@@ -212,7 +220,7 @@\n-            moduleOp = CoreOp.module(funcs);\n-        } else {\n-            kernelReachableResolvedStream().forEach((method) -> {\n-                CoreOp.FuncOp f = convertArrayViewForFunc(computeContext.accelerator.lookup, method.funcOp());\n-                method.funcOp(f);\n-            });\n-        }\n+            setModuleOp(CoreOp.module(funcs));\n+       \/\/ } else {\n+         \/\/   kernelReachableResolvedStream().forEach((method) -> {\n+           \/\/     CoreOp.FuncOp f = convertArrayViewForFunc(computeContext.accelerator.lookup, method.funcOp());\n+             \/\/   method.funcOp(f);\n+            \/\/});\n+       \/\/ }\n@@ -231,1 +239,1 @@\n-                    if (OpTk.isBufferArray(l, iop) &&\n+                    if (OpTk.isBufferArray(iop) &&\n@@ -239,1 +247,1 @@\n-                    if (OpTk.isBufferInitialize(l, vop) &&\n+                    if (OpTk.isBufferInitialize(vop) &&\n@@ -247,1 +255,1 @@\n-                    if (OpTk.isBufferInitialize(l, vlop) &&\n+                    if (OpTk.isBufferInitialize(vlop) &&\n@@ -250,1 +258,1 @@\n-                            Op.Result replacement = (OpTk.notGlobalVarOp(l, vlop)) ?\n+                            Op.Result replacement = (OpTk.notGlobalVarOp(vlop)) ?\n@@ -265,1 +273,1 @@\n-                    if (OpTk.isBufferArray(l, alop) &&\n+                    if (OpTk.isBufferArray(alop) &&\n@@ -307,1 +315,1 @@\n-                    if (OpTk.isBufferArray(l, asop) &&\n+                    if (OpTk.isBufferArray( asop) &&\n@@ -353,1 +361,1 @@\n-                    if (OpTk.isBufferArray(l, alen) &&\n+                    if (OpTk.isBufferArray(alen) &&\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":65,"deletions":57,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -27,15 +27,15 @@\n-import hat.dialect.HatBarrierOp;\n-import hat.dialect.HatBlockThreadIdOp;\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatGlobalThreadIdOp;\n-import hat.dialect.HatGlobalSizeOp;\n-import hat.dialect.HatLocalSizeOp;\n-import hat.dialect.HatLocalThreadIdOp;\n-import hat.dialect.HatLocalVarOp;\n-import hat.dialect.HatPrivateVarOp;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATBarrierOp;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -102,1 +102,1 @@\n-    T barrier(ScopedCodeBuilderContext buildContext, HatBarrierOp barrierOp);\n+    T barrier(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp);\n@@ -104,1 +104,1 @@\n-    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HatLocalVarOp barrierOp);\n+    T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp barrierOp);\n@@ -106,1 +106,1 @@\n-    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HatPrivateVarOp hatLocalVarOp);\n+    T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp);\n@@ -108,1 +108,1 @@\n-    T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HatGlobalThreadIdOp hatGlobalThreadIdOp);\n+    T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp hatGlobalThreadIdOp);\n@@ -110,1 +110,1 @@\n-    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HatGlobalSizeOp hatGlobalSizeOp);\n+    T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp hatGlobalSizeOp);\n@@ -112,1 +112,1 @@\n-    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HatLocalThreadIdOp hatLocalThreadIdOp);\n+    T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp hatLocalThreadIdOp);\n@@ -114,1 +114,1 @@\n-    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HatLocalSizeOp hatLocalSizeOp);\n+    T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp);\n@@ -116,1 +116,1 @@\n-    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HatBlockThreadIdOp hatBlockThreadIdOp);\n+    T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp);\n@@ -118,1 +118,1 @@\n-    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp);\n+    T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp);\n@@ -120,1 +120,1 @@\n-    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatFloat4StoreOp);\n+    T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatFloat4StoreOp);\n@@ -122,1 +122,1 @@\n-    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp);\n+    T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp);\n@@ -124,1 +124,1 @@\n-    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp);\n+    T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp);\n@@ -126,1 +126,1 @@\n-    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp);\n+    T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp);\n@@ -128,1 +128,1 @@\n-    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp);\n+    T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp);\n@@ -130,1 +130,1 @@\n-    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp);\n+    T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp);\n@@ -159,15 +159,15 @@\n-            case HatBarrierOp $ -> barrier(buildContext, $);\n-            case HatLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n-            case HatPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n-            case HatGlobalThreadIdOp $ -> hatGlobalThreadOp(buildContext, $);\n-            case HatGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n-            case HatLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n-            case HatLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n-            case HatBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n-            case HatVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n-            case HatVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n-            case HatVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n-            case HatVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n-            case HatVSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n-            case HatVSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n-            case HatVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n+            case HATBarrierOp $ -> barrier(buildContext, $);\n+            case HATLocalVarOp $ -> hatLocalVarOp(buildContext, $);\n+            case HATPrivateVarOp $ -> hatPrivateVarOp(buildContext, $);\n+            case HATGlobalThreadIdOp $ -> hatGlobalThreadOp(buildContext, $);\n+            case HATGlobalSizeOp $ -> hatGlobalSizeOp(buildContext, $);\n+            case HATLocalThreadIdOp $ -> hatLocalThreadIdOp(buildContext, $);\n+            case HATLocalSizeOp $ -> hatLocalSizeOp(buildContext, $);\n+            case HATBlockThreadIdOp $ -> hatBlockThreadIdOp(buildContext, $);\n+            case HATVectorVarOp $ -> hatVectorVarOp(buildContext, $);\n+            case HATVectorStoreView $ -> hatVectorStoreOp(buildContext, $);\n+            case HATVectorBinaryOp $ -> hatBinaryVectorOp(buildContext, $);\n+            case HATVectorLoadOp $ -> hatVectorLoadOp(buildContext, $);\n+            case HATVSelectLoadOp $ -> hatSelectLoadOp(buildContext, $);\n+            case HATVSelectStoreOp $ -> hatSelectStoreOp(buildContext, $);\n+            case HATVectorVarLoadOp $ -> hatVectorVarLoadOp(buildContext, $);\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/BabylonOpBuilder.java","additions":45,"deletions":45,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -28,5 +28,5 @@\n-import hat.dialect.HatBlockThreadIdOp;\n-import hat.dialect.HatGlobalThreadIdOp;\n-import hat.dialect.HatGlobalSizeOp;\n-import hat.dialect.HatLocalSizeOp;\n-import hat.dialect.HatLocalThreadIdOp;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n@@ -36,1 +36,0 @@\n-import jdk.incubator.code.Op;\n@@ -137,1 +136,1 @@\n-    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HatGlobalThreadIdOp globalThreadIdOp) {\n+    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp globalThreadIdOp) {\n@@ -143,1 +142,1 @@\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HatGlobalSizeOp globalSizeOp) {\n+    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp globalSizeOp) {\n@@ -149,1 +148,1 @@\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HatLocalThreadIdOp localThreadIdOp) {\n+    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp localThreadIdOp) {\n@@ -155,1 +154,1 @@\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HatLocalSizeOp hatLocalSizeOp) {\n+    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp) {\n@@ -161,1 +160,1 @@\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HatBlockThreadIdOp hatBlockThreadIdOp) {\n+    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,7 +28,6 @@\n-import hat.FFIConfigCreator;\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -41,1 +40,0 @@\n-import java.text.SimpleDateFormat;\n@@ -43,1 +41,0 @@\n-import java.util.Date;\n@@ -176,1 +173,1 @@\n-    public T varName(HatMemoryOp hatLocalVarOp) {\n+    public T varName(HATMemoryOp hatLocalVarOp) {\n@@ -181,1 +178,1 @@\n-    public T varName(HatVectorVarOp hatVectorVarOp) {\n+    public T varName(HATVectorVarOp hatVectorVarOp) {\n@@ -186,1 +183,1 @@\n-    public T varName(HatVectorLoadOp vectorLoadOp) {\n+    public T varName(HATVectorLoadOp vectorLoadOp) {\n@@ -191,1 +188,1 @@\n-    public T varName(HatVectorStoreView hatVectorStoreView) {\n+    public T varName(HATVectorStoreView hatVectorStoreView) {\n@@ -196,1 +193,1 @@\n-    public T varName(HatVectorBinaryOp hatVectorBinaryOp) {\n+    public T varName(HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -201,1 +198,1 @@\n-    public T varName(HatVectorVarLoadOp hatVectorVarLoadOp) {\n+    public T varName(HATVectorVarLoadOp hatVectorVarLoadOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilder.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,11 +27,10 @@\n-import hat.dialect.HatBarrierOp;\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatLocalVarOp;\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatPrivateVarOp;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATBarrierOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -46,1 +45,0 @@\n-import jdk.incubator.code.Value;\n@@ -70,4 +68,4 @@\n-            case HatMemoryOp $ -> varName($);\n-            case HatVectorVarOp $ -> varName($);\n-            case HatVectorLoadOp $ -> varName($);\n-            case HatVectorBinaryOp $ -> varName($);\n+            case HATMemoryOp $ -> varName($);\n+            case HATVectorVarOp $ -> varName($);\n+            case HATVectorLoadOp $ -> varName($);\n+            case HATVectorBinaryOp $ -> varName($);\n@@ -88,1 +86,1 @@\n-    public record LocalArrayDeclaration(ClassType classType, HatMemoryOp varOp) {}\n+    public record LocalArrayDeclaration(ClassType classType, HATMemoryOp varOp) {}\n@@ -109,1 +107,1 @@\n-    public T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HatLocalVarOp hatLocalVarOp) {\n+    public T hatLocalVarOp(ScopedCodeBuilderContext buildContext, HATLocalVarOp hatLocalVarOp) {\n@@ -116,1 +114,1 @@\n-    public T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HatPrivateVarOp hatLocalVarOp) {\n+    public T hatPrivateVarOp(ScopedCodeBuilderContext buildContext, HATPrivateVarOp hatLocalVarOp) {\n@@ -423,1 +421,1 @@\n-    public T barrier(ScopedCodeBuilderContext buildContext, HatBarrierOp barrierOp) {\n+    public T barrier(ScopedCodeBuilderContext buildContext, HATBarrierOp barrierOp) {\n@@ -494,1 +492,1 @@\n-                        if (resolve instanceof HatMemoryOp) {\n+                        if (resolve instanceof HATMemoryOp) {\n@@ -622,1 +620,1 @@\n-    public abstract T generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView);\n+    public abstract T generateVectorStore(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView);\n@@ -624,1 +622,1 @@\n-    public abstract T generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp);\n+    public abstract T generateVectorBinary(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp);\n@@ -626,1 +624,1 @@\n-    public abstract T generateVectorLoad(ScopedCodeBuilderContext buildContext,HatVectorLoadOp hatVectorLoadOp);\n+    public abstract T generateVectorLoad(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp);\n@@ -628,1 +626,1 @@\n-    public abstract T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext,HatVSelectLoadOp hatVSelectLoadOp);\n+    public abstract T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp);\n@@ -630,1 +628,1 @@\n-    public abstract T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext,HatVSelectStoreOp hatVSelectStoreOp);\n+    public abstract T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp);\n@@ -633,1 +631,1 @@\n-    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -638,1 +636,1 @@\n-    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -643,1 +641,1 @@\n-    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -648,1 +646,1 @@\n-    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n@@ -653,1 +651,1 @@\n-    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/HATCodeBuilderWithContext.java","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,4 +27,2 @@\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -58,1 +56,1 @@\n-            if (value instanceof Op.Result result && result.op() instanceof HatMemoryOp hatMemoryOp) {\n+            if (value instanceof Op.Result result && result.op() instanceof HATMemoryOp hatMemoryOp) {\n@@ -62,1 +60,1 @@\n-            if (value instanceof Op.Result result && result.op() instanceof HatVectorVarOp hatVectorVarOp) {\n+            if (value instanceof Op.Result result && result.op() instanceof HATVectorVarOp hatVectorVarOp) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/ScopedCodeBuilderContext.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-public class HatBarrierOp extends HatOP {\n+public class HATBarrierOp extends HATOp {\n@@ -43,1 +43,1 @@\n-    public HatBarrierOp(List<Value> operands) {\n+    public HATBarrierOp(List<Value> operands) {\n@@ -47,1 +47,1 @@\n-    public HatBarrierOp(HatBarrierOp hatBarrierOp, CopyContext copyContext) {\n+    public HATBarrierOp(HATBarrierOp hatBarrierOp, CopyContext copyContext) {\n@@ -53,1 +53,1 @@\n-        return new HatBarrierOp(this, copyContext);\n+        return new HATBarrierOp(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBarrierOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatBarrierOp.java","status":"renamed"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATBlockThreadIdOp extends HATThreadOp {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"BlockThreadId\";\n+\n+    public HATBlockThreadIdOp(int dimension, TypeElement resultType) {\n+        super(dimension, List.of());\n+        this.resultType = resultType;\n+    }\n+\n+    public HATBlockThreadIdOp(HATBlockThreadIdOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATBlockThreadIdOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATBlockThreadIdOp.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATGlobalSizeOp extends HATThreadOp {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"GlobalThreadSize\";\n+\n+    public HATGlobalSizeOp(int dimension, TypeElement resultType) {\n+        super(dimension, List.of());\n+        this.resultType = resultType;\n+    }\n+\n+    public HATGlobalSizeOp(HATGlobalSizeOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATGlobalSizeOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalSizeOp.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATGlobalThreadIdOp extends HATThreadOp {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"GlobalThreadId\";\n+\n+    public HATGlobalThreadIdOp(int dimension, TypeElement resultType) {\n+        super(dimension, List.of());\n+        this.resultType = resultType;\n+    }\n+\n+    public HATGlobalThreadIdOp(HATGlobalThreadIdOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATGlobalThreadIdOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATGlobalThreadIdOp.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATLocalSizeOp extends HATThreadOp {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"GlobalThreadSize\";\n+\n+    public HATLocalSizeOp(int dimension, TypeElement resultType) {\n+        super(dimension, List.of());\n+        this.resultType = resultType;\n+    }\n+\n+    public HATLocalSizeOp(HATLocalSizeOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATLocalSizeOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalSizeOp.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATLocalThreadIdOp extends HATThreadOp {\n+\n+    private final TypeElement resultType;\n+    private static final String NAME = \"LocalThreadId\";\n+\n+    public HATLocalThreadIdOp(int dimension, TypeElement resultType) {\n+        super(dimension, List.of());\n+        this.resultType = resultType;\n+    }\n+\n+    public HATLocalThreadIdOp(HATLocalThreadIdOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.resultType = op.resultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATLocalThreadIdOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return resultType;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalThreadIdOp.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.ClassType;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATLocalVarOp extends HATMemoryOp {\n+\n+    public static final String INTRINSIC_NAME = \"createLocal\";\n+\n+    private final TypeElement typeElement;\n+    private final ClassType klassType;\n+    private final TypeElement invokeResultType;\n+\n+    public HATLocalVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+        this.klassType = javaType;\n+        this.invokeResultType = invokeResultType;\n+    }\n+\n+    public HATLocalVarOp(HATLocalVarOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.resultType();\n+        this.klassType = op.klassType;\n+        this.invokeResultType = op.invokeResultType;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATLocalVarOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.hatSharedVarOp.\" + varName(), typeElement);\n+    }\n+\n+    @Override\n+    public ClassType classType() {\n+        return klassType;\n+    }\n+\n+    @Override\n+    public TypeElement invokeType() {\n+        return invokeResultType;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATLocalVarOp.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n-public abstract class HatMemoryOp extends HatOP {\n+public abstract class HATMemoryOp extends HATOp {\n@@ -38,1 +38,1 @@\n-    public HatMemoryOp(String varName, List<Value> operands) {\n+    public HATMemoryOp(String varName, List<Value> operands) {\n@@ -43,1 +43,1 @@\n-    protected HatMemoryOp(HatMemoryOp that, CopyContext cc) {\n+    protected HATMemoryOp(HATMemoryOp that, CopyContext cc) {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatMemoryOp.java","status":"renamed"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HATOp extends Op {\n+\n+    public HATOp(List<Value> operands) {\n+        super(operands);\n+    }\n+\n+    protected HATOp(Op that, CopyContext cc) {\n+        super(that, cc);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATOp.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -37,1 +37,1 @@\n-public class HatPrivateVarOp extends HatMemoryOp {\n+public class HATPrivateVarOp extends HATMemoryOp {\n@@ -46,1 +46,1 @@\n-    public HatPrivateVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n+    public HATPrivateVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType, List<Value> operands) {\n@@ -54,1 +54,1 @@\n-    public HatPrivateVarOp(HatPrivateVarOp op, CopyContext copyContext) {\n+    public HATPrivateVarOp(HATPrivateVarOp op, CopyContext copyContext) {\n@@ -64,1 +64,1 @@\n-        return new HatPrivateVarOp(this, copyContext);\n+        return new HATPrivateVarOp(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATPrivateVarOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatPrivateVarOp.java","status":"renamed"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public abstract class HATThreadOp extends HATOp {\n+\n+    private final int dimension;\n+\n+    public HATThreadOp(int dimension, List<Value> operands) {\n+        super(operands);\n+        this.dimension = dimension;\n+    }\n+\n+    protected HATThreadOp(HATThreadOp that, CopyContext cc) {\n+        super(that, cc);\n+        this.dimension = that.dimension;\n+    }\n+\n+    public int getDimension() {\n+        return dimension;\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATThreadOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-public class HatVSelectLoadOp extends HatVectorViewOp {\n+public class HATVSelectLoadOp extends HATVectorViewOp {\n@@ -41,1 +41,1 @@\n-    public HatVSelectLoadOp(String varName, TypeElement typeElement, int lane, List<Value> operands) {\n+    public HATVSelectLoadOp(String varName, TypeElement typeElement, int lane, List<Value> operands) {\n@@ -47,1 +47,1 @@\n-    public HatVSelectLoadOp(HatVSelectLoadOp that, CopyContext cc) {\n+    public HATVSelectLoadOp(HATVSelectLoadOp that, CopyContext cc) {\n@@ -55,1 +55,1 @@\n-        return new HatVSelectLoadOp(this, copyContext);\n+        return new HATVSelectLoadOp(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVSelectLoadOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVSelectLoadOp.java","status":"renamed"},{"patch":"@@ -37,1 +37,1 @@\n-public class HatVSelectStoreOp extends HatVectorViewOp {\n+public class HATVSelectStoreOp extends HATVectorViewOp {\n@@ -43,1 +43,1 @@\n-    public HatVSelectStoreOp(String varName, TypeElement typeElement, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n+    public HATVSelectStoreOp(String varName, TypeElement typeElement, int lane, CoreOp.VarOp resultVarOp, List<Value> operands) {\n@@ -50,1 +50,1 @@\n-    public HatVSelectStoreOp(HatVSelectStoreOp that, CopyContext cc) {\n+    public HATVSelectStoreOp(HATVSelectStoreOp that, CopyContext cc) {\n@@ -59,1 +59,1 @@\n-        return new HatVSelectStoreOp(this, copyContext);\n+        return new HATVSelectStoreOp(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVSelectStoreOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVSelectStoreOp.java","status":"renamed"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATVectorAddOp extends HATVectorBinaryOp {\n+\n+    public HATVectorAddOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.ADD, operands);\n+    }\n+\n+    public HATVectorAddOp(HATVectorAddOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorAddOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorAddOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n@@ -36,1 +34,1 @@\n-public abstract class HatVectorBinaryOp extends HatVectorViewOp {\n+public abstract class HATVectorBinaryOp extends HATVectorViewOp {\n@@ -59,1 +57,1 @@\n-    public HatVectorBinaryOp(String varName, TypeElement typeElement, OpType operationType, List<Value> operands) {\n+    public HATVectorBinaryOp(String varName, TypeElement typeElement, OpType operationType, List<Value> operands) {\n@@ -67,1 +65,1 @@\n-    public HatVectorBinaryOp(HatVectorBinaryOp op, CopyContext copyContext) {\n+    public HATVectorBinaryOp(HATVectorBinaryOp op, CopyContext copyContext) {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorBinaryOp.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorBinaryOp.java","status":"renamed"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATVectorDivOp extends HATVectorBinaryOp {\n+\n+    public HATVectorDivOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.DIV, operands);\n+    }\n+\n+    public HATVectorDivOp(HATVectorDivOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorDivOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorDivOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-public class HatVectorLoadOp extends HatVectorViewOp {\n+public class HATVectorLoadOp extends HATVectorViewOp {\n@@ -43,1 +43,1 @@\n-    public HatVectorLoadOp(String varName, TypeElement typeElement, TypeElement vectorType, int loadN, boolean isShared, List<Value> operands) {\n+    public HATVectorLoadOp(String varName, TypeElement typeElement, TypeElement vectorType, int loadN, boolean isShared, List<Value> operands) {\n@@ -51,1 +51,1 @@\n-    public HatVectorLoadOp(HatVectorLoadOp op, CopyContext copyContext) {\n+    public HATVectorLoadOp(HATVectorLoadOp op, CopyContext copyContext) {\n@@ -61,1 +61,1 @@\n-        return new HatVectorLoadOp(this, copyContext);\n+        return new HATVectorLoadOp(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorLoadOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorLoadOp.java","status":"renamed"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATVectorMulOp extends HATVectorBinaryOp {\n+\n+    public HATVectorMulOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.MUL, operands);\n+    }\n+\n+    public HATVectorMulOp(HATVectorMulOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorMulOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorMulOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-public class HatVectorStoreView extends HatVectorViewOp {\n+public class HATVectorStoreView extends HATVectorViewOp {\n@@ -43,1 +43,1 @@\n-    public HatVectorStoreView(String varName, TypeElement elementType, int storeN, VectorType vectorType, boolean isSharedOrPrivate, List<Value> operands) {\n+    public HATVectorStoreView(String varName, TypeElement elementType, int storeN, VectorType vectorType, boolean isSharedOrPrivate, List<Value> operands) {\n@@ -51,1 +51,1 @@\n-    public HatVectorStoreView(HatVectorStoreView op, CopyContext copyContext) {\n+    public HATVectorStoreView(HATVectorStoreView op, CopyContext copyContext) {\n@@ -61,1 +61,1 @@\n-        return new HatVectorStoreView(this, copyContext);\n+        return new HATVectorStoreView(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorStoreView.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorStoreView.java","status":"renamed"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+\n+public class HATVectorSubOp extends HATVectorBinaryOp {\n+\n+    public HATVectorSubOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, typeElement, OpType.SUB, operands);\n+    }\n+\n+    public HATVectorSubOp(HATVectorSubOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorSubOp(this, copyContext);\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorSubOp.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.dialect;\n+\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.OpTransformer;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public class HATVectorVarLoadOp extends HATVectorViewOp {\n+\n+    private final TypeElement typeElement;\n+\n+    public HATVectorVarLoadOp(String varName, TypeElement typeElement, List<Value> operands) {\n+        super(varName, operands);\n+        this.typeElement = typeElement;\n+    }\n+\n+    public HATVectorVarLoadOp(HATVectorVarLoadOp op, CopyContext copyContext) {\n+        super(op, copyContext);\n+        this.typeElement = op.typeElement;\n+    }\n+\n+    @Override\n+    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n+        return new HATVectorVarLoadOp(this, copyContext);\n+    }\n+\n+    @Override\n+    public TypeElement resultType() {\n+        return typeElement;\n+    }\n+\n+    @Override\n+    public Map<String, Object> externalize() {\n+        return Map.of(\"hat.dialect.vectorVarLoadOp.\" + varName(), typeElement);\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarLoadOp.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -37,1 +37,1 @@\n-public class HatVectorVarOp extends HatVectorViewOp {\n+public class HATVectorVarOp extends HATVectorViewOp {\n@@ -42,1 +42,1 @@\n-    public HatVectorVarOp(String varName, VarType typeElement, int loadN, List<Value> operands) {\n+    public HATVectorVarOp(String varName, VarType typeElement, int loadN, List<Value> operands) {\n@@ -48,1 +48,1 @@\n-    public HatVectorVarOp(HatVectorVarOp op, CopyContext copyContext) {\n+    public HATVectorVarOp(HATVectorVarOp op, CopyContext copyContext) {\n@@ -56,1 +56,1 @@\n-        return new HatVectorVarOp(this, copyContext);\n+        return new HATVectorVarOp(this, copyContext);\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorVarOp.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorVarOp.java","status":"renamed"},{"patch":"@@ -32,1 +32,1 @@\n-public abstract class HatVectorViewOp extends HatOP {\n+public abstract class HATVectorViewOp extends HATOp {\n@@ -36,1 +36,1 @@\n-    public HatVectorViewOp(String varName, List<Value> operands) {\n+    public HATVectorViewOp(String varName, List<Value> operands) {\n@@ -41,1 +41,1 @@\n-    protected HatVectorViewOp(HatVectorViewOp that, CopyContext cc) {\n+    protected HATVectorViewOp(HATVectorViewOp that, CopyContext cc) {\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATVectorViewOp.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorViewOp.java","status":"renamed"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatBlockThreadIdOp extends HatThreadOP {\n-\n-    private final TypeElement resultType;\n-    private static final String NAME = \"BlockThreadId\";\n-\n-    public HatBlockThreadIdOp(int dimension, TypeElement resultType) {\n-        super(dimension, List.of());\n-        this.resultType = resultType;\n-    }\n-\n-    public HatBlockThreadIdOp(HatBlockThreadIdOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.resultType = op.resultType;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatBlockThreadIdOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatBlockThreadIdOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatGlobalSizeOp extends HatThreadOP {\n-\n-    private final TypeElement resultType;\n-    private static final String NAME = \"GlobalThreadSize\";\n-\n-    public HatGlobalSizeOp(int dimension, TypeElement resultType) {\n-        super(dimension, List.of());\n-        this.resultType = resultType;\n-    }\n-\n-    public HatGlobalSizeOp(HatGlobalSizeOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.resultType = op.resultType;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatGlobalSizeOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatGlobalSizeOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatGlobalThreadIdOp extends HatThreadOP {\n-\n-    private final TypeElement resultType;\n-    private static final String NAME = \"GlobalThreadId\";\n-\n-    public HatGlobalThreadIdOp(int dimension, TypeElement resultType) {\n-        super(dimension, List.of());\n-        this.resultType = resultType;\n-    }\n-\n-    public HatGlobalThreadIdOp(HatGlobalThreadIdOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.resultType = op.resultType;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatGlobalThreadIdOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatGlobalThreadIdOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatLocalSizeOp extends HatThreadOP {\n-\n-    private final TypeElement resultType;\n-    private static final String NAME = \"GlobalThreadSize\";\n-\n-    public HatLocalSizeOp(int dimension, TypeElement resultType) {\n-        super(dimension, List.of());\n-        this.resultType = resultType;\n-    }\n-\n-    public HatLocalSizeOp(HatLocalSizeOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.resultType = op.resultType;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatLocalSizeOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalSizeOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatLocalThreadIdOp extends HatThreadOP {\n-\n-    private final TypeElement resultType;\n-    private static final String NAME = \"LocalThreadId\";\n-\n-    public HatLocalThreadIdOp(int dimension, TypeElement resultType) {\n-        super(dimension, List.of());\n-        this.resultType = resultType;\n-    }\n-\n-    public HatLocalThreadIdOp(HatLocalThreadIdOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.resultType = op.resultType;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatLocalThreadIdOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return resultType;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.\" + NAME, this.getDimension());\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalThreadIdOp.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.java.ClassType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatLocalVarOp extends HatMemoryOp {\n-\n-    public static final String INTRINSIC_NAME = \"createLocal\";\n-\n-    private final TypeElement typeElement;\n-    private final ClassType klassType;\n-    private final TypeElement invokeResultType;\n-\n-    public HatLocalVarOp(String varName, ClassType javaType, TypeElement typeElement, TypeElement invokeResultType,  List<Value> operands) {\n-        super(varName, operands);\n-        this.typeElement = typeElement;\n-        this.klassType = javaType;\n-        this.invokeResultType = invokeResultType;\n-    }\n-\n-    public HatLocalVarOp(HatLocalVarOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.resultType();\n-        this.klassType = op.klassType;\n-        this.invokeResultType = op.invokeResultType;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatLocalVarOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.hatSharedVarOp.\" + varName(), typeElement);\n-    }\n-\n-    @Override\n-    public ClassType classType() {\n-        return klassType;\n-    }\n-\n-    @Override\n-    public TypeElement invokeType() {\n-        return invokeResultType;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatLocalVarOp.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public abstract class HatOP extends Op {\n-\n-    public HatOP(List<Value> operands) {\n-        super(operands);\n-    }\n-\n-    protected HatOP(Op that, CopyContext cc) {\n-        super(that, cc);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatOP.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public abstract class HatThreadOP extends HatOP {\n-\n-    private final int dimension;\n-\n-    public HatThreadOP(int dimension, List<Value> operands) {\n-        super(operands);\n-        this.dimension = dimension;\n-    }\n-\n-    protected HatThreadOP(HatThreadOP that, CopyContext cc) {\n-        super(that, cc);\n-        this.dimension = that.dimension;\n-    }\n-\n-    public int getDimension() {\n-        return dimension;\n-    }\n-}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatThreadOP.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public class HatVectorAddOp extends HatVectorBinaryOp {\n-\n-    public HatVectorAddOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.ADD, operands);\n-    }\n-\n-    public HatVectorAddOp(HatVectorAddOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatVectorAddOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorAddOp.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public class HatVectorDivOp extends HatVectorBinaryOp {\n-\n-    public HatVectorDivOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.DIV, operands);\n-    }\n-\n-    public HatVectorDivOp(HatVectorDivOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatVectorDivOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorDivOp.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public class HatVectorMulOp extends HatVectorBinaryOp {\n-\n-    public HatVectorMulOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.MUL, operands);\n-    }\n-\n-    public HatVectorMulOp(HatVectorMulOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatVectorMulOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorMulOp.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-\n-import java.util.List;\n-\n-public class HatVectorSubOp extends HatVectorBinaryOp {\n-\n-    public HatVectorSubOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, typeElement, OpType.SUB, operands);\n-    }\n-\n-    public HatVectorSubOp(HatVectorSubOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatVectorSubOp(this, copyContext);\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorSubOp.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.dialect;\n-\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.OpTransformer;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.VarType;\n-\n-import java.util.List;\n-import java.util.Map;\n-\n-public class HatVectorVarLoadOp extends HatVectorViewOp {\n-\n-    private final TypeElement typeElement;\n-\n-    public HatVectorVarLoadOp(String varName, TypeElement typeElement, List<Value> operands) {\n-        super(varName, operands);\n-        this.typeElement = typeElement;\n-    }\n-\n-    public HatVectorVarLoadOp(HatVectorVarLoadOp op, CopyContext copyContext) {\n-        super(op, copyContext);\n-        this.typeElement = op.typeElement;\n-    }\n-\n-    @Override\n-    public Op transform(CopyContext copyContext, OpTransformer opTransformer) {\n-        return new HatVectorVarLoadOp(this, copyContext);\n-    }\n-\n-    @Override\n-    public TypeElement resultType() {\n-        return typeElement;\n-    }\n-\n-    @Override\n-    public Map<String, Object> externalize() {\n-        return Map.of(\"hat.dialect.vectorVarLoadOp.\" + varName(), typeElement);\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HatVectorVarLoadOp.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.buffer.KernelContext;\n@@ -31,8 +32,8 @@\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatThreadOP;\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVectorAddOp;\n-import hat.dialect.HatVectorDivOp;\n-import hat.dialect.HatVectorMulOp;\n-import hat.dialect.HatVectorSubOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATThreadOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVectorAddOp;\n+import hat.dialect.HATVectorDivOp;\n+import hat.dialect.HATVectorMulOp;\n+import hat.dialect.HATVectorSubOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -41,0 +42,1 @@\n+import jdk.incubator.code.CodeElement;\n@@ -46,0 +48,1 @@\n+import jdk.incubator.code.analysis.SSA;\n@@ -65,1 +68,1 @@\n-import java.util.Optional;\n+import java.util.function.BiFunction;\n@@ -109,1 +112,9 @@\n-    public static boolean isBufferArray(MethodHandles.Lookup l, Op op) {\n+    public static boolean isBufferArray( Op op) {\n+        \/\/ first check if the return is an array type\n+        \/\/if (op instanceof CoreOp.VarOp vop) {\n+        \/\/    if (!(vop.varValueType() instanceof ArrayType)) return false;\n+        \/\/} else if (!(op instanceof JavaOp.ArrayAccessOp)){\n+        \/\/    if (!(op.resultType() instanceof ArrayType)) return false;\n+        \/\/}\n+\n+        \/\/ then check if returned array is from a buffer access\n@@ -118,0 +129,4 @@\n+        \/\/if (iop.invokeDescriptor().refType() instanceof JavaType javaType) {\n+        \/\/    return isAssignable(l, javaType, MappableIface.class);\n+        \/\/}\n+        \/\/return false;\n@@ -121,1 +136,1 @@\n-    public static boolean notGlobalVarOp(MethodHandles.Lookup l, Op op) {\n+    public static boolean notGlobalVarOp( Op op) {\n@@ -134,1 +149,1 @@\n-    public static boolean isBufferInitialize(MethodHandles.Lookup l, Op op) {\n+    public static boolean isBufferInitialize( Op op) {\n@@ -142,1 +157,1 @@\n-        return isBufferArray(l, op);\n+        return isBufferArray(op);\n@@ -145,2 +160,3 @@\n-    public static boolean isArrayView(MethodHandles.Lookup l, CoreOp.FuncOp entry) {\n-        return entry.elements().anyMatch((element) -> (\n+    public static boolean isArrayView(MethodHandles.Lookup lookup, CoreOp.FuncOp entry) {\n+        var here = CallSite.of(OpTk.class,\"isArrayView\");\n+        return elements(here,entry).anyMatch((element) -> (\n@@ -150,1 +166,1 @@\n-                        isAssignable(l, javaType, MappableIface.class)));\n+                        isAssignable(lookup, javaType, MappableIface.class)));\n@@ -153,1 +169,1 @@\n-    public static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup l,\n+    public static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n@@ -161,2 +177,2 @@\n-\n-        entry.traverse(null, (map, op) -> {\n+        var here = CallSite.of(OpTk.class, \"createTransitiveInvokeModule\");\n+        traverse(here, entry, (map, op) -> {\n@@ -166,1 +182,1 @@\n-                    var method = invokeOp.invokeDescriptor().resolveToMethod(l, invokeOp.invokeKind());\n+                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup, invokeOp.invokeKind());\n@@ -168,0 +184,2 @@\n+                    \/\/ TODO filter calls has side effects we may need another call. We might just check the map.\n+\n@@ -178,15 +196,0 @@\n-        \/\/ modEntry.elements().filter(elem -> elem instanceof JavaOp.InvokeOp)\n-        \/\/         .forEach(elem -> {\n-        \/\/             JavaOp.InvokeOp iop = (JavaOp.InvokeOp) elem;\n-        \/\/             Class<?> javaRefTypeClass = javaRefClassOrThrow(callGraph.computeContext.accelerator.lookup, iop);\n-        \/\/             try {\n-        \/\/                 var method = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n-        \/\/                 CoreOp.FuncOp f = Op.ofMethod(method).orElse(null);\n-        \/\/                 if (f != null && !callGraph.filterCalls(f, iop, method, iop.invokeDescriptor(), javaRefTypeClass)) {\n-        \/\/                     work.push(new RefAndFunc(iop.invokeDescriptor(), f));\n-        \/\/                 }\n-        \/\/             } catch (ReflectiveOperationException _) {\n-        \/\/                 throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n-        \/\/             }\n-        \/\/         });\n-\n@@ -195,19 +198,18 @@\n-            if (!funcsVisited.add(rf.r)) {\n-                continue;\n-            }\n-\n-            CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n-                if (op instanceof JavaOp.InvokeOp iop) {\n-                    try {\n-                        Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n-                        if (invokeOpCalledMethod instanceof Method m) {\n-                            CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n-                            if (f!=null) {\n-                                RefAndFunc call = new RefAndFunc(iop.invokeDescriptor(), f);\n-                                work.push(call);\n-                                Op.Result result = blockBuilder.op(CoreOp.funcCall(\n-                                        call.r.name(),\n-                                        call.f.invokableType(),\n-                                        blockBuilder.context().getValues(iop.operands())));\n-                                blockBuilder.context().mapValue(op.result(), result);\n-                                return blockBuilder;\n+            if (funcsVisited.add(rf.r)) {\n+                \/\/ TODO:is this really transforming? it seems to be creating a new funcop.. Oh I guess for the new ModuleOp?\n+                CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n+                    if (op instanceof JavaOp.InvokeOp iop) {\n+                        try {\n+                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(lookup, iop.invokeKind());\n+                            if (invokeOpCalledMethod instanceof Method m) {\n+                                CoreOp.FuncOp f = Op.ofMethod(m).orElse(null);\n+                                if (f != null) {\n+                                    RefAndFunc call = new RefAndFunc(iop.invokeDescriptor(), f);\n+                                    work.push(call);\n+                                    Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                            call.r.name(),\n+                                            call.f.invokableType(),\n+                                            blockBuilder.context().getValues(iop.operands())));\n+                                    blockBuilder.context().mapValue(op.result(), result);\n+                                    return blockBuilder;\n+                                }\n@@ -215,0 +217,2 @@\n+                        } catch (ReflectiveOperationException _) {\n+                            throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n@@ -216,2 +220,0 @@\n-                    } catch (ReflectiveOperationException _) {\n-                        throw new IllegalStateException(\"Could not resolve invokeWrapper to method\");\n@@ -219,4 +221,3 @@\n-                }\n-                blockBuilder.op(op);\n-                return blockBuilder;\n-            });\n+                    blockBuilder.op(op);\n+                    return blockBuilder;\n+                });\n@@ -224,1 +225,2 @@\n-            funcs.addFirst(tf);\n+                funcs.addFirst(tf);\n+            }\n@@ -310,3 +312,0 @@\n-    public static CoreOp.FuncOp lower( CoreOp.FuncOp funcOp) {\n-        return funcOp.transform(OpTransformer.LOWERING_TRANSFORMER);\n-    }\n@@ -322,2 +321,2 @@\n-                        || (op instanceof HatMemoryOp)\n-                        || (op instanceof HatVectorVarOp)\n+                        || (op instanceof HATMemoryOp)\n+                        || (op instanceof HATVectorVarOp)\n@@ -362,1 +361,1 @@\n-\n+\/*\n@@ -379,1 +378,1 @@\n-\n+*\/\n@@ -414,1 +413,1 @@\n-            case HatThreadOP o -> 0;\n+            case HATThreadOp o -> 0;\n@@ -416,1 +415,1 @@\n-            case HatVSelectLoadOp o -> 0;      \/\/ same as VarLoadOp\n+            case HATVSelectLoadOp o -> 0;      \/\/ same as VarLoadOp\n@@ -425,1 +424,1 @@\n-            case HatVectorMulOp o -> 2;\n+            case HATVectorMulOp o -> 2;\n@@ -427,1 +426,1 @@\n-            case HatVectorDivOp o -> 2;\n+            case HATVectorDivOp o -> 2;\n@@ -430,2 +429,2 @@\n-            case HatVectorAddOp o -> 3;\n-            case HatVectorSubOp o -> 3;\n+            case HATVectorAddOp o -> 3;\n+            case HATVectorSubOp o -> 3;\n@@ -560,0 +559,54 @@\n+\n+\n+    public  record CallSite(Class<?> clazz,String methodName){\n+        public static CallSite of(Class<?> clazz, String methodName) {\n+            boolean TRACE = Boolean.getBoolean(\"TRACE_CALLSITES\");\n+\n+                \/\/System.out.println(\"TRACE_CALLSITES \"+TRACE);\n+\n+            return TRACE?new CallSite(clazz,methodName):null;\n+        }\n+\n+        @Override public  String toString(){\n+            return clazz.toString()+\":\"+methodName;\n+        }\n+    }\n+    public static <T> T traverse(CallSite callSite, CoreOp.FuncOp funcOp, BiFunction<T, CodeElement<?,?>,T> bifunc) {\n+        if (callSite!= null){\n+            System.out.println(callSite + \" traverse is being deprecated!!\");\n+        }\n+       return  funcOp.traverse(null, bifunc);\n+    }\n+    public static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (callSite!= null){\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform(OpTransformer.LOWERING_TRANSFORMER);\n+    }\n+    public static Stream<CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n+        if (callSite!= null){\n+            System.out.println(callSite);\n+        }\n+        return funcOp.elements();\n+    }\n+\n+    public static CoreOp.FuncOp SSATransformLower(CallSite callSite, CoreOp.FuncOp funcOp){\n+        if (callSite!= null){\n+            System.out.println(callSite);\n+        }\n+        return  SSA.transform(lower(callSite,funcOp));\n+    }\n+    public static CoreOp.FuncOp SSATransform(CallSite callSite, CoreOp.FuncOp funcOp){\n+        if (callSite!= null){\n+            System.out.println(callSite);\n+        }\n+        return  SSA.transform(funcOp);\n+    }\n+\n+    public static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, OpTransformer opTransformer) {\n+        if (callSite!= null){\n+            System.out.println(callSite);\n+        }\n+        return funcOp.transform(opTransformer);\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":127,"deletions":74,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-public interface HatCompilationTier {\n+public interface HATCompilationTier {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATCompilationTier.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatCompilationTier.java","status":"renamed"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+\n+public class HATDialectAbstractPhase {\n+\n+    protected final Accelerator accelerator;\n+\n+    HATDialectAbstractPhase(Accelerator accelerator) {\n+        this.accelerator = accelerator;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectAbstractPhase.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.Config;\n+import hat.dialect.HATBarrierOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyBarrierPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+\n+    public HATDialectifyBarrierPhase(Accelerator accelerator) {\n+        super(accelerator);\n+    }\n+\n+    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n+        List<Value> inputOperands = invokeOp.operands();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        HATBarrierOp hatBarrierOp = new HATBarrierOp(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n+        Op.Result inputResult = invokeOp.result();\n+        hatBarrierOp.setLocation(invokeOp.location());\n+        context.mapValue(inputResult, outputResult);\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+            System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        }\n+        Stream<CodeElement<?, ?>> elements = funcOp\n+                .elements()\n+                .mapMulti((element, consumer) -> {\n+                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HATBarrierOp.INTRINSIC_NAME)) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n+        if (collect.isEmpty()) {\n+            \/\/ Return the function with no modifications\n+            return funcOp;\n+        }\n+        var here = OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"run\");\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!collect.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                createBarrierNodeOp(context, invokeOp, blockBuilder);\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+            System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + funcOp.toText());\n+        }\n+        return funcOp;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.Config;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATMemoryOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.ClassType;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyMemoryPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+\n+    public enum Space {\n+        PRIVATE,\n+        SHARED,\n+    }\n+\n+    private final Space memorySpace;\n+\n+    public HATDialectifyMemoryPhase(Accelerator accelerator, Space space) {\n+        super(accelerator);\n+        this.memorySpace = space;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+            String nameNode = switch (memorySpace) {\n+                case PRIVATE -> HATPrivateVarOp.INTRINSIC_NAME;\n+                case SHARED -> HATLocalVarOp.INTRINSIC_NAME;\n+            };\n+\n+            if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+                IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n+            }\n+            Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                    .mapMulti((codeElement, consumer) -> {\n+                        if (codeElement instanceof CoreOp.VarOp varOp) {\n+                            List<Value> inputOperandsVarOp = varOp.operands();\n+                            for (Value inputOperand : inputOperandsVarOp) {\n+                                if (inputOperand instanceof Op.Result result) {\n+                                    if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                        if (OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n+                                            \/\/ It is the node we are looking for\n+                                            consumer.accept(invokeOp);\n+                                            consumer.accept(varOp);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    });\n+\n+            Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+            if (nodesInvolved.isEmpty()) {\n+                \/\/ No memory nodes involved\n+                return funcOp;\n+            }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyMemoryPhase.class, \"run\");\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+                CopyContext context = blockBuilder.context();\n+                if (!nodesInvolved.contains(op)) {\n+                    blockBuilder.op(op);\n+                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                    \/\/ Don't insert the invoke node\n+                    Op.Result result = invokeOp.result();\n+                    List<Op.Result> collect = result.uses().stream().toList();\n+                    for (Op.Result r : collect) {\n+                        if (r.op() instanceof CoreOp.VarOp varOp) {\n+                            \/\/ That's the node we want\n+                            List<Value> inputOperandsVarOp = invokeOp.operands();\n+                            List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                            HATMemoryOp memoryOp = switch (memorySpace) {\n+                                case SHARED ->\n+                                        new HATLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                                default ->\n+                                        new HATPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n+                            };\n+\n+                            Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n+\n+                            \/\/ update location\n+                            memoryOp.setLocation(varOp.location());\n+\n+                            context.mapValue(invokeOp.result(), hatLocalResult);\n+                        }\n+                    }\n+                } else if (op instanceof CoreOp.VarOp varOp) {\n+                    \/\/ pass value\n+                    context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+                }\n+                return blockBuilder;\n+            });\n+            if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+                IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n+            }\n+            return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-public interface HatDialectifyPhase {\n+public interface HATDialectifyPhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyPhase.java","status":"renamed"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.Config;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n+import hat.dialect.HATThreadOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyThreadsPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+\n+    private final ThreadAccess threadAccess;\n+\n+    public HATDialectifyThreadsPhase(Accelerator accelerator,ThreadAccess threadAccess) {\n+        super(accelerator);\n+        this.threadAccess =  threadAccess;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[INFO] Code model before HatDialectifyThreadsPhase: \" + funcOp.toText());\n+\n+        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                        List<Value> operands = fieldLoadOp.operands();\n+                        for (Value inputOperand : operands) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                    boolean isThreadIntrinsic = switch (threadAccess) {\n+                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n+                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n+                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n+                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n+                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n+                                    };\n+                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n+                                        consumer.accept(fieldLoadOp);\n+                                        consumer.accept(varLoadOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            \/\/ No memory nodes involved\n+            return funcOp;\n+        }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyThreadsPhase.class, \"run\");\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+                List<Value> operands = fieldLoadOp.operands();\n+                for (Value operand : operands) {\n+                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> varLoadOperands = varLoadOp.operands();\n+                        List<Value> outputOperands = context.getValues(varLoadOperands);\n+                        int dim = getDimension(threadAccess, fieldLoadOp);\n+                        if (dim < 0) {\n+                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n+                        }\n+                        HATThreadOp threadOP = switch (threadAccess) {\n+                            case GLOBAL_ID -> new HATGlobalThreadIdOp(dim, fieldLoadOp.resultType());\n+                            case GLOBAL_SIZE -> new HATGlobalSizeOp(dim, fieldLoadOp.resultType());\n+                            case LOCAL_ID -> new HATLocalThreadIdOp(dim, fieldLoadOp.resultType());\n+                            case LOCAL_SIZE -> new HATLocalSizeOp(dim, fieldLoadOp.resultType());\n+                            case BLOCK_ID -> new HATBlockThreadIdOp(dim, fieldLoadOp.resultType());\n+                        };\n+                        Op.Result threadResult = blockBuilder.op(threadOP);\n+\n+                        \/\/ update location\n+                        threadOP.setLocation(fieldLoadOp.location());\n+\n+                        context.mapValue(fieldLoadOp.result(), threadResult);\n+                    }\n+                }\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[INFO] Code model after HatDialectifyThreadsPhase: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    public enum ThreadAccess {\n+        GLOBAL_ID,\n+        GLOBAL_SIZE,\n+        LOCAL_ID,\n+        LOCAL_SIZE,\n+        BLOCK_ID,\n+    }\n+\n+    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        String fieldName = fieldLoadOp.fieldDescriptor().name();\n+        switch (threadAccess) {\n+            case GLOBAL_ID -> {\n+                if (fieldName.equals(\"y\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"z\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case GLOBAL_SIZE -> {\n+                if (fieldName.equals(\"gsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"gsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_ID -> {\n+                if (fieldName.equals(\"liy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lyz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case LOCAL_SIZE -> {\n+                if (fieldName.equals(\"lsy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"lsz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+            case BLOCK_ID ->  {\n+                if (fieldName.equals(\"biy\")) {\n+                    return 1;\n+                } else if (fieldName.equals(\"biz\")) {\n+                    return 2;\n+                }\n+                return 0;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+\n+    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n+    }\n+\n+    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n+    }\n+\n+    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n+    }\n+\n+    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n+    }\n+\n+    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n+                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n+                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n+    }\n+\n+    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n+        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n+    }\n+\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+\n+public class HATDialectifyTier implements HATCompilationTier {\n+\n+    private List<HATDialectifyPhase> hatPhases = new ArrayList<>();\n+\n+    public HATDialectifyTier(Accelerator accelerator) {\n+        hatPhases.add(new HATDialectifyBarrierPhase(accelerator));\n+        Arrays.stream(HATDialectifyMemoryPhase.Space.values())\n+                .forEach(space -> hatPhases.add(new HATDialectifyMemoryPhase(accelerator,space)));\n+        Arrays.stream(HATDialectifyThreadsPhase.ThreadAccess.values())\n+                .forEach(threadAccess -> hatPhases.add(new HATDialectifyThreadsPhase(accelerator,threadAccess)));\n+        Arrays.stream(HATDialectifyVectorOpPhase.OpView.values())\n+                .forEach(vectorOperation -> hatPhases.add(new HATDialectifyVectorOpPhase(accelerator, vectorOperation)));\n+        Arrays.stream(HATDialectifyVectorStorePhase.StoreView.values())\n+                .forEach(vectorOperation -> hatPhases.add(new HATDialectifyVectorStorePhase(accelerator, vectorOperation)));\n+        hatPhases.add(new HATDialectifyVSelectPhase(accelerator));\n+    }\n+\n+    \/\/ It computes a set of function code model transformations from FuncOp to FuncOp'.\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        BlockingQueue<HATDialectifyPhase> queue = new ArrayBlockingQueue<>(hatPhases.size());\n+        queue.addAll(hatPhases);\n+\n+        CoreOp.FuncOp f = funcOp;\n+        while (!queue.isEmpty()) {\n+            try {\n+                \/\/ TODO Did we just trash side tables ?\n+                HATDialectifyPhase phase = queue.take();\n+                f = phase.run(f);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return f;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyTier.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.Config;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorViewOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import jdk.incubator.code.dialect.java.JavaType;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyVSelectPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+\n+    public HATDialectifyVSelectPhase(Accelerator accelerator) {\n+        super(accelerator);\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n+        return isMethod(invokeOp, \"x\")\n+                || isMethod(invokeOp, \"y\")\n+                || isMethod(invokeOp, \"z\")\n+                || isMethod(invokeOp, \"w\");\n+    }\n+\n+    int getLane(String fieldName) {\n+        return switch (fieldName) {\n+            case \"x\" -> 0;\n+            case \"y\" -> 1;\n+            case \"z\" -> 2;\n+            case \"w\" -> 3;\n+            default -> -1;\n+        };\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n+        String invokeClass = invokeOp.invokeDescriptor().refType().toString();\n+        boolean isHatVectorType = invokeClass.startsWith(\"hat.buffer.Float\");\n+        return isHatVectorType\n+                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n+                && (isVectorLane(invokeOp));\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp vectorViewOp) {\n+                return vectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private CoreOp.VarOp findVarOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findVarOp(varLoadOp.operands().get(0));\n+    }\n+\n+    private CoreOp.VarOp findVarOp(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findVarOp(varLoadOp);\n+        } else {\n+            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n+                return varOp;\n+            }\n+            return null;\n+        }\n+    }\n+\n+\n+    \/\/ Code Model Pattern:\n+    \/\/  %16 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"63:28\";\n+    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.buffer.Float4::x():float\";\n+\n+    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n+\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[BEFORE] VSelect Load Transform: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            Value inputOperand = inputOperandsInvoke.getFirst();\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(invokeOp);\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyVSelectPhase.class, \"vloadSelectPhase\");\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputInvokeOp = invokeOp.operands();\n+                for (Value v : inputInvokeOp) {\n+                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n+                        int lane = getLane(invokeOp.invokeDescriptor().name());\n+                        HATVectorViewOp vSelectOp;\n+                        String name = findNameVector(varLoadOp);\n+                        if (invokeOp.resultType() != JavaType.VOID) {\n+                            vSelectOp = new HATVSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n+                        } else {\n+                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n+                        }\n+                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n+                        vSelectOp.setLocation(invokeOp.location());\n+                        context.mapValue(invokeOp.result(), hatSelectResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ Pass the value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[After] VSelect Load Transform: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    \/\/ Pattern from the code mode:\n+    \/\/ %20 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"64:13\";\n+    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n+    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.buffer.Float4::x(float):void\";\n+    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[BEFORE] VSelect Store Transform \" + funcOp.toText());\n+        var here = OpTk.CallSite.of(HATDialectifyVSelectPhase.class,\"vstoreSelectPhase\");\n+        \/\/TODO is this side table safe?\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTk.elements(here,funcOp)\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            Value inputOperand = inputOperandsInvoke.getFirst();\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(invokeOp);\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputInvokeOp = invokeOp.operands();\n+                Value v = inputInvokeOp.getFirst();\n+\n+                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n+                    int lane = getLane(invokeOp.invokeDescriptor().name());\n+                    HATVectorViewOp vSelectOp;\n+                    String name = findNameVector(varLoadOp);\n+                    if (invokeOp.resultType() == JavaType.VOID) {\n+                        \/\/ The operand 1 in the store is the address (lane)\n+                        \/\/ The operand 1 in the store is the storeValue\n+                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n+                        vSelectOp = new HATVSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n+                    } else {\n+                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n+                    }\n+                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n+                    vSelectOp.setLocation(invokeOp.location());\n+                    context.mapValue(invokeOp.result(), resultVStore);\n+                }\n+\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ Pass the value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[AFTER] VSelect Store Transform: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        funcOp = vloadSelectPhase(funcOp);\n+        funcOp = vstoreSelectPhase(funcOp);\n+        return funcOp;\n+    }\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVSelectPhase.java","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.Config;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorAddOp;\n+import hat.dialect.HATVectorDivOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorMulOp;\n+import hat.dialect.HATVectorSubOp;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n+import hat.dialect.HATVectorViewOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import javax.xml.crypto.dsig.Transform;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyVectorOpPhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+\n+    private final OpView vectorOperation;\n+\n+    public HATDialectifyVectorOpPhase(Accelerator accelerator, OpView vectorOperation) {\n+        super(accelerator);\n+        this.vectorOperation = vectorOperation;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    private HATVectorBinaryOp.OpType getBinaryOpType(JavaOp.InvokeOp invokeOp) {\n+        return switch (invokeOp.invokeDescriptor().name()) {\n+            case \"add\" -> HATVectorBinaryOp.OpType.ADD;\n+            case \"sub\" -> HATVectorBinaryOp.OpType.SUB;\n+            case \"mul\" -> HATVectorBinaryOp.OpType.MUL;\n+            case \"div\" -> HATVectorBinaryOp.OpType.DIV;\n+            default -> throw new RuntimeException(\"Unknown binary op \" + invokeOp.invokeDescriptor().name());\n+        };\n+    }\n+\n+    public enum OpView {\n+        FLOAT4_LOAD(\"float4View\"),\n+        ADD(\"add\"),\n+        SUB(\"sub\"),\n+        MUL(\"mul\"),\n+        DIV(\"div\");\n+        final String methodName;\n+        OpView(String methodName) {\n+            this.methodName = methodName;\n+        }\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n+        TypeElement typeElement = invokeOp.resultType();\n+        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n+        return isHatVectorType\n+                && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n+                && isMethod(invokeOp, vectorOperation.methodName);\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp hatVectorViewOp) {\n+                return hatVectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findIsSharedOrPrivate(varLoadOp.operands().get(0));\n+    }\n+\n+    private boolean findIsSharedOrPrivate(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findIsSharedOrPrivate(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private HATVectorBinaryOp buildVectorBinaryOp(HATVectorBinaryOp.OpType opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n+        return switch (opType) {\n+            case ADD -> new HATVectorAddOp(varName, resultType, outputOperands);\n+            case SUB -> new HATVectorSubOp(varName, resultType, outputOperands);\n+            case MUL -> new HATVectorMulOp(varName, resultType, outputOperands);\n+            case DIV -> new HATVectorDivOp(varName, resultType, outputOperands);\n+        };\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorLoad(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[BEFORE] Vector Load Ops: \" + funcOp.toText());\n+            Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = varOp.operands();\n+                        for (Value inputOperand : inputOperandsVarOp) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                    if (isVectorOperation(invokeOp)) {\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyVectorOpPhase.class, \"dialectifyVectorLoad\" );\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node\n+                Op.Result result = invokeOp.result();\n+                List<Op.Result> collect = result.uses().stream().toList();\n+                boolean isShared = findIsSharedOrPrivate(invokeOp.operands().getFirst());\n+                for (Op.Result r : collect) {\n+                    if (r.op() instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = invokeOp.operands();\n+                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                        HATVectorViewOp memoryViewOp = new HATVectorLoadOp(varOp.varName(), varOp.resultType(), invokeOp.resultType(), 4, isShared, outputOperandsVarOp);\n+                        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                        memoryViewOp.setLocation(varOp.location());\n+                        context.mapValue(invokeOp.result(), hatLocalResult);\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                \/\/ pass value\n+                \/\/context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n+                List<Value> inputOperandsVarOp = varOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HATVectorViewOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), hatLocalResult);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[AFTER] Vector Load Ops: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorBinaryOps(CoreOp.FuncOp funcOp) {\n+        Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[BEFORE] Vector Binary Ops: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof CoreOp.VarOp varOp) {\n+                        List<Value> inputOperandsVarOp = varOp.operands();\n+                        for (Value inputOperand : inputOperandsVarOp) {\n+                            if (inputOperand instanceof Op.Result result) {\n+                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n+                                    if (isVectorOperation(invokeOp)) {\n+                                        HATVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n+                                        binaryOperation.put(invokeOp, binaryOpType);\n+                                        consumer.accept(invokeOp);\n+                                        consumer.accept(varOp);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyVectorOpPhase.class, \"dialectifyVectorBinaryOps\");\n+        funcOp = OpTk.transform(here, funcOp,(blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                Op.Result result = invokeOp.result();\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+                List<Op.Result> collect = result.uses().stream().toList();\n+                for (Op.Result r : collect) {\n+                    if (r.op() instanceof CoreOp.VarOp varOp) {\n+                        HATVectorBinaryOp.OpType binaryOpType = binaryOperation.get(invokeOp);\n+                        HATVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), outputOperands);\n+                        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n+                        memoryViewOp.setLocation(varOp.location());\n+                        context.mapValue(invokeOp.result(), hatVectorOpResult);\n+                        break;\n+                    }\n+                }\n+            } else if (op instanceof CoreOp.VarOp varOp) {\n+                List<Value> inputOperandsVarOp = varOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                HATVectorViewOp memoryViewOp = new HATVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n+                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varOp.location());\n+                context.mapValue(varOp.result(), hatVectorResult);\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    private CoreOp.FuncOp dialectifyVectorBinaryWithContatenationOps(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[BEFORE] Vector Contact Binary Ops: \" + funcOp.toText());\n+\n+        Map<JavaOp.InvokeOp, HATVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if (isVectorOperation(invokeOp)) {\n+                            List<Value> inputOperandsInvoke = invokeOp.operands();\n+                            for (Value inputOperand : inputOperandsInvoke) {\n+                                if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                    HATVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n+                                    binaryOperation.put(invokeOp, binaryOpType);\n+                                    consumer.accept(varLoadOp);\n+                                    consumer.accept(invokeOp);\n+                                }\n+                            }\n+                        }\n+                    } else if (codeElement instanceof HATVectorBinaryOp hatVectorBinaryOp) {\n+                        List<Value> inputOperandsInvoke = hatVectorBinaryOp.operands();\n+                        for (Value inputOperand : inputOperandsInvoke) {\n+                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                                consumer.accept(varLoadOp);\n+                            }\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+        var here = OpTk.CallSite.of(HATDialectifyVectorOpPhase.class, \"dialectifyBinaryWithConcatenation\");\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                List<Value> inputOperands = invokeOp.operands();\n+                List<Value> outputOperands = context.getValues(inputOperands);\n+                HATVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), outputOperands);\n+                Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), hatVectorOpResult);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                List<Value> inputOperandsVarLoad = varLoadOp.operands();\n+                List<Value> outputOperandsVarLoad = context.getValues(inputOperandsVarLoad);\n+                String varLoadName = findNameVector(varLoadOp);\n+                HATVectorViewOp memoryViewOp = new HATVectorVarLoadOp(varLoadName, varLoadOp.resultType(), outputOperandsVarLoad);\n+                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n+                memoryViewOp.setLocation(varLoadOp.location());\n+                context.mapValue(varLoadOp.result(), hatVectorResult);\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        if (Objects.requireNonNull(vectorOperation) == OpView.FLOAT4_LOAD) {\n+            funcOp = dialectifyVectorLoad(funcOp);\n+        } else {\n+            \/\/ Find binary operations\n+            funcOp = dialectifyVectorBinaryOps(funcOp);\n+            funcOp = dialectifyVectorBinaryWithContatenationOps(funcOp);\n+        }\n+        return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.phases;\n+\n+import hat.Accelerator;\n+import hat.Config;\n+import hat.dialect.HATLocalVarOp;\n+import hat.dialect.HATPrivateVarOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATVectorViewOp;\n+import hat.optools.OpTk;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CopyContext;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class HATDialectifyVectorStorePhase extends HATDialectAbstractPhase implements HATDialectifyPhase {\n+    private final StoreView vectorOperation;\n+\n+    public HATDialectifyVectorStorePhase(Accelerator accelerator, StoreView vectorOperation) {\n+        super(accelerator);\n+        this.vectorOperation = vectorOperation;\n+    }\n+\n+    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n+        return invokeOp.invokeDescriptor().name().equals(methodName);\n+    }\n+\n+    public enum StoreView {\n+        FLOAT4_STORE(\"storeFloat4View\");\n+\n+        final String methodName;\n+        StoreView(String methodName) {\n+            this.methodName = methodName;\n+        }\n+    }\n+\n+    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue) {\n+        if (varValue instanceof Op.Result r\n+                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            TypeElement typeElement = varLoadOp.resultType();\n+            boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n+            return isHatVectorType\n+                    && OpTk.isIfaceBufferMethod(accelerator.lookup, invokeOp)\n+                    && isMethod(invokeOp, vectorOperation.methodName);\n+        }\n+        return false;\n+    }\n+\n+    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findNameVector(varLoadOp.operands().get(0));\n+    }\n+\n+    private String findNameVector(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findNameVector(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorViewOp hatVectorViewOp) {\n+                return hatVectorViewOp.varName();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private boolean findIsSharedOrPrivateSpace(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return findIsSharedOrPrivateSpace(varLoadOp.operands().get(0));\n+    }\n+\n+    private boolean findIsSharedOrPrivateSpace(Value v) {\n+        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            return findIsSharedOrPrivateSpace(varLoadOp);\n+        } else {\n+            \/\/ Leaf of tree -\n+            if (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp)) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[BEFORE] Vector Types STORE Transform: \" + funcOp.toText());\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n+                .mapMulti((codeElement, consumer) -> {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n+                        if ((invokeOp.operands().size() >= 3)\n+                                && (isVectorOperation(invokeOp, invokeOp.operands().get(1)))) {\n+                            consumer.accept(invokeOp);\n+                        }\n+                    }\n+                });\n+\n+        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n+        if (nodesInvolved.isEmpty()) {\n+            return funcOp;\n+        }\n+\n+        var here = OpTk.CallSite.of(HATDialectifyVectorStorePhase.class, \"run\");\n+        funcOp = OpTk.transform(here, funcOp, (blockBuilder, op) -> {\n+            CopyContext context = blockBuilder.context();\n+            if (!nodesInvolved.contains(op)) {\n+                blockBuilder.op(op);\n+            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n+                \/\/ Don't insert the invoke node\n+                List<Value> inputOperandsVarOp = invokeOp.operands();\n+                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n+                \/\/ Find the name of the vector view variable\n+                Value v = invokeOp.operands().get(1);\n+                String name = findNameVector(v);\n+                boolean isSharedOrPrivate = findIsSharedOrPrivateSpace(invokeOp.operands().get(0));\n+\n+                HATVectorViewOp storeView = switch (vectorOperation) {\n+                    case FLOAT4_STORE -> new HATVectorStoreView(name, invokeOp.resultType(), 4, HATVectorViewOp.VectorType.FLOAT4, isSharedOrPrivate,  outputOperandsVarOp);\n+                };\n+                Op.Result hatLocalResult = blockBuilder.op(storeView);\n+                storeView.setLocation(invokeOp.location());\n+                context.mapValue(invokeOp.result(), hatLocalResult);\n+            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+                \/\/ pass value\n+                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n+            }\n+            return blockBuilder;\n+        });\n+        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+            IO.println(\"[AFTER] Vector Types STORE Transform: \" + funcOp.toText());\n+        return funcOp;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-public class HatFinalDetectionPhase implements HatPhase {\n+public class HATFinalDetectionPhase implements HATPhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetectionPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatFinalDetectionPhase.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-public interface HatPhase {\n+public interface HATPhase {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATPhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatPhase.java","status":"renamed"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-\n-public class HatDialectAbstractPhase {\n-\n-    protected final Config config;\n-\n-    HatDialectAbstractPhase(Config config) {\n-        this.config = config;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectAbstractPhase.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import hat.dialect.HatBarrierOp;\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HatDialectifyBarrierPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n-\n-    public HatDialectifyBarrierPhase(Config config) {\n-        super(config);\n-    }\n-\n-    private boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private void createBarrierNodeOp(CopyContext context, JavaOp.InvokeOp invokeOp, Block.Builder blockBuilder) {\n-        List<Value> inputOperands = invokeOp.operands();\n-        List<Value> outputOperands = context.getValues(inputOperands);\n-        HatBarrierOp hatBarrierOp = new HatBarrierOp(outputOperands);\n-        Op.Result outputResult = blockBuilder.op(hatBarrierOp);\n-        Op.Result inputResult = invokeOp.result();\n-        hatBarrierOp.setLocation(invokeOp.location());\n-        context.mapValue(inputResult, outputResult);\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n-            System.out.println(\"[INFO] Code model before HatDialectifyBarrierPhase: \" + funcOp.toText());\n-        }\n-        Stream<CodeElement<?, ?>> elements = funcOp\n-                .elements()\n-                .mapMulti((element, consumer) -> {\n-                    if (element instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isMethodFromHatKernelContext(invokeOp) && isMethod(invokeOp, HatBarrierOp.INTRINSIC_NAME)) {\n-                            consumer.accept(invokeOp);\n-                        }\n-                    }\n-                });\n-        Set<CodeElement<?, ?>> collect = elements.collect(Collectors.toSet());\n-        if (collect.isEmpty()) {\n-            \/\/ Return the function with no modifications\n-            return funcOp;\n-        }\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!collect.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                createBarrierNodeOp(context, invokeOp, blockBuilder);\n-            }\n-            return blockBuilder;\n-        });\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n-            System.out.println(\"[INFO] Code model after HatDialectifyBarrierPhase: \" + funcOp.toText());\n-        }\n-        return funcOp;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyBarrierPhase.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import hat.dialect.HatLocalVarOp;\n-import hat.dialect.HatMemoryOp;\n-import hat.dialect.HatPrivateVarOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.ClassType;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HatDialectifyMemoryPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n-\n-    public enum Space {\n-        PRIVATE,\n-        SHARED,\n-    }\n-\n-    private final Space memorySpace;\n-    private final MethodHandles.Lookup lookup;\n-\n-    public HatDialectifyMemoryPhase(Space space, MethodHandles.Lookup lookup, Config config) {\n-        super(config);\n-        this.memorySpace = space;\n-        this.lookup = lookup;\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-            String nameNode = switch (memorySpace) {\n-                case PRIVATE -> HatPrivateVarOp.INTRINSIC_NAME;\n-                case SHARED -> HatLocalVarOp.INTRINSIC_NAME;\n-            };\n-\n-            if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n-                IO.println(\"[INFO] Code model before HatDialectifyMemoryPhase: \" + funcOp.toText());\n-            }\n-            Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                    .mapMulti((codeElement, consumer) -> {\n-                        if (codeElement instanceof CoreOp.VarOp varOp) {\n-                            List<Value> inputOperandsVarOp = varOp.operands();\n-                            for (Value inputOperand : inputOperandsVarOp) {\n-                                if (inputOperand instanceof Op.Result result) {\n-                                    if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                        if (OpTk.isIfaceBufferMethod(lookup, invokeOp) && isMethod(invokeOp, nameNode)) {\n-                                            \/\/ It is the node we are looking for\n-                                            consumer.accept(invokeOp);\n-                                            consumer.accept(varOp);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    });\n-\n-            Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-            if (nodesInvolved.isEmpty()) {\n-                \/\/ No memory nodes involved\n-                return funcOp;\n-            }\n-\n-            funcOp = funcOp.transform((blockBuilder, op) -> {\n-                CopyContext context = blockBuilder.context();\n-                if (!nodesInvolved.contains(op)) {\n-                    blockBuilder.op(op);\n-                } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                    \/\/ Don't insert the invoke node\n-                    Op.Result result = invokeOp.result();\n-                    List<Op.Result> collect = result.uses().stream().toList();\n-                    for (Op.Result r : collect) {\n-                        if (r.op() instanceof CoreOp.VarOp varOp) {\n-                            \/\/ That's the node we want\n-                            List<Value> inputOperandsVarOp = invokeOp.operands();\n-                            List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                            HatMemoryOp memoryOp = switch (memorySpace) {\n-                                case SHARED ->\n-                                        new HatLocalVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                                default ->\n-                                        new HatPrivateVarOp(varOp.varName(), (ClassType) varOp.varValueType(), varOp.resultType(), invokeOp.resultType(), outputOperandsVarOp);\n-                            };\n-\n-                            Op.Result hatLocalResult = blockBuilder.op(memoryOp);\n-\n-                            \/\/ update location\n-                            memoryOp.setLocation(varOp.location());\n-\n-                            context.mapValue(invokeOp.result(), hatLocalResult);\n-                        }\n-                    }\n-                } else if (op instanceof CoreOp.VarOp varOp) {\n-                    \/\/ pass value\n-                    context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n-                }\n-                return blockBuilder;\n-            });\n-            if (Config.SHOW_COMPILATION_PHASES.isSet(config)) {\n-                IO.println(\"[INFO] Code model after HatDialectifyMemoryPhase: \" + funcOp.toText());\n-            }\n-            return funcOp;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyMemoryPhase.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import hat.dialect.HatBlockThreadIdOp;\n-import hat.dialect.HatGlobalSizeOp;\n-import hat.dialect.HatGlobalThreadIdOp;\n-import hat.dialect.HatLocalSizeOp;\n-import hat.dialect.HatLocalThreadIdOp;\n-import hat.dialect.HatThreadOP;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HatDialectifyThreadsPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n-\n-    private final ThreadAccess threadAccess;\n-\n-    public HatDialectifyThreadsPhase(ThreadAccess threadAccess, Config config) {\n-        super(config);\n-        this.threadAccess =  threadAccess;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[INFO] Code model before HatDialectifyThreadsPhase: \" + funcOp.toText());\n-\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                        List<Value> operands = fieldLoadOp.operands();\n-                        for (Value inputOperand : operands) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                    boolean isThreadIntrinsic = switch (threadAccess) {\n-                                        case GLOBAL_ID -> isFieldLoadGlobalThreadId(fieldLoadOp);\n-                                        case GLOBAL_SIZE -> isFieldLoadGlobalSize(fieldLoadOp);\n-                                        case LOCAL_ID -> isFieldLoadThreadId(fieldLoadOp);\n-                                        case LOCAL_SIZE -> isFieldLoadThreadSize(fieldLoadOp);\n-                                        case BLOCK_ID ->  isFieldLoadBlockId(fieldLoadOp);\n-                                    };\n-                                    if (isMethodFromHatKernelContext(varLoadOp) && isThreadIntrinsic) {\n-                                        consumer.accept(fieldLoadOp);\n-                                        consumer.accept(varLoadOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = elements.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            \/\/ No memory nodes involved\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            } else if (op instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-                List<Value> operands = fieldLoadOp.operands();\n-                for (Value operand : operands) {\n-                    if (operand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> varLoadOperands = varLoadOp.operands();\n-                        List<Value> outputOperands = context.getValues(varLoadOperands);\n-                        int dim = getDimension(threadAccess, fieldLoadOp);\n-                        if (dim < 0) {\n-                            throw new IllegalStateException(\"Thread Access can't be below 0!\");\n-                        }\n-                        HatThreadOP threadOP = switch (threadAccess) {\n-                            case GLOBAL_ID -> new HatGlobalThreadIdOp(dim, fieldLoadOp.resultType());\n-                            case GLOBAL_SIZE -> new HatGlobalSizeOp(dim, fieldLoadOp.resultType());\n-                            case LOCAL_ID -> new HatLocalThreadIdOp(dim, fieldLoadOp.resultType());\n-                            case LOCAL_SIZE -> new HatLocalSizeOp(dim, fieldLoadOp.resultType());\n-                            case BLOCK_ID -> new HatBlockThreadIdOp(dim, fieldLoadOp.resultType());\n-                        };\n-                        Op.Result threadResult = blockBuilder.op(threadOP);\n-\n-                        \/\/ update location\n-                        threadOP.setLocation(fieldLoadOp.location());\n-\n-                        context.mapValue(fieldLoadOp.result(), threadResult);\n-                    }\n-                }\n-            }\n-            return blockBuilder;\n-        });\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[INFO] Code model after HatDialectifyThreadsPhase: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-\n-    public enum ThreadAccess {\n-        GLOBAL_ID,\n-        GLOBAL_SIZE,\n-        LOCAL_ID,\n-        LOCAL_SIZE,\n-        BLOCK_ID,\n-    }\n-\n-    private int getDimension(ThreadAccess threadAccess, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        String fieldName = fieldLoadOp.fieldDescriptor().name();\n-        switch (threadAccess) {\n-            case GLOBAL_ID -> {\n-                if (fieldName.equals(\"y\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"z\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case GLOBAL_SIZE -> {\n-                if (fieldName.equals(\"gsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"gsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case LOCAL_ID -> {\n-                if (fieldName.equals(\"liy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lyz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case LOCAL_SIZE -> {\n-                if (fieldName.equals(\"lsy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"lsz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-            case BLOCK_ID ->  {\n-                if (fieldName.equals(\"biy\")) {\n-                    return 1;\n-                } else if (fieldName.equals(\"biz\")) {\n-                    return 2;\n-                }\n-                return 0;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-\n-    private boolean isFieldLoadGlobalThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"x\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"y\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"z\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"giy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"giz\");\n-    }\n-\n-    private boolean isFieldLoadGlobalSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"gsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"gsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"gsz\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxX\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"maxY\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"maxZ\");\n-    }\n-\n-    private boolean isFieldLoadThreadId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"liy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"liz\");\n-    }\n-\n-    private boolean isFieldLoadThreadSize(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"lsx\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"lsy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"lsz\");\n-    }\n-\n-    private boolean isFieldLoadBlockId(JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n-        return fieldLoadOp.fieldDescriptor().name().equals(\"bix\")\n-                || fieldLoadOp.fieldDescriptor().name().equals(\"biy\")\n-                ||  fieldLoadOp.fieldDescriptor().name().equals(\"biz\");\n-    }\n-\n-    private boolean isMethodFromHatKernelContext(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\n-        return varLoadOp.resultType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyThreadsPhase.java","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-import java.util.concurrent.BlockingQueue;\n-\n-public class HatDialectifyTier implements HatCompilationTier {\n-\n-    List<HatDialectifyPhase> hatPhases = new ArrayList<>();\n-\n-    public HatDialectifyTier(MethodHandles.Lookup lookup) {\n-        Config config = Config.fromEnvOrProperty();\n-        hatPhases.add(new HatDialectifyBarrierPhase(config));\n-        Arrays.stream(HatDialectifyMemoryPhase.Space.values())\n-                .forEach(space -> hatPhases.add(new HatDialectifyMemoryPhase(space, lookup, config)));\n-        Arrays.stream(HatDialectifyThreadsPhase.ThreadAccess.values())\n-                .forEach(threadAccess -> hatPhases.add(new HatDialectifyThreadsPhase(threadAccess, config)));\n-        Arrays.stream(HatDialectifyVectorOpPhase.OpView.values())\n-                .forEach(vectorOperation -> hatPhases.add(new HatDialectifyVectorOpPhase(lookup, vectorOperation, config)));\n-        Arrays.stream(HatDialectifyVectorStorePhase.StoreView.values())\n-                .forEach(vectorOperation -> hatPhases.add(new HatDialectifyVectorStorePhase(lookup, vectorOperation, config)));\n-        hatPhases.add(new HatDialectifyVSelectPhase(lookup, config));\n-    }\n-\n-    \/\/ It computes a set of function code model transformations from FuncOp to FuncOp'.\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        BlockingQueue<HatDialectifyPhase> queue = new ArrayBlockingQueue<>(hatPhases.size());\n-        queue.addAll(hatPhases);\n-        CoreOp.FuncOp f = funcOp;\n-        while (!queue.isEmpty()) {\n-            HatDialectifyPhase phase;\n-            try {\n-                phase = queue.take();\n-                f = phase.run(f);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-        return f;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyTier.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,247 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorViewOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-import jdk.incubator.code.dialect.java.JavaType;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HatDialectifyVSelectPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n-\n-    private final MethodHandles.Lookup lookup;\n-\n-    public HatDialectifyVSelectPhase(MethodHandles.Lookup lookup, Config config) {\n-        super(config);\n-        this.lookup = lookup;\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private boolean isVectorLane(JavaOp.InvokeOp invokeOp) {\n-        return isMethod(invokeOp, \"x\")\n-                || isMethod(invokeOp, \"y\")\n-                || isMethod(invokeOp, \"z\")\n-                || isMethod(invokeOp, \"w\");\n-    }\n-\n-    int getLane(String fieldName) {\n-        return switch (fieldName) {\n-            case \"x\" -> 0;\n-            case \"y\" -> 1;\n-            case \"z\" -> 2;\n-            case \"w\" -> 3;\n-            default -> -1;\n-        };\n-    }\n-\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n-        String invokeClass = invokeOp.invokeDescriptor().refType().toString();\n-        boolean isHatVectorType = invokeClass.startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && OpTk.isIfaceBufferMethod(lookup, invokeOp)\n-                && (isVectorLane(invokeOp));\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n-    private String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HatVectorViewOp vectorViewOp) {\n-                return vectorViewOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    private CoreOp.VarOp findVarOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVarOp(varLoadOp.operands().get(0));\n-    }\n-\n-    private CoreOp.VarOp findVarOp(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findVarOp(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                return varOp;\n-            }\n-            return null;\n-        }\n-    }\n-\n-\n-    \/\/ Code Model Pattern:\n-    \/\/  %16 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"63:28\";\n-    \/\/  %17 : java.type:\"float\" = invoke %16 @loc=\"63:28\" @java.ref:\"hat.buffer.Float4::x():float\";\n-    private CoreOp.FuncOp vloadSelectPhase(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[BEFORE] VSelect Load Transform: \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp) && invokeOp.resultType() != JavaType.VOID) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            Value inputOperand = inputOperandsInvoke.getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                for (Value v : inputInvokeOp) {\n-                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                        List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                        int lane = getLane(invokeOp.invokeDescriptor().name());\n-                        HatVectorViewOp vSelectOp;\n-                        String name = findNameVector(varLoadOp);\n-                        if (invokeOp.resultType() != JavaType.VOID) {\n-                            vSelectOp = new HatVSelectLoadOp(name, invokeOp.resultType(), lane, outputOperandsInvokeOp);\n-                        } else {\n-                            throw new RuntimeException(\"VSelect Load Op must return a value!\");\n-                        }\n-                        Op.Result hatSelectResult = blockBuilder.op(vSelectOp);\n-                        vSelectOp.setLocation(invokeOp.location());\n-                        context.mapValue(invokeOp.result(), hatSelectResult);\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ Pass the value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[After] VSelect Load Transform: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-\n-    \/\/ Pattern from the code mode:\n-    \/\/ %20 : java.type:\"hat.buffer.Float4\" = var.load %15 @loc=\"64:13\";\n-    \/\/ %21 : java.type:\"float\" = var.load %19 @loc=\"64:18\";\n-    \/\/ invoke %20 %21 @loc=\"64:13\" @java.ref:\"hat.buffer.Float4::x(float):void\";\n-    private CoreOp.FuncOp vstoreSelectPhase(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[BEFORE] VSelect Store Transform \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            Value inputOperand = inputOperandsInvoke.getFirst();\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(invokeOp);\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputInvokeOp = invokeOp.operands();\n-                Value v = inputInvokeOp.getFirst();\n-\n-                if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                    List<Value> outputOperandsInvokeOp = context.getValues(inputInvokeOp);\n-                    int lane = getLane(invokeOp.invokeDescriptor().name());\n-                    HatVectorViewOp vSelectOp;\n-                    String name = findNameVector(varLoadOp);\n-                    if (invokeOp.resultType() == JavaType.VOID) {\n-                        \/\/ The operand 1 in the store is the address (lane)\n-                        \/\/ The operand 1 in the store is the storeValue\n-                        CoreOp.VarOp resultOp = findVarOp(outputOperandsInvokeOp.get(1));\n-                        vSelectOp = new HatVSelectStoreOp(name, invokeOp.resultType(), lane, resultOp, outputOperandsInvokeOp);\n-                    } else {\n-                        throw new RuntimeException(\"VSelect Store Op must return a value!\");\n-                    }\n-                    Op.Result resultVStore = blockBuilder.op(vSelectOp);\n-                    vSelectOp.setLocation(invokeOp.location());\n-                    context.mapValue(invokeOp.result(), resultVStore);\n-                }\n-\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ Pass the value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[AFTER] VSelect Store Transform: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        funcOp = vloadSelectPhase(funcOp);\n-        funcOp = vstoreSelectPhase(funcOp);\n-        return funcOp;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyVSelectPhase.java","additions":0,"deletions":247,"binary":false,"changes":247,"status":"deleted"},{"patch":"@@ -1,341 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import hat.dialect.HatLocalVarOp;\n-import hat.dialect.HatPrivateVarOp;\n-import hat.dialect.HatVectorAddOp;\n-import hat.dialect.HatVectorDivOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorMulOp;\n-import hat.dialect.HatVectorSubOp;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n-import hat.dialect.HatVectorViewOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HatDialectifyVectorOpPhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n-\n-    MethodHandles.Lookup lookup;\n-    private final OpView vectorOperation;\n-\n-    public HatDialectifyVectorOpPhase(MethodHandles.Lookup lookup, OpView vectorOperation, Config config) {\n-        super(config);\n-        this.lookup = lookup;\n-        this.vectorOperation = vectorOperation;\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    private HatVectorBinaryOp.OpType getBinaryOpType(JavaOp.InvokeOp invokeOp) {\n-        return switch (invokeOp.invokeDescriptor().name()) {\n-            case \"add\" -> HatVectorBinaryOp.OpType.ADD;\n-            case \"sub\" -> HatVectorBinaryOp.OpType.SUB;\n-            case \"mul\" -> HatVectorBinaryOp.OpType.MUL;\n-            case \"div\" -> HatVectorBinaryOp.OpType.DIV;\n-            default -> throw new RuntimeException(\"Unknown binary op \" + invokeOp.invokeDescriptor().name());\n-        };\n-    }\n-\n-    public enum OpView {\n-        FLOAT4_LOAD(\"float4View\"),\n-        ADD(\"add\"),\n-        SUB(\"sub\"),\n-        MUL(\"mul\"),\n-        DIV(\"div\");\n-        final String methodName;\n-        OpView(String methodName) {\n-            this.methodName = methodName;\n-        }\n-    }\n-\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n-        TypeElement typeElement = invokeOp.resultType();\n-        boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n-        return isHatVectorType\n-                && OpTk.isIfaceBufferMethod(lookup, invokeOp)\n-                && isMethod(invokeOp, vectorOperation.methodName);\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n-    private String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HatVectorViewOp hatVectorViewOp) {\n-                return hatVectorViewOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    private boolean findIsSharedOrPrivate(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findIsSharedOrPrivate(varLoadOp.operands().get(0));\n-    }\n-\n-    private boolean findIsSharedOrPrivate(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findIsSharedOrPrivate(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && (r.op() instanceof HatLocalVarOp || r.op() instanceof HatPrivateVarOp)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private HatVectorBinaryOp buildVectorBinaryOp(HatVectorBinaryOp.OpType opType, String varName, TypeElement resultType, List<Value> outputOperands) {\n-        return switch (opType) {\n-            case ADD -> new HatVectorAddOp(varName, resultType, outputOperands);\n-            case SUB -> new HatVectorSubOp(varName, resultType, outputOperands);\n-            case MUL -> new HatVectorMulOp(varName, resultType, outputOperands);\n-            case DIV -> new HatVectorDivOp(varName, resultType, outputOperands);\n-        };\n-    }\n-\n-    private CoreOp.FuncOp dialectifyVectorLoad(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[BEFORE] Vector Load Ops: \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (isVectorOperation(invokeOp)) {\n-                                        consumer.accept(invokeOp);\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node\n-                Op.Result result = invokeOp.result();\n-                List<Op.Result> collect = result.uses().stream().toList();\n-                boolean isShared = findIsSharedOrPrivate(invokeOp.operands().getFirst());\n-                for (Op.Result r : collect) {\n-                    if (r.op() instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = invokeOp.operands();\n-                        List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                        HatVectorViewOp memoryViewOp = new HatVectorLoadOp(varOp.varName(), varOp.resultType(), invokeOp.resultType(), 4, isShared, outputOperandsVarOp);\n-                        Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                        memoryViewOp.setLocation(varOp.location());\n-                        context.mapValue(invokeOp.result(), hatLocalResult);\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarOp varOp) {\n-                \/\/ pass value\n-                \/\/context.mapValue(varOp.result(), context.getValue(varOp.operands().getFirst()));\n-                List<Value> inputOperandsVarOp = varOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HatVectorViewOp memoryViewOp = new HatVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatLocalResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), hatLocalResult);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[AFTER] Vector Load Ops: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-\n-    private CoreOp.FuncOp dialectifyVectorBinaryOps(CoreOp.FuncOp funcOp) {\n-        Map<JavaOp.InvokeOp, HatVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[BEFORE] Vector Binary Ops: \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof CoreOp.VarOp varOp) {\n-                        List<Value> inputOperandsVarOp = varOp.operands();\n-                        for (Value inputOperand : inputOperandsVarOp) {\n-                            if (inputOperand instanceof Op.Result result) {\n-                                if (result.op() instanceof JavaOp.InvokeOp invokeOp) {\n-                                    if (isVectorOperation(invokeOp)) {\n-                                        HatVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n-                                        binaryOperation.put(invokeOp, binaryOpType);\n-                                        consumer.accept(invokeOp);\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                Op.Result result = invokeOp.result();\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = context.getValues(inputOperands);\n-                List<Op.Result> collect = result.uses().stream().toList();\n-                for (Op.Result r : collect) {\n-                    if (r.op() instanceof CoreOp.VarOp varOp) {\n-                        HatVectorBinaryOp.OpType binaryOpType = binaryOperation.get(invokeOp);\n-                        HatVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOpType, varOp.varName(), invokeOp.resultType(), outputOperands);\n-                        Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n-                        memoryViewOp.setLocation(varOp.location());\n-                        context.mapValue(invokeOp.result(), hatVectorOpResult);\n-                        break;\n-                    }\n-                }\n-            } else if (op instanceof CoreOp.VarOp varOp) {\n-                List<Value> inputOperandsVarOp = varOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                HatVectorViewOp memoryViewOp = new HatVectorVarOp(varOp.varName(), varOp.resultType(), 4, outputOperandsVarOp);\n-                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varOp.location());\n-                context.mapValue(varOp.result(), hatVectorResult);\n-            }\n-            return blockBuilder;\n-        });\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-\n-    private CoreOp.FuncOp dialectifyVectorBinaryWithContatenationOps(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[BEFORE] Vector Contact Binary Ops: \" + funcOp.toText());\n-\n-        Map<JavaOp.InvokeOp, HatVectorBinaryOp.OpType> binaryOperation = new HashMap<>();\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if (isVectorOperation(invokeOp)) {\n-                            List<Value> inputOperandsInvoke = invokeOp.operands();\n-                            for (Value inputOperand : inputOperandsInvoke) {\n-                                if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                    HatVectorBinaryOp.OpType binaryOpType = getBinaryOpType(invokeOp);\n-                                    binaryOperation.put(invokeOp, binaryOpType);\n-                                    consumer.accept(varLoadOp);\n-                                    consumer.accept(invokeOp);\n-                                }\n-                            }\n-                        }\n-                    } else if (codeElement instanceof HatVectorBinaryOp hatVectorBinaryOp) {\n-                        List<Value> inputOperandsInvoke = hatVectorBinaryOp.operands();\n-                        for (Value inputOperand : inputOperandsInvoke) {\n-                            if (inputOperand instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                                consumer.accept(varLoadOp);\n-                            }\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                List<Value> inputOperands = invokeOp.operands();\n-                List<Value> outputOperands = context.getValues(inputOperands);\n-                HatVectorViewOp memoryViewOp = buildVectorBinaryOp(binaryOperation.get(invokeOp), \"null\", invokeOp.resultType(), outputOperands);\n-                Op.Result hatVectorOpResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), hatVectorOpResult);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                List<Value> inputOperandsVarLoad = varLoadOp.operands();\n-                List<Value> outputOperandsVarLoad = context.getValues(inputOperandsVarLoad);\n-                String varLoadName = findNameVector(varLoadOp);\n-                HatVectorViewOp memoryViewOp = new HatVectorVarLoadOp(varLoadName, varLoadOp.resultType(), outputOperandsVarLoad);\n-                Op.Result hatVectorResult = blockBuilder.op(memoryViewOp);\n-                memoryViewOp.setLocation(varLoadOp.location());\n-                context.mapValue(varLoadOp.result(), hatVectorResult);\n-            }\n-            return blockBuilder;\n-        });\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[AFTER] Vector Binary Ops: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (Objects.requireNonNull(vectorOperation) == OpView.FLOAT4_LOAD) {\n-            funcOp = dialectifyVectorLoad(funcOp);\n-        } else {\n-            \/\/ Find binary operations\n-            funcOp = dialectifyVectorBinaryOps(funcOp);\n-            funcOp = dialectifyVectorBinaryWithContatenationOps(funcOp);\n-        }\n-        return funcOp;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyVectorOpPhase.java","additions":0,"deletions":341,"binary":false,"changes":341,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.phases;\n-\n-import hat.Config;\n-import hat.dialect.HatLocalVarOp;\n-import hat.dialect.HatPrivateVarOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatVectorViewOp;\n-import hat.optools.OpTk;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.CopyContext;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n-import jdk.incubator.code.dialect.java.JavaOp;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HatDialectifyVectorStorePhase extends HatDialectAbstractPhase implements HatDialectifyPhase {\n-\n-    MethodHandles.Lookup lookup;\n-    private final StoreView vectorOperation;\n-\n-    public HatDialectifyVectorStorePhase(MethodHandles.Lookup lookup, StoreView vectorOperation, Config config) {\n-        super(config);\n-        this.lookup = lookup;\n-        this.vectorOperation = vectorOperation;\n-    }\n-\n-    private boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    public enum StoreView {\n-        FLOAT4_STORE(\"storeFloat4View\");\n-\n-        final String methodName;\n-        StoreView(String methodName) {\n-            this.methodName = methodName;\n-        }\n-    }\n-\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue) {\n-        if (varValue instanceof Op.Result r\n-                && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            boolean isHatVectorType = typeElement.toString().startsWith(\"hat.buffer.Float\");\n-            return isHatVectorType\n-                    && OpTk.isIfaceBufferMethod(lookup, invokeOp)\n-                    && isMethod(invokeOp, vectorOperation.methodName);\n-        }\n-        return false;\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n-    private String findNameVector(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findNameVector(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HatVectorViewOp hatVectorViewOp) {\n-                return hatVectorViewOp.varName();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    private boolean findIsSharedOrPrivateSpace(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findIsSharedOrPrivateSpace(varLoadOp.operands().get(0));\n-    }\n-\n-    private boolean findIsSharedOrPrivateSpace(Value v) {\n-        if (v instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            return findIsSharedOrPrivateSpace(varLoadOp);\n-        } else {\n-            \/\/ Leaf of tree -\n-            if (v instanceof CoreOp.Result r && (r.op() instanceof HatLocalVarOp || r.op() instanceof HatPrivateVarOp)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    @Override\n-    public CoreOp.FuncOp run(CoreOp.FuncOp funcOp) {\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[BEFORE] Vector Types STORE Transform: \" + funcOp.toText());\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = funcOp.elements()\n-                .mapMulti((codeElement, consumer) -> {\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if ((invokeOp.operands().size() >= 3)\n-                                && (isVectorOperation(invokeOp, invokeOp.operands().get(1)))) {\n-                            consumer.accept(invokeOp);\n-                        }\n-                    }\n-                });\n-\n-        Set<CodeElement<?, ?>> nodesInvolved = float4NodesInvolved.collect(Collectors.toSet());\n-        if (nodesInvolved.isEmpty()) {\n-            return funcOp;\n-        }\n-\n-        funcOp = funcOp.transform((blockBuilder, op) -> {\n-            CopyContext context = blockBuilder.context();\n-            if (!nodesInvolved.contains(op)) {\n-                blockBuilder.op(op);\n-            } else if (op instanceof JavaOp.InvokeOp invokeOp) {\n-                \/\/ Don't insert the invoke node\n-                List<Value> inputOperandsVarOp = invokeOp.operands();\n-                List<Value> outputOperandsVarOp = context.getValues(inputOperandsVarOp);\n-                \/\/ Find the name of the vector view variable\n-                Value v = invokeOp.operands().get(1);\n-                String name = findNameVector(v);\n-                boolean isSharedOrPrivate = findIsSharedOrPrivateSpace(invokeOp.operands().get(0));\n-\n-                HatVectorViewOp storeView = switch (vectorOperation) {\n-                    case FLOAT4_STORE -> new HatVectorStoreView(name, invokeOp.resultType(), 4, HatVectorViewOp.VectorType.FLOAT4, isSharedOrPrivate,  outputOperandsVarOp);\n-                };\n-                Op.Result hatLocalResult = blockBuilder.op(storeView);\n-                storeView.setLocation(invokeOp.location());\n-                context.mapValue(invokeOp.result(), hatLocalResult);\n-            } else if (op instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-                \/\/ pass value\n-                context.mapValue(varLoadOp.result(), context.getValue(varLoadOp.operands().getFirst()));\n-            }\n-            return blockBuilder;\n-        });\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(config))\n-            IO.println(\"[AFTER] Vector Types STORE Transform: \" + funcOp.toText());\n-        return funcOp;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HatDialectifyVectorStorePhase.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import hat.optools.OpTk;\n@@ -78,1 +80,2 @@\n-        var transformed = funcOp.transform((builder, op) -> {\n+        var here = OpTk.CallSite.of(DNA.class, \"main\");\n+        var transformed = OpTk.transform(here, funcOp,(builder, op) -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/DNA.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+\n+import hat.optools.OpTk;\n@@ -114,1 +116,2 @@\n-        f = SSA.transform(f);\n+        var here = OpTk.CallSite.of(LayoutExample.class, \"main\");\n+        f = OpTk.SSATransform(here, f);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.annotations.Kernel;\n@@ -38,0 +39,1 @@\n+import javax.print.DocFlavor;\n@@ -39,0 +41,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -47,0 +51,1 @@\n+\n@@ -48,0 +53,1 @@\n+    private static final int GROUP_SIZE = 32;\n@@ -53,1 +59,1 @@\n-        Schema<SharedS32x256Array> schema = Schema.of(SharedS32x256Array.class, $ -> $.array(\"array\", 256));\n+        Schema<SharedS32x256Array> schema = Schema.of(SharedS32x256Array.class, $ -> $.array(\"array\", 32));\n@@ -56,1 +62,1 @@\n-            return schema.allocate(accelerator);\n+            return schema.allocate(accelerator); \/\/ Why would we get here?\n@@ -60,1 +66,1 @@\n-            return schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST));\n+            return null;\/\/schema.allocate(new Accelerator(MethodHandles.lookup(), Backend.FIRST)); \/\/\/ This is crazy? why\n@@ -202,1 +208,38 @@\n-    @CodeReflection\n+    @CodeReflection @Kernel(\"\"\"\n+                    HAT_KERNEL void crossGroupScan(\n+                        HAT_GLOBAL_MEM KernelContext_t* kc,\n+                        HAT_GLOBAL_MEM S32Array_t* dataBuf\n+                    ){\n+                        HAT_LOCAL_MEM SharedS32x256Array_t scratchBuf;\n+                        const int gid = HAT_GIX*HAT_GSX-1;\n+                        scratchBuf.array[(long)HAT_LIX]=gid>0?dataBuf->array[(long)gid]:0;\n+                        HAT_BARRIER;\n+                        for(int step = 2; step<=HAT_GSX; step=step<<1){\n+                            if((HAT_LIX+1)%step==0){\n+                                scratchBuf.array[(long)HAT_LIX]=scratchBuf.array[(long)HAT_LIX]+scratchBuf.array[(long)(HAT_LIX-(step>>1))];\n+                            }\n+                            HAT_BARRIER;\n+                        }\n+                        int sum = 0;\n+                        if(HAT_LIX+1==HAT_GSX){\n+                            sum=scratchBuf.array[(long)HAT_LIX];\n+                            scratchBuf.array[(long)HAT_LIX]=0;\n+                        }\n+                        HAT_BARRIER;\n+                        for(int step = HAT_GSX; step>1; step=step>>1){\n+                            if((HAT_LIX+1)%step==0){\n+                                const int swap = scratchBuf.array[(long)(HAT_LIX-(step>>1))];\n+                                scratchBuf.array[(long)(HAT_LIX-(step>>1))]=scratchBuf.array[(long)HAT_LIX];\n+                                scratchBuf.array[(long)HAT_LIX]=scratchBuf.array[(long)HAT_LIX]+swap;\n+                            }\n+                            HAT_BARRIER;\n+                        }\n+                        if(HAT_LIX+1==HAT_GSX){\n+                            dataBuf->array[(long)gid]=sum;\n+                        }else if(gid>0){\n+                            dataBuf->array[(long)gid]=scratchBuf.array[(long)(HAT_LIX+1)];\n+                        }\n+                        HAT_BARRIER;\n+                        return;\n+                    }\n+            \"\"\")\n@@ -262,0 +305,22 @@\n+    static String view(int[] data){\n+        StringBuilder sb = new StringBuilder();\n+        for (int i=0;i<data.length;i++){\n+            sb.append(String.format(\"%02d \",data[i]));\n+            if (i%GROUP_SIZE==0 && i>0){\n+                sb.append('|');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+     static String view(S32Array data){\n+        StringBuilder sb = new StringBuilder();\n+        for (int i=0;i<data.length();i++){\n+            sb.append(String.format(\"%02d \",data.array(i)));\n+            if (i%GROUP_SIZE==0 && i>0){\n+                sb.append('|');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n@@ -264,1 +329,0 @@\n-    private static final int GROUP_SIZE = 256;\n@@ -268,0 +332,11 @@\n+        List<String> results = new ArrayList<>();\n+        int[] ref = new int[data.length()];\n+        int[] seq = new int[data.length()];\n+        int sum =0;\n+        for (int i=0;i<data.length();i++){\n+            ref[i]=data.array(i);\n+            sum+=ref[i];\n+            seq[i] = sum;\n+        }\n+        results.add(view(ref));\n+        results.add(view(data));\n@@ -269,5 +344,13 @@\n-\n-        int groupCount = data.length() \/ GROUP_SIZE;\n-        int log2 = 1;\n-        while (log2 < groupCount) {\n-            log2 <<= 1;\n+        results.add(view(data));\n+        cc.dispatchKernel(GROUP_SIZE, kc -> crossGroupScan(kc, data));\n+        results.add(view(data));\n+        cc.dispatchKernel(GROUP_SIZE, kc -> sumKernel(kc, data));\n+      \/\/  results.add(view(data));\n+        results.add(view(seq));\n+        boolean brokenBytecodeGen = true;\n+        if (brokenBytecodeGen){\n+            for (var r:results){\n+                System.out.println(r.substring(0, 120));\n+            }\n+        }else {\n+            results.forEach(r -> System.out.println(r.substring(0, 120)));\n@@ -275,3 +358,0 @@\n-        cc.dispatchKernel(data.length(), kc -> crossGroupScan(kc, data));\n-        cc.dispatchKernel(data.length(), kc -> sumKernel(kc, data));\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PrefixSum.java","additions":93,"deletions":13,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+import hat.optools.OpTk;\n@@ -125,1 +127,2 @@\n-        m = SSA.transform(m);\n+        var here = OpTk.CallSite.of(RawLayout.class, \"main\");\n+        m = OpTk.SSATransform(here, m);\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+\n+import hat.optools.OpTk;\n@@ -136,1 +138,2 @@\n-            CoreOp.FuncOp transformed = javaFunc.transform((builder, op) -> {\n+            var here = OpTk.CallSite.of(Transform.class, \"main\");\n+            CoreOp.FuncOp transformed = OpTk.transform(here, javaFunc,(builder, op) -> {\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Transform.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,12 +29,12 @@\n-import hat.dialect.HatBlockThreadIdOp;\n-import hat.dialect.HatVSelectLoadOp;\n-import hat.dialect.HatVSelectStoreOp;\n-import hat.dialect.HatVectorBinaryOp;\n-import hat.dialect.HatVectorLoadOp;\n-import hat.dialect.HatVectorStoreView;\n-import hat.dialect.HatGlobalThreadIdOp;\n-import hat.dialect.HatGlobalSizeOp;\n-import hat.dialect.HatLocalSizeOp;\n-import hat.dialect.HatLocalThreadIdOp;\n-import hat.dialect.HatVectorVarLoadOp;\n-import hat.dialect.HatVectorVarOp;\n+import hat.dialect.HATBlockThreadIdOp;\n+import hat.dialect.HATVSelectLoadOp;\n+import hat.dialect.HATVSelectStoreOp;\n+import hat.dialect.HATVectorBinaryOp;\n+import hat.dialect.HATVectorLoadOp;\n+import hat.dialect.HATVectorStoreView;\n+import hat.dialect.HATGlobalThreadIdOp;\n+import hat.dialect.HATGlobalSizeOp;\n+import hat.dialect.HATLocalSizeOp;\n+import hat.dialect.HATLocalThreadIdOp;\n+import hat.dialect.HATVectorVarLoadOp;\n+import hat.dialect.HATVectorVarOp;\n@@ -107,1 +107,1 @@\n-    public T generateVectorStore(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+    public T generateVectorStore(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -113,1 +113,1 @@\n-    public T generateVectorBinary(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+    public T generateVectorBinary(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -119,1 +119,1 @@\n-    public T generateVectorLoad(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+    public T generateVectorLoad(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -125,1 +125,1 @@\n-    public T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+    public T generateVectorSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n@@ -131,1 +131,1 @@\n-    public T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+    public T generateVectorSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n@@ -137,1 +137,1 @@\n-    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HatGlobalThreadIdOp globalThreadIdOp) {\n+    public T hatGlobalThreadOp(ScopedCodeBuilderContext buildContext, HATGlobalThreadIdOp globalThreadIdOp) {\n@@ -143,1 +143,1 @@\n-    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HatGlobalSizeOp hatGlobalThreadIdOp) {\n+    public T hatGlobalSizeOp(ScopedCodeBuilderContext buildContext, HATGlobalSizeOp hatGlobalThreadIdOp) {\n@@ -149,1 +149,1 @@\n-    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HatLocalThreadIdOp hatLocalThreadIdOp) {\n+    public T hatLocalThreadIdOp(ScopedCodeBuilderContext buildContext, HATLocalThreadIdOp hatLocalThreadIdOp) {\n@@ -155,1 +155,1 @@\n-    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HatLocalSizeOp hatLocalSizeOp) {\n+    public T hatLocalSizeOp(ScopedCodeBuilderContext buildContext, HATLocalSizeOp hatLocalSizeOp) {\n@@ -161,1 +161,1 @@\n-    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HatBlockThreadIdOp hatBlockThreadIdOp) {\n+    public T hatBlockThreadIdOp(ScopedCodeBuilderContext buildContext, HATBlockThreadIdOp hatBlockThreadIdOp) {\n@@ -167,1 +167,1 @@\n-    public T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HatVectorVarOp hatVectorVarOp) {\n+    public T hatVectorVarOp(ScopedCodeBuilderContext buildContext, HATVectorVarOp hatVectorVarOp) {\n@@ -173,1 +173,1 @@\n-    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HatVectorStoreView hatVectorStoreView) {\n+    public T hatVectorStoreOp(ScopedCodeBuilderContext buildContext, HATVectorStoreView hatVectorStoreView) {\n@@ -179,1 +179,1 @@\n-    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HatVectorBinaryOp hatVectorBinaryOp) {\n+    public T hatBinaryVectorOp(ScopedCodeBuilderContext buildContext, HATVectorBinaryOp hatVectorBinaryOp) {\n@@ -185,1 +185,1 @@\n-    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HatVectorLoadOp hatVectorLoadOp) {\n+    public T hatVectorLoadOp(ScopedCodeBuilderContext buildContext, HATVectorLoadOp hatVectorLoadOp) {\n@@ -191,1 +191,1 @@\n-    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HatVSelectLoadOp hatVSelectLoadOp) {\n+    public T hatSelectLoadOp(ScopedCodeBuilderContext buildContext, HATVSelectLoadOp hatVSelectLoadOp) {\n@@ -197,1 +197,1 @@\n-    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HatVSelectStoreOp hatVSelectStoreOp) {\n+    public T hatSelectStoreOp(ScopedCodeBuilderContext buildContext, HATVSelectStoreOp hatVSelectStoreOp) {\n@@ -203,1 +203,1 @@\n-    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HatVectorVarLoadOp hatVectorVarLoadOp) {\n+    public T hatVectorVarLoadOp(ScopedCodeBuilderContext buildContext, HATVectorVarLoadOp hatVectorVarLoadOp) {\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"}]}