{"files":[{"patch":"@@ -587,25 +587,2 @@\n-        } else if (o instanceof CoreOp.IfExp e) {\n-            var testResult = (boolean) oc.getValue(e.getTest());\n-            if (testResult) {\n-                throw new UnsupportedOperationException();\n-                \/\/return interpretBody(l, e.thenBody(), oc);\n-            } else {\n-                throw new UnsupportedOperationException();\n-                \/\/return interpretBody(l, e.elseBody(), oc);\n-            }\n-        } else if (o instanceof CoreOp.LetExp e) {\n-           \/\/List<Object> evaluatedBindings = e.letBindings.stream().map(b -> interpretBody(l,b,oc)).toList();\n-           \/\/Body exprBody = e.letExp;\n-           \/\/return invoke(l, exprBody.entryBlock(), Map.of(), oc, evaluatedBindings);\n-           return null;\n-        } else if (o instanceof CoreOp.LetRecExp e) {\n-           List<Object> functionBindings = e.functions.stream().map(Object.class::cast).toList();\n-           Op exprBody = e.expBody;\n-           \/\/return invoke(l, exprBody.entryBlock(), Map.of(), oc, functionBindings);\n-           return null;\n-        } else if (o instanceof CoreOp.FunApp e) {\n-            var funOp = (CoreOp.FuncOp) oc.getValue(e.funOp());\n-            var funCallOp = CoreOp.funcCall(funOp,e.args());\n-            return exec(l,oc,funCallOp);\n-        }\n-        else {\n+\n+        } else {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static java.lang.reflect.code.op.OpFactory.*;\n+\n+public final class AnfDialect {\n+\n+    private AnfDialect() {\n+    }\n+\n+    @OpDeclaration(AnfLetOp.NAME)\n+    public static final class AnfLetOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+        public static final String NAME = \"anf.let\";\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement yieldType;\n+\n+            Builder(Body.Builder ancestorBody, TypeElement yieldType) {\n+                this.ancestorBody = ancestorBody;\n+                this.yieldType = yieldType;\n+            }\n+\n+            public AnfLetOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(yieldType));\n+                c.accept(body.entryBlock());\n+                return new AnfLetOp(body);\n+            }\n+        }\n+\n+        \/\/ Terminating operation is the in expression that yields the result for this operation\n+        \/\/ Any operation result in the entry block used by the terminating operation\n+        \/\/ or a descendant operation is a let binding\n+        final Body bindings;\n+\n+        public AnfLetOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.bindings = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        public AnfLetOp(AnfLetOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bindings = that.bindings.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfLetOp(this, cc, ot);\n+        }\n+\n+        public AnfLetOp(Body.Builder bodyBuilder) {\n+            super(NAME, List.of());\n+\n+            this.bindings = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(bindings);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.bindings.yieldType();\n+        }\n+    }\n+\n+\n+    @OpDeclaration(AnfLetRecOp.NAME)\n+    public static final class AnfLetRecOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+        public static final String NAME = \"anf.letrec\";\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement yieldType;\n+\n+            Builder(Body.Builder ancestorBody, TypeElement yieldType) {\n+                this.ancestorBody = ancestorBody;\n+                this.yieldType = yieldType;\n+            }\n+\n+            public AnfLetRecOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(yieldType));\n+                c.accept(body.entryBlock());\n+                return new AnfLetRecOp(body);\n+            }\n+        }\n+\n+        \/\/ Terminating operation is the in expression that yields the result for this operation\n+        \/\/ Any operation result in the entry block used by the terminating operation\n+        \/\/ or a descendant operation is a letrec binding\n+        final Body bindings;\n+\n+        public AnfLetRecOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.bindings = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        public AnfLetRecOp(AnfLetRecOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bindings = that.bindings.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfLetRecOp(this, cc, ot);\n+        }\n+\n+        public AnfLetRecOp(Body.Builder bodyBuilder) {\n+            super(AnfLetRecOp.NAME, List.of());\n+\n+            this.bindings = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(bindings);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.bindings.yieldType();\n+        }\n+\n+        public List<CoreOp.FuncOp> funcOps() {\n+            List<Op> ops = bindings.entryBlock().ops();\n+            return ops.subList(0, ops.size() - 1).stream()\n+                    .<CoreOp.FuncOp>mapMulti((op, objectConsumer) -> {\n+                        if (op instanceof CoreOp.FuncOp fop) {\n+                            objectConsumer.accept(fop);\n+                        }\n+                    }).toList();\n+        }\n+    }\n+\n+    @OpDeclaration(AnfIfOp.NAME)\n+    public static final class AnfIfOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+        public static final String NAME = \"anf.if\";\n+\n+        public static class ThenBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement yieldType;\n+            final Value test;\n+\n+            ThenBuilder(Body.Builder ancestorBody, TypeElement yieldType, Value test) {\n+                this.ancestorBody = ancestorBody;\n+                this.yieldType = yieldType;\n+                this.test = test;\n+            }\n+\n+            public ElseBuilder if_(Consumer<Block.Builder> c) {\n+                Body.Builder then_ = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(yieldType));\n+                c.accept(then_.entryBlock());\n+\n+                return new ElseBuilder(this, then_);\n+            }\n+        }\n+\n+        public static class ElseBuilder {\n+            final ThenBuilder thenBuilder;\n+            final Body.Builder then_;\n+\n+            public ElseBuilder(ThenBuilder thenBuilder, Body.Builder then_) {\n+                this.thenBuilder = thenBuilder;\n+                this.then_ = then_;\n+            }\n+\n+            public AnfIfOp else_(Consumer<Block.Builder> c) {\n+                Body.Builder else_ = Body.Builder.of(thenBuilder.ancestorBody,\n+                        FunctionType.functionType(thenBuilder.yieldType));\n+                c.accept(else_.entryBlock());\n+\n+                return new AnfIfOp(thenBuilder.test, then_, else_);\n+            }\n+        }\n+\n+        final Body then_, else_;\n+\n+        public AnfIfOp(ExternalizableOp.ExternalizedOp def) {\n+            super(def);\n+\n+            this.then_ = def.bodyDefinitions().get(0).build(this);\n+            this.else_ = def.bodyDefinitions().get(1).build(this);\n+        }\n+\n+        public AnfIfOp(AnfIfOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.then_ = that.then_.transform(cc, ot).build(this);\n+            this.else_ = that.else_.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfIfOp(this, cc, ot);\n+        }\n+\n+        AnfIfOp(Value test, Body.Builder thenBodyBuilder, Body.Builder elseBodyBuilder) {\n+            super(NAME, List.of(test));\n+\n+            this.then_ = thenBodyBuilder.build(this);\n+            this.else_ = elseBodyBuilder.build(this);\n+        }\n+\n+        public Value getTest() {\n+            return this.operands().get(0);\n+        }\n+\n+        public Body _then() {\n+            return then_;\n+        }\n+\n+        public Body _else() {\n+            return else_;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(then_, else_);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.then_.yieldType();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(AnfFuncOp.NAME)\n+    public static final class AnfFuncOp extends ExternalizableOp implements Op.Nested {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final String funcName;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcName = funcName;\n+                this.funcType = funcType;\n+            }\n+\n+            public AnfFuncOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new AnfFuncOp(funcName, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"anf.func\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final Body body;\n+\n+        public static AnfFuncOp create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new AnfFuncOp(def, funcName);\n+        }\n+\n+        AnfFuncOp(ExternalizedOp def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        AnfFuncOp(AnfFuncOp that, CopyContext cc, OpTransformer oa) {\n+            this(that, that.funcName, cc, oa);\n+        }\n+\n+        AnfFuncOp(AnfFuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.funcName = funcName;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public AnfFuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfFuncOp(this, cc, ot);\n+        }\n+\n+        AnfFuncOp(String funcName, Body.Builder bodyBuilder) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.funcName = funcName;\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return invokableType();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(AnfApply.NAME)\n+    public static final class AnfApply extends ExternalizableOp implements Op.Terminating {\n+        public static final String NAME = \"anf.apply\";\n+\n+        public AnfApply(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        public AnfApply(AnfApply that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfApply(this, cc);\n+        }\n+\n+        public AnfApply(List<Value> arguments) {\n+            super(AnfApply.NAME, arguments);\n+\n+            \/\/ First argument is func value\n+            \/\/ Subsequent arguments are func arguments\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            FunctionType ft = (FunctionType) operands().get(0).type();\n+            return ft.returnType();\n+        }\n+\n+        public List<Value> args() {\n+            return operands().subList(1, this.operands().size());\n+        }\n+    }\n+\n+\n+    public static AnfLetRecOp.Builder letrec(Body.Builder ancestorBody, TypeElement yieldType) {\n+        return new AnfLetRecOp.Builder(ancestorBody, yieldType);\n+    }\n+\n+    public static AnfLetRecOp letrec(Body.Builder body) {\n+        return new AnfLetRecOp(body);\n+    }\n+\n+    public static AnfLetOp.Builder let(Body.Builder ancestorBody, TypeElement yieldType) {\n+        return new AnfLetOp.Builder(ancestorBody, yieldType);\n+    }\n+\n+    public static AnfLetOp let(Body.Builder body) {\n+        return new AnfLetOp(body);\n+    }\n+\n+    public static AnfIfOp.ThenBuilder if_(Body.Builder ancestorBody, TypeElement yieldType, Value test) {\n+        return new AnfIfOp.ThenBuilder(ancestorBody, yieldType, test);\n+    }\n+\n+    public static AnfIfOp if_(Body.Builder then_, Body.Builder else_, Value test) {\n+        return new AnfIfOp(test, then_, else_);\n+    }\n+\n+    public static AnfFuncOp.Builder func(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+        List<TypeElement> params = new ArrayList<>();\n+        params.add(funcType);\n+        params.addAll(funcType.parameterTypes());\n+        return new AnfFuncOp.Builder(ancestorBody, funcName, FunctionType.functionType(funcType.returnType(), params));\n+    }\n+\n+    public static AnfFuncOp func(String funcName, Body.Builder body) {\n+        return new AnfFuncOp(funcName, body);\n+    }\n+\n+    public static AnfApply apply(List<Value> arguments) {\n+        return new AnfApply(arguments);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/AnfDialect.java","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -2651,175 +2651,0 @@\n-\n-    \/\/ANF-style operations\n-    @OpFactory.OpDeclaration(IfExp.NAME)\n-    public static final class IfExp extends CoreOp implements Op.Terminating {\n-        public static final String NAME = \"if\";\n-\n-        final private Body _then, _else;\n-\n-        public IfExp(IfExp that, CopyContext cc) {\n-            super(that, cc);\n-            this._then = that._then;\n-            this._else = that._else;\n-        }\n-\n-        public IfExp(Value test, Body thn, Body els) {\n-            super(IfExp.NAME, List.of(test));\n-            this._then = thn;\n-            this._else = els;\n-        }\n-\n-        public IfExp(ExternalizedOp def) {\n-            super(def);\n-            if (def.operands().size() == 1) {\n-                throw new IllegalArgumentException(\"IfExp operation must have one operand.\");\n-            }\n-            this._then = def.bodyDefinitions().get(0).build(this);\n-            this._else = def.bodyDefinitions().get(1).build(this);\n-        }\n-\n-        public Value getTest() {\n-            return this.operands().get(0);\n-        }\n-\n-        public Body _then() {\n-            return this.bodies().get(0);\n-        }\n-\n-        public Body _else() {\n-            return this.bodies().get(1);\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new IfExp(this, cc);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return this._then.bodyType().returnType();\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(LetExp.NAME)\n-    public static final class LetExp extends CoreOp implements Op.Lowerable, Op.Terminating {\n-        public static final String NAME = \"let\";\n-\n-        public final Body bindingsExp;\n-\n-        public LetExp(LetExp that, CopyContext cc) {\n-            super(that, cc);\n-            this.bindingsExp = that.bindingsExp;\n-        }\n-\n-        public LetExp(ExternalizedOp def) {\n-            super(def);\n-            if (def.operands().size() != 1) {\n-               throw new IllegalStateException(\"LetExp operation must have one body.\");\n-            }\n-            this.bindingsExp = def.bodyDefinitions().get(0).build(this);\n-        }\n-\n-        public LetExp(Body b) {\n-            super(NAME, List.of());\n-            this.bindingsExp = b;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new LetExp(this, cc);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return this.bindingsExp.bodyType().returnType();\n-        }\n-\n-        @Override\n-        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n-            return null;\n-        }\n-    }\n-\n-\n-    @OpFactory.OpDeclaration(LetRecExp.NAME)\n-    public static final class LetRecExp extends CoreOp implements Op.Terminating {\n-        public static final String NAME = \"letrec\";\n-\n-        public final List<FuncOp> functions;\n-        public final Op expBody;\n-\n-        public LetRecExp(LetRecExp that, CopyContext cc) {\n-            super(that, cc);\n-            this.functions = that.functions;\n-            this.expBody = that.expBody;\n-        }\n-\n-        public LetRecExp(ExternalizedOp def) {\n-            super(def);\n-\n-            List<Body.Builder> fbodies = def.bodyDefinitions().subList(0, def.bodyDefinitions().size() - 1);\n-            this.functions = fbodies.stream().map(b -> new FuncOp(\"anon\", b)).toList();\n-            this.expBody = (Op) def.attributes().get(\"expBody\");\n-        }\n-\n-        public LetRecExp(List<FuncOp> funcs, Op expBody) {\n-            super(LetRecExp.NAME, List.of());\n-            this.functions = funcs;\n-            this.expBody = expBody;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new LetRecExp(this, cc);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return this.expBody.resultType();\n-        }\n-    }\n-\n-    @OpFactory.OpDeclaration(FunApp.NAME)\n-    public static final class FunApp extends CoreOp implements Op.Terminating {\n-        public static final String NAME = \"funapp\";\n-\n-        private final TypeElement resultType;\n-        private final Object name;\n-\n-        public FunApp(FunApp that, CopyContext cc) {\n-            super(that, cc);\n-            this.resultType = that.resultType;\n-            this.name = that.name;\n-        }\n-\n-        public FunApp(ExternalizedOp def) {\n-            super(def);\n-            this.resultType = def.resultType();\n-            this.name = def.attributes().get(\"name\");\n-        }\n-\n-        public FunApp(Object name, List<Value> arguments, TypeElement resultType) {\n-            super(FunApp.NAME, arguments);\n-            this.resultType = resultType;\n-            this.name = name;\n-        }\n-\n-        @Override\n-        public Op transform(CopyContext cc, OpTransformer ot) {\n-            return new FunApp(this, cc);\n-        }\n-\n-        @Override\n-        public TypeElement resultType() {\n-            return this.resultType;\n-        }\n-\n-        public Value funOp() {\n-            return this.operands().get(0);\n-        }\n-\n-        public List<Value> args() {\n-            return this.operands().subList(1, this.operands().size());\n-        }\n-    }\n-\n@@ -4373,18 +4198,0 @@\n-\n-    \/\/ANF-style extension constructors\n-\n-    public static FunApp funApp(Object name, List<Value> args, TypeElement returnType) {\n-        return new FunApp(name, args, returnType);\n-    }\n-\n-    public static IfExp ifExp(Value test, Op _then, Op _else) {\n-        return new IfExp(test, _then, _else);\n-    }\n-\n-    public static LetExp letExp(Block bindings, Op expBody) {\n-        return new LetExp(bindings, expBody);\n-    }\n-\n-    public static LetRecExp letRecExp(List<FuncOp> funcOps, Op expBody) {\n-        return new LetRecExp(funcOps, expBody);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"modified"}]}