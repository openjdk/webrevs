{"files":[{"patch":"@@ -0,0 +1,335 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.AnfDialect;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.util.*;\n+import java.util.function.Function;\n+\n+public class AnfTransformer {\n+\n+\n+    final CoreOp.FuncOp sourceOp;\n+    final Map<Block, Function<Body.Builder, AnfDialect.AnfFuncOp>> fBuilders = new HashMap<>();\n+    final Body.Builder outerBodyBuilder;\n+    final ImmediateDominatorMap idomMap;\n+    final Map<Block, Value> funMap = new HashMap<>();\n+    final Map<Block, Value> funMap2 = new HashMap<>();\n+\n+    public AnfTransformer(CoreOp.FuncOp funcOp) {\n+        sourceOp = funcOp;\n+        outerBodyBuilder = Body.Builder.of(null, FunctionType.functionType(funcOp.body().yieldType()));\n+        idomMap = new ImmediateDominatorMap(funcOp.body());\n+    }\n+\n+    public AnfDialect.AnfFuncOp transform() {\n+        return transformOuterBody(sourceOp.body());\n+    }\n+\n+    \/\/Outer body corresponds to outermost letrec\n+    public AnfDialect.AnfFuncOp transformOuterBody(Body b) {\n+        var entry = b.entryBlock();\n+\n+        var builderEntry = outerBodyBuilder.entryBlock();\n+\n+        var selfRefP = builderEntry.parameter(((CoreOp.FuncOp) b.parentOp()).invokableType());\n+        funMap.put(entry, selfRefP);\n+\n+        for (Block.Parameter p : entry.parameters()) {\n+            var newP = builderEntry.parameter(p.type());\n+            builderEntry.context().mapValue(p,newP);\n+        }\n+\n+        var outerLetRecBody = Body.Builder.of(outerBodyBuilder, FunctionType.functionType(b.yieldType(), List.of()), CopyContext.create(builderEntry.context()));\n+\n+        List<Block> dominatedBlocks = idomMap.idominates(entry);\n+        List<AnfDialect.AnfFuncOp> funs = dominatedBlocks.stream().map(block -> transformBlock(block, outerLetRecBody)).toList();\n+\n+        var res = transformBlock(entry, outerLetRecBody);\n+        return res;\n+\n+    }\n+\n+    public AnfDialect.AnfFuncOp transformBlock(Block b, Body.Builder bodyBuilder) {\n+        if (idomMap.idominates(b).isEmpty()) {\n+            return transformLeafBlock(b, bodyBuilder);\n+        }\n+        return transformDomBlock(b, bodyBuilder);\n+    }\n+\n+    \/\/\"Leaf\" in this case is a leaf of the dominator tree\n+    public AnfDialect.AnfFuncOp transformLeafBlock(Block b, Body.Builder ancestorBodyBuilder) {\n+        var blockReturnType = getBlockReturnType(b);\n+        var blockFType = FunctionType.functionType(blockReturnType);\n+\n+        List<TypeElement> synthParamTypes = new ArrayList<>();\n+        synthParamTypes.add(blockFType);\n+\n+        var blockFTypeSynth = FunctionType.functionType(blockReturnType, synthParamTypes);\n+\n+        Body.Builder newBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFTypeSynth, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+\n+        var selfRefParam = newBodyBuilder.entryBlock().parameters().get(0);\n+        funMap.put(b, selfRefParam);\n+\n+        for (Block.Parameter param : b.parameters()) {\n+            var p = newBodyBuilder.entryBlock().parameter(param.type());\n+            newBodyBuilder.entryBlock().context().mapValue(param, p);\n+        }\n+\n+        var letBody = Body.Builder.of(newBodyBuilder, FunctionType.functionType(blockReturnType, List.of()), CopyContext.create(newBodyBuilder.entryBlock().context()));\n+\n+        AnfDialect.AnfLetOp let = transformOps(b, letBody);\n+        newBodyBuilder.entryBlock().op(let);\n+        return AnfDialect.func(b.toString(), newBodyBuilder);\n+    }\n+\n+    \/\/Non leaf nodes of the dominator tree\n+    public AnfDialect.AnfFuncOp transformDomBlock(Block b, Body.Builder ancestorBodyBuilder) {\n+        var blockReturnType = getBlockReturnType(b);\n+        var blockFType = FunctionType.functionType(blockReturnType);\n+\n+        List<TypeElement> synthParamTypes = new ArrayList<>();\n+        synthParamTypes.add(blockFType);\n+\n+        var blockFTypeSynth = FunctionType.functionType(blockReturnType, synthParamTypes);\n+\n+        \/\/Function body contains letrec and its bodies\n+        Body.Builder funcBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFTypeSynth, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+\n+        \/\/Self param\n+        var selfRefParam = funcBodyBuilder.entryBlock().parameters().get(0);\n+        funMap.put(b, selfRefParam);\n+\n+        for (Block.Parameter param : b.parameters()) {\n+            var p = funcBodyBuilder.entryBlock().parameter(param.type());\n+            funcBodyBuilder.entryBlock().context().mapValue(param, p);\n+        }\n+\n+        \/\/letrec inner body\n+        Body.Builder letrecBody = Body.Builder.of(funcBodyBuilder, FunctionType.functionType(blockReturnType, List.of()), CopyContext.create(funcBodyBuilder.entryBlock().context()));\n+\n+        List<Block> dominates = idomMap.idominates(b);\n+        for (Block dblock : dominates) {\n+            var res = transformDomBlock(dblock, letrecBody);\n+            var fval = letrecBody.entryBlock().op(res);\n+            funMap2.put(dblock, fval);\n+        }\n+\n+        var letBody = Body.Builder.of(letrecBody, letrecBody.bodyType(), CopyContext.create(letrecBody.entryBlock().context()));\n+        transformBlockOps(b, letBody.entryBlock());\n+        var let = AnfDialect.let(letBody);\n+\n+        letrecBody.entryBlock().op(let);\n+\n+        var letrec = AnfDialect.letrec(letrecBody);\n+        funcBodyBuilder.entryBlock().op(letrec);\n+        return AnfDialect.func(b.toString(), funcBodyBuilder);\n+\n+    }\n+\n+    private TypeElement getBlockReturnType(Block b) {\n+        var op = b.ops().getLast();\n+        if (op instanceof Op.Terminating) {\n+            List<Block.Reference> destBlocks = new ArrayList<>();\n+            if (op instanceof CoreOp.ReturnOp ro) {\n+                return ro.returnValue().type();\n+            } else if (op instanceof CoreOp.YieldOp yo) {\n+                return yo.yieldValue().type();\n+            } else if (op instanceof CoreOp.BranchOp bop) {\n+                destBlocks.addAll(bop.successors());\n+            } else if (op instanceof CoreOp.ConditionalBranchOp cbop) {\n+                destBlocks.addAll(cbop.successors());\n+            }\n+            \/\/Traverse until we find a yield or return type, TODO: not going to try to unify types\n+\n+            Set<Block> visitedBlocks = new HashSet<>();\n+            visitedBlocks.add(b);\n+\n+            while (!destBlocks.isEmpty()) {\n+                var block = destBlocks.removeFirst().targetBlock();\n+                if (visitedBlocks.contains(block)) {\n+                    continue;\n+                }\n+\n+                \/\/Discovered a terminator with a return value, use its type\n+                if (block.successors().isEmpty()) {\n+                    var o = block.ops().getLast();\n+                    if (o instanceof CoreOp.ReturnOp ro) {\n+                        return ro.returnValue().type();\n+                    } else if (o instanceof CoreOp.YieldOp yo) {\n+                        return yo.yieldValue().type();\n+                    } else {\n+                        throw new UnsupportedOperationException(\"Unsupported terminator encountered: \" + o.opName());\n+                    }\n+                } else {\n+                    visitedBlocks.add(block);\n+                    var newDests = block.successors().stream().filter((s) -> !visitedBlocks.contains(s.targetBlock())).toList();\n+                    destBlocks.addAll(newDests);\n+                }\n+            }\n+\n+        }\n+\n+        throw new RuntimeException(\"Encountered Block with no return \" + op.opName());\n+    }\n+\n+    private Block.Builder transformEndOp(Block.Builder b, Op op) {\n+        if (op instanceof Op.Terminating t) {\n+            switch (t) {\n+                case CoreOp.ConditionalBranchOp c -> {\n+                    var tbranch_args = c.trueBranch().arguments();\n+                    tbranch_args = tbranch_args.stream().map(b.context()::getValue).toList();\n+                    var fbranch_args = c.falseBranch().arguments();\n+                    fbranch_args = fbranch_args.stream().map(b.context()::getValue).toList();\n+\n+                    List<Value> trueArgs = new ArrayList<>();\n+                    trueArgs.addAll(tbranch_args);\n+\n+                    List<Value> falseArgs = new ArrayList<>();\n+                    falseArgs.addAll(fbranch_args);\n+\n+\n+                    var ifExp = AnfDialect.if_(b.parentBody(),\n+                                    getBlockReturnType(c.trueBranch().targetBlock()),\n+                                    b.context().getValue(c.predicate()))\n+                            .if_((bodyBuilder) -> bindFunApp(bodyBuilder, trueArgs, c.trueBranch().targetBlock()))\n+                            .else_((bodyBuilder) -> bindFunApp(bodyBuilder, falseArgs, c.falseBranch().targetBlock()));\n+\n+                    b.op(ifExp);\n+\n+                    return b;\n+                }\n+                case CoreOp.BranchOp br -> {\n+                    var args = br.branch().arguments();\n+                    args = args.stream().map(b.context()::getValue).toList();\n+\n+                    List<Value> funcArgs = new ArrayList<>();\n+                    funcArgs.addAll(args);\n+                    bindFunApp(b, funcArgs, br.branch().targetBlock());\n+\n+                    return b;\n+                }\n+                case CoreOp.ReturnOp ro -> {\n+                    var rval = b.context().getValue(ro.returnValue());\n+                    b.op(CoreOp._yield(rval));\n+                    return b;\n+                }\n+                case CoreOp.YieldOp y ->  {\n+                    var rval = b.context().getValue(y.yieldValue());\n+                    b.op(CoreOp._yield(rval));\n+                    return b;\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported terminating op encountered: \" + op);\n+                }\n+            }\n+        } else {\n+            b.op(op);\n+            return b;\n+        }\n+    }\n+\n+\n+    private void bindFunApp(Block.Builder b, List<Value> args, Block target) {\n+\n+        List<Value> synthArgs = new ArrayList<>();\n+        synthArgs.addAll(args);\n+        synthArgs.addFirst(funMap.get(target));\n+        try {\n+            b.op(AnfDialect.apply(synthArgs));\n+            return;\n+        } catch (IllegalStateException e) {}\n+\n+        synthArgs.removeFirst();\n+        synthArgs.addFirst(funMap2.get(target));\n+\n+        try {\n+            b.op(AnfDialect.apply(synthArgs));\n+        } catch (IllegalStateException e) {\n+            throw new IllegalStateException(\"No valid mapping to FuncOp for apply\");\n+        }\n+\n+    }\n+\n+\n+    public AnfDialect.AnfLetOp transformOps(Block b, Body.Builder bodyBuilder) {\n+        Block.Builder blockb = bodyBuilder.entryBlock();\n+        return transformOps(b, blockb);\n+    }\n+\n+    public AnfDialect.AnfLetOp transformOps(Block b, Block.Builder blockBuilder) {\n+        transformBlockOps(b, blockBuilder);\n+        return AnfDialect.let(blockBuilder.parentBody());\n+    }\n+\n+    public void transformBlockOps(Block b, Block.Builder blockBuilder) {\n+        for (var op : b.ops()) {\n+            transformEndOp(blockBuilder, op);\n+        }\n+    }\n+\n+    static class ImmediateDominatorMap {\n+\n+        private final Map <Block, List<Block>> dominatesMap;\n+        private final Map <Block, Block> dominatorsMap;\n+\n+        public ImmediateDominatorMap(Body b) {\n+            dominatorsMap = b.immediateDominators();\n+            dominatesMap = new HashMap<>();\n+\n+            \/\/Reverse the idom relation\n+            b.immediateDominators().forEach((dominated, dominator) -> {\n+                if (!dominated.equals(dominator)) {\n+                    dominatesMap.compute(dominator, (k, v) -> {\n+                        if (v == null) {\n+                            var newList = new ArrayList<Block>();\n+                            newList.add(dominated);\n+                            return newList;\n+                        } else {\n+                            v.add(dominated);\n+                            return v;\n+                        }\n+                    });\n+                }\n+            });\n+\n+        }\n+\n+        \/\/Looks \"down\" the dominator tree toward leaves\n+        public List<Block> idominates(Block b) {\n+            return dominatesMap.getOrDefault(b, List.of());\n+        }\n+\n+        \/\/Looks \"up\" the dominator tree toward start node\n+        public Block idominatedBy(Block b) {\n+            return dominatorsMap.get(b);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/AnfTransformer.java","additions":335,"deletions":0,"binary":false,"changes":335,"status":"added"},{"patch":"@@ -136,8 +136,6 @@\n-        void popExceptionRegion(CoreOp.ExceptionRegionExit ere) {\n-            ere.catchBlocks().forEach(catchBlock -> {\n-                if (erStack.peek().catchBlock != catchBlock.targetBlock()) {\n-                    \/\/ @@@ Use internal exception type\n-                    throw interpreterException(new IllegalStateException(\"Mismatched exception regions\"));\n-                }\n-                erStack.pop();\n-            });\n+        void popExceptionRegion(CoreOp.ExceptionRegionEnter ers) {\n+            if (erStack.peek().ers != ers) {\n+                \/\/ @@@ Use internal exception type\n+                throw interpreterException(new IllegalStateException(\"Mismatched exception regions\"));\n+            }\n+            erStack.pop();\n@@ -161,3 +159,0 @@\n-            while (erStack.size() > er.erStackDepth()) {\n-                erStack.pop();\n-            }\n@@ -179,2 +174,0 @@\n-\n-        static final Object UINITIALIZED = new Object();\n@@ -199,1 +192,2 @@\n-    record ExceptionRegionRecord(BlockContext mark, int erStackDepth, Block catchBlock) {\n+    record ExceptionRegionRecord(BlockContext mark, CoreOp.ExceptionRegionEnter ers)\n+            implements CoreOp.ExceptionRegion {\n@@ -201,10 +195,13 @@\n-            List<Block.Parameter> args = catchBlock.parameters();\n-            if (args.size() != 1) {\n-                throw interpreterException(new IllegalStateException(\"Catch block must have one argument\"));\n-            }\n-            TypeElement et = args.get(0).type();\n-            if (et instanceof VarType vt) {\n-                et = vt.valueType();\n-            }\n-            if (resolveToClass(l, et).isInstance(e)) {\n-                return catchBlock;\n+            for (Block.Reference catchBlock : ers.catchBlocks()) {\n+                Block target = catchBlock.targetBlock();\n+                List<Block.Parameter> args = target.parameters();\n+                if (args.size() != 1) {\n+                    throw interpreterException(new IllegalStateException(\"Catch block must have one argument\"));\n+                }\n+                TypeElement et = args.get(0).type();\n+                if (et instanceof VarType vt) {\n+                    et = vt.valueType();\n+                }\n+                if (resolveToClass(l, et).isInstance(e)) {\n+                    return target;\n+                }\n@@ -335,5 +332,4 @@\n-                int erStackDepth = oc.erStack.size();\n-                ers.catchBlocks().forEach(catchBlock -> {\n-                    var er = new ExceptionRegionRecord(oc.stack.peek(), erStackDepth, catchBlock.targetBlock());\n-                    oc.pushExceptionRegion(er);\n-                });\n+                var er = new ExceptionRegionRecord(oc.stack.peek(), ers);\n+                oc.setValue(ers.result(), er);\n+\n+                oc.pushExceptionRegion(er);\n@@ -343,1 +339,1 @@\n-                oc.popExceptionRegion(ere);\n+                oc.popExceptionRegion(ere.regionStart());\n@@ -420,0 +416,6 @@\n+            MethodHandle mh;\n+            if (co.hasReceiver()) {\n+                mh = methodHandle(l, co.invokeDescriptor());\n+            } else {\n+                mh = methodStaticHandle(l, co.invokeDescriptor());\n+            }\n@@ -421,6 +423,0 @@\n-            MethodHandles.Lookup il = switch (co.invokeKind()) {\n-                case STATIC, INSTANCE -> l;\n-                case SUPER -> l.in(target.parameterType(0));\n-            };\n-            MethodHandle mh = resolveToMethodHandle(il, co.invokeDescriptor(), co.invokeKind());\n-\n@@ -484,4 +480,1 @@\n-            Object v = vo.isUninitialized()\n-                    ? VarBox.UINITIALIZED\n-                    : oc.getValue(o.operands().get(0));\n-            return new VarBox(v);\n+            return new VarBox(oc.getValue(o.operands().get(0)));\n@@ -492,5 +485,1 @@\n-            Object value = vb.value();\n-            if (value == VarBox.UINITIALIZED) {\n-                throw interpreterException(new IllegalStateException(\"Loading from uninitialized variable\"));\n-            }\n-            return value;\n+            return vb.value();\n@@ -627,0 +616,8 @@\n+    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodRef d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n+    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodRef d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n@@ -662,1 +659,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d) {\n@@ -664,1 +661,1 @@\n-            return d.resolveToHandle(l, kind);\n+            return d.resolveToHandle(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":44,"deletions":47,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,506 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.op;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static java.lang.reflect.code.op.OpFactory.*;\n+\n+public final class AnfDialect {\n+\n+    private AnfDialect() {\n+    }\n+\n+    @OpDeclaration(AnfLetOp.NAME)\n+    public static final class AnfLetOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+        public static final String NAME = \"anf.let\";\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement yieldType;\n+\n+            Builder(Body.Builder ancestorBody, TypeElement yieldType) {\n+                this.ancestorBody = ancestorBody;\n+                this.yieldType = yieldType;\n+            }\n+\n+            public AnfLetOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(yieldType));\n+                c.accept(body.entryBlock());\n+                return new AnfLetOp(body);\n+            }\n+        }\n+\n+        \/\/ Terminating operation is the in expression that yields the result for this operation\n+        \/\/ Any operation result in the entry block used by the terminating operation\n+        \/\/ or a descendant operation is a let binding\n+        final Body bindings;\n+\n+        public AnfLetOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.bindings = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        public AnfLetOp(AnfLetOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bindings = that.bindings.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfLetOp(this, cc, ot);\n+        }\n+\n+        public AnfLetOp(Body.Builder bodyBuilder) {\n+            super(NAME, List.of());\n+\n+            this.bindings = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(bindings);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.bindings.yieldType();\n+        }\n+    }\n+\n+\n+    @OpDeclaration(AnfLetRecOp.NAME)\n+    public static final class AnfLetRecOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+        public static final String NAME = \"anf.letrec\";\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement yieldType;\n+\n+            Builder(Body.Builder ancestorBody, TypeElement yieldType) {\n+                this.ancestorBody = ancestorBody;\n+                this.yieldType = yieldType;\n+            }\n+\n+            public AnfLetRecOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, FunctionType.functionType(yieldType));\n+                c.accept(body.entryBlock());\n+                return new AnfLetRecOp(body);\n+            }\n+        }\n+\n+        \/\/ Terminating operation is the in expression that yields the result for this operation\n+        \/\/ Any operation result in the entry block used by the terminating operation\n+        \/\/ or a descendant operation is a letrec binding\n+        final Body bindings;\n+\n+        public AnfLetRecOp(ExternalizedOp def) {\n+            super(def);\n+\n+            this.bindings = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        public AnfLetRecOp(AnfLetRecOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.bindings = that.bindings.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfLetRecOp(this, cc, ot);\n+        }\n+\n+        public AnfLetRecOp(Body.Builder bodyBuilder) {\n+            super(AnfLetRecOp.NAME, List.of());\n+\n+            this.bindings = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(bindings);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.bindings.yieldType();\n+        }\n+\n+        public List<CoreOp.FuncOp> funcOps() {\n+            List<Op> ops = bindings.entryBlock().ops();\n+            return ops.subList(0, ops.size() - 1).stream()\n+                    .<CoreOp.FuncOp>mapMulti((op, objectConsumer) -> {\n+                        if (op instanceof CoreOp.FuncOp fop) {\n+                            objectConsumer.accept(fop);\n+                        }\n+                    }).toList();\n+        }\n+    }\n+\n+    @OpDeclaration(AnfIfOp.NAME)\n+    public static final class AnfIfOp extends ExternalizableOp implements Op.Terminating, Op.Nested {\n+        public static final String NAME = \"anf.if\";\n+\n+        public static class ThenBuilder {\n+            final Body.Builder ancestorBody;\n+            final TypeElement yieldType;\n+            final Value test;\n+\n+            ThenBuilder(Body.Builder ancestorBody, TypeElement yieldType, Value test) {\n+                this.ancestorBody = ancestorBody;\n+                this.yieldType = yieldType;\n+                this.test = test;\n+            }\n+\n+            public ElseBuilder if_(Consumer<Block.Builder> c) {\n+                Body.Builder then_ = Body.Builder.of(ancestorBody,\n+                        FunctionType.functionType(yieldType));\n+                c.accept(then_.entryBlock());\n+\n+                return new ElseBuilder(this, then_);\n+            }\n+        }\n+\n+        public static class ElseBuilder {\n+            final ThenBuilder thenBuilder;\n+            final Body.Builder then_;\n+\n+            public ElseBuilder(ThenBuilder thenBuilder, Body.Builder then_) {\n+                this.thenBuilder = thenBuilder;\n+                this.then_ = then_;\n+            }\n+\n+            public AnfIfOp else_(Consumer<Block.Builder> c) {\n+                Body.Builder else_ = Body.Builder.of(thenBuilder.ancestorBody,\n+                        FunctionType.functionType(thenBuilder.yieldType));\n+                c.accept(else_.entryBlock());\n+\n+                return new AnfIfOp(thenBuilder.test, then_, else_);\n+            }\n+        }\n+\n+        final Body then_, else_;\n+\n+        public AnfIfOp(ExternalizableOp.ExternalizedOp def) {\n+            super(def);\n+\n+            this.then_ = def.bodyDefinitions().get(0).build(this);\n+            this.else_ = def.bodyDefinitions().get(1).build(this);\n+        }\n+\n+        public AnfIfOp(AnfIfOp that, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.then_ = that.then_.transform(cc, ot).build(this);\n+            this.else_ = that.else_.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfIfOp(this, cc, ot);\n+        }\n+\n+        AnfIfOp(Value test, Body.Builder thenBodyBuilder, Body.Builder elseBodyBuilder) {\n+            super(NAME, List.of(test));\n+\n+            this.then_ = thenBodyBuilder.build(this);\n+            this.else_ = elseBodyBuilder.build(this);\n+        }\n+\n+        public Value getTest() {\n+            return this.operands().get(0);\n+        }\n+\n+        public Body _then() {\n+            return then_;\n+        }\n+\n+        public Body _else() {\n+            return else_;\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(then_, else_);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.then_.yieldType();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(AnfFuncOp.NAME)\n+    public static final class AnfFuncOp extends ExternalizableOp implements Op.Nested {\n+\n+        public static class Builder {\n+            final Body.Builder ancestorBody;\n+            final String funcName;\n+            final FunctionType funcType;\n+\n+            Builder(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+                this.ancestorBody = ancestorBody;\n+                this.funcName = funcName;\n+                this.funcType = funcType;\n+            }\n+\n+            public AnfFuncOp body(Consumer<Block.Builder> c) {\n+                Body.Builder body = Body.Builder.of(ancestorBody, funcType);\n+                c.accept(body.entryBlock());\n+                return new AnfFuncOp(funcName, body);\n+            }\n+        }\n+\n+        public static final String NAME = \"anf.func\";\n+        public static final String ATTRIBUTE_FUNC_NAME = NAME + \".name\";\n+\n+        final String funcName;\n+        final Body body;\n+\n+        public static AnfFuncOp create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String funcName = def.extractAttributeValue(ATTRIBUTE_FUNC_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new AnfFuncOp(def, funcName);\n+        }\n+\n+        AnfFuncOp(ExternalizedOp def, String funcName) {\n+            super(def);\n+\n+            this.funcName = funcName;\n+            this.body = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        AnfFuncOp(AnfFuncOp that, CopyContext cc, OpTransformer oa) {\n+            this(that, that.funcName, cc, oa);\n+        }\n+\n+        AnfFuncOp(AnfFuncOp that, String funcName, CopyContext cc, OpTransformer ot) {\n+            super(that, cc);\n+\n+            this.funcName = funcName;\n+            this.body = that.body.transform(cc, ot).build(this);\n+        }\n+\n+        @Override\n+        public AnfFuncOp transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfFuncOp(this, cc, ot);\n+        }\n+\n+        AnfFuncOp(String funcName, Body.Builder bodyBuilder) {\n+            super(NAME,\n+                    List.of());\n+\n+            this.funcName = funcName;\n+            this.body = bodyBuilder.build(this);\n+        }\n+\n+        @Override\n+        public List<Body> bodies() {\n+            return List.of(body);\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", funcName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        public FunctionType invokableType() {\n+            return body.bodyType();\n+        }\n+\n+        public String funcName() {\n+            return funcName;\n+        }\n+\n+        public Body body() {\n+            return body;\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return invokableType();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(AnfApply.NAME)\n+    public static final class AnfApply extends ExternalizableOp implements Op.Terminating {\n+        public static final String NAME = \"anf.apply\";\n+\n+        public AnfApply(ExternalizedOp def) {\n+            super(def);\n+        }\n+\n+        public AnfApply(AnfApply that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfApply(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            FunctionType ft = (FunctionType) operands().get(0).type();\n+            return ft.returnType();\n+        }\n+\n+        public AnfApply(List<Value> arguments) {\n+            super(AnfApply.NAME, arguments);\n+\n+            \/\/ First argument is func value\n+            \/\/ Subsequent arguments are func arguments\n+        }\n+\n+\n+        public List<Value> args() {\n+            return operands().subList(1, this.operands().size());\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(AnfApplyStub.NAME)\n+    public static final class AnfApplyStub extends ExternalizableOp implements Op.Terminating {\n+        public static final String NAME = \"anf.apply.stub\";\n+        public static final String ATTRIBUTE_RESULT_TYPE = \".resultType\";\n+        public static final String ATTRIBUTE_CALLSITE_NAME = \".callsiteName\";\n+\n+        public final String callSiteName;\n+        public final TypeElement resultType;\n+\n+        public static AnfApplyStub create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            String callsiteName = def.extractAttributeValue(ATTRIBUTE_CALLSITE_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new AnfApplyStub(def,callsiteName,def.resultType());\n+        }\n+\n+        public AnfApplyStub(ExternalizedOp def, String name, TypeElement resultType) {\n+            super(def);\n+            this.resultType = resultType;\n+            this.callSiteName = name;\n+        }\n+\n+        public AnfApplyStub(AnfApplyStub that, CopyContext cc) {\n+            super(that, cc);\n+            this.callSiteName = that.callSiteName;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> m = new HashMap<>(super.attributes());\n+            m.put(\"\", callSiteName);\n+            return Collections.unmodifiableMap(m);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfApplyStub(this, cc);\n+        }\n+\n+        public AnfApplyStub(String callSiteName, List<Value> arguments, TypeElement resultType) {\n+            super(AnfApplyStub.NAME, arguments);\n+            this.resultType = resultType;\n+            this.callSiteName = callSiteName;\n+\n+            \/\/ First argument is func value\n+            \/\/ Subsequent arguments are func arguments\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.resultType;\n+        }\n+\n+        public List<Value> args() {\n+            return operands().subList(1, this.operands().size());\n+        }\n+    }\n+\n+    public static AnfLetRecOp.Builder letrec(Body.Builder ancestorBody, TypeElement yieldType) {\n+        return new AnfLetRecOp.Builder(ancestorBody, yieldType);\n+    }\n+\n+    public static AnfLetRecOp letrec(Body.Builder body) {\n+        return new AnfLetRecOp(body);\n+    }\n+\n+    public static AnfLetOp.Builder let(Body.Builder ancestorBody, TypeElement yieldType) {\n+        return new AnfLetOp.Builder(ancestorBody, yieldType);\n+    }\n+\n+    public static AnfLetOp let(Body.Builder body) {\n+        return new AnfLetOp(body);\n+    }\n+\n+    public static AnfIfOp.ThenBuilder if_(Body.Builder ancestorBody, TypeElement yieldType, Value test) {\n+        return new AnfIfOp.ThenBuilder(ancestorBody, yieldType, test);\n+    }\n+\n+    public static AnfIfOp if_(Body.Builder then_, Body.Builder else_, Value test) {\n+        return new AnfIfOp(test, then_, else_);\n+    }\n+\n+    public static AnfFuncOp.Builder func(Body.Builder ancestorBody, String funcName, FunctionType funcType) {\n+        List<TypeElement> params = new ArrayList<>();\n+        params.add(funcType.returnType());\n+        params.addAll(funcType.parameterTypes());\n+        return new AnfFuncOp.Builder(ancestorBody, funcName, FunctionType.functionType(funcType.returnType(), params));\n+    }\n+\n+    public static AnfFuncOp func(String funcName, Body.Builder body) {\n+        return new AnfFuncOp(funcName, body);\n+    }\n+\n+    public static AnfApply apply(List<Value> arguments) {\n+        return new AnfApply(arguments);\n+    }\n+    \/\/public static AnfApplyStub applyStub(String name, List<Value> arguments, TypeElement type) { return new AnfApplyStub(name, arguments, type);}\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/AnfDialect.java","additions":506,"deletions":0,"binary":false,"changes":506,"status":"added"},{"patch":"@@ -1402,19 +1402,0 @@\n-\n-        \/**\n-         * The kind of invocation.\n-         *\/\n-        public enum InvokeKind {\n-            \/**\n-             * An invocation on a class (static) method.\n-             *\/\n-            STATIC,\n-            \/**\n-             * An invocation on an instance method.\n-             *\/\n-            INSTANCE,\n-            \/**\n-             * A super invocation on an instance method.\n-             *\/\n-            SUPER\n-        }\n-\n@@ -1423,2 +1404,0 @@\n-        public static final String ATTRIBUTE_INVOKE_KIND = NAME + \".kind\";\n-        public static final String ATTRIBUTE_INVOKE_VARARGS = NAME + \".varargs\";\n@@ -1426,2 +1405,0 @@\n-        final InvokeKind invokeKind;\n-        final boolean isVarArgs;\n@@ -1432,1 +1409,0 @@\n-            \/\/ Required attribute\n@@ -1437,10 +1413,1 @@\n-                        case null, default ->\n-                                throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n-                    });\n-\n-            \/\/ If not present defaults to false\n-            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_INVOKE_VARARGS,\n-                    false, v -> switch (v) {\n-                        case String s -> Boolean.valueOf(s);\n-                        case Boolean b -> b;\n-                        case null, default -> false;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n@@ -1449,21 +1416,1 @@\n-            \/\/ If not present and is not varargs defaults to class or instance invocation\n-            \/\/ based on number of operands and parameters\n-            InvokeKind ik = def.extractAttributeValue(ATTRIBUTE_INVOKE_KIND,\n-                    false, v -> switch (v) {\n-                        case String s -> InvokeKind.valueOf(s);\n-                        case InvokeKind k -> k;\n-                        case null, default -> {\n-                            if (isVarArgs) {\n-                                \/\/ If varargs then we cannot infer invoke kind\n-                                throw new UnsupportedOperationException(\"Unsupported invoke kind value:\" + v);\n-                            }\n-                            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-                            int argCount = def.operands().size();\n-                            yield (argCount == paramCount + 1)\n-                                    ? InvokeKind.INSTANCE\n-                                    : InvokeKind.STATIC;\n-                        }\n-                    });\n-\n-\n-            return new InvokeOp(def, ik, isVarArgs, invokeDescriptor);\n+            return new InvokeOp(def, invokeDescriptor);\n@@ -1472,1 +1419,1 @@\n-        InvokeOp(ExternalizedOp def, InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor) {\n+        InvokeOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n@@ -1475,4 +1422,0 @@\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, def.operands());\n-\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n@@ -1486,2 +1429,0 @@\n-            this.invokeKind = that.invokeKind;\n-            this.isVarArgs = that.isVarArgs;\n@@ -1497,2 +1438,3 @@\n-        InvokeOp(InvokeKind invokeKind, boolean isVarArgs, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-            super(NAME, args);\n+        InvokeOp(MethodRef invokeDescriptor, List<Value> args) {\n+            this(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+        }\n@@ -1500,1 +1442,2 @@\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, args);\n+        InvokeOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+            super(NAME, args);\n@@ -1502,2 +1445,0 @@\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n@@ -1508,9 +1449,0 @@\n-        static void validateArgCount(InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor, List<Value> operands) {\n-            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n-            if ((!isVarArgs && argCount != paramCount)\n-                    || argCount < paramCount - 1) {\n-                throw new IllegalArgumentException(invokeKind + \" \" + isVarArgs + \" \" + invokeDescriptor);\n-            }\n-        }\n-\n@@ -1521,10 +1453,0 @@\n-            if (isVarArgs) {\n-                \/\/ If varargs then we need to declare the invoke.kind attribute\n-                \/\/ Given a method `A::m(A... more)` and an invocation with one\n-                \/\/ operand, we don't know if that operand corresponds to the\n-                \/\/ receiver or a method argument\n-                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n-                m.put(ATTRIBUTE_INVOKE_VARARGS, isVarArgs);\n-            } else if (invokeKind == InvokeKind.SUPER) {\n-                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n-            }\n@@ -1534,8 +1456,0 @@\n-        public InvokeKind invokeKind() {\n-            return invokeKind;\n-        }\n-\n-        public boolean isVarArgs() {\n-            return isVarArgs;\n-        }\n-\n@@ -1546,1 +1460,0 @@\n-        \/\/ @@@ remove?\n@@ -1548,13 +1461,1 @@\n-            return invokeKind != InvokeKind.STATIC;\n-        }\n-\n-        public List<Value> varArgOperands() {\n-            if (!isVarArgs) {\n-                return null;\n-            }\n-\n-            int operandCount = operands().size();\n-            int argCount = operandCount - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n-            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-            int varArgCount = argCount - (paramCount - 1);\n-            return operands().subList(operandCount - varArgCount, operandCount);\n+            return operands().size() != invokeDescriptor().type().parameterTypes().size();\n@@ -2136,0 +2037,1 @@\n+\n@@ -2175,2 +2077,2 @@\n-            if (def.operands().size() > 1) {\n-                throw new IllegalStateException(\"Operation must have zero or one operand\");\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n@@ -2182,1 +2084,1 @@\n-                        case null -> \"\";\n+                        case null -> null;\n@@ -2204,1 +2106,1 @@\n-            return !isUninitialized() && resultType().valueType().equals(initOperand().type());\n+            return resultType().valueType().equals(initOperand().type());\n@@ -2219,10 +2121,1 @@\n-            this.varName =  varName == null ? \"\" : varName;\n-            this.resultType = VarType.varType(type);\n-        }\n-\n-        \/\/ @@@ This and the above constructor can be merged when\n-        \/\/ statements before super can be used in the jdk.compiler module\n-        VarOp(String varName, TypeElement type) {\n-            super(NAME, List.of());\n-\n-            this.varName =  varName == null ? \"\" : varName;\n+            this.varName = varName;\n@@ -2234,1 +2127,1 @@\n-            if (isUnnamedVariable()) {\n+            if (varName == null) {\n@@ -2244,3 +2137,0 @@\n-            if (operands().isEmpty()) {\n-                throw new IllegalStateException(\"Uninitialized variable\");\n-            }\n@@ -2262,8 +2152,0 @@\n-\n-        public boolean isUnnamedVariable() {\n-            return varName.isEmpty();\n-        }\n-\n-        public boolean isUninitialized() {\n-            return operands().isEmpty();\n-        }\n@@ -2583,0 +2465,13 @@\n+    \/\/ @@@ Sealed\n+    \/\/ Synthetic\/hidden type that is the result type of an ExceptionRegionStart operation\n+    \/\/ and is an operand of an ExceptionRegionEnd operation\n+\n+    \/**\n+     * A synthetic exception region type, that is the operation result-type of an exception region\n+     * start operation.\n+     *\/\n+    \/\/ @@@: Create as new type element\n+    public interface ExceptionRegion {\n+        TypeElement EXCEPTION_REGION_TYPE = JavaType.type(ExceptionRegion.class);\n+    }\n+\n@@ -2643,1 +2538,1 @@\n-            return JavaType.VOID;\n+            return ExceptionRegion.EXCEPTION_REGION_TYPE;\n@@ -2655,3 +2550,1 @@\n-        \/\/ First successor is the non-exceptional successor whose target indicates\n-        \/\/ the first block following the exception region.\n-        final List<Block.Reference> s;\n+        final Block.Reference end;\n@@ -2662,2 +2555,2 @@\n-            if (def.successors().size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\" + def.name());\n@@ -2666,1 +2559,5 @@\n-            this.s = List.copyOf(def.successors());\n+            if (def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one successor\" + def.name());\n+            }\n+\n+            this.end = def.successors().get(0);\n@@ -2672,1 +2569,1 @@\n-            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+            this.end = cc.getSuccessorOrCreate(that.end);\n@@ -2680,2 +2577,2 @@\n-        ExceptionRegionExit(List<Block.Reference> s) {\n-            super(NAME, List.of());\n+        ExceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+            super(NAME, checkValue(exceptionRegion));\n@@ -2683,2 +2580,7 @@\n-            if (s.size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            this.end = end;\n+        }\n+\n+        static List<Value> checkValue(Value er) {\n+            if (!(er instanceof Result or && or.op() instanceof ExceptionRegionEnter)) {\n+                throw new IllegalArgumentException(\n+                        \"Operand not the result of an exception.region.start operation: \" + er);\n@@ -2687,1 +2589,1 @@\n-            this.s = List.copyOf(s);\n+            return List.of(er);\n@@ -2692,1 +2594,1 @@\n-            return s;\n+            return List.of(end);\n@@ -2696,1 +2598,1 @@\n-            return s.get(0);\n+            return end;\n@@ -2699,2 +2601,6 @@\n-        public List<Block.Reference> catchBlocks() {\n-            return s.subList(1, s.size());\n+        public ExceptionRegionEnter regionStart() {\n+            if (operands().get(0) instanceof Result or &&\n+                    or.op() instanceof ExceptionRegionEnter ers) {\n+                return ers;\n+            }\n+            throw new InternalError(\"Should not reach here\");\n@@ -3594,0 +3500,1 @@\n+     * @param exceptionRegion the exception region to be exited\n@@ -3595,1 +3502,0 @@\n-     * @param catchers the blocks handling exceptions thrown by the region block\n@@ -3598,16 +3504,2 @@\n-    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, Block.Reference... catchers) {\n-        return exceptionRegionExit(end, List.of(catchers));\n-    }\n-\n-    \/**\n-     * Creates an exception region exit operation\n-     *\n-     * @param end             the block to which control is transferred after the exception region is exited\n-     * @param catchers the blocks handling exceptions thrown by the region block\n-     * @return the exception region exit operation\n-     *\/\n-    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, List<Block.Reference> catchers) {\n-        List<Block.Reference> s = new ArrayList<>();\n-        s.add(end);\n-        s.addAll(catchers);\n-        return new ExceptionRegionExit(s);\n+    public static ExceptionRegionExit exceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+        return new ExceptionRegionExit(exceptionRegion, end);\n@@ -3726,11 +3618,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     * <p>\n-     * The invoke return type is the invoke descriptors return type.\n+     * Creates an invoke operation.\n@@ -3738,1 +3620,1 @@\n-     * @param invokeDescriptor the invoke descriptor\n+     * @param invokeDescriptor the invocation descriptor\n@@ -3743,1 +3625,1 @@\n-        return invoke(invokeDescriptor, List.of(args));\n+        return new InvokeOp(invokeDescriptor, List.of(args));\n@@ -3747,11 +3629,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     * <p>\n-     * The invoke return type is the invoke descriptors return type.\n+     * Creates an invoke operation.\n@@ -3759,2 +3631,2 @@\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n@@ -3764,1 +3636,1 @@\n-        return invoke(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+        return new InvokeOp(invokeDescriptor, args);\n@@ -3768,9 +3640,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * Creates an invoke operation.\n@@ -3778,3 +3642,3 @@\n-     * @param returnType       the invoke return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n@@ -3784,26 +3648,1 @@\n-        return invoke(returnType, invokeDescriptor, List.of(args));\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     *\n-     * @param returnType       the invoke return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n-     * @return the invoke super operation\n-     *\/\n-    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        int paramCount = invokeDescriptor.type().parameterTypes().size();\n-        int argCount = args.size();\n-        InvokeOp.InvokeKind ik = (argCount == paramCount + 1)\n-                ? InvokeOp.InvokeKind.INSTANCE\n-                : InvokeOp.InvokeKind.STATIC;\n-        return new InvokeOp(ik, false, returnType, invokeDescriptor, args);\n+        return new InvokeOp(returnType, invokeDescriptor, List.of(args));\n@@ -3813,1 +3652,1 @@\n-     * Creates an invoke operation modelling an invocation to a method.\n+     * Creates an invoke operation.\n@@ -3815,5 +3654,3 @@\n-     * @param invokeKind       the invoke kind\n-     * @param isVarArgs        true if an invocation to a variable argument method\n-     * @param returnType       the return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n@@ -3821,2 +3658,0 @@\n-     * @throws IllegalArgumentException if there is a mismatch between the argument count\n-     *                                  and the invoke descriptors parameter count.\n@@ -3824,3 +3659,2 @@\n-    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n-                                  TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, args);\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(returnType, invokeDescriptor, args);\n@@ -4036,23 +3870,1 @@\n-     * Creates a var operation modeling an unnamed and uninitialized variable,\n-     * either an unnamed local variable or an unnamed parameter.\n-     *\n-     * @param type the type of the var's value\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(TypeElement type) {\n-        return var(null, type, null);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an uninitialized variable, either a local variable or a parameter.\n-     *\n-     * @param name the name of the var\n-     * @param type the type of the var's value\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(String name, TypeElement type) {\n-        return new VarOp(name, type);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an unnamed variable, either an unnamed local variable or an unnamed parameter.\n+     * Creates a var operation.\n@@ -4068,3 +3880,1 @@\n-     * Creates a var operation modeling a variable, either a local variable or a parameter.\n-     * <p>\n-     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n+     * Creates a var operation.\n@@ -4081,3 +3891,1 @@\n-     * Creates a var operation modeling a variable, either a local variable or a parameter.\n-     * <p>\n-     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n+     * Creates a var operation.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":81,"deletions":273,"binary":false,"changes":354,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main TestAnfBasicFuns\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.AnfTransformer;\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\n+\n+public class TestAnfBasicFuns {\n+\n+    @CodeReflection\n+    public static int test2(int arg1, int arg2) {\n+        if (arg1 > arg2) {\n+            return arg1 + 21;\n+        } else {\n+            return arg2 + 42;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        testRun(\"test2\", List.of(int.class, int.class), 20, 1);\n+\n+    }\n+\n+    private static void testRun(String methodName, List<Class<?>> params, Object...args) {\n+        try {\n+            Class<TestAnfBasicFuns> clazz = TestAnfBasicFuns.class;\n+            Method method = clazz.getDeclaredMethod(methodName,params.toArray(new Class[params.size()]));\n+            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+\n+            \/\/Ensure we're fully lowered before testing.\n+            var fz = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+            fz = SSA.transform(fz);\n+            fz = NormalizeBlocksTransformer.transform(fz);\n+\n+            System.out.println(fz.toText());\n+\n+            var res = new AnfTransformer(fz).transform();\n+            System.out.println(\"---------------------\");\n+            System.out.println(res.toText());\n+\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfBasicFuns.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main TestAnfTransform\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.AnfTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+public class TestAnfTransform {\n+\n+    @CodeReflection\n+    public static int fibonacci(int v) {\n+        if (v == 0) {\n+            return 0;\n+        } else if (v == 1) {\n+            return 1;\n+        }\n+\n+        v = v - 2;\n+        int s1, s2, t;\n+        s1 = 0;\n+        s2 = 1;\n+\n+        while(v > 0) {\n+            t = s1 + s2;\n+            s1 = s2;\n+            s2 = t;\n+            v--;\n+        }\n+\n+        return s1 + s2;\n+\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        testRun(\"fibonacci\", List.of(int.class), 20);\n+\n+    }\n+\n+    private static void testRun(String methodName, List<Class<?>> params, Object...args) {\n+        try {\n+            Class<TestAnfTransform> clazz = TestAnfTransform.class;\n+            Method method = clazz.getDeclaredMethod(methodName,params.toArray(new Class[params.size()]));\n+            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+\n+            \/\/Ensure we're fully lowered before testing.\n+            var fz = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+            fz = SSA.transform(fz);\n+            fz = NormalizeBlocksTransformer.transform(fz);\n+\n+            System.out.println(fz.toText());\n+\n+            var res = new AnfTransformer(fz).transform();\n+            System.out.println(\"---------------------\");\n+            System.out.println(res.toText());\n+\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfTransform.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}