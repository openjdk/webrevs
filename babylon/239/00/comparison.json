{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Parameter;\n@@ -586,1 +587,25 @@\n-        } else {\n+        } else if (o instanceof CoreOp.IfExp e) {\n+            var testResult = (boolean) oc.getValue(e.getTest());\n+            if (testResult) {\n+                throw new UnsupportedOperationException();\n+                \/\/return interpretBody(l, e.thenBody(), oc);\n+            } else {\n+                throw new UnsupportedOperationException();\n+                \/\/return interpretBody(l, e.elseBody(), oc);\n+            }\n+        } else if (o instanceof CoreOp.LetExp e) {\n+           \/\/List<Object> evaluatedBindings = e.letBindings.stream().map(b -> interpretBody(l,b,oc)).toList();\n+           \/\/Body exprBody = e.letExp;\n+           \/\/return invoke(l, exprBody.entryBlock(), Map.of(), oc, evaluatedBindings);\n+           return null;\n+        } else if (o instanceof CoreOp.LetRecExp e) {\n+           List<Object> functionBindings = e.functions.stream().map(Object.class::cast).toList();\n+           Op exprBody = e.expBody;\n+           \/\/return invoke(l, exprBody.entryBlock(), Map.of(), oc, functionBindings);\n+           return null;\n+        } else if (o instanceof CoreOp.FunApp e) {\n+            var funOp = (CoreOp.FuncOp) oc.getValue(e.funOp());\n+            var funCallOp = CoreOp.funcCall(funOp,e.args());\n+            return exec(l,oc,funCallOp);\n+        }\n+        else {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.jar.Attributes;\n+import java.util.stream.IntStream;\n@@ -2650,0 +2652,174 @@\n+    \/\/ANF-style operations\n+    @OpFactory.OpDeclaration(IfExp.NAME)\n+    public static final class IfExp extends CoreOp implements Op.Terminating {\n+        public static final String NAME = \"if\";\n+\n+        final private Body _then, _else;\n+\n+        public IfExp(IfExp that, CopyContext cc) {\n+            super(that, cc);\n+            this._then = that._then;\n+            this._else = that._else;\n+        }\n+\n+        public IfExp(Value test, Body thn, Body els) {\n+            super(IfExp.NAME, List.of(test));\n+            this._then = thn;\n+            this._else = els;\n+        }\n+\n+        public IfExp(ExternalizedOp def) {\n+            super(def);\n+            if (def.operands().size() == 1) {\n+                throw new IllegalArgumentException(\"IfExp operation must have one operand.\");\n+            }\n+            this._then = def.bodyDefinitions().get(0).build(this);\n+            this._else = def.bodyDefinitions().get(1).build(this);\n+        }\n+\n+        public Value getTest() {\n+            return this.operands().get(0);\n+        }\n+\n+        public Body _then() {\n+            return this.bodies().get(0);\n+        }\n+\n+        public Body _else() {\n+            return this.bodies().get(1);\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new IfExp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this._then.bodyType().returnType();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(LetExp.NAME)\n+    public static final class LetExp extends CoreOp implements Op.Lowerable, Op.Terminating {\n+        public static final String NAME = \"let\";\n+\n+        public final Body bindingsExp;\n+\n+        public LetExp(LetExp that, CopyContext cc) {\n+            super(that, cc);\n+            this.bindingsExp = that.bindingsExp;\n+        }\n+\n+        public LetExp(ExternalizedOp def) {\n+            super(def);\n+            if (def.operands().size() != 1) {\n+               throw new IllegalStateException(\"LetExp operation must have one body.\");\n+            }\n+            this.bindingsExp = def.bodyDefinitions().get(0).build(this);\n+        }\n+\n+        public LetExp(Body b) {\n+            super(NAME, List.of());\n+            this.bindingsExp = b;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new LetExp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.bindingsExp.bodyType().returnType();\n+        }\n+\n+        @Override\n+        public Block.Builder lower(Block.Builder b, OpTransformer opT) {\n+            return null;\n+        }\n+    }\n+\n+\n+    @OpFactory.OpDeclaration(LetRecExp.NAME)\n+    public static final class LetRecExp extends CoreOp implements Op.Terminating {\n+        public static final String NAME = \"letrec\";\n+\n+        public final List<FuncOp> functions;\n+        public final Op expBody;\n+\n+        public LetRecExp(LetRecExp that, CopyContext cc) {\n+            super(that, cc);\n+            this.functions = that.functions;\n+            this.expBody = that.expBody;\n+        }\n+\n+        public LetRecExp(ExternalizedOp def) {\n+            super(def);\n+\n+            List<Body.Builder> fbodies = def.bodyDefinitions().subList(0, def.bodyDefinitions().size() - 1);\n+            this.functions = fbodies.stream().map(b -> new FuncOp(\"anon\", b)).toList();\n+            this.expBody = (Op) def.attributes().get(\"expBody\");\n+        }\n+\n+        public LetRecExp(List<FuncOp> funcs, Op expBody) {\n+            super(LetRecExp.NAME, List.of());\n+            this.functions = funcs;\n+            this.expBody = expBody;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new LetRecExp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.expBody.resultType();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(FunApp.NAME)\n+    public static final class FunApp extends CoreOp implements Op.Terminating {\n+        public static final String NAME = \"funapp\";\n+\n+        private final TypeElement resultType;\n+        private final Object name;\n+\n+        public FunApp(FunApp that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+            this.name = that.name;\n+        }\n+\n+        public FunApp(ExternalizedOp def) {\n+            super(def);\n+            this.resultType = def.resultType();\n+            this.name = def.attributes().get(\"name\");\n+        }\n+\n+        public FunApp(Object name, List<Value> arguments, TypeElement resultType) {\n+            super(FunApp.NAME, arguments);\n+            this.resultType = resultType;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new FunApp(this, cc);\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.resultType;\n+        }\n+\n+        public Value funOp() {\n+            return this.operands().get(0);\n+        }\n+\n+        public List<Value> args() {\n+            return this.operands().subList(1, this.operands().size());\n+        }\n+    }\n+\n@@ -4197,0 +4373,18 @@\n+\n+    \/\/ANF-style extension constructors\n+\n+    public static FunApp funApp(Object name, List<Value> args, TypeElement returnType) {\n+        return new FunApp(name, args, returnType);\n+    }\n+\n+    public static IfExp ifExp(Value test, Op _then, Op _else) {\n+        return new IfExp(test, _then, _else);\n+    }\n+\n+    public static LetExp letExp(Block bindings, Op expBody) {\n+        return new LetExp(bindings, expBody);\n+    }\n+\n+    public static LetRecExp letRecExp(List<FuncOp> funcOps, Op expBody) {\n+        return new LetRecExp(funcOps, expBody);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"modified"}]}