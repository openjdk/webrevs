{"files":[{"patch":"@@ -0,0 +1,419 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect.code.analysis;\n+\n+import java.lang.reflect.code.*;\n+import java.lang.reflect.code.op.AnfDialect;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.util.*;\n+import java.util.function.Function;\n+\n+public class AnfTransformer {\n+\n+    final CoreOp.FuncOp sourceOp;\n+    final Map<Block, Function<Body.Builder, AnfDialect.AnfFuncOp>> fBuilders = new HashMap<>();\n+    final Body.Builder outerBodyBuilder;\n+    final ImmediateDominatorMap idomMap;\n+    final Map<String, Value> funMap = new HashMap<>();\n+    final Map<String, AnfDialect.AnfApply> appMap = new HashMap<>();\n+\n+    public AnfTransformer(CoreOp.FuncOp funcOp) {\n+        sourceOp = funcOp;\n+        outerBodyBuilder = Body.Builder.of(null, funcOp.invokableType());\n+        idomMap = new ImmediateDominatorMap(funcOp.body());\n+    }\n+\n+    public AnfDialect.AnfFuncOp transform() {\n+        return transformOuterBody(sourceOp.body());\n+    }\n+\n+    \/\/Outer body corresponds to outermost letrec\n+    \/\/F_p\n+    public AnfDialect.AnfFuncOp transformOuterBody(Body b) {\n+        var entry = b.entryBlock();\n+\n+        var builderEntry = outerBodyBuilder.entryBlock();\n+\n+        for (Block.Parameter p : entry.parameters()) {\n+            var newP = builderEntry.parameter(p.type());\n+            builderEntry.context().mapValue(p,newP);\n+        }\n+\n+        var outerLetRecBody = Body.Builder.of(outerBodyBuilder, FunctionType.functionType(b.yieldType(), List.of()), CopyContext.create(builderEntry.context()));\n+\n+        List<Block> dominatedBlocks = idomMap.idominates(entry);\n+        List<AnfDialect.AnfFuncOp> funs = dominatedBlocks.stream().map(block -> transformBlock(block, outerLetRecBody)).toList();\n+\n+        \/\/Remove ApplyStubs\n+        var res = transformBlock(entry, outerLetRecBody);\n+\n+        \/\/var transformContext = CopyContext.create();\n+        \/\/for (Value v : funMap.values()) {\n+        \/\/    transformContext.mapValue(v,v);\n+        \/\/}\n+        \/\/res = res.transform(transformContext, new ApplyStubTransformer());\n+\n+        return res;\n+\n+    }\n+\n+    public AnfDialect.AnfFuncOp transformBlock(Block b, Body.Builder bodyBuilder) {\n+        if (idomMap.idominates(b).isEmpty()) {\n+            return transformLeafBlock(b, bodyBuilder);\n+        }\n+        return transformDomBlock(b, bodyBuilder);\n+    }\n+\n+    \/\/\"Leaf\" in this case is a leaf of the dominator tree\n+    public AnfDialect.AnfFuncOp transformLeafBlock(Block b, Body.Builder ancestorBodyBuilder) {\n+        var blockParamTypes = b.parameters().stream().map(Value::type).toList();\n+        var blockReturnType = getBlockReturnType(b);\n+        var blockFType = FunctionType.functionType(blockReturnType, blockParamTypes);\n+\n+        Body.Builder newBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFType, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+        for (Block.Parameter param : b.parameters()) {\n+            var p = newBodyBuilder.entryBlock().parameter(param.type());\n+            newBodyBuilder.entryBlock().context().mapValue(param, p);\n+        }\n+\n+\n+        var letBody = Body.Builder.of(newBodyBuilder, FunctionType.functionType(blockReturnType, List.of()), CopyContext.create(newBodyBuilder.entryBlock().context()));\n+\n+        AnfDialect.AnfLetOp let = transformOps(b, letBody);\n+        newBodyBuilder.entryBlock().op(let);\n+        return AnfDialect.func(b.toString(), newBodyBuilder);\n+    }\n+\n+    \/\/Non leaf nodes of the dominator tree\n+    public AnfDialect.AnfFuncOp transformDomBlock(Block b, Body.Builder ancestorBodyBuilder) {\n+        \/\/This block dominates another block, and will return a function containing a letrec structure\n+        var blockParamTypes = b.parameters().stream().map(Value::type).toList();\n+        var blockReturnType = getBlockReturnType(b);\n+        var blockFType = FunctionType.functionType(blockReturnType, blockParamTypes);\n+\n+        \/\/Function body contains letrec and its bodies\n+        Body.Builder funcBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFType, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+\n+        for (Block.Parameter param : b.parameters()) {\n+            var p = funcBodyBuilder.entryBlock().parameter(param.type());\n+            funcBodyBuilder.entryBlock().context().mapValue(param, p);\n+        }\n+\n+        \/\/letrec inner body\n+        Body.Builder letrecBody = Body.Builder.of(funcBodyBuilder, FunctionType.functionType(blockReturnType, List.of()), CopyContext.create(funcBodyBuilder.entryBlock().context()));\n+\n+        List<Block> dominates = idomMap.idominates(b);\n+        List<AnfDialect.AnfFuncOp> funs = new ArrayList<>();\n+                \/\/dominates.stream().map((block) -> transformDomBlock(block, letrecBody)).toList();\n+        for (Block dblock : dominates) {\n+           var res = transformDomBlock(dblock, letrecBody);\n+           funs.add(res);\n+        }\n+\n+        Block.Builder blockBuilder = letrecBody.entryBlock();\n+\n+        for (AnfDialect.AnfFuncOp f : funs) {\n+            var res = blockBuilder.op(f);\n+            this.funMap.put(f.funcName(), res);\n+        }\n+\n+        AnfDialect.AnfLetOp let = transformOps(b, letrecBody);\n+        funcBodyBuilder.entryBlock().op(let);\n+        return AnfDialect.func(b.toString(), funcBodyBuilder);\n+\n+    }\n+\n+    private TypeElement getBlockReturnType(Block b) {\n+        var ops = b.ops().iterator();\n+        while(ops.hasNext()) {\n+            var op = ops.next();\n+            if (op instanceof Op.Terminating) {\n+                List<Block.Reference> destBlocks = new ArrayList<>();\n+                if (op instanceof CoreOp.ReturnOp || op instanceof CoreOp.YieldOp) {\n+                    return op.resultType();\n+                } else if (op instanceof CoreOp.BranchOp bop) {\n+                    destBlocks.addAll(bop.successors());\n+                } else if (op instanceof CoreOp.ConditionalBranchOp cbop) {\n+                    destBlocks.addAll(cbop.successors());\n+                }\n+                \/\/Traverse until we find a yield or return type, TODO: not going to try to unify types\n+\n+                Set<Block> visitedBlocks = new HashSet<>();\n+                visitedBlocks.add(b);\n+\n+                while (!destBlocks.isEmpty()) {\n+                    var block = destBlocks.removeFirst().targetBlock();\n+                    if (visitedBlocks.contains(block)) {\n+                        continue;\n+                    }\n+\n+                    \/\/Discovered a terminator with a return value, use its type\n+                    if (block.successors().isEmpty()) {\n+                        return block.ops().getLast().resultType();\n+                    } else {\n+                        visitedBlocks.add(block);\n+                        var newDests = block.successors().stream().filter((s) -> !visitedBlocks.contains(s.targetBlock())).toList();\n+                        destBlocks.addAll(newDests);\n+                    }\n+                }\n+\n+            }\n+        }\n+        throw new RuntimeException(\"Encountered Block with no return\");\n+    }\n+\n+    private Block.Builder transformEndOp(Block.Builder b, Op op) {\n+        if (op instanceof Op.Terminating t) {\n+            switch (t) {\n+                case CoreOp.ConditionalBranchOp c -> {\n+                    var tbranch_args = c.trueBranch().arguments();\n+                    tbranch_args = tbranch_args.stream().map(b.context()::getValue).toList();\n+                    var fbranch_args = c.falseBranch().arguments();\n+                    fbranch_args = fbranch_args.stream().map(b.context()::getValue).toList();\n+\n+                    var trueFuncName = CoreOp.constant(JavaType.J_L_STRING, c.trueBranch().targetBlock().toString());\n+                    var falseFuncName = CoreOp.constant(JavaType.J_L_STRING, c.falseBranch().targetBlock().toString());\n+                    var trueFuncVal = b.op(trueFuncName);\n+                    var falseFuncVal = b.op(falseFuncName);\n+\n+                    List<Value> trueArgs = new ArrayList<>();\n+                    \/\/trueArgs.add(funMap.get(c.trueBranch().targetBlock().toString()));\n+                    trueArgs.addAll(tbranch_args);\n+\n+                    List<Value> falseArgs = new ArrayList<>();\n+                    \/\/falseArgs.add(get(c.falseBranch().targetBlock().toString()));\n+                    falseArgs.addAll(fbranch_args);\n+\n+\n+                    var trueApp = AnfDialect.applyStub(c.trueBranch().targetBlock().toString(), trueArgs, getBlockReturnType(c.trueBranch().targetBlock()));\n+                    var falseApp = AnfDialect.applyStub(c.falseBranch().targetBlock().toString(), falseArgs, getBlockReturnType(c.falseBranch().targetBlock()));\n+\n+                    var ifExp = AnfDialect.if_(b.parentBody(),\n+                            c.trueBranch().targetBlock().terminatingOp().resultType(),\n+                            b.context().getValue(c.predicate()))\n+                        .if_((bodyBuilder) -> bodyBuilder.op(trueApp))\n+                        .else_((bodyBuilder) -> bodyBuilder.op(falseApp));\n+\n+                    b.op(ifExp);\n+\n+                    return b;\n+                }\n+                case CoreOp.BranchOp br -> {\n+                    var args = br.branch().arguments().stream().toList();\n+                    args = args.stream().map(b.context()::getValue).toList();\n+                    \/\/var targetFuncConst = CoreOp.constant(JavaType.J_L_STRING, br.branch().targetBlock().toString());\n+                    \/\/var targetFuncVal = b.op(targetFuncConst);\n+\n+                    List<Value> funcArgs = new ArrayList<>();\n+                    \/\/funcArgs.add(funMap.get(br.branch().targetBlock().toString()));\n+                    funcArgs.addAll(args);\n+\n+                    var funcApp = AnfDialect.applyStub(br.branch().targetBlock().toString(), funcArgs, getBlockReturnType(br.branch().targetBlock()));\n+\n+                    b.op(funcApp);\n+                    return b;\n+                }\n+                case CoreOp.ReturnOp ro -> {\n+                    var rval = b.context().getValue(ro.returnValue());\n+                    b.op(CoreOp._yield(rval));\n+                    return b;\n+                }\n+                case CoreOp.YieldOp y ->  {\n+                    var rval = b.context().getValue(y.yieldValue());\n+                    b.op(CoreOp._yield(rval));\n+                    return b;\n+                }\n+                default -> {\n+                    throw new UnsupportedOperationException(\"Unsupported terminating op encountered: \" + op);\n+                }\n+            }\n+        } else {\n+            b.op(op);\n+            return b;\n+        }\n+    }\n+\n+    public AnfDialect.AnfLetOp transformOps(Block b, Body.Builder bodyBuilder) {\n+        Block.Builder blockb = bodyBuilder.entryBlock();\n+        return transformOps(b, blockb);\n+    }\n+\n+    public AnfDialect.AnfLetOp transformOps(Block b, Block.Builder blockBuilder) {\n+        for (var op : b.ops()) {\n+            transformEndOp(blockBuilder, op);\n+        }\n+        return AnfDialect.let(blockBuilder.parentBody());\n+    }\n+\n+    \/*\n+    private Map<Block, AnfDialect.AnfFuncOp> letRecConstruction(Body b, Body.Builder bodyBuilder) {\n+        List<Block> workQueue = new LinkedList<>(processedFunctions.keySet().stream().map(Block::immediateDominator).toList());\n+        Set<Block> processed = new HashSet<>(processedFunctions.keySet());\n+        processed.add(b.entryBlock());\n+\n+        while (!workQueue.isEmpty()) {\n+            Block workBlock = workQueue.removeFirst();\n+\n+            if (workBlock == null || processed.contains(workBlock)) {\n+                continue;\n+            }\n+\n+            \/\/Ugly slow. Blocks dominated by this one.\n+            var domBlocks = b.blocks().stream().filter((block) -> block.immediateDominator() != null && block.immediateDominator().equals(workBlock)).toList();\n+\n+            var unProcessedDomBlocks = domBlocks.stream().filter((block) -> !processedFunctions.containsKey(block)).toList();\n+\n+            \/\/If all dependencies aren't processed, queue them in front, requeue, and continue\n+            if (!unProcessedDomBlocks.isEmpty()) {\n+                unProcessedDomBlocks.forEach(workQueue::addLast);\n+                workQueue.addLast(workBlock);\n+                continue;\n+            }\n+\n+            List<AnfDialect.AnfFuncOp> funcs = domBlocks.stream().map(processedFunctions::get).toList();\n+\n+\n+            \/\/var letrecBodyBuilder = Body.Builder.of(bodyBuilder,FunctionType.VOID); \/\/TODO: Solve Void Type\n+            var letrecBuilder = AnfDialect.letrec(bodyBuilder, FunctionType.VOID); \/\/ TODO: Solve Void Type\n+\n+            var letRec = letrecBuilder.body(block -> {\n+                \/\/Define the functions\n+                for (var func : funcs) {\n+                    block.op(func);\n+                }\n+                \/\/LetRec \"in\" Body here\n+                transformOps(workBlock, block);\n+            });\n+\n+\n+            \/\/var paramTys = workBlock.parameters().stream().map(Block.Parameter::type).toList();\n+            var funBuilder = AnfDialect.func(bodyBuilder,workBlock.toString(),bodyBuilder.bodyType());\n+            var fun = funBuilder.body(c -> c.op(letRec));\n+\n+            processedFunctions.put(workBlock,fun);\n+        }\n+\n+        return processedFunctions;\n+    }\n+\n+    public AnfDialect.AnfFuncOp funcConstructor(Block b, Body.Builder ancestorBody)\n+\n+    private void leafFunctions(Body b) {\n+        List<Block> leafBlocks = leafBlocks(b);\n+        \/\/HashMap<Block, AnfDialect.AnfFuncOp> functions = new HashMap<>();\n+\n+        for (Block leafBlock : leafBlocks) {\n+            Function<Body.Builder, AnfDialect.AnfFuncOp> fBuilder = (Body.Builder bodyBuilder) -> transformBlock(leafBlock, bodyBuilder);\n+            funcOps.put(leafBlock, fBuilder);\n+        }\n+    }\n+\n+    private static List<Block> leafBlocks(Body b) {\n+        var idoms = b.immediateDominators();\n+        HashSet<Block> leafBlocks = new HashSet<>(b.blocks());\n+        leafBlocks.remove(b.entryBlock());\n+        b.blocks().forEach((block) -> {\n+            var dom = idoms.get(block);\n+            \/\/Remove all blocks that dominate other blocks.\n+            if (dom != null) {\n+                leafBlocks.remove(dom);\n+            }\n+        });\n+        \/\/Return blocks that dominate nothing. These are leaves.\n+        return leafBlocks.stream().toList();\n+    }\n+*\/\n+    static class ImmediateDominatorMap {\n+\n+        private final Map <Block, List<Block>> dominatesMap;\n+        private final Map <Block, Block> dominatorsMap;\n+\n+        public ImmediateDominatorMap(Body b) {\n+            dominatorsMap = b.immediateDominators();\n+            dominatesMap = new HashMap<>();\n+\n+            \/\/Reverse the idom relation\n+            b.immediateDominators().forEach((dominated, dominator) -> {\n+               if (!dominated.equals(dominator)) {\n+                   dominatesMap.compute(dominator, (k, v) -> {\n+                       if (v == null) {\n+                           var newList = new ArrayList<Block>();\n+                           newList.add(dominated);\n+                           return newList;\n+                       } else {\n+                           v.add(dominated);\n+                           return v;\n+                       }\n+                   });\n+               }\n+            });\n+\n+        }\n+\n+        \/\/Looks \"down\" the dominator tree toward leaves\n+        public List<Block> idominates(Block b) {\n+            return dominatesMap.getOrDefault(b, List.of());\n+        }\n+\n+        \/\/Looks \"up\" the dominator tree toward start node\n+        public Block idominatedBy(Block b) {\n+            return dominatorsMap.get(b);\n+        }\n+    }\n+\n+    class ApplyStubTransformer implements OpTransformer {\n+\n+        \/\/public Map<String, Value> fmap = new HashMap<>();\n+\n+        @Override\n+        public Block.Builder apply(Block.Builder builder, Op op) {\n+            switch (op) {\n+\n+                \/*\n+                case AnfDialect.AnfFuncOp af -> {\n+                    var name = af.funcName();\n+                    var val = builder.op(af);\n+                    fmap.put(name, val);\n+                }\n+                 *\/\n+                case AnfDialect.AnfApplyStub as -> {\n+                    var name = as.callSiteName;\n+                    var args = as.args();\n+                    List<Value> newArgs = new ArrayList<>();\n+                    newArgs.add(funMap.get(name));\n+                    newArgs.addAll(args);\n+                    builder.op(AnfDialect.apply(newArgs));\n+                }\n+                default -> {\n+                    builder.op(op);\n+                }\n+            }\n+            return builder;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/AnfTransformer.java","additions":419,"deletions":0,"binary":false,"changes":419,"status":"added"},{"patch":"@@ -398,0 +398,63 @@\n+    @OpFactory.OpDeclaration(AnfApplyStub.NAME)\n+    public static final class AnfApplyStub extends ExternalizableOp implements Op.Terminating {\n+        public static final String NAME = \"anf.apply.stub\";\n+        public static final String ATTRIBUTE_RESULT_TYPE = \".resultType\";\n+        public static final String ATTRIBUTE_CALLSITE_NAME = \".callsiteName\";\n+\n+        public final TypeElement resultType;\n+        public final String callSiteName;\n+\n+        public static AnfApplyStub create(ExternalizedOp def) {\n+            if (!def.operands().isEmpty()) {\n+                throw new IllegalStateException(\"Bad op \" + def.name());\n+            }\n+\n+            TypeElement resultType = def.extractAttributeValue(ATTRIBUTE_RESULT_TYPE, true,\n+                    v -> switch (v) {\n+                        case TypeElement s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            String callsiteName = def.extractAttributeValue(ATTRIBUTE_CALLSITE_NAME, true,\n+                    v -> switch (v) {\n+                        case String s -> s;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported func name value:\" + v);\n+                    });\n+            return new AnfApplyStub(def, callsiteName, resultType);\n+        }\n+\n+        public AnfApplyStub(ExternalizedOp def, String name, TypeElement resultType) {\n+            super(def);\n+            this.resultType = resultType;\n+            this.callSiteName = name;\n+        }\n+\n+        public AnfApplyStub(AnfApplyStub that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+            this.callSiteName = that.callSiteName;\n+        }\n+\n+\n+        @Override\n+        public Op transform(CopyContext cc, OpTransformer ot) {\n+            return new AnfApplyStub(this, cc);\n+        }\n+\n+        public AnfApplyStub(String callSiteName, List<Value> arguments, TypeElement resultType) {\n+            super(AnfApplyStub.NAME, arguments);\n+            this.resultType = resultType;\n+            this.callSiteName = callSiteName;\n+\n+            \/\/ First argument is func value\n+            \/\/ Subsequent arguments are func arguments\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return this.resultType;\n+        }\n+\n+        public List<Value> args() {\n+            return operands().subList(1, this.operands().size());\n+        }\n+    }\n@@ -437,0 +500,1 @@\n+    public static AnfApplyStub applyStub(String name, List<Value> arguments, TypeElement type) { return new AnfApplyStub(name, arguments, type);}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/AnfDialect.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.code.analysis.AnfTransformer;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+public class TestAnfTransform {\n+\n+    @CodeReflection\n+    public static int test1(int arg1, int arg2) {\n+       return arg1 + arg2 - 52;\n+    }\n+\n+    @CodeReflection\n+    public static int test2(int arg1, int arg2) {\n+        if (arg1 > arg2) {\n+            return arg1 + 21;\n+        } else {\n+            return arg2 + 42;\n+        }\n+    }\n+\n+    @CodeReflection\n+    public static int fibonacci(int v) {\n+        if (v == 0) {\n+            return 0;\n+        } else if (v == 1) {\n+            return 1;\n+        }\n+\n+        v = v - 2;\n+        int s1, s2, t;\n+        s1 = 0;\n+        s2 = 1;\n+\n+        while(v > 0) {\n+            t = s1 + s2;\n+            s1 = s2;\n+            s2 = t;\n+            v--;\n+        }\n+\n+        return s1 + s2;\n+\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        \/\/testRun(\"test2\", List.of(int.class, int.class), 20, 1);\n+        testRun(\"fibonacci\", List.of(int.class), 20);\n+\n+    }\n+\n+    private static void testRun(String methodName, List<Class<?>> params, Object...args) {\n+        try {\n+            Class<TestAnfTransform> clazz = TestAnfTransform.class;\n+            Method method = clazz.getDeclaredMethod(methodName,params.toArray(new Class[params.size()]));\n+            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+\n+            \/\/Ensure we're fully lowered before testing.\n+            var fz = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+            fz = SSA.transform(fz);\n+\n+            System.out.println(fz.toText());\n+\n+            var res = new AnfTransformer(fz).transform();\n+            \/\/var labeled = new Labeler().label(res);\n+            \/\/p.print(res);\n+            \/\/p.print(labeled);\n+\n+            System.out.println(\"---------------------\");\n+            System.out.println(res.toText());\n+\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAnfTransform.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}