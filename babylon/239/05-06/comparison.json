{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.reflect.code.type.JavaType;\n@@ -44,0 +43,1 @@\n+    final Map<Block, Value> funMap2 = new HashMap<>();\n@@ -47,1 +47,1 @@\n-        outerBodyBuilder = Body.Builder.of(null, funcOp.invokableType());\n+        outerBodyBuilder = Body.Builder.of(null, FunctionType.functionType(funcOp.body().yieldType()));\n@@ -62,0 +62,3 @@\n+        var selfRefP = builderEntry.parameter(((CoreOp.FuncOp) b.parentOp()).invokableType());\n+        funMap.put(entry, selfRefP);\n+\n@@ -72,1 +75,0 @@\n-        \/\/Remove ApplyStubs\n@@ -74,7 +76,0 @@\n-\n-        \/\/var transformContext = CopyContext.create();\n-        \/\/for (Value v : funMap.values()) {\n-        \/\/    transformContext.mapValue(v,v);\n-        \/\/}\n-        \/\/res = res.transform(transformContext, new ApplyStubTransformer());\n-\n@@ -94,1 +89,0 @@\n-        var blockParamTypes = b.parameters().stream().map(Value::type).toList();\n@@ -96,1 +90,4 @@\n-        var blockFType = FunctionType.functionType(blockReturnType, blockParamTypes);\n+        var blockFType = FunctionType.functionType(blockReturnType);\n+\n+        List<TypeElement> synthParamTypes = new ArrayList<>();\n+        synthParamTypes.add(blockFType);\n@@ -98,1 +95,1 @@\n-        Body.Builder newBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFType, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+        var blockFTypeSynth = FunctionType.functionType(blockReturnType, synthParamTypes);\n@@ -100,1 +97,3 @@\n-        var selfRefParam = newBodyBuilder.entryBlock().parameter(blockFType);\n+        Body.Builder newBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFTypeSynth, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+\n+        var selfRefParam = newBodyBuilder.entryBlock().parameters().get(0);\n@@ -108,1 +107,0 @@\n-\n@@ -118,2 +116,0 @@\n-        \/\/This block dominates another block, and will return a function containing a letrec structure\n-        var blockParamTypes = b.parameters().stream().map(Value::type).toList();\n@@ -121,1 +117,6 @@\n-        var blockFType = FunctionType.functionType(blockReturnType, blockParamTypes);\n+        var blockFType = FunctionType.functionType(blockReturnType);\n+\n+        List<TypeElement> synthParamTypes = new ArrayList<>();\n+        synthParamTypes.add(blockFType);\n+\n+        var blockFTypeSynth = FunctionType.functionType(blockReturnType, synthParamTypes);\n@@ -124,1 +125,1 @@\n-        Body.Builder funcBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFType, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n+        Body.Builder funcBodyBuilder = Body.Builder.of(ancestorBodyBuilder, blockFTypeSynth, CopyContext.create(ancestorBodyBuilder.entryBlock().context()));\n@@ -127,1 +128,1 @@\n-        var selfRefParam = funcBodyBuilder.entryBlock().parameter(blockFType);\n+        var selfRefParam = funcBodyBuilder.entryBlock().parameters().get(0);\n@@ -139,2 +140,0 @@\n-        List<AnfDialect.AnfFuncOp> funs = new ArrayList<>();\n-        \/\/dominates.stream().map((block) -> transformDomBlock(block, letrecBody)).toList();\n@@ -143,1 +142,2 @@\n-            funs.add(res);\n+            var fval = letrecBody.entryBlock().op(res);\n+            funMap2.put(dblock, fval);\n@@ -146,2 +146,0 @@\n-        Block.Builder blockBuilder = letrecBody.entryBlock();\n-\n@@ -215,5 +213,0 @@\n-                    var trueFuncName = CoreOp.constant(JavaType.J_L_STRING, c.trueBranch().targetBlock().toString());\n-                    var falseFuncName = CoreOp.constant(JavaType.J_L_STRING, c.falseBranch().targetBlock().toString());\n-                    var trueFuncVal = b.op(trueFuncName);\n-                    var falseFuncVal = b.op(falseFuncName);\n-\n@@ -221,1 +214,0 @@\n-                    trueArgs.add(funMap.get(c.trueBranch().targetBlock()));\n@@ -225,1 +217,0 @@\n-                    falseArgs.add(funMap.get(c.falseBranch().targetBlock()));\n@@ -228,2 +219,0 @@\n-                    var trueApp = AnfDialect.apply(trueArgs);\n-                    var falseApp = AnfDialect.apply(falseArgs);\n@@ -232,1 +221,1 @@\n-                                    c.trueBranch().targetBlock().terminatingOp().resultType(),\n+                                    getBlockReturnType(c.trueBranch().targetBlock()),\n@@ -234,2 +223,2 @@\n-                            .if_((bodyBuilder) -> bodyBuilder.op(trueApp))\n-                            .else_((bodyBuilder) -> bodyBuilder.op(falseApp));\n+                            .if_((bodyBuilder) -> bindFunApp(bodyBuilder, trueArgs, c.trueBranch().targetBlock()))\n+                            .else_((bodyBuilder) -> bindFunApp(bodyBuilder, falseArgs, c.falseBranch().targetBlock()));\n@@ -242,1 +231,1 @@\n-                    var args = br.branch().arguments().stream().toList();\n+                    var args = br.branch().arguments();\n@@ -244,2 +233,0 @@\n-                    \/\/var targetFuncConst = CoreOp.constant(JavaType.J_L_STRING, br.branch().targetBlock().toString());\n-                    \/\/var targetFuncVal = b.op(targetFuncConst);\n@@ -248,1 +235,0 @@\n-                    funcArgs.add(funMap.get(br.branch().targetBlock()));\n@@ -250,0 +236,1 @@\n+                    bindFunApp(b, funcArgs, br.branch().targetBlock());\n@@ -251,3 +238,0 @@\n-                    var funcApp = AnfDialect.apply(funcArgs);\n-\n-                    b.op(funcApp);\n@@ -276,0 +260,23 @@\n+\n+    private void bindFunApp(Block.Builder b, List<Value> args, Block target) {\n+\n+        List<Value> synthArgs = new ArrayList<>();\n+        synthArgs.addAll(args);\n+        synthArgs.addFirst(funMap.get(target));\n+        try {\n+            b.op(AnfDialect.apply(synthArgs));\n+            return;\n+        } catch (IllegalStateException e) {}\n+\n+        synthArgs.removeFirst();\n+        synthArgs.addFirst(funMap2.get(target));\n+\n+        try {\n+            b.op(AnfDialect.apply(synthArgs));\n+        } catch (IllegalStateException e) {\n+            throw new IllegalStateException(\"No valid mapping to FuncOp for apply\");\n+        }\n+\n+    }\n+\n+\n@@ -329,31 +336,0 @@\n-\n-    class ApplyStubTransformer implements OpTransformer {\n-\n-        \/\/public Map<String, Value> fmap = new HashMap<>();\n-\n-        @Override\n-        public Block.Builder apply(Block.Builder builder, Op op) {\n-            switch (op) {\n-\n-                \/*\n-                case AnfDialect.AnfFuncOp af -> {\n-                    var name = af.funcName();\n-                    var val = builder.op(af);\n-                    fmap.put(name, val);\n-                }\n-                 *\/\n-                case AnfDialect.AnfApplyStub as -> {\n-                    var name = as.callSiteName;\n-                    var args = as.args();\n-                    List<Value> newArgs = new ArrayList<>();\n-                    newArgs.add(funMap.get(name));\n-                    newArgs.addAll(args);\n-                    builder.op(AnfDialect.apply(newArgs));\n-                }\n-                default -> {\n-                    builder.op(op);\n-                }\n-            }\n-            return builder;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/AnfTransformer.java","additions":51,"deletions":75,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-        params.add(funcType);\n+        params.add(funcType.returnType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/AnfDialect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.OpTransformer;\n+import java.lang.reflect.code.analysis.AnfTransformer;\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n+import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.runtime.CodeReflection;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @run main TestAnfBasicFuns\n+ *\/\n+\n+public class TestAnfBasicFuns {\n+\n+    @CodeReflection\n+    public static int test2(int arg1, int arg2) {\n+        if (arg1 > arg2) {\n+            return arg1 + 21;\n+        } else {\n+            return arg2 + 42;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        testRun(\"test2\", List.of(int.class, int.class), 20, 1);\n+\n+    }\n+\n+    private static void testRun(String methodName, List<Class<?>> params, Object...args) {\n+        try {\n+            Class<TestAnfBasicFuns> clazz = TestAnfBasicFuns.class;\n+            Method method = clazz.getDeclaredMethod(methodName,params.toArray(new Class[params.size()]));\n+            CoreOp.FuncOp f = method.getCodeModel().orElseThrow();\n+\n+            \/\/Ensure we're fully lowered before testing.\n+            var fz = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+            fz = SSA.transform(fz);\n+            fz = NormalizeBlocksTransformer.transform(fz);\n+\n+            System.out.println(fz.toText());\n+\n+            var res = new AnfTransformer(fz).transform();\n+            \/\/var labeled = new Labeler().label(res);\n+            \/\/p.print(res);\n+            \/\/p.print(labeled);\n+\n+            System.out.println(\"---------------------\");\n+            System.out.println(res.toText());\n+\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfBasicFuns.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -26,1 +26,4 @@\n-import java.lang.reflect.code.analysis.AnfTransformer;\n+\/*\n+ * @test\n+ * @run main TestAnfTransform\n+ *\/\n@@ -30,0 +33,1 @@\n+import java.lang.reflect.code.analysis.AnfTransformer;\n@@ -31,0 +35,1 @@\n+import java.lang.reflect.code.analysis.NormalizeBlocksTransformer;\n@@ -91,0 +96,1 @@\n+            fz = NormalizeBlocksTransformer.transform(fz);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/anf\/TestAnfTransform.java","additions":7,"deletions":1,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/lang\/reflect\/code\/TestAnfTransform.java","status":"renamed"}]}