{"files":[{"patch":"@@ -132,1 +132,1 @@\n-                \/\/dominates.stream().map((block) -> transformDomBlock(block, letrecBody)).toList();\n+        \/\/dominates.stream().map((block) -> transformDomBlock(block, letrecBody)).toList();\n@@ -134,2 +134,2 @@\n-           var res = transformDomBlock(dblock, letrecBody);\n-           funs.add(res);\n+            var res = transformDomBlock(dblock, letrecBody);\n+            funs.add(res);\n@@ -145,2 +145,8 @@\n-        AnfDialect.AnfLetOp let = transformOps(b, letrecBody);\n-        funcBodyBuilder.entryBlock().op(let);\n+        var letBody = Body.Builder.of(letrecBody, letrecBody.bodyType(), CopyContext.create(letrecBody.entryBlock().context()));\n+        transformBlockOps(b, letBody.entryBlock());\n+        var let = AnfDialect.let(letBody);\n+\n+        letrecBody.entryBlock().op(let);\n+\n+        var letrec = AnfDialect.letrec(letrecBody);\n+        funcBodyBuilder.entryBlock().op(letrec);\n@@ -152,13 +158,13 @@\n-        var ops = b.ops().iterator();\n-        while(ops.hasNext()) {\n-            var op = ops.next();\n-            if (op instanceof Op.Terminating) {\n-                List<Block.Reference> destBlocks = new ArrayList<>();\n-                if (op instanceof CoreOp.ReturnOp || op instanceof CoreOp.YieldOp) {\n-                    return op.resultType();\n-                } else if (op instanceof CoreOp.BranchOp bop) {\n-                    destBlocks.addAll(bop.successors());\n-                } else if (op instanceof CoreOp.ConditionalBranchOp cbop) {\n-                    destBlocks.addAll(cbop.successors());\n-                }\n-                \/\/Traverse until we find a yield or return type, TODO: not going to try to unify types\n+        var op = b.ops().getLast();\n+        if (op instanceof Op.Terminating) {\n+            List<Block.Reference> destBlocks = new ArrayList<>();\n+            if (op instanceof CoreOp.ReturnOp ro) {\n+                return ro.returnValue().type();\n+            } else if (op instanceof CoreOp.YieldOp yo) {\n+                return yo.yieldValue().type();\n+            } else if (op instanceof CoreOp.BranchOp bop) {\n+                destBlocks.addAll(bop.successors());\n+            } else if (op instanceof CoreOp.ConditionalBranchOp cbop) {\n+                destBlocks.addAll(cbop.successors());\n+            }\n+            \/\/Traverse until we find a yield or return type, TODO: not going to try to unify types\n@@ -166,2 +172,2 @@\n-                Set<Block> visitedBlocks = new HashSet<>();\n-                visitedBlocks.add(b);\n+            Set<Block> visitedBlocks = new HashSet<>();\n+            visitedBlocks.add(b);\n@@ -169,5 +175,5 @@\n-                while (!destBlocks.isEmpty()) {\n-                    var block = destBlocks.removeFirst().targetBlock();\n-                    if (visitedBlocks.contains(block)) {\n-                        continue;\n-                    }\n+            while (!destBlocks.isEmpty()) {\n+                var block = destBlocks.removeFirst().targetBlock();\n+                if (visitedBlocks.contains(block)) {\n+                    continue;\n+                }\n@@ -175,3 +181,7 @@\n-                    \/\/Discovered a terminator with a return value, use its type\n-                    if (block.successors().isEmpty()) {\n-                        return block.ops().getLast().resultType();\n+                \/\/Discovered a terminator with a return value, use its type\n+                if (block.successors().isEmpty()) {\n+                    var o = block.ops().getLast();\n+                    if (o instanceof CoreOp.ReturnOp ro) {\n+                        return ro.returnValue().type();\n+                    } else if (o instanceof CoreOp.YieldOp yo) {\n+                        return yo.yieldValue().type();\n@@ -179,3 +189,1 @@\n-                        visitedBlocks.add(block);\n-                        var newDests = block.successors().stream().filter((s) -> !visitedBlocks.contains(s.targetBlock())).toList();\n-                        destBlocks.addAll(newDests);\n+                        throw new UnsupportedOperationException(\"Unsupported terminator encountered: \" + o.opName());\n@@ -183,0 +191,4 @@\n+                } else {\n+                    visitedBlocks.add(block);\n+                    var newDests = block.successors().stream().filter((s) -> !visitedBlocks.contains(s.targetBlock())).toList();\n+                    destBlocks.addAll(newDests);\n@@ -184,1 +196,0 @@\n-\n@@ -186,0 +197,1 @@\n+\n@@ -187,1 +199,2 @@\n-        throw new RuntimeException(\"Encountered Block with no return\");\n+\n+        throw new RuntimeException(\"Encountered Block with no return \" + op.opName());\n@@ -217,4 +230,4 @@\n-                            c.trueBranch().targetBlock().terminatingOp().resultType(),\n-                            b.context().getValue(c.predicate()))\n-                        .if_((bodyBuilder) -> bodyBuilder.op(trueApp))\n-                        .else_((bodyBuilder) -> bodyBuilder.op(falseApp));\n+                                    c.trueBranch().targetBlock().terminatingOp().resultType(),\n+                                    b.context().getValue(c.predicate()))\n+                            .if_((bodyBuilder) -> bodyBuilder.op(trueApp))\n+                            .else_((bodyBuilder) -> bodyBuilder.op(falseApp));\n@@ -267,3 +280,1 @@\n-        for (var op : b.ops()) {\n-            transformEndOp(blockBuilder, op);\n-        }\n+        transformBlockOps(b, blockBuilder);\n@@ -273,60 +284,3 @@\n-    \/*\n-    private Map<Block, AnfDialect.AnfFuncOp> letRecConstruction(Body b, Body.Builder bodyBuilder) {\n-        List<Block> workQueue = new LinkedList<>(processedFunctions.keySet().stream().map(Block::immediateDominator).toList());\n-        Set<Block> processed = new HashSet<>(processedFunctions.keySet());\n-        processed.add(b.entryBlock());\n-\n-        while (!workQueue.isEmpty()) {\n-            Block workBlock = workQueue.removeFirst();\n-\n-            if (workBlock == null || processed.contains(workBlock)) {\n-                continue;\n-            }\n-\n-            \/\/Ugly slow. Blocks dominated by this one.\n-            var domBlocks = b.blocks().stream().filter((block) -> block.immediateDominator() != null && block.immediateDominator().equals(workBlock)).toList();\n-\n-            var unProcessedDomBlocks = domBlocks.stream().filter((block) -> !processedFunctions.containsKey(block)).toList();\n-\n-            \/\/If all dependencies aren't processed, queue them in front, requeue, and continue\n-            if (!unProcessedDomBlocks.isEmpty()) {\n-                unProcessedDomBlocks.forEach(workQueue::addLast);\n-                workQueue.addLast(workBlock);\n-                continue;\n-            }\n-\n-            List<AnfDialect.AnfFuncOp> funcs = domBlocks.stream().map(processedFunctions::get).toList();\n-\n-\n-            \/\/var letrecBodyBuilder = Body.Builder.of(bodyBuilder,FunctionType.VOID); \/\/TODO: Solve Void Type\n-            var letrecBuilder = AnfDialect.letrec(bodyBuilder, FunctionType.VOID); \/\/ TODO: Solve Void Type\n-\n-            var letRec = letrecBuilder.body(block -> {\n-                \/\/Define the functions\n-                for (var func : funcs) {\n-                    block.op(func);\n-                }\n-                \/\/LetRec \"in\" Body here\n-                transformOps(workBlock, block);\n-            });\n-\n-\n-            \/\/var paramTys = workBlock.parameters().stream().map(Block.Parameter::type).toList();\n-            var funBuilder = AnfDialect.func(bodyBuilder,workBlock.toString(),bodyBuilder.bodyType());\n-            var fun = funBuilder.body(c -> c.op(letRec));\n-\n-            processedFunctions.put(workBlock,fun);\n-        }\n-\n-        return processedFunctions;\n-    }\n-\n-    public AnfDialect.AnfFuncOp funcConstructor(Block b, Body.Builder ancestorBody)\n-\n-    private void leafFunctions(Body b) {\n-        List<Block> leafBlocks = leafBlocks(b);\n-        \/\/HashMap<Block, AnfDialect.AnfFuncOp> functions = new HashMap<>();\n-\n-        for (Block leafBlock : leafBlocks) {\n-            Function<Body.Builder, AnfDialect.AnfFuncOp> fBuilder = (Body.Builder bodyBuilder) -> transformBlock(leafBlock, bodyBuilder);\n-            funcOps.put(leafBlock, fBuilder);\n+    public void transformBlockOps(Block b, Block.Builder blockBuilder) {\n+        for (var op : b.ops()) {\n+            transformEndOp(blockBuilder, op);\n@@ -336,15 +290,0 @@\n-    private static List<Block> leafBlocks(Body b) {\n-        var idoms = b.immediateDominators();\n-        HashSet<Block> leafBlocks = new HashSet<>(b.blocks());\n-        leafBlocks.remove(b.entryBlock());\n-        b.blocks().forEach((block) -> {\n-            var dom = idoms.get(block);\n-            \/\/Remove all blocks that dominate other blocks.\n-            if (dom != null) {\n-                leafBlocks.remove(dom);\n-            }\n-        });\n-        \/\/Return blocks that dominate nothing. These are leaves.\n-        return leafBlocks.stream().toList();\n-    }\n-*\/\n@@ -362,12 +301,12 @@\n-               if (!dominated.equals(dominator)) {\n-                   dominatesMap.compute(dominator, (k, v) -> {\n-                       if (v == null) {\n-                           var newList = new ArrayList<Block>();\n-                           newList.add(dominated);\n-                           return newList;\n-                       } else {\n-                           v.add(dominated);\n-                           return v;\n-                       }\n-                   });\n-               }\n+                if (!dominated.equals(dominator)) {\n+                    dominatesMap.compute(dominator, (k, v) -> {\n+                        if (v == null) {\n+                            var newList = new ArrayList<Block>();\n+                            newList.add(dominated);\n+                            return newList;\n+                        } else {\n+                            v.add(dominated);\n+                            return v;\n+                        }\n+                    });\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/analysis\/AnfTransformer.java","additions":66,"deletions":127,"binary":false,"changes":193,"status":"modified"}]}