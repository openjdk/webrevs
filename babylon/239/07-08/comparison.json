{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.Parameter;\n@@ -137,8 +136,6 @@\n-        void popExceptionRegion(CoreOp.ExceptionRegionExit ere) {\n-            ere.catchBlocks().forEach(catchBlock -> {\n-                if (erStack.peek().catchBlock != catchBlock.targetBlock()) {\n-                    \/\/ @@@ Use internal exception type\n-                    throw interpreterException(new IllegalStateException(\"Mismatched exception regions\"));\n-                }\n-                erStack.pop();\n-            });\n+        void popExceptionRegion(CoreOp.ExceptionRegionEnter ers) {\n+            if (erStack.peek().ers != ers) {\n+                \/\/ @@@ Use internal exception type\n+                throw interpreterException(new IllegalStateException(\"Mismatched exception regions\"));\n+            }\n+            erStack.pop();\n@@ -162,3 +159,0 @@\n-            while (erStack.size() > er.erStackDepth()) {\n-                erStack.pop();\n-            }\n@@ -180,2 +174,0 @@\n-\n-        static final Object UINITIALIZED = new Object();\n@@ -200,1 +192,2 @@\n-    record ExceptionRegionRecord(BlockContext mark, int erStackDepth, Block catchBlock) {\n+    record ExceptionRegionRecord(BlockContext mark, CoreOp.ExceptionRegionEnter ers)\n+            implements CoreOp.ExceptionRegion {\n@@ -202,10 +195,13 @@\n-            List<Block.Parameter> args = catchBlock.parameters();\n-            if (args.size() != 1) {\n-                throw interpreterException(new IllegalStateException(\"Catch block must have one argument\"));\n-            }\n-            TypeElement et = args.get(0).type();\n-            if (et instanceof VarType vt) {\n-                et = vt.valueType();\n-            }\n-            if (resolveToClass(l, et).isInstance(e)) {\n-                return catchBlock;\n+            for (Block.Reference catchBlock : ers.catchBlocks()) {\n+                Block target = catchBlock.targetBlock();\n+                List<Block.Parameter> args = target.parameters();\n+                if (args.size() != 1) {\n+                    throw interpreterException(new IllegalStateException(\"Catch block must have one argument\"));\n+                }\n+                TypeElement et = args.get(0).type();\n+                if (et instanceof VarType vt) {\n+                    et = vt.valueType();\n+                }\n+                if (resolveToClass(l, et).isInstance(e)) {\n+                    return target;\n+                }\n@@ -336,5 +332,4 @@\n-                int erStackDepth = oc.erStack.size();\n-                ers.catchBlocks().forEach(catchBlock -> {\n-                    var er = new ExceptionRegionRecord(oc.stack.peek(), erStackDepth, catchBlock.targetBlock());\n-                    oc.pushExceptionRegion(er);\n-                });\n+                var er = new ExceptionRegionRecord(oc.stack.peek(), ers);\n+                oc.setValue(ers.result(), er);\n+\n+                oc.pushExceptionRegion(er);\n@@ -344,1 +339,1 @@\n-                oc.popExceptionRegion(ere);\n+                oc.popExceptionRegion(ere.regionStart());\n@@ -421,0 +416,6 @@\n+            MethodHandle mh;\n+            if (co.hasReceiver()) {\n+                mh = methodHandle(l, co.invokeDescriptor());\n+            } else {\n+                mh = methodStaticHandle(l, co.invokeDescriptor());\n+            }\n@@ -422,6 +423,0 @@\n-            MethodHandles.Lookup il = switch (co.invokeKind()) {\n-                case STATIC, INSTANCE -> l;\n-                case SUPER -> l.in(target.parameterType(0));\n-            };\n-            MethodHandle mh = resolveToMethodHandle(il, co.invokeDescriptor(), co.invokeKind());\n-\n@@ -485,4 +480,1 @@\n-            Object v = vo.isUninitialized()\n-                    ? VarBox.UINITIALIZED\n-                    : oc.getValue(o.operands().get(0));\n-            return new VarBox(v);\n+            return new VarBox(oc.getValue(o.operands().get(0)));\n@@ -493,5 +485,1 @@\n-            Object value = vb.value();\n-            if (value == VarBox.UINITIALIZED) {\n-                throw interpreterException(new IllegalStateException(\"Loading from uninitialized variable\"));\n-            }\n-            return value;\n+            return vb.value();\n@@ -598,1 +586,0 @@\n-\n@@ -629,0 +616,8 @@\n+    static MethodHandle methodStaticHandle(MethodHandles.Lookup l, MethodRef d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n+    static MethodHandle methodHandle(MethodHandles.Lookup l, MethodRef d) {\n+        return resolveToMethodHandle(l, d);\n+    }\n+\n@@ -664,1 +659,1 @@\n-    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d) {\n@@ -666,1 +661,1 @@\n-            return d.resolveToHandle(l, kind);\n+            return d.resolveToHandle(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":44,"deletions":49,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-import java.util.jar.Attributes;\n-import java.util.stream.IntStream;\n@@ -1404,19 +1402,0 @@\n-\n-        \/**\n-         * The kind of invocation.\n-         *\/\n-        public enum InvokeKind {\n-            \/**\n-             * An invocation on a class (static) method.\n-             *\/\n-            STATIC,\n-            \/**\n-             * An invocation on an instance method.\n-             *\/\n-            INSTANCE,\n-            \/**\n-             * A super invocation on an instance method.\n-             *\/\n-            SUPER\n-        }\n-\n@@ -1425,2 +1404,0 @@\n-        public static final String ATTRIBUTE_INVOKE_KIND = NAME + \".kind\";\n-        public static final String ATTRIBUTE_INVOKE_VARARGS = NAME + \".varargs\";\n@@ -1428,2 +1405,0 @@\n-        final InvokeKind invokeKind;\n-        final boolean isVarArgs;\n@@ -1434,1 +1409,0 @@\n-            \/\/ Required attribute\n@@ -1439,10 +1413,1 @@\n-                        case null, default ->\n-                                throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n-                    });\n-\n-            \/\/ If not present defaults to false\n-            boolean isVarArgs = def.extractAttributeValue(ATTRIBUTE_INVOKE_VARARGS,\n-                    false, v -> switch (v) {\n-                        case String s -> Boolean.valueOf(s);\n-                        case Boolean b -> b;\n-                        case null, default -> false;\n+                        case null, default -> throw new UnsupportedOperationException(\"Unsupported invoke descriptor value:\" + v);\n@@ -1451,21 +1416,1 @@\n-            \/\/ If not present and is not varargs defaults to class or instance invocation\n-            \/\/ based on number of operands and parameters\n-            InvokeKind ik = def.extractAttributeValue(ATTRIBUTE_INVOKE_KIND,\n-                    false, v -> switch (v) {\n-                        case String s -> InvokeKind.valueOf(s);\n-                        case InvokeKind k -> k;\n-                        case null, default -> {\n-                            if (isVarArgs) {\n-                                \/\/ If varargs then we cannot infer invoke kind\n-                                throw new UnsupportedOperationException(\"Unsupported invoke kind value:\" + v);\n-                            }\n-                            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-                            int argCount = def.operands().size();\n-                            yield (argCount == paramCount + 1)\n-                                    ? InvokeKind.INSTANCE\n-                                    : InvokeKind.STATIC;\n-                        }\n-                    });\n-\n-\n-            return new InvokeOp(def, ik, isVarArgs, invokeDescriptor);\n+            return new InvokeOp(def, invokeDescriptor);\n@@ -1474,1 +1419,1 @@\n-        InvokeOp(ExternalizedOp def, InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor) {\n+        InvokeOp(ExternalizedOp def, MethodRef invokeDescriptor) {\n@@ -1477,4 +1422,0 @@\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, def.operands());\n-\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n@@ -1488,2 +1429,0 @@\n-            this.invokeKind = that.invokeKind;\n-            this.isVarArgs = that.isVarArgs;\n@@ -1499,2 +1438,3 @@\n-        InvokeOp(InvokeKind invokeKind, boolean isVarArgs, TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n-            super(NAME, args);\n+        InvokeOp(MethodRef invokeDescriptor, List<Value> args) {\n+            this(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+        }\n@@ -1502,1 +1442,2 @@\n-            validateArgCount(invokeKind, isVarArgs, invokeDescriptor, args);\n+        InvokeOp(TypeElement resultType, MethodRef invokeDescriptor, List<Value> args) {\n+            super(NAME, args);\n@@ -1504,2 +1445,0 @@\n-            this.invokeKind = invokeKind;\n-            this.isVarArgs = isVarArgs;\n@@ -1510,9 +1449,0 @@\n-        static void validateArgCount(InvokeKind invokeKind, boolean isVarArgs, MethodRef invokeDescriptor, List<Value> operands) {\n-            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-            int argCount = operands.size() - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n-            if ((!isVarArgs && argCount != paramCount)\n-                    || argCount < paramCount - 1) {\n-                throw new IllegalArgumentException(invokeKind + \" \" + isVarArgs + \" \" + invokeDescriptor);\n-            }\n-        }\n-\n@@ -1523,10 +1453,0 @@\n-            if (isVarArgs) {\n-                \/\/ If varargs then we need to declare the invoke.kind attribute\n-                \/\/ Given a method `A::m(A... more)` and an invocation with one\n-                \/\/ operand, we don't know if that operand corresponds to the\n-                \/\/ receiver or a method argument\n-                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n-                m.put(ATTRIBUTE_INVOKE_VARARGS, isVarArgs);\n-            } else if (invokeKind == InvokeKind.SUPER) {\n-                m.put(ATTRIBUTE_INVOKE_KIND, invokeKind);\n-            }\n@@ -1536,8 +1456,0 @@\n-        public InvokeKind invokeKind() {\n-            return invokeKind;\n-        }\n-\n-        public boolean isVarArgs() {\n-            return isVarArgs;\n-        }\n-\n@@ -1548,1 +1460,0 @@\n-        \/\/ @@@ remove?\n@@ -1550,13 +1461,1 @@\n-            return invokeKind != InvokeKind.STATIC;\n-        }\n-\n-        public List<Value> varArgOperands() {\n-            if (!isVarArgs) {\n-                return null;\n-            }\n-\n-            int operandCount = operands().size();\n-            int argCount = operandCount - (invokeKind == InvokeKind.STATIC ? 0 : 1);\n-            int paramCount = invokeDescriptor.type().parameterTypes().size();\n-            int varArgCount = argCount - (paramCount - 1);\n-            return operands().subList(operandCount - varArgCount, operandCount);\n+            return operands().size() != invokeDescriptor().type().parameterTypes().size();\n@@ -2138,0 +2037,1 @@\n+\n@@ -2177,2 +2077,2 @@\n-            if (def.operands().size() > 1) {\n-                throw new IllegalStateException(\"Operation must have zero or one operand\");\n+            if (def.operands().size() != 1) {\n+                throw new IllegalStateException(\"Operation must have one operand\");\n@@ -2184,1 +2084,1 @@\n-                        case null -> \"\";\n+                        case null -> null;\n@@ -2206,1 +2106,1 @@\n-            return !isUninitialized() && resultType().valueType().equals(initOperand().type());\n+            return resultType().valueType().equals(initOperand().type());\n@@ -2221,10 +2121,1 @@\n-            this.varName =  varName == null ? \"\" : varName;\n-            this.resultType = VarType.varType(type);\n-        }\n-\n-        \/\/ @@@ This and the above constructor can be merged when\n-        \/\/ statements before super can be used in the jdk.compiler module\n-        VarOp(String varName, TypeElement type) {\n-            super(NAME, List.of());\n-\n-            this.varName =  varName == null ? \"\" : varName;\n+            this.varName = varName;\n@@ -2236,1 +2127,1 @@\n-            if (isUnnamedVariable()) {\n+            if (varName == null) {\n@@ -2246,3 +2137,0 @@\n-            if (operands().isEmpty()) {\n-                throw new IllegalStateException(\"Uninitialized variable\");\n-            }\n@@ -2264,8 +2152,0 @@\n-\n-        public boolean isUnnamedVariable() {\n-            return varName.isEmpty();\n-        }\n-\n-        public boolean isUninitialized() {\n-            return operands().isEmpty();\n-        }\n@@ -2585,0 +2465,13 @@\n+    \/\/ @@@ Sealed\n+    \/\/ Synthetic\/hidden type that is the result type of an ExceptionRegionStart operation\n+    \/\/ and is an operand of an ExceptionRegionEnd operation\n+\n+    \/**\n+     * A synthetic exception region type, that is the operation result-type of an exception region\n+     * start operation.\n+     *\/\n+    \/\/ @@@: Create as new type element\n+    public interface ExceptionRegion {\n+        TypeElement EXCEPTION_REGION_TYPE = JavaType.type(ExceptionRegion.class);\n+    }\n+\n@@ -2645,1 +2538,1 @@\n-            return JavaType.VOID;\n+            return ExceptionRegion.EXCEPTION_REGION_TYPE;\n@@ -2657,3 +2550,1 @@\n-        \/\/ First successor is the non-exceptional successor whose target indicates\n-        \/\/ the first block following the exception region.\n-        final List<Block.Reference> s;\n+        final Block.Reference end;\n@@ -2664,2 +2555,2 @@\n-            if (def.successors().size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + def.name());\n+            if (def.operands().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one operand\" + def.name());\n@@ -2668,1 +2559,5 @@\n-            this.s = List.copyOf(def.successors());\n+            if (def.successors().size() != 1) {\n+                throw new IllegalArgumentException(\"Operation must have one successor\" + def.name());\n+            }\n+\n+            this.end = def.successors().get(0);\n@@ -2674,1 +2569,1 @@\n-            this.s = that.s.stream().map(cc::getSuccessorOrCreate).toList();\n+            this.end = cc.getSuccessorOrCreate(that.end);\n@@ -2682,2 +2577,2 @@\n-        ExceptionRegionExit(List<Block.Reference> s) {\n-            super(NAME, List.of());\n+        ExceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+            super(NAME, checkValue(exceptionRegion));\n@@ -2685,2 +2580,7 @@\n-            if (s.size() < 2) {\n-                throw new IllegalArgumentException(\"Operation must have two or more successors\" + opName());\n+            this.end = end;\n+        }\n+\n+        static List<Value> checkValue(Value er) {\n+            if (!(er instanceof Result or && or.op() instanceof ExceptionRegionEnter)) {\n+                throw new IllegalArgumentException(\n+                        \"Operand not the result of an exception.region.start operation: \" + er);\n@@ -2689,1 +2589,1 @@\n-            this.s = List.copyOf(s);\n+            return List.of(er);\n@@ -2694,1 +2594,1 @@\n-            return s;\n+            return List.of(end);\n@@ -2698,1 +2598,1 @@\n-            return s.get(0);\n+            return end;\n@@ -2701,2 +2601,6 @@\n-        public List<Block.Reference> catchBlocks() {\n-            return s.subList(1, s.size());\n+        public ExceptionRegionEnter regionStart() {\n+            if (operands().get(0) instanceof Result or &&\n+                    or.op() instanceof ExceptionRegionEnter ers) {\n+                return ers;\n+            }\n+            throw new InternalError(\"Should not reach here\");\n@@ -2745,0 +2649,1 @@\n+\n@@ -3595,0 +3500,1 @@\n+     * @param exceptionRegion the exception region to be exited\n@@ -3596,1 +3502,0 @@\n-     * @param catchers the blocks handling exceptions thrown by the region block\n@@ -3599,16 +3504,2 @@\n-    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, Block.Reference... catchers) {\n-        return exceptionRegionExit(end, List.of(catchers));\n-    }\n-\n-    \/**\n-     * Creates an exception region exit operation\n-     *\n-     * @param end             the block to which control is transferred after the exception region is exited\n-     * @param catchers the blocks handling exceptions thrown by the region block\n-     * @return the exception region exit operation\n-     *\/\n-    public static ExceptionRegionExit exceptionRegionExit(Block.Reference end, List<Block.Reference> catchers) {\n-        List<Block.Reference> s = new ArrayList<>();\n-        s.add(end);\n-        s.addAll(catchers);\n-        return new ExceptionRegionExit(s);\n+    public static ExceptionRegionExit exceptionRegionExit(Value exceptionRegion, Block.Reference end) {\n+        return new ExceptionRegionExit(exceptionRegion, end);\n@@ -3727,11 +3618,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     * <p>\n-     * The invoke return type is the invoke descriptors return type.\n+     * Creates an invoke operation.\n@@ -3739,1 +3620,1 @@\n-     * @param invokeDescriptor the invoke descriptor\n+     * @param invokeDescriptor the invocation descriptor\n@@ -3744,1 +3625,1 @@\n-        return invoke(invokeDescriptor, List.of(args));\n+        return new InvokeOp(invokeDescriptor, List.of(args));\n@@ -3748,11 +3629,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n-     * <p>\n-     * The invoke return type is the invoke descriptors return type.\n+     * Creates an invoke operation.\n@@ -3760,2 +3631,2 @@\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n@@ -3765,1 +3636,1 @@\n-        return invoke(invokeDescriptor.type().returnType(), invokeDescriptor, args);\n+        return new InvokeOp(invokeDescriptor, args);\n@@ -3769,9 +3640,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * Creates an invoke operation.\n@@ -3779,3 +3642,3 @@\n-     * @param returnType       the invoke return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n@@ -3785,1 +3648,1 @@\n-        return invoke(returnType, invokeDescriptor, List.of(args));\n+        return new InvokeOp(returnType, invokeDescriptor, List.of(args));\n@@ -3789,9 +3652,1 @@\n-     * Creates an invoke operation modeling an invocation to an\n-     * instance or static (class) method with no variable arguments.\n-     * <p>\n-     * The invoke kind of the invoke operation is determined by\n-     * comparing the argument count with the invoke descriptor's\n-     * parameter count. If they are equal then the invoke kind is\n-     * {@link InvokeOp.InvokeKind#STATIC static}. If the parameter count\n-     * plus one is equal to the argument count then the invoke kind\n-     * is {@link InvokeOp.InvokeKind#STATIC instance}.\n+     * Creates an invoke operation.\n@@ -3799,22 +3654,3 @@\n-     * @param returnType       the invoke return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n-     * @return the invoke super operation\n-     *\/\n-    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        int paramCount = invokeDescriptor.type().parameterTypes().size();\n-        int argCount = args.size();\n-        InvokeOp.InvokeKind ik = (argCount == paramCount + 1)\n-                ? InvokeOp.InvokeKind.INSTANCE\n-                : InvokeOp.InvokeKind.STATIC;\n-        return new InvokeOp(ik, false, returnType, invokeDescriptor, args);\n-    }\n-\n-    \/**\n-     * Creates an invoke operation modelling an invocation to a method.\n-     *\n-     * @param invokeKind       the invoke kind\n-     * @param isVarArgs        true if an invocation to a variable argument method\n-     * @param returnType       the return type\n-     * @param invokeDescriptor the invoke descriptor\n-     * @param args             the invoke arguments\n+     * @param returnType       the invocation return type\n+     * @param invokeDescriptor the invocation descriptor\n+     * @param args             the invoke parameters\n@@ -3822,2 +3658,0 @@\n-     * @throws IllegalArgumentException if there is a mismatch between the argument count\n-     *                                  and the invoke descriptors parameter count.\n@@ -3825,3 +3659,2 @@\n-    public static InvokeOp invoke(InvokeOp.InvokeKind invokeKind, boolean isVarArgs,\n-                                  TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n-        return new InvokeOp(invokeKind, isVarArgs, returnType, invokeDescriptor, args);\n+    public static InvokeOp invoke(TypeElement returnType, MethodRef invokeDescriptor, List<Value> args) {\n+        return new InvokeOp(returnType, invokeDescriptor, args);\n@@ -4037,23 +3870,1 @@\n-     * Creates a var operation modeling an unnamed and uninitialized variable,\n-     * either an unnamed local variable or an unnamed parameter.\n-     *\n-     * @param type the type of the var's value\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(TypeElement type) {\n-        return var(null, type, null);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an uninitialized variable, either a local variable or a parameter.\n-     *\n-     * @param name the name of the var\n-     * @param type the type of the var's value\n-     * @return the var operation\n-     *\/\n-    public static VarOp var(String name, TypeElement type) {\n-        return new VarOp(name, type);\n-    }\n-\n-    \/**\n-     * Creates a var operation modeling an unnamed variable, either an unnamed local variable or an unnamed parameter.\n+     * Creates a var operation.\n@@ -4069,3 +3880,1 @@\n-     * Creates a var operation modeling a variable, either a local variable or a parameter.\n-     * <p>\n-     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n+     * Creates a var operation.\n@@ -4082,3 +3891,1 @@\n-     * Creates a var operation modeling a variable, either a local variable or a parameter.\n-     * <p>\n-     * If the given name is {@code null} or an empty string then the variable is an unnamed variable.\n+     * Creates a var operation.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOp.java","additions":82,"deletions":275,"binary":false,"changes":357,"status":"modified"}]}