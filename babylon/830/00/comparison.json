{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-        char value();\n-        void value(char value);\n+        short value();\n+        void value(short value);\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/BF16Array.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,1 @@\n-public abstract class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends C99CodeBuilder<T>\n-        implements BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n+public abstract class C99HATCodeBuilder<T extends C99HATCodeBuilder<T>> extends C99CodeBuilder<T> implements BabylonOpDispatcher<T, ScopedCodeBuilderContext> {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import hat.buffer.*;\n@@ -29,0 +28,2 @@\n+import hat.buffer.BF16Array;\n+import hat.buffer.F16Array;\n@@ -30,1 +31,8 @@\n-import hat.dialect.*;\n+import hat.dialect.HATBarrierOp;\n+import hat.dialect.HATF16Op;\n+import hat.dialect.HATMemoryDefOp;\n+import hat.dialect.HATMemoryVarOp;\n+import hat.dialect.HATPtrOp;\n+import hat.dialect.HATThreadOp;\n+import hat.dialect.HATVectorOp;\n+import hat.dialect.ReducedFloatType;\n@@ -447,2 +455,0 @@\n-                }else{\n-                    \/\/throw new IllegalStateException(\"what happens here 1\");\n@@ -465,2 +471,0 @@\n-                } else{\n-                      \/\/  throw new IllegalStateException(\"what happens here 2\");\n@@ -468,0 +472,1 @@\n+\n@@ -633,2 +638,10 @@\n-     *      b16_t b1 = {f};\n-     *      return b1.s[1];\n+     *      b16_t b = {f};\n+     *      uint32_t bits = b.i;\n+     *      short sign_bit = (short)((bits & 0x8000_0000) >> 16);\n+     *      int lsb    = bits & 0x1_0000;\n+     *      int round  = bits & 0x0_8000;\n+     *      int sticky = bits & 0x0_7FFF;\n+     *      if (round != 0 && ((lsb | sticky) != 0 )) {\n+     *          bits += 0x1_0000;\n+     *      }\n+     *      return (short) (((bits >> 16 ) | sign_bit) & 0xffff);\n@@ -641,2 +654,1 @@\n-        String b16 = \"b16\";\n-        String s = \"s\";\n+        String idBFloat16 = \"b\";\n@@ -647,3 +659,10 @@\n-                _ -> assign(_ -> bfloat16Type(b16),\n-                        _ ->  brace( _ -> identifier(parameterName)).semicolonNl()\n-                                .returnKeyword(_ ->identifier(b16).dot().identifier(s).sbrace(_ -> intConstOne()))));\n+                _ -> assign(_ -> bfloat16Type(idBFloat16),\n+                        _ ->  brace( _ -> identifier(parameterName)).semicolonNl())\n+                        .assign( _ -> u32Type(\"bits\"), _ -> identifier(idBFloat16).dot().identifier(\"i\")).semicolonNl()\n+                        .assign( _ -> u16Type(\"sign_bit\"), _ -> cast( _ -> s16Type()).paren( _ -> paren( _ -> identifier(\"bits\").ampersand().constant(\"0x80000000\")).rightShift(16))).semicolonNl()\n+                        .assign( _ -> s32Type(\"lsb\"), _ -> identifier(\"bits\").ampersand().constant(\"0x10000\")).semicolonNl()\n+                        .assign( _ -> s32Type(\"round\"), _ -> identifier(\"bits\").ampersand().constant(\"0x08000\")).semicolonNl()\n+                        .assign( _ -> s32Type(\"sticky\"), _ -> identifier(\"bits\").ampersand().constant(\"0x07FFF\")).semicolonNl()\n+                        .ifTrueCondition(_ -> identifier(\"round\").space().ne().space().intConstZero().condAnd().paren( _ -> paren( _ -> identifier(\"lsb\").bitwiseOR().identifier(\"sticky\")).ne().intConstZero()),\n+                                _ -> identifier(\"bits\").space().plusEquals().space().constant(\"0x10000\"))\n+                        .returnKeyword( _ -> cast( _ ->u16Type()).paren( _ -> paren( _ -> paren( _-> identifier(\"bits\").rightShift(16)).bitwiseOR().identifier(\"sign_bit\")).ampersand().constant(\"0xffff\"))));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n-    char value();\n-    void value(char value);\n+    short value();\n+    void value(short value);\n@@ -35,1 +35,1 @@\n-            public char value() {\n+            public short value() {\n@@ -37,2 +37,22 @@\n-                bits >>= 16;\n-                return (char) bits;\n+                short sign_bit = (short)((bits & 0x8000_0000) >> 16);\n+\n+                \/\/ For round to nearest even, determining whether or not to\n+                \/\/ round up (in magnitude) is a function of the least\n+                \/\/ significant bit (LSB), the next bit position (the round\n+                \/\/ position), and the sticky bit (whether there are any\n+                \/\/ nonzero bits in the exact result to the right of the round\n+                \/\/ digit). An increment occurs in three cases:\n+                \/\/\n+                \/\/ LSB  Round Sticky\n+                \/\/ 0    1     1\n+                \/\/ 1    1     0\n+                \/\/ 1    1     1\n+                \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+                int lsb    = bits & 0x1_0000;\n+                int round  = bits & 0x0_8000;\n+                int sticky = bits & 0x0_7FFF;\n+                if (round != 0 && ((lsb | sticky) != 0 )) {\n+                    bits += 0x1_0000;\n+                }\n+                return (short) (((bits >> 16 ) | sign_bit) & 0xffff);\n@@ -42,1 +62,1 @@\n-            public void value(char value) {\n+            public void value(short value) {\n@@ -47,1 +67,1 @@\n-    static BF16 of(char value) {\n+    static BF16 of(short value) {\n@@ -50,1 +70,1 @@\n-            public char value() {\n+            public short value() {\n@@ -55,1 +75,1 @@\n-            public void value(char value) {\n+            public void value(short value) {\n","filename":"hat\/core\/src\/main\/java\/hat\/types\/BF16.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,1 +251,2 @@\n-            u16Type(\"s\").sizeArray(2).semicolon();\n+            u16Type(\"s\").sizeArray(2).semicolon().nl();\n+            u32Type(\"i\").semicolon();\n@@ -270,0 +271,10 @@\n+    public final T ifTrueCondition(Consumer<T> condition, Consumer<T> ... trueStatements) {\n+        return ifKeyword().space().paren( _-> condition.accept(self())).space().brace( _ ->\n+                nl().indent( _ -> {\n+                    for (Consumer<T> statement : trueStatements) {\n+                        statement.accept(self());\n+                        semicolonNl();\n+                    }\n+                })).nl();\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/C99CodeBuilder.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,3 @@\n+    public T plusEquals() {\n+        return symbol(\"+=\");\n+    }\n@@ -103,0 +106,4 @@\n+    public T ne() {\n+        return pling().equals();\n+    }\n+\n@@ -376,1 +383,1 @@\n-    public T bar() {\n+    public T bitwiseOR() {\n@@ -526,1 +533,1 @@\n-        return separated(iterable, _ -> bar(), consumer);\n+        return separated(iterable, _ -> bitwiseOR(), consumer);\n@@ -698,1 +705,1 @@\n-                * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+                * Copyright (c) 2025-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -772,1 +779,1 @@\n-            case JavaOp.OrOp o -> bar();\n+            case JavaOp.OrOp o -> bitwiseOR();\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/codebuilders\/CodeBuilder.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025-2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -412,5 +412,1 @@\n-            try {\n-                HATAsserts.assertEquals((fa + fb + fb), BF16.bfloat162float(val), 0.01f);\n-            } catch (HATAssertionError hae) {\n-                throw new HATExpectedPrecisionError(hae.getMessage());\n-            }\n+            HATAsserts.assertEquals((fa + fb + fb), BF16.bfloat162float(val), 0.01f);\n@@ -452,5 +448,1 @@\n-            try {\n-                HATAsserts.assertEquals(BF16.bfloat162float(r5), BF16.bfloat162float(gotResult), 0.01f);\n-            } catch (HATAssertionError hatAssertionError) {\n-                throw new HATExpectedPrecisionError(hatAssertionError.getMessage());\n-            }\n+            HATAsserts.assertEquals(BF16.bfloat162float(r5), BF16.bfloat162float(gotResult), 0.01f);\n@@ -647,5 +639,1 @@\n-            try {\n-                HATAsserts.assertEquals(BF16.bfloat162float(arrayA.array(i)), BF16.bfloat162float(result), 0.01f);\n-             } catch (HATAssertionError hatAssertionError) {\n-                throw new HATExpectedPrecisionError(hatAssertionError.getMessage());\n-            }\n+            HATAsserts.assertEquals(BF16.bfloat162float(arrayA.array(i)), BF16.bfloat162float(result), 0.01f);\n","filename":"hat\/tests\/src\/main\/java\/hat\/test\/TestBFloat16Type.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"}]}