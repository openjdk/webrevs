{"files":[{"patch":"@@ -389,1 +389,1 @@\n-                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.method().getName()).commaSpace();\n+                call().uni().space().oparen().retVal().cparen().commaSpace().append(op.methodNoLookup().getName()).commaSpace();\n","filename":"hat\/backends\/ptx\/src\/main\/java\/hat\/backend\/PTXCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-        Method method = lambda.getQuotableTargetMethod();\n+        Method method = lambda.getQuotableTargetMethod(this.lookup);\n","filename":"hat\/hat\/src\/main\/java\/hat\/Accelerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import hat.optools.ModuleOpWrapper;\n@@ -37,0 +38,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -38,0 +40,2 @@\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n@@ -40,0 +44,1 @@\n+import java.lang.reflect.code.Value;\n@@ -42,0 +47,3 @@\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n@@ -43,0 +51,3 @@\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Optional;\n@@ -67,1 +78,5 @@\n-    public  enum WRAPPER {\n+\n+\n+\n+\n+    public enum WRAPPER {\n@@ -71,3 +86,4 @@\n-        WRAPPER(String name){\n-            this.pre = MethodRef.method(ComputeContext.class, \"pre\"+name, void.class, Buffer.class);\n-            this.post = MethodRef.method(ComputeContext.class, \"post\"+name, void.class, Buffer.class);\n+\n+        WRAPPER(String name) {\n+            this.pre = MethodRef.method(ComputeContext.class, \"pre\" + name, void.class, Buffer.class);\n+            this.post = MethodRef.method(ComputeContext.class, \"post\" + name, void.class, Buffer.class);\n@@ -76,0 +92,1 @@\n+\n@@ -105,0 +122,5 @@\n+\n+     \/\/   ModuleOpWrapper module = ModuleOpWrapper.createTransitiveInvokeModule(accelerator.lookup, computeMethod);\n+\n+       \/\/ System.out.println(module.op().toText());\n+\n@@ -106,0 +128,1 @@\n+\n@@ -139,1 +162,1 @@\n-    public static class RuntimeInfo{\n+    public static class RuntimeInfo {\n@@ -143,1 +166,2 @@\n-    public  RuntimeInfo runtimeInfo = null;\n+\n+    public RuntimeInfo runtimeInfo = null;\n@@ -146,2 +170,2 @@\n-       \/\/ System.out.println(\"preMutate \" + b);\n-        if (runtimeInfo.gpuDirty.contains(b)){\n+        \/\/ System.out.println(\"preMutate \" + b);\n+        if (runtimeInfo.gpuDirty.contains(b)) {\n@@ -153,1 +177,1 @@\n-       \/\/ System.out.println(\"postMutate \" + b);\n+        \/\/ System.out.println(\"postMutate \" + b);\n@@ -158,2 +182,2 @@\n-       \/\/ System.out.println(\"preAccess \" + b);\n-        if (runtimeInfo.gpuDirty.contains(b)){\n+        \/\/ System.out.println(\"preAccess \" + b);\n+        if (runtimeInfo.gpuDirty.contains(b)) {\n@@ -165,1 +189,1 @@\n-       \/\/ System.out.println(\"postAccess \" + b);\n+        \/\/ System.out.println(\"postAccess \" + b);\n@@ -169,2 +193,2 @@\n-       \/\/ System.out.println(\"preEscape \" + b);\n-        if (runtimeInfo.gpuDirty.contains(b)){\n+        \/\/ System.out.println(\"preEscape \" + b);\n+        if (runtimeInfo.gpuDirty.contains(b)) {\n@@ -174,0 +198,1 @@\n+\n@@ -175,1 +200,1 @@\n-       \/\/ System.out.println(\"postEscape \" + b);\n+        \/\/ System.out.println(\"postEscape \" + b);\n","filename":"hat\/hat\/src\/main\/java\/hat\/ComputeContext.java","additions":40,"deletions":15,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -128,2 +128,2 @@\n-        \/**\n-         * A ResolvedComputeMethodCall (entrypoint or java  methdod reachable from a compute entrypojnt)  has the following calls\n+        \/*\n+         * A ResolvedComputeMethodCall (entrypoint or java  method reachable from a compute entrypojnt)  has the following calls\n@@ -132,1 +132,1 @@\n-         * a) we must have the code model available for these and must extend the dag\n+         *    a) we must have the code model available for these and must be included in the dag\n@@ -134,2 +134,3 @@\n-         * a) getters (return non void)\n-         * b) setters (return void)\n+         *    a) getters (return non void)\n+         *    b) setters (return void)\n+         *    c) default helpers with @CodeReflection?\n@@ -137,1 +138,3 @@\n-         * a) kernel dispatches\n+         *    a) kernel dispatches\n+         *    b) mapped math functions?\n+         *    c) maybe we also handle range creations?\n@@ -139,1 +142,1 @@\n-         * a) range creations (maybe computecontext shuld manage ranges?)\n+         *    a) range creations (maybe compute context should manage ranges?)\n@@ -141,3 +144,2 @@\n-         * a) We must also have the code models for these and must extend the dag to include these.\n-         **\/\n-\n+         *    a) We must also have the code models for these and must extend the dag to include these.\n+         *\/\n@@ -146,1 +148,1 @@\n-            var methodRef = invokeWrapper.methodRef();\n+            MethodRef methodRef = invokeWrapper.methodRef();\n@@ -148,1 +150,1 @@\n-            Method invokeWrapperCalledMethod = invokeWrapper.method();\n+            Method invokeWrapperCalledMethod = invokeWrapper.method(this.computeContext.accelerator.lookup);\n@@ -185,1 +187,0 @@\n-\n@@ -214,1 +215,0 @@\n-\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        \/**\n+        \/*\n@@ -85,1 +85,1 @@\n-         * a) we must have the code model available for these and must extend the dag\n+         *    a) we must have the code model available for these and must extend the dag\n@@ -87,2 +87,2 @@\n-         * a) getters (return non void)\n-         * b) setters (return void)\n+         *    a) getters (return non void)\n+         *    b) setters (return void)\n@@ -90,1 +90,1 @@\n-         **\/\n+         *\/\n@@ -93,1 +93,1 @@\n-            var methodRef = invokeOpWrapper.methodRef();\n+            MethodRef methodRef = invokeOpWrapper.methodRef();\n@@ -95,1 +95,1 @@\n-            Method invokeOpCalledMethod = invokeOpWrapper.method();\n+            Method invokeOpCalledMethod = invokeOpWrapper.method(this.computeContext.accelerator.lookup);\n@@ -104,1 +104,1 @@\n-                    ;                   \/\/System.out.println(\"A call to a method on the kernel class which we have code model for \" + methodRef);\n+                    \/\/System.out.println(\"A call to a method on the kernel class which we have code model for \" + methodRef);\n@@ -113,1 +113,0 @@\n-\n@@ -120,1 +119,0 @@\n-\n@@ -144,1 +142,0 @@\n-\n@@ -147,1 +144,1 @@\n-        ((MethodCall) entrypoint).rankRecurse();\n+        entrypoint.rankRecurse();\n","filename":"hat\/hat\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -92,1 +93,1 @@\n-    public Method method() {\n+    public Method methodNoLookup() {\n@@ -110,0 +111,9 @@\n+    public Method method(MethodHandles.Lookup lookup) {\n+        Method invokedMethod = null;\n+        try {\n+            invokedMethod = methodRef().resolveToMethod(lookup);\n+            return invokedMethod;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n@@ -138,1 +148,0 @@\n-\n@@ -145,1 +154,2 @@\n-            String className = javaRefType().toString();\n+            JavaType refType = javaRefType();\n+            String className = refType.toString();\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -56,2 +57,2 @@\n-    public Method getQuotableTargetMethod() {\n-        return getQuotableTargetInvokeOpWrapper().method();\n+    public Method getQuotableTargetMethod(MethodHandles.Lookup lookup) {\n+        return getQuotableTargetInvokeOpWrapper().method(lookup);\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/LambdaOpWrapper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.CopyContext;\n+import java.lang.reflect.code.Op;\n+import java.lang.reflect.code.Value;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.type.MethodRef;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class ModuleOpWrapper extends OpWrapper<CoreOp.ModuleOp> {\n+    ModuleOpWrapper(CoreOp.ModuleOp op) {\n+        super(op);\n+    }\n+\n+    record MethodRefToEntryFuncOpCall(MethodRef methodRef, CoreOp.FuncOp funcOp) {\n+    }\n+\n+    record Closure(Deque<MethodRefToEntryFuncOpCall> work, LinkedHashSet<MethodRef> funcsVisited,\n+                   List<CoreOp.FuncOp> moduleFuncOps) {\n+    }\n+\n+    public static ModuleOpWrapper createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+                                                               Method entryPoint) {\n+        Optional<CoreOp.FuncOp> codeModel = entryPoint.getCodeModel();\n+        if (codeModel.isPresent()) {\n+            return OpWrapper.wrap(createTransitiveInvokeModule(lookup, MethodRef.method(entryPoint), codeModel.get()));\n+        } else {\n+            return OpWrapper.wrap(CoreOp.module(List.of()));\n+        }\n+    }\n+   \/* static Method resolveToMethod(MethodHandles.Lookup lookup, MethodRef invokedMethodRef){\n+        Method invokedMethod = null;\n+        try {\n+            invokedMethod = invokedMethodRef.resolveToMethod(lookup);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return invokedMethod;\n+    } *\/\n+\n+    static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+                                                        MethodRef methodRef, CoreOp.FuncOp entryFuncOp) {\n+        Closure closure = new Closure(new ArrayDeque<>(), new LinkedHashSet<>(), new ArrayList<>());\n+        closure.work.push(new MethodRefToEntryFuncOpCall(methodRef, entryFuncOp));\n+        while (!closure.work.isEmpty()) {\n+            MethodRefToEntryFuncOpCall methodRefToEntryFuncOpCall = closure.work.pop();\n+            if (closure.funcsVisited.add(methodRefToEntryFuncOpCall.methodRef)) {\n+                CoreOp.FuncOp tf = methodRefToEntryFuncOpCall.funcOp.transform(\n+                        methodRefToEntryFuncOpCall.methodRef.toString(), (blockBuilder, op) -> {\n+                            if (op instanceof CoreOp.InvokeOp invokeOp && OpWrapper.wrap(invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n+                                Method invokedMethod = invokeOpWrapper.method(lookup);\n+                                Optional<CoreOp.FuncOp> optionalInvokedFuncOp = invokedMethod.getCodeModel();\n+                                if (optionalInvokedFuncOp.isPresent() && OpWrapper.wrap(optionalInvokedFuncOp.get()) instanceof FuncOpWrapper funcOpWrapper) {\n+                                    MethodRefToEntryFuncOpCall call =\n+                                            new MethodRefToEntryFuncOpCall(invokeOpWrapper.methodRef(), funcOpWrapper.op());\n+                                    closure.work.push(call);\n+                                    CopyContext copyContext = blockBuilder.context();\n+                                    List<Value> operands = copyContext.getValues(invokeOp.operands());\n+                                    CoreOp.FuncCallOp replacementCall = CoreOp.funcCall(\n+                                            call.methodRef.toString(),\n+                                            call.funcOp.invokableType(),\n+                                            operands);\n+                                    Op.Result replacementResult = blockBuilder.op(replacementCall);\n+                                    copyContext.mapValue(invokeOp.result(), replacementResult);\n+                                    \/\/ System.out.println(\"replaced \" + call);\n+                                } else {\n+                                    \/\/ System.out.println(\"We have no code model for \" + invokeOpWrapper.methodRef());\n+                                    blockBuilder.op(invokeOp);\n+                                }\n+                            } else {\n+                                blockBuilder.op(op);\n+                            }\n+                            return blockBuilder;\n+                        });\n+                closure.moduleFuncOps.add(tf);\n+            }\n+        }\n+\n+        return CoreOp.module(closure.moduleFuncOps);\n+    }\n+}\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -47,0 +47,1 @@\n+        \/\/ This is possibly a premature optimization. But it allows us to treat vardeclarations differently from params.\n@@ -59,0 +60,1 @@\n+            case CoreOp.ModuleOp $ -> (OW) new ModuleOpWrapper($);\n","filename":"hat\/hat\/src\/main\/java\/hat\/optools\/OpWrapper.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}