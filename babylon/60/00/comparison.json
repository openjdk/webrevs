{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.Method;\n@@ -36,0 +37,1 @@\n+import java.util.function.Predicate;\n@@ -510,0 +512,137 @@\n+\n+        \/**\n+         * Determines if this lambda operation could have originated from a\n+         * method reference declared in Java source code.\n+         * <p>\n+         * Such a lambda operation is one with the following constraints:\n+         * <ol>\n+         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n+         *     <li>A body with only one (entry) block that contains only variable declaration\n+         *     operations, variable load operations, invoke operations to box or unbox\n+         *     primitive values, a single invoke operation to the method that is\n+         *     referenced, and a return operation.\n+         *     <li>if the return operation returns a non-void result then that result is,\n+         *     or uniquely depends on, the result of the referencing invoke operation.\n+         *     <li>If the lambda operation captures one value then the first operand corresponds\n+         *     to captured value, and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         *     Otherwise, the first and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         * <\/ol>\n+         * A value, V2, uniquely depends on another value, V1, if the graph of what V2 depends on\n+         * contains only nodes with single edges terminating in V1, and the graph of what depends on V1\n+         * is bidirectionally equal to the graph of what V2 depends on.\n+         *\n+         *\n+         * and the graph of what\n+         * depends on V1 are equal\n+         *\n+         * @return the invocation operation to the method referenced by the lambda\n+         * expression operation, otherwise empty.\n+         *\/\n+        public Optional<InvokeOp> isMethodReference() {\n+            \/\/ Single block\n+            if (body().blocks().size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Zero or one (this) capture\n+            List<Value> cvs = capturedValues();\n+            if (cvs.size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            Map<Value, Value> valueMapping = new HashMap<>();\n+            CoreOps.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, body().entryBlock().ops());\n+            if (methodRefInvokeOp == null) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Lambda's parameters map in encounter order with the invocation's operands\n+            List<Value> lambdaParameters = new ArrayList<>();\n+            if (cvs.size() == 1) {\n+                lambdaParameters.add(cvs.getFirst());\n+            }\n+            lambdaParameters.addAll(parameters());\n+            List<Value> methodRefOperands = methodRefInvokeOp.operands().stream().map(valueMapping::get).toList();\n+            if (!lambdaParameters.equals(methodRefOperands)) {\n+                return Optional.empty();\n+            }\n+\n+            return Optional.of(methodRefInvokeOp);\n+        }\n+\n+        static CoreOps.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n+            CoreOps.InvokeOp methodRefInvokeOp = null;\n+            for (Op op : ops) {\n+                switch (op) {\n+                    case CoreOps.VarOp varOp -> {\n+                        if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOps.VarAccessOp.VarStoreOp)) {\n+                            return null;\n+                        }\n+                    }\n+                    case CoreOps.VarAccessOp.VarLoadOp varLoadOp -> {\n+                        Value v = varLoadOp.varOp().operands().getFirst();\n+                        valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case CoreOps.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n+                        Value v = iop.operands().getFirst();\n+                        valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case CoreOps.InvokeOp iop -> {\n+                        if (methodRefInvokeOp != null) {\n+                            return null;\n+                        }\n+\n+                        for (Value o : iop.operands()) {\n+                            valueMapping.put(o, valueMapping.getOrDefault(o, o));\n+                        }\n+                        methodRefInvokeOp = iop;\n+                    }\n+                    case CoreOps.ReturnOp rop -> {\n+                        if (methodRefInvokeOp == null) {\n+                            return null;\n+                        }\n+                        Value r = rop.returnValue();\n+                        if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n+                            return null;\n+                        }\n+                        if (invokeResult.op() != methodRefInvokeOp) {\n+                            return null;\n+                        }\n+                        assert methodRefInvokeOp.result().uses().size() == 1;\n+                    }\n+                    default -> {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            return methodRefInvokeOp;\n+        }\n+\n+        private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+            for (Op.Result user : value.uses()) {\n+                if (opPredicate.test(user.op())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ @@@ Move to functionality on JavaType(s)\n+        static final Set<String> UNBOX_NAMES = Set.of(\n+                \"byteValue\",\n+                \"shortValue\",\n+                \"charValue\",\n+                \"intValue\",\n+                \"longValue\",\n+                \"floatValue\",\n+                \"doubleValue\",\n+                \"booleanValue\");\n+\n+        private static boolean isBoxOrUnboxInvocation(CoreOps.InvokeOp iop) {\n+            MethodRef mr = iop.invokeDescriptor();\n+            Collection<TypeElement> boxTypes = JavaType.primitiveToWrapper.values();\n+            return boxTypes.contains(mr.refType()) && (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n+        }\n@@ -605,1 +744,0 @@\n-     *\n@@ -996,1 +1134,1 @@\n-            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE,true,\n+            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE, true,\n@@ -1127,1 +1265,1 @@\n-                    true, v -> switch(v) {\n+                    true, v -> switch (v) {\n@@ -1238,2 +1376,2 @@\n-            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,true,\n-                    v -> switch(v) {\n+            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR, true,\n+                    v -> switch (v) {\n@@ -1364,2 +1502,2 @@\n-                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n-                        v -> switch(v) {\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n@@ -1368,1 +1506,2 @@\n-                            default -> throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                            default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n@@ -1423,2 +1562,2 @@\n-                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n-                        v -> switch(v) {\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n@@ -1427,1 +1566,2 @@\n-                            default -> throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                            default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n@@ -1625,1 +1765,1 @@\n-                    v -> switch(v) {\n+                    v -> switch (v) {\n@@ -1691,1 +1831,1 @@\n-                    v -> switch(v) {\n+                    v -> switch (v) {\n@@ -1758,0 +1898,1 @@\n+         *\n@@ -1759,0 +1900,1 @@\n+         * @param <T>   the type of the var's value.\n@@ -1760,1 +1902,0 @@\n-         * @param <T> the type of the var's value.\n@@ -2306,1 +2447,1 @@\n-            super(ConcatOp.NAME, List.of(lhs,rhs));\n+            super(ConcatOp.NAME, List.of(lhs, rhs));\n@@ -2308,0 +2449,1 @@\n+\n@@ -2955,0 +3097,1 @@\n+     *\n@@ -2965,0 +3108,1 @@\n+     *\n@@ -2966,1 +3110,1 @@\n-     * @param body the function body\n+     * @param body     the function body\n@@ -2975,0 +3119,1 @@\n+     *\n@@ -2977,1 +3122,1 @@\n-     * @param args the function arguments\n+     * @param args     the function arguments\n@@ -2986,0 +3131,1 @@\n+     *\n@@ -2988,1 +3134,1 @@\n-     * @param args the function arguments\n+     * @param args     the function arguments\n@@ -2997,0 +3143,1 @@\n+     *\n@@ -3007,0 +3154,1 @@\n+     *\n@@ -3017,0 +3165,1 @@\n+     *\n@@ -3026,0 +3175,1 @@\n+     *\n@@ -3035,0 +3185,1 @@\n+     *\n@@ -3036,1 +3187,1 @@\n-     * @param opFunc a function that accepts the body of the quoted operation and returns the operation to be quoted\n+     * @param opFunc       a function that accepts the body of the quoted operation and returns the operation to be quoted\n@@ -3050,0 +3201,1 @@\n+     *\n@@ -3059,2 +3211,3 @@\n-     * @param ancestorBody the ancestor of the body of the lambda operation\n-     * @param funcType the lambda operation's function type\n+     *\n+     * @param ancestorBody        the ancestor of the body of the lambda operation\n+     * @param funcType            the lambda operation's function type\n@@ -3071,0 +3224,1 @@\n+     *\n@@ -3072,1 +3226,1 @@\n-     * @param body the body of the lambda operation\n+     * @param body                the body of the lambda operation\n@@ -3081,0 +3235,1 @@\n+     *\n@@ -3082,1 +3237,1 @@\n-     * @param funcType the closure operation's function type\n+     * @param funcType     the closure operation's function type\n@@ -3092,0 +3247,1 @@\n+     *\n@@ -3101,0 +3257,1 @@\n+     *\n@@ -3111,0 +3268,1 @@\n+     *\n@@ -3121,1 +3279,2 @@\n-     * @param start the exception region block\n+     *\n+     * @param start    the exception region block\n@@ -3131,1 +3290,2 @@\n-     * @param start the exception region block\n+     *\n+     * @param start    the exception region block\n@@ -3144,0 +3304,1 @@\n+     *\n@@ -3145,1 +3306,1 @@\n-     * @param end the block to which control is transferred after the exception region is exited\n+     * @param end             the block to which control is transferred after the exception region is exited\n@@ -3154,0 +3315,1 @@\n+     *\n@@ -3162,0 +3324,1 @@\n+     *\n@@ -3171,0 +3334,1 @@\n+     *\n@@ -3180,0 +3344,1 @@\n+     *\n@@ -3188,0 +3353,1 @@\n+     *\n@@ -3196,0 +3362,1 @@\n+     *\n@@ -3205,0 +3372,1 @@\n+     *\n@@ -3214,0 +3382,1 @@\n+     *\n@@ -3223,2 +3392,3 @@\n-     * @param condValue the test value of the conditional break operation\n-     * @param trueTarget the jump target when the test value evaluates to true\n+     *\n+     * @param condValue   the test value of the conditional break operation\n+     * @param trueTarget  the jump target when the test value evaluates to true\n@@ -3235,1 +3405,2 @@\n-     * @param type the constant type\n+     *\n+     * @param type  the constant type\n@@ -3247,1 +3418,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3258,1 +3429,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3268,1 +3439,1 @@\n-     * @param returnType the invocation return type\n+     * @param returnType       the invocation return type\n@@ -3270,1 +3441,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3280,1 +3451,1 @@\n-     * @param returnType the invocation return type\n+     * @param returnType       the invocation return type\n@@ -3282,1 +3453,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3292,1 +3463,1 @@\n-     * @param to the conversion target type\n+     * @param to   the conversion target type\n@@ -3304,1 +3475,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3315,1 +3486,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3325,1 +3496,1 @@\n-     * @param returnType the instance type\n+     * @param returnType      the instance type\n@@ -3327,1 +3498,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3338,1 +3509,1 @@\n-     * @param returnType the instance type\n+     * @param returnType      the instance type\n@@ -3340,1 +3511,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3352,1 +3523,1 @@\n-     * @param length the array size\n+     * @param length    the array size\n@@ -3365,1 +3536,1 @@\n-     * @param receiver the receiver value\n+     * @param receiver   the receiver value\n@@ -3377,1 +3548,1 @@\n-     * @param receiver the receiver value\n+     * @param receiver   the receiver value\n@@ -3409,2 +3580,2 @@\n-     * @param receiver the receiver value\n-     * @param v the value to store\n+     * @param receiver   the receiver value\n+     * @param v          the value to store\n@@ -3421,1 +3592,1 @@\n-     * @param v the value to store\n+     * @param v          the value to store\n@@ -3454,1 +3625,1 @@\n-     * @param v the value to store\n+     * @param v     the value to store\n@@ -3476,1 +3647,1 @@\n-     * @param v the value to cast\n+     * @param v          the value to cast\n@@ -3487,2 +3658,2 @@\n-     * @param t the type to cast to\n-     * @param v the value to cast\n+     * @param t          the type to cast to\n+     * @param v          the value to cast\n@@ -3542,1 +3713,1 @@\n-     * @param v the value to store in the var\n+     * @param v        the value to store in the var\n@@ -3810,1 +3981,3 @@\n-    public static ConcatOp concat(Value lhs, Value rhs) { return new ConcatOp(lhs, rhs); }\n+    public static ConcatOp concat(Value lhs, Value rhs) {\n+        return new ConcatOp(lhs, rhs);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":227,"deletions":54,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -41,3 +42,3 @@\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -216,0 +217,43 @@\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable {}\n+\n+    interface QuotableFunction<T, R> extends Function<T, R>, Quotable {}\n+\n+    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R>, Quotable {}\n+\n+    @DataProvider\n+    Iterator<Quotable> methodRefLambdas() {\n+        return List.of(\n+                (QuotableIntUnaryOperator) TestLambdaOps::m1,\n+                (QuotableIntUnaryOperator) TestLambdaOps::m2,\n+                (QuotableFunction<Integer, Integer>) TestLambdaOps::m1,\n+                (QuotableFunction<Integer, Integer>) TestLambdaOps::m2,\n+                (QuotableIntUnaryOperator) this::m3,\n+                (QuotableBiFunction<TestLambdaOps, Integer, Integer>) TestLambdaOps::m4\n+        ).iterator();\n+    }\n+\n+    @Test(dataProvider = \"methodRefLambdas\")\n+    public void testIsMethodReference(Quotable q) {\n+        Quoted quoted = q.quoted();\n+        CoreOps.LambdaOp lop = (CoreOps.LambdaOp) quoted.op();\n+        Assert.assertTrue(lop.isMethodReference().isPresent());\n+    }\n+\n+    static int m1(int i) {\n+        return i;\n+    }\n+\n+    static Integer m2(Integer i) {\n+        return i;\n+    }\n+\n+    int m3(int i) {\n+        return i;\n+    }\n+\n+    static int m4(TestLambdaOps tl, int i) {\n+        return i;\n+    }\n+\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"}]}