{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.Predicate;\n@@ -510,0 +511,133 @@\n+\n+        \/**\n+         * Determines if this lambda operation could have originated from a\n+         * method reference declared in Java source code.\n+         * <p>\n+         * Such a lambda operation is one with the following constraints:\n+         * <ol>\n+         *     <li>Zero or one captured value (assuming correspondence to the {@code this} variable).\n+         *     <li>A body with only one (entry) block that contains only variable declaration\n+         *     operations, variable load operations, invoke operations to box or unbox\n+         *     primitive values, a single invoke operation to the method that is\n+         *     referenced, and a return operation.\n+         *     <li>if the return operation returns a non-void result then that result is,\n+         *     or uniquely depends on, the result of the referencing invoke operation.\n+         *     <li>If the lambda operation captures one value then the first operand corresponds\n+         *     to captured the value, and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         *     Otherwise, the first and subsequent operands of the referencing invocation\n+         *     operation are, or uniquely depend on, the lambda operation's parameters, in order.\n+         * <\/ol>\n+         * A value, V2, uniquely depends on another value, V1, if the graph of what V2 depends on\n+         * contains only nodes with single edges terminating in V1, and the graph of what depends on V1\n+         * is bidirectionally equal to the graph of what V2 depends on.\n+         *\n+         * @return the invocation operation to the method referenced by the lambda\n+         * operation, otherwise empty.\n+         *\/\n+        public Optional<InvokeOp> methodReference() {\n+            \/\/ Single block\n+            if (body().blocks().size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Zero or one (this) capture\n+            List<Value> cvs = capturedValues();\n+            if (cvs.size() > 1) {\n+                return Optional.empty();\n+            }\n+\n+            Map<Value, Value> valueMapping = new HashMap<>();\n+            CoreOps.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, body().entryBlock().ops());\n+            if (methodRefInvokeOp == null) {\n+                return Optional.empty();\n+            }\n+\n+            \/\/ Lambda's parameters map in encounter order with the invocation's operands\n+            List<Value> lambdaParameters = new ArrayList<>();\n+            if (cvs.size() == 1) {\n+                lambdaParameters.add(cvs.getFirst());\n+            }\n+            lambdaParameters.addAll(parameters());\n+            List<Value> methodRefOperands = methodRefInvokeOp.operands().stream().map(valueMapping::get).toList();\n+            if (!lambdaParameters.equals(methodRefOperands)) {\n+                return Optional.empty();\n+            }\n+\n+            return Optional.of(methodRefInvokeOp);\n+        }\n+\n+        static CoreOps.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n+            CoreOps.InvokeOp methodRefInvokeOp = null;\n+            for (Op op : ops) {\n+                switch (op) {\n+                    case CoreOps.VarOp varOp -> {\n+                        if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOps.VarAccessOp.VarStoreOp)) {\n+                            return null;\n+                        }\n+                    }\n+                    case CoreOps.VarAccessOp.VarLoadOp varLoadOp -> {\n+                        Value v = varLoadOp.varOp().operands().getFirst();\n+                        valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case CoreOps.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n+                        Value v = iop.operands().getFirst();\n+                        valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n+                    }\n+                    case CoreOps.InvokeOp iop -> {\n+                        if (methodRefInvokeOp != null) {\n+                            return null;\n+                        }\n+\n+                        for (Value o : iop.operands()) {\n+                            valueMapping.put(o, valueMapping.getOrDefault(o, o));\n+                        }\n+                        methodRefInvokeOp = iop;\n+                    }\n+                    case CoreOps.ReturnOp rop -> {\n+                        if (methodRefInvokeOp == null) {\n+                            return null;\n+                        }\n+                        Value r = rop.returnValue();\n+                        if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n+                            return null;\n+                        }\n+                        if (invokeResult.op() != methodRefInvokeOp) {\n+                            return null;\n+                        }\n+                        assert methodRefInvokeOp.result().uses().size() == 1;\n+                    }\n+                    default -> {\n+                        return null;\n+                    }\n+                }\n+            }\n+\n+            return methodRefInvokeOp;\n+        }\n+\n+        private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+            for (Op.Result user : value.uses()) {\n+                if (opPredicate.test(user.op())) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ @@@ Move to functionality on JavaType(s)\n+        static final Set<String> UNBOX_NAMES = Set.of(\n+                \"byteValue\",\n+                \"shortValue\",\n+                \"charValue\",\n+                \"intValue\",\n+                \"longValue\",\n+                \"floatValue\",\n+                \"doubleValue\",\n+                \"booleanValue\");\n+\n+        private static boolean isBoxOrUnboxInvocation(CoreOps.InvokeOp iop) {\n+            MethodRef mr = iop.invokeDescriptor();\n+            Collection<TypeElement> boxTypes = JavaType.primitiveToWrapper.values();\n+            return boxTypes.contains(mr.refType()) && (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n+        }\n@@ -605,1 +739,0 @@\n-     *\n@@ -996,1 +1129,1 @@\n-            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE,true,\n+            Object value = def.extractAttributeValue(ATTRIBUTE_CONSTANT_VALUE, true,\n@@ -1127,1 +1260,1 @@\n-                    true, v -> switch(v) {\n+                    true, v -> switch (v) {\n@@ -1238,2 +1371,2 @@\n-            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,true,\n-                    v -> switch(v) {\n+            FunctionType constructorType = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR, true,\n+                    v -> switch (v) {\n@@ -1364,2 +1497,2 @@\n-                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n-                        v -> switch(v) {\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n@@ -1368,1 +1501,2 @@\n-                            default -> throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                            default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n@@ -1423,2 +1557,2 @@\n-                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR,true,\n-                        v -> switch(v) {\n+                FieldRef fieldDescriptor = def.extractAttributeValue(ATTRIBUTE_FIELD_DESCRIPTOR, true,\n+                        v -> switch (v) {\n@@ -1427,1 +1561,2 @@\n-                            default -> throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n+                            default ->\n+                                    throw new UnsupportedOperationException(\"Unsupported field descriptor value:\" + v);\n@@ -1625,1 +1760,1 @@\n-                    v -> switch(v) {\n+                    v -> switch (v) {\n@@ -1691,1 +1826,1 @@\n-                    v -> switch(v) {\n+                    v -> switch (v) {\n@@ -1758,0 +1893,1 @@\n+         *\n@@ -1759,0 +1895,1 @@\n+         * @param <T>   the type of the var's value.\n@@ -1760,1 +1897,0 @@\n-         * @param <T> the type of the var's value.\n@@ -2306,1 +2442,1 @@\n-            super(ConcatOp.NAME, List.of(lhs,rhs));\n+            super(ConcatOp.NAME, List.of(lhs, rhs));\n@@ -2308,0 +2444,1 @@\n+\n@@ -2955,0 +3092,1 @@\n+     *\n@@ -2965,0 +3103,1 @@\n+     *\n@@ -2966,1 +3105,1 @@\n-     * @param body the function body\n+     * @param body     the function body\n@@ -2975,0 +3114,1 @@\n+     *\n@@ -2977,1 +3117,1 @@\n-     * @param args the function arguments\n+     * @param args     the function arguments\n@@ -2986,0 +3126,1 @@\n+     *\n@@ -2988,1 +3129,1 @@\n-     * @param args the function arguments\n+     * @param args     the function arguments\n@@ -2997,0 +3138,1 @@\n+     *\n@@ -3007,0 +3149,1 @@\n+     *\n@@ -3017,0 +3160,1 @@\n+     *\n@@ -3026,0 +3170,1 @@\n+     *\n@@ -3035,0 +3180,1 @@\n+     *\n@@ -3036,1 +3182,1 @@\n-     * @param opFunc a function that accepts the body of the quoted operation and returns the operation to be quoted\n+     * @param opFunc       a function that accepts the body of the quoted operation and returns the operation to be quoted\n@@ -3050,0 +3196,1 @@\n+     *\n@@ -3059,2 +3206,3 @@\n-     * @param ancestorBody the ancestor of the body of the lambda operation\n-     * @param funcType the lambda operation's function type\n+     *\n+     * @param ancestorBody        the ancestor of the body of the lambda operation\n+     * @param funcType            the lambda operation's function type\n@@ -3071,0 +3219,1 @@\n+     *\n@@ -3072,1 +3221,1 @@\n-     * @param body the body of the lambda operation\n+     * @param body                the body of the lambda operation\n@@ -3081,0 +3230,1 @@\n+     *\n@@ -3082,1 +3232,1 @@\n-     * @param funcType the closure operation's function type\n+     * @param funcType     the closure operation's function type\n@@ -3092,0 +3242,1 @@\n+     *\n@@ -3101,0 +3252,1 @@\n+     *\n@@ -3111,0 +3263,1 @@\n+     *\n@@ -3121,1 +3274,2 @@\n-     * @param start the exception region block\n+     *\n+     * @param start    the exception region block\n@@ -3131,1 +3285,2 @@\n-     * @param start the exception region block\n+     *\n+     * @param start    the exception region block\n@@ -3144,0 +3299,1 @@\n+     *\n@@ -3145,1 +3301,1 @@\n-     * @param end the block to which control is transferred after the exception region is exited\n+     * @param end             the block to which control is transferred after the exception region is exited\n@@ -3154,0 +3310,1 @@\n+     *\n@@ -3162,0 +3319,1 @@\n+     *\n@@ -3171,0 +3329,1 @@\n+     *\n@@ -3180,0 +3339,1 @@\n+     *\n@@ -3188,0 +3348,1 @@\n+     *\n@@ -3196,0 +3357,1 @@\n+     *\n@@ -3205,0 +3367,1 @@\n+     *\n@@ -3214,0 +3377,1 @@\n+     *\n@@ -3223,2 +3387,3 @@\n-     * @param condValue the test value of the conditional break operation\n-     * @param trueTarget the jump target when the test value evaluates to true\n+     *\n+     * @param condValue   the test value of the conditional break operation\n+     * @param trueTarget  the jump target when the test value evaluates to true\n@@ -3235,1 +3400,2 @@\n-     * @param type the constant type\n+     *\n+     * @param type  the constant type\n@@ -3247,1 +3413,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3258,1 +3424,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3268,1 +3434,1 @@\n-     * @param returnType the invocation return type\n+     * @param returnType       the invocation return type\n@@ -3270,1 +3436,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3280,1 +3446,1 @@\n-     * @param returnType the invocation return type\n+     * @param returnType       the invocation return type\n@@ -3282,1 +3448,1 @@\n-     * @param args the invoke parameters\n+     * @param args             the invoke parameters\n@@ -3292,1 +3458,1 @@\n-     * @param to the conversion target type\n+     * @param to   the conversion target type\n@@ -3304,1 +3470,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3315,1 +3481,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3325,1 +3491,1 @@\n-     * @param returnType the instance type\n+     * @param returnType      the instance type\n@@ -3327,1 +3493,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3338,1 +3504,1 @@\n-     * @param returnType the instance type\n+     * @param returnType      the instance type\n@@ -3340,1 +3506,1 @@\n-     * @param args the constructor arguments\n+     * @param args            the constructor arguments\n@@ -3352,1 +3518,1 @@\n-     * @param length the array size\n+     * @param length    the array size\n@@ -3365,1 +3531,1 @@\n-     * @param receiver the receiver value\n+     * @param receiver   the receiver value\n@@ -3377,1 +3543,1 @@\n-     * @param receiver the receiver value\n+     * @param receiver   the receiver value\n@@ -3409,2 +3575,2 @@\n-     * @param receiver the receiver value\n-     * @param v the value to store\n+     * @param receiver   the receiver value\n+     * @param v          the value to store\n@@ -3421,1 +3587,1 @@\n-     * @param v the value to store\n+     * @param v          the value to store\n@@ -3454,1 +3620,1 @@\n-     * @param v the value to store\n+     * @param v     the value to store\n@@ -3476,1 +3642,1 @@\n-     * @param v the value to cast\n+     * @param v          the value to cast\n@@ -3487,2 +3653,2 @@\n-     * @param t the type to cast to\n-     * @param v the value to cast\n+     * @param t          the type to cast to\n+     * @param v          the value to cast\n@@ -3542,1 +3708,1 @@\n-     * @param v the value to store in the var\n+     * @param v        the value to store in the var\n@@ -3810,1 +3976,3 @@\n-    public static ConcatOp concat(Value lhs, Value rhs) { return new ConcatOp(lhs, rhs); }\n+    public static ConcatOp concat(Value lhs, Value rhs) {\n+        return new ConcatOp(lhs, rhs);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":222,"deletions":54,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -41,3 +42,3 @@\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -216,0 +217,43 @@\n+\n+    interface QuotableIntUnaryOperator extends IntUnaryOperator, Quotable {}\n+\n+    interface QuotableFunction<T, R> extends Function<T, R>, Quotable {}\n+\n+    interface QuotableBiFunction<T, U, R> extends BiFunction<T, U, R>, Quotable {}\n+\n+    @DataProvider\n+    Iterator<Quotable> methodRefLambdas() {\n+        return List.of(\n+                (QuotableIntUnaryOperator) TestLambdaOps::m1,\n+                (QuotableIntUnaryOperator) TestLambdaOps::m2,\n+                (QuotableFunction<Integer, Integer>) TestLambdaOps::m1,\n+                (QuotableFunction<Integer, Integer>) TestLambdaOps::m2,\n+                (QuotableIntUnaryOperator) this::m3,\n+                (QuotableBiFunction<TestLambdaOps, Integer, Integer>) TestLambdaOps::m4\n+        ).iterator();\n+    }\n+\n+    @Test(dataProvider = \"methodRefLambdas\")\n+    public void testIsMethodReference(Quotable q) {\n+        Quoted quoted = q.quoted();\n+        CoreOps.LambdaOp lop = (CoreOps.LambdaOp) quoted.op();\n+        Assert.assertTrue(lop.methodReference().isPresent());\n+    }\n+\n+    static int m1(int i) {\n+        return i;\n+    }\n+\n+    static Integer m2(Integer i) {\n+        return i;\n+    }\n+\n+    int m3(int i) {\n+        return i;\n+    }\n+\n+    static int m4(TestLambdaOps tl, int i) {\n+        return i;\n+    }\n+\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLambdaOps.java","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"}]}