{"files":[{"patch":"@@ -136,1 +136,18 @@\n-    const int threadsPerBlock = estimateThreadsPerBlock(kernelContext->dimensions);\n+    int threadsPerBlockX;\n+    int threadsPerBlockY = 1;\n+    int threadsPerBlockZ = 1;\n+    if (kernelContext -> lsx > 0) {\n+        threadsPerBlockX = kernelContext -> lsx;\n+    } else {\n+        threadsPerBlockX = estimateThreadsPerBlock(kernelContext->dimensions);\n+    }\n+    if (kernelContext-> lsy > 0) {\n+        threadsPerBlockY = kernelContext-> lsy;\n+    } else if (kernelContext->dimensions > 1) {\n+        threadsPerBlockY = estimateThreadsPerBlock(kernelContext->dimensions);\n+    }\n+    if (kernelContext-> lsz > 0) {\n+        threadsPerBlockZ = kernelContext-> lsz;\n+    } else if (kernelContext->dimensions > 2) {\n+        threadsPerBlockZ = estimateThreadsPerBlock(kernelContext->dimensions);\n+    }\n@@ -138,1 +155,1 @@\n-    int blocksPerGridX = (kernelContext->maxX + threadsPerBlock - 1) \/ threadsPerBlock;\n+    int blocksPerGridX = (kernelContext->maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n@@ -141,3 +158,0 @@\n-    int threadsPerBlockX = threadsPerBlock;\n-    int threadsPerBlockY = 1;\n-    int threadsPerBlockZ = 1;\n@@ -146,2 +160,1 @@\n-        blocksPerGridY = (kernelContext->maxY + threadsPerBlock - 1) \/ threadsPerBlock;\n-        threadsPerBlockY = threadsPerBlock;\n+        blocksPerGridY = (kernelContext->maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n@@ -150,2 +163,1 @@\n-        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlock - 1) \/ threadsPerBlock;\n-        threadsPerBlockZ = threadsPerBlock;\n+        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n@@ -154,2 +166,2 @@\n-    \/\/ Enable debug information with trace. Use HAT=TRACE\n-    if (backend->config->trace) {\n+    \/\/ Enable debug information with trace. Use HAT=INFO\n+    if (backend->config->info) {\n@@ -157,2 +169,2 @@\n-        std::cout << \"   \\\\_ BlocksPerGrid  = [\" << blocksPerGridX << \",\" << blocksPerGridY << \",\" << blocksPerGridZ << \"]\" << std::endl;\n-        std::cout << \"   \\\\_ ThreadsPerBlock  [\" << threadsPerBlockX << \",\" << threadsPerBlockY << \",\" << threadsPerBlockZ << \"]\" << std::endl;\n+        std::cout << \"   \\\\_ BlocksPerGrid   = [\" << blocksPerGridX << \",\" << blocksPerGridY << \",\" << blocksPerGridZ << \"]\" << std::endl;\n+        std::cout << \"   \\\\_ ThreadsPerBlock = [\" << threadsPerBlockX << \",\" << threadsPerBlockY << \",\" << threadsPerBlockZ << \"]\" << std::endl;\n@@ -161,3 +173,0 @@\n-    \/\/  auto status= static_cast<CUresult>(cudaStreamSynchronize(cudaBackend->cudaQueue.cuStream));\n-    \/\/  cudaBackend->cudaQueue.wait();\n-\n@@ -178,1 +187,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -189,2 +189,0 @@\n-\n-\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/include\/cuda_backend.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                var kernel = compilationUnit.getKernel( kernelCallGraph.entrypoint.method.getName());\n+                var kernel = compilationUnit.getKernel(kernelCallGraph.entrypoint.method.getName());\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-\n@@ -252,0 +251,13 @@\n+    size_t local_work_size[] = {\n+        static_cast<size_t>(kernelContext->lsx),\n+        static_cast<size_t>(kernelContext->lsy),\n+        static_cast<size_t>(kernelContext->lsz),\n+    };\n+\n+    if (backend->config->info) {\n+        std::cout << \"[INFO] OpenCLBackend::OpenCLQueue::dispatch\" << std::endl;\n+        std::cout << \"[INFO] numDimensions: \" << numDimensions << std::endl;\n+        std::cout << \"[INFO] GLOBAL [\" << global_work_size[0] << \",\" << global_work_size[1] << \",\" << global_work_size[2] << \"]\" << std::endl;\n+        std::cout << \"[INFO] LOCAL  [\" << local_work_size[0] << \",\" << local_work_size[1] << \",\" << local_work_size[2] << \"]\" << std::endl;\n+    }\n+\n@@ -258,1 +270,1 @@\n-        nullptr, \/\/ TODO: Select a local work group instead of the default one\n+        kernelContext->lsx > 0 ? local_work_size : nullptr,\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_queue.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ComputeRange;\n@@ -29,0 +30,2 @@\n+import hat.ThreadMesh;\n+import hat.buffer.KernelBufferContext;\n@@ -33,1 +36,0 @@\n-import hat.buffer.KernelContext;\n@@ -57,1 +59,1 @@\n-        public final KernelContext kernelContext;\n+        public final KernelBufferContext kernelBufferContext;\n@@ -63,3 +65,3 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0);\n-            ndRangeAndArgs[0] = this.kernelContext;\n-            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator,kernelCallGraph,  ndRangeAndArgs);\n+            this.kernelBufferContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0, new int[] {0, 0, 0}, new int[]{0, 0, 0});\n+            ndRangeAndArgs[0] = this.kernelBufferContext;\n+            this.argArray = ArgArray.create(kernelCallGraph.computeContext.accelerator, kernelCallGraph,  ndRangeAndArgs);\n@@ -69,9 +71,20 @@\n-          \/\/  long ns = System.nanoTime();\n-            kernelContext.maxX(ndRange.kid.maxX);\n-            kernelContext.maxY(ndRange.kid.maxY);\n-            kernelContext.maxZ(ndRange.kid.maxZ);\n-            kernelContext.dimensions(ndRange.kid.getDimensions());\n-            args[0] = this.kernelContext;\n-            ArgArray.update(argArray,kernelCallGraph, args);\n-            \/\/System.out.println(\"argupdate  \"+((System.nanoTime()-ns)\/1000)+\" us\");\n-           \/\/ ns = System.nanoTime();\n+            ComputeRange computeRange = ndRange.kid.getComputeRange();\n+            assert computeRange != null;\n+            ThreadMesh globalMesh = computeRange.getGlobalMesh();\n+            ThreadMesh localMesh = computeRange.getLocalMesh();\n+            kernelBufferContext.maxX(globalMesh.getX());\n+            kernelBufferContext.maxY(globalMesh.getY());\n+            kernelBufferContext.maxZ(globalMesh.getZ());\n+            kernelBufferContext.dimensions(globalMesh.getDims());\n+            if (localMesh != null) {\n+                kernelBufferContext.lsx(localMesh.getX());\n+                kernelBufferContext.lsy(localMesh.getY());\n+                kernelBufferContext.lsz(localMesh.getZ());\n+            } else {\n+                kernelBufferContext.lsx(0);\n+                kernelBufferContext.lsy(0);\n+                kernelBufferContext.lsz(0);\n+            }\n+\n+            args[0] = this.kernelBufferContext;\n+            ArgArray.update(argArray, kernelCallGraph, args);\n@@ -79,1 +92,0 @@\n-           \/\/ System.out.println(\"dispatch time \"+((System.nanoTime()-ns)\/1000)+\" us\");\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -362,1 +362,0 @@\n-\n@@ -372,0 +371,6 @@\n+    int lx;\n+    int ly;\n+    int lz;\n+    int lsx;\n+    int lsy;\n+    int lsz;\n@@ -374,1 +379,0 @@\n-\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/shared.h","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -54,1 +54,1 @@\n-        public final KernelContext kernelContext;\n+        public final KernelBufferContext kernelContext;\n@@ -61,1 +61,2 @@\n-            this.kernelContext = KernelContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n+            this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0, 0, 0, 0, 0, new int[] {0, 0, 0}, new int[]{0, 0, 0});\n+            \/\/this.kernelContext = KernelBufferContext.create(kernelCallGraph.computeContext.accelerator, 0, 0);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    public NDRange range(int max) {\n+    public NDRange range(ComputeRange computeRange) {\n@@ -86,13 +86,1 @@\n-        ndRange.kid = new KernelContext(ndRange, max);\n-        return ndRange;\n-    }\n-\n-    public NDRange range(int maxX, int maxY) {\n-        NDRange ndRange = new NDRange(this);\n-        ndRange.kid = new KernelContext(ndRange, maxX, maxY);\n-        return ndRange;\n-    }\n-\n-    public NDRange range(int maxX, int maxY, int maxZ) {\n-        NDRange ndRange = new NDRange(this);\n-        ndRange.kid = new KernelContext(ndRange, maxX, maxY, maxZ);\n+        ndRange.kid = new KernelContext(ndRange, computeRange);\n@@ -210,1 +198,0 @@\n-\n@@ -223,1 +210,1 @@\n-        \/\/ Here we get the captured values  from the Quotable\n+        \/\/ Here we get the captured values from the Quotable\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * callgraphs for the work to be performed by the backend.\n+ * call graphs for the work to be performed by the backend.\n@@ -105,1 +105,0 @@\n-\n@@ -124,1 +123,1 @@\n-     * @param range\n+     * @param computeRange\n@@ -128,10 +127,2 @@\n-    public void dispatchKernel(int range, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernel(range, 0, 0, 1, quotableKernelContextConsumer);\n-    }\n-\n-    public void dispatchKernel(int rangeX, int rangeY, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernel(rangeX, rangeY, 0, 2, quotableKernelContextConsumer);\n-    }\n-\n-    public void dispatchKernel(int rangeX, int rangeY, int rangeZ, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n-        dispatchKernel(rangeX, rangeY, rangeZ, 3, quotableKernelContextConsumer);\n+    public void dispatchKernel(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+        dispatchKernelWithComputeRange(computeRange, quotableKernelContextConsumer);\n@@ -140,1 +131,1 @@\n-    private void dispatchKernel(int rangeX, int rangeY, int rangeZ, int dimNumber, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n+    private void dispatchKernelWithComputeRange(ComputeRange computeRange, QuotableKernelContextConsumer quotableKernelContextConsumer) {\n@@ -147,7 +138,1 @@\n-            NDRange ndRange;\n-            switch (dimNumber) {\n-                case 1 -> ndRange = accelerator.range(rangeX);\n-                case 2 -> ndRange = accelerator.range(rangeX, rangeY);\n-                case 3 -> ndRange = accelerator.range(rangeX, rangeY, rangeZ);\n-                default -> throw new RuntimeException(\"[Error] Unexpected dimension value: \" + dimNumber + \". Allowed dimensions <1, 2, 3>\");\n-            }\n+            NDRange ndRange = accelerator.range(computeRange);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+\/**\n+ * A compute range holds the number of threads to run on an accelerator.\n+ * A compute range has two main properties:\n+ * - The global number of threads: this means the total number of threads to run per dimension.\n+ * This is specified by instancing a new object of type {@link ThreadMesh}.\n+ * - A local group size: this is specified by instancing an object of type {@link ThreadMesh}.\n+ * A local group size is optional. If it is not specified, the HAT runtime may device a default\n+ * value.\n+ *\/\n+public class ComputeRange {\n+\n+    final private ThreadMesh globalMesh;\n+    final private ThreadMesh localMesh;\n+\n+    \/**\n+     * Total number of threads to run per dimension.\n+     * @param globalMesh {@link ThreadMesh}\n+     *\/\n+    public ComputeRange(ThreadMesh globalMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = null;\n+    }\n+\n+    \/**\n+     * Total and local number of threads to run per dimension.\n+     * @param globalMesh {@link ThreadMesh}\n+     * @param localMesh {@link ThreadMesh}\n+     *\/\n+    public ComputeRange(ThreadMesh globalMesh, ThreadMesh localMesh) {\n+        this.globalMesh = globalMesh;\n+        this.localMesh = localMesh;\n+    }\n+\n+    \/**\n+     * Factory method to run a single thread on a target accelerator. Although for some accelerators this could be\n+     * beneficial (e.g., FPGAs), in general, use only for debugging purposes.\n+     *\/\n+    public static final ComputeRange SINGLE_THREADED = new ComputeRange(new ThreadMesh(1));\n+\n+    \/**\n+     * Obtain the total number of threads per dimension. The number of threads\n+     * per dimension is stored in a {@link ThreadMesh}\n+     * @return {@link ThreadMesh}\n+     *\/\n+    public ThreadMesh getGlobalMesh() {\n+        return globalMesh;\n+    }\n+\n+    \/**\n+     * Obtain the local group size per dimension. The group size per dimension is stored\n+     * in a {@link ThreadMesh}.\n+     * @return {@link ThreadMesh}\n+     *\/\n+    public ThreadMesh getLocalMesh() {\n+        return localMesh;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeRange.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -44,0 +44,1 @@\n+    private final ComputeRange computeRange;\n@@ -55,6 +56,1 @@\n-    \/**\n-     * 1D Kernel\n-     * @param ndRange {@link NDRange}\n-     * @param maxX Global number of threads for the first dimension (1D)\n-     *\/\n-    public KernelContext(NDRange ndRange, int maxX) {\n+    public KernelContext(NDRange ndRange, ComputeRange computeRange) {\n@@ -62,1 +58,2 @@\n-        this.maxX = maxX;\n+        this.computeRange = computeRange;\n+        this.maxX = 0;\n@@ -68,29 +65,0 @@\n-    \/**\n-     * 1D Kernel\n-     * @param ndRange {@link NDRange}\n-     * @param maxX Global number of threads for the first dimension (1D)\n-     * @param maxY Global number of threads for the second dimension (2D)\n-     *\/\n-    public KernelContext(NDRange ndRange, int maxX, int maxY) {\n-        this.ndRange = ndRange;\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = 0;\n-        this.dimensions = 2;\n-    }\n-\n-    \/**\n-     * 1D Kernel\n-     * @param ndRange {@link NDRange}\n-     * @param maxX Global number of threads for the first dimension (1D)\n-     * @param maxY Global number of threads for the second dimension (2D)\n-     * @param maxZ Global number of threads for the second dimension (3D)\n-     *\/\n-    public KernelContext(NDRange ndRange, int maxX, int maxY, int maxZ) {\n-        this.ndRange = ndRange;\n-        this.maxX = maxX;\n-        this.maxY = maxY;\n-        this.maxZ = maxZ;\n-        this.dimensions = 3;\n-    }\n-\n@@ -101,0 +69,4 @@\n+    public ComputeRange getComputeRange() {\n+        return this.computeRange;\n+    }\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/KernelContext.java","additions":8,"deletions":36,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-\n-\n@@ -431,1 +429,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/OpsAndTypes.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat;\n+\n+\/**\n+ * Specifies the number of threads per dimension. The Thread Mesh can be used to\n+ * store the global number of threads, local group sizes and offsets.\n+ *\/\n+public class ThreadMesh {\n+\n+    final private int x;\n+    final private int y;\n+    final private int z;\n+    final private int dims;\n+\n+    \/**\n+     * 1D Mesh\n+     * @param x\n+     *\/\n+    public ThreadMesh(int x) {\n+        this.x = x;\n+        this.y = 0;\n+        this.z = 0;\n+        this.dims = 1;\n+    }\n+\n+    \/**\n+     * 2D Mesh\n+     * @param x\n+     * @param y\n+     *\/\n+    public ThreadMesh(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = 0;\n+        this.dims = 2;\n+    }\n+\n+    \/**\n+     * 3D Mesh of threads\n+     * @param x\n+     * @param y\n+     * @param z\n+     *\/\n+    public ThreadMesh(int x, int y, int z) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+        this.dims = 3;\n+    }\n+\n+    \/**\n+     * Obtain the number of threads in the first dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    public int getX() {\n+        return x;\n+    }\n+\n+    \/**\n+     * Obtain the number of threads in the second dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    public int getY() {\n+        return y;\n+    }\n+\n+    \/**\n+     * Obtain the number of threads in the third dimension of the thread-mesh.\n+     * @return\n+     *\/\n+    public int getZ() {\n+        return z;\n+    }\n+\n+    \/**\n+     * Return the mesh dimension. It could be 1, 2 or 3.\n+     * @return int value\n+     *\/\n+    public int getDims() {\n+        return dims;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/ThreadMesh.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -31,0 +32,1 @@\n+import hat.ThreadMesh;\n@@ -76,1 +78,1 @@\n-                        ndRange.kid = new KernelContext(ndRange, range);\n+                        ndRange.kid = new KernelContext(ndRange, new ComputeRange(new ThreadMesh(range)));\n","filename":"hat\/core\/src\/main\/java\/hat\/backend\/java\/WorkStealer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+public interface KernelBufferContext extends Buffer {\n+    int x();\n+    void x(int x);\n+\n+    int y();\n+    void y(int y);\n+\n+    int z();\n+    void z(int z);\n+\n+    int maxX();\n+    void maxX(int maxX);\n+\n+    int maxY();\n+    void maxY(int maxY);\n+\n+    int maxZ();\n+    void maxZ(int maxZ);\n+\n+    int lx();\n+    void lx(int lx);\n+    int ly();\n+    void ly(int ly);\n+    int lz();\n+    void lz(int lz);\n+\n+    int lsx();\n+    void lsx(int lsx);\n+    int lsy();\n+    void lsy(int lsy);\n+    int lsz();\n+    void lsz(int lsz);\n+\n+    int dimensions();\n+    void dimensions(int numDimensions);\n+\n+    \/\/ Important part here! do not forget the new fields.\n+    Schema<KernelBufferContext> schema = Schema.of(KernelBufferContext.class,\n+            s -> s.fields(\n+                    \"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\",\n+                    \"dimensions\",\n+                    \"lx\", \"ly\", \"lz\", \"lsx\",  \"lsy\", \"lsz\"));\n+\n+    static KernelBufferContext create(Accelerator accelerator, int x, int y, int z, int maxX, int maxY, int maxZ, int[] locals, int[] lgs) {\n+        KernelBufferContext kernelContext =  schema.allocate(accelerator);\n+        kernelContext.x(x);\n+        kernelContext.y(y);\n+        kernelContext.z(z);\n+        kernelContext.maxX(maxX);\n+        kernelContext.maxY(maxY);\n+        kernelContext.maxZ(maxZ);\n+        kernelContext.dimensions(3);\n+        if (locals != null) {\n+            kernelContext.lx(locals[0]);\n+            kernelContext.ly(locals[1]);\n+            kernelContext.lz(locals[2]);\n+        }\n+        if (lgs != null) {\n+            kernelContext.lsx(lgs[0]);\n+            kernelContext.lsy(lgs[1]);\n+            kernelContext.lsz(lgs[2]);\n+        }\n+        return kernelContext;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n-\n-public interface KernelContext extends Buffer {\n-    int x();\n-    void x(int x);\n-\n-    int y();\n-    void y(int y);\n-\n-    int z();\n-    void z(int z);\n-\n-    int maxX();\n-    void maxX(int maxX);\n-\n-    int maxY();\n-    void maxY(int maxY);\n-\n-    int maxZ();\n-    void maxZ(int maxZ);\n-\n-    int dimensions();\n-    void dimensions(int numDimensions);\n-\n-    \/\/ Important part here! do not forget the new fields.\n-    Schema<KernelContext> schema = Schema.of(KernelContext.class, s->s.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"));\n-\n-    static KernelContext create(Accelerator accelerator, int x, int maxX) {\n-        KernelContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.maxX(maxX);\n-        kernelContext.dimensions(1);\n-        return kernelContext;\n-    }\n-\n-    static KernelContext create(Accelerator accelerator, int x, int y, int z, int maxX, int maxY, int maxZ) {\n-        KernelContext kernelContext =  schema.allocate(accelerator);\n-        kernelContext.x(x);\n-        kernelContext.y(y);\n-        kernelContext.z(z);\n-        kernelContext.maxX(maxX);\n-        kernelContext.maxY(maxY);\n-        kernelContext.maxZ(maxZ);\n-        kernelContext.dimensions(3);\n-        return kernelContext;\n-    }\n-\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n-\n@@ -72,1 +71,1 @@\n-                    if (ndRange.kid.getDimensions() > 1) {\n+                    if (ndRange.kid.getComputeRange().getGlobalMesh().getDims() > 1) {\n@@ -78,1 +77,1 @@\n-                    if (ndRange.kid.getDimensions() > 2) {\n+                    if (ndRange.kid.getComputeRange().getGlobalMesh().getDims() > 2) {\n@@ -105,1 +104,1 @@\n-        if (ndRange.kid.getDimensions() > 1) {\n+        if (ndRange.kid.getComputeRange().getGlobalMesh().getDims() > 1) {\n@@ -109,1 +108,1 @@\n-        if (ndRange.kid.getDimensions() > 2) {\n+        if (ndRange.kid.getComputeRange().getGlobalMesh().getDims() > 2) {\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.KernelContext;\n+import hat.buffer.KernelBufferContext;\n@@ -63,1 +63,1 @@\n-                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelContext.class))\n+                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelBufferContext.class))\n@@ -68,1 +68,1 @@\n-        return isAssignable(javaRefType(), KernelContext.class);\n+        return isAssignable(javaRefType(), KernelBufferContext.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.ComputeRange;\n@@ -31,0 +32,1 @@\n+import hat.ThreadMesh;\n@@ -95,1 +97,2 @@\n-        cc.dispatchKernel(call.length(),\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(call.length()));\n+        cc.dispatchKernel(computeRange,\n","filename":"hat\/examples\/blackscholes\/src\/main\/java\/blackscholes\/Main.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.ComputeRange;\n@@ -31,0 +32,1 @@\n+import hat.ThreadMesh;\n@@ -317,1 +319,1 @@\n-        cc.dispatchKernel(1,\n+        cc.dispatchKernel(new ComputeRange(new ThreadMesh(1)),\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Chess.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -79,3 +81,4 @@\n-            computeContext.dispatchKernel(a.length(), (kc) -> counted(kc, a));\n-            computeContext.dispatchKernel(a.length(), (kc) -> tuple(kc, a));\n-            computeContext.dispatchKernel(a.length(), (kc) -> breakAndContinue(kc, a));\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(a.length()));\n+            computeContext.dispatchKernel(computeRange, (kc) -> counted(kc, a));\n+            computeContext.dispatchKernel(computeRange, (kc) -> tuple(kc, a));\n+            computeContext.dispatchKernel(computeRange, (kc) -> breakAndContinue(kc, a));\n@@ -83,1 +86,0 @@\n-\n@@ -86,2 +88,1 @@\n-    public static void main(String[] args) {\n-\n+    static void main(String[] args) {\n@@ -96,1 +97,0 @@\n-\n@@ -98,1 +98,0 @@\n-\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/ForTests.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -130,1 +132,2 @@\n-            cc.dispatchKernel(meshData.points(),\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(meshData.points()));\n+            cc.dispatchKernel(computeRange,\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Mesh.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -53,1 +55,2 @@\n-                cc.dispatchKernel(len, kc -> inc(kc, s32Array, len));\n+                ComputeRange computeRange = new ComputeRange(new ThreadMesh(len));\n+                cc.dispatchKernel(computeRange, kc -> inc(kc, s32Array, len));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/MinBufferTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -32,0 +33,1 @@\n+import hat.ThreadMesh;\n@@ -108,1 +110,2 @@\n-            cc.dispatchKernel(1, kc -> Compute.testMethodKernel(kc, coloredWeightedPoint));\n+            ComputeRange computeRange = ComputeRange.SINGLE_THREADED;\n+            cc.dispatchKernel(computeRange, kc -> Compute.testMethodKernel(kc, coloredWeightedPoint));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHat.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -111,1 +112,1 @@\n-            cc.dispatchKernel(1, kc -> Compute.testMethodKernel(kc, pointArray));\n+            cc.dispatchKernel(ComputeRange.SINGLE_THREADED, kc -> Compute.testMethodKernel(kc, pointArray));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PointyHatArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -110,1 +112,2 @@\n-            computeContext.dispatchKernel(size * size, kc -> MatrixMultiply.kernel(kc, a, b, c));\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(size * size));\n+            computeContext.dispatchKernel(computeRange, kc -> MatrixMultiply.kernel(kc, a, b, c));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/GetBackend.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -115,1 +117,1 @@\n-\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(size * size));\n@@ -117,1 +119,1 @@\n-                    size * size,                \/\/ range is passed as int and creation internalized\n+                    computeRange,                \/\/ range is passed as int and creation internalized\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/spirv\/MatrixMultiply.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import hat.ComputeRange;\n@@ -51,0 +52,1 @@\n+import hat.ThreadMesh;\n@@ -252,1 +254,2 @@\n-        cc.dispatchKernel(searchArea.area(),\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(searchArea.area()));\n+        cc.dispatchKernel(computeRange,\n","filename":"hat\/examples\/heal\/src\/main\/java\/heal\/Compute.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -217,0 +219,1 @@\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(range));\n@@ -218,1 +221,1 @@\n-                cc.dispatchKernel(range, kc -> Compute.life(kc, ctrl, grid));\n+                cc.dispatchKernel(computeRange, kc -> Compute.life(kc, ctrl, grid));\n","filename":"hat\/examples\/life\/src\/main\/java\/life\/Main.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -67,1 +69,1 @@\n-\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(s32Array2D.width()*s32Array2D.height()));\n@@ -69,1 +71,1 @@\n-                s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                computeRange, \/\/0..S32Array2D.size()\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -131,1 +133,2 @@\n-        cc.dispatchKernel(size,\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(size));\n+        cc.dispatchKernel(computeRange,\n@@ -133,1 +136,1 @@\n-        );\n+                );\n@@ -137,3 +140,4 @@\n-    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int size) {\n-        cc.dispatchKernel(size, size,\n-                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, size)\n+    public static void matrixMultiply2D(@RO ComputeContext cc, @RO F32Array matrixA, @RO F32Array matrixB, @RW  F32Array matrixC, int globalSize) {\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(globalSize, globalSize), new ThreadMesh(16, 16));\n+        cc.dispatchKernel(computeRange,\n+                kc -> matrixMultiplyKernel2D(kc, matrixA, matrixB, matrixC, globalSize)\n@@ -145,1 +149,2 @@\n-        cc.dispatchKernel(size, size,\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(size, size));\n+        cc.dispatchKernel(computeRange,\n@@ -180,1 +185,1 @@\n-    public static void main(String[] args) {\n+    static void main(String[] args) {\n@@ -217,1 +222,1 @@\n-\n+        int[] locals = new int[] { 0, 1, 2, 4, 1, 2, 2, 4, 5};\n@@ -221,0 +226,1 @@\n+            final int index = it;\n@@ -229,1 +235,0 @@\n-\n","filename":"hat\/examples\/matmul\/src\/main\/java\/matmul\/Main.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import hat.ComputeRange;\n@@ -31,0 +32,1 @@\n+import hat.ThreadMesh;\n@@ -103,2 +105,2 @@\n-\n-        cc.dispatchKernel(universe.length(), kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(universe.length()));\n+        cc.dispatchKernel(computeRange, kc -> nbodyKernel(kc, universe, cmass, cdelT, cespSqr));\n","filename":"hat\/examples\/nbody\/src\/main\/java\/nbody\/opencl\/OpenCLNBodyGLWindow.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import hat.ComputeRange;\n@@ -30,0 +31,1 @@\n+import hat.ThreadMesh;\n@@ -55,1 +57,2 @@\n-        cc.dispatchKernel(s32Array.length(),\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(s32Array.length()));\n+        cc.dispatchKernel(computeRange,\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Main.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ComputeRange;\n@@ -29,0 +30,1 @@\n+import hat.ThreadMesh;\n@@ -317,1 +319,2 @@\n-        cc.dispatchKernel(width * height, kc -> rgbToGreyKernel(kc, s08X3RGBImage, greyImage));\n+        ComputeRange computeRange = new ComputeRange(new ThreadMesh(width * height));\n+        cc.dispatchKernel(computeRange, kc -> rgbToGreyKernel(kc, s08X3RGBImage, greyImage));\n@@ -322,2 +325,4 @@\n-        cc.dispatchKernel(width, kc -> integralColKernel(kc, greyImage, integralImage, integralSqImage));\n-        cc.dispatchKernel(height, kc -> integralRowKernel(kc, integralImage, integralSqImage));\n+        ComputeRange range1 = new ComputeRange(new ThreadMesh(width));\n+        ComputeRange range2 = new ComputeRange(new ThreadMesh(height));\n+        cc.dispatchKernel(range1, kc -> integralColKernel(kc, greyImage, integralImage, integralSqImage));\n+        cc.dispatchKernel(range2, kc -> integralRowKernel(kc, integralImage, integralSqImage));\n@@ -325,1 +330,2 @@\n-        cc.dispatchKernel(scaleTable.multiScaleAccumulativeRange(), kc ->\n+        ComputeRange range3 = new ComputeRange(new ThreadMesh(scaleTable.multiScaleAccumulativeRange()));\n+        cc.dispatchKernel(range3, kc ->\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/ViolaJonesCoreCompute.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import hat.ComputeRange;\n+import hat.ThreadMesh;\n@@ -332,1 +334,1 @@\n-                    .forEachInRange(accelerator.range(scaleTable.multiScaleAccumulativeRange()), r -> {\n+                    .forEachInRange(accelerator.range(new ComputeRange(new ThreadMesh(scaleTable.multiScaleAccumulativeRange()))), r -> {\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/attic\/ViolaJones.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ComputeRange;\n@@ -29,0 +30,1 @@\n+import hat.ThreadMesh;\n@@ -68,0 +70,1 @@\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(s32Array2D.width()*s32Array2D.height()));\n@@ -69,1 +72,1 @@\n-                    s32Array2D.width()*s32Array2D.height(), \/\/0..S32Array2D.size()\n+                    computeRange, \/\/0..S32Array2D.size()\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/TestJavaHATCodeBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.ComputeRange;\n@@ -29,0 +30,1 @@\n+import hat.ThreadMesh;\n@@ -67,1 +69,1 @@\n-\n+            ComputeRange computeRange = new ComputeRange(new ThreadMesh(s32Array2D.width() * s32Array2D.height()));\n@@ -69,1 +71,1 @@\n-                    s32Array2D.width() * s32Array2D.height(), \/\/0..S32Array2D.size()\n+                    computeRange, \/\/0..S32Array2D.size()\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/textmodel\/ui\/TestFuncOpViewer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}