{"files":[{"patch":"@@ -413,5 +413,14 @@\n-        for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n-            FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n-            FuncOpWrapper loweredFunc = calledFunc.lower();\n-            loweredFunc = transformPTXPtrs(loweredFunc, argsMap, usedMathFns);\n-            invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+        if (Boolean.getBoolean(\"moduleOp\")) {\n+            kernelCallGraph.moduleOpWrapper.functionTable().forEach((_, funcOp) -> {\n+                FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,funcOp);\n+                FuncOpWrapper loweredFunc = calledFunc.lower();\n+                loweredFunc = transformPTXPtrs(loweredFunc, argsMap, usedMathFns);\n+                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            });\n+        } else {\n+            for (KernelCallGraph.KernelReachableResolvedMethodCall k : kernelCallGraph.kernelReachableResolvedStream().toList()) {\n+                FuncOpWrapper calledFunc = new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup,k.funcOpWrapper().op());\n+                FuncOpWrapper loweredFunc = calledFunc.lower();\n+                loweredFunc = transformPTXPtrs(loweredFunc, argsMap, usedMathFns);\n+                invokedMethods.append(createFunction(new PTXHATKernelBuilder(addressSize).nl().nl(), loweredFunc, false));\n+            }\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-        kernelCallGraph.kernelReachableResolvedStream().forEach(kr -> {\n+        if (Boolean.getBoolean(\"moduleOp\")) {\n+            kernelCallGraph.moduleOpWrapper.functionTable().forEach((_, funcOp) -> {\n@@ -64,1 +65,6 @@\n-        });\n+            });\n+        } else {\n+            kernelCallGraph.kernelReachableResolvedStream().forEach(kr -> {\n+\n+            });\n+        }\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/java\/hat\/backend\/ffi\/MockBackend.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import hat.optools.FuncOpWrapper;\n@@ -102,2 +103,7 @@\n-        kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n-                .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n+        if (Boolean.getBoolean(\"moduleOp\")) {\n+            kernelCallGraph.moduleOpWrapper.functionTable()\n+                    .forEach((_, funcOp) -> builder.nl().kernelMethod(new FuncOpWrapper(kernelCallGraph.computeContext.accelerator.lookup, funcOp)).nl());\n+        } else {\n+            kernelCallGraph.kernelReachableResolvedStream().sorted((lhs, rhs) -> rhs.rank - lhs.rank)\n+                    .forEach(kernelReachableResolvedMethod -> builder.nl().kernelMethod(kernelReachableResolvedMethod).nl());\n+        }\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.ModuleOpWrapper;\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -44,0 +47,1 @@\n+    public ModuleOpWrapper moduleOpWrapper;\n@@ -49,0 +53,2 @@\n+    public abstract boolean filterCalls(CoreOp.FuncOp f, InvokeOpWrapper invokeOpWrapper, Method method, MethodRef methodRef, Class<?> javaRefTypeClass);\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/CallGraph.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import hat.optools.ModuleOpWrapper;\n@@ -42,3 +43,1 @@\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;\n@@ -49,0 +48,3 @@\n+    public final Map<MethodRef, MethodCall> bufferAccessToMethodCallMap = new LinkedHashMap<>();\n+    boolean moduleOp = Boolean.getBoolean(\"moduleOp\");\n+    ComputeContextMethodCall computeContextMethodCall;\n@@ -103,1 +105,1 @@\n-                        } else if (InvokeOpWrapper.isIfaceUsingLookup(fow.lookup,paramInfo.javaType)) {\n+                        } else if (InvokeOpWrapper.isIfaceUsingLookup(fow.lookup, paramInfo.javaType)) {\n@@ -172,1 +174,1 @@\n-                    FuncOpWrapper fow = OpWrapper.wrap(computeContext.accelerator.lookup,optionalFuncOp.get());\n+                    FuncOpWrapper fow = OpWrapper.wrap(computeContext.accelerator.lookup, optionalFuncOp.get());\n@@ -220,1 +222,29 @@\n-        updateDag(entrypoint);\n+        if (moduleOp) {\n+            closeWithModuleOp(entrypoint);\n+        } else {\n+            updateDag(entrypoint);\n+        }\n+    }\n+\n+    public void closeWithModuleOp(ComputeReachableResolvedMethodCall computeReachableResolvedMethodCall) {\n+        CoreOp.ModuleOp moduleOp = ModuleOpWrapper.createTransitiveInvokeModule(computeContext.accelerator.lookup, computeReachableResolvedMethodCall.funcOpWrapper(), this);\n+        moduleOpWrapper = new ModuleOpWrapper(computeContext.accelerator.lookup, moduleOp);\n+    }\n+\n+    @Override\n+    public boolean filterCalls(CoreOp.FuncOp f, InvokeOpWrapper invokeOpWrapper, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n+        FuncOpWrapper funcOpWrapper = new FuncOpWrapper(computeContext.accelerator.lookup, f);\n+        if (entrypoint.method.getDeclaringClass().equals(invokeOpWrapper.javaRefClass().orElseThrow()) && isKernelDispatch(method, funcOpWrapper)) {\n+            kernelCallGraphMap.computeIfAbsent(methodRef, _ ->\n+                    new KernelCallGraph(this, methodRef, method, funcOpWrapper).closeWithModuleOp()\n+            );\n+        } else if (ComputeContext.class.isAssignableFrom(javaRefTypeClass)) {\n+            computeContextMethodCall = new ComputeContextMethodCall(this, methodRef, method);\n+        } else if (Buffer.class.isAssignableFrom(javaRefTypeClass)) {\n+            bufferAccessToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                    new ComputeReachableIfaceMappedMethodCall(this, methodRef, method)\n+            );\n+        } else {\n+            return false;\n+        }\n+        return true;\n@@ -222,1 +252,2 @@\n-}\n+\n+}\n\\ No newline at end of file\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/ComputeCallGraph.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import hat.optools.InvokeOpWrapper;\n+import hat.optools.ModuleOpWrapper;\n@@ -35,1 +37,1 @@\n-import java.util.Optional;\n+import java.util.*;\n@@ -40,0 +42,1 @@\n+    public final Map<MethodRef, MethodCall> bufferAccessToMethodCallMap = new LinkedHashMap<>();\n@@ -154,0 +157,18 @@\n+\n+    KernelCallGraph closeWithModuleOp() {\n+        CoreOp.ModuleOp moduleOp = ModuleOpWrapper.createTransitiveInvokeModule(computeContext.accelerator.lookup, entrypoint.funcOpWrapper(), this);\n+        moduleOpWrapper = new ModuleOpWrapper(computeContext.accelerator.lookup, moduleOp);\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean filterCalls(CoreOp.FuncOp f, InvokeOpWrapper invokeOpWrapper, Method method, MethodRef methodRef, Class<?> javaRefTypeClass) {\n+        if (Buffer.class.isAssignableFrom(javaRefTypeClass)) {\n+            bufferAccessToMethodCallMap.computeIfAbsent(methodRef, _ ->\n+                    new KernelReachableUnresolvedIfaceMappedMethodCall(this, methodRef, method)\n+            );\n+        } else {\n+            return false;\n+        }\n+        return true;\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/callgraph\/KernelCallGraph.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.code.dialect.core.CoreOp;\n@@ -148,0 +149,21 @@\n+            braceNlIndented(_ -> {\n+                StreamCounter.of(buildContext.funcOpWrapper.wrappedRootOpStream(), (c, root) ->\n+                        nlIf(c.isNotFirst()).recurse(buildContext, root).semicolonIf(!(root instanceof StructuralOpWrapper<?>))\n+                );\n+            });\n+        });\n+        return self();\n+    }\n+\n+    public T kernelMethod(FuncOpWrapper funcOpWrapper) {\n+\n+        CodeBuilderContext buildContext = new CodeBuilderContext(funcOpWrapper);\n+        buildContext.scope(buildContext.funcOpWrapper, () -> {\n+            nl();\n+            functionDeclaration(buildContext,buildContext.funcOpWrapper.getReturnType(), buildContext.funcOpWrapper.functionName());\n+\n+            var list = buildContext.funcOpWrapper.paramTable.list();\n+            parenNlIndented(_ ->\n+                    commaSeparated(list, (info) -> type(buildContext,info.javaType).space().varName(info.varOp))\n+            );\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n-import jdk.incubator.code.CopyContext;\n+\n+import hat.callgraph.CallGraph;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.code.Value;\n@@ -35,6 +35,2 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Optional;\n+\n+import java.util.*;\n@@ -43,1 +39,1 @@\n-    ModuleOpWrapper(MethodHandles.Lookup lookup, CoreOp.ModuleOp op) {\n+    public ModuleOpWrapper(MethodHandles.Lookup lookup, CoreOp.ModuleOp op) {\n@@ -47,1 +43,2 @@\n-    record MethodRefToEntryFuncOpCall(MethodRef methodRef, CoreOp.FuncOp funcOp) {\n+    public SequencedMap<String, CoreOp.FuncOp> functionTable() {\n+        return op().functionTable();\n@@ -50,3 +47,9 @@\n-    record Closure(Deque<MethodRefToEntryFuncOpCall> work, LinkedHashSet<MethodRef> funcsVisited,\n-                   List<CoreOp.FuncOp> moduleFuncOps) {\n-    }\n+\/\/    public static ModuleOpWrapper createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+\/\/                                                               CallGraph.ResolvedMethodCall resolvedMethodCall) {\n+\/\/        Optional<CoreOp.FuncOp> codeModel = Op.ofMethod(entryPoint);\n+\/\/        if (codeModel.isPresent()) {\n+\/\/            return OpWrapper.wrap(lookup, createTransitiveInvokeModule(lookup, resolvedMethodCall.targetMethodRef, resolvedMethodCall.funcOpWrapper()));\n+\/\/        } else {\n+\/\/            return OpWrapper.wrap(lookup, CoreOp.module(List.of()));\n+\/\/        }\n+\/\/    }\n@@ -54,9 +57,0 @@\n-    public  ModuleOpWrapper createTransitiveInvokeModule(\n-                                                               Method entryPoint) {\n-        Optional<CoreOp.FuncOp> codeModel = Op.ofMethod(entryPoint);\n-        if (codeModel.isPresent()) {\n-            return OpWrapper.wrap(lookup, createTransitiveInvokeModule( MethodRef.method(entryPoint), codeModel.get()));\n-        } else {\n-            return OpWrapper.wrap(lookup, CoreOp.module(List.of()));\n-        }\n-    }\n@@ -73,35 +67,25 @@\n-    CoreOp.ModuleOp createTransitiveInvokeModule(\n-                                                        MethodRef methodRef, CoreOp.FuncOp entryFuncOp) {\n-        Closure closure = new Closure(new ArrayDeque<>(), new LinkedHashSet<>(), new ArrayList<>());\n-        closure.work.push(new MethodRefToEntryFuncOpCall(methodRef, entryFuncOp));\n-        while (!closure.work.isEmpty()) {\n-            MethodRefToEntryFuncOpCall methodRefToEntryFuncOpCall = closure.work.pop();\n-            if (closure.funcsVisited.add(methodRefToEntryFuncOpCall.methodRef)) {\n-                CoreOp.FuncOp tf = methodRefToEntryFuncOpCall.funcOp.transform(\n-                        methodRefToEntryFuncOpCall.methodRef.toString(), (blockBuilder, op) -> {\n-                            if (op instanceof JavaOp.InvokeOp invokeOp && OpWrapper.wrap(lookup, invokeOp) instanceof InvokeOpWrapper invokeOpWrapper) {\n-                                Method invokedMethod = invokeOpWrapper.method();\n-                                Optional<CoreOp.FuncOp> optionalInvokedFuncOp = Op.ofMethod(invokedMethod);\n-                                if (optionalInvokedFuncOp.isPresent() && OpWrapper.wrap(lookup, optionalInvokedFuncOp.get()) instanceof FuncOpWrapper funcOpWrapper) {\n-                                    MethodRefToEntryFuncOpCall call =\n-                                            new MethodRefToEntryFuncOpCall(invokeOpWrapper.methodRef(), funcOpWrapper.op());\n-                                    closure.work.push(call);\n-                                    CopyContext copyContext = blockBuilder.context();\n-                                    List<Value> operands = copyContext.getValues(invokeOp.operands());\n-                                    CoreOp.FuncCallOp replacementCall = CoreOp.funcCall(\n-                                            call.methodRef.toString(),\n-                                            call.funcOp.invokableType(),\n-                                            operands);\n-                                    Op.Result replacementResult = blockBuilder.op(replacementCall);\n-                                    copyContext.mapValue(invokeOp.result(), replacementResult);\n-                                    \/\/ System.out.println(\"replaced \" + call);\n-                                } else {\n-                                    \/\/ System.out.println(\"We have no code model for \" + invokeOpWrapper.methodRef());\n-                                    blockBuilder.op(invokeOp);\n-                                }\n-                            } else {\n-                                blockBuilder.op(op);\n-                            }\n-                            return blockBuilder;\n-                        });\n-                closure.moduleFuncOps.add(tf);\n+    public static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup l,\n+                                                        FuncOpWrapper entry, CallGraph<?> callGraph) {\n+        LinkedHashSet<MethodRef> funcsVisited = new LinkedHashSet<>();\n+        List<CoreOp.FuncOp> funcs = new ArrayList<>();\n+        record RefAndFunc(MethodRef r, FuncOpWrapper f) {}\n+\n+        Deque<RefAndFunc> work = new ArrayDeque<>();\n+\n+        entry.selectCalls((invokeOpWrapper) -> {\n+            MethodRef methodRef = invokeOpWrapper.methodRef();\n+            Method method = null;\n+            Class<?> javaRefTypeClass = invokeOpWrapper.javaRefClass().orElseThrow();\n+            try {\n+                method = methodRef.resolveToMethod(l, invokeOpWrapper.op().invokeKind());\n+            } catch (ReflectiveOperationException _) {}\n+            Optional<CoreOp.FuncOp> f = Op.ofMethod(method);\n+            if (f.isPresent() && !callGraph.filterCalls(f.get(), invokeOpWrapper, method, methodRef, javaRefTypeClass)) {\n+                work.push(new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get())));\n+            }\n+        });\n+\n+        while (!work.isEmpty()) {\n+            RefAndFunc rf = work.pop();\n+            if (!funcsVisited.add(rf.r)) {\n+                continue;\n@@ -109,0 +93,28 @@\n+\n+            CoreOp.FuncOp tf = rf.f.transform(rf.r.name(), (blockBuilder, op) -> {\n+                if (op instanceof JavaOp.InvokeOp iop) {\n+                    InvokeOpWrapper iopWrapper = OpWrapper.wrap(entry.lookup, iop);\n+                    MethodRef methodRef = iopWrapper.methodRef();\n+                    Method invokeOpCalledMethod = null;\n+                    try {\n+                        invokeOpCalledMethod = methodRef.resolveToMethod(l, iop.invokeKind());\n+                    } catch (ReflectiveOperationException _) {}\n+                    if (invokeOpCalledMethod instanceof Method m) {\n+                        Optional<CoreOp.FuncOp> f = Op.ofMethod(m);\n+                        if (f.isPresent()) {\n+                            RefAndFunc call = new RefAndFunc(methodRef, new FuncOpWrapper(l, f.get()));\n+                            work.push(call);\n+\n+                            Op.Result result = blockBuilder.op(CoreOp.funcCall(\n+                                    call.r.name(),\n+                                    call.f.op().invokableType(),\n+                                    blockBuilder.context().getValues(iop.operands())));\n+                            blockBuilder.context().mapValue(op.result(), result);\n+                            return blockBuilder;\n+                        }\n+                    }\n+                }\n+                blockBuilder.op(op);\n+                return blockBuilder;\n+            });\n+            funcs.addFirst(tf);\n@@ -111,1 +123,1 @@\n-        return CoreOp.module(closure.moduleFuncOps);\n+        return CoreOp.module(funcs);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/ModuleOpWrapper.java","additions":70,"deletions":58,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -1287,0 +1287,1 @@\n+        public boolean moduleOp;\n@@ -1345,0 +1346,4 @@\n+\n+        public void moduleOp() {\n+            this.moduleOp = true;\n+        }\n@@ -1376,0 +1381,3 @@\n+        if (javaBuilder.moduleOp) {\n+            result.opts.add(\"-DmoduleOp=true\");\n+        }\n","filename":"hat\/hat\/Script.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+     boolean moduleOp = false;\n@@ -74,0 +75,1 @@\n+                   case \"moduleOp\" -> moduleOp = true;\n@@ -173,0 +175,1 @@\n+          if (config.moduleOp) System.out.println(\"Currently using ModuleOp config for CallGraphs\");\n@@ -180,0 +183,1 @@\n+              .when(config.moduleOp, Script.JavaBuilder::moduleOp)\n","filename":"hat\/hat\/run.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    <build> \n+    <build>\n","filename":"hat\/wraps\/cuda\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    <build> \n+    <build>\n","filename":"hat\/wraps\/opencl\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-<build> \n+    <build>\n@@ -56,17 +56,17 @@\n-<plugin>\n-      <groupId>org.apache.maven.plugins<\/groupId>\n-      <artifactId>maven-compiler-plugin<\/artifactId>\n-      <configuration>\n-        <excludes>\n-          <!--\n-              Annoyingly there seems to be two ways to handle callbacks in gl so we have two wrappers\n-                 gl on mac needs  us to exclude\n-                    wrap\/glwrap\/GLCallbackEventHandler.java \n-                 gl on ubuntu\/jetson needs  us to exclude\n-                   wrap\/glwrap\/GLCallbackEventHandler.java \n-          -->\n-          <!-- uncomment for mac --> <exclude>wrap\/opengl\/GLCallbackEventHandler.java<\/exclude>\n-          <!-- uncomment for ubuntu --><!-- <exclude>wrap\/opengl\/GLFuncEventHandler.java<\/exclude> -->\n-        <\/excludes>\n-      <\/configuration>\n-    <\/plugin>\n+         <plugin>\n+            <groupId>org.apache.maven.plugins<\/groupId>\n+            <artifactId>maven-compiler-plugin<\/artifactId>\n+            <configuration>\n+              <excludes>\n+                <!--\n+                    Annoyingly there seems to be two ways to handle callbacks in gl so we have two wrappers\n+                       gl on mac needs  us to exclude\n+                          wrap\/glwrap\/GLCallbackEventHandler.java\n+                       gl on ubuntu\/jetson needs  us to exclude\n+                         wrap\/glwrap\/GLCallbackEventHandler.java\n+                -->\n+               <!-- uncomment for mac --> <exclude>wrap\/opengl\/GLCallbackEventHandler.java<\/exclude>\n+               <!-- uncomment for ubuntu --><!-- <exclude>wrap\/opengl\/GLFuncEventHandler.java<\/exclude> -->\n+              <\/excludes>\n+            <\/configuration>\n+         <\/plugin>\n@@ -74,19 +74,19 @@\n-        <plugin>\n-                <groupId>org.apache.maven.plugins<\/groupId>\n-                <artifactId>maven-antrun-plugin<\/artifactId>\n-                <version>1.8<\/version>\n-                <executions>\n-                    <execution>\n-                        <id>1<\/id>\n-                        <phase>install<\/phase>\n-                        <goals>\n-                            <goal>run<\/goal>\n-                        <\/goals>\n-                        <configuration>\n-                            <target>\n-                                <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n-                            <\/target>\n-                        <\/configuration>\n-                    <\/execution>\n-                <\/executions>\n-            <\/plugin>\n+         <plugin>\n+            <groupId>org.apache.maven.plugins<\/groupId>\n+            <artifactId>maven-antrun-plugin<\/artifactId>\n+            <version>1.8<\/version>\n+            <executions>\n+               <execution>\n+                  <id>1<\/id>\n+                  <phase>install<\/phase>\n+                  <goals>\n+                     <goal>run<\/goal>\n+                  <\/goals>\n+                  <configuration>\n+                     <target>\n+                        <copy file=\"target\/${project.artifactId}-${project.version}.jar\" toDir=\"${hat.build}\"\/>\n+                     <\/target>\n+                  <\/configuration>\n+               <\/execution>\n+            <\/executions>\n+         <\/plugin>\n@@ -95,1 +95,0 @@\n-\n","filename":"hat\/wraps\/opengl\/pom.xml","additions":37,"deletions":38,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-        <!--\n-  <profiles>\n+      <!--\n+      <profiles>\n@@ -62,4 +62,2 @@\n-    <\/profiles>\n-         -->\n-\n-   \n+      <\/profiles>\n+      -->\n","filename":"hat\/wraps\/pom.xml","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    <build> \n+    <build>\n@@ -59,1 +59,0 @@\n-\n","filename":"hat\/wraps\/shared\/pom.xml","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}