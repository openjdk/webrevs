{"files":[{"patch":"@@ -52,2 +52,1 @@\n-    @Override\n-    public CudaHATKernelBuilder globalId(int id) {\n+    private String buildThreadDimId(int id) {\n@@ -64,0 +63,6 @@\n+        return threadDimId;\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder globalId(int id) {\n+        String threadDimId = buildThreadDimId(id);\n@@ -71,0 +76,6 @@\n+    @Override\n+    public CudaHATKernelBuilder localId(int id) {\n+        String threadDimId = buildThreadDimId(id);\n+        return identifier(\"threadIdx\").dot().identifier(threadDimId);\n+    }\n+\n@@ -73,10 +84,1 @@\n-        String threadDimId;\n-        if (id == 0) {\n-            threadDimId = \"x\";\n-        } else if (id == 1) {\n-            threadDimId = \"y\";\n-        } else if (id == 2) {\n-            threadDimId = \"z\";\n-        } else {\n-            throw new RuntimeException(\"Thread Dimension not supported\");\n-        }\n+        String threadDimId = buildThreadDimId(id);\n@@ -88,0 +90,12 @@\n+    @Override\n+    public CudaHATKernelBuilder localSize(int id) {\n+        String threadDimId = buildThreadDimId(id);\n+        return identifier(\"blockDim\").dot().identifier(threadDimId);\n+    }\n+\n+    @Override\n+    public CudaHATKernelBuilder blockSize(int id) {\n+        String threadDimId = buildThreadDimId(id);\n+        return identifier(\"blockIdx\").dot().identifier(threadDimId);\n+    }\n+\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaHATKernelBuilder.java","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -141,3 +141,3 @@\n-    const int dimensions = kernelContext->globalMesh.dimensions;\n-    if (kernelContext -> localMesh.maxX > 0) {\n-        threadsPerBlockX = kernelContext -> localMesh.maxX;\n+    const int dimensions = kernelContext->dimensions;\n+    if (kernelContext->lsx > 0) {\n+        threadsPerBlockX = kernelContext -> lsx;\n@@ -147,2 +147,2 @@\n-    if (kernelContext-> localMesh.maxY > 0) {\n-        threadsPerBlockY = kernelContext-> localMesh.maxY;\n+    if (kernelContext-> lsy > 0) {\n+        threadsPerBlockY = kernelContext->lsy;\n@@ -152,2 +152,2 @@\n-    if (kernelContext-> localMesh.maxZ > 0) {\n-        threadsPerBlockZ = kernelContext-> localMesh.maxZ;\n+    if (kernelContext-> lsz > 0) {\n+        threadsPerBlockZ = kernelContext-> lsz;\n@@ -158,1 +158,1 @@\n-    int blocksPerGridX = (kernelContext->globalMesh.maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n+    int blocksPerGridX = (kernelContext->maxX + threadsPerBlockX - 1) \/ threadsPerBlockX;\n@@ -163,1 +163,1 @@\n-        blocksPerGridY = (kernelContext->globalMesh.maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n+        blocksPerGridY = (kernelContext->maxY + threadsPerBlockY - 1) \/ threadsPerBlockY;\n@@ -166,1 +166,1 @@\n-        blocksPerGridZ = (kernelContext->globalMesh.maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n+        blocksPerGridZ = (kernelContext->maxZ + threadsPerBlockZ - 1) \/ threadsPerBlockZ;\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/native\/cpp\/cuda_backend_queue.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->globalMesh.maxX << std::endl;\n+                std::cout << \"enqueued kernel dispatch \\\"\"<< kernel->name <<\"\\\" globalSize=\" << kernelContext->maxX << std::endl;\n","filename":"hat\/backends\/ffi\/mock\/src\/main\/native\/cpp\/mock_backend.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+    @Override\n+    public OpenCLHATKernelBuilder localId(int id) {\n+        return identifier(\"get_local_id\").oparen().literal(id).cparen();\n+    }\n+\n@@ -67,0 +72,10 @@\n+    @Override\n+    public OpenCLHATKernelBuilder localSize(int id) {\n+        return identifier(\"get_local_size\").oparen().literal(id).cparen();\n+    }\n+\n+    @Override\n+    public OpenCLHATKernelBuilder blockSize(int id) {\n+        return identifier(\"get_group_id\").oparen().literal(id).cparen();\n+    }\n+\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLHATKernelBuilder.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    size_t numDimensions = kernelContext->globalMesh.dimensions;\n+    size_t numDimensions = kernelContext->dimensions;\n@@ -246,3 +246,3 @@\n-        static_cast<size_t>(kernelContext->globalMesh.maxX),\n-        static_cast<size_t>(kernelContext->globalMesh.maxY),\n-        static_cast<size_t>(kernelContext->globalMesh.maxZ)\n+        static_cast<size_t>(kernelContext->maxX),\n+        static_cast<size_t>(kernelContext->maxY),\n+        static_cast<size_t>(kernelContext->maxZ)\n@@ -252,3 +252,3 @@\n-        static_cast<size_t>(kernelContext->localMesh.maxX),\n-        static_cast<size_t>(kernelContext->localMesh.maxY),\n-        static_cast<size_t>(kernelContext->localMesh.maxZ),\n+        static_cast<size_t>(kernelContext->lsx),\n+        static_cast<size_t>(kernelContext->lsy),\n+        static_cast<size_t>(kernelContext->lsz),\n@@ -261,1 +261,1 @@\n-        if (kernelContext->localMesh.maxX > 0) {\n+        if (kernelContext->lsx > 0) {\n@@ -274,1 +274,1 @@\n-        kernelContext->localMesh.maxX > 0 ? local_work_size : nullptr,\n+        kernelContext->lsx > 0 ? local_work_size : nullptr,\n@@ -284,1 +284,1 @@\n-        std::cout << \"enqueued kernel dispatch \\\"\" << kernel->name << \"\\\" globalSize=\" << kernelContext->globalMesh.maxX <<\n+        std::cout << \"enqueued kernel dispatch \\\"\" << kernel->name << \"\\\" globalSize=\" << kernelContext->maxX <<\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/native\/cpp\/opencl_backend_queue.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import hat.KernelContext;\n@@ -36,1 +35,1 @@\n-import hat.buffer.KernelBufferContext;\n+import hat.buffer.KernelContext;\n@@ -61,1 +60,1 @@\n-        public final KernelBufferContext kernelBufferContext;\n+        public final KernelContext kernelContext;\n@@ -67,2 +66,2 @@\n-            this.kernelBufferContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n-            ndRangeAndArgs[0] = this.kernelBufferContext;\n+            this.kernelContext = KernelContext.createDefault(kernelCallGraph.computeContext.accelerator);\n+            ndRangeAndArgs[0] = this.kernelContext;\n@@ -72,5 +71,5 @@\n-        private void setGlobalMesh(KernelContext kc) {\n-            kernelBufferContext.globalMesh().maxX(kc.maxX);\n-            kernelBufferContext.globalMesh().maxY(kc.maxY);\n-            kernelBufferContext.globalMesh().maxZ(kc.maxZ);\n-            kernelBufferContext.globalMesh().dimensions(kc.getDimensions());\n+        private void setGlobalMesh(hat.KernelContext kc) {\n+            kernelContext.maxX(kc.maxX);\n+            kernelContext.maxY(kc.maxY);\n+            kernelContext.maxZ(kc.maxZ);\n+            kernelContext.dimensions(kc.getDimensions());\n@@ -80,4 +79,4 @@\n-            kernelBufferContext.globalMesh().maxX(threadMesh.getX());\n-            kernelBufferContext.globalMesh().maxY(threadMesh.getY());\n-            kernelBufferContext.globalMesh().maxZ(threadMesh.getZ());\n-            kernelBufferContext.globalMesh().dimensions(threadMesh.getDims());\n+            kernelContext.maxX(threadMesh.getX());\n+            kernelContext.maxY(threadMesh.getY());\n+            kernelContext.maxZ(threadMesh.getZ());\n+            kernelContext.dimensions(threadMesh.getDims());\n@@ -87,4 +86,4 @@\n-            kernelBufferContext.localMesh().maxX(threadMesh.getX());\n-            kernelBufferContext.localMesh().maxY(threadMesh.getY());\n-            kernelBufferContext.localMesh().maxZ(threadMesh.getZ());\n-            kernelBufferContext.localMesh().dimensions(threadMesh.getDims());\n+            kernelContext.lsx(threadMesh.getX());\n+            kernelContext.lsy(threadMesh.getY());\n+            kernelContext.lsz(threadMesh.getZ());\n+            \/\/kernelContext.dimensions(threadMesh.getDims());\n@@ -94,4 +93,3 @@\n-            kernelBufferContext.localMesh().maxX(0);\n-            kernelBufferContext.localMesh().maxY(0);\n-            kernelBufferContext.localMesh().maxZ(0);\n-            kernelBufferContext.localMesh().dimensions(0);\n+            kernelContext.lsx(0);\n+            kernelContext.lsy(0);\n+            kernelContext.lsz(0);\n@@ -100,2 +98,2 @@\n-        public void dispatch(NDRange ndRange, Object[] args) {\n-          \/\/  long ns = System.nanoTime();\n+        private void setupComputeRange(NDRange ndRange) {\n+\n@@ -123,0 +121,1 @@\n+        }\n@@ -124,1 +123,3 @@\n-            args[0] = this.kernelBufferContext;\n+        public void dispatch(NDRange ndRange, Object[] args) {\n+            setupComputeRange(ndRange);\n+            args[0] = this.kernelContext;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-        std::cout << \"kernelContext = \" << kernelContext->globalMesh.maxX << std::endl;\n+        std::cout << \"kernelContext = \" << kernelContext->maxX << std::endl;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/cpp\/shared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,1 +362,12 @@\n-class ThreadMesh {\n+\/\/ class ThreadMesh {\n+\/\/ public:\n+\/\/     int x;\n+\/\/     int maxX;\n+\/\/     int y;\n+\/\/     int maxY;\n+\/\/     int z;\n+\/\/     int maxZ;\n+\/\/     int dimensions;\n+\/\/ };\n+\n+class KernelContext {\n@@ -371,6 +382,14 @@\n-};\n-\n-class KernelContext {\n-public:\n-    ThreadMesh globalMesh;\n-    ThreadMesh localMesh;\n+    int gix;\n+    int giy;\n+    int giz;\n+    int lix;\n+    int liy;\n+    int liz;\n+    int lsx;\n+    int lsy;\n+    int lsz;\n+    int bix;\n+    int biy;\n+    int biz;\n+    \/\/ ThreadMesh globalMesh;\n+    \/\/ ThreadMesh localMesh;\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/native\/include\/shared.h","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+    @Override\n+    public OpenCLHatKernelBuilder localId(int id) {\n+        return identifier(\"get_local_id\").oparen().literal(id).cparen();\n+    }\n+\n@@ -65,0 +70,10 @@\n+    @Override\n+    public OpenCLHatKernelBuilder localSize(int id) {\n+        return identifier(\"get_local_size\").oparen().literal(id).cparen();\n+    }\n+\n+    @Override\n+    public OpenCLHatKernelBuilder blockSize(int id) {\n+        return identifier(\"get_group_id\").oparen().literal(id).cparen();\n+    }\n+\n","filename":"hat\/backends\/jextracted\/opencl\/src\/main\/java\/hat\/backend\/jextracted\/OpenCLHatKernelBuilder.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import hat.buffer.KernelBufferContext;\n+import hat.buffer.KernelContext;\n@@ -54,1 +54,1 @@\n-        public final KernelBufferContext kernelContext;\n+        public final KernelContext kernelContext;\n@@ -61,1 +61,1 @@\n-            this.kernelContext = KernelBufferContext.createDefault(kernelCallGraph.computeContext.accelerator);\n+            this.kernelContext = KernelContext.createDefault(kernelCallGraph.computeContext.accelerator);\n@@ -67,1 +67,1 @@\n-            kernelContext.globalMesh().maxX(ndRange.kid.maxX);\n+            kernelContext.maxX(ndRange.kid.maxX);\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/C99JExtractedBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"<1D GlobalMesh: \" + getX() + \">\";\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh1D.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"<2D GlobalMesh: \" + getX() + \",\" + getY() + \">\";\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/GlobalMesh2D.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,3 +45,3 @@\n-    public int x;\n-    public int y;\n-    public int z;\n+    public int x;    \/\/ proposal to rename to gix\n+    public int y;    \/\/ proposal to rename to giy\n+    public int z;    \/\/ proposal to rename to giz\n@@ -53,0 +53,20 @@\n+    \/\/ Global accesses\n+    final public int gix;\n+    final public int giy;\n+    final public int giz;\n+\n+    \/\/ Local accesses within a group\n+    public int lix;\n+    public int liy;\n+    public int liz;\n+\n+    \/\/ Specify sizes for the local group sizes\n+    public int lsx;\n+    public int lsy;\n+    public int lsz;\n+\n+    \/\/ Specify number of blocks per dimension\n+    public int bsx;\n+    public int bsy;\n+    public int bsz;\n+\n@@ -63,0 +83,3 @@\n+        this.gix = computeRange.getGlobalMesh().getX();\n+        this.giy = computeRange.getGlobalMesh().getY();\n+        this.giz = computeRange.getGlobalMesh().getZ();\n@@ -76,0 +99,3 @@\n+        this.gix = maxX;\n+        this.giy = 0;\n+        this.giz = 0;\n@@ -90,0 +116,5 @@\n+\n+        this.gix = maxX;\n+        this.giy = maxY;\n+        this.giz = 0;\n+\n@@ -105,0 +136,5 @@\n+\n+        this.gix = maxX;\n+        this.giy = maxY;\n+        this.giz = maxZ;\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/KernelContext.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"<1D LocalMesh: \" + getX() + \">\";\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh1D.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"<2D LocalMesh: \" + getX() + \",\" + getY() + \">\";\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/LocalMesh2D.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package hat.buffer;\n-\n-import hat.Accelerator;\n-import hat.ifacemapper.Schema;\n-\n-public interface KernelBufferContext extends Buffer {\n-\n-    interface MeshBuffer extends Struct {\n-        int x();\n-        void x(int x);\n-\n-        int y();\n-        void y(int y);\n-\n-        int z();\n-        void z(int z);\n-\n-        int maxX();\n-        void maxX(int maxX);\n-\n-        int maxY();\n-        void maxY(int maxY);\n-\n-        int maxZ();\n-        void maxZ(int maxZ);\n-\n-        int dimensions();\n-        void dimensions(int numDimensions);\n-    }\n-\n-    MeshBuffer globalMesh();\n-\n-    MeshBuffer localMesh();\n-\n-    Schema<KernelBufferContext> schemaKernelBufferContext = Schema.of(KernelBufferContext.class,\n-            kernelBufferContext -> kernelBufferContext\n-                    .field(\"globalMesh\", f -> f.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"))\n-                    .field(\"localMesh\", f -> f.fields(\"x\",\"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\"))\n-            );\n-\n-    private static void setDefaultMesh(MeshBuffer meshBuffer) {\n-        meshBuffer.x(0);\n-        meshBuffer.maxX(0);\n-        meshBuffer.y(0);\n-        meshBuffer.maxY(0);\n-        meshBuffer.z(0);\n-        meshBuffer.maxZ(0);\n-        meshBuffer.dimensions(3);\n-    }\n-\n-    static KernelBufferContext createDefault(Accelerator accelerator) {\n-        KernelBufferContext kernelBufferContext =  schemaKernelBufferContext.allocate(accelerator);\n-        setDefaultMesh(kernelBufferContext.globalMesh());\n-        setDefaultMesh(kernelBufferContext.localMesh());\n-        return kernelBufferContext;\n-    }\n-}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelBufferContext.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.buffer;\n+\n+import hat.Accelerator;\n+import hat.ifacemapper.Schema;\n+\n+public interface KernelContext extends Buffer {\n+\n+    \/\/ ----------------------------------------------------------------------|\n+    \/\/| OpenCL            | CUDA                                  | HAT      |\n+    \/\/| ----------------- | ------------------------------------- |--------- |\n+    \/\/| get_global_id(0)  | blockIdx.x *blockDim.x + threadIdx.x  | gix      |\n+    \/\/| get_global_size(0)| gridDim.x * blockDim.x                | gsx      |\n+    \/\/| get_local_id(0)   | threadIdx.x                           | lix      |\n+    \/\/| get_local_size(0) | blockDim.x                            | lsx      |\n+    \/\/| get_group_id(0)   | blockIdx.x                            | bix      |\n+    \/\/| get_num_groups(0) | gridDim.x                             | bsx      |\n+    \/\/ ----------------------------------------------------------------------|\n+\n+    int x();\n+    void x(int x);\n+\n+    int y();\n+    void y(int y);\n+\n+    int z();\n+    void z(int z);\n+\n+    int maxX();\n+    void maxX(int maxX);\n+\n+    int maxY();\n+    void maxY(int maxY);\n+\n+    int maxZ();\n+    void maxZ(int maxZ);\n+\n+    int dimensions();\n+    void dimensions(int numDimensions);\n+\n+    \/\/ Global: new names\n+    int gix();\n+    void gix(int gix);\n+    int giy();\n+    void giy(int giy);\n+    int giz();\n+    void giz(int giz);\n+\n+    \/\/ Local accesses\n+    int lix();\n+    void lix(int lix);\n+    int liy();\n+    void liy(int liy);\n+    int liz();\n+    void liz(int liz);\n+\n+    \/\/ Block size\n+    int lsx();\n+    void lsx(int lsx);\n+    int lsy();\n+    void lsy(int lsy);\n+    int lsz();\n+    void lsz(int lsz);\n+\n+    \/\/ Block ID\n+    int bix();\n+    void bix(int bix);\n+    int biy();\n+    void biy(int biy);\n+    int biz();\n+    void biz(int biz);\n+\n+    Schema<KernelContext> schema = Schema.of(KernelContext.class,\n+            kernelContext -> kernelContext\n+                    .fields(\n+                            \"x\", \"maxX\", \"y\", \"maxY\", \"z\", \"maxZ\", \"dimensions\",  \/\/ Initial version\n+                            \"gix\", \"giy\", \"giz\",  \/\/ global accesses\n+                            \"lix\", \"liy\", \"liz\",  \/\/ local (thread-ids)\n+                            \"lsx\", \"lsy\", \"lsz\",  \/\/ block size\n+                            \"bix\", \"biy\", \"biz\"  \/\/ block id\n+                    ));\n+\n+    static KernelContext  createDefault(Accelerator accelerator) {\n+        KernelContext kernelContext =  schema.allocate(accelerator);\n+        kernelContext.x(0);\n+        kernelContext.maxX(0);\n+        kernelContext.y(0);\n+        kernelContext.maxY(0);\n+        kernelContext.z(0);\n+        kernelContext.maxZ(0);\n+        kernelContext.dimensions(3);\n+\n+        kernelContext.gix(0);\n+        kernelContext.giy(0);\n+        kernelContext.giz(0);\n+        kernelContext.lix(0);\n+        kernelContext.liy(0);\n+        kernelContext.liz(0);\n+        kernelContext.lsx(0);\n+        kernelContext.lsy(0);\n+        kernelContext.lsz(0);\n+        kernelContext.bix(0);\n+        kernelContext.biy(0);\n+        kernelContext.biz(0);\n+\n+        return kernelContext;\n+    }\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/KernelContext.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -41,1 +40,0 @@\n-import javax.annotation.processing.SupportedSourceVersion;\n@@ -65,6 +63,35 @@\n-                .lineComment(\"KernelContext_s created from iface buffer\")\n-                \/\/ Previously we created KernelContext explicitly here.  That was required before KernelContext was an iface buffer\n-                \/\/ It is reasonable to use hat.codebuilders.HATCodeBuilderWithContext.typedef()\n-                \/\/ But note that we pass null as first arg which is normally expected to be a bound schema\n-                \/\/ Clearly this will fail if we ever make KernelContext a variant array.  But that seems unlikely.\n-                .typedef(null,hat.buffer.KernelContext.schema.rootIfaceType);\n+\n+                \/\/ Another generic way of declaring the kernelContext is as follows:\n+                \/\/ \/\/ It is reasonable to use hat.codebuilders.HATCodeBuilderWithContext.typedef()\n+                \/\/ \/\/ But note that we pass null as first arg which is normally expected to be a bound schema\n+                \/\/ \/\/ Clearly this will fail if we ever make KernelContext a variant array.  But that seems unlikely.\n+                \/\/ .typedef(null, hat.buffer.KernelContext.schema.rootIfaceType);\n+\n+                .typedefStructOrUnion(true, \"KernelContext\", _ -> {\n+\n+                    intDeclaration(\"x\").semicolonNl();\n+                    intDeclaration(\"maxX\").semicolonNl();\n+                    intDeclaration(\"y\").semicolonNl();\n+                    intDeclaration(\"maxY\").semicolon().nl();\n+                    intDeclaration(\"z\").semicolonNl();\n+                    intDeclaration(\"maxZ\").semicolon().nl();\n+                    intDeclaration(\"dimensions\").semicolonNl();\n+\n+                    \/\/ Because of order of serialization, we need to put\n+                    \/\/ these new members at the end.\n+                    intDeclaration(\"gix\").semicolonNl();\n+                    intDeclaration(\"giy\").semicolonNl();\n+                    intDeclaration(\"giz\").semicolonNl();\n+\n+                    intDeclaration(\"lix\").semicolonNl();\n+                    intDeclaration(\"liy\").semicolonNl();\n+                    intDeclaration(\"liz\").semicolonNl();\n+\n+                    intDeclaration(\"lsx\").semicolonNl();\n+                    intDeclaration(\"lsy\").semicolonNl();\n+                    intDeclaration(\"lsz\").semicolonNl();\n+\n+                    intDeclaration(\"bsx\").semicolonNl();\n+                    intDeclaration(\"bsy\").semicolonNl();\n+                    intDeclaration(\"bsz\").semicolonNl();\n+                });\n@@ -89,0 +116,7 @@\n+\n+        \/\/\n+        identifier(\"kc\").rarrow().identifier(\"gix\").equals().globalId(0).semicolon().nl();\n+        identifier(\"kc\").rarrow().identifier(\"lix\").equals().localId(0).semicolon().nl();\n+        identifier(\"kc\").rarrow().identifier(\"lsx\").equals().localSize(0).semicolon().nl();\n+        identifier(\"kc\").rarrow().identifier(\"bsx\").equals().blockSize(0).semicolon().nl();\n+\n@@ -92,0 +126,5 @@\n+\n+            identifier(\"kc\").rarrow().identifier(\"giy\").equals().globalId(1).semicolon().nl();\n+            identifier(\"kc\").rarrow().identifier(\"liy\").equals().localId(1).semicolon().nl();\n+            identifier(\"kc\").rarrow().identifier(\"lsy\").equals().localSize(1).semicolon().nl();\n+            identifier(\"kc\").rarrow().identifier(\"bsy\").equals().blockSize(1).semicolon().nl();\n@@ -96,0 +135,5 @@\n+\n+            identifier(\"kc\").rarrow().identifier(\"giz\").equals().globalId(2).semicolon().nl();\n+            identifier(\"kc\").rarrow().identifier(\"liz\").equals().localId(2).semicolon().nl();\n+            identifier(\"kc\").rarrow().identifier(\"lsz\").equals().localSize(2).semicolon().nl();\n+            identifier(\"kc\").rarrow().identifier(\"bsz\").equals().blockSize(2).semicolon().nl();\n@@ -217,0 +261,2 @@\n+    public abstract T localId(int id);\n+\n@@ -219,0 +265,4 @@\n+    public abstract T localSize(int id);\n+\n+    public abstract T blockSize(int id);\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATKernelBuilder.java","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import hat.buffer.KernelBufferContext;\n+import hat.buffer.KernelContext;\n@@ -33,0 +33,1 @@\n+\n@@ -63,1 +64,1 @@\n-                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelBufferContext.class))\n+                && (isAssignable(javaType, hat.KernelContext.class) || isAssignable(javaType, KernelContext.class))\n@@ -68,1 +69,1 @@\n-        return isAssignable(javaRefType(), KernelBufferContext.class);\n+        return isAssignable(javaRefType(), KernelContext.class);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/InvokeOpWrapper.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.ComputeContext;\n+import hat.ComputeRange;\n+import hat.GlobalMesh1D;\n+import hat.KernelContext;\n+import hat.LocalMesh1D;\n+import hat.backend.Backend;\n+import hat.buffer.S32Array;\n+import hat.ifacemapper.MappableIface.RO;\n+import hat.ifacemapper.MappableIface.RW;\n+import jdk.incubator.code.CodeReflection;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * How to test?\n+ * <code>\n+ *     HAT=SHOW_CODE java -cp job.jar hat.java exp ffi-opencl LocalIds\n+ * <\/code>\n+ *\/\n+public class LocalIds {\n+\n+    private static boolean PRINT_RESULTS = false;\n+\n+    @CodeReflection\n+    private static void assign(@RO KernelContext context, @RW S32Array arrayA, @RW S32Array arrayB, @RW S32Array arrayC) {\n+        int gx = context.gix;\n+        int lx = context.lix;\n+        int lsx = context.lsx;\n+        int bsx = context.bsx;\n+        arrayA.array(gx, lx);\n+        arrayB.array(gx, lsx);\n+        arrayC.array(gx, bsx);\n+    }\n+\n+    private static final int BLOCK_SIZE = 16;\n+\n+    @CodeReflection\n+    private static void mySimpleCompute(@RO ComputeContext cc,  @RW S32Array arrayA, @RW S32Array arrayB, @RW S32Array arrayC) {\n+        \/\/ 2 groups of 16 threads each\n+        ComputeRange computeRange = new ComputeRange(new GlobalMesh1D(32), new LocalMesh1D(BLOCK_SIZE));\n+        cc.dispatchKernel(computeRange, kc -> assign(kc, arrayA, arrayB, arrayC));\n+    }\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Experiment: local IDs and local groups\");\n+\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n+        final int size = 32;\n+        S32Array arrayA = S32Array.create(accelerator, size);\n+        S32Array arrayB = S32Array.create(accelerator, size);\n+        S32Array arrayC = S32Array.create(accelerator, size);\n+\n+        \/\/ Set initial value to 0\n+        arrayA.fill(i -> 0);\n+        arrayB.fill(i -> 0);\n+        arrayC.fill(i -> 0);\n+\n+        \/\/ Compute on the accelerator\n+        accelerator.compute( cc -> LocalIds.mySimpleCompute(cc, arrayA, arrayB, arrayC));\n+\n+        int[] expectedIds = new int[size];\n+        int j = 0;\n+        for (int i = 0; i < size; i++) {\n+            expectedIds[i] = j++;\n+            if (j == BLOCK_SIZE) {\n+                j = 0;\n+            }\n+        }\n+\n+        System.out.println(\"Execution finished\");\n+\n+        if (PRINT_RESULTS) {\n+            System.out.println(\"Result Locals: \");\n+            for (int i = 0; i < arrayA.length(); i++) {\n+                System.out.println(arrayA.array(i));\n+            }\n+            System.out.println(\"Result Blocks: \");\n+            for (int i = 0; i < arrayB.length(); i++) {\n+                System.out.println(arrayB.array(i));\n+            }\n+            System.out.println(\"Result Block ID: \");\n+            for (int i = 0; i < arrayC.length(); i++) {\n+                System.out.println(arrayC.array(i));\n+            }\n+        }\n+\n+        boolean correct = true;\n+        for (int i = 0; i < arrayA.length(); i++) {\n+            if (expectedIds[i] != arrayA.array(i)) {\n+                System.out.println(\"Mismatch local ids\");\n+                correct = false;\n+            }\n+        }\n+        if (correct) {\n+            System.out.println(\"Local IDs are correct\");\n+        }\n+\n+\n+        correct = true;\n+        for (int i = 0; i < arrayB.length(); i++) {\n+            if (BLOCK_SIZE != arrayB.array(i)) {\n+                System.out.println(\"Mismatch group Sizes\");\n+                correct = false;\n+            }\n+        }\n+        if (correct) {\n+            System.out.println(\"Group Size are correct\");\n+        }\n+\n+        IntStream.range(0, size).forEach(i -> {\n+            int v = i < BLOCK_SIZE ? 0 : 1;\n+            expectedIds[i] = v;\n+        });\n+        for (int i = 0; i < arrayC.length(); i++) {\n+            if (expectedIds[i] != arrayC.array(i)) {\n+                System.out.println(\"Mismatch group IDs\");\n+                correct = false;\n+            }\n+        }\n+        if (correct) {\n+            System.out.println(\"Group IDs are correct\");\n+        }\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LocalIds.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}