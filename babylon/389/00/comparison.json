{"files":[{"patch":"@@ -103,2 +103,2 @@\n-CudaBackend::CudaBackend(int mode)\n-        : Backend(mode), initStatus(cuInit(0)), cudaConfig(mode), cudaQueue(this), device(),context()  {\n+CudaBackend::CudaBackend(int configBits)\n+        : Backend(new Config(configBits), new CudaQueue(this)), initStatus(cuInit(0)), device(),context()  {\n@@ -122,1 +122,1 @@\n-        cudaQueue.init();\n+        dynamic_cast<CudaQueue *>(queue)->init();\n@@ -246,1 +246,1 @@\n-    if (cudaConfig.traceCalls) {\n+    if (config->traceCalls) {\n@@ -250,2 +250,2 @@\n-    if (cudaConfig.ptx){\n-        if (cudaConfig.trace) {\n+    if (config->ptx){\n+        if (config->trace) {\n@@ -257,1 +257,1 @@\n-        if (cudaConfig.traceCalls) {\n+        if (config->traceCalls) {\n@@ -260,1 +260,1 @@\n-        if (cudaConfig.showCode){\n+        if (config->showCode){\n@@ -265,1 +265,1 @@\n-    if (cudaConfig.showCode){\n+    if (config->showCode){\n@@ -317,4 +317,0 @@\n-CudaBackend::CudaConfig::CudaConfig(int mode)\n-   : Backend::Config(mode){\n-\n-}\n@@ -322,0 +318,1 @@\n+    queue->computeEnd();\n@@ -325,1 +322,1 @@\n-\n+    queue->computeStart();\n@@ -327,2 +324,26 @@\n-bool CudaBackend::getBufferFromDeviceIfDirty(void *memorySegment, long size){\n-return true;\n+bool CudaBackend::getBufferFromDeviceIfDirty(void *memorySegment, long memorySegmentLength){\n+    if (config->traceCalls){\n+        std::cout << \"getBufferFromDeviceIfDirty(\" <<std::hex << (long)memorySegment << \",\" << std::dec<< memorySegmentLength <<\"){\"<<std::endl;\n+    }\n+    if (config->minimizeCopies){\n+        BufferState * bufferState = BufferState::of(memorySegment,memorySegmentLength);\n+        if (bufferState->state == BufferState::DEVICE_OWNED){\n+            queue->copyFromDevice(static_cast<Backend::Buffer *>(bufferState->vendorPtr));\n+            if (config->traceEnqueues | config->traceCopies){\n+                std::cout << \"copying buffer from device (from java access) \"<< std::endl;\n+            }\n+            queue->wait();\n+            queue->release();\n+        }else{\n+            std::cout << \"HOW DID WE GET HERE 1 attempting  to get buffer but buffer is not device dirty\"<<std::endl;\n+            std::exit(1);\n+        }\n+    }else{\n+        std::cerr << \"HOW DID WE GET HERE ? java side should avoid calling getBufferFromDeviceIfDirty as we are not minimising buffers!\"<<std::endl;\n+        std::exit(1);\n+    }\n+    if (config->traceCalls){\n+        std::cout << \"}getBufferFromDeviceIfDirty()\"<<std::endl;\n+    }\n+    return true;\n+\n@@ -336,0 +357,16 @@\n+}\n+\n+CudaBackend::CudaBuffer * CudaBackend::getOrCreateBuffer(BufferState *bufferState) {\n+    CudaBuffer *cudaBuffer = nullptr;\n+    if (bufferState->vendorPtr == 0L || bufferState->state == BufferState::NEW_STATE){\n+        cudaBuffer = new CudaBuffer(this,  bufferState);\n+        if (config->trace){\n+            std::cout << \"We allocated arg buffer \"<<std::endl;\n+        }\n+    }else{\n+        if (config->trace){\n+            std::cout << \"Were reusing  buffer  buffer \"<<std::endl;\n+        }\n+        cudaBuffer=  static_cast<CudaBuffer*>(bufferState->vendorPtr);\n+    }\n+    return cudaBuffer;\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend.cpp","additions":53,"deletions":16,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -33,6 +33,3 @@\n-CudaBackend::CudaBuffer::CudaBuffer(Backend *backend, Arg_s *arg, BufferState_s *bufferState)\n-        : Buffer(backend, arg,bufferState), devicePtr() {\n-    \/*\n-     *   (void *) arg->value.buffer.memorySegment,\n-     *   (size_t) arg->value.buffer.sizeInBytes);\n-     *\/\n+CudaBackend::CudaBuffer::CudaBuffer(Backend *backend,  BufferState *bufferState)\n+        : Buffer(backend, bufferState), devicePtr() {\n+\n@@ -40,1 +37,1 @@\n-    if (cudaBackend->cudaConfig.traceCalls) {\n+    if (cudaBackend->config->traceCalls) {\n@@ -45,1 +42,1 @@\n-            .e=cuMemAlloc(&devicePtr, (size_t) arg->value.buffer.sizeInBytes),\n+            .e=cuMemAlloc(&devicePtr, (size_t) bufferState->length),\n@@ -48,1 +45,1 @@\n-    if (cudaBackend->cudaConfig.traceCalls) {\n+    if (cudaBackend->config->traceCalls) {\n@@ -56,1 +53,1 @@\n-    if (cudaBackend->cudaConfig.traceCalls) {\n+    if (cudaBackend->config->traceCalls) {\n@@ -66,35 +63,0 @@\n-void CudaBackend::CudaBuffer::copyToDevice() {\n-    auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n-    if (cudaBackend->cudaConfig.traceCalls) {\n-        std::cout << \"copyToDevice() 0x\"\n-                  << std::hex << arg->value.buffer.sizeInBytes << std::dec << \"\/\"\n-                  << arg->value.buffer.sizeInBytes << \" \"\n-                  << \"devptr \" << std::hex << (long) devicePtr << std::dec\n-                  << std::endl;\n-    }\n-    WHERE{.f=__FILE__, .l=__LINE__,\n-            .e=cuMemcpyHtoDAsync(devicePtr, arg->value.buffer.memorySegment,\n-                                 arg->value.buffer.sizeInBytes,cudaBackend->cudaQueue.cuStream),\n-            .t=\"cuMemcpyHtoDAsync\"\n-    }.report();\n-    cudaBackend->cudaQueue.wait();\n-}\n-\n-void CudaBackend::CudaBuffer::copyFromDevice() {\n-    auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n-    if (cudaBackend->cudaConfig.traceCalls) {\n-        std::cout << \"copyFromDevice() 0x\"\n-                     << std::hex<<arg->value.buffer.sizeInBytes<<std::dec << \"\/\"\n-                     << arg->value.buffer.sizeInBytes << \" \"\n-                     << \"devptr \" << std::hex<<  (long)devicePtr <<std::dec\n-                    << std::endl;\n-    }\n-    WHERE{.f=__FILE__, .l=__LINE__,\n-            .e=cuMemcpyDtoHAsync(arg->value.buffer.memorySegment, devicePtr, arg->value.buffer.sizeInBytes,\n-                                 cudaBackend->cudaQueue.cuStream),\n-            .t=\"cuMemcpyDtoHAsync\"\n-    }.report();\n-\n-    cudaBackend->cudaQueue.wait();\n-\n-}\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_buffer.cpp","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\n+\/*\n@@ -117,1 +117,1 @@\n-}\n+} *\/\n@@ -124,0 +124,7 @@\n+}\n+\n+bool CudaBackend::CudaModule::CudaKernel::setArg(KernelArg *arg){\n+    argslist[arg->idx] = static_cast<void *>(&arg->value);\n+}\n+bool CudaBackend::CudaModule::CudaKernel::setArg(KernelArg *arg, Buffer *buffer) {\n+    argslist[arg->idx] = static_cast<void *>(&dynamic_cast<CudaBuffer *>(buffer)->devicePtr);\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_kernel.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-void CudaBackend::CudaQueue::showEvents(int width) {\n@@ -44,1 +43,0 @@\n-}\n@@ -50,3 +48,0 @@\n-    if (eventc > 0){\n-\n-    }\n@@ -55,33 +50,0 @@\n-void CudaBackend::CudaQueue::marker(int bits){\n-   \/\/ cl_int status = clEnqueueMarkerWithWaitList(\n-          \/\/  command_queue,\n-           \/\/ this->eventc, this->eventListPtr(),this->nextEventPtr()\n-   \/\/ );\n-   \/\/ if (status != CL_SUCCESS){\n-     \/\/   std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n-     \/\/   std::exit(1);\n-  \/\/  }\n-   \/\/ inc(bits);\n-}\n-void CudaBackend::CudaQueue::marker(int bits, const char* arg){\n-   \/\/ cl_int status = clEnqueueMarkerWithWaitList(\n-          \/\/  command_queue,\n-          \/\/  this->eventc, this->eventListPtr(),this->nextEventPtr()\n-  \/\/  );\n-   \/\/ if (status != CL_SUCCESS){\n-     \/\/   std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n-      \/\/  std::exit(1);\n-   \/\/ }\n-   \/\/ inc(bits, arg);\n-}\n-void CudaBackend::CudaQueue::marker(int bits, int arg){\n-    \/\/cl_int status = clEnqueueMarkerWithWaitList(\n-          \/\/  command_queue,\n-        \/\/    this->eventc, this->eventListPtr(),this->nextEventPtr()\n-  \/\/  );\n-   \/\/ if (status != CL_SUCCESS){\n-    \/\/    std::cerr << \"failed to clEnqueueMarkerWithWaitList \"<<errorMsg(status)<< std::endl;\n-    \/\/    std::exit(1);\n-  \/\/  }\n- \/\/   inc(bits, arg);\n-}\n@@ -92,1 +54,0 @@\n-    marker(StartComputeBits);\n@@ -98,2 +59,0 @@\n-    marker(EndComputeBits);\n-}\n@@ -101,24 +60,0 @@\n-void CudaBackend::CudaQueue::inc(int bits){\n-    if (eventc+1 >= eventMax){\n-        std::cerr << \"CudaBackend::CudaQueue event list overflowed!!\" << std::endl;\n-    }else{\n-        eventInfoBits[eventc]=bits;\n-    }\n-    eventc++;\n-}\n-void CudaBackend::CudaQueue::inc(int bits, const char *arg){\n-    if (eventc+1 >= eventMax){\n-        std::cerr << \"CudaBackend::CudaQueue event list overflowed!!\" << std::endl;\n-    }else{\n-        eventInfoBits[eventc]=bits|HasConstCharPtrArgBits;\n-        eventInfoConstCharPtrArgs[eventc]=arg;\n-    }\n-    eventc++;\n-}\n-void CudaBackend::CudaQueue::inc(int bits, int arg){\n-    if (eventc+1 >= eventMax){\n-        std::cerr << \"CudaBackend::CudaQueue event list overflowed!!\" << std::endl;\n-    }else{\n-        eventInfoBits[eventc]=bits|arg|hasIntArgBits;\n-    }\n-    eventc++;\n@@ -127,21 +62,2 @@\n-void CudaBackend::CudaQueue::markAsEndComputeAndInc(){\n-    inc(EndComputeBits);\n-}\n-void CudaBackend::CudaQueue::markAsStartComputeAndInc(){\n-    inc(StartComputeBits);\n-}\n-void CudaBackend::CudaQueue::markAsNDRangeAndInc(){\n-    inc(NDRangeBits);\n-}\n-void CudaBackend::CudaQueue::markAsCopyToDeviceAndInc(int argn){\n-    inc(CopyToDeviceBits, argn);\n-}\n-void CudaBackend::CudaQueue::markAsCopyFromDeviceAndInc(int argn){\n-    inc(CopyFromDeviceBits, argn);\n-}\n-void CudaBackend::CudaQueue::markAsEnterKernelDispatchAndInc(){\n-    inc(EnterKernelDispatchBits);\n-}\n-void CudaBackend::CudaQueue::markAsLeaveKernelDispatchAndInc(){\n-    inc(LeaveKernelDispatchBits);\n-}\n+\n+\n@@ -150,9 +66,1 @@\n-   \/\/ cl_int status = CL_SUCCESS;\n-  \/\/  for (int i = 0; i < eventc; i++) {\n-   \/\/     status = clReleaseEvent(events[i]);\n-    \/\/    if (status != CL_SUCCESS) {\n-      \/\/      std::cerr << CudaBackend::errorMsg(status) << std::endl;\n-      \/\/      exit(1);\n-   \/\/     }\n-   \/\/ }\/\/\n- \/\/   eventc = 0;\n+\n@@ -168,0 +76,67 @@\n+\n+void CudaBackend::CudaQueue::copyToDevice(Buffer *buffer) {\n+    \/\/auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n+    auto *cudaBuffer = dynamic_cast<CudaBuffer *>(buffer);\n+    if (backend->config->traceCalls) {\n+        std::cout << \"copyToDevice() 0x\"\n+                << std::hex<<cudaBuffer->bufferState->length<<std::dec << \"\/\"\n+                << cudaBuffer->bufferState->length << \" \"\n+                << \"devptr \" << std::hex<<  (long)cudaBuffer->devicePtr <<std::dec\n+                  << std::endl;\n+    }\n+    WHERE{.f=__FILE__, .l=__LINE__,\n+            .e=cuMemcpyHtoDAsync(\n+                    cudaBuffer->devicePtr,\n+                    cudaBuffer->bufferState->ptr,\n+                    cudaBuffer->bufferState->length,\n+                    dynamic_cast<CudaQueue*>(backend->queue)->cuStream),\n+            .t=\"cuMemcpyHtoDAsync\"\n+    }.report();\n+\n+}\n+\n+void CudaBackend::CudaQueue::copyFromDevice(Buffer *buffer) {\n+    auto *cudaBuffer = dynamic_cast<CudaBuffer *>(buffer);\n+    \/\/auto cudaBackend = dynamic_cast<CudaBackend*>(backend);\n+    if (backend->config->traceCalls) {\n+        std::cout << \"copyFromDevice() 0x\"\n+                  << std::hex<<cudaBuffer->bufferState->length<<std::dec << \"\/\"\n+                  << cudaBuffer->bufferState->length << \" \"\n+                  << \"devptr \" << std::hex<<  (long)cudaBuffer->devicePtr <<std::dec\n+                  << std::endl;\n+    }\n+    WHERE{.f=__FILE__, .l=__LINE__,\n+            .e=cuMemcpyDtoHAsync(\n+                    cudaBuffer->bufferState->ptr,\n+                    cudaBuffer->devicePtr,\n+                    cudaBuffer->bufferState->length,\n+                                 dynamic_cast<CudaQueue*>(backend->queue)->cuStream),\n+            .t=\"cuMemcpyDtoHAsync\"\n+    }.report();\n+\n+}\n+\n+void CudaBackend::CudaQueue::dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) {\n+    auto cudaKernel = dynamic_cast<CudaModule::CudaKernel *>(kernel);\n+\n+    int range = kernelContext->maxX;\n+    int rangediv1024 = range \/ 1024;\n+    int rangemod1024 = range % 1024;\n+    if (rangemod1024 > 0) {\n+        rangediv1024++;\n+    }\n+\/\/ std::cout << \"Running the kernel...\" << std::endl;\n+\/\/ std::cout << \"   Requested range   = \" << range << std::endl;\n+\/\/ std::cout << \"   Range mod 1024    = \" << rangemod1024 << std::endl;\n+\/\/ std::cout << \"   Actual range 1024 = \" << (rangediv1024 * 1024) << std::endl;\n+\/\/  auto status= static_cast<CUresult>(cudaStreamSynchronize(cudaBackend->cudaQueue.cuStream));\n+\n+\/\/  cudaBackend->cudaQueue.wait();\n+    auto status = cuLaunchKernel(cudaKernel->function,\n+                                 rangediv1024, 1, 1,\n+                                 1024, 1, 1,\n+                                 0, cuStream,\n+                                 cudaKernel->argslist, nullptr);\n+\n+    WHERE{.f=__FILE__, .l=__LINE__, .e=status, .t=\"cuLaunchKernel\"}.report();\n+}\n\\ No newline at end of file\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/cuda_backend_queue.cpp","additions":70,"deletions":95,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-class KernelContext{\n+class KernelContextWithBufferState{\n@@ -31,1 +31,1 @@\n-BufferState_s bufferState;\n+BufferState bufferState;\n@@ -36,1 +36,1 @@\n-    Arg_s argv[2];\n+    KernelArg argv[2];\n@@ -40,1 +40,1 @@\n-struct S32Array1024_s {\n+struct S32Array1024WithBufferState {\n@@ -43,1 +43,1 @@\n-    BufferState_s bufferState;\n+    BufferState bufferState;\n@@ -47,3 +47,3 @@\n-            | CudaBackend::CudaConfig::Config::INFO_BIT\n-            | CudaBackend::CudaConfig::Config::TRACE_CALLS_BIT\n-            | CudaBackend::CudaConfig::Config::TRACE_COPIES_BIT\n+            | Backend::Config::Config::INFO_BIT\n+            | Backend::Config::Config::TRACE_CALLS_BIT\n+            | Backend::Config::Config::TRACE_COPIES_BIT\n@@ -145,7 +145,7 @@\n-     auto  *ndrange = bufferOf<NDRange>(\"ndrange\");\n-    ndrange->x=0;\n-    ndrange->maxX=maxX;\n-    auto *s32Array1024 = bufferOf<S32Array1024_s>(\"s32Arrayx1024\");\n-    s32Array1024->length=maxX;\n-    for (int i=0; i<s32Array1024->length; i++){\n-        s32Array1024->array[i]=i;\n+     auto  *kernelContextWithBufferState = bufferOf<KernelContextWithBufferState>(\"kernelcontext\");\n+    kernelContextWithBufferState->x=0;\n+    kernelContextWithBufferState->maxX=maxX;\n+    auto *pS32Array1024WithBufferState = bufferOf<S32Array1024WithBufferState>(\"s32Arrayx1024\");\n+    pS32Array1024WithBufferState->length=maxX;\n+    for (int i=0; i<pS32Array1024WithBufferState->length; i++){\n+        pS32Array1024WithBufferState->array[i]=i;\n@@ -155,2 +155,2 @@\n-            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) ndrange, .sizeInBytes = sizeof(NDRange), .access = RO_BYTE}}},\n-            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) s32Array1024, .sizeInBytes = sizeof(S32Array1024_s), .access = RW_BYTE}}}\n+            {.idx = 0, .variant = '&',.value = {.buffer ={.memorySegment = (void *) kernelContextWithBufferState, .sizeInBytes = sizeof(KernelContextWithBufferState), .access = RO_BYTE}}},\n+            {.idx = 1, .variant = '&',.value = {.buffer ={.memorySegment = (void *) pS32Array1024WithBufferState, .sizeInBytes = sizeof(S32Array1024WithBufferState), .access = RW_BYTE}}}\n@@ -161,2 +161,2 @@\n-    for (int i=0; i<s32Array1024->length; i++){\n-        int sq = s32Array1024->array[i];\n+    for (int i=0; i<pS32Array1024WithBufferState->length; i++){\n+        int sq = pS32Array1024WithBufferState->array[i];\n","filename":"hat\/backends\/ffi\/cuda\/cpp\/squares.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -99,5 +99,0 @@\n-class CudaConfig : public Backend::Config{\n-    public:\n-        CudaConfig(int mode);\n-        ~CudaConfig()=default;\n-    };\n@@ -109,20 +104,13 @@\n-        void showEvents(int width);\n-        void wait();\n-        void release();\n-        void computeStart();\n-        void computeEnd();\n-        void inc(int bits);\n-        void inc(int bits, const char *arg);\n-        void inc(int bits, int arg);\n-        void marker(int bits);\n-        void marker(int bits, const char *arg);\n-        void marker(int bits, int arg);\n-        void markAsCopyToDeviceAndInc(int argn);\n-        void markAsCopyFromDeviceAndInc(int argn);\n-        void markAsNDRangeAndInc();\n-        void markAsStartComputeAndInc();\n-        void markAsEndComputeAndInc();\n-        void markAsEnterKernelDispatchAndInc();\n-        void markAsLeaveKernelDispatchAndInc();\n-      \/\/  void sync(const char *file, int line) const;\n-        virtual ~CudaQueue();\n+         void wait() override;\n+\n+         void release() override;\n+\n+         void computeStart() override;\n+\n+         void computeEnd() override;\n+\n+         void copyToDevice(Buffer *buffer) override;\n+\n+         void copyFromDevice(Buffer *buffer) override;\n+\n+        virtual void dispatch(KernelContext *kernelContext, CompilationUnit::Kernel *kernel) override;\n@@ -130,0 +118,1 @@\n+        virtual ~CudaQueue();\n@@ -136,3 +125,1 @@\n-        CudaBuffer(Backend *backend,Arg_s *arg, BufferState_s *bufferStateS);\n-        void copyToDevice();\n-        void copyFromDevice();\n+        CudaBuffer(Backend *backend, BufferState *bufferState);\n@@ -153,3 +140,0 @@\n-        private:\n-            CUfunction function;\n-\n@@ -157,0 +141,2 @@\n+            bool setArg(KernelArg *arg) override;\n+            bool setArg(KernelArg *arg, Buffer *buffer) override;\n@@ -161,1 +147,3 @@\n-            long ndrange( void *argArray);\n+\n+            CUfunction function;\n+            void *argslist[100];\n@@ -171,2 +159,0 @@\n-\n-\n@@ -179,3 +165,0 @@\n-\n-    CudaConfig cudaConfig;\n-    CudaQueue cudaQueue;\n@@ -190,0 +173,1 @@\n+    CudaBuffer * getOrCreateBuffer(BufferState *bufferState) override;\n@@ -193,1 +177,0 @@\n-\n","filename":"hat\/backends\/ffi\/cuda\/include\/cuda_backend.h","additions":21,"deletions":38,"binary":false,"changes":59,"status":"modified"}]}