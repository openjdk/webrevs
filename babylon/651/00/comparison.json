{"files":[{"patch":"@@ -55,1 +55,0 @@\n-        <module>arrayview<\/module>\n","filename":"hat\/examples\/pom.xml","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n","filename":"hat\/examples\/view\/src\/main\/java\/view\/F32.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-        var example_arrayview = Jar.of(project.id(\"example{s}-arrayview\"), core);\n@@ -183,1 +182,1 @@\n-                    Stream.of(\"core\",\"tools\",\"examples\",\"backends\",\"docs\",\"wraps\")\n+                    Stream.of(\"hat\",\"core\",\"tools\",\"examples\",\"backends\",\"docs\",\"wraps\")\n@@ -186,0 +185,1 @@\n+                                System.out.println(\"Checking \"+dir);\n","filename":"hat\/hat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+[ -d build\/job.classes ] && echo \"removing old job classes dir \" && rm -rf build\/job.classes\n+echo \"creating job classes dir \" && mkdir -p build\/job.classes\n+echo \"compiling job classes \" && javac -d build\/job.classes --source-path hat\/job\/src\/main\/java $(find hat\/job\/src\/main\/java\/job -name \"*.java\")\n+echo \"creating hat\/job.jar\" && jar cf hat\/job.jar -C build\/job.classes job\n","filename":"hat\/hat\/bootstrap.bash","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"filename":"hat\/hat\/job.jar","binary":true,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+bootstrap.classes\/\n+bootstrap.jar\n+build\/\n+out\/\n","filename":"hat\/hat\/job\/.gitignore","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+public class CMake extends DependencyImpl<CMake> implements Dependency.Buildable, Dependency.WithPath {\n+    public ForkExec.Result cmake(Consumer<String> lineConsumer, List<String> tailopts) {\n+        ForkExec.Opts opts = ForkExec.Opts.of(\"cmake\");\n+        tailopts.forEach(opts::add);\n+        id.project().reporter.command(this, opts.toString());\n+        id.project().reporter.progress(this, opts.toString());\n+        var result =  ForkExec.forkExec(this, id.project().rootPath(), opts);\n+        result.stdErrAndOut().forEach((line) -> {\n+            lineConsumer.accept(line);\n+            id().project().reporter.info(this, line);\n+        });\n+\n+        if (result.status()!=0){\n+            id().project().reporter.error(this, opts.toString());\n+            throw new RuntimeException(\"CMake failed\");\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public List<Path> generatedPaths() {\n+        throw new IllegalStateException(\"who called me\");\n+    }\n+\n+    ForkExec.Result cmake(Consumer<String> lineConsumer, String... opts) {\n+        return cmake(lineConsumer, List.of(opts));\n+    }\n+\n+    public ForkExec.Result cmakeInit(Consumer<String> lineConsumer) {\n+        return cmake(lineConsumer, \"--fresh\", \"-DHAT_TARGET=\" + id().project().buildPath(), \"-B\", cmakeBuildDir().toString(), \"-S\", cmakeSourceDir().toString());\n+    }\n+\n+    public ForkExec.Result cmakeBuildTarget(Consumer<String> lineConsumer, String target) {\n+        return cmake(lineConsumer, \"--build\", cmakeBuildDir().toString(), \"--target\", target);\n+    }\n+\n+    public ForkExec.Result cmakeBuild(Consumer<String> lineConsumer) {\n+        return cmake(lineConsumer, \"--build\", cmakeBuildDir().toString());\n+    }\n+\n+    public ForkExec.Result cmakeClean(Consumer<String> lineConsumer) {\n+        return cmakeBuildTarget(lineConsumer, \"clean\");\n+    }\n+\n+\n+    @Override\n+    public boolean build() {\n+        cmakeInit(_ -> {\n+        });\n+        cmakeBuild(_ -> {\n+        });\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean clean() {\n+        cmakeInit(_ -> {\n+        });\n+        cmakeClean(_ -> {\n+        });\n+        return false;\n+    }\n+\n+    final Path cmakeSourceDir;\n+    final Path cmakeBuildDir;\n+\n+    Path cmakeSourceDir() {\n+        return cmakeSourceDir;\n+    }\n+\n+    Path cmakeBuildDir() {\n+        return cmakeBuildDir;\n+    }\n+\n+    final Path CMakeLists_txt;\n+\n+    protected CMake(Project.Id gsn, Path cmakeSourceDir, Set<Dependency> dependencies) {\n+        super(gsn, dependencies);\n+        if (id.path() != null && !Files.exists(id.path())) {\n+            System.err.println(\"The path does not exist: \" + id.path());\n+        }\n+        this.cmakeSourceDir = cmakeSourceDir;\n+        this.cmakeBuildDir = cmakeSourceDir.resolve(\"build\");\n+        this.CMakeLists_txt = cmakeSourceDir.resolve(\"CMakeLists.txt\");\n+    }\n+\n+    protected CMake(Project.Id id, Set<Dependency> dependencies) {\n+        this(id, id.path(), dependencies);\n+    }\n+\n+    public static CMake of(Project.Id id, Set<Dependency> dependencies) {\n+        return new CMake(id, dependencies);\n+    }\n+\n+    public static CMake of(Project.Id id, Dependency... dependencies) {\n+        return of(id, Set.of(dependencies));\n+    }\n+\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/CMake.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public abstract class CMakeInfo extends CMake implements Dependency.Optional, JExtractOptProvider {\n+\n+    Path asPath(String key) {\n+        return properties.containsKey(key) ? Path.of((String) properties.get(key)) : null;\n+    }\n+\n+    boolean asBoolean(String key) {\n+        return properties.containsKey(key) && Boolean.parseBoolean((String) properties.get(key));\n+    }\n+\n+    String asString(String key) {\n+        return (properties.containsKey(key) && properties.get(key) instanceof String s) ? s : null;\n+    }\n+    List<String> asSemiSeparatedStringList(String key) {\n+        return Arrays.stream(asString(key).split(\";\")).toList();\n+    }\n+\n+    final String find;\n+    final String response;\n+    final static String template = \"\"\"\n+            cmake_minimum_required(VERSION 3.22.1)\n+            project(extractions)\n+            find_package(__find__)\n+            get_cmake_property(_variableNames VARIABLES)\n+            foreach (_variableName ${_variableNames})\n+               message(STATUS \"${_variableName}=${${_variableName}}\")\n+            endforeach()\n+            \"\"\";\n+\n+    final String text;\n+\n+    final Set<String> vars;\n+    Properties properties = new Properties();\n+    final Path propertiesPath;\n+    final String sysName;\n+    final String fwk;\n+    final boolean darwin;\n+    final boolean linux;\n+    final Map<String, String> otherVarMap = new LinkedHashMap<>();\n+    final boolean available;\n+\n+    CMakeInfo(Project.Id id, String find, String response, Set<String> varsIn, Set<Dependency> buildDependencies) {\n+        super(id, id.project().confPath().resolve(\"cmake-info\").resolve(find), buildDependencies);\n+        this.find = find;\n+        this.response = response;\n+\n+        this.vars = new LinkedHashSet<>(Set.of(\n+                \"CMAKE_HOST_SYSTEM_NAME\",\n+                \"CMAKE_HOST_SYSTEM_PROCESSOR\",\n+                \"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\",\n+                response\n+        ));\n+        this.vars.addAll(varsIn);\n+\n+        this.text = template.replaceAll(\"__find__\", find).replaceAll(\"__response__\", response);\n+        this.propertiesPath = cmakeSourceDir().resolve(\"properties\");\n+        if (Files.exists(propertiesPath)) {\n+            properties = new Properties();\n+            try {\n+                properties.load(Files.newInputStream(propertiesPath));\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        } else {\n+            id.project().mkdir(cmakeBuildDir());\n+            try {\n+                Files.writeString(CMakeLists_txt, this.text, StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n+                Pattern p = Pattern.compile(\"-- *([A-Za-z_0-9]+)=(.*)\");\n+                cmakeInit((line) -> {\n+                    if (p.matcher(line) instanceof Matcher matcher && matcher.matches()) {\n+                        \/\/   System.out.println(\"GOT \"+matcher.group(1)+\"->\"+matcher.group(2));\n+                        if (this.vars.contains(matcher.group(1))) {\n+                            properties.put(matcher.group(1), matcher.group(2));\n+                        } else {\n+                            otherVarMap.put(matcher.group(1), matcher.group(2));\n+                        }\n+                    } else {\n+                        \/\/ System.out.println(\"skipped \" + line);\n+                    }\n+                });\n+                properties.store(Files.newOutputStream(propertiesPath), \"A comment\");\n+            } catch (IOException ioException) {\n+                throw new IllegalStateException(ioException);\n+            }\n+        }\n+        available = asBoolean(response);\n+        sysName = asString(\"CMAKE_HOST_SYSTEM_NAME\");\n+        darwin = sysName.equals(\"Darwin\");\n+        linux = sysName.equals(\"Linux\");\n+        fwk = darwin?asString(\"CMAKE_C_IMPLICIT_LINK_FRAMEWORK_DIRECTORIES\"):null;\n+    }\n+\n+    @Override\n+    public void writeCompilerFlags(Path outputDir) {\n+        if (darwin) {\n+            try {\n+                Path compileFLags = outputDir.resolve(\"compile_flags.txt\");\n+                Files.writeString(compileFLags, \"-F\" + fwk + \"\\n\", StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+    }\n+    @Override\n+    public boolean isAvailable() {\n+        return available;\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/CMakeInfo.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.Set;\n+\n+public class Cuda extends CMakeInfo {\n+    public Cuda(Project.Id id, Set<Dependency> buildDependencies) {\n+        super(id, \"CUDAToolkit\", \"CUDATOOLKIT_FOUND\", Set.of(\n+                \"CUDA_OpenCL_LIBRARY\",\n+                \"CUDA_cuFile_LIBRARY\",\n+                \"CUDA_cuda_driver_LIBRARY\",\n+                \"CUDA_cudart_LIBRARY\",\n+                \"CUDAToolkit_BIN_DIR\",\n+                \"CUDAToolkit_INCLUDE_DIRS\",\n+                \"CUDAToolkit_NVCC_EXECUTABLE\",\n+                \"CUDAToolkit_LIBRARY_DIR\",\n+                \"CUDAToolkit_Version\"\n+        ), buildDependencies);\n+    }\n+\n+    public Cuda(Project.Id id, Dependency ...dependencies) {\n+        this(id, Set.of(dependencies));\n+    }\n+\n+    @Override\n+    public void jExtractOpts(ForkExec.Opts opts) {\n+\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Cuda.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class Dag {\n+        record DotBuilder(Consumer<String> consumer){\n+           \/\/ https:\/\/graphviz.org\/doc\/info\/lang.html\n+            static DotBuilder of(Consumer<String> stringConsumer, Consumer<DotBuilder> builderConsumer){\n+                DotBuilder db = new DotBuilder(stringConsumer);\n+                db.append(\"strict digraph graphname {\").append(\"\\n\");\n+                db.append(\"   node [shape=record];\\n\");\n+                builderConsumer.accept(db);\n+                db.append(\"\\n}\");\n+                return db;\n+            }\n+            DotBuilder append(String s){\n+                consumer.accept(s);\n+                return this;\n+            }\n+            DotBuilder quoted(String s){\n+                append(\"\\\"\").append(s).append(\"\\\"\");\n+                return this;\n+            }\n+            DotBuilder node(String n, String label){\n+                return append(\"\\n   \").quoted(n).append(\"[\").append(\"label\").append(\"=\").quoted(label).append(\"]\").append(\";\");\n+            }\n+            DotBuilder edge(String from, String to){\n+                return append(\"\\n   \").quoted(from).append(\"->\").quoted(to).append(\";\");\n+            }\n+        }\n+        Map<Dependency, Set<Dependency>> map = new LinkedHashMap<>();\n+        record Edge(Dependency from, Dependency to) {}\n+        List<Edge> edges = new ArrayList<>();\n+         public void recurse( Dependency from) {\n+            var set = map.computeIfAbsent(from, _ -> new LinkedHashSet<>());\n+            var deps = from.dependencies();\n+            deps.forEach(dep -> {\n+                edges.add(new Edge(from, dep));\n+                set.add(dep);\n+                recurse( dep);\n+            });\n+        }\n+        public Dag(Set<Dependency> deps) {\n+            deps.forEach(this::recurse);\n+        }\n+        public Dag(Dependency...deps) {\n+             this(Stream.of(deps).collect(Collectors.toSet()));\n+        }\n+\n+        public String toDot(){\n+            StringBuilder sb = new StringBuilder();\n+            DotBuilder.of(sb::append, db-> {\n+                map.keySet().forEach(k -> {\n+                    db.node(k.id().projectRelativeHyphenatedName(), k.id().projectRelativeHyphenatedName());\n+                });\n+                edges.forEach(e ->\n+                        db.edge(e.from.id().projectRelativeHyphenatedName(), e.to.id().projectRelativeHyphenatedName())\n+                );\n+            });\n+            return sb.toString();\n+        }\n+        public Set<Dependency> ordered(){\n+            Set<Dependency> ordered = new LinkedHashSet<>();\n+            while (!map.isEmpty()) {\n+                var leaves = map.entrySet().stream()\n+                        .filter(e -> e.getValue().isEmpty())    \/\/ if this entry has zero dependencies\n+                        .map(Map.Entry::getKey)                 \/\/ get the key\n+                        .collect(Collectors.toSet());\n+                map.values().forEach(v -> leaves.forEach(v::remove));\n+                leaves.forEach(leaf -> {\n+                    map.remove(leaf);\n+                    ordered.add(leaf);\n+                });\n+            }\n+            return ordered;\n+        }\n+\n+    public Dag available(){\n+        var ordered = this.ordered();\n+        Set<Dependency> unavailable = ordered.stream().filter(\n+                d -> {\n+                    if (d instanceof Dependency.Optional opt) {\n+                       return !opt.isAvailable();\n+                    }else{\n+                        return false;\n+                    }\n+                })\n+                .collect(Collectors.toSet());\n+\n+        boolean changed = true;\n+        while (changed) {\n+            changed = false;\n+            for(Dependency dep : ordered) {\n+                if (!changed) {\n+                    var optionalDependsOnUnavailable = dep.dependencies().stream().filter(d ->\n+                            unavailable.contains(d) || d instanceof Dependency.Optional o && !o.isAvailable()).findFirst();\n+                    if (optionalDependsOnUnavailable.isPresent()) {\n+                        changed = true;\n+                        unavailable.add(dep);\n+                        ordered.remove(dep);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return new Dag(ordered);\n+    }\n+\n+\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Dag.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+\n+public interface Dependency {\n+    Project.Id id();\n+\n+    Set<Dependency> dependencies();\n+\n+    interface WithPath extends Dependency {\n+    }\n+\n+    interface Buildable extends Dependency {\n+        boolean build();\n+\n+        boolean clean();\n+\n+        List<Path> generatedPaths();\n+    }\n+\n+    interface Executable extends Dependency {\n+    }\n+\n+    interface ExecutableJar extends Executable {\n+        boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> vmOpts, List<String> args);\n+    }\n+\n+    interface Runnable extends Executable {\n+        boolean run();\n+    }\n+\n+    interface Optional extends Dependency {\n+        boolean isAvailable();\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Dependency.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public abstract class DependencyImpl<T extends DependencyImpl<T>> implements Dependency {\n+    protected final Project.Id id;\n+\n+    @Override\n+    public Project.Id id() {\n+        return id;\n+    }\n+\n+    final private Set<Dependency> dependencies = new LinkedHashSet<>();\n+\n+    @Override\n+    public Set<Dependency> dependencies() {\n+        return dependencies;\n+    }\n+\n+    DependencyImpl(Project.Id id, Set<Dependency> dependencies) {\n+        this.id = id;\n+        this.dependencies.addAll(dependencies);\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/DependencyImpl.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ForkExec {\n+    public record Result(\n+            Dependency dependency,\n+            Path path,\n+            Opts opts,\n+            int status,\n+            List<String> stdErrAndOut){\n+    }\n+    static Result forkExec(Dependency dependency, Path path, Opts opts) {\n+        try {\n+            List<String> stdErrAndOut = new ArrayList<>();\n+            Process process = new ProcessBuilder()\n+                    .directory(path.toFile())\n+                    .command(opts.opts)\n+                    .redirectErrorStream(true)\n+                    .start();\n+            new BufferedReader(new InputStreamReader(process.getInputStream())).lines().forEach(line->{\n+                System.out.println(line);\n+                stdErrAndOut.add(line);\n+            });\n+            process.waitFor();\n+            return new Result(dependency, path, opts, process.exitValue(), stdErrAndOut);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static class Opts {\n+        List<String> opts = new ArrayList<>();\n+        private Opts(){\n+\n+        }\n+        Opts add(String ...opts){\n+            this.opts.addAll(List.of(opts));\n+            return this;\n+        }\n+\n+        public static Opts of(String executable) {\n+            Opts opts = new Opts();\n+            opts.add(executable);\n+            return opts;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.join(\" \", opts);\n+        }\n+\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/ForkExec.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,338 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import org.w3c.dom.Element;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+public class Intellij {\n+    public Path intellijDir;\n+    public Modules modules;\n+    public ImlGraph imlGraph;\n+    public WorkspaceInfo workSpace;\n+    public CompilerInfo compilerInfo;\n+\n+    Map<String, String> vars;\n+\n+    \/\/static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+    static Pattern varPattern = Pattern.compile(\"\\\\$([^$]*)\\\\$\");\n+\n+    public String expand(String value) { \/\/ recurse\n+        String result = value;\n+        if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+            var v = matcher.group(1);\n+            result = expand(value.substring(0, matcher.start())\n+                    + (v.startsWith(\"env\")\n+                    ? System.getenv(v.substring(4))\n+                    : vars.get(v))\n+                    + value.substring(matcher.end()));\n+            \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+        }\n+        return result;\n+    }\n+\n+\n+    public Intellij(Path intellijDir) {\n+        this.vars = new HashMap<>();\n+        this.vars.put(\"PROJECT_DIR\", intellijDir.toString());\n+        this.intellijDir = intellijDir;\n+        var ideaDir = intellijDir.resolve(\".idea\");\n+        this.modules = new Modules(this, new XMLNode(ideaDir.resolve(\"modules.xml\")));\n+        this.imlGraph = new ImlGraph(this, modules);\n+        this.workSpace = new WorkspaceInfo(this, new XMLNode(ideaDir.resolve(\"workspace.xml\")));\n+        this.compilerInfo = new CompilerInfo(this, new XMLNode(ideaDir.resolve(\"compiler.xml\")));\n+    }\n+\n+    interface Queryable {\n+        Intellij intellij();\n+\n+        XMLNode xmlNode();\n+\n+        default Stream<XMLNode> query(String xpath) {\n+            return xmlNode().nodes(xmlNode().xpath(xpath)).map(e -> new XMLNode((Element) e));\n+        }\n+\n+        interface withUrl extends Queryable {\n+            default String url() {\n+                return xmlNode().attr(\"url\");\n+            }\n+        }\n+\n+        interface withType extends Queryable {\n+            default String type() {\n+                return xmlNode().attr(\"type\");\n+            }\n+        }\n+\n+        interface withPath extends Queryable {\n+            default String path() {\n+                return xmlNode().attr(\"path\");\n+            }\n+        }\n+        interface withValue extends Queryable {\n+            default String value() {\n+                return xmlNode().attr(\"value\");\n+            }\n+        }\n+        interface withName extends Queryable {\n+            default String name() {\n+                return xmlNode().attr(\"name\");\n+            }\n+        }\n+        interface withOptions extends Queryable {\n+            default String[] options() {\n+                return xmlNode().attr(\"options\").split(\" \");\n+            }\n+        }\n+    }\n+\n+    public record Modules(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+        public record Module(Path imlPath, Intellij intellij, XMLNode xmlNode) implements Queryable {\n+            public record ModuleOrderEntry(Path imlPath, Intellij intellij, XMLNode xmlNode) implements Queryable.withType {\n+            }\n+\n+            public record ModuleLibraryOrderEntry(Intellij intellij, XMLNode xmlNode) implements Queryable.withType {\n+                public record Library(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+                    public record Classes(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+                        public record Root(Intellij intellij, XMLNode xmlNode) implements Queryable.withUrl { }\n+                        public Stream<Root> roots() {\n+                            return query(\"root\").map(e -> new Root(intellij, e));\n+                        }\n+                    }\n+\n+                    public Stream<Classes> listOfClasses() {\n+                        return query(\"CLASSES\").map(e -> new Classes(intellij, e));\n+                    }\n+                }\n+\n+                public Stream<Library> libraries() {\n+                    return query(\"library\").map(e -> new Library(intellij, e));\n+                }\n+            }\n+\n+            public record Content(Intellij intellij, XMLNode xmlNode) implements Queryable.withUrl {\n+                public record SourceFolder(Intellij intellij, XMLNode xmlNode) implements Queryable.withUrl, Queryable.withType { }\n+\n+                public record ExcludeFolder(Intellij intellij, XMLNode xmlNode) implements Queryable.withUrl { }\n+\n+                public Stream<SourceFolder> sourceFolders() {\n+                    return query(\"sourceFolder\").map(e -> new SourceFolder(intellij, e));\n+                }\n+\n+                public Stream<ExcludeFolder> excludeFolders() {\n+                    return query(\"excludeFolder\").map(e -> new ExcludeFolder(intellij, e));\n+                }\n+            }\n+\n+            public Stream<ModuleOrderEntry> moduleOrderEntries() {\n+                return query(\"\/module\/component\/orderEntry[@type='module']\")\n+                        .map(e -> new ModuleOrderEntry(imlPath.getParent().resolve(e.attr(\"module-name\") + \".iml\"), intellij, e));\n+            }\n+\n+            public Stream<ModuleLibraryOrderEntry> moduleLibraryOrderEntries() {\n+                return query(\"\/module\/component\/orderEntry[@type='module-library']\").map(e -> new ModuleLibraryOrderEntry(intellij, e));\n+            }\n+\n+            public Stream<Content> content() {\n+                return query(\"\/module\/component\/content\").map(e -> new Content(intellij, e));\n+            }\n+        }\n+\n+        public Stream<Modules.Module> modules() {\n+            return query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n+                    .map(xmlNode -> Path.of(xmlNode.attrMap.get(\"filepath\").replace(\"$PROJECT_DIR$\", intellij().intellijDir.toString())))\n+                    .map(path -> new Module(path, intellij, new XMLNode(path)));\n+        }\n+    }\n+\n+    public record WorkspaceInfo(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+        public record ApplicationInfo(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+            public record ClassPath(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+                public record Entry(Intellij intellij, XMLNode xmlNode) implements Queryable.withPath {\n+                }\n+\n+                public Stream<Entry> entries() {\n+                    return query(\"entry\").map(n -> new Entry(intellij(), n));\n+                }\n+            }\n+\n+            public String className() {\n+                return query(\"option[@name='MAIN_CLASS_NAME']\").findFirst().get().attr(\"value\");\n+            }\n+\n+            public String[] vmArgs() {\n+                return query(\"option[@name='VM_PARAMETERS']\").findFirst().get().attr(\"value\").split(\" \");\n+            }\n+\n+            public ClassPath classPath() {\n+                return new ClassPath(intellij(), query(\"classpathModifications\").findFirst().get());\n+            }\n+        }\n+\n+        public Stream<ApplicationInfo> applications() {\n+            return query(\"\/project\/component[@name='RunManager']\/configuration\").map(n -> new ApplicationInfo(intellij(), n));\n+        }\n+    }\n+\n+    public record CompilerInfo(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+        public record CompilerConfiguration(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+            public record ExcludeFromCompile(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+                public record File(Intellij intellij, XMLNode xmlNode) implements Queryable.withUrl {\n+\n+                }\n+               public  Stream<File> files(){\n+                    return query(\"file\").map(n -> new File(intellij, n));\n+                }\n+            }\n+           public  Stream<ExcludeFromCompile> excludeFromCompile(){\n+                return query(\"excludeFromCompile\").map(n -> new ExcludeFromCompile(intellij, n));\n+            }\n+        }\n+\n+        public record JavacSettings(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+            public record AdditionalOptionsStrings(Intellij intellij, XMLNode xmlNode) implements Queryable.withValue, Queryable.withName {\n+\n+            }\n+\n+            public record AdditionalOptionsOverride(Intellij intellij, XMLNode xmlNode) implements Queryable {\n+                public record Module(Intellij intellij, XMLNode xmlNode) implements Queryable.withName, Queryable.withOptions {\n+\n+                }\n+                public Stream<Module> modules() {\n+                    return query(\"module\").map(n -> new Module(intellij(), n));\n+                }\n+            }\n+\n+            public Stream<AdditionalOptionsStrings> additionalOptionsStrings() {\n+                return query(\"option[@name='ADDITIONAL_OPTIONS_STRING']\").map(n -> new AdditionalOptionsStrings(intellij(), n));\n+            }\n+\n+            public Stream<AdditionalOptionsOverride> additionalOptionsOverride() {\n+                return query(\"option[@name='ADDITIONAL_OPTIONS_OVERRIDE']\").map(n -> new AdditionalOptionsOverride(intellij(), n));\n+            }\n+        }\n+      public  Stream<JavacSettings> javacSettings() {\n+            return query(\"component[@name='JavacSettings']\").map(n -> new JavacSettings(intellij(), n));\n+        }\n+      public  Stream<CompilerConfiguration> compilerConfigurations() {\n+            return query(\"component[@name='CompilerConfiguration']\").map(n -> new CompilerConfiguration(intellij(), n));\n+        }\n+    }\n+\n+\n+    public static class ImlGraph {\n+        Intellij intellij;\n+        Set<Modules.Module> moduleSet = new HashSet<>();\n+        public Map<Modules.Module, List<Modules.Module>> fromToDependencies = new HashMap<>();\n+        Map<Modules.Module, List<Modules.Module>> toFromDependencies = new HashMap<>();\n+\n+        ImlGraph(Intellij intellij, Modules modules) {\n+            this.intellij = intellij;\n+            Map<Path, Modules.Module> pathToModule = new HashMap<>();\n+            modules.modules().forEach(module -> {\n+                moduleSet.add(module);\n+                pathToModule.put(module.imlPath(), module);\n+            });\n+            moduleSet.forEach(module ->\n+                    module.moduleOrderEntries().forEach(moduleOrderEntry -> {\n+                                fromToDependencies.computeIfAbsent(pathToModule.get(module.imlPath()), _ -> new ArrayList<>()).add(pathToModule.get(moduleOrderEntry.imlPath));\n+                                toFromDependencies.computeIfAbsent(pathToModule.get(moduleOrderEntry.imlPath), _ -> new ArrayList<>()).add(pathToModule.get(module.imlPath()));\n+                            }\n+                    ));\n+        }\n+    }\n+\n+    public static void main(String[] argArr) throws IOException, InterruptedException {\n+        Path userDir = Path.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\"\/*System.getProperty(\"user.dir\")*\/);\n+        Intellij intelliJ = new Intellij(userDir.resolve(\"intellij\"));\n+        var compilerInfo = intelliJ.compilerInfo;\n+        compilerInfo.javacSettings().forEach(javacSettings -> {\n+            javacSettings.additionalOptionsStrings().forEach(additionalOptionsStrings -> {\n+                System.out.println(\"javac (allmodules) \"+additionalOptionsStrings.value());\n+            });\n+            javacSettings.additionalOptionsOverride().forEach(additionalOptionsOverride -> {\n+                additionalOptionsOverride.modules().forEach(module -> {\n+                    System.out.println(\"javac module \"+module.name()+ \" \"+String.join(\" \", module.options()));\n+                });\n+            });\n+        });\n+        compilerInfo.compilerConfigurations().forEach(compilerConfiguration -> {\n+            compilerConfiguration.excludeFromCompile().forEach(excludeFromCompile -> {\n+                excludeFromCompile.files().forEach(compileFile -> {\n+                    System.out.println(\"excluding \"+compileFile.url());\n+                });\n+            });\n+        });\n+\n+        var workspace = intelliJ.workSpace;\n+        \/\/ System.out.println(workspace);\n+\n+        workspace.applications().forEach(\n+                a -> {\n+                    System.out.println(\"java \" + String.join(\" \", a.vmArgs()) + \" \" + a.className());\n+                    Intellij.WorkspaceInfo.ApplicationInfo.ClassPath cp = a.classPath();\n+                    cp.entries().forEach(e -> {\n+                        System.out.println(intelliJ.expand(e.path()));\n+                    });\n+\n+                });\n+        intelliJ.modules.modules().forEach(module -> {\n+            System.out.println(\"module \" + module.imlPath().getFileName());\n+            module.content().forEach(content -> {\n+                System.out.println(\"       \" + content.url());\n+                content.sourceFolders().forEach(sourceFolder -> {\n+                    System.out.println(\"              \" + sourceFolder.url());\n+                });\n+                content.excludeFolders().forEach(sourceFolder -> {\n+                    System.out.println(\"              exclude \" + sourceFolder.url());\n+                });\n+            });\n+            module.moduleOrderEntries().forEach(moduleDep -> {\n+                System.out.println(\"      dep \" + moduleDep.imlPath().getFileName());\n+            });\n+            module.moduleLibraryOrderEntries().forEach(moduleDep -> {\n+                moduleDep.libraries().forEach(library -> {\n+                    library.listOfClasses().forEach(libraryClass -> {\n+                        libraryClass.roots().forEach(rootClass -> {\n+                            System.out.println(\"      dep \" + rootClass.url());\n+                        });\n+                    });\n+                });\n+            });\n+        });\n+\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Intellij.java","additions":338,"deletions":0,"binary":false,"changes":338,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.nio.file.Path;\n+import java.util.Set;\n+\n+public class JExtract extends Jar {\n+    final JExtractOptProvider optProvider;\n+\n+    private JExtract(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+        super(id, exclude, dependencies);\n+        \/\/ We expect the dependencies to include a JextractOptProvider\n+        var optionalProvider = dependencies.stream().filter(dep -> dep instanceof JExtractOptProvider).map(dep -> (JExtractOptProvider) dep).findFirst();\n+        this.optProvider = optionalProvider.orElseThrow();\n+        id.project().add(this);\n+    }\n+\n+    @Override\n+    public Path javaSourcePath() {\n+        return id.path().resolve(\"src\/main\/java\");\n+    }\n+\n+    @Override\n+    public boolean build() {\n+        try {\n+            id.project().mkdir(javaSourcePath());\n+            var opts = ForkExec.Opts.of(\"jextract\").add(\n+                    \"--target-package\", id().shortHyphenatedName(),\n+                    \"--output\", javaSourcePath().toString()\n+            );\n+            optProvider.jExtractOpts(opts);\n+            optProvider.writeCompilerFlags(id().project().rootPath());\n+            id().project().reporter.command(this, opts.toString());\n+            System.out.println(String.join(\" \", opts.toString()));\n+            id().project().reporter.progress(this, \"extracting\");\n+            var result= ForkExec.forkExec(this, id.project().rootPath(),opts);\n+            result.stdErrAndOut().forEach((line)->{\n+                id().project().reporter.warning(this, line);\n+            });\n+            super.build();\n+            return result.status()==0;\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean clean() {\n+        return false;\n+    }\n+\n+    static public JExtract extract(Project.Id id, Set<Dependency> dependencies) {\n+        return new JExtract(id, Set.of(), dependencies);\n+    }\n+\n+    static public JExtract extract(Project.Id id, Dependency... dependencies) {\n+        return new JExtract(id, Set.of(), Set.of(dependencies));\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/JExtract.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.nio.file.Path;\n+\n+interface JExtractOptProvider {\n+    void jExtractOpts(ForkExec.Opts opts);\n+     void writeCompilerFlags(Path outputDir);\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/JExtractOptProvider.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import com.sun.source.util.JavacTask;\n+\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+\n+public class Jar extends DependencyImpl<Jar> implements Dependency.Buildable, Dependency.WithPath, Dependency.ExecutableJar {\n+    final Set<Path> exclude;\n+\n+    protected Jar(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+        super(id, dependencies);\n+        this.exclude = exclude;\n+        if (id.path() != null && !Files.exists(id.path())) {\n+            System.err.println(\"The path does not exist: \" + id.path());\n+        }\n+        if (!Files.exists(javaSourcePath())) {\n+            var jsp = javaSourcePath();\n+            System.out.println(\"Failed to find java source \" + jsp + \" path for \" + id.shortHyphenatedName());\n+        }\n+        id.project().add(this);\n+    }\n+\n+    public static Jar of(Project.Id id, Set<Path> exclude, Set<Dependency> dependencies) {\n+        return new Jar(id, exclude, dependencies);\n+    }\n+\n+    public static Jar of(Project.Id id, Set<Dependency> dependencies) {\n+        return new Jar(id, Set.of(), dependencies);\n+    }\n+\n+    public static Jar of(Project.Id id, Set<Path> exclude, Dependency... dependencies) {\n+        return of(id, exclude, Set.of(dependencies));\n+    }\n+\n+    public static Jar of(Project.Id id, Dependency... dependencies) {\n+        return of(id, Set.of(), Set.of(dependencies));\n+    }\n+\n+    public static class JavaSource extends SimpleJavaFileObject {\n+        Path path;\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+            try {\n+                return Files.readString(Path.of(toUri()));\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        JavaSource(Path path) {\n+            super(path.toUri(), Kind.SOURCE);\n+            this.path = path;\n+        }\n+    }\n+\n+    public Path jarFile() {\n+        return id().project().buildPath().resolve(id().fullHyphenatedName() + \".jar\");\n+    }\n+\n+    @Override\n+    public List<Path> generatedPaths() {\n+        throw new IllegalStateException(\"who called me\");\n+    }\n+\n+\n+    @Override\n+    public boolean clean() {\n+        id().project().clean(null, classesDir(), jarFile());\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean build() {\n+        List<String> opts = new ArrayList<>(\n+                List.of(\n+                        \"--source=26\",\n+                        \"--enable-preview\",\n+                        \"--add-modules=jdk.incubator.code\",\n+                        \"--add-exports=jdk.incubator.code\/jdk.incubator.code.dialect.java.impl=ALL-UNNAMED\",\n+                        \"-g\",\n+                        \"-d\", classesDirName()\n+                ));\n+        Dag dag = new Dag(dependencies());\n+        var deps = classPath(dag.ordered());\n+        if (!deps.isEmpty()) {\n+            opts.addAll(List.of(\n+                    \"--class-path=\" + deps\n+            ));\n+        }\n+        opts.addAll(List.of(\n+                        \"--source-path=\" + javaSourcePathName()\n+                )\n+        );\n+        JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n+\n+        id().project().clean(this, classesDir());\n+\n+        if (Files.exists(javaSourcePath())) {\n+            try (var files = Files.walk(javaSourcePath())) {\n+                var listOfSources = files.filter(p -> Files.isRegularFile(p) && p.toString().endsWith(\".java\") && !exclude.contains(p)).map(JavaSource::new).toList();\n+                id().project().reporter.command(this, \"javac \" +\n+                        String.join(\" \", opts) + \" \" + String.join(\" \",\n+                        listOfSources.stream().map(JavaSource::getName).collect(Collectors.toList())));\n+\n+\n+                var diagnosticListener = new DiagnosticListener<JavaFileObject>() {\n+                    @Override\n+                    public void report(Diagnostic<? extends JavaFileObject> diagnostic) {\n+                        if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {\n+                            id().project().reporter.error(Jar.this, diagnostic.toString());\n+                        } else if (diagnostic.getKind() == Diagnostic.Kind.WARNING) {\n+                            id().project().reporter.warning(Jar.this, diagnostic.toString());\n+                        } else if (diagnostic.getKind() == Diagnostic.Kind.MANDATORY_WARNING) {\n+                            id().project().reporter.warning(Jar.this, \"!!\" + diagnostic.toString());\n+                        } else if (diagnostic.getKind() == Diagnostic.Kind.NOTE) {\n+                            id().project().reporter.note(Jar.this, diagnostic.toString());\n+                        } else {\n+                            id().project().reporter.warning(Jar.this, diagnostic.getKind() + \":\" + diagnostic.toString());\n+                        }\n+                    }\n+                };\n+                ((JavacTask) javac.getTask(\n+                        new PrintWriter(System.err),\n+                        javac.getStandardFileManager(diagnosticListener, null, null),\n+                        diagnosticListener,\n+                        opts,\n+                        null,\n+                        listOfSources\n+                )).generate().forEach(gc ->\n+                        id.project().reporter.note(this, gc.getName())\n+                );\n+\n+                List<Path> dirsToJar = new ArrayList<>(List.of(classesDir()));\n+                if (Files.exists(javaResourcePath())) {\n+                    dirsToJar.add(javaResourcePath());\n+                }\n+\n+                Manifest manifest = new Manifest();\n+                Attributes mainAttributes = manifest.getMainAttributes();\n+                mainAttributes.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+               \/\/ mainAttributes.put(Attributes.Name.MAIN_CLASS,   id().shortHyphenatedName()+\".Main\");\n+               \/\/ mainAttributes.put(Attributes.Name.IMPLEMENTATION_VENDOR, \"HAT's Java Opinionated Builder (JOB)\");\n+                var jarStream = new JarOutputStream(Files.newOutputStream(jarFile()), manifest);\n+                record RootAndPath(Path root, Path path) {\n+                }\n+                id().project().reporter.command(this, \"jar cvf \" + jarFile() + \" \" +\n+                        String.join(dirsToJar.stream().map(Path::toString).collect(Collectors.joining(\" \"))));\n+                id().project().reporter.progress(this, \"compiled \" + listOfSources.size() + \" file\" + (listOfSources.size() > 1 ? \"s\" : \"\") + \" to \" + jarFile().getFileName());\n+\n+                dirsToJar.forEach(r -> {\n+                    try {\n+\n+                        Files.walk(r)\n+                                .filter(p -> !Files.isDirectory(p))\n+                                .map(p -> new RootAndPath(r, p))\n+                                .sorted(Comparator.comparing(RootAndPath::path))\n+                                .forEach(\n+                                        rootAndPath -> {\n+                                            try {\n+                                                var entry = new JarEntry(rootAndPath.root.relativize(rootAndPath.path).toString());\n+                                                entry.setTime(Files.getLastModifiedTime(rootAndPath.path()).toMillis());\n+                                                jarStream.putNextEntry(entry);\n+                                                Files.newInputStream(rootAndPath.path()).transferTo(jarStream);\n+                                                jarStream.closeEntry();\n+                                            } catch (IOException e) {\n+                                                throw new RuntimeException(e);\n+                                            }\n+                                        });\n+\n+\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                });\n+\n+                jarStream.finish();\n+                jarStream.close();\n+                return true;\n+            } catch (Exception e) {\n+                \/\/   println(e.getMessage());\n+                throw new RuntimeException(e);\n+            }\n+        } else {\n+            return true;\n+        }\n+    }\n+\n+    protected String classPath(Set<Dependency> dependencies) {\n+        return String.join(\":\", dependencies.stream().filter(p ->\n+                p instanceof Jar).map(a -> (Jar) a).map(Jar::jarFileName).toList());\n+    }\n+\n+    protected String classPathWithThisLast(Set<Dependency> dependencies) {\n+        Set<Dependency> all = new LinkedHashSet<>(dependencies);\n+        all.remove(this);\n+        all.add(this);\n+        return String.join(\":\", all.stream().filter(p ->\n+                p instanceof Jar).map(a -> (Jar) a).map(Jar::jarFileName).toList());\n+    }\n+\n+    private Path classesDir() {\n+        return id().project().buildPath().resolve(id().fullHyphenatedName() + \".classes\");\n+    }\n+\n+    private String classesDirName() {\n+        return classesDir().toString();\n+    }\n+\n+    private String jarFileName() {\n+        return jarFile().toString();\n+    }\n+\n+    private Path javaResourcePath() {\n+        return id().path().resolve(\"src\/main\/resources\");\n+\n+    }\n+\n+    private String javaResourcePathName() {\n+        return javaResourcePath().toString();\n+    }\n+\n+    private String javaSourcePathName() {\n+        return javaSourcePath().toString();\n+    }\n+\n+    protected Path javaSourcePath() {\n+        return id().path().resolve(\"src\/main\/java\");\n+    }\n+\n+    @Override\n+    public boolean run(String mainClassName, Set<Dependency> depsInOrder, List<String> vmOpts, List<String> args) {\n+        ForkExec.Opts opts = ForkExec.Opts.of(ProcessHandle.current()\n+                .info()\n+                .command()\n+                .orElseThrow()).add(\n+                \"--enable-preview\",\n+                \"--enable-native-access=ALL-UNNAMED\"\n+        );\n+        opts.add(\n+                \"--add-exports=jdk.incubator.code\/jdk.incubator.code.dialect.java.impl=ALL-UNNAMED\", \/\/ for OpRenderer\n+                \"--class-path\", classPathWithThisLast(depsInOrder),\n+                \"-Djava.library.path=\" + id().project().buildPath()\n+        );\n+        vmOpts.forEach(opts::add);\n+        opts.add(\n+                mainClassName\n+        );\n+        args.forEach(opts::add);\n+        id().project().reporter.command(this, opts.toString());\n+        System.out.println(String.join(\" \", opts.toString()));\n+        id().project().reporter.progress(this, \"running\");\n+        var result = ForkExec.forkExec(this, id().project().rootPath(), opts);\n+        result.stdErrAndOut().forEach((line) -> {\n+            id().project().reporter.warning(this, line);\n+        });\n+        if (result.status() != 0) {\n+            System.out.println(\"Java failed to execute, is a valid java in your path ? \" + id().fullHyphenatedName());\n+        }\n+        return result.status() == 0;\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Jar.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.Set;\n+\n+public class Linux extends DependencyImpl<Linux> implements Dependency.Optional {\n+    final boolean available;\n+    public Linux(Project.Id id) {\n+        super(id, Set.of());\n+        available = System.getProperty(\"os.name\").toLowerCase().contains(\"linux\");\n+    }\n+    @Override\n+    public boolean isAvailable() {\n+        return available;\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Linux.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.Set;\n+\n+public class Mac extends DependencyImpl<Mac> implements Dependency.Optional {\n+    final boolean available;\n+\n+    public Mac(Project.Id id) {\n+        super(id, Set.of());\n+        available = System.getProperty(\"os.name\").toLowerCase().contains(\"mac\");\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+        return available;\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Mac.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,446 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import org.w3c.dom.Element;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+public class Maven {\n+    public Path rootDir;\n+    public Modules modules;\n+    public ImlGraph imlGraph;\n+    public WorkspaceInfo workSpace;\n+    public CompilerInfo compilerInfo;\n+\n+    Map<String, String> vars;\n+\n+    \/\/static Pattern varPattern = Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+    static Pattern varPattern = Pattern.compile(\"\\\\$([^$]*)\\\\$\");\n+\n+    public String expand(String value) { \/\/ recurse\n+        String result = value;\n+        if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+            var v = matcher.group(1);\n+            result = expand(value.substring(0, matcher.start())\n+                    + (v.startsWith(\"env\")\n+                    ? System.getenv(v.substring(4))\n+                    : vars.get(v))\n+                    + value.substring(matcher.end()));\n+            \/\/out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+        }\n+        return result;\n+    }\n+\n+\n+    public Maven(Path rootDir) {\n+        this.vars = new HashMap<>();\n+      \/\/  this.vars.put(\"PROJECT_DIR\", rootDir.toString());\n+        this.rootDir = rootDir;\n+      \/\/  var ideaDir = rootDir.resolve(\".idea\");\n+       \/\/ this.modules = new Modules(this, new XMLNode(ideaDir.resolve(\"modules.xml\")));\n+       \/\/ this.imlGraph = new ImlGraph(this, modules);\n+       \/\/ this.workSpace = new WorkspaceInfo(this, new XMLNode(ideaDir.resolve(\"workspace.xml\")));\n+       \/\/ this.compilerInfo = new CompilerInfo(this, new XMLNode(ideaDir.resolve(\"compiler.xml\")));\n+    }\n+\n+    interface Queryable {\n+        Maven maven();\n+\n+        XMLNode xmlNode();\n+\n+        default Stream<XMLNode> query(String xpath) {\n+            return xmlNode().nodes(xmlNode().xpath(xpath)).map(e -> new XMLNode((Element) e));\n+        }\n+\n+        interface withUrl extends Queryable {\n+            default String url() {\n+                return xmlNode().attr(\"url\");\n+            }\n+        }\n+\n+        interface withType extends Queryable {\n+            default String type() {\n+                return xmlNode().attr(\"type\");\n+            }\n+        }\n+\n+        interface withPath extends Queryable {\n+            default String path() {\n+                return xmlNode().attr(\"path\");\n+            }\n+        }\n+        interface withValue extends Queryable {\n+            default String value() {\n+                return xmlNode().attr(\"value\");\n+            }\n+        }\n+        interface withName extends Queryable {\n+            default String name() {\n+                return xmlNode().attr(\"name\");\n+            }\n+        }\n+        interface withOptions extends Queryable {\n+            default String[] options() {\n+                return xmlNode().attr(\"options\").split(\" \");\n+            }\n+        }\n+        interface withText extends Queryable {\n+            default String text(String nodeName) {\n+            \/\/    return xmlNode().query(nodeName).findFirst().get().element.getTextContent();\n+                return xmlNode().xmlNodes(xmlNode().xpath(nodeName)).findFirst().get().element.getTextContent();\n+            }\n+            default String text() {\n+                \/\/    return xmlNode().query(nodeName).findFirst().get().element.getTextContent();\n+                return xmlNode().element.getTextContent();\n+            }\n+        }\n+    }\n+\n+    public record Modules(Maven maven, XMLNode xmlNode) implements Queryable {\n+        public record Module(Path imlPath, Maven maven, XMLNode xmlNode) implements Queryable {\n+            public record ModuleOrderEntry(Path imlPath, Maven maven, XMLNode xmlNode) implements withType {\n+            }\n+\n+            public record ModuleLibraryOrderEntry(Maven maven, XMLNode xmlNode) implements withType {\n+                public record Library(Maven maven, XMLNode xmlNode) implements Queryable {\n+                    public record Classes(Maven maven, XMLNode xmlNode) implements Queryable {\n+                        public record Root(Maven maven, XMLNode xmlNode) implements withUrl { }\n+                        public Stream<Root> roots() {\n+                            return query(\"root\").map(e -> new Root(maven, e));\n+                        }\n+                    }\n+\n+                    public Stream<Classes> listOfClasses() {\n+                        return query(\"CLASSES\").map(e -> new Classes(maven, e));\n+                    }\n+                }\n+\n+                public Stream<Library> libraries() {\n+                    return query(\"library\").map(e -> new Library(maven, e));\n+                }\n+            }\n+\n+            public record Content(Maven maven, XMLNode xmlNode) implements withUrl {\n+                public record SourceFolder(Maven maven, XMLNode xmlNode) implements withUrl, withType { }\n+\n+                public record ExcludeFolder(Maven maven, XMLNode xmlNode) implements withUrl { }\n+\n+                public Stream<SourceFolder> sourceFolders() {\n+                    return query(\"sourceFolder\").map(e -> new SourceFolder(maven, e));\n+                }\n+\n+                public Stream<ExcludeFolder> excludeFolders() {\n+                    return query(\"excludeFolder\").map(e -> new ExcludeFolder(maven, e));\n+                }\n+            }\n+\n+            public Stream<ModuleOrderEntry> moduleOrderEntries() {\n+                return query(\"\/module\/component\/orderEntry[@type='module']\")\n+                        .map(e -> new ModuleOrderEntry(imlPath.getParent().resolve(e.attr(\"module-name\") + \".iml\"), maven, e));\n+            }\n+\n+            public Stream<ModuleLibraryOrderEntry> moduleLibraryOrderEntries() {\n+                return query(\"\/module\/component\/orderEntry[@type='module-library']\").map(e -> new ModuleLibraryOrderEntry(maven, e));\n+            }\n+\n+            public Stream<Content> content() {\n+                return query(\"\/module\/component\/content\").map(e -> new Content(maven, e));\n+            }\n+        }\n+\n+        public Stream<Module> modules() {\n+            return query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n+                    .map(xmlNode -> Path.of(xmlNode.attrMap.get(\"filepath\").replace(\"$PROJECT_DIR$\", maven().rootDir.toString())))\n+                    .map(path -> new Module(path, maven, new XMLNode(path)));\n+        }\n+    }\n+\n+    public record WorkspaceInfo(Maven maven, XMLNode xmlNode) implements Queryable {\n+        public record ApplicationInfo(Maven maven, XMLNode xmlNode) implements Queryable {\n+            public record ClassPath(Maven maven, XMLNode xmlNode) implements Queryable {\n+                public record Entry(Maven maven, XMLNode xmlNode) implements withPath {\n+                }\n+\n+                public Stream<Entry> entries() {\n+                    return query(\"entry\").map(n -> new Entry(maven(), n));\n+                }\n+            }\n+\n+            public String className() {\n+                return query(\"option[@name='MAIN_CLASS_NAME']\").findFirst().get().attr(\"value\");\n+            }\n+\n+            public String[] vmArgs() {\n+                return query(\"option[@name='VM_PARAMETERS']\").findFirst().get().attr(\"value\").split(\" \");\n+            }\n+\n+            public ClassPath classPath() {\n+                return new ClassPath(maven(), query(\"classpathModifications\").findFirst().get());\n+            }\n+        }\n+\n+        public Stream<ApplicationInfo> applications() {\n+            return query(\"\/project\/component[@name='RunManager']\/configuration\").map(n -> new ApplicationInfo(maven(), n));\n+        }\n+    }\n+\n+    public record CompilerInfo(Maven maven, XMLNode xmlNode) implements Queryable {\n+        public record CompilerConfiguration(Maven maven, XMLNode xmlNode) implements Queryable {\n+            public record ExcludeFromCompile(Maven maven, XMLNode xmlNode) implements Queryable {\n+                public record File(Maven maven, XMLNode xmlNode) implements withUrl {\n+\n+                }\n+               public  Stream<File> files(){\n+                    return query(\"file\").map(n -> new File(maven, n));\n+                }\n+            }\n+           public  Stream<ExcludeFromCompile> excludeFromCompile(){\n+                return query(\"excludeFromCompile\").map(n -> new ExcludeFromCompile(maven, n));\n+            }\n+        }\n+\n+        public record JavacSettings(Maven maven, XMLNode xmlNode) implements Queryable {\n+            public record AdditionalOptionsStrings(Maven maven, XMLNode xmlNode) implements withValue, withName {\n+\n+            }\n+\n+            public record AdditionalOptionsOverride(Maven maven, XMLNode xmlNode) implements Queryable {\n+                public record Module(Maven maven, XMLNode xmlNode) implements withName, withOptions {\n+\n+                }\n+                public Stream<Module> modules() {\n+                    return query(\"module\").map(n -> new Module(maven(), n));\n+                }\n+            }\n+\n+            public Stream<AdditionalOptionsStrings> additionalOptionsStrings() {\n+                return query(\"option[@name='ADDITIONAL_OPTIONS_STRING']\").map(n -> new AdditionalOptionsStrings(maven(), n));\n+            }\n+\n+            public Stream<AdditionalOptionsOverride> additionalOptionsOverride() {\n+                return query(\"option[@name='ADDITIONAL_OPTIONS_OVERRIDE']\").map(n -> new AdditionalOptionsOverride(maven(), n));\n+            }\n+        }\n+      public  Stream<JavacSettings> javacSettings() {\n+            return query(\"component[@name='JavacSettings']\").map(n -> new JavacSettings(maven(), n));\n+        }\n+      public  Stream<CompilerConfiguration> compilerConfigurations() {\n+            return query(\"component[@name='CompilerConfiguration']\").map(n -> new CompilerConfiguration(maven(), n));\n+        }\n+    }\n+\n+\n+    public static class ImlGraph {\n+        Maven intellij;\n+        Set<Modules.Module> moduleSet = new HashSet<>();\n+        public Map<Modules.Module, List<Modules.Module>> fromToDependencies = new HashMap<>();\n+        Map<Modules.Module, List<Modules.Module>> toFromDependencies = new HashMap<>();\n+\n+        ImlGraph(Maven intellij, Modules modules) {\n+            this.intellij = intellij;\n+            Map<Path, Modules.Module> pathToModule = new HashMap<>();\n+            modules.modules().forEach(module -> {\n+                moduleSet.add(module);\n+                pathToModule.put(module.imlPath(), module);\n+            });\n+            moduleSet.forEach(module ->\n+                    module.moduleOrderEntries().forEach(moduleOrderEntry -> {\n+                                fromToDependencies.computeIfAbsent(pathToModule.get(module.imlPath()), _ -> new ArrayList<>()).add(pathToModule.get(moduleOrderEntry.imlPath));\n+                                toFromDependencies.computeIfAbsent(pathToModule.get(moduleOrderEntry.imlPath), _ -> new ArrayList<>()).add(pathToModule.get(module.imlPath()));\n+                            }\n+                    ));\n+        }\n+    }\n+\n+    \/*----*\/\n+    public record POM(Maven maven, XMLNode xmlNode) implements Queryable {\n+        public record Project(Path path,Maven maven, XMLNode xmlNode) implements Queryable {\n+            public record Module(Maven maven, XMLNode xmlNode) implements Queryable.withText {\n+            }\n+            String modelVersion(){\n+                return query(\"modelVersion\").findFirst().get().element.getTextContent();\n+            }\n+            String packaging(){\n+                return query(\"packaging\").findFirst().get().element.getTextContent();\n+            }\n+            String groupId(){\n+                return query(\"groupId\").findFirst().get().element.getTextContent();\n+            }\n+            String artifactId(){\n+                return query(\"artifactId\").findFirst().get().element.getTextContent();\n+            }\n+            String version(){\n+                return query(\"version\").findFirst().get().element.getTextContent();\n+            }\n+\n+            public Stream<Module> modules() {\n+                return query(\"modules\").map(m->new Module(maven, m));\n+            }\n+        }\n+        Stream<Project> projects(Path path) {\n+            return query(\"\/project\").map(p->new Project(path, maven, xmlNode));\n+        }\n+\n+        public record Module(Path imlPath, Maven maven, XMLNode xmlNode) implements Queryable {\n+            public record ModuleOrderEntry(Path imlPath, Maven maven, XMLNode xmlNode) implements withType {\n+            }\n+\n+            public record ModuleLibraryOrderEntry(Maven maven, XMLNode xmlNode) implements withType {\n+                public record Library(Maven maven, XMLNode xmlNode) implements Queryable {\n+                    public record Classes(Maven maven, XMLNode xmlNode) implements Queryable {\n+                        public record Root(Maven maven, XMLNode xmlNode) implements withUrl { }\n+                        public Stream<Root> roots() {\n+                            return query(\"root\").map(e -> new Root(maven, e));\n+                        }\n+                    }\n+\n+                    public Stream<Classes> listOfClasses() {\n+                        return query(\"CLASSES\").map(e -> new Classes(maven, e));\n+                    }\n+                }\n+\n+                public Stream<Library> libraries() {\n+                    return query(\"library\").map(e -> new Library(maven, e));\n+                }\n+            }\n+\n+            public record Content(Maven maven, XMLNode xmlNode) implements withUrl {\n+                public record SourceFolder(Maven maven, XMLNode xmlNode) implements withUrl, withType { }\n+\n+                public record ExcludeFolder(Maven maven, XMLNode xmlNode) implements withUrl { }\n+\n+                public Stream<SourceFolder> sourceFolders() {\n+                    return query(\"sourceFolder\").map(e -> new SourceFolder(maven, e));\n+                }\n+\n+                public Stream<ExcludeFolder> excludeFolders() {\n+                    return query(\"excludeFolder\").map(e -> new ExcludeFolder(maven, e));\n+                }\n+            }\n+\n+            public Stream<ModuleOrderEntry> moduleOrderEntries() {\n+                return query(\"\/module\/component\/orderEntry[@type='module']\")\n+                        .map(e -> new ModuleOrderEntry(imlPath.getParent().resolve(e.attr(\"module-name\") + \".iml\"), maven, e));\n+            }\n+\n+            public Stream<ModuleLibraryOrderEntry> moduleLibraryOrderEntries() {\n+                return query(\"\/module\/component\/orderEntry[@type='module-library']\").map(e -> new ModuleLibraryOrderEntry(maven, e));\n+            }\n+\n+            public Stream<Content> content() {\n+                return query(\"\/module\/component\/content\").map(e -> new Content(maven, e));\n+            }\n+        }\n+\n+        public Stream<Module> modules() {\n+            return query(\"\/project\/component[@name='ProjectModuleManager']\/modules\/module\")\n+                    .map(xmlNode -> Path.of(xmlNode.attrMap.get(\"filepath\").replace(\"$PROJECT_DIR$\", maven().rootDir.toString())))\n+                    .map(path -> new Module(path, maven, new XMLNode(path)));\n+        }\n+    }\n+\n+\n+    public static void main(String[] argArr) throws IOException, InterruptedException {\n+        Path userDir = Path.of(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\"\/*System.getProperty(\"user.dir\")*\/);\n+        Maven maven = new Maven(userDir);\n+        var root = new POM(maven,new XMLNode(userDir.resolve(\"pom.xml\")));\n+        root.projects(userDir).forEach(project -> {\n+            System.out.println(project.groupId());\n+            System.out.println(project.artifactId());\n+            System.out.println(project.packaging());\n+            System.out.println(project.version());\n+            System.out.println(project.modelVersion());\n+            project.modules().forEach(m->System.out.println(m.text()));\n+        });\n+        \/*\n+        var compilerInfo = intelliJ.compilerInfo;\n+        compilerInfo.javacSettings().forEach(javacSettings -> {\n+            javacSettings.additionalOptionsStrings().forEach(additionalOptionsStrings -> {\n+                System.out.println(\"javac (allmodules) \"+additionalOptionsStrings.value());\n+            });\n+            javacSettings.additionalOptionsOverride().forEach(additionalOptionsOverride -> {\n+                additionalOptionsOverride.modules().forEach(module -> {\n+                    System.out.println(\"javac module \"+module.name()+ \" \"+String.join(\" \", module.options()));\n+                });\n+            });\n+        });\n+        compilerInfo.compilerConfigurations().forEach(compilerConfiguration -> {\n+            compilerConfiguration.excludeFromCompile().forEach(excludeFromCompile -> {\n+                excludeFromCompile.files().forEach(compileFile -> {\n+                    System.out.println(\"excluding \"+compileFile.url());\n+                });\n+            });\n+        });\n+\n+        var workspace = intelliJ.workSpace;\n+        \/\/ System.out.println(workspace);\n+\n+        workspace.applications().forEach(\n+                a -> {\n+                    System.out.println(\"java \" + String.join(\" \", a.vmArgs()) + \" \" + a.className());\n+                    Maven.WorkspaceInfo.ApplicationInfo.ClassPath cp = a.classPath();\n+                    cp.entries().forEach(e -> {\n+                        System.out.println(intelliJ.expand(e.path()));\n+                    });\n+\n+                });\n+        intelliJ.modules.modules().forEach(module -> {\n+            System.out.println(\"module \" + module.imlPath().getFileName());\n+            module.content().forEach(content -> {\n+                System.out.println(\"       \" + content.url());\n+                content.sourceFolders().forEach(sourceFolder -> {\n+                    System.out.println(\"              \" + sourceFolder.url());\n+                });\n+                content.excludeFolders().forEach(sourceFolder -> {\n+                    System.out.println(\"              exclude \" + sourceFolder.url());\n+                });\n+            });\n+            module.moduleOrderEntries().forEach(moduleDep -> {\n+                System.out.println(\"      dep \" + moduleDep.imlPath().getFileName());\n+            });\n+            module.moduleLibraryOrderEntries().forEach(moduleDep -> {\n+                moduleDep.libraries().forEach(library -> {\n+                    library.listOfClasses().forEach(libraryClass -> {\n+                        libraryClass.roots().forEach(rootClass -> {\n+                            System.out.println(\"      dep \" + rootClass.url());\n+                        });\n+                    });\n+                });\n+            });\n+        }); *\/\n+\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Maven.java","additions":446,"deletions":0,"binary":false,"changes":446,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.Set;\n+\n+public class OpenCL extends CMakeInfo {\n+    public OpenCL(Project.Id id, Set<Dependency> buildDependencies) {\n+        super(id, \"OpenCL\", \"OPENCL_FOUND\", Set.of(\n+                \"OPENCL_FOUND\",\n+                \"OpenCL_FOUND\",\n+                \"OpenCL_INCLUDE_DIRS\",\n+                \"OpenCL_LIBRARY\",\n+                \"OpenCL_VERSION_STRING\"\n+        ), buildDependencies);\n+    }\n+    public OpenCL(Project.Id id, Dependency ...dependencies) {\n+        this(id,Set.of(dependencies));\n+    }\n+\n+    @Override\n+    public void jExtractOpts(ForkExec.Opts opts) {\n+        if (isAvailable()) {\n+            if (darwin) {\n+                opts.add(\n+                        \"--library\", \":\/System\/Library\/Frameworks\/OpenCL.framework\/OpenCL\",\n+                        \"--header-class-name\", \"opencl_h\",\n+                        fwk + \"\/OpenCL.framework\/Headers\/opencl.h\"\n+                );\n+            } else if (linux) {\n+                opts.add(\n+                        \"--library\", asString(\"OpenCL_LIBRARY\"),\n+                        \"--include-dir\",\"\\\"\/usr\/include\/linux;\/usr\/include\\\"\",\n+                        \"--header-class-name\", \"opencl_h\",\n+                        asString(\"OpenCL_INCLUDE_DIRS\") + \"\/CL\/opencl.h\"\n+                );\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/OpenCL.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+public class OpenGL extends CMakeInfo {\n+\n+   \/\/ final Path glLibrary;\n+\n+    public OpenGL(Project.Id id, Set<Dependency> buildDependencies) {\n+        super(id, \"OpenGL\", \"OPENGL_FOUND\", Set.of(\n+                \"OPENGL_GLU_FOUND\",\n+                \"OPENGL_gl_LIBRARY\",\n+                \"OPENGL_glu_LIBRARY\",\n+                \"OPENGL_INCLUDE_DIR\",\n+                \"OPENGL_LIBRARIES\",\n+                \"OPENGL_LIBRARY\"\n+\n+        ), buildDependencies);\n+    }\n+    public OpenGL(Project.Id id, Dependency ...dependencies) {\n+        this(id, Set.of(dependencies));\n+    }\n+\n+    @Override\n+    public void jExtractOpts(ForkExec.Opts opts) {\n+        if (isAvailable()) {\n+            if (darwin) {\n+                List.of(\"GLUT\", \"OpenGL\").forEach(s -> opts.add(\"--library\", \":\/System\/Library\/Frameworks\/\" + s + \".framework\/\" + s));\n+                opts.add(\"--header-class-name\", \"opengl_h\", fwk + \"\/GLUT.framework\/Headers\/GLUT.h\");\n+            } else if (linux) {\n+                asSemiSeparatedStringList(\"OPENGL_LIBRARY\").forEach(lib -> opts.add(\"--library\", \":\" + lib));\n+                opts.add(\n+                        \"--library\",\":\/usr\/lib\/x86_64-linux-gnu\/libglut.so\",\n+                        \"--include-dir\",\"\\\"\/usr\/include\/linux;\/usr\/include\\\"\",\n+                        \"--header-class-name\", \"opengl_h\", \"\/usr\/include\/GL\/glut.h\"\n+                );\n+            }\n+        }\n+    }\n+\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/OpenGL.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.Set;\n+\n+public class Opt extends DependencyImpl<Opt> implements Dependency.Optional {\n+    final boolean available;\n+\n+    public Opt(Project.Id id, boolean available, Set<Dependency> buildDependencies) {\n+        super(id, buildDependencies);\n+        this.available = available;\n+    }\n+    public Opt(Project.Id id, boolean available, Dependency ... dependencies) {\n+        super(id, Set.of(dependencies));\n+        this.available = available;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+        return available;\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Opt.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public class Project {\n+    public Dependency.Optional isAvailable(String ...nameAndArgs) {\n+        boolean isInPath = false;\n+        try {\n+\n+            var process = new ProcessBuilder().command(nameAndArgs).start();\n+            process.waitFor();\n+            isInPath = (process.exitValue() == 0);\n+        } catch (Exception e) {\n+            \/\/ We'll take that as a no then  :)\n+        }\n+        return new Opt(id(nameAndArgs[0]), isInPath, Set.of());\n+    }\n+\n+    public Path dir(String s) {\n+        return rootPath().resolve(s);\n+    }\n+\n+    enum IdType {Unknown, CMakeAndJar, Jar,CMake,CMakeInfo,JExtract,Custom}\n+\n+    public record Id(Project project, IdType type, String fullHyphenatedName, String projectRelativeHyphenatedName,\n+                     String shortHyphenatedName, String version,\n+                     Path path) {\n+        String str() {\n+            return project.name() + \" \" + fullHyphenatedName + \" \" + projectRelativeHyphenatedName + \" \" + shortHyphenatedName + \" \" + version + \" \" + (path == null ? \"null\" : path);\n+        }\n+\n+        static Id of(Project project, IdType idType, String projectRelativeHyphenatedName, String shortHyphenatedName, String version, Path path) {\n+            return new Id(project, idType,project.name() + \"-\" + projectRelativeHyphenatedName + \"-\" + version, projectRelativeHyphenatedName, shortHyphenatedName, version, path);\n+        }\n+    }\n+\n+    static Id id(Project project, String projectRelativeHyphenatedName, Path path) {\n+\n+        if (projectRelativeHyphenatedName == null || projectRelativeHyphenatedName.isEmpty()) {\n+            throw new IllegalArgumentException(\"projectRelativeHyphenatedName cannot be null or empty yet\");\n+        }\n+        var version = \"1.0\";\n+        if (!Files.isDirectory(path)) {\n+            throw new IllegalArgumentException(\"path \"+path+\" must be a directory\");\n+        }\n+        int lastIndex = projectRelativeHyphenatedName.lastIndexOf('-');\n+        String[] names;\n+        if (Pattern.matches(\"\\\\d+.\\\\d+\", projectRelativeHyphenatedName.substring(lastIndex + 1))) {\n+            version = projectRelativeHyphenatedName.substring(lastIndex + 1);\n+            names = projectRelativeHyphenatedName.substring(0, lastIndex).split(\"-\");\n+        } else {\n+            names = projectRelativeHyphenatedName.split(\"-\");\n+        }\n+        var tailNames = Arrays.copyOfRange(names, 1, names.length); \/\/ [] -> [....]\n+        var shortHyphenatedName = projectRelativeHyphenatedName;\n+        if (tailNames.length == 1) {\n+             shortHyphenatedName = tailNames[0];\n+        } else {\n+            var midNames = Arrays.copyOfRange(tailNames, 0, tailNames.length);\n+            shortHyphenatedName = String.join(\"-\", midNames);\n+        }\n+\n+        IdType idType=IdType.Custom;\n+        if (Files.isDirectory(path.resolve(\"src\/main\/java\"))){\n+            if (Files.isDirectory(path.resolve(\"src\/main\/native\")) && Files.isRegularFile(path.resolve(\"CMakeLists.txt\"))){\n+                idType=IdType.CMakeAndJar;\n+            }else{\n+                idType=IdType.Jar;\n+            }\n+        }else  if (Files.isRegularFile(path.resolve(\"CMakeLists.txt\"))){\n+            idType=IdType.CMake;\n+        }\n+\n+        return Id.of(project, idType,projectRelativeHyphenatedName, shortHyphenatedName, version, path);\n+    }\n+\n+    static Id id(Project project, String projectRelativeHyphenatedName) {\n+        var version = \"1.0\";\n+        if (projectRelativeHyphenatedName == null || projectRelativeHyphenatedName.isEmpty()) {\n+            throw new IllegalArgumentException(\"projectRelativeHyphenatedName cannot be null or empty yet\");\n+        }\n+        int lastIndex = projectRelativeHyphenatedName.lastIndexOf('-');\n+        String[] names;\n+        if (Pattern.matches(\"\\\\d+.\\\\d+\", projectRelativeHyphenatedName.substring(lastIndex + 1))) {\n+            version = projectRelativeHyphenatedName.substring(lastIndex + 1);\n+            names = projectRelativeHyphenatedName.substring(0, lastIndex).split(\"-\");\n+        } else {\n+            names = projectRelativeHyphenatedName.split(\"-\");\n+        }\n+\n+        Path realPossiblyPuralizedPath = null;\n+        if (project.rootPath().resolve(names[0]) instanceof Path path && Files.isDirectory(path)) {\n+            realPossiblyPuralizedPath = path;\n+        } else if (project.rootPath.resolve(names[0] + \"s\") instanceof Path path && Files.isDirectory(path)) {\n+            realPossiblyPuralizedPath = path;\n+        }\n+        Id id = null;\n+        if (realPossiblyPuralizedPath == null || names.length == 1) {\n+                \/* not a dir just a shortHyphenatedName or the shortHyphenatedName is a simplename (no hyphens)\n+                                           hyphenated                 shortHyphernated       path\n+                    core ->                core                       core                   <root>\/core\n+                    mac  ->                mac                        mac                    null\n+                 *\/\n+            var shortHyphenatedName = projectRelativeHyphenatedName;\n+            id = Id.of(project, IdType.Unknown,  projectRelativeHyphenatedName, shortHyphenatedName, version, realPossiblyPuralizedPath);\n+        } else {\n+                \/* we have one or more names\n+                                           hyphenated                 shortHyphernated       path\n+                    backends_ffi_opencl -> backend_ffi_opencl             ffi-opencl         <root>\/backend(s)_ffi_opencl\n+\n+                *\/\n+            var tailNames = Arrays.copyOfRange(names, 1, names.length); \/\/ [] -> [....]\n+            var expectedPath = realPossiblyPuralizedPath.resolve(String.join(\"\/\", tailNames));\n+            if (!Files.isDirectory(expectedPath)) {\n+                throw new IllegalArgumentException(\"The base path existed but sub path does not exist: \" + expectedPath);\n+            } else {\n+                if (tailNames.length == 1) {\n+                    var shortHyphenatedName = tailNames[0];\n+                    id = Id.of(project, IdType.Unknown,projectRelativeHyphenatedName, shortHyphenatedName, version, expectedPath);\n+                } else {\n+                    var midNames = Arrays.copyOfRange(tailNames, 0, tailNames.length);\n+                    var shortHyphenatedName = String.join(\"-\", midNames);\n+                    id = Id.of(project, IdType.Unknown,projectRelativeHyphenatedName, shortHyphenatedName, version, expectedPath);\n+                }\n+            }\n+        }\n+        return id;\n+    }\n+\n+    public Id id(String id) {\n+        Pattern p = Pattern.compile(\"(.*)\\\\{([a-zA-Z0-9]+)(\\\\|[a-zA-Z0-9]+)?}(.*)\");\n+\n+        \/\/ ok lets transform the id into a project relative path\n+        \/\/ for example \"backend{s}-ffi\" -> id =\"backend-ffi\"  path=\"${project}\/backends\/ffi\"\n+        if (p.matcher(id) instanceof Matcher m && m.matches() && m.groupCount() == 4) {\n+            id = m.group(1)+(m.group(3)==null?\"\":m.group(3).substring(1))+m.group(4);  \/\/ we dropped the {} and its content\n+            var pathName = m.group(1)+m.group(2)+m.group(4);\/\/ we included the {} content (dropped the actual braces)\n+            Path path =  this.rootPath.resolve(pathName.replace('-','\/'));\n+            if (Files.isDirectory(path)) {\n+                \/\/System.out.println(\"Id '\"+id+\"'->  path '\"+path+\"'\");\n+                return id(id, path);\n+            }else{\n+                throw new IllegalArgumentException(\"Id '\"+id+\"' contains a path substitution but resulting path '\"+path+\"' does not exist\");\n+            }\n+        }\n+        Path path = this.rootPath.resolve(this.rootPath.resolve(id.replace('-','\/')));\n+        if (Files.isDirectory(path)) {\n+            \/\/System.out.println(\"Id '\"+id+\"'->  path '\"+path+\"' (No substitution)\");\n+            return  id(id, this.rootPath.resolve(path.toString()));\n+        }\n+        return id(this, id);\n+    }\n+    public Id id(String id, Path path) {\n+        return id(this, id, path);\n+    }\n+\n+\n+    private final Path rootPath;\n+    private final Path buildPath;\n+    private final Path confPath;\n+\n+    private final Map<String, Dependency> artifacts = new LinkedHashMap<>();\n+\n+    public String name() {\n+        return rootPath().getFileName().toString();\n+    }\n+\n+    public Path rootPath() {\n+        return rootPath;\n+    }\n+\n+    public Path buildPath() {\n+        return buildPath;\n+    }\n+\n+    public Path confPath() {\n+        return confPath;\n+    }\n+\n+    public final Reporter reporter;\n+\n+    public Project(Path root, Reporter reporter) {\n+        this.rootPath = root;\n+        if (!Files.exists(root)) {\n+            throw new IllegalArgumentException(\"Root path for project does not exist: \" + root);\n+        }\n+        this.buildPath = root.resolve(\"build\");\n+        this.confPath = root.resolve(\"conf\");\n+        this.reporter = reporter;\n+\n+    }\n+\n+\n+    public Dependency add(Dependency dependency) {\n+        artifacts.put(dependency.id().shortHyphenatedName, dependency);\n+        return dependency;\n+    }\n+\n+    public Dependency get(String shortHyphenatedName) {\n+        return artifacts.get(shortHyphenatedName);\n+    }\n+\n+    public void rmdir(Path... paths) {\n+        for (Path path : paths) {\n+            if (Files.exists(path)) {\n+                try (var files = Files.walk(path)) {\n+                    files.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void clean(Dependency dependency, Path... paths) {\n+        for (Path path : paths) {\n+            if (Files.exists(path)) {\n+                try (var files = Files.walk(path)) {\n+                    files.sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);\n+                    reporter.command(dependency, \"rm -rf \" + path);\n+                    mkdir(path);\n+                    reporter.command(dependency, \"mkdir -p \" + path);\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void mkdir(Path... paths) {\n+        for (Path path : paths) {\n+            if (!Files.exists(path)) {\n+                try {\n+                    Files.createDirectories(path);\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Dag clean(Set<Dependency> dependencies) {\n+        boolean all = false;\n+        if (dependencies.isEmpty()) {\n+            all = true;\n+            dependencies = this.artifacts.values().stream().collect(Collectors.toSet());\n+        }\n+        Dag dag = new Dag(dependencies);\n+        dag.ordered().stream()\n+                .filter(d -> d instanceof Dependency.Buildable)\n+                .map(d -> (Dependency.Buildable) d)\n+                .forEach(Dependency.Buildable::clean);\n+        if (all) {\n+            rmdir(buildPath());\n+        }\n+        return dag;\n+    }\n+\n+    public Dag clean(String... names) {\n+        return clean(Set.of(names).stream().map(s -> this.artifacts.get(s)).collect(Collectors.toSet()));\n+    }\n+\n+    public Dag build(Dag dag) {\n+        dag.ordered().stream()\n+                .filter(d -> d instanceof Dependency.Buildable)\n+                .map(d -> (Dependency.Buildable) d)\n+                .forEach(Dependency.Buildable::build);\n+        return dag;\n+    }\n+\n+    public Dag build(Set<Dependency> dependencies) {\n+        if (dependencies.isEmpty()) {\n+            dependencies = this.artifacts.values().stream().collect(Collectors.toSet());\n+        }\n+        Dag dag = new Dag(dependencies);\n+        build(dag);\n+        return dag;\n+    }\n+\n+    public Dag build(Dependency... dependencies) {\n+        return build(Set.of(dependencies));\n+    }\n+\n+    public Dag all() {\n+        return new Dag(new HashSet<>(this.artifacts.values()));\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Project.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.function.Consumer;\n+\n+public class Reporter {\n+    public final Consumer<String> command = System.out::println;\n+    public final Consumer<String> progress = System.out::println;\n+    public final Consumer<String> error = System.out::println;\n+    public final Consumer<String> info = System.out::println;\n+    public final Consumer<String> warning = System.out::println;\n+    public final Consumer<String> note = System.out::println;\n+\n+    public void command(Dependency dependency, String command) {\n+        if (dependency != null) {\n+            this.command.accept(\"# \" + dependency.id().projectRelativeHyphenatedName() + \" command line \");\n+        }\n+        this.command.accept(command);\n+    }\n+\n+    public void progress(Dependency dependency, String command) {\n+        if (dependency != null) {\n+            progress.accept(\"# \" + dependency.id().projectRelativeHyphenatedName() + \" \" + command);\n+        }\n+    }\n+\n+    public void error(Dependency dependency, String command) {\n+        if (dependency != null) {\n+            error.accept(\"# \" + dependency.id().projectRelativeHyphenatedName() + \" error \");\n+        }\n+        error.accept(command);\n+    }\n+\n+    public void info(Dependency dependency, String command) {\n+        \/\/ if (dependency != null) {\n+        \/\/     info.accept(\"# \"+dependency.id().projectRelativeHyphenatedName+\" info \");\n+        \/\/  }\n+        info.accept(command);\n+    }\n+\n+    public void note(Dependency dependency, String command) {\n+        \/\/  if (dependency != null) {\n+        \/\/    note.accept(\"# \"+dependency.id().projectRelativeHyphenatedName+\" note \");\n+        \/\/  }\n+        note.accept(command);\n+    }\n+\n+    public void warning(Dependency dependency, String command) {\n+        \/\/   if (dependency != null) {\n+        \/\/      warning.accept(\"# \"+dependency.id().projectRelativeHyphenatedName+\" warning \");\n+        \/\/  }\n+        warning.accept(command);\n+    }\n+\n+    static Reporter verbose = new Reporter();\n+    public static Reporter commandsAndErrors = new Reporter() {\n+        @Override\n+        public void warning(Dependency dependency, String command) {\n+\n+        }\n+\n+        @Override\n+        public void info(Dependency dependency, String command) {\n+\n+        }\n+\n+        @Override\n+        public void note(Dependency dependency, String command) {\n+\n+        }\n+\n+        @Override\n+        public void progress(Dependency dependency, String command) {\n+\n+        }\n+\n+    };\n+\n+    public static Reporter progressAndErrors = new Reporter() {\n+        @Override\n+        public void warning(Dependency dependency, String command) {\n+\n+        }\n+\n+        @Override\n+        public void info(Dependency dependency, String command) {\n+\n+        }\n+\n+        @Override\n+        public void note(Dependency dependency, String command) {\n+\n+        }\n+\n+        @Override\n+        public void command(Dependency dependency, String command) {\n+\n+        }\n+\n+        public void progress(Dependency dependency, String command) {\n+            if (dependency != null) {\n+                progress.accept(dependency.id().projectRelativeHyphenatedName() + \":\" + command);\n+            }\n+        }\n+    };\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Reporter.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+\n+public class Util {\n+\n+\n+    public static boolean grep(Pattern pattern, String str){\n+        return pattern.matcher(str).matches();\n+    }\n+\n+    public static boolean grepLines(Pattern pattern, List<String> lines){\n+        var result=new boolean[]{false};\n+        lines.forEach(line->{\n+            result[0] |= grep(pattern, line);\n+        });\n+        return result[0];\n+    }\n+\n+\n+    public static boolean grepLines(List<Pattern> patterns, List<String> lines){\n+        for (var pattern:patterns){\n+            if (grepLines(pattern, lines)){\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean grepLines(Pattern pattern, Path path){\n+        try{\n+            return grepLines(pattern, Files.readAllLines(path));\n+        }catch(IOException i){\n+            return false;\n+        }\n+    }\n+\n+    public static boolean grepLines(List<Pattern> patterns, Path path){\n+        try{\n+            return grepLines(patterns, Files.readAllLines(path));\n+        }catch(IOException i){\n+            return false;\n+        }\n+    }\n+\n+    public static void recurse(Path dir, Predicate<Path> dirPredicate, Predicate<Path> filePredicate, Consumer<Path> consumer){\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {\n+            for (Path entry : stream) {\n+                if (Files.isDirectory(entry)) {\n+                    if (dirPredicate.test(entry)) {\n+                        recurse(entry, dirPredicate,filePredicate, consumer);\n+                   \/\/ }else{\n+                     \/\/   System.out.println(entry + \"failed dir predicate\" );\n+                    }\n+                }else if (filePredicate.test(entry)){\n+                    consumer.accept(entry);\n+                }\n+            }\n+        }catch(IOException ioe){\n+            throw new IllegalStateException(ioe);\n+        }\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Util.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import java.util.Set;\n+\n+public class Windows extends DependencyImpl<Linux> implements Dependency.Optional {\n+    final boolean available;\n+\n+    public Windows(Project.Id id, Set<Dependency> buildDependencies) {\n+        super(id, buildDependencies);\n+        available = System.getProperty(\"os.name\").toLowerCase().contains(\"windows\");\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+        return available;\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/Windows.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,966 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package job;\n+\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+public class XMLNode {\n+    Element element;\n+    List<XMLNode> children = new ArrayList<>();\n+    Map<String, String> attrMap = new HashMap<>();\n+\n+    public static class AbstractXMLBuilder<T extends AbstractXMLBuilder<T>> {\n+        final public Element element;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public T self() {\n+            return (T) this;\n+        }\n+\n+        public T attr(String name, String value) {\n+            element.setAttribute(name, value);\n+            return self();\n+        }\n+\n+        public T attr(URI uri, String name, String value) {\n+            element.setAttributeNS(uri.toString(), name, value);\n+            return self();\n+        }\n+\n+        public T element(String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n+            var node = element.getOwnerDocument().createElement(name);\n+            element.appendChild(node);\n+            var builder = factory.apply(node);\n+            xmlBuilderConsumer.accept(builder);\n+            return self();\n+        }\n+\n+        public T element(\n+                URI uri, String name, Function<Element, T> factory, Consumer<T> xmlBuilderConsumer) {\n+            var node = element.getOwnerDocument().createElementNS(uri.toString(), name);\n+            element.appendChild(node);\n+            var builder = factory.apply(node);\n+            xmlBuilderConsumer.accept(builder);\n+            return self();\n+        }\n+\n+        AbstractXMLBuilder(Element element) {\n+            this.element = element;\n+        }\n+\n+        public T text(String thisText) {\n+            var node = element.getOwnerDocument().createTextNode(thisText);\n+            element.appendChild(node);\n+            return self();\n+        }\n+\n+        public T comment(String thisComment) {\n+            var node = element.getOwnerDocument().createComment(thisComment);\n+            element.appendChild(node);\n+            return self();\n+        }\n+\n+        <L> T forEach(List<L> list, BiConsumer<T, L> biConsumer) {\n+            list.forEach(l -> biConsumer.accept(self(), l));\n+            return self();\n+        }\n+\n+        <L> T forEach(Stream<L> stream, BiConsumer<T, L> biConsumer) {\n+            stream.forEach(l -> biConsumer.accept(self(), l));\n+            return self();\n+        }\n+\n+        <L> T forEach(Stream<L> stream, Consumer<L> consumer) {\n+            stream.forEach(consumer);\n+            return self();\n+        }\n+\n+        protected T then(Consumer<T> xmlBuilderConsumer) {\n+            xmlBuilderConsumer.accept(self());\n+            return self();\n+        }\n+    }\n+\n+    public static class PomXmlBuilder extends AbstractXMLBuilder<PomXmlBuilder> {\n+        PomXmlBuilder(Element element) {\n+            super(element);\n+        }\n+\n+        public PomXmlBuilder element(String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+            return element(name, PomXmlBuilder::new, xmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder element(URI uri, String name, Consumer<PomXmlBuilder> xmlBuilderConsumer) {\n+            return element(uri, name, PomXmlBuilder::new, xmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder modelVersion(String s) {\n+            return element(\"modelVersion\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder pom(String groupId, String artifactId, String version) {\n+            return modelVersion(\"4.0.0\").packaging(\"pom\").ref(groupId, artifactId, version);\n+        }\n+\n+        public PomXmlBuilder jar(String groupId, String artifactId, String version) {\n+            return modelVersion(\"4.0.0\").packaging(\"jar\").ref(groupId, artifactId, version);\n+        }\n+\n+        public PomXmlBuilder groupId(String s) {\n+            return element(\"groupId\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder artifactId(String s) {\n+            return element(\"artifactId\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder packaging(String s) {\n+            return element(\"packaging\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder version(String s) {\n+            return element(\"version\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder build(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"build\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder plugins(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"plugins\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder plugin(\n+                String groupId,\n+                String artifactId,\n+                String version,\n+                Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\n+                    \"plugin\", $ -> $.ref(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n+        }\n+\n+        public PomXmlBuilder antPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return plugin(\n+                    \"org.apache.maven.plugins\",\n+                    \"maven-antrun-plugin\",\n+                    \"1.8\",\n+                    pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder surefirePlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return plugin(\n+                    \"org.apache.maven.plugins\",\n+                    \"maven-surefire-plugin\",\n+                    \"3.1.2\",\n+                    pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder compilerPlugin(\n+                Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return plugin(\n+                    \"org.apache.maven.plugins\",\n+                    \"maven-compiler-plugin\",\n+                    \"3.11.0\", pomXmlBuilderConsumer\n+            );\n+        }\n+\n+        public PomXmlBuilder execPlugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return plugin(\"org.codehaus.mojo\", \"exec-maven-plugin\", \"3.1.0\", pomXmlBuilderConsumer);\n+        }\n+\n+\n+        public PomXmlBuilder plugin(\n+                String groupId, String artifactId, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n+        }\n+\n+        public PomXmlBuilder plugin(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"plugin\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder parent(String groupId, String artifactId, String version) {\n+            return parent(parent -> parent.ref(groupId, artifactId, version));\n+        }\n+\n+        public PomXmlBuilder parent(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"parent\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder pluginManagement(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"pluginManagement\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder file(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"file\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder activation(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"activation\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder profiles(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"profiles\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder profile(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"profile\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder arguments(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"arguments\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder executions(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"executions\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder execution(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"execution\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder execIdPhaseConf(\n+                String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return execution(execution -> execution.id(id).phase(phase).goals(gs -> gs.goal(\"exec\")).configuration(pomXmlBuilderConsumer));\n+        }\n+\n+        public PomXmlBuilder exec(\n+                String phase, String executable, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return execIdPhaseConf(\n+                    executable + \"-\" + phase,\n+                    phase,\n+                    conf -> conf.executable(executable).arguments(pomXmlBuilderConsumer));\n+        }\n+\n+        public PomXmlBuilder cmake(\n+                String id, String phase, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return execIdPhaseConf(\n+                    id, phase, conf -> conf.executable(\"cmake\").arguments(pomXmlBuilderConsumer));\n+        }\n+\n+        public PomXmlBuilder cmake(String id, String phase, String... args) {\n+            return execIdPhaseConf(\n+                    id,\n+                    phase,\n+                    conf ->\n+                            conf.executable(\"cmake\")\n+                                    .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n+        }\n+\n+        public PomXmlBuilder jextract(String id, String phase, String... args) {\n+            return execIdPhaseConf(\n+                    id,\n+                    phase,\n+                    conf ->\n+                            conf.executable(\"jextract\")\n+                                    .arguments(arguments -> arguments.forEach(Stream.of(args), arguments::argument)));\n+        }\n+\n+        public PomXmlBuilder ant(\n+                String id, String phase, String goal, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return execution(execution -> execution\n+                    .id(id)\n+                    .phase(phase)\n+                    .goals(gs -> gs.goal(goal))\n+                    .configuration(configuration -> configuration.target(pomXmlBuilderConsumer)));\n+        }\n+\n+        public PomXmlBuilder goals(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"goals\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder target(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"target\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder configuration(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"configuration\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder compilerArgs(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"compilerArgs\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder compilerArgs(String... args) {\n+            return element(\"compilerArgs\", $ -> $.forEach(Stream.of(args), $::arg));\n+        }\n+\n+        public PomXmlBuilder properties(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"properties\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder dependencies(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"dependencies\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder dependsOn(String groupId, String artifactId, String version) {\n+            return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version));\n+        }\n+\n+        public PomXmlBuilder dependsOn(String groupId, String artifactId, String version, String phase) {\n+            return element(\"dependencies\", $ -> $.dependency(groupId, artifactId, version, phase));\n+        }\n+\n+        public PomXmlBuilder dependency(String groupId, String artifactId, String version) {\n+            return dependency($ -> $.ref(groupId, artifactId, version));\n+        }\n+\n+        public PomXmlBuilder dependency(\n+                String groupId, String artifactId, String version, String scope) {\n+            return dependency($ -> $.ref(groupId, artifactId, version).scope(scope));\n+        }\n+\n+        public PomXmlBuilder dependency(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"dependency\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder modules(Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"modules\", pomXmlBuilderConsumer);\n+        }\n+\n+        public PomXmlBuilder modules(List<String> modules) {\n+            return element(\"modules\", $ -> $.forEach(modules.stream(), $::module));\n+        }\n+\n+        public PomXmlBuilder modules(String... modules) {\n+            return modules(List.of(modules));\n+        }\n+\n+        public PomXmlBuilder module(String name) {\n+            return element(\"module\", $ -> $.text(name));\n+        }\n+\n+        public PomXmlBuilder property(String name, String value) {\n+            return element(name, $ -> $.text(value));\n+        }\n+\n+        public PomXmlBuilder antproperty(String name, String value) {\n+            return element(\"property\", $ -> $.attr(\"name\", name).attr(\"value\", value));\n+        }\n+\n+        public PomXmlBuilder scope(String s) {\n+            return element(\"scope\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder phase(String s) {\n+            return element(\"phase\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder argument(String s) {\n+            return element(\"argument\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder goal(String s) {\n+            return element(\"goal\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder copy(String file, String toDir) {\n+            return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n+        }\n+\n+        public PomXmlBuilder antjar(String basedir, String include, String destfile) {\n+            return element(\"jar\", $ -> $.attr(\"basedir\", basedir).attr(\"includes\", include + \"\/**\").attr(\"destfile\", destfile));\n+        }\n+\n+        public PomXmlBuilder echo(String message) {\n+            return element(\"echo\", $ -> $.attr(\"message\", message));\n+        }\n+\n+        public PomXmlBuilder echo(String filename, String message) {\n+            return element(\"echo\", $ -> $.attr(\"message\", message).attr(\"file\", filename));\n+        }\n+\n+        public PomXmlBuilder mkdir(String dirName) {\n+            return element(\"mkdir\", $ -> $.attr(\"dir\", dirName));\n+        }\n+\n+        public PomXmlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+            return groupId(groupId).artifactId(artifactId);\n+        }\n+\n+        public PomXmlBuilder ref(String groupId, String artifactId, String version) {\n+            return groupIdArtifactId(groupId, artifactId).version(version);\n+        }\n+\n+        public PomXmlBuilder skip(String string) {\n+            return element(\"skip\", $ -> $.text(string));\n+        }\n+\n+        public PomXmlBuilder id(String s) {\n+            return element(\"id\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder arg(String s) {\n+            return element(\"arg\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder argLine(String s) {\n+            return element(\"argLine\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder source(String s) {\n+            return element(\"source\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder target(String s) {\n+            return element(\"target\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder showWarnings(String s) {\n+            return element(\"showWarnings\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder showDeprecation(String s) {\n+            return element(\"showDeprecation\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder failOnError(String s) {\n+            return element(\"failOnError\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder exists(String s) {\n+            return element(\"exists\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder activeByDefault(String s) {\n+            return element(\"activeByDefault\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder executable(String s) {\n+            return element(\"executable\", $ -> $.text(s));\n+        }\n+\n+        public PomXmlBuilder workingDirectory(String s) {\n+            return element(\"workingDirectory\", $ -> $.text(s));\n+        }\n+    }\n+\n+    public static class ImlBuilder extends AbstractXMLBuilder<ImlBuilder> {\n+\n+        ImlBuilder(Element element) {\n+            super(element);\n+        }\n+\n+        public ImlBuilder element(String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n+            return element(name, ImlBuilder::new, xmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder element(URI uri, String name, Consumer<ImlBuilder> xmlBuilderConsumer) {\n+            return element(uri, name, ImlBuilder::new, xmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder modelVersion(String s) {\n+            return element(\"modelVersion\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder groupId(String s) {\n+            return element(\"groupId\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder artifactId(String s) {\n+            return element(\"artifactId\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder packaging(String s) {\n+            return element(\"packaging\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder version(String s) {\n+            return element(\"version\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder build(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"build\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder plugins(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"plugins\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder plugin(\n+                String groupId,\n+                String artifactId,\n+                String version,\n+                Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\n+                    \"plugin\",\n+                    $ ->\n+                            $.groupIdArtifactIdVersion(groupId, artifactId, version).then(pomXmlBuilderConsumer));\n+        }\n+\n+        public ImlBuilder plugin(\n+                String groupId, String artifactId, Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\n+                    \"plugin\", $ -> $.groupIdArtifactId(groupId, artifactId).then(pomXmlBuilderConsumer));\n+        }\n+\n+        public ImlBuilder plugin(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"plugin\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder parent(String groupId, String artifactId, String version) {\n+            return parent(parent -> parent.groupIdArtifactIdVersion(groupId, artifactId, version));\n+        }\n+\n+        public ImlBuilder parent(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"parent\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder pluginManagement(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"pluginManagement\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder file(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"file\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder activation(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"activation\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder profiles(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"profiles\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder profile(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"profile\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder arguments(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"arguments\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder executions(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"executions\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder execution(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"execution\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder goals(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"goals\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder target(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"target\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder configuration(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"configuration\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder compilerArgs(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"compilerArgs\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder properties(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"properties\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder dependencies(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"dependencies\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder dependency(String groupId, String artifactId, String version) {\n+            return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version));\n+        }\n+\n+        public ImlBuilder dependency(String groupId, String artifactId, String version, String scope) {\n+            return dependency($ -> $.groupIdArtifactIdVersion(groupId, artifactId, version).scope(scope));\n+        }\n+\n+        public ImlBuilder dependency(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"dependency\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder modules(Consumer<ImlBuilder> pomXmlBuilderConsumer) {\n+            return element(\"modules\", pomXmlBuilderConsumer);\n+        }\n+\n+        public ImlBuilder module(String name) {\n+            return element(\"module\", $ -> $.text(name));\n+        }\n+\n+        public ImlBuilder property(String name, String value) {\n+            return element(name, $ -> $.text(value));\n+        }\n+\n+        public ImlBuilder scope(String s) {\n+            return element(\"scope\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder phase(String s) {\n+            return element(\"phase\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder argument(String s) {\n+            return element(\"argument\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder goal(String s) {\n+            return element(\"goal\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder copy(String file, String toDir) {\n+            return element(\"copy\", $ -> $.attr(\"file\", file).attr(\"toDir\", toDir));\n+        }\n+\n+        public ImlBuilder groupIdArtifactId(String groupId, String artifactId) {\n+            return groupId(groupId).artifactId(artifactId);\n+        }\n+\n+        public ImlBuilder groupIdArtifactIdVersion(String groupId, String artifactId, String version) {\n+            return groupIdArtifactId(groupId, artifactId).version(version);\n+        }\n+\n+        public ImlBuilder skip(String string) {\n+            return element(\"skip\", $ -> $.text(string));\n+        }\n+\n+        public ImlBuilder id(String s) {\n+            return element(\"id\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder arg(String s) {\n+            return element(\"arg\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder argLine(String s) {\n+            return element(\"argLine\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder source(String s) {\n+            return element(\"source\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder target(String s) {\n+            return element(\"target\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder showWarnings(String s) {\n+            return element(\"showWarnings\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder showDeprecation(String s) {\n+            return element(\"showDeprecation\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder failOnError(String s) {\n+            return element(\"failOnError\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder exists(String s) {\n+            return element(\"exists\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder activeByDefault(String s) {\n+            return element(\"activeByDefault\", $ -> $.text(s));\n+        }\n+\n+        public ImlBuilder executable(String s) {\n+            return element(\"executable\", $ -> $.text(s));\n+        }\n+    }\n+\n+    public static class XMLBuilder extends AbstractXMLBuilder<XMLBuilder> {\n+        XMLBuilder(Element element) {\n+            super(element);\n+        }\n+\n+        public XMLBuilder element(String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+            return element(name, XMLBuilder::new, xmlBuilderConsumer);\n+        }\n+\n+        public XMLBuilder element(URI uri, String name, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+            return element(uri, name, XMLBuilder::new, xmlBuilderConsumer);\n+        }\n+    }\n+\n+    static XMLNode create(String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+\n+        try {\n+            var doc =\n+                    DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+            var element = doc.createElement(nodeName);\n+            doc.appendChild(element);\n+            XMLBuilder xmlBuilder = new XMLBuilder(element);\n+            xmlBuilderConsumer.accept(xmlBuilder);\n+            return new XMLNode(element);\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static XMLNode createIml(String commentText, Consumer<ImlBuilder> imlBuilderConsumer) {\n+        try {\n+            var doc =\n+                    DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+            var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+            var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+            var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+            var comment = doc.createComment(commentText);\n+            doc.appendChild(comment);\n+            var element = doc.createElementNS(uri1.toString(), \"project\");\n+            doc.appendChild(element);\n+            element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n+            ImlBuilder imlBuilder = new ImlBuilder(element);\n+            imlBuilderConsumer.accept(imlBuilder);\n+            return new XMLNode(element);\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static XMLNode createPom(\n+            String commentText, Consumer<PomXmlBuilder> pomXmlBuilderConsumer) {\n+        try {\n+            var doc =\n+                    DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+\n+            var uri1 = URI.create(\"http:\/\/maven.apache.org\/POM\/4.0.0\");\n+            var uri2 = URI.create(\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\");\n+            var uri3 = URI.create(\"http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\");\n+            var comment = doc.createComment(commentText);\n+            doc.appendChild(comment);\n+            var element = doc.createElementNS(uri1.toString(), \"project\");\n+            doc.appendChild(element);\n+            element.setAttributeNS(uri2.toString(), \"xsi:schemaLocation\", uri1 + \" \" + uri3);\n+            PomXmlBuilder pomXmlBuilder = new PomXmlBuilder(element);\n+            pomXmlBuilderConsumer.accept(pomXmlBuilder);\n+            return new XMLNode(element);\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static XMLNode create(URI uri, String nodeName, Consumer<XMLBuilder> xmlBuilderConsumer) {\n+        try {\n+            var doc =\n+                    DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n+            var element = doc.createElementNS(uri.toString(), nodeName);\n+            doc.appendChild(element);\n+            XMLBuilder xmlBuilder = new XMLBuilder(element);\n+            xmlBuilderConsumer.accept(xmlBuilder);\n+            return new XMLNode(element);\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    XMLNode(Element element) {\n+        this.element = element;\n+        this.element.normalize();\n+        NodeList nodeList = element.getChildNodes();\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            if (nodeList.item(i) instanceof Element e) {\n+                this.children.add(new XMLNode(e));\n+            }\n+        }\n+        for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+            if (element.getAttributes().item(i) instanceof Attr attr) {\n+                this.attrMap.put(attr.getName(), attr.getValue());\n+            }\n+        }\n+    }\n+\n+    public boolean hasAttr(String name) {\n+        return attrMap.containsKey(name);\n+    }\n+\n+    public String attr(String name) {\n+        return attrMap.get(name);\n+    }\n+\n+    static Document parse(InputStream is) {\n+        try {\n+            return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(is);\n+        } catch (ParserConfigurationException | SAXException | IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Document parse(Path path) {\n+        try {\n+            return parse(Files.newInputStream(path));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    XMLNode(Path path) {\n+        this(parse(path).getDocumentElement());\n+    }\n+\n+    XMLNode(File file) {\n+        this(parse(file.toPath()).getDocumentElement());\n+    }\n+\n+    XMLNode(URL url) throws Throwable {\n+        this(parse(url.openStream()).getDocumentElement());\n+    }\n+\n+    void write(StreamResult streamResult) throws Throwable {\n+        var transformer = TransformerFactory.newInstance().newTransformer();\n+        transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+        transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n+        transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+        transformer.transform(new DOMSource(element.getOwnerDocument()), streamResult);\n+    }\n+\n+    void write(File file) {\n+        try {\n+            write(new StreamResult(file));\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    public void write(Path xmlFile) {\n+        try {\n+            write(new StreamResult(xmlFile.toFile()));\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        var stringWriter = new StringWriter();\n+        try {\n+            var transformer = TransformerFactory.newInstance().newTransformer();\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+            transformer.transform(new DOMSource(element), new StreamResult(stringWriter));\n+            return stringWriter.toString();\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    XPathExpression xpath(String expression) {\n+        XPath xpath = XPathFactory.newInstance().newXPath();\n+        try {\n+            return xpath.compile(expression);\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    Node node(XPathExpression xPathExpression) {\n+        try {\n+            return (Node) xPathExpression.evaluate(this.element, XPathConstants.NODE);\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    Optional<Node> optionalNode(XPathExpression xPathExpression) {\n+        var nodes = nodes(xPathExpression).toList();\n+        return switch (nodes.size()) {\n+            case 0 -> Optional.empty();\n+            case 1 -> Optional.of(nodes.getFirst());\n+            default -> throw new IllegalStateException(\"Expected 0 or 1 but got more\");\n+        };\n+    }\n+\n+    String str(XPathExpression xPathExpression) {\n+        try {\n+            return (String) xPathExpression.evaluate(this.element, XPathConstants.STRING);\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    String xpathQueryString(String xpathString) {\n+        try {\n+            return (String) xpath(xpathString).evaluate(this.element, XPathConstants.STRING);\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    NodeList nodeList(XPathExpression xPathExpression) {\n+        try {\n+            return (NodeList) xPathExpression.evaluate(this.element, XPathConstants.NODESET);\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    Stream<Node> nodes(XPathExpression xPathExpression) {\n+        var nodeList = nodeList(xPathExpression);\n+        List<Node> nodes = new ArrayList<>();\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            nodes.add(nodeList.item(i));\n+        }\n+        return nodes.stream();\n+    }\n+\n+    Stream<Element> elements(XPathExpression xPathExpression) {\n+        return nodes(xPathExpression)\n+                .filter(n -> n instanceof Element)\n+                .map(n -> (Element) n);\n+    }\n+\n+    Stream<XMLNode> xmlNodes(XPathExpression xPathExpression) {\n+        return elements(xPathExpression).map(e -> new XMLNode(e));\n+    }\n+}\n","filename":"hat\/hat\/job\/src\/main\/java\/job\/XMLNode.java","additions":966,"deletions":0,"binary":false,"changes":966,"status":"added"},{"patch":"@@ -15,1 +15,0 @@\n-      <module fileurl=\"file:\/\/$PROJECT_DIR$\/example_arrayview.iml\" filepath=\"$PROJECT_DIR$\/example_arrayview.iml\" \/>\n@@ -28,0 +27,1 @@\n+      <module fileurl=\"file:\/\/$PROJECT_DIR$\/job.iml\" filepath=\"$PROJECT_DIR$\/job.iml\" \/>\n","filename":"hat\/intellij\/.idea\/modules.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,13 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<module type=\"JAVA_MODULE\" version=\"4\">\n-  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n-    <exclude-output \/>\n-    <content url=\"file:\/\/$MODULE_DIR$\/..\/examples\/arrayview\">\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/examples\/arrayview\/src\/main\/java\" isTestSource=\"false\" \/>\n-      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/examples\/arrayview\/src\/main\/resources\" type=\"java-resource\" \/>\n-    <\/content>\n-    <orderEntry type=\"inheritedJdk\" \/>\n-    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n-    <orderEntry type=\"module\" module-name=\"core\" \/>\n-  <\/component>\n-<\/module>\n","filename":"hat\/intellij\/example_arrayview.iml","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -0,0 +1,11 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<module type=\"JAVA_MODULE\" version=\"4\">\n+  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n+    <exclude-output \/>\n+    <content url=\"file:\/\/$MODULE_DIR$\/..\/hat\/job\/\">\n+      <sourceFolder url=\"file:\/\/$MODULE_DIR$\/..\/hat\/job\/src\/main\/java\" isTestSource=\"false\" \/>\n+    <\/content>\n+    <orderEntry type=\"inheritedJdk\" \/>\n+    <orderEntry type=\"sourceFolder\" forTests=\"false\" \/>\n+  <\/component>\n+<\/module>\n","filename":"hat\/intellij\/job.iml","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"}]}