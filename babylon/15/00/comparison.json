{"files":[{"patch":"@@ -387,2 +387,2 @@\n-         * Any non-entry blocks with no operations and are not referred to as successors of other blocks\n-         * are removed.\n+         * <p>\n+         * Any unreferenced empty blocks are removed. An unreferenced block is a non-entry block with no predecessors.\n@@ -394,0 +394,1 @@\n+         * @throws IllegalStateException if a block has no terminal operation, unless unreferenced and empty\n@@ -416,1 +417,0 @@\n-                boolean empty = block.ops.isEmpty();\n@@ -419,5 +419,5 @@\n-                \/\/ All blocks should have a terminating operation as the last operation\n-                if (!empty && !(block.ops.getLast() instanceof Op.Terminating)) {\n-                    \/\/ @@@ exception\n-                    throw new IllegalStateException(\"Block has no terminating operation as the last operation\");\n-                }\n+                \/\/ All referenced blocks should have a terminating operation as the last operation\n+                if (block.ops.isEmpty()) {\n+                    if (block.isEntryBlock() || !block.predecessors.isEmpty()) {\n+                        throw noTerminatingOperation();\n+                    }\n@@ -425,6 +425,2 @@\n-                \/\/ Remove any non-entry blocks with no operations and no predecessors\n-                \/\/ @@@ Remove non-empty blocks with no predecessors?\n-                \/\/     Retaining such blocks may be useful for debugging, or perhaps it's intentional?\n-                if (empty &&\n-                        !block.isEntryBlock() &&\n-                        block.predecessors.isEmpty()) {\n+                    \/\/ Remove unreferenced empty block\n+                    assert !block.isEntryBlock() && block.predecessors.isEmpty();\n@@ -432,0 +428,2 @@\n+                } else if (!(block.ops.getLast() instanceof Op.Terminating)) {\n+                    throw noTerminatingOperation();\n@@ -441,0 +439,4 @@\n+        static IllegalStateException noTerminatingOperation() {\n+            return new IllegalStateException(\"Block has no terminating operation as the last operation\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/Body.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.reflect.code.op.CoreOps;\n@@ -147,1 +146,1 @@\n-        var f = CoreOps.func(\"f\", body);\n+        var f = func(\"f\", body);\n@@ -174,1 +173,1 @@\n-        var f = CoreOps.func(\"f\", body);\n+        var f = func(\"f\", body);\n@@ -219,1 +218,1 @@\n-        CoreOps.func(\"f\", body);\n+        func(\"f\", body);\n@@ -222,1 +221,1 @@\n-        Assert.assertThrows(IllegalStateException.class, () -> CoreOps.func(\"f\", body));\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n@@ -230,1 +229,1 @@\n-        CoreOps.func(\"f\", body);\n+        func(\"f\", body);\n@@ -245,1 +244,1 @@\n-        Assert.assertThrows(IllegalStateException.class, () -> CoreOps.func(\"f\", body));\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n@@ -281,1 +280,1 @@\n-        Assert.assertThrows(IllegalStateException.class, () -> CoreOps.func(\"f\", body));\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n@@ -285,1 +284,1 @@\n-    public void testEmptyBlocksElided() {\n+    public void testUnreferencedBlocksRemoved() {\n@@ -298,0 +297,44 @@\n+\n+    @Test\n+    public void testEmptyEntryBlock() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testNonEmptyEntryBlockNoTerminatingOp() {\n+        var body = Body.Builder.of(null, VOID);\n+        var block = body.entryBlock();\n+        \/\/ No terminating op\n+        block.op(constant(INT, 0));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testEmptyBlockWithPredecessor() {\n+        var body = Body.Builder.of(null, VOID);\n+        var entryBlock = body.entryBlock();\n+        \/\/ Create empty block\n+        var block = entryBlock.block();\n+        \/\/ Branch to empty block\n+        entryBlock.op(branch(block.successor()));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n+\n+    @Test\n+    public void testNonEmptyBlockNoTerminatingOp() {\n+        var body = Body.Builder.of(null, VOID);\n+        var entryBlock = body.entryBlock();\n+        \/\/ Create empty block\n+        var block = entryBlock.block();\n+        \/\/ Branch to empty block\n+        entryBlock.op(branch(block.successor()));\n+        \/\/ No terminating op\n+        block.op(constant(INT, 0));\n+\n+        Assert.assertThrows(IllegalStateException.class, () -> func(\"f\", body));\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestBuild.java","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"}]}