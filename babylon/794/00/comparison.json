{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -32,0 +33,2 @@\n+    @Reflect default void schema(){array(width()*height());};\n+    Schema<F32Array2D> schema = Schema.of(F32Array2D.class);\n@@ -49,3 +52,0 @@\n-    Schema<F32Array2D> schema = Schema.of(F32Array2D.class, s32Array->s32Array\n-            .arrayLen(\"width\",\"height\").stride(1).array(\"array\"));\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32Array2D.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.Reflect;\n@@ -40,0 +41,6 @@\n+    long PAD_SIZE = 12;\n+    default int pad(int pad){return pad;}\n+   \/\/ Ideally ? @Reflect default void  schema(){pad(12);array(length()+pad(12));}\n+    \/\/Schema<F32ArrayPadded> schema = Schema.of(F32ArrayPadded.class);\n+    Schema<F32ArrayPadded> schema = Schema.of(F32ArrayPadded.class, $ -> $\n+            .arrayLen(\"length\").pad(PAD_SIZE).array(\"array\"));\n@@ -43,2 +50,0 @@\n-    long PAD_SIZE = 12;\n-    long ARRAY_OFFSET = JAVA_INT.byteSize()+PAD_SIZE;\n@@ -46,2 +51,1 @@\n-    Schema<F32ArrayPadded> schema = Schema.of(F32ArrayPadded.class, $ -> $\n-            .arrayLen(\"length\").pad(PAD_SIZE).array(\"array\"));\n+    long ARRAY_OFFSET = JAVA_INT.byteSize()+PAD_SIZE;\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/F32ArrayPadded.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    @Reflect default void schema(){array(width()*height());};\n+    Schema<S32Array2D> schema = Schema.of(S32Array2D.class);\n@@ -54,3 +56,0 @@\n-    Schema<S32Array2D> schema = Schema.of(S32Array2D.class, s32Array->s32Array\n-            .arrayLen(\"width\",\"height\").array(\"array\"));\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/buffer\/S32Array2D.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.Accelerator;\n+import hat.backend.Backend;\n+import jdk.incubator.code.Reflect;\n+import optkl.ifacemapper.BoundSchema;\n+import optkl.ifacemapper.Buffer;\n+import optkl.ifacemapper.MappableIface;\n+import optkl.ifacemapper.Schema;\n+import optkl.util.carriers.CommonCarrier;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.invoke.MethodHandles;\n+\n+public class S32Array2DNewSchemaTest implements Buffer {\n+    public interface S32Arr2D extends Buffer {\n+         @Reflect default void schema(){array(width()*height());};\n+         Schema<S32Arr2D> schema = Schema.of(S32Arr2D.class);\n+        \/\/ Schema<S32Arr2D> oldSchema = Schema.of(S32Arr2D.class, s32Array -> s32Array.arrayLen(\"width\", \"height\").array(\"array\"));\n+        int width();\n+        int height();\n+        int array(long idx);\n+        void array(long idx, int i);\n+        static S32Arr2D create(CommonCarrier cc, int width, int height) {\n+            return schema.allocate(cc, width, height);\n+        }\n+    }\n+    public static void main(String[] args) {\n+        var lookup = MethodHandles.lookup();\n+        Accelerator accelerator = new Accelerator(lookup, Backend.FIRST);\n+\n+        S32Arr2D s32Arr2D  = S32Arr2D.create(accelerator, 100,200);\n+        GroupLayout groupLayout = (GroupLayout) MappableIface.getLayout(s32Arr2D);\n+        System.out.println(\"Layout from buffer \"+groupLayout);\n+\n+        if ( MappableIface.getBoundSchema(s32Arr2D)\n+                .rootBoundSchemaNode()\n+                .getName(\"array\") instanceof BoundSchema.ArrayFieldLayout arrayFieldLayout){\n+            arrayFieldLayout.elementOffset(0);\n+            arrayFieldLayout.elementLayout(0);\n+            if (arrayFieldLayout instanceof BoundSchema.BoundArrayFieldLayout boundArrayFieldLayout){\n+                boundArrayFieldLayout.dimFields.forEach(dimLayout->{\n+                    System.out.println(dimLayout.field.name + \" offset=@\"+dimLayout.offset());\n+                });\n+            }\n+        }\n+        System.out.println(\"-----\");\n+        S32Arr2D.schema.toText(System.out::print);\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32Array2DNewSchemaTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.Set;\n@@ -141,0 +140,42 @@\n+        record Receiver(JavaOp.InvokeOp array, List<JavaOp.InvokeOp> args){\n+            public String arrayName() {\n+                return array.invokeDescriptor().name();\n+            }\n+\n+        }\n+\n+        \/\/recurses\n+        private static Receiver consumedInvoke(JavaOp.InvokeOp firstArg, Op.Result result){\/\/ we have a call which is possibly being passed to another method  \" array(length)\"\n+            if (result.op() instanceof JavaOp.InvokeOp invokeOp){\n+                return new Receiver(invokeOp, List.of(firstArg));\n+            }else if (result.op() instanceof JavaOp.ConvOp convOp) {\n+                return ( consumedInvoke(firstArg, convOp.result().uses().iterator().next()));\n+            }else if (result.op() instanceof JavaOp.MulOp mul) {\n+                \/\/So this works for single mul say array(width()*height);\n+                var maybeInvoke = mul.result().uses().iterator().next();\n+                var invoke = (JavaOp.InvokeOp)(maybeInvoke.op() instanceof JavaOp.ConvOp invokeOp?maybeInvoke.uses().iterator().next().op():maybeInvoke.op());\n+                var lhs = (JavaOp.InvokeOp)(((Op.Result)mul.operands().get(0)).op());\n+                var rhs = (JavaOp.InvokeOp)(((Op.Result)mul.operands().get(1)).op());\n+                var list = List.of(lhs,rhs );\n+                return new Receiver(invoke, list);\n+            }else{\n+                return null;\n+            }\n+        }\n+        \/*\n+        Consider this strawman iface\n+        public interface S32Array2D extends Buffer {\n+          @Reflect default void schema(){array(width()*height());};\n+          Schema<S32Array2D> schema = Schema.of(S32Array2D.class);\n+          int width();\n+          int height();\n+          int array(long idx);\n+          void array(long idx, int i);\n+         }\n+\n+         We are trying to replicate the manual\n+\n+         Schema<S32Array2D> schema = Schema.of(S32Array2D.class, s32Array->s32Array\n+              .arrayLen(\"width\",\"height\").array(\"array\"));\n+         *\/\n+\n@@ -143,0 +184,1 @@\n+            \/\/ Just collect the unique names of all declared methods. In our straw man case we expect (\"width\",\"height\",\"array\" ..... a bunch of others )\n@@ -144,0 +186,1 @@\n+            \/\/ We need to track ones we have handled\n@@ -152,1 +195,1 @@\n-                                System.out.println(\"Hmm\");\n+                               \/\/System.out.println(\"This could get recursive very quickly\");\n@@ -160,1 +203,1 @@\n-                                    System.out.println(\"...pad(\"+padLength+\")\");\n+                                   \/\/ System.out.println(\"...pad(\"+padLength+\")\");\n@@ -172,11 +215,13 @@\n-                                    if (uses.stream().findFirst().get() instanceof Op.Result result) {\/\/ is might it a constant like we have only one, so probably a constant like length\n-                                        var possibleConsumedInvoke = result.op(); \/\/ we have a call which is possibly being passed to another method  \" array(length)\"\n-                                        var consumedInvoke = (possibleConsumedInvoke instanceof JavaOp.ConvOp convOp\n-                                                && convOp.result().uses() instanceof Set<Op.Result> usesofConvOp\n-                                                && usesofConvOp.stream().findFirst().get().op() instanceof JavaOp.InvokeOp iop)\n-                                                ? iop : (JavaOp.InvokeOp) possibleConsumedInvoke;\n-                                        if (declared.contains(consumedInvoke.invokeDescriptor().name())) {\n-                                            \/\/System.out.println(\"...\"+consumedInvoke.invokeDescriptor().name()  + \"(\"+name+\")\");\n-                                            schemaBuilder.arrayLen(name).array(consumedInvoke.invokeDescriptor().name());\n-                                            handled.add(name);\n-                                            handled.add(consumedInvoke.invokeDescriptor().name());\n+                                    \/\/ assuming   @Reflect default void schema(){array(width()*height());};\n+                                    \/\/ The nature of the model is that we will find  methods 'width' and 'height' first and which are used to bind the dimensions of 'array'\n+                                    \/\/ So given that invokeOp -> width() and name == \"width\" we are interested in finding a method that consumes this (in our case  array(width()....))\n+                                    if (uses.iterator().next() instanceof Op.Result result) {\/\/ is might it a constant like we have only one, so probably a constant like length\n+                                        \/\/ we have a call which is possibly being passed to another method say we have width and we want to find invokeOp -> \"array(width())\"\n+                                        if (consumedInvoke(invokeOp, result) instanceof Receiver  receiver\n+                                              && receiver.args.stream().map(i->i.invokeDescriptor().name()).filter(declared::contains).toList() instanceof List<String> containedConsumers\n+                                               && receiver.args.size() == containedConsumers.size()){\n+                                            \/\/ in our case we expect Reciever (array,[width, height])\n+                                            schemaBuilder.arrayLen(containedConsumers).array(receiver.arrayName());\n+                                            handled.add(receiver.arrayName());\n+                                            containedConsumers.forEach(c->handled.add(c));\n+                                            \/\/handled.add(consumerMethodName);\n@@ -189,0 +234,2 @@\n+                                }else {\n+                                    throw new IllegalStateException(\"Schema order seems to use \"+name+\" in more than one binding!?\");\n@@ -191,1 +238,1 @@\n-                                \/\/System.out.println(\"skipping \"+name);\n+                               \/\/ System.out.println(\"skipping \"+name);\n@@ -198,1 +245,0 @@\n-    \/*\n@@ -200,39 +246,0 @@\n-    record SchemaFromAnnotatedFields<T extends Buffer>(Class<T> iface, Field field) implements SchemaConstructor<T> {\n-        static <T extends Buffer> SchemaFromAnnotatedFields<T> of(Class<T> iface) {\n-            try {\n-                Field schemaField = iface.getDeclaredField(\"schema\");\n-                if (!Modifier.isStatic(schemaField.getModifiers())) {\n-                    throw new RuntimeException(\"no static field called schema\");\n-                }\n-                return new SchemaFromAnnotatedFields<>(iface, schemaField);\n-            } catch (NoSuchFieldException nsme) {\n-                \/\/ throw new RuntimeException(nsme);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Schema<T> create() {\n-            String[] order = (field().getAnnotation(Order.class) instanceof Order orderAnnotation) ? orderAnnotation.value() : null;\n-            Set<String> handled = new HashSet<>();\n-            return Schema.of(iface, (schemaBuilder) -> {\n-                Arrays.stream(iface.getDeclaredMethods()).filter(m -> Modifier.isAbstract(m.getModifiers())).forEach(m -> {\n-                    if (m.getAnnotation(ProvidesDimFor.class) instanceof ProvidesDimFor providesDimFor) {\n-                        schemaBuilder.arrayLen(m.getName()).array(providesDimFor.value());\n-                        if (!handled.contains(m.getName())) {\n-                            handled.add(m.getName());\n-                        }\n-                        handled.add(providesDimFor.value());\n-                    } else if (order == null && !handled.contains(m.getName())) {\n-                        System.out.println(m.getName());\n-                        schemaBuilder.fields(m.getName());\n-                        handled.add(m.getName());\n-                    }\n-                });\n-                if (order != null) {\n-                    schemaBuilder.fields(order);\n-                }\n-            });\n-        }\n-    }\n-*\/\n@@ -242,2 +249,0 @@\n-     \/*   } else if (SchemaFromAnnotatedFields.of(iface) instanceof Schema.SchemaFromAnnotatedFields<T> schemaFromAnnotatedFields) {\n-            return schemaFromAnnotatedFields.create(); *\/\n@@ -437,1 +442,1 @@\n-        public ArrayBuildState arrayLen(String... arrayLenFieldNames) {\n+        public ArrayBuildState arrayLen(List<String> arrayLenFieldNames) {\n@@ -439,1 +444,1 @@\n-            Arrays.stream(arrayLenFieldNames).forEach(arrayLenFieldName -> {\n+            arrayLenFieldNames.forEach(arrayLenFieldName -> {\n@@ -447,0 +452,4 @@\n+        public ArrayBuildState arrayLen(String... arrayLenFieldNames) {\n+            return arrayLen(List.of(arrayLenFieldNames));\n+        }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/ifacemapper\/Schema.java","additions":68,"deletions":59,"binary":false,"changes":127,"status":"modified"}]}