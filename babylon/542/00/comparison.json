{"files":[{"patch":"@@ -193,1 +193,0 @@\n-        List<Phi> phiUsers = phi.replaceBy(same, this);\n@@ -198,2 +197,6 @@\n-        for (Phi user : phiUsers) {\n-            tryRemoveTrivialPhi(user);\n+        phi.users.remove(phi);\n+        phi.replaceBy(same, this);\n+        for (Object o : phi.users()) {\n+            if (o instanceof Phi user){\n+                tryRemoveTrivialPhi(user);\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/SSABraun.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -156,0 +156,149 @@\n+    @CodeReflection\n+    static int deadCode(int n) {\n+        int factorial = 1;\n+        int unused = factorial;\n+        int unusedLoop = 0;\n+        for (int i = 0; i < 4; i++) {\n+            unusedLoop++;\n+        }\n+        while (n > 0) {\n+            factorial *= n;\n+            n--;\n+            if (factorial == 0) {\n+                factorial = -1;\n+                int unusedNested = factorial;\n+            }\n+        }\n+        return factorial;\n+    }\n+\n+    @Test\n+    public void testDeadCode() {\n+        CoreOp.FuncOp f = getFuncOp(\"deadCode\");\n+\n+        CoreOp.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 10), deadCode(10));\n+    }\n+\n+    @CodeReflection\n+    static int ifelseLoopNested(int n) {\n+        int counter = 10;\n+        while (n > 0) {\n+            if (n % 2 == 0) {\n+                int sum = n;\n+                for (int i = 0; i < 5; i++) {\n+                    if (sum > n \/ 2) {\n+                        sum -= i;\n+                    } else {\n+                        sum += i;\n+                        break;\n+                    }\n+                }\n+                n += sum;\n+            } else {\n+                int difference = (n % 3 == 0) ? n \/ 2 : n * 2;\n+                n -= difference;\n+            }\n+            counter--;\n+        }\n+        return n;\n+    }\n+\n+    @Test\n+    public void testIfelseLoopNested() {\n+        CoreOp.FuncOp f = getFuncOp(\"ifelseLoopNested\");\n+\n+        CoreOp.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 10), ifelseLoopNested(10));\n+    }\n+\n+    @CodeReflection\n+    static int violaJones(int x, int maxX, int length, int integral) {\n+        int scale = 0;\n+        scale++;\n+        while (x > scale && scale < length) {\n+        }\n+        for (int i = 0; i < integral; i++) {\n+            scale--;\n+        }\n+        return scale;\n+    }\n+\n+    @Test\n+    public void testViolaJones() {\n+        CoreOp.FuncOp f = getFuncOp(\"violaJones\");\n+\n+        CoreOp.FuncOp lf = generate(f);\n+\n+        Assert.assertEquals((int) Interpreter.invoke(MethodHandles.lookup(), lf, 0, 1, 0, 0), violaJones(0, 1, 0, 0));\n+    }\n+\n+    @CodeReflection\n+    static boolean binarySearch(int[] arr, int target) {\n+        int l = 0;\n+        int r = arr.length - 1;\n+        while (l < r) {\n+            int m = (r - l) \/ 2;\n+            m += l;\n+            if (arr[m] < target) {\n+                l = m + 1;\n+            } else if (arr[m] > target) {\n+                r = m - 1;\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Test\n+    public void testBinarySearch() {\n+        CoreOp.FuncOp f = getFuncOp(\"binarySearch\");\n+\n+        CoreOp.FuncOp lf = generate(f);\n+\n+        int[] arr = new int[]{1, 2, 4, 7, 11, 19, 21, 29, 30, 36};\n+\n+        Assert.assertEquals((boolean) Interpreter.invoke(MethodHandles.lookup(), lf, arr, 4), binarySearch(arr, 4));\n+    }\n+\n+    @CodeReflection\n+    static void quicksort(int[] arr, int lo, int hi) {\n+        if (lo >= hi || lo < 0) {\n+            return;\n+        }\n+\n+        int pivot = arr[hi];\n+        int i = lo;\n+        for (int j = lo; j < hi; j++) {\n+            if (arr[j] <= pivot) {\n+                int temp = arr[i];\n+                arr[i] = arr[j];\n+                arr[j] = temp;\n+                i++;\n+            }\n+        }\n+        int temp = arr[i];\n+        arr[i] = arr[hi];\n+        arr[hi] = temp;\n+\n+        quicksort(arr, lo, i - 1);\n+        quicksort(arr, i + 1, hi);\n+    }\n+\n+    @Test\n+    public void testQuicksort() {\n+        CoreOp.FuncOp f = getFuncOp(\"quicksort\");\n+\n+        CoreOp.FuncOp lf = generate(f);\n+\n+        int[] arr1 = new int[]{5, 2, 7, 45, 34, 14, 0, 27, 43, 11, 38, 56, 81};\n+        int[] arr2 = new int[]{2, 11, 45, 34, 0, 27, 38, 56, 7, 43, 14, 5, 81};\n+\n+        Interpreter.invoke(MethodHandles.lookup(), lf, arr1, 0, arr1.length - 1);\n+        quicksort(arr2, 0, arr2.length - 1);\n+        Assert.assertEquals(arr1, arr2);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestSSA.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"modified"}]}