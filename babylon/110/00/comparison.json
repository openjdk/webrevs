{"files":[{"patch":"@@ -117,0 +117,3 @@\n+    \/**\n+     * Return a string representation of this Java type.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/TypeElement.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        return externalize().toString();\n+        return componentType.toString() + \"[]\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.stream.Collectors;\n@@ -101,1 +102,12 @@\n-        return externalize().toString();\n+        String prefix = enclosing != null ?\n+                enclosing + \"$\":\n+                (!type.packageName().isEmpty() ?\n+                        type.packageName() + \".\" : \"\");\n+        String name = enclosing == null ?\n+                type.displayName() :\n+                type.displayName().substring(enclosing.type.displayName().length() + 1);\n+        String typeArgs = hasTypeArguments() ?\n+                typeArguments().stream().map(JavaType::toString)\n+                        .collect(Collectors.joining(\", \", \"<\", \">\")) :\n+                \"\";\n+        return String.format(\"%s%s%s\", prefix, name, typeArgs);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        return externalize().toString();\n+        return type.displayName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        return externalize().toString();\n+        return name;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,3 @@\n-        return externalize().toString();\n+        return boundKind() == BoundKind.EXTENDS &&\n+                boundType.equals(J_L_OBJECT) ?\n+                \"?\" : boundKind().boundStr + boundType.toString();\n@@ -119,1 +121,1 @@\n-        EXTENDS,\n+        EXTENDS(\"? extends \"),\n@@ -121,1 +123,7 @@\n-        SUPER\n+        SUPER(\"? super \");\n+\n+        final String boundStr;\n+\n+        BoundKind(String boundStr) {\n+            this.boundStr = boundStr;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/WildcardType.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -179,0 +179,6 @@\n+    @Test(dataProvider = \"types\")\n+    public void testTypeString(Type type) throws ReflectiveOperationException {\n+        JavaType javaType = JavaType.type(type);\n+        Assert.assertEquals(type.getTypeName(), javaType.toString());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}