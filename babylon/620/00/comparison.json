{"files":[{"patch":"@@ -376,1 +376,1 @@\n-            if (Config.SHOW_CODE.isSet(config())) {\n+            if (config().showCode()) {\n@@ -428,1 +428,1 @@\n-        if (Config.SHOW_KERNEL_MODEL.isSet(config())){\n+        if (config().showKernelModel()){\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            if (Config.SHOW_CODE.isSet(config())) {\n+            if (config().showCode()) {\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-        if (Config.SHOW_KERNEL_MODEL.isSet(config())) {\n+        if (config().showKernelModel()) {\n@@ -227,1 +227,1 @@\n-        if (Config.SHOW_LOWERED_KERNEL_MODEL.isSet(config())){\n+        if (config().showLoweredKernelModel()){\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/C99FFIBackend.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-        if (Config.MINIMIZE_COPIES.isSet(config())) {\n-            if (Config.SHOW_COMPUTE_MODEL.isSet(config())) {\n+        if (config().minimizeCopies()) {\n+            if (config().showComputeModel()) {\n@@ -208,1 +208,1 @@\n-            if (Config.SHOW_COMPUTE_MODEL.isSet(config())) {\n+            if (config().showComputeModel()) {\n@@ -213,1 +213,1 @@\n-            if (Config.SHOW_COMPUTE_MODEL.isSet(config())) {\n+            if (config().showComputeModel()) {\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -189,0 +189,4 @@\n+    \/\/ convenience\n+    public Config config(){\n+        return backend.config();\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,4 @@\n-    public static final Bit MINIMIZE_COPIES =  Bit.nextBit(DEVICE, \"MINIMIZE_COPIES\",\"FFI ONLY Try to minimize copies\");\n+    private static final Bit MINIMIZE_COPIES =  Bit.nextBit(DEVICE, \"MINIMIZE_COPIES\",\"FFI ONLY Try to minimize copies\");\n+    public boolean minimizeCopies() {\n+        return MINIMIZE_COPIES.isSet(this);\n+    }\n@@ -71,3 +74,12 @@\n-    public static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\",\"Show generated code (PTX\/OpenCL\/CUDA)\");\n-    public static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\", \"Show (via OpWriter) Kernel Model\");\n-    public static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\", \"Show (via OpWriter) Compute Model\");\n+    private static final Bit SHOW_CODE = Bit.nextBit(PROFILE,\"SHOW_CODE\",\"Show generated code (PTX\/OpenCL\/CUDA)\");\n+    public boolean showCode() {\n+        return SHOW_CODE.isSet(this);\n+    }\n+    private static final Bit SHOW_KERNEL_MODEL = Bit.nextBit(SHOW_CODE,\"SHOW_KERNEL_MODEL\", \"Show (via OpWriter) Kernel Model\");\n+    public boolean showKernelModel() {\n+        return SHOW_COMPUTE_MODEL.isSet(this);\n+    }\n+    private static final Bit SHOW_COMPUTE_MODEL = Bit.nextBit(SHOW_KERNEL_MODEL,\"SHOW_COMPUTE_MODEL\", \"Show (via OpWriter) Compute Model\");\n+    public boolean showComputeModel() {\n+        return SHOW_COMPUTE_MODEL.isSet(this);\n+    }\n@@ -83,5 +95,19 @@\n-    public static final Bit NO_DIALECT = Bit.nextBit(INTERPRET, \"NO_DIALECT\", \"Skip generating HAT dialect ops\");\n-    public static final Bit HEADLESS = Bit.nextBit(NO_DIALECT, \"HEADLESS\", \"Don't show UI\");\n-    public static final Bit SHOW_LOWERED_KERNEL_MODEL = Bit.nextBit(HEADLESS,\"SHOW_LOWERED_KERNEL_MODEL\", \"Show (via OpWriter) Lowered Kernel Model\");\n-    public static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(SHOW_LOWERED_KERNEL_MODEL, \"SHOW_COMPILATION_PHASES\", \"Show HAT compilation phases\");\n-\n+    private static final Bit NO_DIALECT = Bit.nextBit(INTERPRET, \"NO_DIALECT\", \"Skip generating HAT dialect ops\");\n+    public boolean interpret() {\n+        return INTERPRET.isSet(this);\n+    }\n+    private static final Bit HEADLESS = Bit.nextBit(NO_DIALECT, \"HEADLESS\", \"Don't show UI\");\n+    public boolean headless() {\n+        return HEADLESS.isSet(this)|| Boolean.getBoolean(\"headless\");\n+    }\n+    public boolean headless(String arg) {\n+        return headless()|\"--headless\".equals(arg);\n+    }\n+    private static final Bit SHOW_LOWERED_KERNEL_MODEL = Bit.nextBit(HEADLESS,\"SHOW_LOWERED_KERNEL_MODEL\", \"Show (via OpWriter) Lowered Kernel Model\");\n+    public boolean showLoweredKernelModel() {\n+        return SHOW_LOWERED_KERNEL_MODEL.isSet(this);\n+    }\n+    private static final Bit SHOW_COMPILATION_PHASES = Bit.nextBit(SHOW_LOWERED_KERNEL_MODEL, \"SHOW_COMPILATION_PHASES\", \"Show HAT compilation phases\");\n+    public boolean showCompilationPhases() {\n+        return SHOW_COMPILATION_PHASES.isSet(this);\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/Config.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.code.CopyContext;\n@@ -63,0 +64,1 @@\n+import java.util.LinkedHashMap;\n@@ -67,0 +69,2 @@\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n@@ -557,1 +561,6 @@\n-\n+    public static boolean fieldNameIs(JavaOp.FieldAccessOp.FieldAccessOp fieldAccessOp, String name) {\n+        return fieldName(fieldAccessOp).equals(name);\n+    }\n+    public static boolean fieldNameMatches(JavaOp.FieldAccessOp.FieldAccessOp fieldAccessOp, Pattern pattern) {\n+        return pattern.matcher(fieldName(fieldAccessOp)).matches();\n+    }\n@@ -611,0 +620,30 @@\n+    public record  OpMap(CoreOp.FuncOp fromFuncOp, CoreOp.FuncOp toFuncOp,  Map<Op,Op> fromToOpMap){}\n+\n+    public  static <InOp extends Op, OutOp extends Op> OutOp replaceOp(Block.Builder blockBuilder, InOp inOp,java.util.function.Function<List<Value>, OutOp> factory) {\n+        List<Value> inputOperands = inOp.operands();\n+        CopyContext context = blockBuilder.context();\n+        List<Value> outputOperands = context.getValues(inputOperands);\n+        OutOp outOp = factory.apply(outputOperands);\n+        Op.Result outputResult = blockBuilder.op(outOp);\n+        Op.Result inputResult = inOp.result();\n+        outOp.setLocation(inOp.location());\n+        context.mapValue(inputResult, outputResult);\n+        return outOp;\n+    }\n+    public static < OutOp extends Op> OpMap simpleOpMappingTransform(OpTk.CallSite here, CoreOp.FuncOp fromFuncOp, Predicate<Op> opPredicate,\n+                                                         java.util.function.Function<List<Value>, OutOp> opFactory){\n+        Map<Op,Op> fromToOpMap = new LinkedHashMap<>();\n+        CoreOp.FuncOp toFuncOp =  OpTk.transform(here, fromFuncOp, (blockBuilder, inOp) -> {\n+            if (opPredicate.test(inOp)) {\n+                fromToOpMap.put(inOp, replaceOp(blockBuilder, inOp, opFactory));\n+            }else {\n+                var r = blockBuilder.op(inOp);\n+                fromToOpMap.put(inOp,r.op());\n+            }\n+            return blockBuilder;\n+        });\n+        return new OpMap(fromFuncOp, toFuncOp, fromToOpMap);\n+    }\n+\n+\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -98,1 +98,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+        if (accelerator.config().showCompilationPhases()) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+            if (accelerator.config().showCompilationPhases()) {\n@@ -133,1 +133,1 @@\n-            if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config())) {\n+            if (accelerator.config().showCompilationPhases()) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -61,1 +61,1 @@\n-\n+        }\n@@ -128,1 +128,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -130,0 +130,1 @@\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -120,0 +120,1 @@\n+        }\n@@ -169,1 +170,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -171,0 +172,1 @@\n+        }\n@@ -179,1 +181,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -181,0 +183,1 @@\n+        }\n@@ -235,1 +238,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -237,0 +240,1 @@\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVSelectPhase.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -146,0 +146,1 @@\n+        }\n@@ -203,1 +204,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -205,0 +206,1 @@\n+        }\n@@ -210,1 +212,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -212,0 +214,1 @@\n+        }\n@@ -266,1 +269,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -268,0 +271,1 @@\n+        }\n@@ -272,1 +276,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -274,1 +278,1 @@\n-\n+        }\n@@ -327,1 +331,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -329,0 +333,1 @@\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -116,0 +116,1 @@\n+        }\n@@ -157,1 +158,1 @@\n-        if (Config.SHOW_COMPILATION_PHASES.isSet(accelerator.backend.config()))\n+        if (accelerator.config().showCompilationPhases()) {\n@@ -159,0 +160,1 @@\n+        }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+public class TransformState {\n+\n+    @CodeReflection\n+    static int threeSum(int a, int b, int c) {\n+        return a + b * c;\n+    }\n+\n+    \/\/@Test\n+    public static void testOpToOp() {\n+        CoreOp.FuncOp threeSumFuncOp = getFuncOp(\"threeSum\");\n+        Map<Op, Op> oldOpToNewOpMap = new HashMap<>();\n+        OpTransformer opTracker = (block, op) -> {\n+            if (op instanceof JavaOp.AddOp) {\n+                CopyContext cc = block.context();\n+                var newSubOp = JavaOp.sub(cc.getValue(op.operands().get(0)), cc.getValue(op.operands().get(1)));\n+                Op.Result result = block.op(newSubOp);\n+                cc.mapValue(op.result(), result);\n+                oldOpToNewOpMap.put(op,newSubOp);\/\/ <-- this maps op -> new subOp\n+            } else {\n+                var result = block.op(op);\n+                oldOpToNewOpMap.put(op,result.op()); \/\/<-- this maps op ->  op'\n+            }\n+            return block;\n+        };\n+\n+        System.out.println(threeSumFuncOp.toText());\n+        CoreOp.FuncOp threeSumFuncOp1 = threeSumFuncOp.transform(opTracker);\n+        System.out.println(threeSumFuncOp1.toText());\n+    }\n+\n+    \/\/@Test\n+    public static void testDelegate() {\n+        CoreOp.FuncOp threeSumFuncOp = getFuncOp(\"threeSum\");\n+        JavaOp.AddOp addOp = (JavaOp.AddOp) threeSumFuncOp.elements().filter(e -> e instanceof JavaOp.AddOp).findFirst().orElseThrow();\n+        JavaOp.MulOp mulOp = (JavaOp.MulOp) threeSumFuncOp.elements().filter(e -> e instanceof JavaOp.MulOp).findFirst().orElseThrow();\n+        Map<Value, String> mapState = new HashMap<>();\n+        mapState.put(addOp.result(), \"STATE 1\");\n+        mapState.put(mulOp.result(), \"STATE 2\");\n+\n+        Map<Value, String> transformedMapState = new HashMap<>();\n+        Map<Op, Op> transformedOpMapState = new HashMap<>();\n+\n+        OpTransformer opTracker = (block, op) -> {\n+            if (op instanceof JavaOp.AddOp) {\n+                CopyContext cc = block.context();\n+                var newSubOp = JavaOp.sub(cc.getValue(op.operands().get(0)), cc.getValue(op.operands().get(1)));\n+                Op.Result result = block.op(newSubOp);\n+                cc.mapValue(op.result(), result);\n+                transformedOpMapState.put(op,newSubOp);\/\/ <-- this maps op -> new subOp\n+            } else {\n+                var result = block.op(op);\n+                transformedOpMapState.put(op,result.op()); \/\/<-- this maps op ->  op'\n+            }\n+            return block;\n+        };\n+        OpTransformer t = trackingValueDelegatingTransformer(\n+                (block, op) -> {\n+                    if (op instanceof JavaOp.AddOp) {\n+                        CopyContext cc = block.context();\n+                        var newSubOp = JavaOp.sub(cc.getValue(op.operands().get(0)), cc.getValue(op.operands().get(1)));\n+                        Op.Result r = block.op(newSubOp);\n+                        cc.mapValue(op.result(), r);\n+                        transformedOpMapState.put(op,newSubOp);\n+                    } else {\n+                        var r = block.op(op);\n+                        transformedOpMapState.put(op,r.op());\n+                    }\n+                    return block;\n+                },\n+                (vIn, vOut) -> {\n+                    if (mapState.containsKey(vIn) && vOut != null) {\n+                        transformedMapState.put(vOut, mapState.get(vIn));\n+                    }\n+                });\n+\n+        System.out.println(threeSumFuncOp.toText());\n+        print(mapState);\n+        CoreOp.FuncOp threeSumFuncOp1 = threeSumFuncOp.transform(opTracker);\n+        System.out.println(threeSumFuncOp1.toText());\n+        print(transformedMapState);\n+    }\n+\n+    static void print(Map<Value, String> mappedStated) {\n+        mappedStated.forEach((v, s) -> {\n+            System.out.println(v + \"[\" + ((v instanceof Op.Result r ? r.op() : \"\") + \"] -> \" + s));\n+        });\n+    }\n+\n+    static OpTransformer trackingValueDelegatingTransformer(\n+            BiFunction<Block.Builder, Op, Block.Builder> t,\n+            BiConsumer<Value, Value> mapAction) {\n+        return (block, op) -> {\n+            try {\n+                return t.apply(block, op);\n+            } finally {\n+                Value in = op.result();\n+                Value out = block.context().getValueOrDefault(in, null);\n+                mapAction.accept(in, out);\n+            }\n+        };\n+    }\n+\n+\n+    \/\/@Test\n+    static public void testAndThen() {\n+        CoreOp.FuncOp threeSumFuncOp = getFuncOp(\"threeSum\");\n+        JavaOp.AddOp addOp = (JavaOp.AddOp) threeSumFuncOp.elements().filter(e -> e instanceof JavaOp.AddOp).findFirst().orElseThrow();\n+        JavaOp.MulOp mulOp = (JavaOp.MulOp) threeSumFuncOp.elements().filter(e -> e instanceof JavaOp.MulOp).findFirst().orElseThrow();\n+        Map<Value, String> mapState = new HashMap<>();\n+        mapState.put(addOp.result(), \"STATE 1\");\n+        mapState.put(mulOp.result(), \"STATE 2\");\n+\n+        Map<Value, String> transformedMapState = new HashMap<>();\n+\n+        OpTransformer t = trackingValueAndThenTransformer(\n+                (block, op) -> {\n+                    if (op instanceof JavaOp.AddOp) {\n+                        CopyContext cc = block.context();\n+                        Op.Result r = block.op(JavaOp.sub(\n+                                cc.getValue(op.operands().get(0)),\n+                                cc.getValue(op.operands().get(1))));\n+                        cc.mapValue(op.result(), r);\n+                    } else {\n+                        block.op(op);\n+                    }\n+                    return block;\n+                },\n+                (vIn, vOut) -> {\n+                    if (mapState.containsKey(vIn) && vOut != null) {\n+                        transformedMapState.put(vOut, mapState.get(vIn));\n+                    }\n+                });\n+\n+        System.out.println(threeSumFuncOp.toText());\n+        print(mapState);\n+        CoreOp.FuncOp threeSumFuncOp1 = threeSumFuncOp.transform(t);\n+        System.out.println(threeSumFuncOp1.toText());\n+        print(transformedMapState);\n+    }\n+\n+    static OpTransformer trackingValueAndThenTransformer(\n+            OpTransformer t,\n+            BiConsumer<Value, Value> mapAction) {\n+        return OpTransformer.andThen(t, (block, op) -> {\n+            Value in = op.result();\n+            Value out = block.context().getValueOrDefault(in, null);\n+            mapAction.accept(in, out);\n+            return block;\n+        });\n+    }\n+\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(TransformState.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return Op.ofMethod(m).get();\n+    }\n+\n+    static public  void main(String[] args) {\n+        testOpToOp();\n+        \/\/testDelegate();\n+        \/\/testAndThen();\n+    }\n+}\n\\ No newline at end of file\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/TransformState.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -84,4 +84,1 @@\n-\n-        \/\/ TODO: lets use Config going forward\n-        boolean headless = Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"))\n-                || Config.HEADLESS.isSet(accelerator.backend.config());\n+        boolean headless = accelerator.config().headless(args.length>0?args[0]:null);\n@@ -92,1 +89,1 @@\n-        if (headless){\n+        if (accelerator.config().headless(args.length>0?args[0]:null)){\n","filename":"hat\/examples\/mandel\/src\/main\/java\/mandel\/Main.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n@@ -48,0 +49,1 @@\n+        boolean headless = accelerator.config().headless(args.length>0?args[0]:null);\n@@ -51,1 +53,0 @@\n-\n@@ -54,6 +55,0 @@\n-        Accelerator accelerator = new Accelerator(MethodHandles.lookup(), Backend.FIRST);\n-\n-        \/\/ TODO: lets use Config going forward\n-        boolean headless = Boolean.getBoolean(\"headless\") ||( args.length>0 && args[0].equals(\"--headless\"))\n-                || Config.HEADLESS.isSet(accelerator.backend.config());\n-\n","filename":"hat\/examples\/violajones\/src\/main\/java\/violajones\/Main.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"}]}