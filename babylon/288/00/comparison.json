{"files":[{"patch":"@@ -6,0 +6,1 @@\n+stage\/\n","filename":"hat\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                println(\"We have \" + extractedOpenCLJar.path());\n+                println(\"We have prebuilt \" + extractedOpenCLJar.path());\n@@ -107,1 +107,1 @@\n-                } \n+                }\n@@ -114,1 +114,1 @@\n-                println(\"We have \" + extractedOpenGLJar.path());\n+                println(\"We have prebuilt \" + extractedOpenGLJar.path());\n@@ -181,0 +181,10 @@\n+  var hatlessNBodyDir = hatDir.dir(\"hatless-examples\/nbody\");\n+\n+  buildDir.jarFile(\"hatless-example-nbody.jar\", $->$\n+     .javac($$->$$.opts(hatOpts)\n+         .source(24)\n+         .class_path(buildDir.jarFile(\"jextracted-opencl.jar\"),buildDir.jarFile(\"jextracted-opengl.jar\"))\n+         .source_path(hatlessNBodyDir.sourceDir(\"src\/main\/java\"))\n+     )\n+     .dir_list(hatlessNBodyDir.dir(\"src\/main\/resources\"))\n+ );\n","filename":"hat\/bld","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -450,0 +450,4 @@\n+\n+        public BuildDir existingBuildDir(String subdir) {\n+            return assertExists(BuildDir.of(path(subdir)));\n+        }\n@@ -476,0 +480,9 @@\n+        public ClassPathEntryProvider jarFiles(String ...names) {\n+            var classPath = ClassPath.of();\n+            Stream.of(names).forEach(name->\n+                classPath.add(JarFile.of(path().resolve(name))\n+                )\n+            );\n+            return classPath;\n+        }\n+\n@@ -922,0 +935,1 @@\n+        public boolean startOnFirstThread;\n@@ -956,0 +970,5 @@\n+\n+        public JavaBuilder start_on_first_thread() {\n+            this.startOnFirstThread =   true;\n+            return this;\n+        }\n@@ -961,0 +980,3 @@\n+        if (javaBuilder.startOnFirstThread){\n+            execOpts.add(\"-XstartOnFirstThread\");\n+        }\n","filename":"hat\/bldr\/Bldr.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+--enable-preview --source 24 hatlessrun\n","filename":"hat\/bldr\/hatlessrun","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+opengl\/\n+opencl\/\n","filename":"hat\/hatless-examples\/nbody\/.gitignore","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,528 @@\n+package nbody;\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opencl.opencl_h_1.CL_DEVICE_TYPE_ALL;\n+import static opencl.opencl_h_1.CL_MEM_READ_WRITE;\n+import static opencl.opencl_h_1.CL_MEM_USE_HOST_PTR;\n+import static opencl.opencl_h_1.CL_QUEUE_PROFILING_ENABLE;\n+import static opencl.opencl_h_1.read;\n+import static opencl.opencl_h_2.C_POINTER;\n+import static opencl.opencl_h_2.clBuildProgram;\n+import static opencl.opencl_h_2.clCreateBuffer;\n+import static opencl.opencl_h_2.clCreateCommandQueue;\n+import static opencl.opencl_h_2.clCreateContext;\n+import static opencl.opencl_h_2.clCreateKernel;\n+import static opencl.opencl_h_2.clCreateProgramWithSource;\n+import static opencl.opencl_h_2.clEnqueueNDRangeKernel;\n+import static opencl.opencl_h_2.clEnqueueReadBuffer;\n+import static opencl.opencl_h_2.clEnqueueWriteBuffer;\n+import static opencl.opencl_h_2.clFlush;\n+import static opencl.opencl_h_2.clGetDeviceIDs;\n+import static opencl.opencl_h_2.clGetDeviceInfo;\n+import static opencl.opencl_h_2.clGetPlatformIDs;\n+import static opencl.opencl_h_2.clGetPlatformInfo;\n+import static opencl.opencl_h_2.clGetProgramBuildInfo;\n+import static opencl.opencl_h_2.clReleaseContext;\n+import static opencl.opencl_h_2.clReleaseMemObject;\n+import static opencl.opencl_h_2.clSetKernelArg;\n+import static opencl.opencl_h_2.clWaitForEvents;\n+import static opencl.opencl_h_2.cl_event;\n+import static opencl.opencl_h_2.cl_mem;\n+import static opencl.opencl_h_3.CL_DEVICE_BUILT_IN_KERNELS;\n+import static opencl.opencl_h_3.CL_DEVICE_MAX_COMPUTE_UNITS;\n+import static opencl.opencl_h_3.CL_DEVICE_NAME;\n+import static opencl.opencl_h_3.CL_FALSE;\n+import static opencl.opencl_h_3.CL_PLATFORM_NAME;\n+import static opencl.opencl_h_3.CL_PLATFORM_VENDOR;\n+import static opencl.opencl_h_3.CL_PLATFORM_VERSION;\n+import static opencl.opencl_h_3.CL_PROGRAM_BUILD_LOG;\n+import static opencl.opencl_h_3.CL_SUCCESS;\n+import static opencl.opencl_h_3.CL_TRUE;\n+import static opencl.opencl_h_3.C_CHAR;\n+import static opencl.opencl_h_3.C_FLOAT;\n+import static opencl.opencl_h_3.C_INT;\n+import static opencl.opencl_h_3.C_LONG;\n+\/\/import static opengl.glut_h.C_CHAR;\n+\/\/import static opengl.glut_h.C_INT;\n+\/\/import static opengl.glut_h_3.C_LONG;\n+\n+public class CLWrap {\n+    public static MemorySegment NULL = java.lang.foreign.MemorySegment.NULL;\n+\n+    \/\/ https:\/\/streamhpc.com\/blog\/2013-04-28\/opencl-error-codes\/\n+    static class Platform {\n+        static class Device {\n+            final Platform platform;\n+            final MemorySegment deviceId;\n+\n+            int intDeviceInfo(int query) {\n+                var value = 0;\n+                int status;\n+                if ((status = clGetDeviceInfo(deviceId, query, JAVA_INT.byteSize(), platform.intValuePtr, NULL)) != CL_SUCCESS()) {\n+                    System.out.println(\"Failed to get query \" + query);\n+                } else {\n+                    value = platform.intValuePtr.get(C_INT, 0);\n+                }\n+                return value;\n+            }\n+\n+            String strDeviceInfo(int query) {\n+                String value = null;\n+                int status;\n+                if ((status = clGetDeviceInfo(deviceId, query, 2048, platform.byte2048ValuePtr, platform.intValuePtr)) != CL_SUCCESS()) {\n+                    System.out.println(\"Failed to get query \" + query);\n+                } else {\n+                    int len = platform.intValuePtr.get(C_INT, 0);\n+                    byte[] bytes = platform.byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n+                    value = new String(bytes).substring(0, len - 1);\n+                }\n+                return value;\n+            }\n+\n+            int computeUnits() {\n+                return intDeviceInfo(CL_DEVICE_MAX_COMPUTE_UNITS());\n+            }\n+\n+            String deviceName() {\n+                return strDeviceInfo(CL_DEVICE_NAME());\n+            }\n+\n+            String builtInKernels() {\n+                return strDeviceInfo(CL_DEVICE_BUILT_IN_KERNELS());\n+            }\n+\n+            Device(Platform platform, MemorySegment deviceId) {\n+                this.platform = platform;\n+                this.deviceId = deviceId;\n+            }\n+\n+            public static class Context {\n+                Device device;\n+                MemorySegment context;\n+                MemorySegment queue;\n+\n+                Context(Device device, MemorySegment context) {\n+                    this.device = device;\n+                    this.context = context;\n+                    var statusPtr = device.platform.openCL.arena.allocate(C_INT, 1);\n+\n+                    var queue_props = CL_QUEUE_PROFILING_ENABLE();\n+                    if ((queue = clCreateCommandQueue(context, device.deviceId, queue_props, statusPtr)) == NULL) {\n+                        int status = statusPtr.get(C_INT, 0);\n+                        clReleaseContext(context);\n+                        \/\/ delete[] platforms;\n+                        \/\/ delete[] device_ids;\n+                        return;\n+                    }\n+\n+                }\n+\n+                static public class Program {\n+                    Context context;\n+                    String source;\n+                    MemorySegment program;\n+                    String log;\n+\n+                    Program(Context context, String source) {\n+                        this.context = context;\n+                        this.source = source;\n+                        var statusPtr = context.device.platform.openCL.arena.allocate(C_INT, 1);\n+                   \/\/     MemorySegment sourcePtr = context.device.platform.openCL.arena.allocate(C_CHAR, source.length());\n+                     \/\/   MemorySegment.copy(source.getBytes(), 0, sourcePtr, C_CHAR, 0, source.length());\n+                        MemorySegment sourcePtr = context.device.platform.openCL.arena.allocateFrom(source);\n+                        var sourcePtrPtr = context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n+                        sourcePtrPtr.set(C_POINTER, 0, sourcePtr);\n+                        var sourceLenPtr = context.device.platform.openCL.arena.allocate(C_LONG, 1);\n+                        sourceLenPtr.set(C_LONG, 0, source.length());\n+                        if ((program = clCreateProgramWithSource(context.context, 1, sourcePtrPtr, sourceLenPtr, statusPtr)) == NULL) {\n+                            int status = statusPtr.get(C_INT, 0);\n+                            if (status != CL_SUCCESS()) {\n+                                System.out.println(\"failed to createProgram \" + status);\n+                            }\n+                            System.out.println(\"failed to createProgram\");\n+                        } else {\n+                            int status = statusPtr.get(C_INT, 0);\n+                            if (status != CL_SUCCESS()) {\n+                                System.out.println(\"failed to create program \" + status);\n+                            }\n+                            var deviceIdPtr = context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n+                            deviceIdPtr.set(C_POINTER, 0, context.device.deviceId);\n+                            if ((status = clBuildProgram(program, 1, deviceIdPtr, NULL, NULL, NULL)) != CL_SUCCESS()) {\n+                                System.out.println(\"failed to build\" + status);\n+                                \/\/ dont return we may still be able to get log!\n+                            }\n+\n+                            var logLenPtr = context.device.platform.openCL.arena.allocate(C_LONG, 1);\n+\n+                            if ((status = clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), 0, NULL, logLenPtr)) != CL_SUCCESS()) {\n+                                System.out.println(\"failed to get log build \" + status);\n+                            } else {\n+                                long logLen = logLenPtr.get(C_LONG, 0);\n+\n+                                var logPtr = context.device.platform.openCL.arena.allocate(C_CHAR, 1 + logLen);\n+\n+\n+                                if ((status = clGetProgramBuildInfo(program, context.device.deviceId, CL_PROGRAM_BUILD_LOG(), logLen, logPtr, logLenPtr)) != CL_SUCCESS()) {\n+                                    System.out.println(\"clGetBuildInfo (getting log) failed\");\n+\n+                                } else {\n+                                    byte[] bytes = logPtr.toArray(ValueLayout.JAVA_BYTE);\n+                                    log = new String(bytes).substring(0, (int) logLen);\n+\n+                                }\n+                            }\n+                        }\n+\n+\n+                    }\n+\n+                    public static class Kernel {\n+                        Program program;\n+                        MemorySegment kernel;\n+                        String name;\n+\n+                        public Kernel(Program program, String name) {\n+                            this.program = program;\n+                            this.name = name;\n+                            var statusPtr = program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n+                            MemorySegment kernelNamePtr = program.context.device.platform.openCL.arena.allocate(C_CHAR, name.length() + 1);\n+                            MemorySegment.copy(name.getBytes(), 0, kernelNamePtr, C_CHAR, 0, name.length());\n+\n+                            kernel = clCreateKernel(program.program, kernelNamePtr, statusPtr);\n+                            int status = statusPtr.get(C_INT, 0);\n+                            if (status != CL_SUCCESS()) {\n+                                System.out.println(\"failed to create kernel \" + status);\n+                            }\n+                        }\n+\n+                        public void run(int range, Object... args) {\n+                            var bufPtr = program.context.device.platform.openCL.arena.allocate(cl_mem, args.length);\n+                            var statusPtr = program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n+                            int status;\n+                            var eventMax = args.length * 4 + 1;\n+                            int eventc = 0;\n+                            var eventsPtr = program.context.device.platform.openCL.arena.allocate(cl_event, eventMax);\n+                            boolean block =false;\/\/ true;\n+                            for (int i = 0; i < args.length; i++) {\n+                                if (args[i] instanceof MemorySegment memorySegment) {\n+                                    MemorySegment clMem = clCreateBuffer(program.context.context,\n+                                            CL_MEM_USE_HOST_PTR() | CL_MEM_READ_WRITE(),\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            statusPtr);\n+                                    status = statusPtr.get(C_INT, 0);\n+                                    if (status != CL_SUCCESS()) {\n+                                        System.out.println(\"failed to create memory buffer \" + status);\n+                                    }\n+                                    bufPtr.set(cl_mem, i*cl_mem.byteSize(), clMem);\n+                                    status = clEnqueueWriteBuffer(program.context.queue,\n+                                            clMem,\n+                                            block?CL_TRUE():CL_FALSE(), \/\/block?\n+                                            0,\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            block?0:eventc,\n+                                            block?NULL:((eventc == 0) ? NULL : eventsPtr),\n+                                            block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event)\n+                                    );\n+                                    if (status != CL_SUCCESS()) {\n+                                        System.out.println(\"failed to enqueue write \" + status);\n+                                    }\n+                                    if (!block) {\n+                                        eventc++;\n+                                    }\n+                                    var clMemPtr =  program.context.device.platform.openCL.arena.allocate(C_POINTER, 1);\n+                                    clMemPtr.set(C_POINTER, 0, clMem);\n+\n+                                    status = clSetKernelArg(kernel, i, C_POINTER.byteSize(), clMemPtr);\n+                                    if (status != CL_SUCCESS()) {\n+                                        System.out.println(\"failed to set arg \" + status);\n+                                    }\n+                                } else {\n+                                    bufPtr.set(cl_mem, i*cl_mem.byteSize(), NULL);\n+                                    if (args[i] instanceof Integer integer) {\n+                                        var intPtr =  program.context.device.platform.openCL.arena.allocate(C_INT, 1);\n+                                        intPtr.set(C_INT,0,integer.intValue());\n+                                        status = clSetKernelArg(kernel, i, C_INT.byteSize(), intPtr);\n+                                        if (status != CL_SUCCESS()) {\n+                                            System.out.println(\"failed to set arg \" + status);\n+                                        }\n+                                    }else if (args[i] instanceof Float f) {\n+                                            var floatPtr =  program.context.device.platform.openCL.arena.allocate(C_FLOAT, 1);\n+                                            floatPtr.set(C_FLOAT,0,f.floatValue());\n+                                            status = clSetKernelArg(kernel, i, C_FLOAT.byteSize(), floatPtr);\n+                                            if (status != CL_SUCCESS()) {\n+                                                System.out.println(\"failed to set arg \" + status);\n+                                            }\n+                                        }\n+\n+                                }\n+                            }\n+\n+                            var globalSizePtr = program.context.device.platform.openCL.arena.allocate(C_INT, 3);\n+                            globalSizePtr.set(C_INT, 0, range);\n+                            status = clEnqueueNDRangeKernel(\n+                                    program.context.queue,\n+                                    kernel,\n+                                    1,\n+                                    NULL,\n+                                    globalSizePtr,\n+                                    NULL,\n+                                    block?0:eventc,\n+                                    block?NULL:((eventc == 0) ? NULL : eventsPtr),\n+                                    block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event\n+                                    )\n+                            );\n+                            if (status != CL_SUCCESS()) {\n+                                System.out.println(\"failed to enqueue NDRange \" + status);\n+                            }\n+\n+\n+                            if (block) {\n+                                clFlush(program.context.queue);\n+                            }else{\n+                                eventc++;\n+\n+                                status = clWaitForEvents(eventc, eventsPtr);\n+                                if (status != CL_SUCCESS()) {\n+                                    System.out.println(\"failed to wait for ndrange events \" + status);\n+                                }\n+                            }\n+\n+                            for (int i = 0; i < args.length; i++) {\n+                                if (args[i] instanceof MemorySegment memorySegment) {\n+                                    MemorySegment clMem = bufPtr.get(cl_mem, (long) i*cl_mem.byteSize());\n+\n+                                   status = clEnqueueReadBuffer(program.context.queue,\n+                                            clMem,\n+                                            block?CL_TRUE():CL_FALSE(),\n+                                            0,\n+                                            memorySegment.byteSize(),\n+                                            memorySegment,\n+                                            block?0:eventc,\n+                                            block?NULL:((eventc == 0) ? NULL : eventsPtr),\n+                                            block?NULL:eventsPtr.asSlice( eventc*cl_event.byteSize(), cl_event)\/\/ block?NULL:readEventPtr\n+                                    );\n+                                    if (status != CL_SUCCESS()) {\n+                                        System.out.println(\"failed to enqueue read \" + status);\n+                                    }\n+                                    if (!block){\n+                                        eventc++;\n+                                    }\n+                                }\n+                            }\n+                            if (!block) {\n+                                status = clWaitForEvents(eventc, eventsPtr);\n+                                if (status != CL_SUCCESS()) {\n+                                    System.out.println(\"failed to wait for events \" + status);\n+                                }\n+                            }\n+                            for (int i = 0; i < args.length; i++) {\n+                                if (args[i] instanceof MemorySegment memorySegment) {\n+                                    MemorySegment clMem = bufPtr.get(cl_mem, (long) i*cl_mem.byteSize());\n+                                    status = clReleaseMemObject(clMem);\n+                                    if (status != CL_SUCCESS()) {\n+                                        System.out.println(\"failed to release memObject \" + status);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    public Kernel getKernel(String kernelName) {\n+                        return new Kernel(this, kernelName);\n+                    }\n+                }\n+\n+                public Program buildProgram(String source) {\n+                    var program = new Program(this, source);\n+                    return program;\n+                }\n+            }\n+\n+            public Context createContext() {\n+\n+                var statusPtr = platform.openCL.arena.allocate(C_INT, 1);\n+                MemorySegment context;\n+                var deviceIds = platform.openCL.arena.allocate(C_POINTER, 1);\n+                deviceIds.set(C_POINTER, 0, this.deviceId);\n+                if ((context = clCreateContext(NULL, 1, deviceIds, NULL, NULL, statusPtr)) == NULL) {\n+                    int status = statusPtr.get(C_INT, 0);\n+                    System.out.println(\"Failed to get context  \");\n+                    return null;\n+                } else {\n+                    int status = statusPtr.get(C_INT, 0);\n+                    if (status != CL_SUCCESS()) {\n+                        System.out.println(\"failed to get context  \" + status);\n+                    }\n+                    return new Context(this, context);\n+                }\n+            }\n+        }\n+\n+        int intPlatformInfo(int query) {\n+            var value = 0;\n+            int status;\n+            if ((status = clGetPlatformInfo(platformId, query, JAVA_INT.byteSize(), intValuePtr, NULL)) != CL_SUCCESS()) {\n+                System.out.println(\"Failed to get query \" + query);\n+            } else {\n+                value = intValuePtr.get(C_INT, 0);\n+            }\n+            return value;\n+        }\n+\n+        String strPlatformInfo(int query) {\n+            String value = null;\n+            int status;\n+            if ((status = clGetPlatformInfo(platformId, query, 2048, byte2048ValuePtr, intValuePtr)) != CL_SUCCESS()) {\n+                System.err.println(\"Failed to get query \" + query);\n+            } else {\n+                int len = intValuePtr.get(C_INT, 0);\n+                byte[] bytes = byte2048ValuePtr.toArray(ValueLayout.JAVA_BYTE);\n+                value = new String(bytes).substring(0, len - 1);\n+            }\n+            return value;\n+        }\n+\n+        CLWrap openCL;\n+        MemorySegment platformId;\n+        List<Device> devices = new ArrayList<>();\n+        final MemorySegment intValuePtr;\n+        final MemorySegment byte2048ValuePtr;\n+\n+        String platformName() {\n+            return strPlatformInfo(CL_PLATFORM_NAME());\n+        }\n+\n+        String vendorName() {\n+            return strPlatformInfo(CL_PLATFORM_VENDOR());\n+        }\n+\n+        String version() {\n+            return strPlatformInfo(CL_PLATFORM_VERSION());\n+        }\n+\n+        public Platform(CLWrap openCL, MemorySegment platformId) {\n+            this.openCL = openCL;\n+            this.platformId = platformId;\n+            this.intValuePtr = openCL.arena.allocate(C_INT, 1);\n+            this.byte2048ValuePtr = openCL.arena.allocate(C_CHAR, 2048);\n+            var devicecPtr = openCL.arena.allocate(C_INT, 1);\n+            int status;\n+            if ((status = clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), 0, NULL, devicecPtr)) != CL_SUCCESS()) {\n+                System.err.println(\"Failed getting devicec for platform 0 \");\n+            } else {\n+                int devicec = devicecPtr.get(C_INT, 0);\n+                \/\/  System.out.println(\"platform 0 has \" + devicec + \" device\" + ((devicec > 1) ? \"s\" : \"\"));\n+                var deviceIdsPtr = openCL.arena.allocate(C_POINTER, devicec);\n+                if ((status = clGetDeviceIDs(platformId, CL_DEVICE_TYPE_ALL(), devicec, deviceIdsPtr, devicecPtr)) != CL_SUCCESS()) {\n+                    System.err.println(\"Failed getting deviceids  for platform 0 \");\n+                } else {\n+                    \/\/ System.out.println(\"We have \"+devicec+\" device ids\");\n+                    for (int i = 0; i < devicec; i++) {\n+                        devices.add(new Device(this, deviceIdsPtr.get(C_POINTER, i*C_POINTER.byteSize())));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    List<Platform> platforms = new ArrayList<>();\n+\n+    Arena arena;\n+\n+    CLWrap(Arena arena) {\n+        this.arena = arena;\n+        int status;\n+        var platformcPtr = arena.allocate(C_INT, 1);\n+\n+        if ((status = clGetPlatformIDs(0, NULL, platformcPtr)) != CL_SUCCESS()) {\n+            System.out.println(\"Failed to get opencl platforms\");\n+        } else {\n+            int platformc = platformcPtr.get(JAVA_INT, 0);\n+            \/\/ System.out.println(\"There are \"+platformc+\" platforms\");\n+            var platformIdsPtr = arena.allocate(C_POINTER, platformc);\n+            if ((status = clGetPlatformIDs(platformc, platformIdsPtr, platformcPtr)) != CL_SUCCESS()) {\n+                System.out.println(\"Failed getting ids\");\n+            } else {\n+                for (int i = 0; i < platformc; i++) {\n+                    \/\/ System.out.println(\"We should have the ids\");\n+                    platforms.add(new Platform(this, platformIdsPtr.get(C_POINTER, i)));\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) throws IOException {\n+        try (var arena = Arena.ofConfined()) {\n+            CLWrap openCL = new CLWrap(arena);\n+\n+            CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n+            openCL.platforms.forEach(platform -> {\n+                System.out.println(\"Platform Name \" + platform.platformName());\n+                platform.devices.forEach(device -> {\n+                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                    System.out.println(\"   Device Name       \" + device.deviceName());\n+                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+                    selectedDevice[0] = device;\n+                });\n+            });\n+            var context = selectedDevice[0].createContext();\n+            var program = context.buildProgram(\"\"\"\n+                    __kernel void squares(__global int* in,__global int* out ){\n+                        int gid = get_global_id(0);\n+                        out[gid] = in[gid]*in[gid];\n+                    }\n+                    \"\"\");\n+            var kernel = program.getKernel(\"squares\");\n+            var in = arena.allocate(C_INT, 512);\n+            var out = arena.allocate(C_INT, 512);\n+            for (int i = 0; i < 512; i++) {\n+                in.set(C_INT, (int)i*C_INT.byteSize(),i);\n+            }\n+            kernel.run(512, in, out );\n+            for (int i = 0; i < 512; i++) {\n+                System.out.println(i + \" \" + out.get(C_INT, (int)i*C_INT.byteSize()));\n+            }\n+        }\n+    }\n+}\n","filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/CLWrap.java","additions":528,"deletions":0,"binary":false,"changes":528,"status":"added"},{"patch":"@@ -0,0 +1,262 @@\n+package nbody;\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+import opengl.glutDisplayFunc$func;\n+import opengl.glutIdleFunc$func;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBufferByte;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opengl.glut_h.C_CHAR;\n+import static opengl.glut_h.C_FLOAT;\n+import static opengl.glut_h.C_INT;\n+import static opengl.glut_h.GLUT_DEPTH;\n+import static opengl.glut_h.GLUT_DOUBLE;\n+import static opengl.glut_h.GLUT_RGB;\n+import static opengl.glut_h.GL_AMBIENT;\n+import static opengl.glut_h.GL_COLOR_BUFFER_BIT;\n+import static opengl.glut_h.GL_COLOR_MATERIAL;\n+import static opengl.glut_h.GL_DEPTH_BUFFER_BIT;\n+import static opengl.glut_h.GL_DEPTH_TEST;\n+import static opengl.glut_h.GL_DIFFUSE;\n+import static opengl.glut_h.GL_FRONT;\n+import static opengl.glut_h.GL_LIGHT0;\n+import static opengl.glut_h.GL_LIGHTING;\n+import static opengl.glut_h.GL_LINEAR;\n+import static opengl.glut_h.GL_NEAREST;\n+import static opengl.glut_h.GL_ONE;\n+import static opengl.glut_h.GL_POSITION;\n+import static opengl.glut_h.GL_QUADS;\n+import static opengl.glut_h.GL_SHININESS;\n+import static opengl.glut_h.GL_SMOOTH;\n+import static opengl.glut_h.GL_SPECULAR;\n+import static opengl.glut_h.GL_SRC_ALPHA;\n+import static opengl.glut_h.GL_TEXTURE_2D;\n+import static opengl.glut_h.GL_TEXTURE_MAG_FILTER;\n+import static opengl.glut_h.GL_TEXTURE_MIN_FILTER;\n+import static opengl.glut_h.GL_UNSIGNED_BYTE;\n+import static opengl.glut_h.glActiveTexture;\n+import static opengl.glut_h.glBegin;\n+import static opengl.glut_h.glBindTexture;\n+import static opengl.glut_h.glBlendFunc;\n+import static opengl.glut_h.glClear;\n+import static opengl.glut_h.glClearColor;\n+import static opengl.glut_h.glColor3f;\n+import static opengl.glut_h.glDisable;\n+import static opengl.glut_h.glEnable;\n+import static opengl.glut_h.glEnd;\n+import static opengl.glut_h.glGenTextures;\n+import static opengl.glut_h.glLightfv;\n+import static opengl.glut_h.glLoadIdentity;\n+import static opengl.glut_h.glMaterialfv;\n+import static opengl.glut_h.glPopMatrix;\n+import static opengl.glut_h.glPushMatrix;\n+import static opengl.glut_h.glRotatef;\n+import static opengl.glut_h.glScalef;\n+import static opengl.glut_h.glShadeModel;\n+import static opengl.glut_h.glTexCoord2f;\n+import static opengl.glut_h.glTexImage2D;\n+import static opengl.glut_h.glTexParameteri;\n+import static opengl.glut_h.glVertex3f;\n+import static opengl.glut_h.glutCreateWindow;\n+import static opengl.glut_h.glutDisplayFunc;\n+import static opengl.glut_h.glutIdleFunc;\n+import static opengl.glut_h.glutInit;\n+import static opengl.glut_h.glutInitDisplayMode;\n+import static opengl.glut_h.glutInitWindowSize;\n+import static opengl.glut_h.glutMainLoop;\n+import static opengl.glut_h.glutPostRedisplay;\n+import static opengl.glut_h.glutSolidTeapot;\n+import static opengl.glut_h.glutSwapBuffers;\n+import static opengl.glut_h_2.GL_BLEND;\n+import static opengl.glut_h_2.GL_RGBA;\n+\n+public class GLWrap {\n+    public static class GLTexture {\n+        final Arena arena;\n+        final MemorySegment data;\n+        final int width;\n+        final int height;\n+        int idx;\n+        GLTexture(Arena arena, InputStream textureStream) {\n+            this.arena = arena;\n+            BufferedImage img = null;\n+            try {\n+                img = ImageIO.read(textureStream);\n+                this.width = img.getWidth();\n+                this.height = img.getHeight();\n+                BufferedImage image = new BufferedImage(width,height, BufferedImage.TYPE_4BYTE_ABGR_PRE);\n+                image.getGraphics().drawImage(img, 0, 0, null);\n+                var raster = image.getRaster();\n+                var dataBuffer = raster.getDataBuffer();\n+                data = arena.allocateFrom(C_CHAR, ((DataBufferByte) dataBuffer).getData());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class GLWindow {\n+        Arena arena;\n+        int width;\n+        int height;\n+        String name;\n+        GLTexture[] textures;\n+        MemorySegment textureBuf;\n+        GLWindow(Arena arena, int width, int height, String name, GLTexture... textures) {\n+            this.arena = arena;\n+            this.width = width;\n+            this.height = height;\n+            this.name = name;\n+            this.textures = textures;\n+            var argc = arena.allocateFrom(C_INT, 0);\n+            glutInit(argc, argc);\n+            glutInitDisplayMode(GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH());\n+            glutInitWindowSize(width, height);\n+            glutCreateWindow(arena.allocateFrom(\"NBODY!\"));\n+\n+            glClearColor(0f, 0f, 0f, 0f);\n+            \/\/ Setup Lighting see  https:\/\/www.khronos.org\/opengl\/wiki\/How_lighting_works\n+            glShadeModel(GL_SMOOTH());\n+            glEnable(GL_BLEND());\n+            glBlendFunc(GL_SRC_ALPHA(), GL_ONE());\n+            glEnable(GL_TEXTURE_2D());\n+            textureBuf = arena.allocate(C_INT, textures.length*C_INT.byteSize());\n+            glGenTextures(textures.length, textureBuf);\n+            int[] count = {0};\n+            Arrays.stream(textures).forEach(texture -> {\n+                texture.idx=count[0]++;\n+                glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, texture.idx * JAVA_INT.byteSize()));\n+                glTexImage2D(GL_TEXTURE_2D(), 0, GL_RGBA(), texture.width,\n+                        texture.height, 0, GL_RGBA(), GL_UNSIGNED_BYTE(), texture.data);\n+                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MAG_FILTER(), GL_LINEAR());\n+                glTexParameteri(GL_TEXTURE_2D(), GL_TEXTURE_MIN_FILTER(), GL_NEAREST());\n+            });\n+            var useLighting = false;\n+            if (useLighting) {\n+                glEnable(GL_LIGHTING());\n+\n+                var light = GL_LIGHT0(); \/\/ .... GL_LIGHT_0 .. -> 7\n+\n+                var pos = arena.allocateFrom(C_FLOAT, new float[]{0.0f, 15.0f, -15.0f, 0});\n+\n+                glLightfv(light, GL_POSITION(), pos);\n+\n+                var red_ambient_light = arena.allocateFrom(C_FLOAT, new float[]{1f, 0.0f, 0.0f, 0.0f});\n+\n+                var grey_diffuse_light = arena.allocateFrom(C_FLOAT, new float[]{1f, 1f, 1f, 0.0f});\n+\n+                var yellow_specular_light = arena.allocateFrom(C_FLOAT, new float[]{1.0f, 1.0f, 0.0f, 0.0f});\n+                glLightfv(light, GL_AMBIENT(), red_ambient_light);\n+                glLightfv(light, GL_DIFFUSE(), grey_diffuse_light);\n+                glLightfv(light, GL_SPECULAR(), yellow_specular_light);\n+\n+                var shini = arena.allocate(C_FLOAT, 113);\n+                glMaterialfv(GL_FRONT(), GL_SHININESS(), shini);\n+\n+                var useColorMaterials = false;\n+                if (useColorMaterials) {\n+                    glEnable(GL_COLOR_MATERIAL());\n+                } else {\n+                    glDisable(GL_COLOR_MATERIAL());\n+                }\n+                glEnable(light);\n+                glEnable(GL_DEPTH_TEST());\n+            } else {\n+                glDisable(GL_LIGHTING());\n+            }\n+            glutDisplayFunc(glutDisplayFunc$func.allocate(this::display, arena));\n+            glutIdleFunc(glutIdleFunc$func.allocate(this::onIdle, arena));\n+        }\n+        void display() {\n+            glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+            glPushMatrix();\n+            glLoadIdentity();\n+            glRotatef(0f, 0f,0f, 0f);\n+            \/\/glRotatef(rot, 0f, 1f, 0f);\n+            \/\/   glTranslatef(0f, 0f, trans);\n+            glScalef(.1f, .1f, 1);\n+\n+            glActiveTexture(textureBuf.get(ValueLayout.JAVA_INT, 0));\n+            glBindTexture(GL_TEXTURE_2D(), textureBuf.get(ValueLayout.JAVA_INT, 0));\n+            glColor3f(1f, 1f, 1f);\n+            glBegin(GL_QUADS());\n+            {\n+                float dx = -.5f;\n+                float dy = -.5f;\n+                float dz = -.5f;\n+                float x = 0f;\n+                float y= 0f;\n+                float z = 0f;\n+                    glTexCoord2f(0, 1);\n+                    glVertex3f(x + dx, y + dy + 1, z + dz);\n+                    glTexCoord2f(0, 0);\n+                    glVertex3f(x + dx, y + dy, z + dz);\n+                    glTexCoord2f(1, 0);\n+                    glVertex3f(x + dx + 1, y + dy, z + dz);\n+                    glTexCoord2f(1, 1);\n+                    glVertex3f(x + dx + 1, y + dy + 1, z + dz);\n+            }\n+            glEnd();\n+            glColor3f(0.8f, 0.1f, 0.1f);\n+            glutSolidTeapot(1d);\n+            glPopMatrix();\n+            glutSwapBuffers();\n+        }\n+\n+        void onIdle() {\n+            glutPostRedisplay();\n+        }\n+\n+        public void mainLoop() {\n+            glutMainLoop();\n+        }\n+    }\n+\n+\n+    public void main(String[] args) throws IOException {\n+        try (var arena = Arena.ofConfined()) {\n+            new GLWindow(arena, 800,800,\"name\",\n+                    new GLTexture(arena, GLWrap.class.getResourceAsStream(\"\/particle.png\"))\n+            ).mainLoop();\n+        }\n+    }\n+}\n+\n","filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/GLWrap.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -0,0 +1,347 @@\n+package nbody;\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ *   - Redistributions of source code must retain the above copyright\n+ *     notice, this list of conditions and the following disclaimer.\n+ *\n+ *   - Redistributions in binary form must reproduce the above copyright\n+ *     notice, this list of conditions and the following disclaimer in the\n+ *     documentation and\/or other materials provided with the distribution.\n+ *\n+ *   - Neither the name of Oracle nor the names of its\n+ *     contributors may be used to endorse or promote products derived\n+ *     from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n+ * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.stream.IntStream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static opengl.glut_h.GL_COLOR_BUFFER_BIT;\n+import static opengl.glut_h.GL_DEPTH_BUFFER_BIT;\n+import static opengl.glut_h.GL_QUADS;\n+import static opengl.glut_h.GL_TEXTURE_2D;\n+import static opengl.glut_h.glBegin;\n+import static opengl.glut_h.glBindTexture;\n+import static opengl.glut_h.glClear;\n+import static opengl.glut_h.glColor3f;\n+import static opengl.glut_h.glEnd;\n+import static opengl.glut_h.glLoadIdentity;\n+import static opengl.glut_h.glPopMatrix;\n+import static opengl.glut_h.glPushMatrix;\n+import static opengl.glut_h.glRotatef;\n+import static opengl.glut_h.glScalef;\n+import static opengl.glut_h.glTexCoord2f;\n+import static opengl.glut_h.glVertex3f;\n+import static opengl.glut_h.glutSwapBuffers;\n+import static opengl.glut_h_3.C_FLOAT;\n+\n+\n+public class Main{\n+public static class NBody extends GLWrap.GLWindow {\n+\n+    protected final float delT = .1f;\n+\n+    protected final float espSqr = 0.1f;\n+\n+    protected final float mass = .5f;\n+\n+\n+    private static int STRIDE = 4;\n+    private static int Xidx = 0;\n+    private static int Yidx = 1;\n+    private static int Zidx = 2;\n+\n+    final float[] xyzPos;\n+    final float[] xyzVel;\n+\n+    final GLWrap.GLTexture particle;\n+    final MemorySegment xyzPosSeg;\n+    final MemorySegment xyzVelSeg;\n+\n+    final CLWrap.Platform.Device.Context.Program.Kernel kernel;\n+\n+    int count;\n+    int frames = 0;\n+    long startTime = 0l;\n+\n+    public enum Mode {\n+        OpenCL(\"\"\"\n+                    __kernel void nbody( __global float *xyzPos ,__global float* xyzVel, float mass, float delT, float espSqr ){\n+                        int body = get_global_id(0);\n+                        int STRIDE=4;\n+                        int Xidx=0;\n+                        int Yidx=1;\n+                        int Zidx=2;\n+                        int bodyStride = body*STRIDE;\n+                        int bodyStrideX = bodyStride+Xidx;\n+                        int bodyStrideY = bodyStride+Yidx;\n+                        int bodyStrideZ = bodyStride+Zidx;\n+\n+                        float accx = 0.0;\n+                        float accy = 0.0;\n+                        float accz = 0.0;\n+                        float myPosx = xyzPos[bodyStrideX];\n+                        float myPosy = xyzPos[bodyStrideY];\n+                        float myPosz = xyzPos[bodyStrideZ];\n+                        for (int i = 0; i < get_global_size(0); i++) {\n+                            int iStride = i*STRIDE;\n+                            float dx = xyzPos[iStride+Xidx] - myPosx;\n+                            float dy = xyzPos[iStride+Yidx] - myPosy;\n+                            float dz = xyzPos[iStride+Zidx] - myPosz;\n+                            float invDist =  (float) 1.0\/sqrt((float)((dx * dx) + (dy * dy) + (dz * dz) + espSqr));\n+                            float s = mass * invDist * invDist * invDist;\n+                            accx = accx + (s * dx);\n+                            accy = accy + (s * dy);\n+                            accz = accz + (s * dz);\n+                        }\n+                        accx = accx * delT;\n+                        accy = accy * delT;\n+                        accz = accz * delT;\n+                        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * 0.5 * delT);\n+                        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * 0.5 * delT);\n+                        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * 0.5 * delT);\n+\n+                        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n+                        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n+                        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+\n+                    }\n+                    \"\"\"),\n+        OpenCL4(\"\"\"\n+                    __kernel void nbody( __global float4 *xyzPos ,__global float4* xyzVel, float mass, float delT, float espSqr ){\n+                        float4 acc = (0.0,0.0,0.0,0.0);\n+                        float4 myPos = xyzPos[get_global_id(0)];\n+                        float4 myVel = xyzVel[get_global_id(0)];\n+                        for (int i = 0; i < get_global_size(0); i++) {\n+                               float4 delta =  xyzPos[i] - myPos;\n+                               float invDist =  (float) 1.0\/sqrt((float)((delta.x * delta.x) + (delta.y * delta.y) + (delta.z * delta.z) + espSqr));\n+                               float s = mass * invDist * invDist * invDist;\n+                               acc= acc + (s * delta);\n+                        }\n+                        acc = acc*delT;\n+                        myPos = myPos + (myVel * delT) + (acc * delT)\/2;\n+                        myVel = myVel + acc;\n+                        xyzPos[get_global_id(0)] = myPos;\n+                        xyzVel[get_global_id(0)] = myVel;\n+\n+                    }\n+                    \"\"\"),\n+        JavaSeq(false),\n+        JavaMT(true);\n+        final public String code;\n+        final public boolean isOpenCL;\n+        final public boolean isJava;\n+        final public boolean isMultiThreaded;\n+        Mode(String code){\n+            this.code = code;\n+            this.isOpenCL = true;\n+            this.isJava = false;\n+            this.isMultiThreaded =false;\n+        }\n+        Mode(boolean isMultiThreaded){\n+            this.code = null;\n+            this.isOpenCL = false;\n+            this.isJava = true;\n+            this.isMultiThreaded = isMultiThreaded;\n+        }\n+    }\n+\n+    ;\n+    final Mode mode;\n+\n+    public NBody(Arena arena, int width, int height, GLWrap.GLTexture particle, int count, Mode mode) {\n+        super(arena, width, height, \"nbody\", particle);\n+        this.particle = particle;\n+        this.count = count;\n+        this.xyzPos = new float[count * STRIDE];\n+        this.xyzVel = new float[count * STRIDE];\n+        this.mode = mode;\n+        final float maxDist = 80f;\n+\n+        System.out.println(count + \" particles\");\n+\n+        for (int body = 0; body < count; body++) {\n+            final float theta = (float) (Math.random() * Math.PI * 2);\n+            final float phi = (float) (Math.random() * Math.PI * 2);\n+            final float radius = (float) (Math.random() * maxDist);\n+\n+            \/\/ get random 3D coordinates in sphere\n+            xyzPos[(body * STRIDE) + Xidx] = (float) (radius * Math.cos(theta) * Math.sin(phi));\n+            xyzPos[(body * STRIDE) + Yidx] = (float) (radius * Math.sin(theta) * Math.sin(phi));\n+            xyzPos[(body * STRIDE) + Zidx] = (float) (radius * Math.cos(phi));\n+            \/\/xyzPos[(body * STRIDE) + Widx] = (float) 0.0;\n+        }\n+        if (mode.isOpenCL) {\n+            xyzPosSeg = arena.allocateFrom(JAVA_FLOAT, xyzPos);\n+            xyzVelSeg = arena.allocateFrom(JAVA_FLOAT, xyzVel);\n+            CLWrap openCL = new CLWrap(arena);\n+\n+            CLWrap.Platform.Device[] selectedDevice = new CLWrap.Platform.Device[1];\n+            openCL.platforms.forEach(platform -> {\n+                System.out.println(\"Platform Name \" + platform.platformName());\n+                platform.devices.forEach(device -> {\n+                    System.out.println(\"   Compute Units     \" + device.computeUnits());\n+                    System.out.println(\"   Device Name       \" + device.deviceName());\n+                    System.out.println(\"   Built In Kernels  \" + device.builtInKernels());\n+                    selectedDevice[0] = device;\n+                });\n+            });\n+            var context = selectedDevice[0].createContext();\n+            var program = context.buildProgram(mode.code);\n+            kernel = program.getKernel(\"nbody\");\n+        }else{\n+            kernel = null;\n+            xyzPosSeg=null;\n+            xyzVelSeg=null;\n+        }\n+    }\n+\n+\n+    float rot = 0f;\n+\n+    public static void run(int body, int size, float[] xyzPos, float[] xyzVel, float mass, float delT, float espSqr) {\n+        float accx = 0.f;\n+        float accy = 0.f;\n+        float accz = 0.f;\n+        int bodyStride = body*STRIDE;\n+        int bodyStrideX = bodyStride+Xidx;\n+        int bodyStrideY = bodyStride+Yidx;\n+        int bodyStrideZ = bodyStride+Zidx;\n+\n+        final float myPosx = xyzPos[bodyStrideX];\n+        final float myPosy = xyzPos[bodyStrideY];\n+        final float myPosz = xyzPos[bodyStrideZ];\n+\n+        for (int i = 0; i < size; i++) {\n+            int iStride = i*STRIDE;\n+            int iStrideX = iStride+Xidx;\n+            int iStrideY = iStride+Yidx;\n+            int iStrideZ = iStride+Zidx;\n+            final float dx = xyzPos[iStrideX] - myPosx;\n+            final float dy = xyzPos[iStrideY] - myPosy;\n+            final float dz = xyzPos[iStrideZ] - myPosz;\n+            final float invDist = 1 \/ (float) Math.sqrt((dx * dx) + (dy * dy) + (dz * dz) + espSqr);\n+            final float s = mass * invDist * invDist * invDist;\n+            accx = accx + (s * dx);\n+            accy = accy + (s * dy);\n+            accz = accz + (s * dz);\n+        }\n+        accx = accx * delT;\n+        accy = accy * delT;\n+        accz = accz * delT;\n+        xyzPos[bodyStrideX] = myPosx + (xyzVel[bodyStrideX] * delT) + (accx * .5f * delT);\n+        xyzPos[bodyStrideY] = myPosy + (xyzVel[bodyStrideY] * delT) + (accy * .5f * delT);\n+        xyzPos[bodyStrideZ] = myPosz + (xyzVel[bodyStrideZ] * delT) + (accz * .5f * delT);\n+\n+        xyzVel[bodyStrideX] = xyzVel[bodyStrideX] + accx;\n+        xyzVel[bodyStrideY] = xyzVel[bodyStrideY] + accy;\n+        xyzVel[bodyStrideZ] = xyzVel[bodyStrideZ] + accz;\n+    }\n+\n+    void display() {\n+        if (startTime == 0) {\n+            startTime = System.currentTimeMillis();\n+        }\n+        glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+        glPushMatrix();\n+        glLoadIdentity();\n+        glRotatef(-rot \/ 2f, 0f, 0f, 1f);\n+        \/\/glRotatef(rot, 0f, 1f, 0f);\n+        \/\/   glTranslatef(0f, 0f, trans);\n+        glScalef(.01f, .01f, .01f);\n+        glColor3f(1f, 1f, 1f);\n+\n+        if (mode.isJava){\n+            if (mode.isMultiThreaded) {\n+                IntStream.range(0, count).parallel().forEach(\n+                        i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n+                );\n+            }else {\n+                IntStream.range(0, count).forEach(\n+                        i -> run(i, count, xyzPos, xyzVel, mass, delT, espSqr)\n+                );\n+            }\n+        } else {\n+            kernel.run(count,  xyzPosSeg, xyzVelSeg, mass, delT, espSqr);\n+        }\n+        glBegin(GL_QUADS());\n+        {\n+            glBindTexture(GL_TEXTURE_2D(), textureBuf.get(JAVA_INT, particle.idx * JAVA_INT.byteSize()));\n+            float dx = -.5f;\n+            float dy = -.5f;\n+            float dz = -.5f;\n+            for (int i = 0; i < count; i++) {\n+                float x = mode.isOpenCL ? xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Xidx * C_FLOAT.byteSize())) : xyzPos[(i * STRIDE) + Xidx];\n+                float y = mode.isOpenCL ? xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Yidx * C_FLOAT.byteSize())) : xyzPos[(i * STRIDE) + Yidx];\n+                float z = mode.isOpenCL ? xyzPosSeg.get(C_FLOAT, (i * STRIDE * C_FLOAT.byteSize()) + (Zidx * C_FLOAT.byteSize())) : xyzPos[(i * STRIDE) + Zidx];\n+                final int LEFT = 0;\n+                final int RIGHT = 1;\n+                final int TOP = 0;\n+                final int BOTTOM = 1;\n+                glTexCoord2f(LEFT, BOTTOM);\n+                glVertex3f(x + dx + LEFT, y + dy + BOTTOM, z + dz);\n+                glTexCoord2f(LEFT, TOP);\n+                glVertex3f(x + dx + LEFT, y + dy + TOP, z + dz);\n+                glTexCoord2f(RIGHT, TOP);\n+                glVertex3f(x + dx + RIGHT, y + dy + TOP, z + dz);\n+                glTexCoord2f(RIGHT, BOTTOM);\n+                glVertex3f(x + dx + RIGHT, y + dy + BOTTOM, z + dz);\n+            }\n+        }\n+        glEnd();\n+        glColor3f(0.8f, 0.1f, 0.1f);\n+        glPopMatrix();\n+        glutSwapBuffers();\n+        frames++;\n+        long elapsed = System.currentTimeMillis()-startTime;\n+        if (elapsed >200 || (frames % 100) == 0) {\n+            float secs = elapsed \/ 1000f;\n+            System.out.println((frames \/ secs) + \"fps\");\n+        }\n+    }\n+\n+    void onIdle() {\n+        rot += 1f;\n+        super.onIdle();\n+    }\n+}\n+\n+public void main(String[] args) throws IOException {\n+    int particleCount = args.length>2?Integer.parseInt(args[2]):32768;\n+    NBody.Mode mode = args.length>3?switch(args[3]){\n+        case \"OpenCL\" -> NBody.Mode.OpenCL;\n+        case \"JavaSeq\" -> NBody.Mode.JavaSeq;\n+        case \"JavaMT\" -> NBody.Mode.JavaMT;\n+        case \"OpenCL4\" -> NBody.Mode.OpenCL4;\n+        default -> throw new IllegalStateException(\"No mode \"+args[3]);\n+    }:NBody.Mode.OpenCL;\n+    System.out.println(\"mode\"+mode);\n+    try (var arena = Arena.ofConfined()) {\n+        var particleTexture = new GLWrap.GLTexture(arena, NBody.class.getResourceAsStream(\"\/particle.png\"));\n+        new NBody(arena, 1000, 1000, particleTexture, particleCount, mode).mainLoop();\n+    }\n+}\n+}\n+\n","filename":"hat\/hatless-examples\/nbody\/src\/main\/java\/nbody\/Main.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"filename":"hat\/hatless-examples\/nbody\/src\/main\/resources\/particle.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/* vim: set ft=java:\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static bldr.Bldr.*;\n+\n+\n+void main(String[] args) {\n+  var name = args[0];\n+  var argn=1;\n+  var hatDir = Dir.current();\n+  var buildDir = hatDir.existingBuildDir(\"build\");\n+  var hatlessExampleDir = hatDir.dir(\"hatless-examples\/\"+name);\n+  var source =hatlessExampleDir.sourceDir(\"src\/main\/java\");\n+  var resources =hatlessExampleDir.sourceDir(\"src\/main\/resources\");\n+  var opencl = buildDir.jarFile(\"jextracted-opencl.jar\");\n+  var opengl = buildDir.jarFile(\"jextracted-opengl.jar\");\n+\n+  var example = buildDir.jarFile(\"hatless-example\"+name+\".jar\");\n+\n+  java($->$\n+    .enable_preview()\n+    .start_on_first_thread()\n+    .enable_native_access(\"ALL-UNNAMED\")\n+    .class_path(opencl, opengl, example.create($$->$$\n+        .javac($$$->$$$\n+            .enable_preview()\n+            .source(24)\n+            .class_path(opencl, opengl)\n+            .source_path(source)\n+        )\n+        .dir_list(resources)\n+      )\n+    )\n+    .main_class(name+\".Main\")\n+    .args(Arrays.copyOfRange(args, argn, args.length))\n+  );\n+\n+}\n","filename":"hat\/hatlessrun","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}