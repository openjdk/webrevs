{"files":[{"patch":"@@ -0,0 +1,182 @@\n+package oracle.code.onnx;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.ClassType;\n+import jdk.incubator.code.type.FunctionType;\n+import jdk.incubator.code.type.MethodRef;\n+import jdk.incubator.code.type.VarType;\n+import oracle.code.onnx.compiler.OnnxTransformer;\n+\n+public record LambdaToFunc(OnnxTransformer.OnnxFuncOp func, int[] operandsMapping) {\n+\n+    static final boolean DEBUG = Boolean.getBoolean(\"oracle.code.onnx.OnnxRuntime.DEBUG\");\n+\n+    public static LambdaToFunc fromLambda(MethodHandles.Lookup l, CoreOp.LambdaOp lambda, Map<Value, Object> evaluatedValues) {\n+        evaluatedValues = new HashMap<>(evaluatedValues);\n+        \/\/ Shortcut for lambda expressions that call just one method\n+        if (singleMethodInvocation(lambda) instanceof\n+                SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping)) {\n+            Method m;\n+            try {\n+                m = iop.invokeDescriptor().resolveToMethod(l, iop.invokeKind());\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+\n+            var fOpt = Op.ofMethod(m);\n+            if (fOpt.isPresent()) {\n+                CoreOp.FuncOp f = Op.ofMethod(m).orElseThrow();\n+                var operands = iop.operands();\n+                var captured = lambda.capturedValues();\n+                var operandsMapping = new int[iop.operands().size()];\n+                var fParams = f.parameters();\n+                for (int i = 0; i < operandsMapping.length; i++) {\n+                    var opValue = valueMapping.get(operands.get(i));\n+                    operandsMapping[i] = captured.indexOf(opValue);\n+                    if (i == 0) {\n+                        var value = evaluatedValues.get(opValue);\n+                        if (value instanceof CoreOp.Var v) {\n+                            value = v.value();\n+                        }\n+                        if (value != null && !(value instanceof Tensor)) {\n+                            \/\/ @@@ probably a receiver\n+                            evaluatedValues.put(fParams.get(i), value);\n+                        }\n+                    }\n+                }\n+                if (DEBUG) {\n+                    System.out.println(f.toText());\n+                }\n+                OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, evaluatedValues, f);\n+                return new LambdaToFunc(onnxFunc, operandsMapping);\n+            }\n+        }\n+        var capturedValues = lambda.capturedValues();\n+        var functionType = FunctionType.functionType(lambda.invokableType().returnType(),\n+                capturedValues.stream().map(Value::type)\n+                        .map(t -> t instanceof VarType vt ? vt.valueType() : t).toList());\n+        CoreOp.FuncOp f = CoreOp.func(\"onnxCode\", functionType)\n+                .body(bb -> {\n+                    bb.context().mapValues(capturedValues, bb.parameters());\n+                    for (Op op : lambda.body().entryBlock().ops()) {\n+                        int i;\n+                        if (op instanceof CoreOp.VarAccessOp.VarLoadOp load &&\n+                                (i = capturedValues.indexOf(load.varOp().result())) >= 0) {\n+                            bb.context().mapValue(op.result(), bb.parameters().get(i)); \/\/ remap var load result to block param\n+                        } else {\n+                            bb.apply(op);\n+                        }\n+                    }\n+                });\n+        if (DEBUG) {\n+            System.out.println(f.toText());\n+        }\n+        OnnxTransformer.OnnxFuncOp onnxFunc = OnnxTransformer.transform(l, evaluatedValues, f);\n+\n+        var operandsMapping = new int[capturedValues.size()];\n+        for (int i = 0; i < operandsMapping.length; i++) {\n+            operandsMapping[i] = i;\n+        }\n+        return new LambdaToFunc(onnxFunc, operandsMapping);\n+    }\n+\n+    record SingleMethod(CoreOp.InvokeOp iop, Map<Value, Value> valueMapping) {}\n+    static SingleMethod singleMethodInvocation(CoreOp.LambdaOp lop) {\n+        \/\/ Single block\n+        if (lop.body().blocks().size() > 1) {\n+            return null;\n+        }\n+\n+        Map<Value, Value> valueMapping = new HashMap<>();\n+        CoreOp.InvokeOp methodRefInvokeOp = extractMethodInvoke(valueMapping, lop.body().entryBlock().ops());\n+        if (methodRefInvokeOp == null) {\n+            return null;\n+        }\n+\n+        return new SingleMethod(methodRefInvokeOp, valueMapping);\n+    }\n+\n+    static CoreOp.InvokeOp extractMethodInvoke(Map<Value, Value> valueMapping, List<Op> ops) {\n+        CoreOp.InvokeOp methodRefInvokeOp = null;\n+        for (Op op : ops) {\n+            switch (op) {\n+                case CoreOp.VarOp varOp -> {\n+                    if (isValueUsedWithOp(varOp.result(), o -> o instanceof CoreOp.VarAccessOp.VarStoreOp)) {\n+                        return null;\n+                    }\n+                }\n+                case CoreOp.VarAccessOp.VarLoadOp varLoadOp -> {\n+                    Value v = varLoadOp.varOp().result();\n+                    valueMapping.put(varLoadOp.result(), valueMapping.getOrDefault(v, v));\n+                }\n+                case CoreOp.InvokeOp iop when isBoxOrUnboxInvocation(iop) -> {\n+                    Value v = iop.operands().getFirst();\n+                    valueMapping.put(iop.result(), valueMapping.getOrDefault(v, v));\n+                }\n+                case CoreOp.InvokeOp iop -> {\n+                    if (methodRefInvokeOp != null) {\n+                        return null;\n+                    }\n+\n+                    for (Value o : iop.operands()) {\n+                        valueMapping.put(o, valueMapping.getOrDefault(o, o));\n+                    }\n+                    methodRefInvokeOp = iop;\n+                }\n+                case CoreOp.ReturnOp rop -> {\n+                    if (methodRefInvokeOp == null) {\n+                        return null;\n+                    }\n+                    Value r = rop.returnValue();\n+                    if (!(valueMapping.getOrDefault(r, r) instanceof Op.Result invokeResult)) {\n+                        return null;\n+                    }\n+                    if (invokeResult.op() != methodRefInvokeOp) {\n+                        return null;\n+                    }\n+                    assert methodRefInvokeOp.result().uses().size() == 1;\n+                }\n+                default -> {\n+                    return null;\n+                }\n+            }\n+        }\n+\n+        return methodRefInvokeOp;\n+    }\n+\n+    private static boolean isValueUsedWithOp(Value value, Predicate<Op> opPredicate) {\n+        for (Op.Result user : value.uses()) {\n+            if (opPredicate.test(user.op())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ @@@ Move to functionality on JavaType(s)\n+    static final Set<String> UNBOX_NAMES = Set.of(\n+            \"byteValue\",\n+            \"shortValue\",\n+            \"charValue\",\n+            \"intValue\",\n+            \"longValue\",\n+            \"floatValue\",\n+            \"doubleValue\",\n+            \"booleanValue\");\n+\n+    private static boolean isBoxOrUnboxInvocation(CoreOp.InvokeOp iop) {\n+        MethodRef mr = iop.invokeDescriptor();\n+        return mr.refType() instanceof ClassType ct && ct.unbox().isPresent() &&\n+                (UNBOX_NAMES.contains(mr.name()) || mr.name().equals(\"valueOf\"));\n+    }\n+}\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/LambdaToFunc.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -353,2 +353,2 @@\n-        int firstInitializer = params.size() - initializers.size();\n-        var args = params.subList(params.isEmpty() || params.getFirst().type() instanceof OnnxType.TensorType ? 0 : 1, firstInitializer);\n+        int first = params.size() - initializers.size();\n+        var args = params.isEmpty() || params.getFirst().type() instanceof OnnxType.TensorType ? params : params.subList(1, params.size());\n@@ -356,1 +356,1 @@\n-                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + firstInitializer)), initializers.get(i))).toList(),\n+                IntStream.range(0, initializers.size()).mapToObj(i -> tensorProto(indexer.getName(params.get(i + first)), initializers.get(i))).toList(),\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxProtoBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -16,1 +16,0 @@\n-import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -54,1 +53,3 @@\n-    static class CachedSessionClassValue extends ClassValue<Session> {\n+    record CachedSession(Session session, int[] operandsMapping) {}\n+\n+    static class CachedSessionClassValue extends ClassValue<CachedSession> {\n@@ -59,1 +60,1 @@\n-        Session computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n+        CachedSession computeIfAbsent(Class<?> lambdaClass, MethodHandles.Lookup l,  Quoted q) {\n@@ -71,8 +72,0 @@\n-        \/\/ @@@ heuristic assumption the first non-tensor and non-varbox captured value is receiver\n-        private static Object getReceiver(SequencedCollection<Object> values) {\n-            for (var v : values) {\n-                if (!(v instanceof Tensor || v instanceof CoreOp.Var)) return v;\n-            }\n-            return null;\n-        }\n-\n@@ -80,4 +73,5 @@\n-        protected Session computeValue(Class<?> type) {\n-            var trans = OnnxTransformer.ofLambda(l, (CoreOp.LambdaOp)q.op());\n-            var func = trans.transform();\n-            byte[] protobufModel = OnnxProtoBuilder.build(func.body().entryBlock(), trans.initializers(getReceiver(q.capturedValues().sequencedValues())));\n+        protected CachedSession computeValue(Class<?> type) {\n+            var mf = LambdaToFunc.fromLambda(l, (CoreOp.LambdaOp)q.op(), q.capturedValues());\n+\n+            List<Tensor> initializers = mf.func().initializers().stream().map(val -> (Tensor) val).toList();\n+            byte[] protobufModel = OnnxProtoBuilder.build(mf.func().func().body().entryBlock(), initializers);\n@@ -86,1 +80,1 @@\n-                System.out.println(func.toText());\n+                System.out.println(mf.func().func().toText());\n@@ -94,1 +88,1 @@\n-            return getInstance().createSession(\n+            return new CachedSession(getInstance().createSession(\n@@ -96,2 +90,1 @@\n-                    protobufModel);\n-\n+                    protobufModel), mf.operandsMapping());\n@@ -103,4 +96,0 @@\n-    public static <T> Tensor<T> execute(OnnxFunction<Tensor<T>> codeLambda) {\n-        return execute(MethodHandles.lookup(), codeLambda);\n-    }\n-\n@@ -117,1 +106,3 @@\n-        List<Tensor> arguments = q.capturedValues().sequencedValues().stream()\n+        var captured = q.capturedValues().sequencedValues().toArray();\n+        List<Tensor> arguments = IntStream.of(model.operandsMapping())\n+                .mapToObj(i -> captured[i])\n@@ -125,1 +116,2 @@\n-        return model.run(arena, arguments).getFirst();\n+\n+        return model.session.run(arena, arguments).getFirst();\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import oracle.code.onnx.Tensor;\n@@ -45,0 +46,1 @@\n+    static final TypeElement TENSOR_RAW_CLASS = JavaType.type(Tensor.class);\n@@ -47,1 +49,1 @@\n-    final Map<CoreOp.InvokeOp, List<Object>> evaluatedAttributes;\n+    Map<CoreOp.InvokeOp, List<Object>> evaluatedAttributes;\n@@ -51,1 +53,3 @@\n-    final Set<Op> unevaluatedOperations;\n+    Set<Op> unevaluatedOperations;\n+\n+    List<Object> initializers;\n@@ -56,0 +60,1 @@\n+        this.initializers = new ArrayList<>();\n@@ -59,2 +64,2 @@\n-    void evaluate(MethodHandles.Lookup l, T op) {\n-        var ev = new HashMap();\n+    void evaluate(MethodHandles.Lookup l, T op, Map<Value, Object> evaluatedValues) {\n+        var ev = new HashMap(evaluatedValues);\n@@ -204,2 +209,2 @@\n-\/\/        assert yieldContext == null ||\n-\/\/                yieldContext.b().parentBody() == entry.parentBody().parentOp().ancestorBody();\n+        assert yieldContext == null ||\n+                yieldContext.b().parentBody() == entry.parentBody().parentOp().ancestorBody();\n@@ -305,1 +310,1 @@\n-            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n+\/\/            assert o.operands().subList(0, inputs.size()).stream().noneMatch(oc::isValueDefined);\n@@ -319,0 +324,6 @@\n+            } else if (opClass == ExplicitOnnxOps.If.class) {\n+                \/\/ @@@ hard-coded 2 extra undeclared attributes\n+                List<Object> attrs = o.operands().subList(inputs.size(), inputs.size() + 2).stream()\n+                        .map(oc::getValue)\n+                        .toList();\n+                evaluatedAttributes.put(io, attrs);\n@@ -329,0 +340,12 @@\n+            unevaluatedOperations.add(o);\n+            return null;\n+        } else if (o instanceof CoreOp.FieldAccessOp.FieldLoadOp fo && fo.fieldDescriptor().type() instanceof ClassType ct && ct.rawType().equals(TENSOR_RAW_CLASS)) {\n+            try {\n+                if (fo.operands().isEmpty()) {\n+                    initializers.add(fo.fieldDescriptor().resolveToHandle(l).get());\n+                } else {\n+                    initializers.add(fo.fieldDescriptor().resolveToHandle(l).get(oc.getValue(fo.operands().getFirst())));\n+                }\n+            } catch (ReflectiveOperationException ex) {\n+                throw interpreterException(ex);\n+            }\n@@ -476,3 +499,1 @@\n-                interpretBody(l, lambdaOp.body(), oc, List.of());\n-                unevaluatedOperations.add(o);\n-                return null;\n+                return lambdaOp;\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxPartialEvaluator.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,6 +3,3 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.*;\n-import java.util.*;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.incubator.code.*;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.TypeElement;\n+import jdk.incubator.code.Value;\n@@ -13,0 +10,1 @@\n+import oracle.code.onnx.OnnxRuntime;\n@@ -17,0 +15,8 @@\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.code.*;\n+import oracle.code.onnx.LambdaToFunc;\n@@ -24,17 +30,1 @@\n-\n-    static final JavaType TENSOR_CLASS = JavaType.type(Tensor.class);\n-\n-    private final MethodHandles.Lookup l;\n-    private final CoreOp.FuncOp inputFunc;\n-    private final List<FieldRef> inits;\n-\n-    public static OnnxTransformer ofLambda(MethodHandles.Lookup lookup, CoreOp.LambdaOp lambda) {\n-        var qotableLambdaFunc = SSA.transform((CoreOp.FuncOp)lambda.ancestorBody().parentOp().ancestorBody().parentOp());\n-\n-        var flatLambdaFunc = CoreOp.func(qotableLambdaFunc.funcName(), FunctionType.functionType(lambda.invokableType().returnType(), qotableLambdaFunc.invokableType().parameterTypes())).body(bb -> {\n-            var cc  = bb.context();\n-            cc.mapValues(qotableLambdaFunc.parameters(), bb.parameters());\n-            qotableLambdaFunc.body().entryBlock().firstOp().bodies().getFirst().entryBlock().ops().getFirst().bodies().getFirst().entryBlock().ops().forEach(bb::apply);\n-        });\n-\n-        return new OnnxTransformer(lookup, flatLambdaFunc);\n+    private OnnxTransformer() {\n@@ -43,65 +33,1 @@\n-    public OnnxTransformer(MethodHandles.Lookup lookup, CoreOp.FuncOp func) {\n-        l = lookup;\n-\n-        var inlinedFunc = func.transform(OpTransformer.DROP_LOCATION_TRANSFORMER).transform((bb, op) -> {\n-            var cc  = bb.context();\n-            switch (op) {\n-                case CoreOp.InvokeOp io when resolve(io) instanceof CoreOp.FuncOp inline -> {\n-                    \/\/ @@@ inline the whole FuncOp with nested bodies\n-                    var entryBlock = inline.transform(OpTransformer.DROP_LOCATION_TRANSFORMER).body().entryBlock();\n-                    for (int i = 0; i < io.operands().size(); i++) {\n-                        var out = cc.getValue(io.operands().get(i));\n-                        cc.mapValue(entryBlock.parameters().get(i), cc.getValueOrDefault(out, out));\n-                    }\n-                    for (var o : entryBlock.ops()) {\n-                        if (o instanceof CoreOp.ReturnOp ro) {\n-                            cc.mapValue(io.result(), cc.getValue(ro.returnValue()));\n-                        } else {\n-                            bb.apply(o);\n-                        }\n-                    }\n-                }\n-                default -> bb.apply(op);\n-            }\n-            return bb;\n-        });\n-\n-        inits = new ArrayList<>();\n-        var top = new Block.Builder[1];\n-        \/\/ turning field loads into additiona arguments\n-        inputFunc = inlinedFunc.transform((bb, op) -> {\n-            if (top[0] == null) top[0] = bb;\n-            var cc  = bb.context();\n-            switch (op) {\n-                case CoreOp.FieldAccessOp.FieldLoadOp flo when op.resultType() instanceof ClassType ct && ct.rawType().equals(TENSOR_CLASS) -> {\n-                    inits.add(flo.fieldDescriptor());\n-                    \/\/ initializers turn into top block parameters\n-                    cc.mapValue(op.result(), top[0].parameter(op.resultType()));\n-                }\n-                default -> bb.apply(op);\n-            }\n-            return bb;\n-        });\n-    }\n-\n-    CoreOp.FuncOp resolve(CoreOp.InvokeOp io) {\n-        try {\n-            var res = Op.ofMethod(io.invokeDescriptor().resolveToDirectMethod(l));\n-            if (res.isPresent()) {\n-                return SSA.transform(res.get());\n-            }\n-        } catch (ReflectiveOperationException _) {}\n-        return null;\n-    }\n-\n-    public List<Tensor> initializers(Object receiver) {\n-        return inits.stream().map(i -> {\n-            try {\n-                return (Tensor)i.resolveToHandle(l).get(receiver);\n-            } catch (ReflectiveOperationException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }).toList();\n-    }\n-\n-    public CoreOp.FuncOp transform() {\n+    public record OnnxFuncOp(CoreOp.FuncOp func, List<Object> initializers) {}\n@@ -109,0 +35,1 @@\n+    public static OnnxFuncOp transform(MethodHandles.Lookup l, Map<Value, Object> evaluatedValues, CoreOp.FuncOp in) {\n@@ -110,1 +37,1 @@\n-        pe.evaluate(l, inputFunc);\n+        pe.evaluate(l, in, evaluatedValues);\n@@ -112,2 +39,3 @@\n-        FunctionType ft = FunctionType.functionType(type(inputFunc.invokableType().returnType()),\n-                inputFunc.invokableType().parameterTypes().stream().map(OnnxTransformer::type).toList()\n+        FunctionType ft = FunctionType.functionType(\n+                type(in.invokableType().returnType()),\n+                in.invokableType().parameterTypes().stream().map(OnnxTransformer::type).toList()\n@@ -115,54 +43,30 @@\n-        CoreOp.FuncOp onnxModel = CoreOp.func(inputFunc.funcName(), ft).body(b -> {\n-            b.transformBody(inputFunc.body(), b.parameters(), bodyTransformer(pe));\n-        });\n-\n-        var paramTypes = onnxModel.invokableType().parameterTypes();\n-\n-        CoreOp.FuncOp stripModel = onnxModel;\n-        if (!paramTypes.isEmpty() && !(paramTypes.getFirst() instanceof OnnxType.TensorType)) {\n-            \/\/ drop receiver\n-            stripModel = CoreOp.func(onnxModel.funcName(), FunctionType.functionType(onnxModel.invokableType().returnType(), paramTypes.subList(1, paramTypes.size()))).body(bb -> {\n-                bb.context().mapValues(onnxModel.parameters().subList(1, paramTypes.size()), bb.parameters());\n-                onnxModel.body().entryBlock().ops().forEach(bb::apply);\n-            });\n-        }\n-\n-        return SSA.transform(stripModel).transform((b, op) -> {\n-            \/\/ Drop any non-terminating operation whose result is not used\n-            if (op instanceof Op.Terminating || !op.result().uses().isEmpty()) {\n-                b.op(op);\n-            }\n-            return b;\n-        });\n-    }\n-\n-    OpTransformer bodyTransformer(OnnxPartialEvaluator pe) {\n-        return (bb, op) -> {\n-            if (!pe.unevaluatedOperations.contains(op)) {\n-                return bb;\n-            }\n-            switch (op) {\n-                \/\/ Transform invocation to ONNX operator to operation modeling the operator\n-                case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS) -> {\n-                    String operatorName = io.invokeDescriptor().name();\n-                    Class<? extends OnnxOp> opClass = onnxOpClassFromName(operatorName);\n-                    OnnxOp.OnnxSchema schema = schemaFromOnnxOpClass(opClass);\n-\n-                    List<Object> attributes = pe.evaluatedAttributes.get(io);\n-\n-                    Method opMethod = Stream.of(OnnxOps.class.getMethods())\n-                            .filter(m -> m.getName().equals(operatorName))\n-                            .findFirst().orElseThrow();\n-\n-                    List<Object> opArgs = new ArrayList<>();\n-\n-                    \/\/ @@@ Operator API currently requires all optional output parameters are required\n-                    if (schema.outputs().stream().anyMatch(p -> p.quantifier().isOptional())) {\n-                        opArgs.add(recordTypeToTupleType(l, (ClassType) op.resultType()));\n-                        Set<? extends OnnxOp.OnnxParameter> optionalOutputs = schema.outputs().stream()\n-                                .filter(p -> p.quantifier().isOptional())\n-                                .collect(Collectors.toSet());\n-                        opArgs.add(optionalOutputs);\n-                    } else {\n-                        opArgs.add(type(op.resultType()));\n-                    }\n+        CoreOp.FuncOp onnxModel = CoreOp.func(in.funcName(), ft).body(b -> {\n+            b.transformBody(in.body(), b.parameters(), (bb, op) -> {\n+                if (!pe.unevaluatedOperations.contains(op)) {\n+                    return bb;\n+                }\n+                switch (op) {\n+                    \/\/ Transform invocation to ONNX operator to operation modeling the operator\n+                    case CoreOp.InvokeOp io when io.invokeDescriptor().refType().equals(ONNX_OPERATORS_CLASS) -> {\n+                        String operatorName = io.invokeDescriptor().name();\n+                        Class<? extends OnnxOp> opClass = onnxOpClassFromName(operatorName);\n+                        OnnxOp.OnnxSchema schema = schemaFromOnnxOpClass(opClass);\n+\n+                        List<Object> attributes = pe.evaluatedAttributes.get(io);\n+\n+                        Method opMethod = Stream.of(OnnxOps.class.getMethods())\n+                                .filter(m -> m.getName().equals(operatorName))\n+                                .findFirst().orElseThrow();\n+\n+                        List<Object> opArgs = new ArrayList<>();\n+\n+                        \/\/ @@@ Operator API currently requires all optional output parameters are required\n+                        if (schema.outputs().stream().anyMatch(p -> p.quantifier().isOptional())) {\n+                            opArgs.add(recordTypeToTupleType(l, (ClassType) op.resultType()));\n+                            Set<? extends OnnxOp.OnnxParameter> optionalOutputs = schema.outputs().stream()\n+                                    .filter(p -> p.quantifier().isOptional())\n+                                    .collect(Collectors.toSet());\n+                            opArgs.add(optionalOutputs);\n+                        } else {\n+                            opArgs.add(type(op.resultType()));\n+                        }\n@@ -170,3 +74,3 @@\n-                    for (int i = 0; i < schema.inputs().size(); i++) {\n-                        OnnxOp.OnnxParameter p = schema.inputs().get(i);\n-                        Value v = io.operands().get(i);\n+                        for (int i = 0; i < schema.inputs().size(); i++) {\n+                            OnnxOp.OnnxParameter p = schema.inputs().get(i);\n+                            Value v = io.operands().get(i);\n@@ -174,14 +78,16 @@\n-                        switch (p.quantifier()) {\n-                            case REQUIRED -> {\n-                                opArgs.add(bb.context().getValue(v));\n-                            }\n-                            case OPTIONAL -> {\n-                                \/\/ Evaluation of expressions Optional.empty and Optional.of() with symbolic values\n-                                if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp optionalInvoke\n-                                        && optionalInvoke.invokeDescriptor().refType().equals(JavaType.type(Optional.class))) {\n-                                    switch (optionalInvoke.invokeDescriptor().name()) {\n-                                        case \"of\" -> {\n-                                            opArgs.add(Optional.of(bb.context().getValue(optionalInvoke.operands().getFirst())));\n-                                        }\n-                                        case \"empty\" -> {\n-                                            opArgs.add(Optional.empty());\n+                            switch (p.quantifier()) {\n+                                case REQUIRED -> {\n+                                    opArgs.add(bb.context().getValue(v));\n+                                }\n+                                case OPTIONAL -> {\n+                                    \/\/ Evaluation of expressions Optional.empty and Optional.of() with symbolic values\n+                                    if (v instanceof Op.Result r && r.op() instanceof CoreOp.InvokeOp optionalInvoke\n+                                            && optionalInvoke.invokeDescriptor().refType().equals(JavaType.type(Optional.class))) {\n+                                        switch (optionalInvoke.invokeDescriptor().name()) {\n+                                            case \"of\" -> {\n+                                                opArgs.add(Optional.of(bb.context().getValue(optionalInvoke.operands().getFirst())));\n+                                            }\n+                                            case \"empty\" -> {\n+                                                opArgs.add(Optional.empty());\n+                                            }\n+                                            default -> throw new UnsupportedOperationException();\n@@ -189,1 +95,2 @@\n-                                        default -> throw new UnsupportedOperationException();\n+                                    } else {\n+                                        throw new UnsupportedOperationException();\n@@ -191,1 +98,2 @@\n-                                } else {\n+                                }\n+                                case VARIADIC -> {\n@@ -195,2 +103,15 @@\n-                            case VARIADIC -> {\n-                                throw new UnsupportedOperationException();\n+                        }\n+                        opArgs.addAll(attributes.stream().map(a -> {\n+                            if (a instanceof CoreOp.LambdaOp lo) {\n+                                var ltf = LambdaToFunc.fromLambda(l, lo, evaluatedValues);\n+                                var cc = bb.context();\n+                                var lbb = Body.Builder.of(bb.parentBody(), lo.invokableType(), cc);\n+                                var eb = lbb.entryBlock();\n+                                var params = ltf.func().func().body().entryBlock().parameters();\n+                                var captured = lo.capturedValues();\n+                                for (int i = 0; i < params.size(); i++) {\n+                                    var param = params.get(i);\n+                                    cc.mapValue(param, eb.op(OnnxOps.Identity(param.type(), cc.getValue(traverseUp(captured.get(i))))));\n+                                }\n+                                ltf.func().func().body().entryBlock().ops().forEach(eb::apply);\n+                                return lbb;\n@@ -198,0 +119,8 @@\n+                            return a;\n+                        }).toList());\n+\n+                        OnnxOp onnxOp;\n+                        try {\n+                            onnxOp = (OnnxOp) opMethod.invoke(null, opArgs.toArray());\n+                        } catch (ReflectiveOperationException | RuntimeException e) {\n+                            throw new RuntimeException(e);\n@@ -199,0 +128,2 @@\n+                        Op.Result result = bb.op(onnxOp);\n+                        bb.context().mapValue(io.result(), result);\n@@ -200,7 +131,5 @@\n-                    opArgs.addAll(attributes);\n-                    if (opClass == ExplicitOnnxOps.If.class) {\n-                        \/\/ Explicit transformation of nested bodies\n-                        for (int i = 1; i < 3; i++) {\n-                            var lambda = (CoreOp.LambdaOp)(((Op.Result)op.operands().get(i)).op());\n-                            opArgs.add(lambda.body().transform(bb.context(), bodyTransformer(pe)));\n-                        }\n+                    \/\/ Transform access to the result of an operator that is a record access\n+                    case CoreOp.InvokeOp io when\n+                            recordComponentAccessToTupleIndex(l, io.invokeDescriptor()) instanceof Integer index -> {\n+                        Op.Result result = bb.op(CoreOp.tupleLoad(bb.context().getValue(io.operands().getFirst()), index));\n+                        bb.context().mapValue(io.result(), result);\n@@ -208,5 +137,2 @@\n-                    OnnxOp onnxOp;\n-                    try {\n-                        onnxOp = (OnnxOp) opMethod.invoke(null, opArgs.toArray());\n-                    } catch (ReflectiveOperationException | RuntimeException e) {\n-                        throw new RuntimeException(e);\n+                    case CoreOp.FieldAccessOp.FieldLoadOp fo when fo.fieldDescriptor().type() instanceof ClassType ct && ct.rawType().equals(TENSOR_RAW_CLASS) -> {\n+                        bb.context().mapValue(fo.result(), b.parameter(type(fo.resultType())));\n@@ -214,8 +140,2 @@\n-                    Op.Result result = bb.op(onnxOp);\n-                    bb.context().mapValue(io.result(), result);\n-                }\n-                \/\/ Transform access to the result of an operator that is a record access\n-                case CoreOp.InvokeOp io when\n-                        recordComponentAccessToTupleIndex(l, io.invokeDescriptor()) instanceof Integer index -> {\n-                    Op.Result result = bb.op(CoreOp.tupleLoad(bb.context().getValue(io.operands().getFirst()), index));\n-                    bb.context().mapValue(io.result(), result);\n+                    \/\/ Copy remaining operations, which may be removed later transformations\n+                    default -> bb.op(op);\n@@ -223,5 +143,8 @@\n-                \/\/ Skip nested lambdas\n-                case CoreOp.LambdaOp _ -> {\n-                }\n-                \/\/ Copy remaining operations, which may be removed later transformations\n-                default -> bb.op(op);\n+                return bb;\n+            });\n+        });\n+\n+        return new OnnxFuncOp(SSA.transform(onnxModel).transform((b, op) -> {\n+            \/\/ Drop any non-terminating operation whose result is not used\n+            if (op instanceof Op.Terminating || !op.result().uses().isEmpty()) {\n+                b.op(op);\n@@ -229,2 +152,7 @@\n-            return bb;\n-        };\n+            return b;\n+        }), pe.initializers);\n+    }\n+\n+    static Value traverseUp(Value v) {\n+        \/\/ @@@ when captured value is a VaroOp\n+        return v instanceof Op.Result or && or.op() instanceof CoreOp.VarOp vo && !vo.isUninitialized()? vo.initOperand() : v;\n@@ -235,0 +163,1 @@\n+        Class<? extends OnnxOp> opClass;\n@@ -336,0 +265,1 @@\n+\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":123,"deletions":193,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -48,0 +49,1 @@\n+import java.util.HashMap;\n@@ -49,1 +51,0 @@\n-import oracle.code.onnx.compiler.OnnxTransformer;\n@@ -325,2 +326,2 @@\n-            var onnxModel = new OnnxTransformer(MethodHandles.lookup(), f).transform();\n-            System.out.println(onnxModel.toText());\n+            var onnxModel = OnnxTransformer.transform(MethodHandles.lookup(), new HashMap<>(), f);\n+            System.out.println(onnxModel.func().toText());\n@@ -331,1 +332,1 @@\n-            Assertions.assertEquals(serialize(expectedOnnxModel), serialize(onnxModel));\n+            Assertions.assertEquals(serialize(expectedOnnxModel), serialize(onnxModel.func()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/CNNTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -21,1 +22,1 @@\n-                OnnxRuntime.execute(() -> add(a, a)));\n+                OnnxRuntime.execute(MethodHandles.lookup(), () -> add(a, a)));\n@@ -35,1 +36,1 @@\n-                OnnxRuntime.execute(() -> sub(a, b)));\n+                OnnxRuntime.execute(MethodHandles.lookup(), () -> sub(a, b)));\n@@ -48,1 +49,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> fconstant()));\n+        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> fconstant()));\n@@ -61,1 +62,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> fconstants()));\n+        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> fconstants()));\n@@ -74,1 +75,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> lconstant()));\n+        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> lconstant()));\n@@ -87,1 +88,1 @@\n-        assertEquals(expected, OnnxRuntime.execute(() -> lconstants()));\n+        assertEquals(expected, OnnxRuntime.execute(MethodHandles.lookup(), () -> lconstants()));\n@@ -101,1 +102,1 @@\n-                OnnxRuntime.execute(() -> reshapeAndShape(data, shape)));\n+                OnnxRuntime.execute(MethodHandles.lookup(), () -> reshapeAndShape(data, shape)));\n@@ -115,1 +116,1 @@\n-                OnnxRuntime.execute(() -> indicesOfMaxPool(x)));\n+                OnnxRuntime.execute(MethodHandles.lookup(), () -> indicesOfMaxPool(x)));\n@@ -131,1 +132,1 @@\n-        assertEquals(expFalse, OnnxRuntime.execute(() -> ifConst(condFalse)));\n+        assertEquals(expFalse, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifConst(condFalse)));\n@@ -134,1 +135,1 @@\n-        assertEquals(expTrue, OnnxRuntime.execute(() -> ifConst(condTrue)));\n+        assertEquals(expTrue, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifConst(condTrue)));\n@@ -140,1 +141,1 @@\n-        return OnnxOperators.If(cond, () -> OnnxOperators.Identity(falseValue), () -> OnnxOperators.Identity(trueValue));\n+        return OnnxOperators.If(cond, () -> OnnxOperators.Identity(falseValue), () -> trueValue);\n@@ -151,1 +152,1 @@\n-        assertEquals(expFalse, OnnxRuntime.execute(() -> ifCapture(condFalse, expTrue)));\n+        assertEquals(expFalse, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifCapture(condFalse, expTrue)));\n@@ -154,1 +155,1 @@\n-        assertEquals(expTrue, OnnxRuntime.execute(() -> ifCapture(condTrue, expTrue)));\n+        assertEquals(expTrue, OnnxRuntime.execute(MethodHandles.lookup(), () -> ifCapture(condTrue, expTrue)));\n@@ -168,32 +169,1 @@\n-                     OnnxRuntime.execute(() -> initialized()));\n-    }\n-\n-    final Tensor<Float> initialized2 = Tensor.ofFlat(33f);\n-    final Tensor<Float> initialized3 = Tensor.ofFlat(-1f);\n-    final Tensor<Float> initialized4 = Tensor.ofFlat(-99f);\n-\n-    @CodeReflection\n-    public Tensor<Float> ifInitialized(Tensor<Boolean> cond1, Tensor<Boolean> cond2) {\n-        return OnnxOperators.If(cond1,\n-                () -> OnnxOperators.If(cond2,\n-                        () -> OnnxOperators.Identity(initialized4),\n-                        () -> OnnxOperators.Identity(initialized3)),\n-                () -> OnnxOperators.If(cond2,\n-                        () -> OnnxOperators.Identity(initialized2),\n-                        () -> OnnxOperators.Identity(initialized)));\n-    }\n-\n-    @Test\n-    public void testIfInitialized() throws Exception {\n-        var condFalse = Tensor.ofScalar(false);\n-        var condTrue = Tensor.ofScalar(true);\n-\n-        assertEquals(initialized, ifInitialized(condTrue, condTrue));\n-        assertEquals(initialized, OnnxRuntime.execute(() -> ifInitialized(condTrue, condTrue)));\n-        assertEquals(initialized2, ifInitialized(condTrue, condFalse));\n-        assertEquals(initialized2, OnnxRuntime.execute(() -> ifInitialized(condTrue, condFalse)));\n-        assertEquals(initialized3, ifInitialized(condFalse, condTrue));\n-        assertEquals(initialized3, OnnxRuntime.execute(() -> ifInitialized(condFalse, condTrue)));\n-        assertEquals(initialized4, ifInitialized(condFalse, condFalse));\n-        assertEquals(initialized4, OnnxRuntime.execute(() -> ifInitialized(condFalse, condFalse)));\n-\n+                     OnnxRuntime.execute(MethodHandles.lookup(), () -> initialized()));\n","filename":"cr-examples\/onnx\/src\/test\/java\/oracle\/code\/onnx\/SimpleTest.java","additions":15,"deletions":45,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -904,5 +904,4 @@\n-\/\/ @@@ captured values of lambdas are not defined in the same tree\n-\/\/            if (!isReachable(v)) {\n-\/\/                throw new IllegalStateException(\n-\/\/                        String.format(\"Operand of operation %s is not defined in tree: %s\", op, v));\n-\/\/            }\n+            if (!isReachable(v)) {\n+                throw new IllegalStateException(\n+                        String.format(\"Operand of operation %s is not defined in tree: %s\", op, v));\n+            }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}