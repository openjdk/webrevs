{"files":[{"patch":"@@ -832,1 +832,1 @@\n-                            Class<?> intfClass = intfType.resolve(lookup);\n+                            Class<?> intfClass = (Class<?>)intfType.erasure().resolve(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-                    JavaType.ofNominalDescriptor(ovti.classSymbol());\n+                    JavaType.type(ovti.classSymbol());\n@@ -97,1 +97,1 @@\n-        return JavaType.ofNominalDescriptor(ce.asSymbol());\n+        return JavaType.type(ce.asSymbol());\n@@ -305,1 +305,1 @@\n-                        case ClassDesc v -> CoreOps.constant(JavaType.J_L_CLASS, JavaType.ofNominalDescriptor(v));\n+                        case ClassDesc v -> CoreOps.constant(JavaType.J_L_CLASS, JavaType.type(v));\n@@ -359,1 +359,1 @@\n-                                JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                                JavaType.type(inst.owner().asSymbol()),\n@@ -361,1 +361,1 @@\n-                                JavaType.ofNominalDescriptor(inst.typeSymbol()));\n+                                JavaType.type(inst.typeSymbol()));\n@@ -393,1 +393,1 @@\n-                            JavaType.ofNominalDescriptor(inst.owner().asSymbol()),\n+                            JavaType.type(inst.owner().asSymbol()),\n@@ -450,1 +450,1 @@\n-                            JavaType.ofNominalDescriptor(inst.componentType().asSymbol().arrayType()),\n+                            JavaType.type(inst.componentType().asSymbol().arrayType()),\n@@ -456,1 +456,1 @@\n-                                    JavaType.ofNominalDescriptor(inst.arrayType().asSymbol()),\n+                                    JavaType.type(inst.arrayType().asSymbol()),\n@@ -461,1 +461,1 @@\n-                    stack.push(op(CoreOps.cast(JavaType.ofNominalDescriptor(inst.type().asSymbol()), stack.pop())));\n+                    stack.push(op(CoreOps.cast(JavaType.type(inst.type().asSymbol()), stack.pop())));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/bytecode\/BytecodeLift.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -662,1 +662,1 @@\n-                return jt.resolve(l);\n+                return (Class<?>)jt.erasure().resolve(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/interpreter\/Interpreter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-        public static final JavaType QUOTED_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Quoted_CLASS_NAME));\n+        public static final JavaType QUOTED_TYPE = JavaType.type(ClassDesc.of(Quoted_CLASS_NAME));\n@@ -2287,1 +2287,1 @@\n-        TypeElement EXCEPTION_REGION_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(\"ExceptionRegion\"));\n+        TypeElement EXCEPTION_REGION_TYPE = JavaType.type(ExceptionRegion.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/CoreOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1260,1 +1260,1 @@\n-                JavaType iterable = type(type(Iterator.class), elementType);\n+                JavaType iterable = parameterized(type(Iterator.class), elementType);\n@@ -2395,1 +2395,1 @@\n-        JavaType PATTERN_BINDING_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+        JavaType PATTERN_BINDING_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n@@ -2397,1 +2397,1 @@\n-        JavaType PATTERN_RECORD_TYPE = JavaType.ofNominalDescriptor(ClassDesc.of(Pattern_CLASS_NAME +\n+        JavaType PATTERN_RECORD_TYPE = JavaType.type(ClassDesc.of(Pattern_CLASS_NAME +\n@@ -2401,1 +2401,1 @@\n-            return type(PATTERN_BINDING_TYPE, (JavaType) t);\n+            return parameterized(PATTERN_BINDING_TYPE, (JavaType) t);\n@@ -2405,1 +2405,1 @@\n-            return type(PATTERN_RECORD_TYPE, (JavaType) t);\n+            return parameterized(PATTERN_RECORD_TYPE, (JavaType) t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/op\/ExtendedOps.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Type;\n@@ -35,1 +40,0 @@\n-    static final String NAME = \"[\";\n@@ -43,0 +47,15 @@\n+    @Override\n+    public Type resolve(Lookup lookup) throws ReflectiveOperationException {\n+        Type resolvedComponent = componentType.resolve(lookup);\n+        if (resolvedComponent instanceof Class<?> resolvedComponentClass) {\n+            return Array.newInstance(resolvedComponentClass, 0).getClass();\n+        } else { \/\/ generic array\n+            return makeReflectiveGenericArray(resolvedComponent);\n+        }\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    private static GenericArrayType makeReflectiveGenericArray(Type component) {\n+\/*__throw new UnsupportedOperationException();__*\/        return sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl.make(component);\n+    }\n+\n@@ -50,0 +69,3 @@\n+    \/**\n+     * {@return the dimensions associated with this array type}\n+     *\/\n@@ -99,2 +121,2 @@\n-    public String toNominalDescriptorString() {\n-        return \"[\" + componentType.toNominalDescriptorString();\n+    public ClassDesc toNominalDescriptor() {\n+        return componentType.toNominalDescriptor().arrayType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n@@ -29,0 +33,1 @@\n+import java.util.ArrayList;\n@@ -38,1 +43,1 @@\n-    private final String type;\n+    private final ClassDesc type;\n@@ -42,1 +47,1 @@\n-    ClassType(String type) {\n+    ClassType(ClassDesc type) {\n@@ -46,4 +51,3 @@\n-    ClassType(String type, List<JavaType> typeArguments) {\n-        switch (type) {\n-            case \"boolean\", \"char\", \"byte\", \"short\", \"int\", \"long\",\n-                    \"float\", \"double\", \"void\" -> throw new IllegalArgumentException();\n+    ClassType(ClassDesc type, List<JavaType> typeArguments) {\n+        if (!type.isClassOrInterface()) {\n+            throw new IllegalArgumentException(\"Invalid base type: \" + type);\n@@ -55,0 +59,18 @@\n+    @Override\n+    public Type resolve(Lookup lookup) throws ReflectiveOperationException {\n+        Class<?> baseType = type.resolveConstantDesc(lookup);\n+        List<Type> resolvedTypeArgs = new ArrayList<>();\n+        for (JavaType typearg : typeArguments) {\n+            resolvedTypeArgs.add(typearg.resolve(lookup));\n+        }\n+        return resolvedTypeArgs.isEmpty() ?\n+                baseType :\n+                makeReflectiveParameterizedType(baseType,\n+                        resolvedTypeArgs.toArray(new Type[0]), baseType.getDeclaringClass()); \/\/ @@@: generic owner is erased here\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    private static ParameterizedType makeReflectiveParameterizedType(Class<?> base, Type[] typeArgs, Class<?> owner) {\n+\/*__throw new UnsupportedOperationException();__*\/        return sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(base, typeArgs, owner);\n+    }\n+\n@@ -61,1 +83,1 @@\n-        TypeDefinition td = new TypeDefinition(type, args);\n+        TypeDefinition td = new TypeDefinition(toClassName(), args);\n@@ -114,0 +136,4 @@\n+    \/**\n+     * {@return a class type whose base type is the same as this class type, but without any\n+     * type arguments}\n+     *\/\n@@ -118,0 +144,4 @@\n+    \/**\n+     * {@return {@code true} if this class type has a non-empty type argument list}\n+     * @see ClassType#typeArguments()\n+     *\/\n@@ -122,0 +152,3 @@\n+    \/**\n+     * {@return the type argument list associated with this class type}\n+     *\/\n@@ -131,0 +164,3 @@\n+    \/**\n+     * {@return a human-readable name for this class type}\n+     *\/\n@@ -132,5 +168,4 @@\n-        return type;\n-    }\n-\n-    public String toInternalName() {\n-        return toClassDescriptor(type);\n+        String pkg = type.packageName();\n+        return pkg.isEmpty() ?\n+                type.displayName() :\n+                String.format(\"%s.%s\", pkg, type.displayName());\n@@ -140,14 +175,2 @@\n-    public String toNominalDescriptorString() {\n-        return toBytecodeDescriptor(type);\n-    }\n-\n-    static String toBytecodeDescriptor(String type) {\n-        if (type.equals(\"null\")) {\n-            type = Object.class.getName();\n-        }\n-\n-        return \"L\" + type.replace('.', '\/') + \";\";\n-    }\n-\n-    static String toClassDescriptor(String type) {\n-        return type.replace('.', '\/');\n+    public ClassDesc toNominalDescriptor() {\n+        return type;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ClassType.java","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                default -> JavaType.ofNominalDescriptor(ClassDesc.of(identifier));\n+                default -> JavaType.type(ClassDesc.of(identifier));\n@@ -154,1 +154,1 @@\n-                t = JavaType.type(t, typeArguments);\n+                t = JavaType.parameterized(t, typeArguments);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/CoreTypeFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -30,0 +31,7 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n@@ -34,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -36,1 +45,13 @@\n- * The symbolic description of a Java type.\n+ * The symbolic description of a Java type. Java types can be classified as follows:\n+ * <ul>\n+ *     <li>{@linkplain PrimitiveType primitive types}, e.g. {@code int}, {@code void}<\/li>\n+ *     <li>{@linkplain ClassType class types}, e.g. {@code String}, {@code List<? extends Number>}<\/li>\n+ *     <li>{@linkplain ArrayType array types}, e.g. {@code Object[][]}, {@code List<Runnable>[]}<\/li>\n+ *     <li>{@linkplain WildcardType wildcard types}, e.g. {@code ? extends Number}, {@code ? super ArrayList<String>}<\/li>\n+ *     <li>{@linkplain TypeVarRef type-variables}, e.g. {@code T extends Runnable}<\/li>\n+ * <\/ul>\n+ * Java types can be constructed from either {@linkplain ClassDesc nominal descriptors} or\n+ * {@linkplain Type reflective type mirrors}. Conversely, Java types can be\n+ * {@linkplain #toNominalDescriptor() turned} into nominal descriptors,\n+ * or be {@linkplain #resolve(Lookup) resolved} into reflective type mirrors.\n+ * @sealedGraph\n@@ -41,2 +62,2 @@\n-    \/\/ @@@ Share with general void type?\n-    PrimitiveType VOID = new PrimitiveType(\"void\");\n+    \/** {@link JavaType} representing {@code void} *\/\n+    PrimitiveType VOID = new PrimitiveType(ConstantDescs.CD_void);\n@@ -44,1 +65,2 @@\n-    PrimitiveType BOOLEAN = new PrimitiveType(\"boolean\");\n+    \/** {@link JavaType} representing {@code boolean} *\/\n+    PrimitiveType BOOLEAN = new PrimitiveType(ConstantDescs.CD_boolean);\n@@ -46,1 +68,2 @@\n-    ClassType J_L_BOOLEAN = new ClassType(\"java.lang.Boolean\");\n+    \/** {@link JavaType} representing {@link Boolean} *\/\n+    ClassType J_L_BOOLEAN = new ClassType(ConstantDescs.CD_Boolean);\n@@ -48,0 +71,1 @@\n+    \/** {@link JavaType} representing {@code boolean[]} *\/\n@@ -50,1 +74,2 @@\n-    PrimitiveType BYTE = new PrimitiveType(\"byte\");\n+    \/** {@link JavaType} representing {@code byte} *\/\n+    PrimitiveType BYTE = new PrimitiveType(ConstantDescs.CD_byte);\n@@ -52,1 +77,2 @@\n-    ClassType J_L_BYTE = new ClassType(\"java.lang.Byte\");\n+    \/** {@link JavaType} representing {@link Byte} *\/\n+    ClassType J_L_BYTE = new ClassType(ConstantDescs.CD_Byte);\n@@ -54,0 +80,1 @@\n+    \/** {@link JavaType} representing {@code byte[]} *\/\n@@ -56,1 +83,2 @@\n-    PrimitiveType CHAR = new PrimitiveType(\"char\");\n+    \/** {@link JavaType} representing {@code char} *\/\n+    PrimitiveType CHAR = new PrimitiveType(ConstantDescs.CD_char);\n@@ -58,1 +86,2 @@\n-    ClassType J_L_CHARACTER = new ClassType(\"java.lang.Character\");\n+    \/** {@link JavaType} representing {@link Character} *\/\n+    ClassType J_L_CHARACTER = new ClassType(ConstantDescs.CD_Character);\n@@ -60,0 +89,1 @@\n+    \/** {@link JavaType} representing {@code char[]} *\/\n@@ -62,1 +92,2 @@\n-    PrimitiveType SHORT = new PrimitiveType(\"short\");\n+    \/** {@link JavaType} representing {@code short} *\/\n+    PrimitiveType SHORT = new PrimitiveType(ConstantDescs.CD_short);\n@@ -64,1 +95,2 @@\n-    ClassType J_L_SHORT = new ClassType(\"java.lang.Short\");\n+    \/** {@link JavaType} representing {@link Short} *\/\n+    ClassType J_L_SHORT = new ClassType(ConstantDescs.CD_Short);\n@@ -66,0 +98,1 @@\n+    \/** {@link JavaType} representing {@code short[]} *\/\n@@ -68,1 +101,2 @@\n-    PrimitiveType INT = new PrimitiveType(\"int\");\n+    \/** {@link JavaType} representing {@code int} *\/\n+    PrimitiveType INT = new PrimitiveType(ConstantDescs.CD_int);\n@@ -70,1 +104,2 @@\n-    ClassType J_L_INTEGER = new ClassType(\"java.lang.Integer\");\n+    \/** {@link JavaType} representing {@link Integer} *\/\n+    ClassType J_L_INTEGER = new ClassType(ConstantDescs.CD_Integer);\n@@ -72,0 +107,1 @@\n+    \/** {@link JavaType} representing {@code int[]} *\/\n@@ -74,1 +110,2 @@\n-    PrimitiveType LONG = new PrimitiveType(\"long\");\n+    \/** {@link JavaType} representing {@code long} *\/\n+    PrimitiveType LONG = new PrimitiveType(ConstantDescs.CD_long);\n@@ -76,1 +113,2 @@\n-    ClassType J_L_LONG = new ClassType(\"java.lang.Long\");\n+    \/** {@link JavaType} representing {@link Long} *\/\n+    ClassType J_L_LONG = new ClassType(ConstantDescs.CD_Long);\n@@ -78,0 +116,1 @@\n+    \/** {@link JavaType} representing {@code long[]} *\/\n@@ -80,1 +119,2 @@\n-    PrimitiveType FLOAT = new PrimitiveType(\"float\");\n+    \/** {@link JavaType} representing {@code float} *\/\n+    PrimitiveType FLOAT = new PrimitiveType(ConstantDescs.CD_float);\n@@ -82,1 +122,2 @@\n-    ClassType J_L_FLOAT = new ClassType(\"java.lang.Float\");\n+    \/** {@link JavaType} representing {@link Float} *\/\n+    ClassType J_L_FLOAT = new ClassType(ConstantDescs.CD_Float);\n@@ -84,0 +125,1 @@\n+    \/** {@link JavaType} representing {@code float[]} *\/\n@@ -86,1 +128,2 @@\n-    PrimitiveType DOUBLE = new PrimitiveType(\"double\");\n+    \/** {@link JavaType} representing {@code double} *\/\n+    PrimitiveType DOUBLE = new PrimitiveType(ConstantDescs.CD_double);\n@@ -88,1 +131,2 @@\n-    ClassType J_L_DOUBLE = new ClassType(\"java.lang.Double\");\n+    \/** {@link JavaType} representing {@link Double} *\/\n+    ClassType J_L_DOUBLE = new ClassType(ConstantDescs.CD_Double);\n@@ -90,0 +134,1 @@\n+    \/** {@link JavaType} representing {@code double[]} *\/\n@@ -92,1 +137,2 @@\n-    ClassType J_L_OBJECT = new ClassType(\"java.lang.Object\");\n+    \/** {@link JavaType} representing {@link Object} *\/\n+    ClassType J_L_OBJECT = new ClassType(ConstantDescs.CD_Object);\n@@ -94,0 +140,1 @@\n+    \/** {@link JavaType} representing {@link Object[]} *\/\n@@ -96,1 +143,2 @@\n-    ClassType J_L_CLASS = new ClassType(\"java.lang.Class\");\n+    \/** {@link JavaType} representing {@link Class} *\/\n+    ClassType J_L_CLASS = new ClassType(ConstantDescs.CD_Class);\n@@ -98,1 +146,2 @@\n-    ClassType J_L_STRING = new ClassType(\"java.lang.String\");\n+    \/** {@link JavaType} representing {@link String} *\/\n+    ClassType J_L_STRING = new ClassType(ConstantDescs.CD_String);\n@@ -100,5 +149,2 @@\n-    ClassType J_L_STRING_TEMPLATE = new ClassType(\"java.lang.StringTemplate\");\n-\n-    ClassType J_L_STRING_TEMPLATE_PROCESSOR = new ClassType(\"java.lang.StringTemplate$Processor\");\n-\n-    ClassType J_U_LIST = new ClassType(\"java.util.List\");\n+    \/** {@link JavaType} representing {@link List} *\/\n+    ClassType J_U_LIST = new ClassType(ConstantDescs.CD_List);\n@@ -108,0 +154,13 @@\n+    \/**\n+     * {@return the basic type associated with this Java type}. A basic type is one of the following\n+     * types:\n+     * <ul>\n+     *     <li>{@link JavaType#VOID}<\/li>\n+     *     <li>{@link JavaType#INT}<\/li>\n+     *     <li>{@link JavaType#LONG}<\/li>\n+     *     <li>{@link JavaType#FLOAT}<\/li>\n+     *     <li>{@link JavaType#DOUBLE}<\/li>\n+     *     <li>{@link JavaType#J_L_OBJECT}<\/li>\n+     * <\/ul>\n+     *\n+     *\/\n@@ -110,0 +169,4 @@\n+    \/**\n+     * {@return the nominal descriptor associated with this Java type}\n+     *\/\n+    ClassDesc toNominalDescriptor();\n@@ -111,9 +174,7 @@\n-    String toNominalDescriptorString();\n-\n-    default ClassDesc toNominalDescriptor() {\n-        return ClassDesc.ofDescriptor(toNominalDescriptorString());\n-    }\n-\n-    default Class<?> resolve(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        return (Class<?>) toNominalDescriptor().resolveConstantDesc(l);\n-    }\n+    \/**\n+     * Resolve this Java type to a reflective type mirror.\n+     * @param lookup the lookup used to create the reflective type mirror\n+     * @return a reflective type mirror for this type\n+     * @throws ReflectiveOperationException if this Java type cannot be resolved\n+     *\/\n+    Type resolve(MethodHandles.Lookup lookup) throws ReflectiveOperationException;\n@@ -128,27 +189,17 @@\n-    static JavaType type(Class<?> c) {\n-        if (c.isPrimitive()) {\n-            return new PrimitiveType(c.getName());\n-        } else if (c.isArray()) {\n-            return array(type(c.getComponentType()));\n-        } else {\n-            return new ClassType(c.getName());\n-        }\n-    }\n-\n-    static JavaType type(Class<?> c, Class<?>... typeArguments) {\n-        return type(c, List.of(typeArguments));\n-    }\n-\n-    static JavaType type(Class<?> c, List<Class<?>> typeArguments) {\n-        if (c.isPrimitive()) {\n-            throw new IllegalArgumentException(\"Cannot parameterize a primitive type\");\n-        } else if (c.isArray()) {\n-            return array(type(c.getComponentType(), typeArguments));\n-        } else {\n-            return new ClassType(c.getName(),\n-                    typeArguments.stream().map(JavaType::type).toList());\n-        }\n-    }\n-\n-    static JavaType ofNominalDescriptor(ClassDesc d) {\n-        return ofNominalDescriptorStringInternal(d.descriptorString(), 0);\n+    \/**\n+     * Constructs a Java type from a reflective type mirror.\n+     *\n+     * @param reflectiveType the reflective type mirror\n+     *\/\n+    static JavaType type(Type reflectiveType) {\n+        return switch (reflectiveType) {\n+            case Class<?> c -> type(c.describeConstable().get());\n+            case ParameterizedType pt -> parameterized(type(pt.getRawType()),\n+                    Stream.of(pt.getActualTypeArguments()).map(JavaType::type).toList());\n+            case java.lang.reflect.WildcardType wt -> wt.getLowerBounds().length == 0 ?\n+                    wildcard(BoundKind.EXTENDS, type(wt.getUpperBounds()[0])) :\n+                    wildcard(BoundKind.SUPER, type(wt.getLowerBounds()[0]));\n+            case TypeVariable<?> tv -> typeVarRef(tv.getName(), owner(tv.getGenericDeclaration()), type(tv.getBounds()[0]));\n+            case GenericArrayType at -> array(type(at.getGenericComponentType()));\n+            default -> throw new InternalError();\n+        };\n@@ -157,2 +208,6 @@\n-    static JavaType ofNominalDescriptorString(String d) {\n-        return ofNominalDescriptor(ClassDesc.ofDescriptor(d));\n+    private static TypeVarRef.Owner owner(GenericDeclaration genDecl) {\n+        return switch (genDecl) {\n+            case Executable e -> MethodRef.method(e);\n+            case Class<?> t -> (ClassType)type(t);\n+            default -> throw new InternalError();\n+        };\n@@ -161,5 +216,8 @@\n-    private static JavaType ofNominalDescriptorStringInternal(String descriptor, int i) {\n-        if (descriptor.charAt(i) == '[') {\n-            return new ArrayType(ofNominalDescriptorStringInternal(descriptor, i + 1));\n-        } else {\n-            return switch (descriptor.charAt(i)) {\n+    \/**\n+     * Constructs a Java type from a nominal descriptor.\n+     *\n+     * @param desc the nominal descriptor\n+     *\/\n+    static JavaType type(ClassDesc desc) {\n+        if (desc.isPrimitive()) {\n+            return switch (desc.descriptorString().charAt(0)) {\n@@ -175,5 +233,0 @@\n-                case 'L' -> {\n-                    \/\/ La.b.c.Class;\n-                    String typeName = descriptor.substring(i + 1, descriptor.length() - 1).replace('\/', '.');\n-                    yield new ClassType(typeName);\n-                }\n@@ -182,0 +235,5 @@\n+        } else if (desc.isArray()) {\n+            return array(type(desc.componentType()));\n+        } else {\n+            \/\/ class\n+            return new ClassType(desc, List.of());\n@@ -185,2 +243,12 @@\n-    static JavaType type(JavaType t, JavaType... typeArguments) {\n-        return type(t, List.of(typeArguments));\n+    \/**\n+     * Constructs a parameterized class type.\n+     *\n+     * @param type the base type of the parameterized type\n+     * @param typeArguments the type arguments of the parameterized type\n+     * @return a parameterized class type\n+     * @throws IllegalArgumentException if {@code type} is not a {@linkplain ClassType class type}\n+     * @throws IllegalArgumentException if {@code type} is {@linkplain ClassType class type} with\n+     * a non-empty {@linkplain ClassType#typeArguments() type argument list}.\n+     *\/\n+    static ClassType parameterized(JavaType type, JavaType... typeArguments) {\n+        return parameterized(type, List.of(typeArguments));\n@@ -189,6 +257,18 @@\n-    static JavaType type(JavaType t, List<JavaType> typeArguments) {\n-        return switch (t) {\n-            case ArrayType at -> array(type(at.componentType(), typeArguments));\n-            case ClassType ct when !ct.hasTypeArguments() -> new ClassType(ct.toClassName(), typeArguments);\n-            default -> throw new IllegalArgumentException(\"Cannot parameterize type: \" + t);\n-        };\n+    \/**\n+     * Constructs a parameterized class type.\n+     *\n+     * @param type the base type of the parameterized type\n+     * @param typeArguments the type arguments of the parameterized type\n+     * @return a parameterized class type\n+     * @throws IllegalArgumentException if {@code type} is not a {@linkplain ClassType class type}\n+     * @throws IllegalArgumentException if {@code type} is {@linkplain ClassType class type} with\n+     * a non-empty {@linkplain ClassType#typeArguments() type argument list}.\n+     *\/\n+    static ClassType parameterized(JavaType type, List<JavaType> typeArguments) {\n+        if (!(type instanceof ClassType ct)) {\n+            throw new IllegalArgumentException(\"Not a class type: \" + type);\n+        }\n+        if (ct.hasTypeArguments()) {\n+            throw new IllegalArgumentException(\"Already parameterized: \" + type);\n+        }\n+        return new ClassType(type.toNominalDescriptor(), typeArguments);\n@@ -256,0 +336,5 @@\n+    \/**\n+     * Constructs a Java type from a string representation.\n+     * @param s string representation\n+     * @return a Java type corresponding to the provided string representation\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/JavaType.java","additions":168,"deletions":83,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Constructor;\n@@ -72,2 +73,4 @@\n-    static MethodRef method(Method m) {\n-        return method(m.getDeclaringClass(), m.getName(), m.getReturnType(), m.getParameterTypes());\n+    static MethodRef method(Executable e) {\n+        return method(e.getDeclaringClass(), e.getName(),\n+                e instanceof Method m ? m.getReturnType() : e.getDeclaringClass(),\n+                e.getParameterTypes());\n@@ -112,2 +115,2 @@\n-                JavaType.ofNominalDescriptor(d.returnType()),\n-                d.parameterList().stream().map(JavaType::ofNominalDescriptor).toList());\n+                JavaType.type(d.returnType()),\n+                d.parameterList().stream().map(JavaType::type).toList());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/MethodRef.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,3 @@\n-import java.lang.reflect.code.TypeElement;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Type;\n@@ -38,1 +40,1 @@\n-    private final String type;\n+    private final ClassDesc type;\n@@ -40,1 +42,1 @@\n-    PrimitiveType(String type) {\n+    PrimitiveType(ClassDesc type) {\n@@ -44,0 +46,5 @@\n+    @Override\n+    public Type resolve(Lookup lookup) throws ReflectiveOperationException {\n+        return type.resolveConstantDesc(lookup);\n+    }\n+\n@@ -46,1 +53,1 @@\n-        return new TypeDefinition(type, List.of());\n+        return new TypeDefinition(type.displayName(), List.of());\n@@ -76,2 +83,1 @@\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        return switch (bytecodeKind) {\n+        return switch (type.descriptorString().charAt(0)) {\n@@ -106,2 +112,2 @@\n-    public String toNominalDescriptorString() {\n-        return toBytecodeDescriptor(type);\n+    public ClassDesc toNominalDescriptor() {\n+        return type;\n@@ -110,19 +116,5 @@\n-    static String toBytecodeDescriptor(String type) {\n-        Character bytecodeKind = PRIMITIVE_TYPE_MAP.get(type);\n-        return bytecodeKind.toString();\n-    }\n-\n-    static Map<String, Character> PRIMITIVE_TYPE_MAP;\n-\n-    static {\n-        PRIMITIVE_TYPE_MAP = Map.of(\n-                \"boolean\", 'Z',\n-                \"byte\", 'B',\n-                \"short\", 'S',\n-                \"char\", 'C',\n-                \"int\", 'I',\n-                \"long\", 'J',\n-                \"float\", 'F',\n-                \"double\", 'D',\n-                \"void\", 'V'\n-        );\n+    \/**\n+     * {@return {@code true} if this type is {@link JavaType#VOID}}\n+     *\/\n+    public boolean isVoid() {\n+        return toBasicType() == JavaType.VOID;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/PrimitiveType.java","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n@@ -29,1 +34,0 @@\n-import java.util.Optional;\n@@ -46,0 +50,20 @@\n+    @Override\n+    public Type resolve(Lookup lookup) throws ReflectiveOperationException {\n+        TypeVariable<?>[] typeVariables = switch (owner) {\n+            case MethodRef methodRef -> {\n+                Executable method = ((MethodRef)owner).resolveToMember(lookup);\n+                yield method.getTypeParameters();\n+            }\n+            case JavaType type -> {\n+                Class<?> erasedDecl = (Class<?>)type.resolve(lookup);\n+                yield erasedDecl.getTypeParameters();\n+            }\n+        };\n+        for (TypeVariable<?> tv : typeVariables) {\n+            if (tv.getName().equals(name)) {\n+                return tv;\n+            }\n+        }\n+        throw new ReflectiveOperationException(\"Type-variable not found: \" + name);\n+    }\n+\n@@ -98,1 +122,1 @@\n-        throw new UnsupportedOperationException(\"Type var\");\n+        return erasure().toBasicType();\n@@ -102,2 +126,2 @@\n-    public String toNominalDescriptorString() {\n-        throw new UnsupportedOperationException(\"Type var\");\n+    public ClassDesc toNominalDescriptor() {\n+        return erasure().toNominalDescriptor();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/TypeVarRef.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Type;\n@@ -44,0 +47,14 @@\n+    @Override\n+    public Type resolve(Lookup lookup) throws ReflectiveOperationException {\n+        Type[] upperBounds = kind == BoundKind.EXTENDS ?\n+                new Type[] { boundType.resolve(lookup) } : new Type[] { Object.class };\n+        Type[] lowerBounds = kind == BoundKind.SUPER ?\n+                new Type[] { boundType.resolve(lookup) } : new Type[0];\n+        return makeReflectiveWildcard(upperBounds, lowerBounds);\n+    }\n+\n+    \/\/ Copied code in jdk.compiler module throws UOE\n+    private static java.lang.reflect.WildcardType makeReflectiveWildcard(Type[] upper, Type[] lower) {\n+\/*__throw new UnsupportedOperationException();__*\/        return sun.reflect.generics.reflectiveObjects.WildcardTypeImpl.make(upper, lower);\n+    }\n+\n@@ -93,1 +110,1 @@\n-    public String toNominalDescriptorString() {\n+    public ClassDesc toNominalDescriptor() {\n@@ -97,0 +114,3 @@\n+    \/**\n+     * The bound kind of a wildcard type.\n+     *\/\n@@ -98,0 +118,1 @@\n+        \/** A bound kind representing a {@code ? extends} wildcard type*\/\n@@ -99,0 +120,1 @@\n+        \/** A bound kind representing a {@code ? super} wildcard type*\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/WildcardType.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-            return jt.resolve(l);\n+            return (Class<?>)jt.resolve(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/FieldRefImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-            return jt.resolve(l);\n+            return (Class<?>)jt.resolve(l);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/impl\/MethodRefImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-        JavaType mapType = type(J_U_MAP, keyType, valueType);\n+        JavaType mapType = parameterized(J_U_MAP, keyType, valueType);\n@@ -354,1 +354,1 @@\n-        JavaType listType = type(J_U_LIST, elementType);\n+        JavaType listType = parameterized(J_U_LIST, elementType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/writer\/OpBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    private WildcardTypeImpl(FieldTypeSignature[] ubs,\n-                             FieldTypeSignature[] lbs,\n+    private WildcardTypeImpl(Object[] ubs,\n+                             Object[] lbs,\n@@ -80,0 +80,11 @@\n+    \/**\n+     * Eager factory method.\n+     * @param ubs - an array of types representing the upper bounds\n+     * @param lbs - an array of types representing the lower bounds\n+     * @return a wild card type with the requested bounds\n+     *\/\n+    public static WildcardTypeImpl make(Type[] ubs,\n+                                        Type[] lbs) {\n+        return new WildcardTypeImpl(ubs, lbs, null);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/generics\/reflectiveObjects\/WildcardTypeImpl.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.tools.javac.code.Type.IntersectionClassType;\n@@ -42,1 +41,0 @@\n-import com.sun.tools.javac.code.Type.UnionClassType;\n@@ -2272,1 +2270,1 @@\n-                    yield JavaType.type(JavaType.ofNominalDescriptor(ClassDesc.of(t.tsym.flatName().toString())), typeArguments);\n+                    yield JavaType.parameterized(JavaType.type(ClassDesc.of(t.tsym.flatName().toString())), typeArguments);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ReflectMethods.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-                return ((JavaType) typeElement).resolve(lookup);\n+                return (Class<?>)((JavaType) typeElement).erasure().resolve(lookup);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/CoreBinaryOpsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+        assertEquals(typeAndErasure.type.toBasicType(), typeAndErasure.erasure.toBasicType());\n+        assertEquals(typeAndErasure.type.toNominalDescriptor(), typeAndErasure.erasure.toNominalDescriptor());\n@@ -88,1 +90,1 @@\n-                genericTypes.add(new TypeAndErasure(JavaType.type(LIST, arg), LIST));\n+                genericTypes.add(new TypeAndErasure(JavaType.parameterized(LIST, arg), LIST));\n@@ -95,1 +97,1 @@\n-                genericTypes.add(new TypeAndErasure(JavaType.type(LIST, arg), LIST));\n+                genericTypes.add(new TypeAndErasure(JavaType.parameterized(LIST, arg), LIST));\n@@ -105,0 +107,1 @@\n+                if (t.type.isVoid() continue; \/\/ void is not a valid array component type\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestErasure.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            TypeElement resultType = JavaType.type(JavaType.type(Stream.class), (JavaType) elementType());\n+            TypeElement resultType = JavaType.parameterized(JavaType.type(Stream.class), (JavaType) elementType());\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import static java.lang.reflect.code.type.JavaType.parameterized;\n@@ -61,1 +62,1 @@\n-        JavaType queryableType = type(Queryable.TYPE, elementType);\n+        JavaType queryableType = parameterized(Queryable.TYPE, elementType);\n@@ -79,1 +80,1 @@\n-        JavaType resultType = type(type(Stream.class), elementType());\n+        JavaType resultType = parameterized(type(Stream.class), elementType());\n@@ -92,1 +93,1 @@\n-        JavaType queryResultType = JavaType.type(QueryResult.TYPE, resultType);\n+        JavaType queryResultType = parameterized(QueryResult.TYPE, resultType);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import static java.lang.reflect.code.type.JavaType.parameterized;\n@@ -60,1 +61,1 @@\n-            JavaType queryableType = type(Queryable.TYPE, elementType);\n+            JavaType queryableType = parameterized(Queryable.TYPE, elementType);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/TestQueryProvider.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import static java.lang.reflect.code.type.JavaType.parameterized;\n@@ -48,1 +49,1 @@\n-        JavaType listType = type(type(List.class), elementType);\n+        JavaType listType = parameterized(type(List.class), elementType);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static java.lang.reflect.code.type.JavaType.parameterized;\n@@ -63,1 +64,1 @@\n-        JavaType listType = type(type(List.class), elementType);\n+        JavaType listType = parameterized(type(List.class), elementType);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n@@ -31,0 +36,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n@@ -65,2 +73,2 @@\n-        Assert.assertEquals(jt.toNominalDescriptorString(), bcd);\n-        Assert.assertEquals(jt, JavaType.ofNominalDescriptorString(bcd));\n+        Assert.assertEquals(jt.toNominalDescriptor().descriptorString(), bcd);\n+        Assert.assertEquals(jt, JavaType.type(ClassDesc.ofDescriptor(bcd)));\n@@ -141,0 +149,139 @@\n+\n+    @Test(dataProvider = \"classDescs\")\n+    public void testClassDescRoundTrip(ClassDesc classDesc) {\n+        Assert.assertEquals(classDesc, JavaType.type(classDesc).toNominalDescriptor());\n+    }\n+\n+    @DataProvider\n+    public Object[][] classDescs() throws ReflectiveOperationException {\n+        List<Object[]> classDescs = new ArrayList<>();\n+        for (Field f : ConstantDescs.class.getDeclaredFields()) {\n+            if (f.getName().startsWith(\"CD_\")) {\n+                ClassDesc cd = (ClassDesc)f.get(null);\n+                classDescs.add(new Object[] { cd });\n+                if (!cd.equals(ConstantDescs.CD_void)) {\n+                    classDescs.add(new Object[]{cd.arrayType()});\n+                    classDescs.add(new Object[]{cd.arrayType().arrayType()});\n+                }\n+            }\n+        }\n+        return classDescs.stream().toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"types\")\n+    public void testTypeRoundTrip(Type type) throws ReflectiveOperationException {\n+        Assert.assertEquals(type, JavaType.type(type).resolve(MethodHandles.lookup()));\n+    }\n+\n+    @DataProvider\n+    public Object[][] types() throws ReflectiveOperationException {\n+        List<Object[]> types = new ArrayList<>();\n+        for (Field f : TypeHolder.class.getDeclaredFields()) {\n+            types.add(new Object[] { f.getGenericType() });\n+        }\n+        return types.stream().toArray(Object[][]::new);\n+    }\n+\n+    static class TypeHolder<X extends Number> {\n+        boolean p1;\n+        char p2;\n+        byte p3;\n+        short p4;\n+        int p5;\n+        long p6;\n+        float p7;\n+        double p8;\n+\n+        boolean[] ap1;\n+        char[] ap2;\n+        byte[] ap3;\n+        short[] ap4;\n+        int[] ap5;\n+        long[] ap6;\n+        float[] ap7;\n+        double[] ap8;\n+\n+        boolean[][] aap1;\n+        char[][] aap2;\n+        byte[][] aap3;\n+        short[][] aap4;\n+        int[][] aap5;\n+        long[][] aap6;\n+        float[][] aap7;\n+        double[][] aap8;\n+\n+        String r1;\n+        Map<String, String> r2;\n+        Map<String, ?  extends String> r3;\n+        Map<? extends String, String> r4;\n+        Map<? extends String, ?  extends String> r5;\n+        Map<? extends List<? extends String>, ? super List<? extends String>> r6;\n+        Map<? extends List<? extends String>[], ? super List<? extends String>[]> r7;\n+        List<boolean[]> r8;\n+        List<char[]> r9;\n+        List<byte[]> r10;\n+        List<short[]> r11;\n+        List<int[]> r12;\n+        List<long[]> r13;\n+        List<float[]> r14;\n+        List<double[]> r15;\n+\n+        String[] ar1;\n+        Map<String, String>[] ar2;\n+        Map<String, ?  extends String>[] ar3;\n+        Map<? extends String, String>[] ar4;\n+        Map<? extends String, ?  extends String>[] ar5;\n+        Map<? extends List<? extends String>, ? super List<? extends String>>[] ar6;\n+        Map<? extends List<? extends String>[], ? super List<? extends String>[]>[] ar7;\n+        List<boolean[]>[] ar8;\n+        List<char[]>[] ar9;\n+        List<byte[]>[] ar10;\n+        List<short[]>[] ar11;\n+        List<int[]>[] ar12;\n+        List<long[]>[] ar13;\n+        List<float[]>[] ar14;\n+        List<double[]>[] ar15;\n+\n+        String[][] aar1;\n+        Map<String, String>[][] aar2;\n+        Map<String, ?  extends String>[][] aar3;\n+        Map<? extends String, String>[][] aar4;\n+        Map<? extends String, ?  extends String>[][] aar5;\n+        Map<? extends List<? extends String>, ? super List<? extends String>>[][] aar6;\n+        Map<? extends List<? extends String>[], ? super List<? extends String>[]>[][] aar7;\n+        List<boolean[]>[][] aar8;\n+        List<char[]>[][] aar9;\n+        List<byte[]>[][] aar10;\n+        List<short[]>[][] aar11;\n+        List<int[]>[][] aar12;\n+        List<long[]>[][] aar13;\n+        List<float[]>[][] aar14;\n+        List<double[]>[][] aar15;\n+\n+        X x1;\n+        Map<X, X> x2;\n+        Map<X, ?  extends X> x3;\n+        Map<? extends X, X> x4;\n+        Map<? extends X, ?  extends X> x5;\n+        Map<? extends List<? extends X>, ? super List<? extends X>> x6;\n+        Map<? extends List<? extends X>[], ? super List<? extends X>[]> x7;\n+        List<X[]> x8;\n+\n+        X[] ax1;\n+        Map<X, X>[] ax2;\n+        Map<X, ?  extends X>[] ax3;\n+        Map<? extends X, X>[] ax4;\n+        Map<? extends X, ?  extends X>[] ax5;\n+        Map<? extends List<? extends X>, ? super List<? extends X>>[] ax6;\n+        Map<? extends List<? extends X>[], ? super List<? extends X>[]>[] ax7;\n+        List<X[]>[] ax8;\n+\n+        X[][] aax1;\n+        Map<X, X>[][] aax2;\n+        Map<X, ?  extends X>[][] aax3;\n+        Map<? extends X, X>[][] aax4;\n+        Map<? extends X, ?  extends X>[][] aax5;\n+        Map<? extends List<? extends X>, ? super List<? extends X>>[][] aax6;\n+        Map<? extends List<? extends X>[], ? super List<? extends X>[]>[][] aax7;\n+        List<X[]>[][] aax8;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestJavaType.java","additions":149,"deletions":2,"binary":false,"changes":151,"status":"modified"}]}