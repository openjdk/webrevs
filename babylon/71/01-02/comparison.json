{"files":[{"patch":"@@ -51,1 +51,1 @@\n-            return Array.newInstance(resolvedComponentClass, 0).getClass();\n+            return resolvedComponentClass.arrayType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/code\/type\/ArrayType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestErasure\n- *\/\n-\n-import static org.testng.Assert.*;\n-import org.testng.annotations.*;\n-\n-import java.lang.reflect.code.type.ClassType;\n-import java.lang.reflect.code.type.JavaType;\n-import java.lang.reflect.code.type.WildcardType.BoundKind;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-@Test\n-public class TestErasure {\n-\n-    @Test(dataProvider = \"typesAndErasures\")\n-    public void testErasure(String testName, TypeAndErasure typeAndErasure) {\n-        assertEquals(typeAndErasure.type.erasure(), typeAndErasure.erasure);\n-        assertEquals(typeAndErasure.type.toBasicType(), typeAndErasure.erasure.toBasicType());\n-        assertEquals(typeAndErasure.type.toNominalDescriptor(), typeAndErasure.erasure.toNominalDescriptor());\n-    }\n-\n-    @DataProvider\n-    public static Object[][] typesAndErasures() {\n-        List<TypeAndErasure> typeAndErasures = new ArrayList<>();\n-        typeAndErasures.addAll(primitives());\n-        typeAndErasures.addAll(references());\n-        typeAndErasures.addAll(genericReferences());\n-        typeAndErasures.addAll(arrays());\n-        typeAndErasures.addAll(typeVars());\n-        return typeAndErasures.stream()\n-                .map(t -> new Object[] { t.type.toString(), t })\n-                .toArray(Object[][]::new);\n-    }\n-\n-    static List<TypeAndErasure> primitives() {\n-        return List.of(\n-                new TypeAndErasure(JavaType.BOOLEAN, JavaType.BOOLEAN),\n-                new TypeAndErasure(JavaType.CHAR, JavaType.CHAR),\n-                new TypeAndErasure(JavaType.BYTE, JavaType.BYTE),\n-                new TypeAndErasure(JavaType.SHORT, JavaType.SHORT),\n-                new TypeAndErasure(JavaType.INT, JavaType.INT),\n-                new TypeAndErasure(JavaType.FLOAT, JavaType.FLOAT),\n-                new TypeAndErasure(JavaType.LONG, JavaType.LONG),\n-                new TypeAndErasure(JavaType.DOUBLE, JavaType.DOUBLE),\n-                new TypeAndErasure(JavaType.VOID, JavaType.VOID));\n-    }\n-\n-    static List<TypeAndErasure> references() {\n-        return List.of(\n-                new TypeAndErasure(JavaType.J_L_STRING, JavaType.J_L_STRING),\n-                new TypeAndErasure(JavaType.J_L_OBJECT, JavaType.J_L_OBJECT));\n-    }\n-\n-    static List<TypeAndErasure> genericReferences() {\n-        JavaType LIST = JavaType.type(List.class);\n-        List<TypeAndErasure> genericTypes = new ArrayList<>();\n-        BoundKind[] kinds = new BoundKind[] { null, BoundKind.EXTENDS, BoundKind.SUPER };\n-        for (BoundKind kind : kinds) {\n-            for (TypeAndErasure t : references()) {\n-                JavaType arg = t.type;\n-                if (kind != null) {\n-                    arg = JavaType.wildcard(kind, arg);\n-                }\n-                genericTypes.add(new TypeAndErasure(JavaType.parameterized(LIST, arg), LIST));\n-            }\n-            for (TypeAndErasure t : primitives()) {\n-                JavaType arg = JavaType.array(t.type);\n-                if (kind != null) {\n-                    arg = JavaType.wildcard(kind, arg);\n-                }\n-                genericTypes.add(new TypeAndErasure(JavaType.parameterized(LIST, arg), LIST));\n-            }\n-        }\n-        return genericTypes;\n-    }\n-\n-    static List<TypeAndErasure> arrays() {\n-        List<TypeAndErasure> arrayTypes = new ArrayList<>();\n-        for (int dims = 1 ; dims <= 3 ; dims++) {\n-            for (TypeAndErasure t : primitives()) {\n-                if (t.type.isVoid() continue; \/\/ void is not a valid array component type\n-                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n-            }\n-            for (TypeAndErasure t : references()) {\n-                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n-            }\n-            for (TypeAndErasure t : genericReferences()) {\n-                arrayTypes.add(new TypeAndErasure(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n-            }\n-        }\n-        return arrayTypes;\n-    }\n-\n-    static List<TypeAndErasure> typeVars() {\n-        List<TypeAndErasure> typeVars = new ArrayList<>();\n-        for (int dims = 1 ; dims <= 3 ; dims++) {\n-            for (TypeAndErasure t : references()) {\n-                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", (ClassType)JavaType.J_L_OBJECT, t.type), t.erasure));\n-            }\n-            for (TypeAndErasure t : genericReferences()) {\n-                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", (ClassType)JavaType.J_L_OBJECT, t.type), t.erasure));\n-            }\n-            for (TypeAndErasure t : arrays()) {\n-                typeVars.add(new TypeAndErasure(JavaType.typeVarRef(\"X\", (ClassType)JavaType.J_L_OBJECT, t.type), t.erasure));\n-            }\n-        }\n-        return typeVars;\n-    }\n-\n-    record TypeAndErasure(JavaType type, JavaType erasure) { }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestErasure.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestErasure\n+ *\/\n+\n+import static org.testng.Assert.*;\n+import org.testng.annotations.*;\n+\n+import java.lang.reflect.code.type.ArrayType;\n+import java.lang.reflect.code.type.ClassType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.reflect.code.type.TypeVarRef;\n+import java.lang.reflect.code.type.WildcardType.BoundKind;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Test\n+public class TestErasure {\n+\n+    @Test(dataProvider = \"typesAndErasures\")\n+    public void testErasure(String testName, TypeAndErasure<?> typeAndErasure) {\n+        assertEquals(typeAndErasure.type.erasure(), typeAndErasure.erasure);\n+        assertEquals(typeAndErasure.type.toBasicType(), typeAndErasure.erasure.toBasicType());\n+        assertEquals(typeAndErasure.type.toNominalDescriptor(), typeAndErasure.erasure.toNominalDescriptor());\n+    }\n+\n+    @DataProvider\n+    public static Object[][] typesAndErasures() {\n+        List<TypeAndErasure<?>> typeAndErasures = new ArrayList<>();\n+        typeAndErasures.addAll(primitives());\n+        typeAndErasures.addAll(references());\n+        typeAndErasures.addAll(genericReferences());\n+        typeAndErasures.addAll(arrays());\n+        typeAndErasures.addAll(typeVars());\n+        return typeAndErasures.stream()\n+                .map(t -> new Object[] { t.type.toString(), t })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    static List<TypeAndErasure<PrimitiveType>> primitives() {\n+        return List.of(\n+                new TypeAndErasure<>(JavaType.BOOLEAN, JavaType.BOOLEAN),\n+                new TypeAndErasure<>(JavaType.CHAR, JavaType.CHAR),\n+                new TypeAndErasure<>(JavaType.BYTE, JavaType.BYTE),\n+                new TypeAndErasure<>(JavaType.SHORT, JavaType.SHORT),\n+                new TypeAndErasure<>(JavaType.INT, JavaType.INT),\n+                new TypeAndErasure<>(JavaType.FLOAT, JavaType.FLOAT),\n+                new TypeAndErasure<>(JavaType.LONG, JavaType.LONG),\n+                new TypeAndErasure<>(JavaType.DOUBLE, JavaType.DOUBLE),\n+                new TypeAndErasure<>(JavaType.VOID, JavaType.VOID));\n+    }\n+\n+    static List<TypeAndErasure<ClassType>> references() {\n+        return List.of(\n+                new TypeAndErasure<>(JavaType.J_L_STRING, JavaType.J_L_STRING),\n+                new TypeAndErasure<>(JavaType.J_L_OBJECT, JavaType.J_L_OBJECT));\n+    }\n+\n+    static List<TypeAndErasure<ClassType>> genericReferences() {\n+        JavaType LIST = JavaType.type(List.class);\n+        List<TypeAndErasure<ClassType>> genericTypes = new ArrayList<>();\n+        BoundKind[] kinds = new BoundKind[] { null, BoundKind.EXTENDS, BoundKind.SUPER };\n+        for (BoundKind kind : kinds) {\n+            for (TypeAndErasure<ClassType> t : references()) {\n+                JavaType arg = t.type;\n+                if (kind != null) {\n+                    arg = JavaType.wildcard(kind, arg);\n+                }\n+                genericTypes.add(new TypeAndErasure<>(JavaType.parameterized(LIST, arg), LIST));\n+            }\n+            for (TypeAndErasure<PrimitiveType> t : primitives()) {\n+                JavaType arg = JavaType.array(t.type);\n+                if (kind != null) {\n+                    arg = JavaType.wildcard(kind, arg);\n+                }\n+                genericTypes.add(new TypeAndErasure<>(JavaType.parameterized(LIST, arg), LIST));\n+            }\n+        }\n+        return genericTypes;\n+    }\n+\n+    static List<TypeAndErasure<ArrayType>> arrays() {\n+        List<TypeAndErasure<ArrayType>> arrayTypes = new ArrayList<>();\n+        for (int dims = 1 ; dims <= 3 ; dims++) {\n+            for (TypeAndErasure<PrimitiveType> t : primitives()) {\n+                if (t.type.isVoid()) continue; \/\/ void is not a valid array component type\n+                arrayTypes.add(new TypeAndErasure<>(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+            for (TypeAndErasure<ClassType> t : references()) {\n+                arrayTypes.add(new TypeAndErasure<>(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+            for (TypeAndErasure<ClassType> t : genericReferences()) {\n+                arrayTypes.add(new TypeAndErasure<>(JavaType.array(t.type, dims), JavaType.array(t.erasure, dims)));\n+            }\n+        }\n+        return arrayTypes;\n+    }\n+\n+    static List<TypeAndErasure<TypeVarRef>> typeVars() {\n+        List<TypeAndErasure<TypeVarRef>> typeVars = new ArrayList<>();\n+        for (int dims = 1 ; dims <= 3 ; dims++) {\n+            for (TypeAndErasure<ClassType> t : references()) {\n+                typeVars.add(new TypeAndErasure<>(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+            for (TypeAndErasure<ClassType> t : genericReferences()) {\n+                typeVars.add(new TypeAndErasure<>(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+            for (TypeAndErasure<ArrayType> t : arrays()) {\n+                typeVars.add(new TypeAndErasure<>(JavaType.typeVarRef(\"X\", JavaType.J_L_OBJECT, t.type), t.erasure));\n+            }\n+        }\n+        return typeVars;\n+    }\n+\n+    record TypeAndErasure<T extends JavaType>(T type, JavaType erasure) { }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestErasure.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}