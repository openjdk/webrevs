{"files":[{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.analysis.NormalizeBlocksTransformer;\n+import jdk.incubator.code.analysis.SSA;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.op.ExtendedOp;\n+import jdk.incubator.code.parser.OpParser;\n+import jdk.incubator.code.writer.OpWriter;\n+\n+import java.io.StringWriter;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+public class CodeReflectionTester {\n+\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: CodeReflectionTester <classname>\");\n+            System.exit(1);\n+        }\n+        Class<?> clazz = Class.forName(args[0]);\n+\n+        Method lookupMethod = clazz.getMethod(\"lookup\");\n+        MethodHandles.Lookup lookup = (MethodHandles.Lookup) lookupMethod.invoke(null);\n+\n+        Method opConstantsMethod = clazz.getMethod(\"opConstants\");\n+        @SuppressWarnings(\"unchecked\")\n+        Predicate<Op> opConstants = (Predicate<Op>) opConstantsMethod.invoke(null);\n+\n+        for (Method m : clazz.getDeclaredMethods()) {\n+            check(lookup, opConstants, m);\n+        }\n+    }\n+\n+    static void check(MethodHandles.Lookup l, Predicate<Op> opConstants, Method method) throws ReflectiveOperationException {\n+        if (!method.isAnnotationPresent(CodeReflection.class)) {\n+            return;\n+        }\n+\n+        for (EvaluatedModel em : getModels(method)) {\n+            CoreOp.FuncOp f = Op.ofMethod(method).orElseThrow(() ->\n+                    new AssertionError(\"No code model for reflective method\"));\n+            f = evaluate(l, opConstants, f, em.ssa());\n+\n+            String actual = canonicalizeModel(method, f);\n+            System.out.println(actual);\n+            String expected = canonicalizeModel(method, em.value());\n+            if (!actual.equals(expected)) {\n+                throw new AssertionError(String.format(\"Bad code model\\nFound:\\n%s\\n\\nExpected:\\n%s\", actual, expected));\n+            }\n+        }\n+    }\n+\n+    static EvaluatedModel[] getModels(Method method) {\n+        EvaluatedModels ems = method.getAnnotation(EvaluatedModels.class);\n+        if (ems != null) {\n+            return ems.value();\n+        }\n+\n+        EvaluatedModel em = method.getAnnotation(EvaluatedModel.class);\n+        if (em != null) {\n+            return new EvaluatedModel[] { em };\n+        }\n+\n+        throw new AssertionError(\"No @EvaluatedModel annotation found on reflective method\");\n+    }\n+\n+    static CoreOp.FuncOp evaluate(MethodHandles.Lookup l, Predicate<Op> opConstants, CoreOp.FuncOp f, boolean ssa) {\n+        f = f.transform(OpTransformer.LOWERING_TRANSFORMER);\n+\n+        if (ssa) {\n+            f = SSA.transform(f);\n+        }\n+\n+        f = PartialEvaluator.evaluate(l, opConstants, new HashSet<>(), f);\n+\n+        return cleanUp(f);\n+    }\n+\n+    static CoreOp.FuncOp cleanUp(CoreOp.FuncOp f) {\n+        return removeUnusedOps(NormalizeBlocksTransformer.transform(f));\n+    }\n+\n+    static CoreOp.FuncOp removeUnusedOps(CoreOp.FuncOp f) {\n+        Predicate<Op> unused = op -> (op instanceof Op.Pure || op instanceof CoreOp.VarOp) &&\n+                op.result().uses().isEmpty();\n+        while (f.elements().skip(1).anyMatch(ce -> ce instanceof Op op && unused.test(op))) {\n+            f = f.transform((block, op) -> {\n+                if (!unused.test(op)) {\n+                    block.op(op);\n+                }\n+                return block;\n+            });\n+        }\n+        return f;\n+    }\n+\n+    \/\/ serializes dropping location information, parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, Op o) {\n+        return canonicalizeModel(m, serialize(o));\n+    }\n+\n+    \/\/ parses, and then serializes, dropping location information\n+    static String canonicalizeModel(Member m, String d) {\n+        Op o;\n+        try {\n+            o = OpParser.fromString(ExtendedOp.FACTORY, d).get(0);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(m.toString(), e);\n+        }\n+        return serialize(o);\n+    }\n+\n+    \/\/ serializes, dropping location information\n+    static String serialize(Op o) {\n+        StringWriter w = new StringWriter();\n+        OpWriter.writeTo(w, o, OpWriter.LocationOption.DROP_LOCATION);\n+        return w.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/CodeReflectionTester.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.*;\n+\n+@Repeatable(EvaluatedModels.class)\n+@Target(ElementType.METHOD)\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface EvaluatedModel {\n+    String value();\n+    boolean ssa() default false;\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/EvaluatedModel.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.*;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.METHOD)\n+public @interface EvaluatedModels {\n+    EvaluatedModel[] value();\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/EvaluatedModels.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -7,3 +7,1 @@\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n+ * published by the Free Software Foundation.\n@@ -26,2 +24,0 @@\n-package oracle.code.onnx.compiler;\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/InvokableLeafOps.java","additions":1,"deletions":5,"binary":false,"changes":6,"previous_filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/InvokableLeafOps.java","status":"copied"},{"patch":"@@ -0,0 +1,113 @@\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.Body;\n+\n+import java.util.*;\n+\n+public class LoopAnalyzer {\n+    public record Loop(Block header, List<Block> latches, Set<Block> body, List<LoopExit> exits) {\n+    }\n+\n+    public record LoopExit(Block exit, Block target) {\n+    }\n+\n+    public static Optional<Loop> isLoop(Block header) {\n+        List<Block> latches = header.predecessors()\n+                .stream().filter(p -> p.isDominatedBy(header))\n+                .toList();\n+        if (latches.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        Set<Block> body = new HashSet<>();\n+        for (Block latch : latches) {\n+            loopBody(body, header, latch);\n+        }\n+        List<LoopExit> exits = loopExits(body);\n+        return Optional.of(new Loop(header, latches, body, exits));\n+    }\n+\n+    static Set<Block> naturalLoopBody(Set<Block> loopBody, Block header, Block latch) {\n+        Deque<Block> stack = new ArrayDeque<>();\n+        stack.push(latch);\n+        Block node;\n+        \/\/ Backward depth first search from latch to header\n+        while (!stack.isEmpty() && (node = stack.pop()) != header) {\n+            if (!loopBody.add(node)) {\n+                continue;\n+            }\n+\n+            stack.addAll(node.predecessors().reversed());\n+        }\n+        loopBody.add(header);\n+\n+        return loopBody;\n+    }\n+\n+    static Set<Block> loopBody(Set<Block> loopBody, Block header, Block latch) {\n+        naturalLoopBody(loopBody, header, latch);\n+\n+        Set<Block> extendedLoopBody = new HashSet<>();\n+        for (Block lb : loopBody) {\n+            for (Block lbs : lb.successorTargets()) {\n+                if (!loopBody.contains(lbs) && !extendedLoopBody.contains(lbs)) {\n+                    \/\/ Find if there is path from lbs to latch that does not pass through header\n+                    Deque<Block> stack = new ArrayDeque<>();\n+                    stack.push(lbs);\n+                    Set<Block> visited = new HashSet<>();\n+                    while (!stack.isEmpty()) {\n+                        Block x = stack.pop();\n+                        if (!visited.add(x)) {\n+                            continue;\n+                        }\n+\n+                        if (find(x, header, latch)) {\n+                            extendedLoopBody.add(x);\n+                        }\n+\n+                        stack.addAll(x.successorTargets());\n+                    }\n+                }\n+            }\n+        }\n+\n+        loopBody.addAll(extendedLoopBody);\n+        return loopBody;\n+    }\n+\n+    \/\/ Determine if there is a forward path from x to y that does not pass through n\n+    static boolean find(Block x, Block n, Block y) {\n+        if (x == n) {\n+            return false;\n+        }\n+        if (x == y) {\n+            return true;\n+        }\n+\n+        boolean r = false;\n+        for (Block b : x.successorTargets()) {\n+            \/\/ Back branch\n+            if (x.isDominatedBy(b))\n+                return false;\n+            if (find(b, n, y)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static List<LoopExit> loopExits(Set<Block> loopBody) {\n+        List<LoopExit> loopExits = new ArrayList<>();\n+        for (Block block : loopBody) {\n+            for (Block t : block.successorTargets()) {\n+                if (!loopBody.contains(t)) {\n+                    loopExits.add(new LoopExit(block, t));\n+                }\n+            }\n+        }\n+        return loopExits;\n+    }\n+\n+    static List<Loop> findLoops(Body body) {\n+        return body.blocks().stream().flatMap(b -> isLoop(b).stream()).toList();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/LoopAnalyzer.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,584 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.type.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.util.*;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+final class PartialEvaluator {\n+    final Set<Value> constants;\n+    final Predicate<Op> opConstant;\n+\n+    PartialEvaluator(Set<Value> constants, Predicate<Op> opConstant) {\n+        this.constants = new LinkedHashSet<>(constants);\n+        this.opConstant = opConstant;\n+    }\n+\n+    public static\n+    CoreOp.FuncOp evaluate(MethodHandles.Lookup l,\n+                           Predicate<Op> opConstant, Set<Value> constants,\n+                           CoreOp.FuncOp op) {\n+        PartialEvaluator pe = new PartialEvaluator(constants, opConstant);\n+        Body.Builder outBody = pe.evaluateBody(l, op.body());\n+        return CoreOp.func(op.funcName(), outBody);\n+    }\n+\n+\n+    @SuppressWarnings(\"serial\")\n+    public static final class EvaluationException extends RuntimeException {\n+        private EvaluationException(Throwable cause) {\n+            super(cause);\n+        }\n+    }\n+\n+    static EvaluationException evaluationException(Throwable cause) {\n+        return new EvaluationException(cause);\n+    }\n+\n+    static final class BodyContext {\n+        final BodyContext parent;\n+\n+        final Map<Block, List<Block>> evaluatedPredecessors;\n+        final Map<Value, Object> evaluatedValues;\n+\n+        final Queue<Block> blockStack;\n+        final BitSet visited;\n+\n+        BodyContext(Block entryBlock) {\n+            this.parent = null;\n+\n+            this.evaluatedPredecessors = new HashMap<>();\n+            this.evaluatedValues = new HashMap<>();\n+            this.blockStack = new PriorityQueue<>(Comparator.comparingInt(Block::index));\n+\n+            this.visited = new BitSet();\n+        }\n+\n+        Object getValue(Value v) {\n+            Object rv = evaluatedValues.get(v);\n+            if (rv != null) {\n+                return rv;\n+            }\n+\n+            throw evaluationException(new IllegalArgumentException(\"Undefined value: \" + v));\n+        }\n+\n+        void setValue(Value v, Object o) {\n+            evaluatedValues.put(v, o);\n+        }\n+    }\n+\n+    Body.Builder evaluateBody(MethodHandles.Lookup l,\n+                              Body inBody) {\n+        Block inEntryBlock = inBody.entryBlock();\n+\n+        Body.Builder outBody = Body.Builder.of(null, inBody.bodyType());\n+        Block.Builder outEntryBlock = outBody.entryBlock();\n+\n+        CopyContext cc = outEntryBlock.context();\n+        cc.mapBlock(inEntryBlock, outEntryBlock);\n+        cc.mapValues(inEntryBlock.parameters(), outEntryBlock.parameters());\n+\n+        evaluateEntryBlock(l, inEntryBlock, outEntryBlock, new BodyContext(inEntryBlock));\n+\n+        return outBody;\n+    }\n+\n+    void evaluateEntryBlock(MethodHandles.Lookup l,\n+                            Block inEntryBlock,\n+                            Block.Builder outEntryBlock,\n+                            BodyContext bc) {\n+        assert inEntryBlock.isEntryBlock();\n+\n+        Map<Block, LoopAnalyzer.Loop> loops = new HashMap<>();\n+        Set<Block> loopNoPeeling = new HashSet<>();\n+\n+        \/\/ The first block cannot have any successors so the queue will have at least one entry\n+        bc.blockStack.add(inEntryBlock);\n+        while (!bc.blockStack.isEmpty()) {\n+            final Block inBlock = bc.blockStack.poll();\n+            if (bc.visited.get(inBlock.index())) {\n+                continue;\n+            }\n+            bc.visited.set(inBlock.index());\n+\n+            final Block.Builder outBlock = outEntryBlock.context().getBlock(inBlock);\n+\n+            nopeel: if (inBlock.predecessors().size() > 1 && bc.evaluatedPredecessors.get(inBlock).size() == 1) {\n+                \/\/ If we reached to this block through just one evaluated predecessor\n+                Block inBlockPred = bc.evaluatedPredecessors.get(inBlock).getFirst();\n+                Block.Reference inBlockRef = inBlockPred.terminatingOp().successors().stream()\n+                        .filter(r -> r.targetBlock() == inBlock)\n+                        .findFirst().get();\n+                List<Value> args = inBlockRef.arguments();\n+                List<Boolean> argConstant = args.stream().map(constants::contains).toList();\n+\n+                LoopAnalyzer.Loop loop = loops.computeIfAbsent(inBlock, b -> LoopAnalyzer.isLoop(inBlock).orElse(null));\n+                if (loop != null && inBlockPred.isDominatedBy(loop.header())) {\n+                    \/\/ Entering loop header from latch\n+                    assert loop.latches().contains(inBlockPred);\n+\n+                    \/\/ Linear constant path from each exiting block (or nearest evaluated present dominator) to loop header\n+                    boolean constantExits = true;\n+                    for (LoopAnalyzer.LoopExit loopExitPair : loop.exits()) {\n+                        Block loopExit = loopExitPair.exit();\n+\n+                        \/\/ Find nearest evaluated dominator\n+                        List<Block> ePreds = bc.evaluatedPredecessors.get(loopExit);\n+                        while (ePreds == null) {\n+                            loopExit = loopExit.immediateDominator();\n+                            ePreds = bc.evaluatedPredecessors.get(loopExit);\n+                        }\n+                        assert loop.body().contains(loopExit);\n+\n+                        if (ePreds.size() != 1 ||\n+                                !(loopExit.terminatingOp() instanceof CoreOp.ConditionalBranchOp cbr) ||\n+                                !constants.contains(cbr.result())) {\n+                            \/\/ If there are multiple encounters, or terminal op is not a constant conditional branch\n+                            constantExits = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    \/\/ Determine if constant args, before reset\n+                    boolean constantArgs = constants.containsAll(args);\n+\n+                    \/\/ Reset state within loop body\n+                    for (Block block : loop.body()) {\n+                        \/\/ Reset visits, but not for loop header\n+                        if (block != loop.header()) {\n+                            bc.evaluatedPredecessors.remove(block);\n+                            bc.visited.set(block.index(), false);\n+                        }\n+\n+                        \/\/ Reset constants\n+                        for (Op op : block.ops()) {\n+                            constants.remove(op.result());\n+                        }\n+                        constants.removeAll(block.parameters());\n+\n+                        \/\/ Reset no peeling for any nested loops\n+                        loopNoPeeling.remove(block);\n+                    }\n+\n+                    if (!constantExits || !constantArgs) {\n+                        \/\/ Finish peeling\n+                        \/\/ No constant exit and no constant args\n+                        loopNoPeeling.addAll(loop.latches());\n+                        break nopeel;\n+                    }\n+                    \/\/ Peel next iteration\n+                }\n+\n+                \/\/ Propagate constant arguments\n+                for (int i = 0; i < args.size(); i++) {\n+                    Value inArgument = args.get(i);\n+                    if (argConstant.get(i)) {\n+                        Block.Parameter inParameter = inBlock.parameters().get(i);\n+\n+                        \/\/ Map input parameter to output argument\n+                        outBlock.context().mapValue(inParameter, outBlock.context().getValue(inArgument));\n+                        \/\/ Set parameter constant\n+                        constants.add(inParameter);\n+                        bc.setValue(inParameter, bc.getValue(inArgument));\n+                    }\n+                }\n+            }\n+\n+            \/\/ Process all but the terminating operation\n+            int nops = inBlock.ops().size();\n+            for (int i = 0; i < nops - 1; i++) {\n+                Op op = inBlock.ops().get(i);\n+\n+                if (isConstant(op)) {\n+                    \/\/ Evaluate operation\n+                    \/\/ @@@ Handle exceptions\n+                    Object result = interpretOp(l, bc, op);\n+                    bc.setValue(op.result(), result);\n+\n+                    if (op instanceof CoreOp.VarOp) {\n+                        \/\/ @@@ Do not turn into constant to avoid conflicts with the interpreter\n+                        \/\/ and its runtime representation of vars\n+                        outBlock.op(op);\n+                    } else {\n+                        \/\/ Result was evaluated, replace with constant operation\n+                        Op.Result constantResult = outBlock.op(CoreOp.constant(op.resultType(), result));\n+                        outBlock.context().mapValue(op.result(), constantResult);\n+                    }\n+                } else {\n+                    \/\/ Copy unevaluated operation\n+                    Op.Result r = outBlock.op(op);\n+                    \/\/ Explicitly remap result, since the op can be copied more than once in pealed loops\n+                    \/\/ @@@ See comment Block.op code which implicitly limits this\n+                    outBlock.context().mapValue(op.result(), r);\n+                }\n+            }\n+\n+            \/\/ Process the terminating operation\n+            Op to = inBlock.terminatingOp();\n+            switch (to) {\n+                case CoreOp.ConditionalBranchOp cb -> {\n+                    if (isConstant(to)) {\n+                        boolean p = switch (bc.getValue(cb.predicate())) {\n+                            case Boolean bp -> bp;\n+                            case Integer ip ->\n+                                \/\/ @@@ This is required when lifting up from bytecode, since boolean values\n+                                \/\/ are erased to int values, abd the bytecode lifting implementation is not currently\n+                                \/\/ sophisticated enough to recover the type information\n+                                    ip != 0;\n+                            default -> throw evaluationException(\n+                                    new UnsupportedOperationException(\"Unsupported type input to operation: \" + cb));\n+                        };\n+\n+                        Block.Reference nextInBlockRef = p ? cb.trueBranch() : cb.falseBranch();\n+                        Block nextInBlock = nextInBlockRef.targetBlock();\n+\n+                        \/\/ @@@ might be latch to loop\n+                        assert !inBlock.isDominatedBy(nextInBlock);\n+\n+                        processBlock(bc, inBlock, nextInBlock, outBlock);\n+\n+                        outBlock.op(CoreOp.branch(outBlock.context().getSuccessorOrCreate(nextInBlockRef)));\n+                    } else {\n+                        \/\/ @@@ might be non-constant latch to loop\n+                        processBlock(bc, inBlock, cb.falseBranch().targetBlock(), outBlock);\n+                        processBlock(bc, inBlock, cb.trueBranch().targetBlock(), outBlock);\n+\n+                        outBlock.op(to);\n+                    }\n+                }\n+                case CoreOp.BranchOp b -> {\n+                    Block.Reference nextInBlockRef = b.branch();\n+                    Block nextInBlock = nextInBlockRef.targetBlock();\n+\n+                    if (inBlock.isDominatedBy(nextInBlock)) {\n+                        \/\/ latch to loop header\n+                        assert bc.visited.get(nextInBlock.index());\n+                        if (!loopNoPeeling.contains(inBlock) && constants.containsAll(nextInBlock.parameters())) {\n+                            \/\/ Reset loop body to peel off another iteration\n+                            bc.visited.set(nextInBlock.index(), false);\n+                            bc.evaluatedPredecessors.remove(nextInBlock);\n+                        }\n+                    }\n+\n+                    processBlock(bc, inBlock, nextInBlock, outBlock);\n+\n+                    outBlock.op(b);\n+                }\n+                case CoreOp.ReturnOp _ -> outBlock.op(to);\n+                default -> throw evaluationException(\n+                        new UnsupportedOperationException(\"Unsupported terminating operation: \" + to.opName()));\n+            }\n+        }\n+    }\n+\n+    boolean isConstant(Op op) {\n+        if (constants.contains(op.result())) {\n+            return true;\n+        } else if (constants.containsAll(op.operands()) && opConstant.test(op)) {\n+            constants.add(op.result());\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    void processBlock(BodyContext bc, Block inBlock, Block nextInBlock, Block.Builder outBlock) {\n+        bc.blockStack.add(nextInBlock);\n+        if (!bc.evaluatedPredecessors.containsKey(nextInBlock)) {\n+            \/\/ Copy block\n+            Block.Builder nextOutBlock = outBlock.block(nextInBlock.parameterTypes());\n+            outBlock.context().mapBlock(nextInBlock, nextOutBlock);\n+            outBlock.context().mapValues(nextInBlock.parameters(), nextOutBlock.parameters());\n+        }\n+        bc.evaluatedPredecessors.computeIfAbsent(nextInBlock, _ -> new ArrayList<>()).add(inBlock);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Throwable> void eraseAndThrow(Throwable e) throws E {\n+        throw (E) e;\n+    }\n+\n+    \/\/ @@@ This could be shared with the interpreter if it was more extensible\n+    Object interpretOp(MethodHandles.Lookup l, BodyContext bc, Op o) {\n+        switch (o) {\n+            case CoreOp.ConstantOp co -> {\n+                if (co.resultType().equals(JavaType.J_L_CLASS)) {\n+                    return resolveToClass(l, (JavaType) co.value());\n+                } else {\n+                    return co.value();\n+                }\n+            }\n+            case CoreOp.InvokeOp co -> {\n+                MethodType target = resolveToMethodType(l, o.opType());\n+                MethodHandles.Lookup il = switch (co.invokeKind()) {\n+                    case STATIC, INSTANCE -> l;\n+                    case SUPER -> l.in(target.parameterType(0));\n+                };\n+                MethodHandle mh = resolveToMethodHandle(il, co.invokeDescriptor(), co.invokeKind());\n+\n+                mh = mh.asType(target).asFixedArity();\n+                Object[] values = o.operands().stream().map(bc::getValue).toArray();\n+                return invoke(mh, values);\n+            }\n+            case CoreOp.NewOp no -> {\n+                Object[] values = o.operands().stream().map(bc::getValue).toArray();\n+                JavaType nType = (JavaType) no.resultType();\n+                if (nType instanceof ArrayType at) {\n+                    if (values.length > at.dimensions()) {\n+                        throw evaluationException(new IllegalArgumentException(\"Bad constructor NewOp: \" + no));\n+                    }\n+                    int[] lengths = Stream.of(values).mapToInt(v -> (int) v).toArray();\n+                    for (int length : lengths) {\n+                        nType = ((ArrayType) nType).componentType();\n+                    }\n+                    return Array.newInstance(resolveToClass(l, nType), lengths);\n+                } else {\n+                    MethodHandle mh = constructorHandle(l, no.constructorDescriptor().type());\n+                    return invoke(mh, values);\n+                }\n+            }\n+            case CoreOp.VarOp vo -> {\n+                Object[] vbox = vo.isUninitialized()\n+                        ? new Object[] { null, false }\n+                        : new Object[] { bc.getValue(o.operands().get(0)) };\n+                return vbox;\n+            }\n+            case CoreOp.VarAccessOp.VarLoadOp vlo -> {\n+                \/\/ Cast to CoreOp.Var, since the instance may have originated as an external instance\n+                \/\/ via a captured value map\n+                Object[] vbox = (Object[]) bc.getValue(o.operands().get(0));\n+                if (vbox.length == 2 && !((Boolean) vbox[1])) {\n+                    throw evaluationException(new IllegalStateException(\"Loading from uninitialized variable\"));\n+                }\n+                return vbox[0];\n+            }\n+            case CoreOp.VarAccessOp.VarStoreOp vso -> {\n+                Object[] vbox = (Object[]) bc.getValue(o.operands().get(0));\n+                if (vbox.length == 2) {\n+                    vbox[1] = true;\n+                }\n+                vbox[0] = bc.getValue(o.operands().get(1));\n+                return null;\n+            }\n+            case CoreOp.TupleOp to -> {\n+                return o.operands().stream().map(bc::getValue).toList();\n+            }\n+            case CoreOp.TupleLoadOp tlo -> {\n+                @SuppressWarnings(\"unchecked\")\n+                List<Object> tb = (List<Object>) bc.getValue(o.operands().get(0));\n+                return tb.get(tlo.index());\n+            }\n+            case CoreOp.TupleWithOp two -> {\n+                @SuppressWarnings(\"unchecked\")\n+                List<Object> tb = (List<Object>) bc.getValue(o.operands().get(0));\n+                List<Object> copy = new ArrayList<>(tb);\n+                copy.set(two.index(), bc.getValue(o.operands().get(1)));\n+                return Collections.unmodifiableList(copy);\n+            }\n+            case CoreOp.FieldAccessOp.FieldLoadOp fo -> {\n+                if (fo.operands().isEmpty()) {\n+                    VarHandle vh = fieldStaticHandle(l, fo.fieldDescriptor());\n+                    return vh.get();\n+                } else {\n+                    Object v = bc.getValue(o.operands().get(0));\n+                    VarHandle vh = fieldHandle(l, fo.fieldDescriptor());\n+                    return vh.get(v);\n+                }\n+            }\n+            case CoreOp.FieldAccessOp.FieldStoreOp fo -> {\n+                if (fo.operands().size() == 1) {\n+                    Object v = bc.getValue(o.operands().get(0));\n+                    VarHandle vh = fieldStaticHandle(l, fo.fieldDescriptor());\n+                    vh.set(v);\n+                } else {\n+                    Object r = bc.getValue(o.operands().get(0));\n+                    Object v = bc.getValue(o.operands().get(1));\n+                    VarHandle vh = fieldHandle(l, fo.fieldDescriptor());\n+                    vh.set(r, v);\n+                }\n+                return null;\n+            }\n+            case CoreOp.InstanceOfOp io -> {\n+                Object v = bc.getValue(o.operands().get(0));\n+                return isInstance(l, io.type(), v);\n+            }\n+            case CoreOp.CastOp co -> {\n+                Object v = bc.getValue(o.operands().get(0));\n+                return cast(l, co.type(), v);\n+            }\n+            case CoreOp.ArrayLengthOp arrayLengthOp -> {\n+                Object a = bc.getValue(o.operands().get(0));\n+                return Array.getLength(a);\n+            }\n+            case CoreOp.ArrayAccessOp.ArrayLoadOp arrayLoadOp -> {\n+                Object a = bc.getValue(o.operands().get(0));\n+                Object index = bc.getValue(o.operands().get(1));\n+                return Array.get(a, (int) index);\n+            }\n+            case CoreOp.ArrayAccessOp.ArrayStoreOp arrayStoreOp -> {\n+                Object a = bc.getValue(o.operands().get(0));\n+                Object index = bc.getValue(o.operands().get(1));\n+                Object v = bc.getValue(o.operands().get(2));\n+                Array.set(a, (int) index, v);\n+                return null;\n+            }\n+            case CoreOp.ArithmeticOperation arithmeticOperation -> {\n+                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                Object[] values = o.operands().stream().map(bc::getValue).toArray();\n+                return invoke(mh, values);\n+            }\n+            case CoreOp.TestOperation testOperation -> {\n+                MethodHandle mh = opHandle(l, o.opName(), o.opType());\n+                Object[] values = o.operands().stream().map(bc::getValue).toArray();\n+                return invoke(mh, values);\n+            }\n+            case CoreOp.ConvOp convOp -> {\n+                MethodHandle mh = opHandle(l, o.opName() + \"_\" + o.opType().returnType(), o.opType());\n+                Object[] values = o.operands().stream().map(bc::getValue).toArray();\n+                return invoke(mh, values);\n+            }\n+            case CoreOp.ConcatOp concatOp -> {\n+                return o.operands().stream()\n+                        .map(bc::getValue)\n+                        .map(String::valueOf)\n+                        .collect(Collectors.joining());\n+            }\n+            \/\/ @@@\n+\/\/            case CoreOp.LambdaOp lambdaOp -> {\n+\/\/                interpretEntryBlock(l, lambdaOp.body().entryBlock(), oc, new HashMap<>());\n+\/\/                unevaluatedOperations.add(o);\n+\/\/                return null;\n+\/\/            }\n+\/\/            case CoreOp.FuncOp funcOp -> {\n+\/\/                interpretEntryBlock(l, funcOp.body().entryBlock(), oc, new HashMap<>());\n+\/\/                unevaluatedOperations.add(o);\n+\/\/                return null;\n+\/\/            }\n+            case null, default -> throw evaluationException(\n+                    new UnsupportedOperationException(\"Unsupported operation: \" + o.opName()));\n+        }\n+    }\n+\n+\n+    static MethodHandle opHandle(MethodHandles.Lookup l, String opName, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(l, ft).erase();\n+        try {\n+            return MethodHandles.lookup().findStatic(InvokableLeafOps.class, opName, mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw evaluationException(e);\n+        }\n+    }\n+\n+    static MethodHandle constructorHandle(MethodHandles.Lookup l, FunctionType ft) {\n+        MethodType mt = resolveToMethodType(l, ft);\n+\n+        if (mt.returnType().isArray()) {\n+            if (mt.parameterCount() != 1 || mt.parameterType(0) != int.class) {\n+                throw evaluationException(new IllegalArgumentException(\"Bad constructor descriptor: \" + ft));\n+            }\n+            return MethodHandles.arrayConstructor(mt.returnType());\n+        } else {\n+            try {\n+                return l.findConstructor(mt.returnType(), mt.changeReturnType(void.class));\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw evaluationException(e);\n+            }\n+        }\n+    }\n+\n+    static VarHandle fieldStaticHandle(MethodHandles.Lookup l, FieldRef d) {\n+        return resolveToVarHandle(l, d);\n+    }\n+\n+    static VarHandle fieldHandle(MethodHandles.Lookup l, FieldRef d) {\n+        return resolveToVarHandle(l, d);\n+    }\n+\n+    static Object isInstance(MethodHandles.Lookup l, TypeElement d, Object v) {\n+        Class<?> c = resolveToClass(l, d);\n+        return c.isInstance(v);\n+    }\n+\n+    static Object cast(MethodHandles.Lookup l, TypeElement d, Object v) {\n+        Class<?> c = resolveToClass(l, d);\n+        return c.cast(v);\n+    }\n+\n+    static MethodHandle resolveToMethodHandle(MethodHandles.Lookup l, MethodRef d, CoreOp.InvokeOp.InvokeKind kind) {\n+        try {\n+            return d.resolveToHandle(l, kind);\n+        } catch (ReflectiveOperationException e) {\n+            throw evaluationException(e);\n+        }\n+    }\n+\n+    static VarHandle resolveToVarHandle(MethodHandles.Lookup l, FieldRef d) {\n+        try {\n+            return d.resolveToHandle(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw evaluationException(e);\n+        }\n+    }\n+\n+    public static MethodType resolveToMethodType(MethodHandles.Lookup l, FunctionType ft) {\n+        try {\n+            return MethodRef.toNominalDescriptor(ft).resolveConstantDesc(l);\n+        } catch (ReflectiveOperationException e) {\n+            throw evaluationException(e);\n+        }\n+    }\n+\n+    public static Class<?> resolveToClass(MethodHandles.Lookup l, TypeElement d) {\n+        try {\n+            if (d instanceof JavaType jt) {\n+                return (Class<?>) jt.erasure().resolve(l);\n+            } else {\n+                throw new ReflectiveOperationException();\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw evaluationException(e);\n+        }\n+    }\n+\n+    static Object invoke(MethodHandle m, Object... args) {\n+        try {\n+            return m.invokeWithArguments(args);\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            eraseAndThrow(e);\n+            throw new InternalError(\"should not reach here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/PartialEvaluator.java","additions":584,"deletions":0,"binary":false,"changes":584,"status":"added"},{"patch":"@@ -0,0 +1,705 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.*;\n+import java.util.function.IntConsumer;\n+import java.util.function.Predicate;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code\n+ * @build TestPE\n+ * @build CodeReflectionTester\n+ * @run main CodeReflectionTester TestPE\n+ * @enablePreview\n+ *\/\n+\n+public class TestPE {\n+\n+    public static MethodHandles.Lookup lookup() {\n+        return MethodHandles.lookup();\n+    }\n+\n+    public static Predicate<Op> opConstants() {\n+        return op -> switch (op) {\n+            case CoreOp.ConstantOp _ -> true;\n+            case CoreOp.InvokeOp _ -> false;\n+            case CoreOp.ReturnOp _ -> false;\n+            default -> op.result() != null;\n+        };\n+    }\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"ifStatement\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                %2 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %3 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %4 : java.type:\"int\" = constant @1;\n+                invoke %3 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"ifStatement\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                %2 : java.type:\"int\" = constant @1;\n+                invoke %1 %2 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void ifStatement(IntConsumer c) {\n+        if (true) {\n+            c.accept(1);\n+        } else {\n+            c.accept(2);\n+        }\n+    }\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"forStatement\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                %2 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %3 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %4 : java.type:\"int\" = constant @0;\n+                invoke %3 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %5 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %6 : java.type:\"int\" = constant @2;\n+                invoke %5 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %7 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %8 : java.type:\"int\" = constant @-4;\n+                invoke %7 %8 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %9 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %10 : java.type:\"int\" = constant @6;\n+                invoke %9 %10 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %11 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %12 : java.type:\"int\" = constant @-8;\n+                invoke %11 %12 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"forStatement\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                %2 : java.type:\"int\" = constant @0;\n+                invoke %1 %2 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %3 : java.type:\"int\" = constant @2;\n+                invoke %1 %3 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %4 : java.type:\"int\" = constant @-4;\n+                invoke %1 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %5 : java.type:\"int\" = constant @6;\n+                invoke %1 %5 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %6 : java.type:\"int\" = constant @-8;\n+                invoke %1 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void forStatement(IntConsumer c) {\n+        for (int i = 0; i < 5; i++) {\n+            int v;\n+            if (i % 2 == 0) {\n+                v = -i * 2;\n+            } else {\n+                v = i * 2;\n+            }\n+            c.accept(v);\n+        }\n+    }\n+\/\/\n+    @CodeReflection\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"forStatementNonConstant\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %4 : Var<java.type:\"int\"> = var %2 @\"n\";\n+                %5 : java.type:\"int\" = constant @0;\n+                %6 : java.type:\"int\" = var.load %4;\n+                %7 : java.type:\"boolean\" = lt %5 %6;\n+                cbranch %7 ^block_1 ^block_4;\n+\n+              ^block_1:\n+                %8 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %9 : java.type:\"int\" = constant @2;\n+                invoke %8 %9 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                branch ^block_2;\n+\n+              ^block_2:\n+                %10 : java.type:\"int\" = constant @1;\n+                %11 : java.type:\"int\" = var.load %4;\n+                %12 : java.type:\"boolean\" = lt %10 %11;\n+                cbranch %12 ^block_3 ^block_4;\n+\n+              ^block_3:\n+                %13 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %14 : java.type:\"int\" = constant @2;\n+                invoke %13 %14 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                branch ^block_2;\n+\n+              ^block_4:\n+                return;\n+            };\n+            \"\"\",\n+            ssa = false\n+    )\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"forStatementNonConstant\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : java.type:\"int\" = constant @0;\n+                %4 : java.type:\"boolean\" = lt %3 %2;\n+                cbranch %4 ^block_1 ^block_4;\n+\n+              ^block_1:\n+                %5 : java.type:\"int\" = constant @2;\n+                invoke %1 %5 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %6 : java.type:\"int\" = constant @1;\n+                branch ^block_2(%6);\n+\n+              ^block_2(%7 : java.type:\"int\"):\n+                %8 : java.type:\"boolean\" = lt %7 %2;\n+                cbranch %8 ^block_3 ^block_4;\n+\n+              ^block_3:\n+                %9 : java.type:\"int\" = constant @2;\n+                invoke %1 %9 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %10 : java.type:\"int\" = constant @1;\n+                %11 : java.type:\"int\" = add %7 %10;\n+                branch ^block_2(%11);\n+\n+              ^block_4:\n+                return;\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void forStatementNonConstant(IntConsumer c, int n) {\n+        for (int i = 0; i < n; i++) {\n+            int v;\n+            if (false) {\n+                v = -1;\n+            } else {\n+                v = 2;\n+            }\n+            c.accept(v);\n+        }\n+    }\n+\n+    boolean b = true;\n+    int[] x = new int[10];\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"f\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                 %2 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                 %3 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %4 : java.type:\"int\" = constant @1;\n+                 invoke %3 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %5 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %6 : java.type:\"int\" = constant @3;\n+                 invoke %5 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %7 : java.type:\"boolean\" = field.load %0 @java.ref:\"TestPE::b:boolean\";\n+                 cbranch %7 ^block_1 ^block_2;\n+\n+               ^block_1:\n+                 %8 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %9 : java.type:\"int\" = constant @5;\n+                 invoke %8 %9 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %10 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %11 : java.type:\"int\" = constant @0;\n+                 invoke %10 %11 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %12 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %13 : java.type:\"int\" = constant @6;\n+                 invoke %12 %13 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %14 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %15 : java.type:\"int\" = constant @1;\n+                 invoke %14 %15 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %16 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %17 : java.type:\"int\" = constant @0;\n+                 %18 : java.type:\"int[]\" = field.load %0 @java.ref:\"TestPE::x:int[]\";\n+                 %19 : java.type:\"int\" = constant @0;\n+                 %20 : java.type:\"int\" = array.load %18 %19;\n+                 %21 : java.type:\"int\" = add %17 %20;\n+                 invoke %16 %21 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %22 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %23 : java.type:\"int\" = constant @1;\n+                 invoke %22 %23 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %24 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %25 : java.type:\"int\" = constant @7;\n+                 invoke %24 %25 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %26 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %27 : java.type:\"int\" = constant @2;\n+                 invoke %26 %27 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %28 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %29 : java.type:\"int\" = constant @1;\n+                 %30 : java.type:\"int[]\" = field.load %0 @java.ref:\"TestPE::x:int[]\";\n+                 %31 : java.type:\"int\" = constant @1;\n+                 %32 : java.type:\"int\" = array.load %30 %31;\n+                 %33 : java.type:\"int\" = add %29 %32;\n+                 invoke %28 %33 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %34 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %35 : java.type:\"int\" = constant @2;\n+                 invoke %34 %35 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %36 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %37 : java.type:\"int\" = constant @7;\n+                 invoke %36 %37 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %38 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %39 : java.type:\"int\" = constant @2;\n+                 invoke %38 %39 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %40 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %41 : java.type:\"int\" = constant @2;\n+                 %42 : java.type:\"int[]\" = field.load %0 @java.ref:\"TestPE::x:int[]\";\n+                 %43 : java.type:\"int\" = constant @2;\n+                 %44 : java.type:\"int\" = array.load %42 %43;\n+                 %45 : java.type:\"int\" = add %41 %44;\n+                 invoke %40 %45 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 %46 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %47 : java.type:\"int\" = constant @8;\n+                 invoke %46 %47 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 branch ^block_3;\n+\n+               ^block_2:\n+                 branch ^block_3;\n+\n+               ^block_3:\n+                 %48 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                 %49 : java.type:\"int\" = constant @9;\n+                 invoke %48 %49 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                 return;\n+             };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"f\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                   %2 : java.type:\"int\" = constant @1;\n+                   invoke %1 %2 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %3 : java.type:\"int\" = constant @3;\n+                   invoke %1 %3 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %4 : java.type:\"boolean\" = field.load %0 @java.ref:\"TestPE::b:boolean\";\n+                   cbranch %4 ^block_1 ^block_2;\n+\n+                 ^block_1:\n+                   %5 : java.type:\"int\" = constant @5;\n+                   invoke %1 %5 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %6 : java.type:\"int\" = constant @0;\n+                   invoke %1 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %7 : java.type:\"int\" = constant @6;\n+                   invoke %1 %7 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %8 : java.type:\"int\" = constant @1;\n+                   invoke %1 %8 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %9 : java.type:\"int[]\" = field.load %0 @java.ref:\"TestPE::x:int[]\";\n+                   %10 : java.type:\"int\" = array.load %9 %6;\n+                   %11 : java.type:\"int\" = add %6 %10;\n+                   invoke %1 %11 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %12 : java.type:\"int\" = constant @1;\n+                   invoke %1 %12 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %13 : java.type:\"int\" = constant @7;\n+                   invoke %1 %13 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %14 : java.type:\"int\" = constant @2;\n+                   invoke %1 %14 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %15 : java.type:\"int[]\" = field.load %0 @java.ref:\"TestPE::x:int[]\";\n+                   %16 : java.type:\"int\" = array.load %15 %12;\n+                   %17 : java.type:\"int\" = add %12 %16;\n+                   invoke %1 %17 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %18 : java.type:\"int\" = constant @2;\n+                   invoke %1 %18 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %19 : java.type:\"int\" = constant @7;\n+                   invoke %1 %19 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %20 : java.type:\"int\" = constant @2;\n+                   invoke %1 %20 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %21 : java.type:\"int[]\" = field.load %0 @java.ref:\"TestPE::x:int[]\";\n+                   %22 : java.type:\"int\" = array.load %21 %18;\n+                   %23 : java.type:\"int\" = add %18 %22;\n+                   invoke %1 %23 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   %24 : java.type:\"int\" = constant @8;\n+                   invoke %1 %24 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   branch ^block_3;\n+\n+                 ^block_2:\n+                   branch ^block_3;\n+\n+                 ^block_3:\n+                   %25 : java.type:\"int\" = constant @9;\n+                   invoke %1 %25 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                   return;\n+               };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void f(IntConsumer c) {\n+        c.accept(1);\n+\n+        if (false) {\n+            c.accept(2);\n+        } else if (true) {\n+            c.accept(3);\n+        } else {\n+            c.accept(4);\n+        }\n+\n+        if (b) {\n+            c.accept(5);\n+            for (int i = 0; i < 3; i++) {\n+                c.accept(i);\n+                int v;\n+                if (i == 0) {\n+                    c.accept(6);\n+                    v = 1;\n+                } else {\n+                    c.accept(7);\n+                    v = 2;\n+                }\n+                c.accept(v);\n+                c.accept(i + x[i]);\n+            }\n+\n+            c.accept(8);\n+        }\n+\n+        c.accept(9);\n+    }\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"constantsInBranches\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %4 : Var<java.type:\"int\"> = var %2 @\"arg\";\n+                %5 : java.type:\"int\" = var.load %4;\n+                %6 : Var<java.type:\"int\"> = var %5 @\"x\";\n+                %7 : java.type:\"int\" = var.load %6;\n+                %8 : java.type:\"int\" = constant @0;\n+                %9 : java.type:\"boolean\" = eq %7 %8;\n+                cbranch %9 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %10 : java.type:\"int\" = constant @1;\n+                var.store %6 %10;\n+                branch ^block_3;\n+\n+              ^block_2:\n+                %11 : java.type:\"int\" = constant @2;\n+                var.store %6 %11;\n+                branch ^block_3;\n+\n+              ^block_3:\n+                %12 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %13 : java.type:\"int\" = var.load %6;\n+                invoke %12 %13 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"constantsInBranches\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : java.type:\"int\" = constant @0;\n+                %4 : java.type:\"boolean\" = eq %2 %3;\n+                cbranch %4 ^block_1 ^block_2;\n+\n+              ^block_1:\n+                %5 : java.type:\"int\" = constant @1;\n+                branch ^block_3(%5);\n+\n+              ^block_2:\n+                %6 : java.type:\"int\" = constant @2;\n+                branch ^block_3(%6);\n+\n+              ^block_3(%7 : java.type:\"int\"):\n+                invoke %1 %7 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void constantsInBranches(IntConsumer c, int arg) {\n+        var x = arg;\n+        if (x == 0) {\n+            x = 1;\n+        } else {\n+            x = 2;\n+        }\n+        c.accept(x);\n+    }\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"nestedForStatement\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                %2 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %3 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %4 : java.type:\"int\" = constant @0;\n+                invoke %3 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %5 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %6 : java.type:\"int\" = constant @1;\n+                invoke %5 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %7 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %8 : java.type:\"int\" = constant @2;\n+                invoke %7 %8 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %9 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %10 : java.type:\"int\" = constant @1;\n+                invoke %9 %10 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %11 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %12 : java.type:\"int\" = constant @2;\n+                invoke %11 %12 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %13 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %14 : java.type:\"int\" = constant @3;\n+                invoke %13 %14 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %15 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %16 : java.type:\"int\" = constant @2;\n+                invoke %15 %16 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %17 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %18 : java.type:\"int\" = constant @3;\n+                invoke %17 %18 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %19 : java.type:\"java.util.function.IntConsumer\" = var.load %2;\n+                %20 : java.type:\"int\" = constant @4;\n+                invoke %19 %20 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"nestedForStatement\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\")java.type:\"void\" -> {\n+                %2 : java.type:\"int\" = constant @0;\n+                invoke %1 %2 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %3 : java.type:\"int\" = constant @1;\n+                invoke %1 %3 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %4 : java.type:\"int\" = constant @2;\n+                invoke %1 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %5 : java.type:\"int\" = constant @1;\n+                invoke %1 %5 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %6 : java.type:\"int\" = constant @2;\n+                invoke %1 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %7 : java.type:\"int\" = constant @3;\n+                invoke %1 %7 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %8 : java.type:\"int\" = constant @2;\n+                invoke %1 %8 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %9 : java.type:\"int\" = constant @3;\n+                invoke %1 %9 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %10 : java.type:\"int\" = constant @4;\n+                invoke %1 %10 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void nestedForStatement(IntConsumer c) {\n+        for (int i = 0; i < 3; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                c.accept(i + j);\n+            }\n+        }\n+    }\n+\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"whileWithBreak\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %4 : Var<java.type:\"int\"> = var %2 @\"n\";\n+                %5 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %6 : java.type:\"int\" = constant @0;\n+                invoke %5 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %7 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %8 : java.type:\"int\" = constant @1;\n+                invoke %7 %8 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %9 : java.type:\"int\" = constant @2;\n+                %10 : java.type:\"int\" = var.load %4;\n+                %11 : java.type:\"boolean\" = ge %9 %10;\n+                cbranch %11 ^block_3 ^block_1;\n+\n+              ^block_1:\n+                %12 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %13 : java.type:\"int\" = constant @2;\n+                invoke %12 %13 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                branch ^block_2;\n+\n+              ^block_2:\n+                %14 : java.type:\"int\" = constant @3;\n+                %15 : java.type:\"int\" = var.load %4;\n+                %16 : java.type:\"boolean\" = ge %14 %15;\n+                cbranch %16 ^block_3 ^block_4;\n+\n+              ^block_3:\n+                %17 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %18 : java.type:\"int\" = constant @-1;\n+                invoke %17 %18 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+\n+              ^block_4:\n+                %19 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %20 : java.type:\"int\" = constant @3;\n+                invoke %19 %20 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                branch ^block_2;\n+            };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"whileWithBreak\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : java.type:\"int\" = constant @0;\n+                invoke %1 %3 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %4 : java.type:\"int\" = constant @1;\n+                invoke %1 %4 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %5 : java.type:\"int\" = constant @2;\n+                %6 : java.type:\"boolean\" = ge %5 %2;\n+                cbranch %6 ^block_4 ^block_1;\n+\n+              ^block_1:\n+                invoke %1 %5 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %7 : java.type:\"int\" = constant @3;\n+                branch ^block_2(%7);\n+\n+              ^block_2(%8 : java.type:\"int\"):\n+                %9 : java.type:\"int\" = constant @2;\n+                %10 : java.type:\"boolean\" = ge %8 %9;\n+                cbranch %10 ^block_3 ^block_6;\n+\n+              ^block_3:\n+                %11 : java.type:\"boolean\" = ge %8 %2;\n+                cbranch %11 ^block_4 ^block_5;\n+\n+              ^block_4:\n+                %12 : java.type:\"int\" = constant @-1;\n+                invoke %1 %12 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+\n+              ^block_5:\n+                branch ^block_7;\n+\n+              ^block_6:\n+                branch ^block_7;\n+\n+              ^block_7:\n+                invoke %1 %8 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %13 : java.type:\"int\" = constant @1;\n+                %14 : java.type:\"int\" = add %8 %13;\n+                branch ^block_2(%14);\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void whileWithBreak(IntConsumer c, int n) {\n+        int i = 0;\n+        while (true) {\n+            if (i >= 2) {\n+                if (i >= n) {\n+                    break;\n+                }\n+            }\n+            c.accept(i);\n+            i += 1;\n+        }\n+        c.accept(-1);\n+    }\n+\n+    @CodeReflection\n+    @EvaluatedModel(\"\"\"\n+            func @\"whileWithBreakAndContinue\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : Var<java.type:\"java.util.function.IntConsumer\"> = var %1 @\"c\";\n+                %4 : Var<java.type:\"int\"> = var %2 @\"n\";\n+                %5 : java.type:\"int\" = constant @2;\n+                %6 : java.type:\"int\" = var.load %4;\n+                %7 : java.type:\"boolean\" = ge %5 %6;\n+                cbranch %7 ^block_3 ^block_1;\n+\n+              ^block_1:\n+                branch ^block_2;\n+\n+              ^block_2:\n+                %8 : java.type:\"int\" = constant @4;\n+                %9 : java.type:\"int\" = var.load %4;\n+                %10 : java.type:\"boolean\" = ge %8 %9;\n+                cbranch %10 ^block_3 ^block_4;\n+\n+              ^block_3:\n+                %11 : java.type:\"java.util.function.IntConsumer\" = var.load %3;\n+                %12 : java.type:\"int\" = constant @-1;\n+                invoke %11 %12 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+\n+              ^block_4:\n+                branch ^block_2;\n+            };\n+            \"\"\")\n+    @EvaluatedModel(value = \"\"\"\n+            func @\"whileWithBreakAndContinue\" (%0 : java.type:\"TestPE\", %1 : java.type:\"java.util.function.IntConsumer\", %2 : java.type:\"int\")java.type:\"void\" -> {\n+                %3 : java.type:\"int\" = constant @2;\n+                %4 : java.type:\"boolean\" = ge %3 %2;\n+                cbranch %4 ^block_4 ^block_1;\n+\n+              ^block_1:\n+                %5 : java.type:\"int\" = constant @4;\n+                branch ^block_2(%5);\n+\n+              ^block_2(%6 : java.type:\"int\"):\n+                %7 : java.type:\"int\" = constant @2;\n+                %8 : java.type:\"boolean\" = ge %6 %7;\n+                cbranch %8 ^block_3 ^block_6;\n+\n+              ^block_3:\n+                %9 : java.type:\"boolean\" = ge %6 %2;\n+                cbranch %9 ^block_4 ^block_5;\n+\n+              ^block_4:\n+                %10 : java.type:\"int\" = constant @-1;\n+                invoke %1 %10 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                return;\n+\n+              ^block_5:\n+                branch ^block_7;\n+\n+              ^block_6:\n+                branch ^block_7;\n+\n+              ^block_7:\n+                %11 : java.type:\"int\" = constant @5;\n+                %12 : java.type:\"boolean\" = lt %6 %11;\n+                cbranch %12 ^block_8 ^block_9;\n+\n+              ^block_8:\n+                %13 : java.type:\"int\" = constant @2;\n+                %14 : java.type:\"int\" = add %6 %13;\n+                branch ^block_2(%14);\n+\n+              ^block_9:\n+                invoke %1 %6 @java.ref:\"java.util.function.IntConsumer::accept(int):void\";\n+                %15 : java.type:\"int\" = constant @1;\n+                %16 : java.type:\"int\" = add %6 %15;\n+                branch ^block_2(%16);\n+            };\n+            \"\"\",\n+            ssa = true\n+    )\n+    void whileWithBreakAndContinue(IntConsumer c, int n) {\n+        int i = 0;\n+        while (true) {\n+            if (i >= 2) {\n+                if (i >= n) {\n+                    break;\n+                }\n+            }\n+            if (i < 5) {\n+                i += 2;\n+                continue;\n+            }\n+            c.accept(i);\n+            i += 1;\n+        }\n+        c.accept(-1);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/pe\/TestPE.java","additions":705,"deletions":0,"binary":false,"changes":705,"status":"added"}]}