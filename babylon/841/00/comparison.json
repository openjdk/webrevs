{"files":[{"patch":"@@ -65,3 +65,0 @@\n-\n-        public static final String INTRINSIC_NAME = \"createLocal\";\n-\n@@ -113,3 +110,0 @@\n-\n-        public static final String INTRINSIC_NAME = \"createPrivate\";\n-\n@@ -164,1 +158,0 @@\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATMemoryVarOp.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,5 +53,0 @@\n-  \/\/  @Override\n-  \/\/  final public Map<String, Object> externalize() {\n-    \/\/    return Map.of(\"hat.dialect.\" + getClass().getSimpleName(), \"\");\n-   \/\/ }\n-\n","filename":"hat\/core\/src\/main\/java\/hat\/dialect\/HATThreadOp.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,28 +44,16 @@\n-        Stream<CodeElement<?, ?>> elements = funcOp.elements();\n-        elements.forEach(codeElement -> {\n-            if (codeElement instanceof CoreOp.VarOp varOp) {\n-                Op.Result varResult = varOp.result();\n-                Set<Op.Result> uses = varResult.uses();\n-\n-                \/\/ Obtain if the varOp comes from a declaration of\n-                \/\/ a var with MappableIface type. If so, we can't\n-                \/\/ generate the constant, because at this point of the analysis\n-                \/\/ after the dialectify, the only accesses left are accesses\n-                \/\/ to global memory.\n-                if (!OpHelper.isAssignable(kernelCallGraph.lookup(), varOp.resultType().valueType(),\n-                        MappableIface.class, F16.class, BF16.class)) {\n-                    boolean isFinalVarOp = true;\n-                    for (Op.Result use : uses) {\n-                        switch (use.op()) {\n-                            case CoreOp.VarAccessOp.VarStoreOp storeOp when\n-                                (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) ->\n-                                    isFinalVarOp = false;\n-                            case CoreOp.YieldOp yieldOp when\n-                                 (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult))) ->\n-                                    isFinalVarOp = false;\n-                            case null, default -> {\n-                            }\n-                        }\n-                    }\n-                    if (isFinalVarOp) {\n-                        finalVars.put(varResult, varOp);\n+        OpHelper.Named.Var.stream(kernelCallGraph.lookup(),funcOp)\n+                .filter(varOpHelper->!varOpHelper.assignable(MappableIface.class, F16.class, BF16.class))\n+                .forEach(varOpHelper->{\n+                    \/\/ At this point the varOp DOES NOT come from a declaration of a var with MappableIface type.\n+                    \/\/ For those we can't generate the constant, because at this point of the analysis\n+                    \/\/ the only accesses left are accesses to global memory.\n+                    Op.Result varResult = varOpHelper.op().result();\n+                    if (!varResult.uses().stream()\n+                            .map(use->use.op())\n+                            .anyMatch(op->\n+                                    (op instanceof CoreOp.VarAccessOp.VarStoreOp storeOp &&\n+                                            (storeOp.operands().stream().anyMatch(operand -> operand.equals(varResult))))\n+                                ||\n+                                    (op instanceof CoreOp.YieldOp yieldOp &&\n+                                            (yieldOp.operands().stream().anyMatch(operand -> operand.equals(varResult)))))){\n+                        finalVars.put(varResult, varOpHelper.op());\n@@ -73,2 +61,0 @@\n-                }\n-            }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATFinalDetector.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import optkl.OpHelper;\n@@ -40,0 +41,1 @@\n+import optkl.util.Regex;\n@@ -46,2 +48,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -62,1 +62,0 @@\n-    private static final Set<String> reservedMethods = new HashSet<>();\n@@ -64,9 +63,1 @@\n-    static {\n-        reservedMethods.add(\"createLocal\");\n-        reservedMethods.add(\"createPrivate\");\n-        reservedMethods.add(\"create\");\n-        reservedMethods.add(\"float2View\");\n-        reservedMethods.add(\"float4View\");\n-    }\n-\n-    protected abstract HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n+    protected abstract HATMemoryVarOp create(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp);\n@@ -82,1 +73,1 @@\n-        Set<CoreOp.VarOp> removeMe = new LinkedHashSet<>();\n+        Set<CodeElement<?,?>> nodesInvolved = new LinkedHashSet<>();\n@@ -84,8 +75,3 @@\n-\n-        funcOp.elements()\n-                .filter(e -> e instanceof CoreOp.VarOp )\n-                .map(e-> (CoreOp.VarOp) e)\n-                .forEach(varOp->varOp\n-                        .operands()\n-                        .stream()\n-                        .filter(o -> o instanceof Op.Result result\n+        OpHelper.Named.Var.stream(lookup(),funcOp)\n+                .forEach(varHelper->varHelper.op().operands().stream()\n+                        .filter(operand -> operand instanceof Op.Result result\n@@ -96,1 +82,1 @@\n-                            removeMe.add(varOp);\n+                            nodesInvolved.add(varHelper.op());\n@@ -101,1 +87,1 @@\n-        return Trxfmr.of(this,funcOp).transform(ce->mapMe.contains(ce)||removeMe.contains(ce), (blockBuilder, op) -> {\n+        return Trxfmr.of(this,funcOp).transform(ce->mapMe.contains(ce)||nodesInvolved.contains(ce), (blockBuilder, op) -> {\n@@ -107,1 +93,1 @@\n-                            blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(factory(blockBuilder, varOp, invoke.op())))\n+                            blockBuilder.context().mapValue(invoke.op().result(), blockBuilder.op(create(blockBuilder, varOp, invoke.op())))\n@@ -109,2 +95,2 @@\n-            } else if (op instanceof CoreOp.VarOp varOp && removeMe.contains(varOp)) {\n-                blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n+            } else if (OpHelper.Named.Var.var(lookup(),op) instanceof OpHelper.Named.Var varHelper && nodesInvolved.contains(varHelper.op())) {\n+                blockBuilder.context().mapValue(varHelper.op().result(), blockBuilder.context().getValue(varHelper.op().operands().getFirst()));\n@@ -123,1 +109,1 @@\n-\n+        public static final String INTRINSIC_NAME = \"createPrivate\";\n@@ -127,1 +113,1 @@\n-                    && invoke.named(HATMemoryVarOp.HATPrivateVarOp.INTRINSIC_NAME);\n+                    && invoke.named(INTRINSIC_NAME);\n@@ -132,1 +118,1 @@\n-        protected HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+        protected HATMemoryVarOp create(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n@@ -149,1 +135,1 @@\n-\n+        public static final String INTRINSIC_NAME = \"createLocal\";\n@@ -152,2 +138,1 @@\n-            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n-                    && invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME);\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class) && invoke.named(INTRINSIC_NAME);\n@@ -158,1 +143,1 @@\n-        protected HATMemoryVarOp factory(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+        protected HATMemoryVarOp create(Block.Builder builder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n@@ -174,1 +159,1 @@\n-\n+        public static final String INTRINSIC_NAME = \"createLocal\";\n@@ -177,2 +162,1 @@\n-            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class)\n-                 || invoke.named(HATMemoryVarOp.HATLocalVarOp.INTRINSIC_NAME);\n+            return invoke.refIs( DeviceType.class, MappableIface.class, HAType.class) && invoke.named(INTRINSIC_NAME);\n@@ -181,0 +165,1 @@\n+        static private Regex reservedMethods = Regex.of(\"(createLocal|createPrivate|create|float2View|float4View)\");\n@@ -184,21 +169,13 @@\n-            Stream<CodeElement<?, ?>> memoryLoadOps = funcOp.elements()\n-                    .mapMulti((codeElement, consumer) -> {\n-                        if (invoke(lookup(),codeElement) instanceof Invoke invoke\n-                             && invoke.refIs(DeviceType.class)\n-                                    && !invoke.returnsVoid()\n-                                    && !invoke.returnsPrimitive()\n-                                    && !reservedMethods.contains(invoke.name())) {\n-                                Op.Result result = invoke.op().result();\n-                                Set<Op.Result> uses = result.uses();\n-                                for (Op.Result use : uses) {\n-                                    if (use.op() instanceof CoreOp.VarOp varOp) {\n-                                        varTable.put(varOp, invoke.op());\n-                                        consumer.accept(invoke.op());\n-                                        consumer.accept(varOp);\n-                                    }\n-                                }\n-\n-                        }\n-                    });\n-\n-            Set<CodeElement<?, ?>> nodesInvolved = memoryLoadOps.collect(Collectors.toSet());\n+            Set<CodeElement<?, ?>> nodesInvolved = new HashSet<>();\n+            Invoke.stream(lookup(),funcOp)\n+                    .filter(invoke->invoke.refIs(DeviceType.class) && invoke.returnsClassType() && !invoke.named(reservedMethods))\n+                    .forEach(invoke -> invoke.op().result().uses().stream()\n+                           .filter(use->use.op() instanceof CoreOp.VarOp)\n+                           .map(use->(CoreOp.VarOp)use.op())\n+                           .forEach(varOp -> {\n+                                varTable.put(varOp, invoke.op());\n+                                nodesInvolved.add(invoke.op());\n+                                nodesInvolved.add(varOp);\n+                           })\n+                    );\n+\n@@ -216,1 +193,1 @@\n-                    factory(blockBuilder, varOp, varTable.get(varOp));\n+                    create(blockBuilder, varOp, varTable.get(varOp));\n@@ -222,2 +199,2 @@\n-        protected HATMemoryVarOp factory(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n-            HATMemoryVarOp.HATPrivateInitVarOp privateVarOp = new HATMemoryVarOp.HATPrivateInitVarOp(varOp.varName(),\n+        protected HATMemoryVarOp create(Block.Builder blockBuilder, CoreOp.VarOp varOp, JavaOp.InvokeOp invokeOp) {\n+            var  privateVarOp = copyLocation(varOp,new HATMemoryVarOp.HATPrivateInitVarOp(varOp.varName(),\n@@ -227,4 +204,2 @@\n-                    blockBuilder.context().getValues(varOp.operands()));\n-            Op.Result op1 = blockBuilder.op(privateVarOp);\n-            privateVarOp.setLocation(varOp.location());\n-            blockBuilder.context().mapValue(varOp.result(), op1);\n+                    blockBuilder.context().getValues(varOp.operands())));\n+            blockBuilder.context().mapValue(varOp.result(), blockBuilder.op(privateVarOp));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATMemoryPhase.java","additions":39,"deletions":64,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -135,2 +135,2 @@\n-     default <C>boolean isAssignable(JavaType javaType, Class<C> clazz){\n-            return  OpHelper.isAssignable(lookup(),javaType,clazz);\n+     default boolean isAssignable(JavaType javaType, Class<?> ...clazzes){\n+            return  OpHelper.isAssignable(lookup(),javaType,clazzes);\n@@ -265,1 +265,1 @@\n-           return Set.of(names).contains(name());\n+           return named(Set.of(names));\n@@ -274,0 +274,3 @@\n+        default boolean named(Set<String> set){\n+            return set.contains(name());\n+        }\n@@ -297,2 +300,6 @@\n-            default  <T>boolean of(Class<T> clazz){\n-                return isAssignable((JavaType) op().varValueType(),clazz);\n+            default  boolean assignable(Class<?> ...clazzes){\n+                return isAssignable((JavaType) op().varValueType(),clazzes);\n+            }\n+\n+            default TypeElement type(){\n+                return op().resultType().valueType();\n@@ -300,0 +307,1 @@\n+\n@@ -455,2 +463,6 @@\n-                            TypeElement resultType = operand.type();\/\/instanceof VarType varType ? varType.valueType() : null;\n-                            assignable &= isAssignable((JavaType) resultType, classes[i]);\n+                            TypeElement resultType = operand.type();\n+                            if (resultType instanceof JavaType javaType) {\n+                                assignable &= isAssignable(javaType, classes[i]);\n+                            }else{\n+                                assignable=false;\n+                            }\n@@ -574,0 +586,1 @@\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"}]}