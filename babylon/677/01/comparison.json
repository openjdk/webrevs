{"files":[{"patch":"@@ -117,1 +117,1 @@\n-                Field initializerField = i.resolveToMember(lookup);\n+                Field initializerField = i.resolveToField(lookup);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-            var res = Op.ofMethod(io.invokeDescriptor().resolveToDirectMethod(l));\n+            var res = Op.ofMethod(io.invokeDescriptor().resolveToMethod(l));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                        <argLine>--enable-preview\n+                        <argLine>--enable-preview --add-modules jdk.incubator.code\n@@ -75,0 +75,1 @@\n+                        <arg>--add-modules<\/arg><arg>jdk.incubator.code<\/arg>\n","filename":"cr-examples\/triton\/pom.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                        f = flop.fieldDescriptor().resolveToMember(MethodHandles.lookup());\n+                        f = flop.fieldDescriptor().resolveToField(MethodHandles.lookup());\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                        invokeOpCalledMethod = methodRef.resolveToMethod(l, iop.invokeKind());\n+                        invokeOpCalledMethod = methodRef.resolveToMethod(l);\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup, invokeOp.invokeKind());\n+                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n@@ -132,1 +132,1 @@\n-                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(lookup, iop.invokeKind());\n+                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(lookup);\n@@ -266,1 +266,1 @@\n-            return op.invokeDescriptor().resolveToMethod(lookup, op.invokeKind());\n+            return op.invokeDescriptor().resolveToMethod(lookup);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-                Op.Result builder = block.op(JavaOp.new_(ConstructorRef.constructor(J_L_STRING_BUILDER)));\n+                Op.Result builder = block.op(JavaOp.new_(MethodRef.constructor(J_L_STRING_BUILDER)));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/StringConcatTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.dialect.java;\n-\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.java.impl.ConstructorRefImpl;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Constructor;\n-import java.util.List;\n-\n-import static jdk.incubator.code.dialect.core.CoreType.functionType;\n-\n-\/**\n- * The symbolic reference to a Java constructor.\n- *\/\n-public sealed interface ConstructorRef extends JavaRef, TypeVariableType.Owner\n-        permits ConstructorRefImpl {\n-\n-    FunctionType type();\n-\n-    default TypeElement refType() {\n-        return type().returnType();\n-    }\n-\n-    \/\/ Resolutions to constructors and method handles\n-\n-    \/\/ Resolve to constructor on referenced class\n-    Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    \/\/ Resolve to constructor on referenced class\n-    MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n-\n-    \/\/ Factories\n-\n-    static ConstructorRef constructor(Constructor<?> c) {\n-        return constructor(c.getDeclaringClass(),\n-                c.getParameterTypes());\n-    }\n-\n-    static ConstructorRef constructor(MethodType mt) {\n-        return constructor(mt.returnType(), mt.parameterList());\n-    }\n-\n-    static ConstructorRef constructor(Class<?> refType, Class<?>... params) {\n-        return constructor(refType, List.of(params));\n-    }\n-\n-    static ConstructorRef constructor(Class<?> refType, List<Class<?>> params) {\n-        return constructor(JavaType.type(refType), params.stream().map(JavaType::type).toList());\n-    }\n-\n-    static ConstructorRef constructor(TypeElement refType, List<? extends TypeElement> params) {\n-        return constructor(functionType(refType, params));\n-    }\n-\n-    static ConstructorRef constructor(TypeElement refType, TypeElement... params) {\n-        return constructor(functionType(refType, params));\n-    }\n-\n-    static ConstructorRef constructor(FunctionType type) {\n-        return new ConstructorRefImpl(type);\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/ConstructorRef.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -35,1 +36,11 @@\n- * The symbolic reference to a Java field.\n+ * The symbolic reference to a Java field, called the <em>target field<\/em>.\n+ * <p>\n+ * All field references are defined in terms of the following attributes:\n+ * <ul>\n+ *     <li>an <em>owner type<\/em>, the type of which the target field is a member;<\/li>\n+ *     <li>a <em>name<\/em>, the name of the target field.<\/li>\n+ *     <li>a <em>type<\/em>, the type of the target field.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Field references can be <em>resolved<\/em> to their corresponding {@linkplain #resolveToField(Lookup) target field}.\n+ * Or they can be turned into a {@linkplain #resolveToHandle(Lookup) var handle} that can be used to access the target field.\n@@ -40,0 +51,3 @@\n+    \/**\n+     * {@return the owner type of this method reference}\n+     *\/\n@@ -42,0 +56,3 @@\n+    \/**\n+     * {@return the name of this method reference}\n+     *\/\n@@ -44,0 +61,3 @@\n+    \/**\n+     * {@return the type of this method reference}\n+     *\/\n@@ -48,1 +68,9 @@\n-    Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    \/**\n+     * Resolves the target field associated with this field reference.\n+     * @return the field associated with this field reference\n+     * @param l the lookup used for resolving this field reference\n+     * @throws ReflectiveOperationException if a resolution error occurs\n+     * @throws UnsupportedOperationException if this reference is not a constructor reference\n+     * @throws IllegalArgumentException if the provided {@code kind} is unsupported for this method reference\n+     *\/\n+    Field resolveToField(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -50,0 +78,11 @@\n+    \/**\n+     * {@return a var handle used to access the target field associated with this field reference}\n+     * The var handle is obtained by invoking the corresponding method on the provided lookup, in the following order:\n+     * <ol>\n+     *     <li>first {@link MethodHandles.Lookup#findStaticVarHandle(Class, String, Class)} is used;<\/li>\n+     *     <li>if the above step fails, then {@link MethodHandles.Lookup#findVarHandle(Class, String, Class)} is used;<\/li>\n+     *     <li>otherwise, resolution fails and an exception is thrown<\/li>.\n+     * <\/ol>\n+     * @param l the lookup used for resolving this field reference\n+     * @throws ReflectiveOperationException if a resolution error occurs\n+     *\/\n@@ -54,0 +93,4 @@\n+    \/**\n+     * {@return a field reference obtained from the provided field}\n+     * @param f a reflective field\n+     *\/\n@@ -58,0 +101,6 @@\n+    \/**\n+     * {@return a field reference obtained from the provided owner, name and type}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param type the reference type\n+     *\/\n@@ -62,0 +111,6 @@\n+    \/**\n+     * {@return a field reference obtained from the provided owner, name and type}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param type the reference type\n+     *\/\n@@ -65,1 +120,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/FieldRef.java","additions":59,"deletions":4,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -788,1 +788,1 @@\n-        final ConstructorRef constructorDescriptor;\n+        final MethodRef constructorDescriptor;\n@@ -793,1 +793,1 @@\n-            ConstructorRef constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,\n+            MethodRef constructorDescriptor = def.extractAttributeValue(ATTRIBUTE_NEW_DESCRIPTOR,\n@@ -795,1 +795,1 @@\n-                        case ConstructorRef cd -> cd;\n+                        case MethodRef cd -> cd;\n@@ -823,1 +823,1 @@\n-        NewOp(boolean isVarargs, TypeElement resultType, ConstructorRef constructorDescriptor, List<Value> args) {\n+        NewOp(boolean isVarargs, TypeElement resultType, MethodRef constructorDescriptor, List<Value> args) {\n@@ -827,0 +827,3 @@\n+            if (!constructorDescriptor.isConstructor()) {\n+                throw new IllegalArgumentException(\"Not a constructor descriptor: \" + constructorDescriptor);\n+            }\n@@ -833,1 +836,1 @@\n-        static void validateArgCount(boolean isVarArgs, ConstructorRef constructorDescriptor, List<Value> operands) {\n+        static void validateArgCount(boolean isVarArgs, MethodRef constructorDescriptor, List<Value> operands) {\n@@ -860,1 +863,1 @@\n-        public ConstructorRef constructorDescriptor() {\n+        public MethodRef constructorDescriptor() {\n@@ -2802,1 +2805,1 @@\n-                        throwBlock.op(new_(ConstructorRef.constructor(NullPointerException.class)))\n+                        throwBlock.op(new_(MethodRef.constructor(NullPointerException.class)))\n@@ -5270,1 +5273,1 @@\n-    public static NewOp new_(ConstructorRef constructorDescriptor, Value... args) {\n+    public static NewOp new_(MethodRef constructorDescriptor, Value... args) {\n@@ -5281,1 +5284,1 @@\n-    public static NewOp new_(ConstructorRef constructorDescriptor, List<Value> args) {\n+    public static NewOp new_(MethodRef constructorDescriptor, List<Value> args) {\n@@ -5293,1 +5296,1 @@\n-    public static NewOp new_(TypeElement returnType, ConstructorRef constructorDescriptor,\n+    public static NewOp new_(TypeElement returnType, MethodRef constructorDescriptor,\n@@ -5306,1 +5309,1 @@\n-    public static NewOp new_(TypeElement returnType, ConstructorRef constructorDescriptor,\n+    public static NewOp new_(TypeElement returnType, MethodRef constructorDescriptor,\n@@ -5319,1 +5322,1 @@\n-    public static NewOp new_(boolean isVarargs, TypeElement returnType, ConstructorRef constructorDescriptor,\n+    public static NewOp new_(boolean isVarargs, TypeElement returnType, MethodRef constructorDescriptor,\n@@ -5332,1 +5335,1 @@\n-        ConstructorRef constructorDescriptor = ConstructorRef.constructor(arrayType, INT);\n+        MethodRef constructorDescriptor = MethodRef.constructor(arrayType, INT);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaOp.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-        permits MethodRef, ConstructorRef, FieldRef, RecordTypeRef {\n+        permits MethodRef, FieldRef, RecordTypeRef {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-            case Constructor<?> c -> ConstructorRef.constructor(c);\n+            case Constructor<?> c -> MethodRef.constructor(c);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/JavaType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n@@ -35,0 +36,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -36,0 +38,1 @@\n+import java.lang.reflect.Constructor;\n@@ -45,1 +48,14 @@\n- * The symbolic reference to a Java method.\n+ * The symbolic reference to a Java method, called the <em>target method<\/em>.\n+ * <p>\n+ * All method references are defined in terms of the following attributes:\n+ * <ul>\n+ *     <li>an <em>owner type<\/em>, the type of which the target method is a member;<\/li>\n+ *     <li>a <em>name<\/em>, the name of the target method.<\/li>\n+ *     <li>a <em>type<\/em>, the type of the target method.<\/li>\n+ * <\/ul>\n+ * Some method references, called <em>constructor references<\/em> are used to model a Java constructor, called\n+ * the <em>target constructor<\/em>. The name of a constructor reference is always the special name {@code \"<init>\"}.\n+ * <p>\n+ * Method references can be <em>resolved<\/em> to their corresponding {@linkplain #resolveToMethod(Lookup) target method} or\n+ * {@linkplain #resolveToMethod(Lookup) target constructor}. Or they can be turned into a\n+ * {@linkplain #resolveToHandle(Lookup, InvokeKind) method handle} that can be used to invoke the target method or constructor.\n@@ -50,0 +66,3 @@\n+    \/**\n+     * {@return the owner type of this method reference}\n+     *\/\n@@ -52,0 +71,3 @@\n+    \/**\n+     * {@return the name of this method reference}\n+     *\/\n@@ -54,0 +76,3 @@\n+    \/**\n+     * {@return the type of this method reference}\n+     *\/\n@@ -56,1 +81,4 @@\n-    \/\/ Resolutions to methods and method handles\n+    \/**\n+     * {@return {@code true}, if this method reference is a constructor reference}\n+     *\/\n+    boolean isConstructor();\n@@ -58,2 +86,1 @@\n-    \/\/ Resolve to static or instance method declared on referenced class\n-    Method resolveToDirectMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    \/\/ Resolutions to methods, constructors and method handles\n@@ -61,2 +88,8 @@\n-    \/\/ Resolve to static or instance method declared on referenced class\n-    MethodHandle resolveToDirectHandle(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    \/**\n+     * Resolves the target method associated with this method reference.\n+     * @return the method associated with this method reference\n+     * @param l the lookup used for resolving this method reference\n+     * @throws ReflectiveOperationException if a resolution error occurs\n+     * @throws UnsupportedOperationException if this reference is a constructor reference\n+     *\/\n+    Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -64,1 +97,9 @@\n-    Method resolveToMethod(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException;\n+    \/**\n+     * Resolves the target method associated with this method reference.\n+     * @return the constructor associated with this constructor reference\n+     * @param l the lookup used for resolving this method reference\n+     * @throws ReflectiveOperationException if a resolution error occurs\n+     * @throws UnsupportedOperationException if this reference is not a constructor reference\n+     * @throws IllegalArgumentException if the provided {@code kind} is unsupported for this method reference\n+     *\/\n+    Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -66,1 +107,16 @@\n-    \/\/ For InvokeKind.SUPER the specialCaller == l.lookupClass() for Lookup::findSpecial\n+    \/**\n+     * {@return a method handle used to invoke the target method or constructor associated with this method reference}\n+     * The method handle is obtained by invoking the corresponding method on the provided lookup, as determined by\n+     * the provided {@code kind}:\n+     * <ul>\n+     *     <li>if <code>kind == SUPER && isConstructor()<\/code>, then {@link MethodHandles.Lookup#findConstructor(Class, MethodType)} is used;<\/li>\n+     *     <li>if <code>kind == STATIC && !isConstructor()<\/code>, then {@link MethodHandles.Lookup#findStatic(Class, String, MethodType)} is used;<\/li>\n+     *     <li>if <code>kind == INSTANCE && !isConstructor()<\/code>, then {@link MethodHandles.Lookup#findVirtual(Class, String, MethodType)} is used;<\/li>\n+     *     <li>if <code>kind == SUPER && !isConstructor()<\/code>, then {@link MethodHandles.Lookup#findSpecial(Class, String, MethodType, Class)} is used;<\/li>\n+     *     <li>otherwise, the provided {@code kind} is unsupported for this method reference, and {@link IllegalArgumentException} is thrown<\/li>.\n+     * <\/ul>\n+     * @param l the lookup used for resolving this method reference\n+     * @param kind the invocation kind to be used for resolving this method reference\n+     * @throws ReflectiveOperationException if a resolution error occurs\n+     * @throws IllegalArgumentException if the provided {@code kind} is unsupported for this method reference\n+     *\/\n@@ -69,1 +125,1 @@\n-    \/\/ Factories\n+    \/\/ Method factories\n@@ -71,0 +127,4 @@\n+    \/**\n+     * {@return a method reference obtained from the provided method}\n+     * @param m a reflective method\n+     *\/\n@@ -77,0 +137,6 @@\n+    \/**\n+     * {@return a method reference obtained from the provided owner, name and type}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param mt the reference type\n+     *\/\n@@ -81,0 +147,7 @@\n+    \/**\n+     * {@return a method reference obtained from the provided owner, name, return type and parameter types}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param retType the reference return type\n+     * @param params the reference parameter types\n+     *\/\n@@ -85,0 +158,7 @@\n+    \/**\n+     * {@return a method reference obtained from the provided owner, name, return type and parameter types}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param retType the reference return type\n+     * @param params the reference parameter types\n+     *\/\n@@ -89,1 +169,6 @@\n-\n+    \/**\n+     * {@return a method reference obtained from the provided owner, name and type}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param type the reference type\n+     *\/\n@@ -94,0 +179,7 @@\n+    \/**\n+     * {@return a method reference obtained from the provided owner, name, return type and parameter types}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param retType the reference return type\n+     * @param params the reference parameter types\n+     *\/\n@@ -98,0 +190,7 @@\n+    \/**\n+     * {@return a method reference obtained from the provided owner, name, return type and parameter types}\n+     * @param refType the reference owner type\n+     * @param name the reference name\n+     * @param retType the reference return type\n+     * @param params the reference parameter types\n+     *\/\n@@ -102,0 +201,64 @@\n+    \/\/ Constructor factories\n+\n+    \/**\n+     * {@return a method reference obtained from the provided constructor}\n+     * @param c a reflective constructor\n+     *\/\n+    static MethodRef constructor(Constructor<?> c) {\n+        return constructor(c.getDeclaringClass(),\n+                c.getParameterTypes());\n+    }\n+\n+    \/**\n+     * {@return a method reference obtained from the provided type}\n+     * The owner type of the returned method reference is the return type of the provided type.\n+     * @param mt the reference type\n+     *\/\n+    static MethodRef constructor(MethodType mt) {\n+        return constructor(mt.returnType(), mt.parameterList());\n+    }\n+\n+    \/**\n+     * {@return a method reference obtained from the provided owner and parameter types}\n+     * @param refType the reference owner type\n+     * @param params the reference parameter types\n+     *\/\n+    static MethodRef constructor(Class<?> refType, Class<?>... params) {\n+        return constructor(refType, List.of(params));\n+    }\n+\n+    \/**\n+     * {@return a method reference obtained from the provided owner and parameter types}\n+     * @param refType the reference owner type\n+     * @param params the reference parameter types\n+     *\/\n+    static MethodRef constructor(Class<?> refType, List<Class<?>> params) {\n+        return constructor(JavaType.type(refType), params.stream().map(JavaType::type).toList());\n+    }\n+\n+    \/**\n+     * {@return a method reference obtained from the provided owner and parameter types}\n+     * @param refType the reference owner type\n+     * @param params the reference parameter types\n+     *\/\n+    static MethodRef constructor(TypeElement refType, List<? extends TypeElement> params) {\n+        return constructor(functionType(refType, params));\n+    }\n+\n+    \/**\n+     * {@return a method reference obtained from the provided owner and parameter types}\n+     * @param refType the reference owner type\n+     * @param params the reference parameter types\n+     *\/\n+    static MethodRef constructor(TypeElement refType, TypeElement... params) {\n+        return constructor(functionType(refType, params));\n+    }\n+\n+    \/**\n+     * {@return a method reference obtained from the provided type}\n+     * The owner type of the returned method reference is the return type of the provided type.\n+     * @param type the reference type\n+     *\/\n+    static MethodRef constructor(FunctionType type) {\n+        return new MethodRefImpl(type.returnType(), INIT_NAME, type);\n+    }\n@@ -125,1 +288,6 @@\n-}\n\\ No newline at end of file\n+\n+    \/**\n+     * The name of a constructor reference\n+     *\/\n+    String INIT_NAME = \"<init>\";\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/MethodRef.java","additions":180,"deletions":12,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.impl.MethodRefImpl;\n@@ -57,1 +59,1 @@\n-            case ConstructorRef constructorRef -> {\n+            case MethodRef constructorRef when constructorRef.isConstructor() -> {\n@@ -62,1 +64,1 @@\n-                Method method = methodRef.resolveToDirectMethod(lookup);\n+                Method method = methodRef.resolveToMethod(lookup);\n@@ -140,1 +142,1 @@\n-    public sealed interface Owner extends TypeElement permits ClassType, MethodRef, ConstructorRef { }\n+    public sealed interface Owner extends TypeElement permits ClassType, MethodRef { }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/TypeVariableType.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.code.dialect.java.impl;\n-\n-import jdk.incubator.code.TypeElement;\n-import jdk.incubator.code.dialect.java.ArrayType;\n-import jdk.incubator.code.dialect.java.ConstructorRef;\n-import jdk.incubator.code.dialect.core.FunctionType;\n-import jdk.incubator.code.dialect.java.JavaType;\n-import jdk.incubator.code.dialect.java.MethodRef;\n-import jdk.incubator.code.extern.ExternalizedTypeElement;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleInfo;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Constructor;\n-import java.util.Objects;\n-\n-import static java.util.stream.Collectors.joining;\n-\n-public final class ConstructorRefImpl implements ConstructorRef {\n-\n-    final FunctionType type;\n-\n-    static final MethodHandle MULTI_NEW_ARRAY_MH;\n-\n-    static {\n-        try {\n-            MULTI_NEW_ARRAY_MH = MethodHandles.lookup().findStatic(Array.class, \"newInstance\",\n-                    MethodType.methodType(Object.class, Class.class, int[].class));\n-        } catch (ReflectiveOperationException ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-\n-    public ConstructorRefImpl(FunctionType functionType) {\n-        this.type = functionType;\n-    }\n-\n-    @Override\n-    public FunctionType type() {\n-        return type;\n-    }\n-\n-    @Override\n-    public Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l));\n-        return methodHandleInfo.reflectAs(Constructor.class, l);\n-    }\n-\n-    @Override\n-    public MethodHandle resolveToHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        Class<?> refC = resolve(l, type.returnType());\n-        if (type.returnType() instanceof ArrayType at) {\n-            if (at.dimensions() == 1) {\n-                return MethodHandles.arrayConstructor(refC);\n-            } else {\n-                int dims = type.parameterTypes().size();\n-                Class<?> elementType = refC;\n-                for (int i = 0 ; i < type.parameterTypes().size(); i++) {\n-                    elementType = elementType.componentType();\n-                }\n-                \/\/ only the use-site knows how many dimensions are specified\n-                return MULTI_NEW_ARRAY_MH.asType(MULTI_NEW_ARRAY_MH.type().changeReturnType(refC))\n-                        .bindTo(elementType)\n-                        .asCollector(int[].class, dims);\n-            }\n-        } else {\n-            \/\/ MH lookup wants a void-returning lookup type\n-            MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l).changeReturnType(void.class);\n-            return l.findConstructor(refC, mt);\n-        }\n-    }\n-\n-    static Class<?> resolve(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (t instanceof JavaType jt) {\n-            return (Class<?>)jt.erasure().resolve(l);\n-        } else {\n-            \/\/ @@@\n-            throw new ReflectiveOperationException();\n-        }\n-    }\n-\n-    @Override\n-    public ExternalizedTypeElement externalize() {\n-        return JavaTypeUtils.constructorRef(type.returnType().externalize(),\n-                type.parameterTypes().stream().map(TypeElement::externalize).toList());\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return JavaTypeUtils.toExternalRefString(externalize());\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (!(o instanceof ConstructorRefImpl that)) return false;\n-        return Objects.equals(type, that.type);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hashCode(type);\n-    }\n-}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/ConstructorRefImpl.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import java.lang.invoke.MethodHandle;\n@@ -65,1 +67,1 @@\n-    public Field resolveToMember(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+    public Field resolveToField(MethodHandles.Lookup l) throws ReflectiveOperationException {\n@@ -69,3 +71,20 @@\n-        Field f = refC.getDeclaredField(name);\n-        if (!f.getType().equals(typeC)) {\n-            throw new NoSuchFieldException();\n+        MethodHandle getterHandle = null;\n+        ReflectiveOperationException c = null;\n+\n+        try {\n+            getterHandle = l.findStaticGetter(refC, name, typeC);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            c = e;\n+        }\n+\n+        if (c != null) {\n+            c = null;\n+            try {\n+                getterHandle = l.findGetter(refC, name, typeC);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                c = e;\n+            }\n+        }\n+\n+        if (c != null) {\n+            throw c;\n@@ -74,1 +93,3 @@\n-        return f;\n+        assert getterHandle != null;\n+        return l.revealDirect(getterHandle)\n+                .reflectAs(Field.class, l);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/FieldRefImpl.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-                yield ConstructorRef.constructor(owner, paramTypes);\n+                yield MethodRef.constructor(owner, paramTypes);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/JavaTypeUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.code.dialect.java.ArrayType;\n@@ -29,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n@@ -34,0 +36,2 @@\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n@@ -40,0 +44,1 @@\n+import java.util.Arrays;\n@@ -47,0 +52,11 @@\n+    static final MethodHandle MULTI_NEW_ARRAY_MH;\n+\n+    static {\n+        try {\n+            MULTI_NEW_ARRAY_MH = MethodHandles.lookup().findStatic(Array.class, \"newInstance\",\n+                    MethodType.methodType(Object.class, Class.class, int[].class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -72,2 +88,3 @@\n-    public Method resolveToDirectMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        return resolveToDirectHandle(l, hr -> hr.mhi().reflectAs(Method.class, l));\n+    @Override\n+    public boolean isConstructor() {\n+        return name.equals(INIT_NAME);\n@@ -76,3 +93,12 @@\n-    public MethodHandle resolveToDirectHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n-        return resolveToDirectHandle(l, HandleResult::mh);\n-    }\n+    @Override\n+    public Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        if (isConstructor()) {\n+            throw new UnsupportedOperationException(\"Not a method reference\");\n+        }\n+        ReflectiveOperationException c = null;\n+        MethodHandle mh = null;\n+        try {\n+            mh = resolveToHandle(l, InvokeKind.STATIC);\n+        } catch (ReflectiveOperationException ex) {\n+            c = ex;\n+        }\n@@ -80,4 +106,1 @@\n-    <T> T resolveToDirectHandle(MethodHandles.Lookup l, Function<HandleResult, T> f) throws ReflectiveOperationException {\n-        ReflectiveOperationException roe = null;\n-        for (JavaOp.InvokeOp.InvokeKind ik :\n-                List.of(JavaOp.InvokeOp.InvokeKind.STATIC, JavaOp.InvokeOp.InvokeKind.INSTANCE)) {\n+        if (mh == null) {\n@@ -85,6 +108,3 @@\n-                HandleResult hr = resolveToHandleResult(l, ik);\n-                if (hr.isDirect()) {\n-                    return f.apply(hr);\n-                }\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                roe = e;\n+                mh = resolveToHandle(l, InvokeKind.STATIC);\n+            } catch (ReflectiveOperationException ex) {\n+                c = ex;\n@@ -93,2 +113,3 @@\n-        if (roe == null) {\n-            roe = new ReflectiveOperationException(\"Indirect reference to method\");\n+\n+        if (c != null) {\n+            throw c;\n@@ -96,1 +117,4 @@\n-        throw roe;\n+\n+        assert mh != null;\n+        return l.revealDirect(mh)\n+                .reflectAs(Method.class, l);\n@@ -100,3 +124,6 @@\n-    public Method resolveToMethod(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n-        MethodHandleInfo methodHandleInfo = l.revealDirect(resolveToHandle(l, kind));\n-        return methodHandleInfo.reflectAs(Method.class, l);\n+    public Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        if (!isConstructor()) {\n+            throw new UnsupportedOperationException(\"Not a constructor reference\");\n+        }\n+        return l.revealDirect(resolveToHandle(l, InvokeKind.SUPER))\n+                .reflectAs(Constructor.class, l);\n@@ -107,12 +134,13 @@\n-        Class<?> refC = resolve(l, refType);\n-        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n-        return switch (kind) {\n-            case SUPER -> l.findSpecial(refC, name, mt, l.lookupClass());\n-            case STATIC -> l.findStatic(refC, name, mt);\n-            case INSTANCE -> l.findVirtual(refC, name, mt);\n-        };\n-    }\n-\n-    record HandleResult (Class<?> refC, MethodHandle mh, MethodHandleInfo mhi) {\n-        boolean isDirect() {\n-            return refC == mhi.getDeclaringClass();\n+        if (!isConstructor()) {\n+            Class<?> refC = resolve(l, refType);\n+            MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n+            return switch (kind) {\n+                case SUPER -> l.findSpecial(refC, name, mt, l.lookupClass());\n+                case STATIC -> l.findStatic(refC, name, mt);\n+                case INSTANCE -> l.findVirtual(refC, name, mt);\n+            };\n+        } else {\n+            if (kind != JavaOp.InvokeOp.InvokeKind.SUPER) {\n+                throw new IllegalArgumentException(\"Bad invoke kind for constructor: \" + kind);\n+            }\n+            return resolveToConstructorHandle(l);\n@@ -122,10 +150,21 @@\n-    HandleResult resolveToHandleResult(MethodHandles.Lookup l, JavaOp.InvokeOp.InvokeKind kind) throws ReflectiveOperationException {\n-        Class<?> refC = resolve(l, refType);\n-        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n-        MethodHandle mh = switch (kind) {\n-            case SUPER -> l.findSpecial(refC, name, mt, l.lookupClass());\n-            case STATIC -> l.findStatic(refC, name, mt);\n-            case INSTANCE -> l.findVirtual(refC, name, mt);\n-        };\n-        MethodHandleInfo mhi = l.revealDirect(resolveToHandle(l, kind));\n-        return new HandleResult(refC, mh, mhi);\n+    private MethodHandle resolveToConstructorHandle(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+        Class<?> refC = resolve(l, type.returnType());\n+        if (type.returnType() instanceof ArrayType at) {\n+            if (at.dimensions() == 1) {\n+                return MethodHandles.arrayConstructor(refC);\n+            } else {\n+                int dims = type.parameterTypes().size();\n+                Class<?> elementType = refC;\n+                for (int i = 0 ; i < type.parameterTypes().size(); i++) {\n+                    elementType = elementType.componentType();\n+                }\n+                \/\/ only the use-site knows how many dimensions are specified\n+                return MULTI_NEW_ARRAY_MH.asType(MULTI_NEW_ARRAY_MH.type().changeReturnType(refC))\n+                        .bindTo(elementType)\n+                        .asCollector(int[].class, dims);\n+            }\n+        } else {\n+            \/\/ MH lookup wants a void-returning lookup type\n+            MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l).changeReturnType(void.class);\n+            return l.findConstructor(refC, mt);\n+        }\n@@ -145,3 +184,8 @@\n-        return JavaTypeUtils.methodRef(name, refType.externalize(),\n-                type.returnType().externalize(),\n-                type.parameterTypes().stream().map(TypeElement::externalize).toList());\n+        if (!isConstructor()) {\n+            return JavaTypeUtils.methodRef(name, refType.externalize(),\n+                    type.returnType().externalize(),\n+                    type.parameterTypes().stream().map(TypeElement::externalize).toList());\n+        } else {\n+            return JavaTypeUtils.constructorRef(type.returnType().externalize(),\n+                    type.parameterTypes().stream().map(TypeElement::externalize).toList());\n+        }\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/MethodRefImpl.java","additions":90,"deletions":46,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-        return builder.op(new_(ConstructorRef.constructor(EXTERNALIZED_OP_F_TYPE), args));\n+        return builder.op(new_(MethodRef.constructor(EXTERNALIZED_OP_F_TYPE), args));\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/OpBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1392,1 +1392,1 @@\n-            ConstructorRef constructorRef = ConstructorRef.constructor(constructorType);\n+            MethodRef constructorRef = MethodRef.constructor(constructorType);\n@@ -1424,1 +1424,1 @@\n-                ConstructorRef constructorRef = ConstructorRef.constructor(arrayType,\n+                MethodRef constructorRef = MethodRef.constructor(arrayType,\n@@ -1621,1 +1621,1 @@\n-                        append(JavaOp.new_(ConstructorRef.constructor(MatchException.class)))\n+                        append(JavaOp.new_(MethodRef.constructor(MatchException.class)))\n@@ -2983,1 +2983,1 @@\n-    MethodSymbol constructorDescriptorToSymbol(ConstructorRef constructorRef) {\n+    MethodSymbol constructorDescriptorToSymbol(MethodRef constructorRef) {\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/internal\/ReflectMethods.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -691,1 +691,1 @@\n-    static MethodHandle resolveToConstructorHandle(MethodHandles.Lookup l, ConstructorRef d) {\n+    static MethodHandle resolveToConstructorHandle(MethodHandles.Lookup l, MethodRef d) {\n@@ -693,1 +693,1 @@\n-            return d.resolveToHandle(l);\n+            return d.resolveToHandle(l, JavaOp.InvokeOp.InvokeKind.SUPER);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/interpreter\/Interpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                        em = r.resolveToMethod(l, iop.invokeKind());\n+                        em = r.resolveToMethod(l);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -435,1 +435,1 @@\n-                                        ConstructorRef.constructor(\n+                                        MethodRef.constructor(\n@@ -599,1 +599,1 @@\n-                            ConstructorRef.constructor(\n+                            MethodRef.constructor(\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/lift\/BytecodeLift.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-        ConstructorRef cr = refFromFlatString(cds);\n+        MethodRef cr = refFromFlatString(cds);\n@@ -118,1 +118,1 @@\n-        ConstructorRef cr = (ConstructorRef) JavaTypeUtils.toJavaRef(JavaTypeUtils.inflate(ecr));\n+        MethodRef cr = (MethodRef) JavaTypeUtils.toJavaRef(JavaTypeUtils.inflate(ecr));\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/type\/TestReferences.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}