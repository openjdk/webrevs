{"files":[{"patch":"@@ -117,1 +117,1 @@\n-                Field initializerField = i.resolveToDeclaredField(lookup);\n+                Field initializerField = i.resolveToField(lookup);\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/OnnxRuntime.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-            var res = Op.ofMethod(io.invokeDescriptor().resolveToDeclaredMethod(l));\n+            var res = Op.ofMethod(io.invokeDescriptor().resolveToMethod(l));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                        f = flop.fieldDescriptor().resolveToDeclaredField(MethodHandles.lookup());\n+                        f = flop.fieldDescriptor().resolveToField(MethodHandles.lookup());\n","filename":"cr-examples\/triton\/src\/main\/java\/oracle\/code\/triton\/TritonTransformer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                        invokeOpCalledMethod = methodRef.resolveToDeclaredMethod(l, iop.invokeKind());\n+                        invokeOpCalledMethod = methodRef.resolveToMethod(l);\n","filename":"hat\/core\/src\/main\/java\/hat\/BufferTagger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-                    var method = invokeOp.invokeDescriptor().resolveToDeclaredMethod(lookup, invokeOp.invokeKind());\n+                    var method = invokeOp.invokeDescriptor().resolveToMethod(lookup);\n@@ -132,1 +132,1 @@\n-                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToDeclaredMethod(lookup, iop.invokeKind());\n+                            Method invokeOpCalledMethod = iop.invokeDescriptor().resolveToMethod(lookup);\n@@ -266,1 +266,1 @@\n-            return op.invokeDescriptor().resolveToDeclaredMethod(lookup, op.invokeKind());\n+            return op.invokeDescriptor().resolveToMethod(lookup);\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * Field references can be <em>resolved<\/em> to their corresponding {@linkplain #resolveToDeclaredField(Lookup) target field}.\n+ * Field references can be <em>resolved<\/em> to their corresponding {@linkplain #resolveToField(Lookup) target field}.\n@@ -69,4 +69,2 @@\n-     * Resolves the target field associated with this field reference. Resolution looks for a field with the given\n-     * {@linkplain #name() name} and {@linkplain #type() type} declared in the given {@linkplain #refType() owner type}.\n-     * If no such field can be found, {@link NoSuchFieldException} is thrown.\n-     * @return the method associated with this field reference\n+     * Resolves the target field associated with this field reference.\n+     * @return the field associated with this field reference\n@@ -75,0 +73,2 @@\n+     * @throws UnsupportedOperationException if this reference is not a constructor reference\n+     * @throws IllegalArgumentException if the provided {@code kind} is unsupported for this method reference\n@@ -76,1 +76,1 @@\n-    Field resolveToDeclaredField(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    Field resolveToField(MethodHandles.Lookup l) throws ReflectiveOperationException;\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/FieldRef.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n- * Method references can be <em>resolved<\/em> to their corresponding {@linkplain #resolveToDeclaredMethod(Lookup) target method} or\n- * {@linkplain #resolveToDeclaredMethod(Lookup) target constructor}. Or they can be turned into a\n+ * Method references can be <em>resolved<\/em> to their corresponding {@linkplain #resolveToMethod(Lookup) target method} or\n+ * {@linkplain #resolveToMethod(Lookup) target constructor}. Or they can be turned into a\n@@ -89,3 +89,1 @@\n-     * Resolves the target method associated with this method reference. Resolution looks for a method with the given\n-     * {@linkplain #name() name} and {@linkplain #type() type} declared in the given {@linkplain #refType() owner type}.\n-     * If no such method can be found, {@link NoSuchMethodException} is thrown.\n+     * Resolves the target method associated with this method reference.\n@@ -97,1 +95,1 @@\n-    Method resolveToDeclaredMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -100,3 +98,1 @@\n-     * Resolves the target constructor associated with this constructor reference. Resolution looks for a constructor with the given\n-     * {@linkplain #type() type} declared in the given {@linkplain #refType() owner type}.\n-     * If no such constructor can be found, {@link NoSuchMethodException} is thrown.\n+     * Resolves the target method associated with this method reference.\n@@ -104,1 +100,1 @@\n-     * @param l the lookup used for resolving this constructor reference\n+     * @param l the lookup used for resolving this method reference\n@@ -107,0 +103,1 @@\n+     * @throws IllegalArgumentException if the provided {@code kind} is unsupported for this method reference\n@@ -108,1 +105,1 @@\n-    Constructor<?> resolveToDeclaredConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException;\n+    Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException;\n@@ -122,0 +119,1 @@\n+     * @param kind the invocation kind to be used for resolving this method reference\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/MethodRef.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.code.dialect.java.impl.MethodRefImpl;\n@@ -58,1 +60,1 @@\n-                Constructor<?> constructor = constructorRef.resolveToDeclaredConstructor(lookup);\n+                Constructor<?> constructor = constructorRef.resolveToConstructor(lookup);\n@@ -62,1 +64,1 @@\n-                Method method = methodRef.resolveToDeclaredMethod(lookup);\n+                Method method = methodRef.resolveToMethod(lookup);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/TypeVariableType.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import java.lang.invoke.MethodHandle;\n@@ -65,1 +67,1 @@\n-    public Field resolveToDeclaredField(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+    public Field resolveToField(MethodHandles.Lookup l) throws ReflectiveOperationException {\n@@ -69,3 +71,20 @@\n-        Field f = refC.getDeclaredField(name);\n-        if (!f.getType().equals(typeC)) {\n-            throw new NoSuchFieldException();\n+        MethodHandle getterHandle = null;\n+        ReflectiveOperationException c = null;\n+\n+        try {\n+            getterHandle = l.findStaticGetter(refC, name, typeC);\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            c = e;\n+        }\n+\n+        if (c != null) {\n+            c = null;\n+            try {\n+                getterHandle = l.findGetter(refC, name, typeC);\n+            } catch (NoSuchFieldException | IllegalAccessException e) {\n+                c = e;\n+            }\n+        }\n+\n+        if (c != null) {\n+            throw c;\n@@ -74,1 +93,3 @@\n-        return f;\n+        assert getterHandle != null;\n+        return l.revealDirect(getterHandle)\n+                .reflectAs(Field.class, l);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/FieldRefImpl.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.code.dialect.java.JavaOp.InvokeOp.InvokeKind;\n@@ -93,1 +94,1 @@\n-    public Method resolveToDeclaredMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+    public Method resolveToMethod(MethodHandles.Lookup l) throws ReflectiveOperationException {\n@@ -97,7 +98,13 @@\n-        Class<?> refC = resolve(l, refType);\n-        MethodType mt = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n-        for (Method m : refC.getDeclaredMethods()) {\n-            if (m.getName().equals(name) &&\n-                    Arrays.equals(m.getParameterTypes(), mt.parameterArray()) &&\n-                    m.getReturnType().equals(mt.returnType())) {\n-                return m;\n+        ReflectiveOperationException c = null;\n+        MethodHandle mh = null;\n+        try {\n+            mh = resolveToHandle(l, InvokeKind.STATIC);\n+        } catch (ReflectiveOperationException ex) {\n+            c = ex;\n+        }\n+\n+        if (mh == null) {\n+            try {\n+                mh = resolveToHandle(l, InvokeKind.STATIC);\n+            } catch (ReflectiveOperationException ex) {\n+                c = ex;\n@@ -106,1 +113,8 @@\n-        throw new NoSuchMethodException(toString());\n+\n+        if (c != null) {\n+            throw c;\n+        }\n+\n+        assert mh != null;\n+        return l.revealDirect(mh)\n+                .reflectAs(Method.class, l);\n@@ -110,1 +124,1 @@\n-    public Constructor<?> resolveToDeclaredConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException {\n+    public Constructor<?> resolveToConstructor(MethodHandles.Lookup l) throws ReflectiveOperationException {\n@@ -114,9 +128,2 @@\n-        Class<?> refC = resolve(l, refType);\n-        MethodType ct = MethodRef.toNominalDescriptor(type).resolveConstantDesc(l);\n-        for (Constructor<?> c : refC.getDeclaredConstructors()) {\n-            if (c.getName().equals(name) &&\n-                    Arrays.equals(c.getParameterTypes(), ct.parameterArray())) {\n-                return c;\n-            }\n-        }\n-        throw new NoSuchMethodException(toString());\n+        return l.revealDirect(resolveToHandle(l, InvokeKind.SUPER))\n+                .reflectAs(Constructor.class, l);\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/dialect\/java\/impl\/MethodRefImpl.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                        em = r.resolveToDeclaredMethod(l);\n+                        em = r.resolveToMethod(l);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestTransitiveInvokeModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}