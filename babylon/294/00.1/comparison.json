{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=babylon\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-warning=issuestitle,binary\n+error=author,committer,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -12,1 +11,1 @@\n-branches=.*\n+branches=\n","filename":".jcheck\/conf","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,4 @@\n-\n+    final MethodHandle quotableOpField;       \/\/ A getter method handle that is used to retrieve the\n+                                              \/\/ string representation of the quotable lambda's associated\n+                                              \/\/ intermediate representation (can be null).\n+    final MethodHandleInfo quotableOpFieldInfo;  \/\/ Info about the quotable getter method handle (can be null).\n@@ -108,0 +111,3 @@\n+     * @param reflectiveField a {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter}\n+     *                   method handle that is used to retrieve the string representation of the\n+     *                   quotable lambda's associated intermediate representation.\n@@ -119,1 +125,2 @@\n-                                        MethodType[] altMethods)\n+                                        MethodType[] altMethods,\n+                                        MethodHandle reflectiveField)\n@@ -180,0 +187,1 @@\n+        this.quotableOpField = reflectiveField;\n@@ -206,0 +214,14 @@\n+\n+        if (reflectiveField != null) {\n+            try {\n+                quotableOpFieldInfo = caller.revealDirect(reflectiveField); \/\/ may throw SecurityException\n+            } catch (IllegalArgumentException e) {\n+                throw new LambdaConversionException(implementation + \" is not direct or cannot be cracked\");\n+            }\n+            if (quotableOpFieldInfo.getReferenceKind() != REF_getField &&\n+                    quotableOpFieldInfo.getReferenceKind() != REF_getStatic) {\n+                throw new LambdaConversionException(String.format(\"Unsupported MethodHandle kind: %s\", quotableOpFieldInfo));\n+            }\n+        } else {\n+            quotableOpFieldInfo = null;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -41,0 +43,3 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n@@ -45,0 +50,2 @@\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n@@ -72,0 +79,8 @@\n+    \/\/ Static builders to avoid lambdas\n+    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n+        @Override\n+        public void accept(MethodBuilder mb) {\n+            mb.withCode(code);\n+        }\n+    };\n+\n@@ -77,0 +92,3 @@\n+    private static final String NAME_METHOD_QUOTED = \"quoted\";\n+    private static final String quotedInstanceFieldName = \"quoted\";\n+\n@@ -145,1 +163,2 @@\n-                                       MethodType[] altMethods)\n+                                       MethodType[] altMethods,\n+                                       MethodHandle reflectiveField)\n@@ -149,1 +168,1 @@\n-              isSerializable, altInterfaces, altMethods);\n+              isSerializable, altInterfaces, altMethods, reflectiveField);\n@@ -320,0 +339,5 @@\n+                \/\/ if quotable, generate the field that will hold the value of quoted\n+                if (quotableOpField != null) {\n+                    clb.withField(quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted, ACC_PRIVATE + ACC_FINAL);\n+                }\n+\n@@ -346,0 +370,4 @@\n+\n+                if (quotableOpField != null) {\n+                    generateQuotableMethod(clb);\n+                }\n@@ -353,1 +381,8 @@\n-            var classdata = useImplMethodHandle? implementation : null;\n+            List<?> classdata;\n+            if (useImplMethodHandle || quotableOpField != null) {\n+                classdata = quotableOpField == null ?\n+                        List.of(implementation) :\n+                        List.of(implementation, quotableOpField, CodeReflectionSupport.HANDLE_MAKE_QUOTED);\n+            } else {\n+                classdata = null;\n+            }\n@@ -402,0 +437,3 @@\n+                        if (quotableOpField != null) {\n+                            generateQuotedFieldInitializer(cob);\n+                        }\n@@ -407,0 +445,79 @@\n+    private void generateQuotedFieldInitializer(CodeBuilder cob) {\n+        ConstantPoolBuilder cp = cob.constantPool();\n+        MethodHandleEntry bsmDataAt = cp.methodHandleEntry(BSM_CLASS_DATA_AT);\n+        NameAndTypeEntry natMH = cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle);\n+        \/\/ push the receiver on the stack for operand of put field instruction\n+        cob.aload(0)\n+           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(2))), natMH))\n+        \/\/ load op string from field\n+           .ldc(cp.constantDynamicEntry(cp.bsmEntry(bsmDataAt, List.of(cp.intEntry(1))), natMH));\n+        MethodType mtype = quotableOpFieldInfo.getMethodType();\n+        if (quotableOpFieldInfo.getReferenceKind() != MethodHandleInfo.REF_getStatic) {\n+            mtype = mtype.insertParameterTypes(0, implClass);\n+        }\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", mtype.describeConstable().get());\n+\n+        \/\/ load captured args in array\n+\n+        int capturedArity = factoryType.parameterCount();\n+        cob.loadConstant(capturedArity)\n+           .anewarray(CD_Object);\n+        \/\/ initialize quoted captures\n+        for (int i = 0; i < capturedArity; i++) {\n+            cob.dup()\n+               .loadConstant(i)\n+               .aload(0)\n+               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n+            TypeConvertingMethodAdapter.boxIfTypePrimitive(cob, TypeKind.from(argDescs[i]));\n+            cob.aastore();\n+        }\n+\n+        \/\/ now create a Quoted from String and captured args Object[]\n+\n+        cob.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(CodeReflectionSupport.HANDLE_MAKE_QUOTED.type()))\n+           .putfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted);\n+    }\n+\n+    static class CodeReflectionSupport {\n+        static final Class<?> QUOTED_CLASS;\n+        static final Class<?> QUOTABLE_CLASS;\n+        static final MethodHandle HANDLE_MAKE_QUOTED;\n+\n+        static {\n+            try {\n+                ModuleLayer layer = codeLayer();\n+                QUOTED_CLASS = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.Quoted\");\n+                QUOTABLE_CLASS = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.Quotable\");\n+                Class<?> quotedHelper = layer.findLoader(\"jdk.incubator.code\")\n+                        .loadClass(\"jdk.incubator.code.internal.QuotedHelper\");\n+                MethodHandle makeQuoted = Lookup.IMPL_LOOKUP.findStatic(quotedHelper, \"makeQuoted\",\n+                        MethodType.methodType(QUOTED_CLASS, MethodHandles.Lookup.class, String.class, Object[].class));\n+                HANDLE_MAKE_QUOTED = makeQuoted.bindTo(Lookup.IMPL_LOOKUP);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+\n+        static ModuleLayer codeLayer() {\n+            final ModuleLayer codeLayer;\n+            if (ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ we are in an exploded build, so just use the boot layer\n+                return ModuleLayer.boot();\n+            } else if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ the code module is installed, but not in the boot layer, create a new layer which contains it\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(ModuleFinder.of(), ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                return parent.defineModulesWithOneLoader(cf, scl);\n+            } else {\n+                throw new IllegalStateException(\"jdk.incubator.code module not found\");\n+            }\n+        }\n+\n+        static final ClassDesc CD_Quoted = QUOTED_CLASS.describeConstable().get();\n+        static final MethodTypeDesc MTD_Quoted = MethodTypeDescImpl.ofValidated(CD_Quoted);\n+    }\n+\n@@ -463,0 +580,14 @@\n+    \/**\n+     * Generate a writeReplace method that supports serialization\n+     *\/\n+    private void generateQuotableMethod(ClassBuilder clb) {\n+        clb.withMethod(NAME_METHOD_QUOTED, CodeReflectionSupport.MTD_Quoted, ACC_PUBLIC + ACC_FINAL, new MethodBody(new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cob) {\n+                cob.aload(0)\n+                   .getfield(lambdaClassEntry.asSymbol(), quotedInstanceFieldName, CodeReflectionSupport.CD_Quoted)\n+                   .areturn();\n+            }\n+        }));\n+    }\n+\n@@ -506,1 +637,1 @@\n-                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n+                    cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA_AT), List.of(cp.intEntry(0))),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":135,"deletions":4,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -270,0 +270,4 @@\n+    \/** Flag for {@link #altMetafactory} indicating the lambda object\n+     * must be a {@code Quotable} object, inspectable using code reflection. *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -352,1 +356,2 @@\n-                                             EMPTY_MT_ARRAY);\n+                                             EMPTY_MT_ARRAY,\n+                                 null);\n@@ -398,0 +403,1 @@\n+     *                          MethodHandle quotableField    \/\/ IF flags has QUOTABLE set\n@@ -421,0 +427,4 @@\n+     *     <li>{@code quotableField} is a\n+     *     {@linkplain MethodHandles.Lookup#findGetter(Class, String, Class) getter} method handle\n+     *     that is used to retrieve the string representation of the quotable lambda's associated\n+     *     intermediate representation.<\/li>\n@@ -435,0 +445,3 @@\n+     * <p>When FLAG_QUOTABLE is set in {@code flags}, the function objects\n+     * will implement {@code Quotable}.\n+     *\n@@ -500,0 +513,1 @@\n+        MethodHandle quotableField = null;\n@@ -520,0 +534,5 @@\n+        if ((flags & FLAG_QUOTABLE) != 0) {\n+            quotableField = extractArg(args, argIndex++, MethodHandle.class);\n+            altInterfaces = Arrays.copyOf(altInterfaces, altInterfaces.length + 1);\n+            altInterfaces[altInterfaces.length-1] = InnerClassLambdaMetafactory.CodeReflectionSupport.QUOTABLE_CLASS;\n+        }\n@@ -544,1 +563,2 @@\n-                                                  altMethods);\n+                                                  altMethods,\n+                                                  quotableField);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Optional;\n@@ -50,0 +51,1 @@\n+import java.util.function.Function;\n@@ -99,0 +101,4 @@\n+    \/\/ Cache of code model, if present\n+    \/\/ @@@ May require caching based on symbolic name and class loader\n+    private volatile Optional<?>     codeModel;\n+\n@@ -227,0 +233,15 @@\n+    \/* package *\/\n+    Optional<?> setCodeModelIfNeeded(Function<Method, Optional<?>> modelFactory) {\n+        Optional<?> localRef = codeModel;\n+        if (localRef == null) {\n+            synchronized (this) {\n+                localRef = codeModel;\n+                if (localRef == null) {\n+                    Optional<?> op = modelFactory.apply(this);\n+                    codeModel = localRef = op;\n+                }\n+            }\n+        }\n+        return localRef;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -165,1 +165,4 @@\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.jshell, \/\/ participates in preview features\n+        jdk.incubator.code; \/\/ participates in preview features\n+    exports jdk.internal.classfile.impl to\n+        jdk.incubator.code;\n@@ -178,1 +181,2 @@\n-        jdk.crypto.cryptoki;\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.code;\n@@ -315,1 +319,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.code;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+        REFLECT_METHODS(JDK22, Fragments.FeatureReflectMethods, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.Type.ArrayType;\n@@ -329,0 +330,12 @@\n+    \/** Enter a class into symbol table.\n+     *  @param s The name of the class.\n+     *\/\n+    public Type enterClass(ModuleSymbol moduleSymbol, String s) {\n+        try {\n+            return enterClass(moduleSymbol, names.fromString(s)).type;\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            return Type.noType;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,10 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : UPWARDS_NO_INTERSECTION;\n+            }\n@@ -212,0 +222,42 @@\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return true;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? this : DOWNWARDS_NO_INTERSECTION;\n+            }\n+        },\n+        UPWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return DOWNWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? UPWARDS : this;\n+            }\n+        },\n+        DOWNWARDS_NO_INTERSECTION() {\n+            @Override\n+            ProjectionKind complement() {\n+                return UPWARDS_NO_INTERSECTION;\n+            }\n+\n+            @Override\n+            boolean allowIntersectionTypes() {\n+                return false;\n+            }\n+\n+            @Override\n+            ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes) {\n+                return allowIntersectionTypes ? DOWNWARDS : this;\n+            }\n@@ -215,0 +267,2 @@\n+        abstract boolean allowIntersectionTypes();\n+        abstract ProjectionKind withIntersectionTypes(boolean allowIntersectionTypes);\n@@ -253,5 +307,12 @@\n-            if (t.isCompound()) {\n-                List<Type> components = directSupertypes(t);\n-                List<Type> components1 = components.map(c -> c.map(this, pkind));\n-                if (components == components1) return t;\n-                else return makeIntersectionType(components1);\n+            if (t.isUnion() || t.isIntersection()) {\n+                if (pkind.allowIntersectionTypes()) {\n+                    List<Type> components = directSupertypes(t);\n+                    List<Type> components1 = components.map(c -> c.map(this, pkind));\n+                    if (components == components1) return t;\n+                    else return makeIntersectionType(components1);\n+                } else if (t.isIntersection()) {\n+                    return visit(((IntersectionClassType)t).getExplicitComponents().head, pkind);\n+                } else {\n+                    Assert.check(t.isUnion());\n+                    return visit(((UnionClassType)t).getLub(), pkind);\n+                }\n@@ -312,0 +373,1 @@\n+                            case UPWARDS_NO_INTERSECTION:\n@@ -315,0 +377,1 @@\n+                            case DOWNWARDS_NO_INTERSECTION:\n@@ -329,1 +392,1 @@\n-                    return pkind == ProjectionKind.UPWARDS ?\n+                    return (pkind == ProjectionKind.UPWARDS || pkind == ProjectionKind.UPWARDS_NO_INTERSECTION) ?\n@@ -338,1 +401,1 @@\n-            return t.containsAny(vars) ?\n+            return (t.containsAny(vars) || (!pkind.allowIntersectionTypes() && !chk.checkDenotable(t))) ?\n@@ -356,1 +419,1 @@\n-                if (pkind == ProjectionKind.DOWNWARDS) {\n+                if (pkind == ProjectionKind.DOWNWARDS || pkind == ProjectionKind.DOWNWARDS_NO_INTERSECTION) {\n@@ -360,1 +423,1 @@\n-                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);\n+                Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS.withIntersectionTypes(pkind.allowIntersectionTypes()));\n@@ -370,1 +433,1 @@\n-                } else if (!lower.hasTag(BOT)) {\n+                } else if (!lower.hasTag(BOT) && (!lower.isIntersection() || pkind.allowIntersectionTypes())) {\n@@ -393,2 +456,2 @@\n-                        bound = wt.type.map(TypeProjection.this, pkind.complement());\n-                        if (bound.hasTag(BOT)) {\n+                        bound = wt.type.map(TypeProjection.this, pkind.withIntersectionTypes(true).complement());\n+                        if (bound.hasTag(BOT) || (bound.isIntersection() && !pkind.allowIntersectionTypes())) {\n@@ -422,1 +485,14 @@\n-        return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);\n+        return upward(t, true, vars);\n+    }\n+\n+    \/**\n+     * Computes an upward projection of given type, and vars. See {@link TypeProjection}.\n+     *\n+     * @param t the type to be projected\n+     * @param allowIntersection whether intersection types should be allowed in the projection\n+     * @param vars the set of type variables to be mapped\n+     * @return the type obtained as result of the projection\n+     *\/\n+    public Type upward(Type t, boolean allowIntersection, List<Type> vars) {\n+        return t.map(new TypeProjection(vars),\n+                allowIntersection ? ProjectionKind.UPWARDS : ProjectionKind.UPWARDS_NO_INTERSECTION);\n@@ -5341,0 +5417,24 @@\n+\n+    \/\/ code reflection\n+\n+    \/\/ The predicates below do not use a predefined symbol in Symtab.\n+    \/\/ This is deliberate, as we cannot initialize symbols in modules\n+    \/\/ other than java.base at startup.\n+\n+    public boolean isQuoted(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quoted) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n+\n+    public boolean isQuotable(Type type) {\n+        Symbol s = type.tsym;\n+        return s != null &&\n+                s.kind == TYP &&\n+                s.name.equals(names.quotable) &&\n+                s.packge().fullname.equals(names.jdk_incubator_code) &&\n+                s.packge().modle.name.equals(names.jdk_incubator_code);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":114,"deletions":14,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import com.sun.source.tree.LambdaExpressionTree.BodyKind;\n@@ -50,0 +52,1 @@\n+import com.sun.tools.javac.comp.Attr.ResultInfo;\n@@ -51,0 +54,1 @@\n+import com.sun.tools.javac.comp.Check.NestedCheckContext;\n@@ -52,0 +56,1 @@\n+import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;\n@@ -64,0 +69,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;\n@@ -446,0 +452,13 @@\n+    public <R> R runWithAttributedMethod(Env<AttrContext> env, JCMethodDecl tree, Function<JCBlock, R> attributedAction) {\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+        try {\n+            JCBlock dupTree = (JCBlock)deferredAttr.attribSpeculative(tree.body, env, statInfo,\n+                    null, DeferredAttr.AttributionMode.ATTRIB_TO_TREE,\n+                    argumentAttr.withLocalCacheContext());\n+            return attributedAction.apply(dupTree);\n+        } finally {\n+            attrRecover.doRecovery();\n+            log.useSource(prevSource);\n+        }\n+    }\n+\n@@ -3154,0 +3173,8 @@\n+        if (types.isQuoted(pt())) {\n+            attribQuotedLambda(that);\n+        } else {\n+            attribFunctionalLambda(that, wrongContext);\n+        }\n+    }\n+\n+    void attribFunctionalLambda(JCLambda that, boolean wrongContext) {\n@@ -3297,0 +3324,93 @@\n+\n+    void attribQuotedLambda(JCLambda that) {\n+        \/\/ create an environment for attribution of the lambda expression\n+        final Env<AttrContext> localEnv = lambdaEnv(that, env);\n+        try {\n+            \/\/ if quoted lambda is implicit, issue error, and recover\n+            if (that.paramKind == ParameterKind.IMPLICIT) {\n+                log.error(that, Errors.QuotedLambdaMustBeExplicit);\n+                \/\/ recovery\n+                List<JCVariableDecl> params = that.params;\n+                while (params.nonEmpty()) {\n+                    Type argType = syms.errType;\n+                    if (params.head.isImplicitlyTyped()) {\n+                        setSyntheticVariableType(params.head, argType);\n+                    }\n+                    params = params.tail;\n+                }\n+            }\n+            \/\/ attribute lambda parameters\n+            attribStats(that.params, localEnv);\n+            List<Type> explicitParamTypes = TreeInfo.types(that.params);\n+\n+            ListBuffer<Type> restypes = new ListBuffer<>();\n+            ListBuffer<DiagnosticPosition> resPositions = new ListBuffer<>();\n+            ResultInfo bodyResultInfo = localEnv.info.returnResult = unknownExprInfo;\n+\n+            \/\/ type-check lambda body, and capture return types\n+            if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {\n+                attribTree(that.getBody(), localEnv, bodyResultInfo);\n+                restypes.add(that.getBody().type);\n+            } else {\n+                JCBlock body = (JCBlock)that.body;\n+                if (body == breakTree &&\n+                        resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {\n+                    breakTreeFound(copyEnv(localEnv));\n+                }\n+                attribStats(body.stats, localEnv);\n+                new LambdaReturnScanner() {\n+                    @Override\n+                    public void visitReturn(JCReturn tree) {\n+                        if (tree.expr != null) {\n+                            resPositions.add(tree);\n+                        }\n+                        restypes.add(tree.expr == null ? syms.voidType : tree.expr.type);\n+                    }\n+                }.scan(body);\n+            }\n+\n+            \/\/ check if lambda body can complete normally\n+            preFlow(that);\n+            flow.analyzeLambda(localEnv, that, make, false);\n+\n+            final Type restype;\n+            if (that.getBodyKind() == BodyKind.STATEMENT) {\n+                if (that.canCompleteNormally) {\n+                    \/\/ a lambda that completes normally has an implicit void return\n+                    restypes.add(syms.voidType);\n+                }\n+\n+                boolean hasNonVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t != syms.voidType);\n+                boolean hasVoidReturn = restypes.toList()\n+                        .stream().anyMatch(t -> t == syms.voidType);\n+\n+                if (hasVoidReturn && hasNonVoidReturn) {\n+                    \/\/ void vs. non-void mismatch\n+                    log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+                    restype = syms.errorType;\n+                } else if (hasVoidReturn) {\n+                    restype = syms.voidType;\n+                } else {\n+                    restype = condType(resPositions.toList(), restypes.toList());\n+                }\n+            } else {\n+                restype = restypes.first();\n+            }\n+\n+            \/\/ infer lambda return type using lub\n+            if (restype.hasTag(ERROR)) {\n+                \/\/ some other error occurred\n+                log.error(that.body, Errors.CantInferQuotedLambdaReturnType(restypes.toList()));\n+            }\n+\n+            \/\/ infer thrown types\n+            List<Type> thrownTypes = flow.analyzeLambdaThrownTypes(localEnv, that, make);\n+\n+            \/\/ set up target descriptor with explicit parameter types, and inferred thrown\/return types\n+            that.target = new MethodType(explicitParamTypes, restype, thrownTypes, syms.methodClass);\n+            result = that.type = pt();\n+        } finally {\n+            localEnv.info.scope.leave();\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    \/** Flag for alternate metafactories indicating the lambda object is intended to be quotable *\/\n+    public static final int FLAG_QUOTABLE = 1 << 3;\n+\n@@ -831,0 +834,1 @@\n+        boolean isQuotable = isQuotable(tree);\n@@ -832,1 +836,1 @@\n-                isSerializable || bridges.length() > 1;\n+                isSerializable || isQuotable || bridges.length() > 1;\n@@ -847,0 +851,1 @@\n+                        !types.isQuotable(t) &&\n@@ -853,0 +858,1 @@\n+            flags |= isQuotable ? FLAG_QUOTABLE : 0;\n@@ -875,0 +881,4 @@\n+            if (isQuotable) {\n+                VarSymbol reflectField = (VarSymbol)tree.codeModel;\n+                staticArgs = staticArgs.append(reflectField.asMethodHandle(true));\n+            }\n@@ -941,0 +951,4 @@\n+    boolean isQuotable(JCFunctionalExpression tree) {\n+        return tree.codeModel != null;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-                void skip(JCTree tree) {\n+                protected void skip(JCTree tree) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+                slam.codeModel = tree.codeModel;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.module.Configuration;\n@@ -40,0 +41,1 @@\n+import java.util.Optional;\n@@ -42,0 +44,1 @@\n+import java.util.ServiceLoader;\n@@ -88,2 +91,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -382,0 +383,2 @@\n+    private boolean hasCodeReflectionModule;\n+\n@@ -1058,0 +1061,9 @@\n+\n+        if (modules.modulesInitialized()) {\n+            \/\/ This has to happen precisely here. At this point, we have all we need to\n+            \/\/ determine whether jdk.incubator.module is part of the module graph\n+            \/\/ but we have yet to trigger an ENTER event. This gives the code reflection plugin\n+            \/\/ a window to check whether code reflection should be enabled for this compilation unit.\n+            hasCodeReflectionModule = modules.getObservableModule(names.jdk_incubator_code) != null;\n+        }\n+\n@@ -1617,0 +1629,7 @@\n+            if (Feature.REFLECT_METHODS.allowedInSource(source)) {\n+                Optional<CodeReflectionTransformer> reflectMethods = reflectMethods();\n+                if (reflectMethods.isPresent()) {\n+                    env.tree = reflectMethods.get().translateTopLevelClass(context, env.tree, localMake);\n+                }\n+            }\n+\n@@ -1624,1 +1643,2 @@\n-                env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+                env.tree = TransPatterns.instance(context)\n+                        .translateTopLevelClass(env, env.tree, localMake);\n@@ -1672,0 +1692,33 @@\n+    Optional<CodeReflectionTransformer> reflectMethods() {\n+        return CodeReflectionSupport.CODE_LAYER != null ?\n+                ServiceLoader.load(CodeReflectionSupport.CODE_LAYER, CodeReflectionTransformer.class).findFirst() :\n+                Optional.empty();\n+    }\n+\n+    static class CodeReflectionSupport {\n+        static final ModuleLayer CODE_LAYER;\n+\n+        static {\n+            if (ModuleLayer.boot().findModule(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ we are in an exploded build, so just use the boot layer\n+                CODE_LAYER = ModuleLayer.boot();\n+            } else if (java.lang.module.ModuleFinder.ofSystem().find(\"jdk.incubator.code\").isPresent()) {\n+                \/\/ the code module is installed, but not in the boot layer, create a new layer which contains it\n+                ModuleLayer parent = ModuleLayer.boot();\n+                Configuration cf = parent.configuration()\n+                        .resolve(java.lang.module.ModuleFinder.of(), java.lang.module.ModuleFinder.ofSystem(), Set.of(\"jdk.incubator.code\"));\n+                ClassLoader scl = ClassLoader.getSystemClassLoader();\n+                CODE_LAYER = parent.defineModulesWithOneLoader(cf, scl);\n+                Module codeReflectionModule = CODE_LAYER.findModule(\"jdk.incubator.code\").get();\n+                Module jdkCompilerModule = JavaCompiler.class.getModule();\n+                \/\/ We need to add exports all jdk.compiler packages so that the plugin can use them\n+                for (String packageName : jdkCompilerModule.getPackages()) {\n+                    jdkCompilerModule.addExports(packageName, codeReflectionModule);\n+                }\n+            } else {\n+                \/\/ if we run in bootstrap mode, there might be no jdk.incubator.code\n+                CODE_LAYER = null;\n+            }\n+        }\n+    }\n+\n@@ -1827,0 +1880,4 @@\n+    public boolean hasCodeReflectionModule() {\n+        return hasCodeReflectionModule;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1399,0 +1399,8 @@\n+# 0: list of type\n+compiler.err.cant.infer.quoted.lambda.return.type=\\\n+    cannot infer return type for quoted lambda expression\\n\\\n+    (found: {0})\n+\n+compiler.err.quoted.lambda.must.be.explicit=\\\n+    Quoted lambda cannot have implicit parameter types\n+\n@@ -4132,0 +4140,25 @@\n+\n+########################################\n+# Diagnostics for code reflection\n+########################################\n+\n+compiler.misc.feature.reflect.methods=\\\n+    code reflection\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.dump=\\\n+    code reflection enabled for method {0}.{1}\\n\\\n+    {2}\n+\n+# 0: symbol, 1: symbol, 2: string\n+compiler.note.method.ir.skip=\\\n+    unsupported code reflection node {2} found in method {0}.{1}\n+\n+# 0: string\n+compiler.note.quoted.ir.dump=\\\n+    code reflection enabled for method quoted lambda\\n\\\n+    {0}\n+\n+# 0: string\n+compiler.note.quoted.ir.skip=\\\n+    unsupported code reflection node {0} found in quoted lambda\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -803,1 +803,2 @@\n-    public abstract static class JCFunctionalExpression extends JCPolyExpression {\n+    public abstract static sealed class JCFunctionalExpression extends JCPolyExpression\n+                                                               permits JCLambda, JCMemberReference {\n@@ -814,0 +815,2 @@\n+        \/** code reflection specific metadata. *\/\n+        public Symbol codeModel;\n@@ -816,1 +819,8 @@\n-            return target != null ? types.findDescriptorType(target) : types.createErrorType(null);\n+            if (target == null) {\n+                return types.createErrorType(null);\n+            } else if (target.hasTag(TypeTag.METHOD)) {\n+                \/\/ this is a quoted expression\n+                return target;\n+            } else {\n+                return types.findDescriptorType(target);\n+            }\n@@ -2009,1 +2019,1 @@\n-    public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n+    public static final class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {\n@@ -2598,1 +2608,1 @@\n-    public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n+    public static non-sealed class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -670,0 +670,3 @@\n+\n+jdk_lang_reflect_code = \\\n+   java\/lang\/reflect\/code\n","filename":"test\/jdk\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import static java.lang.classfile.Opcode.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import jdk.incubator.code.bytecode.BranchCompactor;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import java.util.List;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @run testng TestBranchCompactor\n+ *\/\n+public class TestBranchCompactor {\n+\n+    @Test\n+    public void testBranchCompactor() {\n+        var cc = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        var clm = cc.parse(cc.build(ClassDesc.of(\"c\"), clb -> clb.withMethodBody(\"m\", ConstantDescs.MTD_void, 0,\n+                cb -> cb.transforming(new BranchCompactor(), cob -> {\n+                    var l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .lineNumber(1)\n+                       .labelBinding(l)\n+                       .nop();\n+\n+                    l = cob.newLabel();\n+                    cob.goto_w(l) \/\/compact\n+                       .lineNumber(2)\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/compact\n+                       .labelBinding(l);\n+\n+                    cob.iconst_0();\n+                    l = cob.newLabel();\n+                    cob.ifeq(l) \/\/do not compact\n+                       .labelBinding(l);\n+\n+                    l = cob.newLabel();\n+                    cob.goto_(l) \/\/do not compact\n+                       .nop()\n+                       .labelBinding(l)\n+                       .return_();\n+                }))));\n+        var code = clm.methods().get(0).code().get();\n+        ClassPrinter.toYaml(code, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+        Assert.assertEquals(\n+                code.elementList().stream().mapMulti((e, ec) -> {if (e instanceof Instruction i) ec.accept(i.opcode());}).toList(),\n+                List.of(NOP, ICONST_0, IFEQ, GOTO, NOP, RETURN));\n+        Assert.assertEquals(code.findAttribute(Attributes.lineNumberTable()).get().lineNumbers().size(), 2);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,738 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AccessFlag;\n+import org.testng.Assert;\n+import org.testng.SkipException;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Interpreter;\n+import java.lang.reflect.Method;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.type.JavaType;\n+import jdk.incubator.code.CodeReflection;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @run testng\/othervm -Djdk.invoke.MethodHandle.dumpClassFiles=true TestBytecode\n+ *\/\n+\n+public class TestBytecode {\n+\n+    @CodeReflection\n+    static int intNumOps(int i, int j, int k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static byte byteNumOps(byte i, byte j, byte k) {\n+        k++;\n+        i = (byte) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static short shortNumOps(short i, short j, short k) {\n+        k++;\n+        i = (short) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static char charNumOps(char i, char j, char k) {\n+        k++;\n+        i = (char) ((i + j) \/ k - i % j);\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static long longNumOps(long i, long j, long k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static float floatNumOps(float i, float j, float k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static double doubleNumOps(double i, double j, double k) {\n+        k++;\n+        i = (i + j) \/ k - i % j;\n+        i--;\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int intBitOps(int i, int j, int k) {\n+        return ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static byte byteBitOps(byte i, byte j, byte k) {\n+        return (byte) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static short shortBitOps(short i, short j, short k) {\n+        return (short) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static char charBitOps(char i, char j, char k) {\n+        return (char) ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static long longBitOps(long i, long j, long k) {\n+        return ~(i & j | k ^ j);\n+    }\n+\n+    @CodeReflection\n+    static boolean boolBitOps(boolean i, boolean j, boolean k) {\n+        return i & j | k ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int intShiftOps(int i, int j, int k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    static byte byteShiftOps(byte i, byte j, byte k) {\n+        return (byte) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static short shortShiftOps(short i, short j, short k) {\n+        return (short) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static char charShiftOps(char i, char j, char k) {\n+        return (char) (((-1 >> i) << (j << k)) >>> (k - j));\n+    }\n+\n+    @CodeReflection\n+    static long longShiftOps(long i, long j, long k) {\n+        return ((-1 >> i) << (j << k)) >>> (k - j);\n+    }\n+\n+    @CodeReflection\n+    static Object[] boxingAndUnboxing(int i, byte b, short s, char c, Integer ii, Byte bb, Short ss, Character cc) {\n+        ii += i; ii += b; ii += s; ii += c;\n+        i += ii; i += bb; i += ss; i += cc;\n+        b += ii; b += bb; b += ss; b += cc;\n+        s += ii; s += bb; s += ss; s += cc;\n+        c += ii; c += bb; c += ss; c += cc;\n+        return new Object[]{i, b, s, c};\n+    }\n+\n+    @CodeReflection\n+    static String constructor(String s, int i, int j) {\n+        return new String(s.getBytes(), i, j);\n+    }\n+\n+    @CodeReflection\n+    static Class<?> classArray(int i, int j) {\n+        Class<?>[] ifaces = new Class[1 + i + j];\n+        ifaces[0] = Function.class;\n+        return ifaces[0];\n+    }\n+\n+    @CodeReflection\n+    static String[] stringArray(int i, int j) {\n+        return new String[i];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArray2(int i, int j) {\n+        return new String[i][];\n+    }\n+\n+    @CodeReflection\n+    static String[][] stringArrayMulti(int i, int j) {\n+        return new String[i][j];\n+    }\n+\n+    @CodeReflection\n+    static int[][] initializedIntArray(int i, int j) {\n+        return new int[][]{{i, j}, {i + j}};\n+    }\n+\n+    @CodeReflection\n+    static int ifElseCompare(int i, int j) {\n+        if (i < 3) {\n+            i += 1;\n+        } else {\n+            j += 2;\n+        }\n+        return i + j;\n+    }\n+\n+    @CodeReflection\n+    static int ifElseEquality(int i, int j) {\n+        if (j != 0) {\n+            if (i != 0) {\n+                i += 1;\n+            } else {\n+                i += 2;\n+            }\n+        } else {\n+            if (j != 0) {\n+                i += 3;\n+            } else {\n+                i += 4;\n+            }\n+        }\n+        return i;\n+    }\n+\n+    @CodeReflection\n+    static int objectsCompare(Boolean b1, Boolean b2, Boolean b3) {\n+        Object a = b1;\n+        Object b = b2;\n+        Object c = b3;\n+        return a == b ? (a != c ? 1 : 2) : (b != c ? 3 : 4);\n+    }\n+\n+    @CodeReflection\n+    static int conditionalExpr(int i, int j) {\n+        return ((i - 1 >= 0) ? i - 1 : j - 1);\n+    }\n+\n+    @CodeReflection\n+    static int nestedConditionalExpr(int i, int j) {\n+        return (i < 2) ? (j < 3) ? i : j : i + j;\n+    }\n+\n+    static final int[] MAP = {0, 1, 2, 3, 4};\n+\n+    @CodeReflection\n+    static int deepStackBranches(boolean a, boolean b) {\n+        return MAP[a ? MAP[b ? 1 : 2] : MAP[b ? 3 : 4]];\n+    }\n+\n+    @CodeReflection\n+    static int tryFinally(int i, int j) {\n+        try {\n+            i = i + j;\n+        } finally {\n+            i = i + j;\n+        }\n+        return i;\n+    }\n+\n+    public record A(String s) {}\n+\n+    @CodeReflection\n+    static A newWithArgs(int i, int j) {\n+        return new A(\"hello world\".substring(i, i + j));\n+    }\n+\n+    @CodeReflection\n+    static int loop(int n, int j) {\n+        int sum = 0;\n+        for (int i = 0; i < n; i++) {\n+            sum = sum + j;\n+        }\n+        return sum;\n+    }\n+\n+\n+    @CodeReflection\n+    static int ifElseNested(int a, int b) {\n+        int c = a + b;\n+        int d = 10 - a + b;\n+        if (b < 3) {\n+            if (a < 3) {\n+                a += 1;\n+            } else {\n+                b += 2;\n+            }\n+            c += 3;\n+        } else {\n+            if (a > 2) {\n+                a += 4;\n+            } else {\n+                b += 5;\n+            }\n+            d += 6;\n+        }\n+        return a + b + c + d;\n+    }\n+\n+    @CodeReflection\n+    static int nestedLoop(int m, int n) {\n+        int sum = 0;\n+        for (int i = 0; i < m; i++) {\n+            for (int j = 0; j < n; j++) {\n+                sum = sum + i + j;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @CodeReflection\n+    static int methodCall(int a, int b) {\n+        int i = Math.max(a, b);\n+        return Math.negateExact(i);\n+    }\n+\n+    @CodeReflection\n+    static int[] primitiveArray(int i, int j) {\n+        int[] ia = new int[i + 1];\n+        ia[0] = j;\n+        return ia;\n+    }\n+\n+    @CodeReflection\n+    static boolean not(boolean b) {\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static boolean notCompare(int i, int j) {\n+        boolean b = i < j;\n+        return !b;\n+    }\n+\n+    @CodeReflection\n+    static int mod(int i, int j) {\n+        return i % (j + 1);\n+    }\n+\n+    @CodeReflection\n+    static int xor(int i, int j) {\n+        return i ^ j;\n+    }\n+\n+    @CodeReflection\n+    static int whileLoop(int i, int n) { int\n+        counter = 0;\n+        while (i < n && counter < 3) {\n+            counter++;\n+            if (counter == 4) {\n+                break;\n+            }\n+            i++;\n+        }\n+        return counter;\n+    }\n+\n+    public interface Func {\n+        int apply(int a);\n+    }\n+\n+    public interface QuotableFunc extends Quotable {\n+        int apply(int a);\n+    }\n+\n+    static int consume(int i, Func f) {\n+        return f.apply(i + 1);\n+    }\n+\n+    static int consumeQuotable(int i, QuotableFunc f) {\n+        Assert.assertNotNull(f.quoted());\n+        Assert.assertNotNull(f.quoted().op());\n+        Assert.assertTrue(f.quoted().op() instanceof CoreOp.LambdaOp);\n+        return f.apply(i + 1);\n+    }\n+\n+    @CodeReflection\n+    static int lambda(int i) {\n+        return consume(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    static int quotableLambda(int i) {\n+        return consumeQuotable(i, a -> -a);\n+    }\n+\n+    @CodeReflection\n+    static int lambdaWithCapture(int i, String s) {\n+        return consume(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int quotableLambdaWithCapture(int i, String s) {\n+        return consumeQuotable(i, a -> a + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int nestedLambdasWithCaptures(int i, int j, String s) {\n+        return consume(i, a -> consume(a, b -> a + b + j - s.length()) + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int nestedQuotableLambdasWithCaptures(int i, int j, String s) {\n+        return consumeQuotable(i, a -> consumeQuotable(a, b -> a + b + j - s.length()) + s.length());\n+    }\n+\n+    @CodeReflection\n+    static int methodHandle(int i) {\n+        return consume(i, Math::negateExact);\n+    }\n+\n+    int instanceMethod(int i) {\n+        return -i + 13;\n+    }\n+\n+    @CodeReflection\n+    int instanceMethodHandle(int i) {\n+        return consume(i, this::instanceMethod);\n+    }\n+\n+    static void consume(boolean b, Consumer<Object> requireNonNull) {\n+        if (b) {\n+            requireNonNull.accept(new Object());\n+        } else try {\n+            requireNonNull.accept(null);\n+            throw new AssertionError(\"Expectend NPE\");\n+        } catch (NullPointerException expected) {\n+        }\n+    }\n+\n+    @CodeReflection\n+    static void nullReturningMethodHandle(boolean b) {\n+        consume(b, Objects::requireNonNull);\n+    }\n+\n+    @CodeReflection\n+    static boolean compareLong(long i, long j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareFloat(float i, float j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static boolean compareDouble(double i, double j) {\n+        return i > j;\n+    }\n+\n+    @CodeReflection\n+    static int lookupSwitch(int i) {\n+        return switch (1000 * i) {\n+            case 1000 -> 1;\n+            case 2000 -> 2;\n+            case 3000 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    @CodeReflection\n+    static int tableSwitch(int i) {\n+        return switch (i) {\n+            case 1 -> 1;\n+            case 2 -> 2;\n+            case 3 -> 3;\n+            default -> 0;\n+        };\n+    }\n+\n+    int instanceField = -1;\n+\n+    @CodeReflection\n+    int instanceFieldAccess(int i) {\n+        int ret = instanceField;\n+        instanceField = i;\n+        return ret;\n+    }\n+\n+    @CodeReflection\n+    static String stringConcat(String a, String b) {\n+        return \"a\"+ a +\"\\u0001\" + a + \"b\\u0002c\" + b + \"\\u0001\\u0002\" + b + \"dd\";\n+    }\n+\n+    @CodeReflection\n+    static String multiTypeConcat(int i, Boolean b, char c, Short s, float f, Double d) {\n+        return \"i:\"+ i +\" b:\" + b + \" c:\" + c + \" f:\" + f + \" d:\" + d;\n+    }\n+\n+    @CodeReflection\n+    static int ifTrue(int i) {\n+        if (true) {\n+            return i;\n+        }\n+        return -i;\n+    }\n+\n+    @CodeReflection\n+    static int excHandlerFollowingSplitTable(boolean b) {\n+        try {\n+            if (b) return 1;\n+            else throw new Exception();\n+        } catch (Exception ex) {}\n+        return 2;\n+    }\n+\n+    @CodeReflection\n+    static int varModifiedInTryBlock(boolean b) {\n+        int i = 0;\n+        try {\n+            i++;\n+            if (b) throw new Exception();\n+            i++;\n+            throw new Exception();\n+        } catch (Exception ex) {\n+            return i;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static boolean finallyWithLoop(boolean b) {\n+        try {\n+            while (b) {\n+                if (b)\n+                    return false;\n+                b = !b;\n+            }\n+            return true;\n+        } finally {\n+            b = false;\n+        }\n+    }\n+\n+    @CodeReflection\n+    static long doubleUseOfOperand(int x) {\n+        long piece = x;\n+        return piece * piece;\n+    }\n+\n+    record TestData(Method testMethod) {\n+        @Override\n+        public String toString() {\n+            String s = testMethod.getName() + Arrays.stream(testMethod.getParameterTypes())\n+                    .map(Class::getSimpleName).collect(Collectors.joining(\",\", \"(\", \")\"));\n+            if (s.length() > 30) s = s.substring(0, 27) + \"...\";\n+            return s;\n+        }\n+    }\n+\n+    @DataProvider(name = \"testMethods\")\n+    public static TestData[]testMethods() {\n+        return Stream.of(TestBytecode.class.getDeclaredMethods())\n+                .filter(m -> m.isAnnotationPresent(CodeReflection.class))\n+                .map(TestData::new).toArray(TestData[]::new);\n+    }\n+\n+    private static byte[] CLASS_DATA;\n+    private static ClassModel CLASS_MODEL;\n+\n+    @BeforeClass\n+    public static void setup() throws Exception {\n+        CLASS_DATA = TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes();\n+        CLASS_MODEL = ClassFile.of().parse(CLASS_DATA);\n+    }\n+\n+    private static MethodTypeDesc toMethodTypeDesc(Method m) {\n+        return MethodTypeDesc.of(\n+                m.getReturnType().describeConstable().orElseThrow(),\n+                Arrays.stream(m.getParameterTypes())\n+                        .map(cls -> cls.describeConstable().orElseThrow()).toList());\n+    }\n+\n+\n+    private static final Map<Class<?>, Object[]> TEST_ARGS = new IdentityHashMap<>();\n+    private static Object[] values(Object... values) {\n+        return values;\n+    }\n+    private static void initTestArgs(Object[] values, Class<?>... argTypes) {\n+        for (var argType : argTypes) TEST_ARGS.put(argType, values);\n+    }\n+    static {\n+        initTestArgs(values(1, 2, 4), int.class, Integer.class);\n+        initTestArgs(values((byte)1, (byte)3, (byte)4), byte.class, Byte.class);\n+        initTestArgs(values((short)1, (short)2, (short)3), short.class, Short.class);\n+        initTestArgs(values((char)2, (char)3, (char)4), char.class, Character.class);\n+        initTestArgs(values(false, true), boolean.class, Boolean.class);\n+        initTestArgs(values(\"Hello World\"), String.class);\n+        initTestArgs(values(1l, 2l, 4l), long.class, Long.class);\n+        initTestArgs(values(1f, 3f, 4f), float.class, Float.class);\n+        initTestArgs(values(1d, 2d, 3d), double.class, Double.class);\n+    }\n+\n+    interface Executor {\n+        void execute(Object[] args) throws Throwable;\n+    }\n+\n+    private static void permutateAllArgs(Class<?>[] argTypes, Executor executor) throws Throwable {\n+        final int argn = argTypes.length;\n+        Object[][] argValues = new Object[argn][];\n+        for (int i = 0; i < argn; i++) {\n+            argValues[i] = TEST_ARGS.get(argTypes[i]);\n+        }\n+        int[] argIndexes = new int[argn];\n+        Object[] args = new Object[argn];\n+        while (true) {\n+            for (int i = 0; i < argn; i++) {\n+                args[i] = argValues[i][argIndexes[i]];\n+            }\n+            executor.execute(args);\n+            int i = argn - 1;\n+            while (i >= 0 && argIndexes[i] == argValues[i].length - 1) i--;\n+            if (i < 0) return;\n+            argIndexes[i++]++;\n+            while (i < argn) argIndexes[i++] = 0;\n+        }\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testLift(TestData d) throws Throwable {\n+        CoreOp.FuncOp flift;\n+        try {\n+            flift = BytecodeLift.lift(CLASS_DATA, d.testMethod.getName(), toMethodTypeDesc(d.testMethod));\n+        } catch (Throwable e) {\n+            ClassPrinter.toYaml(ClassFile.of().parse(TestBytecode.class.getResourceAsStream(\"TestBytecode.class\").readAllBytes())\n+                    .methods().stream().filter(m -> m.methodName().equalsString(d.testMethod().getName())).findAny().get(),\n+                    ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+            System.out.println(\"Lift failed, compiled model:\");\n+            Op.ofMethod(d.testMethod).ifPresent(f -> f.writeTo(System.out));\n+            throw e;\n+        }\n+        try {\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args ->\n+                Assert.assertEquals(invokeAndConvert(flift, receiver1, args), d.testMethod.invoke(receiver2, args)));\n+        } catch (Throwable e) {\n+            System.out.println(\"Compiled model:\");\n+            Op.ofMethod(d.testMethod).ifPresent(f -> f.writeTo(System.out));\n+            System.out.println(\"Lifted model:\");\n+            flift.writeTo(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    private static Object invokeAndConvert(CoreOp.FuncOp func, Object receiver, Object... args) {\n+        List argl = new ArrayList(args.length + 1);\n+        if (receiver != null) argl.add(receiver);\n+        argl.addAll(Arrays.asList(args));\n+        Object ret = Interpreter.invoke(MethodHandles.lookup(), func, argl);\n+        if (ret instanceof Integer i) {\n+            TypeElement rt = func.invokableType().returnType();\n+            if (rt.equals(JavaType.BOOLEAN)) {\n+                return i != 0;\n+            } else if (rt.equals(JavaType.BYTE)) {\n+                return i.byteValue();\n+            } else if (rt.equals(JavaType.CHAR)) {\n+                return (short)i.intValue();\n+            } else if (rt.equals(JavaType.SHORT)) {\n+                return i.shortValue();\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Test(dataProvider = \"testMethods\")\n+    public void testGenerate(TestData d) throws Throwable {\n+        CoreOp.FuncOp func = Op.ofMethod(d.testMethod).get();\n+\n+        CoreOp.FuncOp lfunc;\n+        try {\n+            lfunc = func.transform(CopyContext.create(), OpTransformer.LOWERING_TRANSFORMER);\n+        } catch (UnsupportedOperationException uoe) {\n+            throw new SkipException(\"lowering caused:\", uoe);\n+        }\n+\n+        try {\n+            MethodHandle mh = BytecodeGenerator.generate(MethodHandles.lookup(), lfunc);\n+            Object receiver1, receiver2;\n+            if (d.testMethod.accessFlags().contains(AccessFlag.STATIC)) {\n+                receiver1 = null;\n+                receiver2 = null;\n+            } else {\n+                receiver1 = new TestBytecode();\n+                receiver2 = new TestBytecode();\n+            }\n+            permutateAllArgs(d.testMethod.getParameterTypes(), args -> {\n+                    List argl = new ArrayList(args.length + 1);\n+                    if (receiver1 != null) argl.add(receiver1);\n+                    argl.addAll(Arrays.asList(args));\n+                    Assert.assertEquals(mh.invokeWithArguments(argl), d.testMethod.invoke(receiver2, args));\n+            });\n+        } catch (Throwable e) {\n+            func.writeTo(System.out);\n+            lfunc.writeTo(System.out);\n+            String methodName = d.testMethod().getName();\n+            for (var mm : CLASS_MODEL.methods()) {\n+                if (mm.methodName().equalsString(methodName)\n+                        || mm.methodName().stringValue().startsWith(\"lambda$\" + methodName + \"$\")) {\n+                    ClassPrinter.toYaml(mm,\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                }\n+            }\n+            Files.list(Path.of(\"DUMP_CLASS_FILES\")).forEach(p -> {\n+                if (p.getFileName().toString().matches(methodName + \"\\\\..+\\\\.class\")) try {\n+                    ClassPrinter.toYaml(ClassFile.of().parse(p),\n+                                        ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES,\n+                                        System.out::print);\n+                } catch (IOException ignore) {}\n+            });\n+            throw e;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":738,"deletions":0,"binary":false,"changes":738,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.StringWriter;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Instruction;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.attribute.CodeAttribute;\n+import java.lang.classfile.instruction.*;\n+import java.lang.invoke.MethodHandles;\n+import jdk.incubator.code.bytecode.BytecodeGenerator;\n+import jdk.incubator.code.bytecode.BytecodeLift;\n+import jdk.incubator.code.interpreter.Verifier;\n+import jdk.incubator.code.op.CoreOp;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.Assert;\n+import org.testng.annotations.Ignore;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.code java.base\/jdk.internal.classfile.components\n+ * @enablePreview\n+ * @modules java.base\/java.lang.invoke:open\n+ * @run testng TestSmallCorpus\n+ *\/\n+public class TestSmallCorpus {\n+\n+    private static final String ROOT_PATH = \"modules\/java.base\/\";\n+    private static final String CLASS_NAME_SUFFIX = \".class\";\n+    private static final String METHOD_NAME = null;\n+    private static final int ROUNDS = 3;\n+\n+    private static final FileSystem JRT = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+    private static final ClassFile CF = ClassFile.of();\n+    private static final int COLUMN_WIDTH = 150;\n+    private static final MethodHandles.Lookup TRUSTED_LOOKUP;\n+    static {\n+        try {\n+            var lf = MethodHandles.Lookup.class.getDeclaredField(\"IMPL_LOOKUP\");\n+            lf.setAccessible(true);\n+            TRUSTED_LOOKUP = (MethodHandles.Lookup)lf.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private MethodModel bytecode;\n+    CoreOp.FuncOp reflection;\n+    private int stable, unstable;\n+    private Long[] stats = new Long[6];\n+\n+    @Ignore\n+    @Test\n+    public void testRoundTripStability() throws Exception {\n+        stable = 0;\n+        unstable = 0;\n+        Arrays.fill(stats, 0l);\n+        for (Path p : Files.walk(JRT.getPath(ROOT_PATH))\n+                .filter(p -> Files.isRegularFile(p) && p.toString().endsWith(CLASS_NAME_SUFFIX))\n+                .toList()) {\n+            testRoundTripStability(p);\n+        }\n+\n+        System.out.println(\"\"\"\n+        statistics     original  generated\n+        code length: %1$,10d %4$,10d\n+        max locals:  %2$,10d %5$,10d\n+        max stack:   %3$,10d %6$,10d\n+        \"\"\".formatted((Object[])stats));\n+\n+        \/\/ Roundtrip is 100% stable after 3 rounds, no exceptions, no verification errors\n+        Assert.assertTrue(stable > 54500 && unstable == 0, String.format(\"stable: %d unstable: %d\", stable, unstable));\n+    }\n+\n+    private void testRoundTripStability(Path path) throws Exception {\n+        var clm = CF.parse(path);\n+        for (var originalModel : clm.methods()) {\n+            if (originalModel.code().isPresent() && (METHOD_NAME == null || originalModel.methodName().equalsString(METHOD_NAME))) try {\n+                bytecode = originalModel;\n+                reflection = null;\n+                MethodModel prevBytecode = null;\n+                CoreOp.FuncOp prevReflection = null;\n+                for (int round = 1; round <= ROUNDS; round++) try {\n+                    prevBytecode = bytecode;\n+                    prevReflection = reflection;\n+                    lift();\n+                    verifyReflection();\n+                    generate();\n+                    verifyBytecode();\n+                } catch (UnsupportedOperationException uoe) {\n+                    throw uoe;\n+                } catch (Throwable t) {\n+                    System.out.println(\" at \" + path + \" \" + originalModel.methodName() + originalModel.methodType() + \" round \" + round);\n+                    throw t;\n+                }\n+                if (ROUNDS > 0) {\n+                    var normPrevBytecode = normalize(prevBytecode);\n+                    var normBytecode = normalize(bytecode);\n+                    if (normPrevBytecode.equals(normBytecode)) {\n+                        stable++;\n+                    } else {\n+                        unstable++;\n+                        System.out.println(\"Unstable code \" + path + \" \" + originalModel.methodName() + originalModel.methodType() + \" after \" + ROUNDS +\" round(s)\");\n+                        if (prevReflection != null) printInColumns(prevReflection, reflection);\n+                        printInColumns(normPrevBytecode, normBytecode);\n+                        System.out.println();\n+                    }\n+                    var ca = (CodeAttribute)originalModel.code().get();\n+                    stats[0] += ca.codeLength();\n+                    stats[1] += ca.maxLocals();\n+                    stats[2] += ca.maxStack();\n+                    ca = (CodeAttribute)bytecode.code().get();\n+                    stats[3] += ca.codeLength();\n+                    stats[4] += ca.maxLocals();\n+                    stats[5] += ca.maxStack();\n+                }\n+            } catch (UnsupportedOperationException uoe) {\n+                \/\/ InvokeOp when InvokeKind == SUPER\n+            }\n+        }\n+    }\n+\n+    private void verifyReflection() {\n+        var errors = Verifier.verify(TRUSTED_LOOKUP, reflection);\n+        if (!errors.isEmpty()) {\n+            printBytecode();\n+            System.out.println(\"Code reflection model verification failed:\");\n+            errors.forEach(e -> System.out.println(e.getMessage()));\n+            System.out.println(errors.getFirst().getPrintedContext());\n+            throw new AssertionError(\"Code reflection model verification failed\");\n+        }\n+    }\n+\n+    private void verifyBytecode() {\n+        var errors = ClassFile.of().verify(bytecode.parent().get()).stream()\n+                .filter(e -> !e.getMessage().contains(\"Illegal call to internal method\")).toList();\n+        if (!errors.isEmpty()) {\n+            printReflection();\n+            System.out.println(\"Bytecode verification failed:\");\n+            errors.forEach(e -> System.out.println(e.getMessage()));\n+            printBytecode();\n+            throw new AssertionError(\"Bytecode verification failed\");\n+        }\n+    }\n+\n+    private static void printInColumns(CoreOp.FuncOp first, CoreOp.FuncOp second) {\n+        StringWriter fw = new StringWriter();\n+        first.writeTo(fw);\n+        StringWriter sw = new StringWriter();\n+        second.writeTo(sw);\n+        printInColumns(fw.toString().lines().toList(), sw.toString().lines().toList());\n+    }\n+\n+    private static void printInColumns(List<String> first, List<String> second) {\n+        System.out.println(\"-\".repeat(COLUMN_WIDTH ) + \"--+-\" + \"-\".repeat(COLUMN_WIDTH ));\n+        for (int i = 0; i < first.size() || i < second.size(); i++) {\n+            String f = i < first.size() ? first.get(i) : \"\";\n+            String s = i < second.size() ? second.get(i) : \"\";\n+            System.out.println(\" \" + f + (f.length() < COLUMN_WIDTH ? \" \".repeat(COLUMN_WIDTH - f.length()) : \"\") + (f.equals(s) ? \" | \" : \" x \") + s);\n+        }\n+    }\n+\n+    private void lift() {\n+        try {\n+            reflection = BytecodeLift.lift(bytecode);\n+        } catch (Throwable t) {\n+            printReflection();\n+            printBytecode();\n+            System.out.println(\"Lift failed\");\n+            throw t;\n+        }\n+    }\n+\n+    private void generate() {\n+        try {\n+            bytecode = CF.parse(BytecodeGenerator.generateClassData(\n+                TRUSTED_LOOKUP,\n+                reflection)).methods().getFirst();\n+        } catch (UnsupportedOperationException uoe) {\n+            throw uoe;\n+        } catch (Throwable t) {\n+            printBytecode();\n+            printReflection();\n+            System.out.println(\"Generation failed\");\n+            throw t;\n+        }\n+    }\n+\n+    private void printBytecode() {\n+        ClassPrinter.toYaml(bytecode, ClassPrinter.Verbosity.CRITICAL_ATTRIBUTES, System.out::print);\n+    }\n+\n+    private void printReflection() {\n+        if (reflection != null) System.out.println(reflection.toText());\n+    }\n+\n+    public static List<String> normalize(MethodModel mm) {\n+        record El(int index, String format, Label... targets) {\n+            public El(int index, Instruction i, Object format, Label... targets) {\n+                this(index, trim(i.opcode()) + \" \" + format, targets);\n+            }\n+            public String toString(Map<Label, Integer> targetsMap) {\n+                return \"%3d: \".formatted(index) + (targets.length == 0 ? format : format.formatted(Stream.of(targets).map(l -> targetsMap.get(l)).toArray()));\n+            }\n+        }\n+\n+        Map<Label, Integer> targetsMap = new HashMap<>();\n+        List<El> elements = new ArrayList<>();\n+        Label lastLabel = null;\n+        int i = 0;\n+        for (var e : mm.code().orElseThrow()) {\n+            var er = switch (e) {\n+                case LabelTarget lt -> {\n+                    lastLabel = lt.label();\n+                    yield null;\n+                }\n+                case ExceptionCatch ec ->\n+                    new El(i++, \"ExceptionCatch start: @%d end: @%d handler: @%d\" + ec.catchType().map(ct -> \" catch type: \" + ct.asInternalName()).orElse(\"\"), ec.tryStart(), ec.tryEnd(), ec.handler());\n+                case BranchInstruction ins ->\n+                    new El(i++, ins, \"@%d\", ins.target());\n+                case ConstantInstruction ins ->\n+                    new El(i++, \"LDC \" + ins.constantValue());\n+                case FieldInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \".\" + ins.name().stringValue());\n+                case InvokeDynamicInstruction ins ->\n+                    new El(i++, ins, ins.name().stringValue() + ins.typeSymbol() + \" \" + ins.bootstrapMethod() + \"(\" + ins.bootstrapArgs() + \")\");\n+                case InvokeInstruction ins ->\n+                    new El(i++, ins, ins.owner().asInternalName() + \"::\" + ins.name().stringValue() + ins.typeSymbol().displayDescriptor());\n+                case LoadInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case StoreInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot());\n+                case IncrementInstruction ins ->\n+                    new El(i++, ins, \"#\" + ins.slot() + \" \" + ins.constant());\n+                case LookupSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case NewMultiArrayInstruction ins ->\n+                    new El(i++, ins, ins.arrayType().asInternalName() + \"(\" + ins.dimensions() + \")\");\n+                case NewObjectInstruction ins ->\n+                    new El(i++, ins, ins.className().asInternalName());\n+                case NewPrimitiveArrayInstruction ins ->\n+                    new El(i++, ins, ins.typeKind());\n+                case NewReferenceArrayInstruction ins ->\n+                    new El(i++, ins, ins.componentType().asInternalName());\n+                case TableSwitchInstruction ins ->\n+                    new El(i++, ins, \"default: @%d\" + ins.cases().stream().map(c -> \", \" + c.caseValue() + \": @%d\").collect(Collectors.joining()),\n+                            Stream.concat(Stream.of(ins.defaultTarget()), ins.cases().stream().map(SwitchCase::target)).toArray(Label[]::new));\n+                case TypeCheckInstruction ins ->\n+                    new El(i++, ins, ins.type().asInternalName());\n+                case Instruction ins ->\n+                    new El(i++, ins, \"\");\n+                default -> null;\n+            };\n+            if (er != null) {\n+                if (lastLabel != null) {\n+                    targetsMap.put(lastLabel, elements.size());\n+                    lastLabel = null;\n+                }\n+                elements.add(er);\n+            }\n+        }\n+        return elements.stream().map(el -> el.toString(targetsMap)).toList();\n+    }\n+\n+    private static String trim(Opcode opcode) {\n+        var name = opcode.toString();\n+        int i = name.indexOf('_');\n+        return i > 2 ? name.substring(0, i) : name;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -215,0 +215,7 @@\n+compiler.misc.feature.reflect.methods                         # code reflection\n+compiler.note.method.ir.dump                                  # code reflection\n+compiler.note.method.ir.skip                                  # code reflection\n+compiler.err.cant.infer.quoted.lambda.return.type             # code reflection\n+compiler.err.quoted.lambda.must.be.explicit                   # code reflection\n+compiler.note.quoted.ir.dump                                  # code reflection\n+compiler.note.quoted.ir.skip                                  # code reflection\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}