{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=24\n+version=25\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,3 +116,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -148,1 +145,1 @@\n-            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+            this.implInfo = caller.revealDirect(implementation);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -31,1 +32,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -37,1 +37,0 @@\n-import java.lang.classfile.FieldBuilder;\n@@ -44,1 +43,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -61,1 +59,1 @@\n-import java.lang.classfile.constantpool.MethodRefEntry;\n+\n@@ -65,3 +63,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n-import static java.lang.invoke.MethodType.methodType;\n@@ -70,1 +65,1 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n+import jdk.internal.vm.annotation.Stable;\n@@ -81,1 +76,1 @@\n-    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+    private static final @Stable String[] ARG_NAME_CACHE = {\"arg$1\", \"arg$2\", \"arg$3\", \"arg$4\", \"arg$5\", \"arg$6\", \"arg$7\", \"arg$8\"};\n@@ -108,1 +103,1 @@\n-        disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);\n+        disableEagerInitialization = Boolean.getBoolean(disableEagerInitializationKey);\n@@ -117,1 +112,0 @@\n-    private final String[] argNames;                 \/\/ Generated names for the constructor arguments\n@@ -160,3 +154,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -183,1 +174,1 @@\n-        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n+        lambdaClassEntry = pool.classEntry(ConstantUtils.internalNameToDesc(lambdaClassName));\n@@ -196,0 +187,2 @@\n+        ClassDesc[] argDescs;\n+        MethodTypeDesc constructorTypeDesc;\n@@ -197,1 +190,0 @@\n-            argNames = new String[parameterCount];\n@@ -200,1 +192,0 @@\n-                argNames[i] = \"arg$\" + (i + 1);\n@@ -203,0 +194,1 @@\n+            constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -204,1 +196,1 @@\n-            argNames = EMPTY_STRING_ARRAY;\n+            constructorTypeDesc = MTD_void;\n@@ -207,1 +199,2 @@\n-        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n+        this.argDescs = argDescs;\n+        this.constructorTypeDesc = constructorTypeDesc;\n@@ -210,1 +203,5 @@\n-    private static String lambdaClassName(Class<?> targetClass) {\n+    private static String argName(int i) {\n+        return i < ARG_NAME_CACHE.length ? ARG_NAME_CACHE[i] :  \"arg$\" + (i + 1);\n+    }\n+\n+    private static String sanitizedTargetClassName(Class<?> targetClass) {\n@@ -216,1 +213,5 @@\n-        return name.replace('.', '\/').concat(\"$$Lambda\");\n+        return name.replace('.', '\/');\n+    }\n+\n+    private static String lambdaClassName(Class<?> targetClass) {\n+        return sanitizedTargetClassName(targetClass).concat(\"$$Lambda\");\n@@ -335,1 +336,1 @@\n-                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n+                    clb.withField(argName(i), argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -432,4 +433,3 @@\n-                            cob.aload(0);\n-                            Class<?> argType = factoryType.parameterType(i);\n-                            cob.loadLocal(TypeKind.from(argType), cob.parameterSlot(i));\n-                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                            cob.aload(0)\n+                               .loadLocal(TypeKind.from(factoryType.parameterType(i)), cob.parameterSlot(i))\n+                               .putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -470,1 +470,1 @@\n-               .getfield(lambdaClassEntry.asSymbol(), argNames[i], argDescs[i]);\n+               .getfield(lambdaClassEntry.asSymbol(), argName(i), argDescs[i]);\n@@ -526,3 +526,3 @@\n-        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n-        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final ClassDesc CD_SerializedLambda = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n@@ -537,1 +537,1 @@\n-        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final ClassDesc CD_NotSerializableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n@@ -540,1 +540,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ConstantUtils.CD_Object_array);\n@@ -554,1 +554,1 @@\n-                           .ldc(classDesc(targetClass))\n+                           .ldc(ClassDesc.ofInternalName(sanitizedTargetClassName(targetClass)))\n@@ -569,1 +569,1 @@\n-                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -640,1 +640,1 @@\n-                for (int i = 0; i < argNames.length ; i++) {\n+                for (int i = 0; i < argDescs.length; i++) {\n@@ -642,1 +642,1 @@\n-                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argName(i), argDescs[i])));\n@@ -690,1 +690,1 @@\n-        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+        return cls.isHidden() ? null : ConstantUtils.referenceClassDesc(cls.descriptorString());\n@@ -695,1 +695,1 @@\n-                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+                                 : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -232,0 +232,16 @@\n+ * <p>Uses besides evaluation of lambda expressions and method references are\n+ * unintended.  These linkage methods may change their unspecified behaviors at\n+ * any time to better suit the Java language features they were designed to\n+ * support, and such changes may impact unintended uses.  Unintended uses of\n+ * these linkage methods may lead to resource leaks, or other unspecified\n+ * negative effects.\n+ *\n+ * @implNote In the reference implementation, the classes implementing the created\n+ * function objects are strongly reachable from the defining class loader of the\n+ * caller, like classes and interfaces in Java source code.  This technique\n+ * reduces heap memory use, but as a consequence, the implementation classes can\n+ * be unloaded only if the caller class can be unloaded.  In particular, if the\n+ * caller is a {@linkplain MethodHandles.Lookup.ClassOption#STRONG weak hidden\n+ * class}, the implementation class, a strong hidden class, may not be unloaded\n+ * even if the caller may be unloaded.\n+ *\n@@ -323,3 +339,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -483,3 +496,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">refuses access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,2 +86,0 @@\n-    \/\/ generic info repository; lazily initialized\n-    private transient volatile MethodRepository genericInfo;\n@@ -91,11 +89,14 @@\n-    @Stable\n-    private MethodAccessor      methodAccessor;\n-    \/\/ For sharing of MethodAccessors. This branching structure is\n-    \/\/ currently only two levels deep (i.e., one root Method and\n-    \/\/ potentially many Method objects pointing to it.)\n-    \/\/\n-    \/\/ If this branching structure would ever contain cycles, deadlocks can\n-    \/\/ occur in annotation code.\n-    private Method              root;\n-    \/\/ Hash code of this object\n-    private int                 hash;\n+\n+    \/**\n+     * Methods are mutable due to {@link AccessibleObject#setAccessible(boolean)}.\n+     * Thus, we return a new copy of a root each time a method is returned.\n+     * Some lazily initialized immutable states can be stored on root and shared to the copies.\n+     *\/\n+    private Method root;\n+    private transient volatile MethodRepository genericInfo;\n+    private @Stable MethodAccessor methodAccessor;\n+    \/\/ End shared states\n+    private int hash; \/\/ not shared right now, eligible if expensive\n+\n+    \/\/ Cache of code model, if present\n+    \/\/ @@@ May require caching based on symbolic name and class loader\n@@ -117,4 +118,6 @@\n-        \/\/ lazily initialize repository if necessary\n-            \/\/ create and cache generic info repository\n-            genericInfo = MethodRepository.make(getGenericSignature(),\n-                                                getFactory());\n+            var root = this.root;\n+            if (root != null) {\n+                genericInfo = root.getGenericInfo();\n+            } else {\n+                genericInfo = MethodRepository.make(getGenericSignature(), getFactory());\n+            }\n@@ -124,1 +127,1 @@\n-        return genericInfo; \/\/return cached repository\n+        return genericInfo;\n@@ -160,7 +163,0 @@\n-        \/\/ This routine enables sharing of MethodAccessor objects\n-        \/\/ among Method objects which refer to the same underlying\n-        \/\/ method in the VM. (All of this contortion is only necessary\n-        \/\/ because of the \"accessibility\" bit in AccessibleObject,\n-        \/\/ which implicitly requires that new java.lang.reflect\n-        \/\/ objects be fabricated for each reflective call on Class\n-        \/\/ objects.)\n@@ -174,1 +170,1 @@\n-        \/\/ Might as well eagerly propagate this if already present\n+        \/\/ Propagate shared states\n@@ -176,0 +172,1 @@\n+        res.genericInfo = genericInfo;\n@@ -181,1 +178,0 @@\n-     * @throws SecurityException {@inheritDoc}\n@@ -186,1 +182,0 @@\n-        AccessibleObject.checkPermission();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-    exports java.lang.classfile.components;\n@@ -149,0 +148,2 @@\n+    exports jdk.internal to\n+        jdk.incubator.vector;\n@@ -157,0 +158,1 @@\n+        java.se, \/\/ for ParticipatesInPreview\n@@ -171,2 +173,0 @@\n-        java.management.rmi,\n-        java.naming,\n@@ -183,0 +183,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -297,1 +299,0 @@\n-        java.desktop,\n@@ -322,8 +323,1 @@\n-        java.datatransfer,\n-        java.management,\n-        java.management.rmi,\n-        java.rmi,\n-        java.sql.rowset;\n-    exports sun.security.action to\n-        java.desktop,\n-        java.security.jgss;\n+        java.management;\n@@ -341,1 +335,0 @@\n-        java.rmi,\n@@ -355,2 +348,0 @@\n-        java.desktop,\n-        java.rmi,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -151,0 +151,5 @@\n+\n+    \/**\n+      * 25, tbd\n+      *\/\n+    JDK25(\"25\"),\n@@ -203,0 +208,1 @@\n+        case JDK25  -> Target.JDK1_25;\n@@ -265,0 +271,3 @@\n+        JAVA_BASE_TRANSITIVE(JDK24, Fragments.FeatureJavaBaseTransitive, DiagKind.PLURAL),\n+        PRIVATE_MEMBERS_IN_PERMITS_CLAUSE(JDK19),\n+        ERASE_POLY_SIG_RETURN_TYPE(JDK24),\n@@ -352,0 +361,1 @@\n+        case JDK25  -> RELEASE_25;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Type.UnknownType;\n@@ -424,3 +423,0 @@\n-        \/\/ Create the unknown type\n-        unknownType = new UnknownType();\n-\n@@ -436,0 +432,17 @@\n+        noModule = new ModuleSymbol(names.empty, null) {\n+            @Override public boolean isNoModule() {\n+                return true;\n+            }\n+        };\n+        addRootPackageFor(noModule);\n+\n+        Source source = Source.instance(context);\n+        if (Feature.MODULES.allowedInSource(source)) {\n+            java_base = enterModule(names.java_base);\n+            \/\/avoid completing java.base during the Symtab initialization\n+            java_base.completer = Completer.NULL_COMPLETER;\n+            java_base.visiblePackages = Collections.emptyMap();\n+        } else {\n+            java_base = noModule;\n+        }\n+\n@@ -443,1 +456,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -463,1 +475,0 @@\n-                    ModuleSymbol java_base = enterModule(names.java_base);\n@@ -472,7 +483,0 @@\n-        noModule = new ModuleSymbol(names.empty, null) {\n-            @Override public boolean isNoModule() {\n-                return true;\n-            }\n-        };\n-        addRootPackageFor(noModule);\n-\n@@ -491,2 +495,2 @@\n-        unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);\n-        unknownSymbol.type = unknownType;\n+        \/\/ Create the unknown type\n+        unknownType = new ErrorType(unknownSymbol, Type.noType);\n@@ -542,10 +546,0 @@\n-        Source source = Source.instance(context);\n-        if (Feature.MODULES.allowedInSource(source)) {\n-            java_base = enterModule(names.java_base);\n-            \/\/avoid completing java.base during the Symtab initialization\n-            java_base.completer = Completer.NULL_COMPLETER;\n-            java_base.visiblePackages = Collections.emptyMap();\n-        } else {\n-            java_base = noModule;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1295,1 +1295,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1545,1 +1545,1 @@\n-                if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {\n+                if (t == s || t.qtype == s || s.hasTag(ERROR)) {\n@@ -1751,0 +1751,6 @@\n+            \/* there are three cases for ts and ss:\n+             *   - one is a class and the other one is an interface (case I)\n+             *   - both are classes                                 (case II)\n+             *   - both are interfaces                              (case III)\n+             * all those cases are covered in JLS 23, section: \"5.1.6.1 Allowed Narrowing Reference Conversion\"\n+             *\/\n@@ -1758,23 +1764,24 @@\n-                if (isSubtype(erasure(ts.type), erasure(ss.type))) {\n-                    return false;\n-                }\n-                \/\/ if both are classes or both are interfaces, shortcut\n-                if (ts.isInterface() == ss.isInterface() && isSubtype(erasure(ss.type), erasure(ts.type))) {\n-                    return false;\n-                }\n-                if (ts.isInterface() && !ss.isInterface()) {\n-                    \/* so ts is interface but ss is a class\n-                     * an interface is disjoint from a class if the class is disjoint form the interface\n-                     *\/\n-                    return areDisjoint(ss, ts);\n-                }\n-                \/\/ a final class that is not subtype of ss is disjoint\n-                if (!ts.isInterface() && ts.isFinal()) {\n-                    return true;\n-                }\n-                \/\/ if at least one is sealed\n-                if (ts.isSealed() || ss.isSealed()) {\n-                    \/\/ permitted subtypes have to be disjoint with the other symbol\n-                    ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n-                    ClassSymbol other = sealedOne == ts ? ss : ts;\n-                    return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n+\n+                if (ts.isInterface() != ss.isInterface()) { \/\/ case I: one is a class and the other one is an interface\n+                    ClassSymbol isym = ts.isInterface() ? ts : ss; \/\/ isym is the interface and csym the class\n+                    ClassSymbol csym = isym == ts ? ss : ts;\n+                    if (!isSubtype(erasure(csym.type), erasure(isym.type))) {\n+                        if (csym.isFinal()) {\n+                            return true;\n+                        } else if (csym.isSealed()) {\n+                            return areDisjoint(isym, csym.getPermittedSubclasses());\n+                        } else if (isym.isSealed()) {\n+                            \/\/ if the class is not final and not sealed then it has to be freely extensible\n+                            return areDisjoint(csym, isym.getPermittedSubclasses());\n+                        }\n+                    } \/\/ now both are classes or both are interfaces\n+                } else if (!ts.isInterface()) {              \/\/ case II: both are classes\n+                    return !isSubtype(erasure(ss.type), erasure(ts.type)) && !isSubtype(erasure(ts.type), erasure(ss.type));\n+                } else {                                     \/\/ case III: both are interfaces\n+                    if (!isSubtype(erasure(ts.type), erasure(ss.type)) && !isSubtype(erasure(ss.type), erasure(ts.type))) {\n+                        if (ts.isSealed()) {\n+                            return areDisjoint(ss, ts.getPermittedSubclasses());\n+                        } else if (ss.isSealed()) {\n+                            return areDisjoint(ts, ss.getPermittedSubclasses());\n+                        }\n+                    }\n@@ -1782,0 +1789,1 @@\n+                \/\/ at this point we haven't been able to statically prove that the classes or interfaces are disjoint\n@@ -1784,0 +1792,4 @@\n+\n+            boolean areDisjoint(ClassSymbol csym, List<Type> permittedSubtypes) {\n+                return permittedSubtypes.stream().allMatch(psubtype -> areDisjoint(csym, (ClassSymbol) psubtype.tsym));\n+            }\n@@ -2501,1 +2513,1 @@\n-                             NONE, ERROR, UNKNOWN, UNDETVAR, UNINITIALIZED_THIS,\n+                             NONE, ERROR, UNDETVAR, UNINITIALIZED_THIS,\n@@ -3407,0 +3419,4 @@\n+    \/* this class won't substitute all types for example UndetVars are never substituted, this is\n+     * by design as UndetVars are used locally during inference and shouldn't escape from inference routines,\n+     * some specialized applications could need a tailored solution\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":42,"deletions":26,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2612,2 +2612,1 @@\n-                        rs.resolveImplicitThis(tree.meth.pos(),\n-                                               localEnv, site, true);\n+                        checkNewInnerClass(tree.meth.pos(), localEnv, site, true);\n@@ -2820,3 +2819,1 @@\n-        } else if (!clazztype.tsym.isInterface() &&\n-                   (clazztype.tsym.flags_field & NOOUTERTHIS) == 0 &&\n-                   clazztype.getEnclosingType().hasTag(CLASS)) {\n+        } else {\n@@ -2824,1 +2821,1 @@\n-            rs.resolveImplicitThis(tree.pos(), env, clazztype);\n+            checkNewInnerClass(tree.pos(), env, clazztype, false);\n@@ -3089,0 +3086,18 @@\n+        void checkNewInnerClass(DiagnosticPosition pos, Env<AttrContext> env, Type type, boolean isSuper) {\n+            boolean isLocal = type.tsym.owner.kind == MTH;\n+            if ((type.tsym.flags() & (INTERFACE | ENUM | RECORD)) != 0 ||\n+                    (!isLocal && !type.tsym.isInner()) ||\n+                    (isSuper && env.enclClass.sym.isAnonymous())) {\n+                \/\/ nothing to check\n+                return;\n+            }\n+            Symbol res = isLocal ?\n+                    rs.findLocalClassOwner(env, type.tsym) :\n+                    rs.findSelfContaining(pos, env, type.getEnclosingType().tsym, isSuper);\n+            if (res.exists()) {\n+                rs.accessBase(res, pos, env.enclClass.sym.type, names._this, true);\n+            } else {\n+                log.error(pos, Errors.EnclClassRequired(type.tsym));\n+            }\n+        }\n+\n@@ -3762,1 +3777,0 @@\n-                    case MISSING_ENCL:\n@@ -3813,5 +3827,1 @@\n-                Type enclosingType = exprType.getEnclosingType();\n-                if (enclosingType != null && enclosingType.hasTag(CLASS)) {\n-                    \/\/ Check for the existence of an appropriate outer instance\n-                    rs.resolveImplicitThis(that.pos(), env, exprType);\n-                }\n+                checkNewInnerClass(that.pos(), env, exprType, false);\n@@ -4311,0 +4321,1 @@\n+        chk.validate(tree.var.vartype, env, true);\n@@ -4320,1 +4331,0 @@\n-        chk.validate(tree.var.vartype, env, true);\n@@ -4841,1 +4851,1 @@\n-                chk.checkPreview(tree.pos(), env.info.scope.owner, sym);\n+                chk.checkPreview(tree.pos(), env.info.scope.owner, site, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-                this.hashCode = hashCode = TreeHasher.hash(tree, symbol.params());\n+                this.hashCode = hashCode = TreeHasher.hash(types, tree, symbol.params());\n@@ -232,1 +232,1 @@\n-                    && new TreeDiffer(symbol.params(), dedupedLambda.symbol.params()).scan(tree, dedupedLambda.tree);\n+                    && new TreeDiffer(types, symbol.params(), dedupedLambda.symbol.params()).scan(tree, dedupedLambda.tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+    private final boolean allowPrivateMembersInPermitsClause;\n@@ -150,0 +151,1 @@\n+        allowPrivateMembersInPermitsClause = Feature.PRIVATE_MEMBERS_IN_PERMITS_CLAUSE.allowedInSource(source);\n@@ -428,1 +430,3 @@\n-                 sym.owner.outermostClass())\n+                 sym.owner.outermostClass()\n+                 ||\n+                 privateMemberInPermitsClauseIfAllowed(env, sym))\n@@ -461,0 +465,7 @@\n+\n+    private boolean privateMemberInPermitsClauseIfAllowed(Env<AttrContext> env, Symbol sym) {\n+        return allowPrivateMembersInPermitsClause &&\n+            env.info.isPermitsClause &&\n+            ((JCClassDecl) env.tree).sym.outermostClass() == sym.owner.outermostClass();\n+    }\n+\n@@ -1856,0 +1867,4 @@\n+        if (bestSoFar.kind == AMBIGUOUS) {\n+            AmbiguityError a_err = (AmbiguityError)bestSoFar.baseSymbol();\n+            bestSoFar = a_err.mergeAbstracts(site);\n+        }\n@@ -2137,4 +2152,2 @@\n-    private final RecoveryLoadClass starImportScopeRecovery = (env, name) -> {\n-        Scope importScope = env.toplevel.starImportScope;\n-        Symbol existing = importScope.findFirst(Convert.shortName(name),\n-                                                sym -> sym.kind == TYP && sym.flatName() == name);\n+    private final RecoveryLoadClass starImportScopeRecovery =\n+            onDemandImportScopeRecovery(false);\n@@ -2142,3 +2155,2 @@\n-        if (existing != null) {\n-            try {\n-                existing = finder.loadClass(existing.packge().modle, name);\n+    private final RecoveryLoadClass moduleImportScopeRecovery =\n+            onDemandImportScopeRecovery(true);\n@@ -2146,3 +2158,15 @@\n-                return new InvisibleSymbolError(env, true, existing);\n-            } catch (CompletionFailure cf) {\n-                \/\/ignore\n+    private RecoveryLoadClass onDemandImportScopeRecovery(boolean moduleImportScope) {\n+        return (env, name) -> {\n+            Scope importScope = moduleImportScope ? env.toplevel.moduleImportScope\n+                                                  : env.toplevel.starImportScope;\n+            Symbol existing = importScope.findFirst(Convert.shortName(name),\n+                                                    sym -> sym.kind == TYP && sym.flatName() == name);\n+\n+            if (existing != null) {\n+                try {\n+                    existing = finder.loadClass(existing.packge().modle, name);\n+\n+                    return new InvisibleSymbolError(env, true, existing);\n+                } catch (CompletionFailure cf) {\n+                    \/\/ignore\n+                }\n@@ -2150,3 +2174,3 @@\n-        }\n-        return null;\n-    };\n+            return null;\n+        };\n+    }\n@@ -2421,0 +2445,5 @@\n+\n+            sym = findGlobalType(env, env.toplevel.moduleImportScope, name, moduleImportScopeRecovery);\n+            if (sym.exists()) return sym;\n+\n+            else bestSoFar = bestOf(bestSoFar, sym);\n@@ -2760,1 +2789,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2792,1 +2821,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2916,1 +2945,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2975,1 +3004,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -3506,12 +3535,0 @@\n-        @Override\n-        final Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n-            Symbol sym = doLookup(env, phase);\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n-            return sym;\n-        }\n-\n-        abstract Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase);\n-\n@@ -3564,4 +3581,0 @@\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n@@ -3734,1 +3747,1 @@\n-            Symbol sym = needsInference ?\n+            return needsInference ?\n@@ -3738,1 +3751,0 @@\n-            return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;\n@@ -3783,0 +3795,57 @@\n+    \/**\n+     * Find a \"valid\" reference to an enclosing 'A.this' such that A is a subclass of the provided class symbol.\n+     * A reference to an enclosing 'A.this' is \"valid\" if (a) we're not in the early-construction context for A\n+     * and (b) if the current class is not an inner class of A.\n+     *\/\n+    Symbol findSelfContaining(DiagnosticPosition pos,\n+                    Env<AttrContext> env,\n+                    TypeSymbol c,\n+                    boolean isSuper) {\n+        Env<AttrContext> env1 = isSuper ? env.outer : env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (isStatic(env1)) staticOnly = true;\n+            if (env1.enclClass.sym.isSubClass(c, types)) {\n+                Symbol sym = env1.info.scope.findFirst(names._this);\n+                if (sym != null) {\n+                    if (staticOnly) {\n+                        \/\/ current class is not an inner class, stop search\n+                        return new StaticError(sym);\n+                    } else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym)) {\n+                        \/\/ early construction context, stop search\n+                        return new RefBeforeCtorCalledError(sym);\n+                    } else {\n+                        \/\/ found it\n+                        return sym;\n+                    }\n+                }\n+            }\n+            if ((env1.enclClass.sym.flags() & STATIC) != 0) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return varNotFound;\n+    }\n+\n+    \/**\n+     * Resolve the (method) owner of a local class. This can fail if the local class\n+     * is referenced from a static context nested inside the local class. Effectively,\n+     * this lookup succeeds if we can access a local variable declared inside the owner\n+     * method from the provided env.\n+     *\/\n+    Symbol findLocalClassOwner(Env<AttrContext> env, TypeSymbol c) {\n+        Symbol owner = c.owner;\n+        Assert.check(owner.kind == MTH);\n+        Env<AttrContext> env1 = env;\n+        boolean staticOnly = false;\n+        while (env1.outer != null) {\n+            if (env1.info.scope.owner == owner) {\n+                return (staticOnly) ?\n+                    new BadLocalClassCreation(c) :\n+                    owner;\n+            }\n+            if (isStatic(env1)) staticOnly = true;\n+            env1 = env1.outer;\n+        }\n+        return methodNotFound;\n+    }\n+\n@@ -3807,1 +3876,1 @@\n-                                  name, true);\n+                            name, true);\n@@ -3814,2 +3883,2 @@\n-            name == names._super && !isStatic(env) &&\n-            types.isDirectSuperInterface(c, env.enclClass.sym)) {\n+                name == names._super && !isStatic(env) &&\n+                types.isDirectSuperInterface(c, env.enclClass.sym)) {\n@@ -3830,2 +3899,2 @@\n-                              Errors.IllegalDefaultSuperCall(c,\n-                                                             Fragments.RedundantSupertype(c, i)));\n+                            Errors.IllegalDefaultSuperCall(c,\n+                                    Fragments.RedundantSupertype(c, i)));\n@@ -3938,70 +4007,0 @@\n-    \/**\n-     * Resolve `c.this' for an enclosing class c that contains the\n-     * named member.\n-     * @param pos           The position to use for error reporting.\n-     * @param env           The environment current at the expression.\n-     * @param member        The member that must be contained in the result.\n-     *\/\n-    Symbol resolveSelfContaining(DiagnosticPosition pos,\n-                                 Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);\n-        if (sym == null) {\n-            log.error(pos, Errors.EnclClassRequired(member));\n-            return syms.errSymbol;\n-        } else {\n-            return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);\n-        }\n-    }\n-\n-    boolean enclosingInstanceMissing(Env<AttrContext> env, Type type) {\n-        if (type.hasTag(CLASS) && type.getEnclosingType().hasTag(CLASS)) {\n-            Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);\n-            return encl == null || encl.kind.isResolutionError();\n-        }\n-        return false;\n-    }\n-\n-    private Symbol resolveSelfContainingInternal(Env<AttrContext> env,\n-                                 Symbol member,\n-                                 boolean isSuperCall) {\n-        Name name = names._this;\n-        Env<AttrContext> env1 = isSuperCall ? env.outer : env;\n-        boolean staticOnly = false;\n-        if (env1 != null) {\n-            while (env1 != null && env1.outer != null) {\n-                if (isStatic(env1)) staticOnly = true;\n-                if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {\n-                    Symbol sym = env1.info.scope.findFirst(name);\n-                    if (sym != null) {\n-                        if (staticOnly) sym = new StaticError(sym);\n-                        return sym;\n-                    }\n-                }\n-                if ((env1.enclClass.sym.flags() & STATIC) != 0)\n-                    staticOnly = true;\n-                env1 = env1.outer;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Resolve an appropriate implicit this instance for t's container.\n-     * JLS 8.8.5.1 and 15.9.2\n-     *\/\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t) {\n-        return resolveImplicitThis(pos, env, t, false);\n-    }\n-\n-    Type resolveImplicitThis(DiagnosticPosition pos, Env<AttrContext> env, Type t, boolean isSuperCall) {\n-        Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)\n-                         ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)\n-                         : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;\n-        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n-        }\n-        return thisType;\n-    }\n-\n@@ -4731,0 +4730,22 @@\n+    \/**\n+     * Specialization of {@link StaticError} for illegal\n+     * creation of local class instances from a static context.\n+     *\/\n+    class BadLocalClassCreation extends StaticError {\n+        BadLocalClassCreation(Symbol sym) {\n+            super(sym, \"bad local class creation\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                                   DiagnosticPosition pos,\n+                                   Symbol location,\n+                                   Type site,\n+                                   Name name,\n+                                   List<Type> argtypes,\n+                                   List<Type> typeargtypes) {\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"local.cant.be.inst.static\", kindName(sym), sym);\n+        }\n+    }\n+\n@@ -4890,17 +4911,0 @@\n-    \/**\n-     * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,\n-     * but pointing to a class for which an enclosing instance is not available.\n-     *\/\n-    class BadConstructorReferenceError extends InvalidSymbolError {\n-\n-        public BadConstructorReferenceError(Symbol sym) {\n-            super(MISSING_ENCL, sym, \"BadConstructorReferenceError\");\n-        }\n-\n-        @Override\n-        JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {\n-           return diags.create(dkind, log.currentSource(), pos,\n-                \"cant.access.inner.cls.constr\", site.tsym.name, argtypes, site.getEnclosingType());\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":132,"deletions":128,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -817,2 +817,1 @@\n-        Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;\n-        tree.selector = translate(tree.selector, target);\n+        tree.selector = translate(tree.selector, erasure(tree.selector.type));\n@@ -856,2 +855,1 @@\n-        Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;\n-        tree.selector = translate(tree.selector, target);\n+        tree.selector = translate(tree.selector, erasure(tree.selector.type));\n@@ -1071,1 +1069,7 @@\n-        tree.expr = translate(tree.expr, null);\n+        if (tree.pattern.type.isPrimitive()) {\n+            tree.erasedExprOriginalType = erasure(tree.expr.type);\n+            tree.expr = translate(tree.expr, null);\n+        }\n+        else {\n+            tree.expr = translate(tree.expr, null);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCInstanceOf;\n@@ -1565,0 +1566,7 @@\n+            public void visitTypeTest(JCInstanceOf tree) {\n+                if (tree.pattern.type.isPrimitive()) {\n+                    hasPatterns = true;\n+                }\n+                super.visitTypeTest(tree);\n+            }\n+            @Override\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.nio.file.Path;\n@@ -65,1 +62,0 @@\n-import com.sun.tools.javac.file.JavacFileManager;\n@@ -170,1 +166,0 @@\n-    private SecurityException processorLoaderException;\n@@ -272,12 +267,11 @@\n-        try {\n-            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                try {\n-                    serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n-                } catch (IOException e) {\n-                    throw new Abort(e);\n-                }\n-            } else {\n-                \/\/ If processorpath is not explicitly set, use the classpath.\n-                processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                    ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n-                    : fileManager.getClassLoader(CLASS_PATH);\n+        if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+            try {\n+                serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);\n+            } catch (IOException e) {\n+                throw new Abort(e);\n+            }\n+        } else {\n+            \/\/ If processorpath is not explicitly set, use the classpath.\n+            processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n+                ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)\n+                : fileManager.getClassLoader(CLASS_PATH);\n@@ -285,2 +279,2 @@\n-                if (options.isSet(\"accessInternalAPI\"))\n-                    ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n+            if (options.isSet(\"accessInternalAPI\"))\n+                ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());\n@@ -288,3 +282,2 @@\n-                if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n-                    compiler.closeables = compiler.closeables.prepend(closeable);\n-                }\n+            if (processorClassLoader != null && processorClassLoader instanceof Closeable closeable) {\n+                compiler.closeables = compiler.closeables.prepend(closeable);\n@@ -292,2 +285,0 @@\n-        } catch (SecurityException e) {\n-            processorLoaderException = e;\n@@ -309,20 +300,16 @@\n-            if (processorLoaderException == null) {\n-                \/*\n-                 * If the \"-processor\" option is used, search the appropriate\n-                 * path for the named class.  Otherwise, use a service\n-                 * provider mechanism to create the processor iterator.\n-                 *\n-                 * Note: if an explicit processor path is not set,\n-                 * only the class path and _not_ the module path are\n-                 * searched for processors.\n-                 *\/\n-                String processorNames = options.get(Option.PROCESSOR);\n-                if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n-                    processorIterator = (processorNames == null) ?\n-                            new ServiceIterator(serviceLoader, log) :\n-                            new NameServiceIterator(serviceLoader, log, processorNames);\n-                } else if (processorNames != null) {\n-                    processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n-                } else {\n-                    processorIterator = new ServiceIterator(processorClassLoader, log);\n-                }\n+            \/*\n+             * If the \"-processor\" option is used, search the appropriate\n+             * path for the named class.  Otherwise, use a service\n+             * provider mechanism to create the processor iterator.\n+             *\n+             * Note: if an explicit processor path is not set,\n+             * only the class path and _not_ the module path are\n+             * searched for processors.\n+             *\/\n+            String processorNames = options.get(Option.PROCESSOR);\n+            if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {\n+                processorIterator = (processorNames == null) ?\n+                        new ServiceIterator(serviceLoader, log) :\n+                        new NameServiceIterator(serviceLoader, log, processorNames);\n+            } else if (processorNames != null) {\n+                processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);\n@@ -330,8 +317,1 @@\n-                \/*\n-                 * A security exception will occur if we can't create a classloader.\n-                 * Ignore the exception if, with hindsight, we didn't need it anyway\n-                 * (i.e. no processor was specified either explicitly, or implicitly,\n-                 * in service configuration file.) Otherwise, we cannot continue.\n-                 *\/\n-                processorIterator = handleServiceLoaderUnavailability(\"proc.cant.create.loader\",\n-                        processorLoaderException);\n+                processorIterator = new ServiceIterator(processorClassLoader, log);\n@@ -367,41 +347,0 @@\n-    \/**\n-     * Returns an empty processor iterator if no processors are on the\n-     * relevant path, otherwise if processors are present, logs an\n-     * error.  Called when a service loader is unavailable for some\n-     * reason, either because a service loader class cannot be found\n-     * or because a security policy prevents class loaders from being\n-     * created.\n-     *\n-     * @param key The resource key to use to log an error message\n-     * @param e   If non-null, pass this exception to Abort\n-     *\/\n-    private Iterator<Processor> handleServiceLoaderUnavailability(String key, Exception e) {\n-        if (fileManager instanceof JavacFileManager standardFileManager) {\n-            Iterable<? extends Path> workingPath = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)\n-                ? standardFileManager.getLocationAsPaths(ANNOTATION_PROCESSOR_PATH)\n-                : standardFileManager.getLocationAsPaths(CLASS_PATH);\n-\n-            if (needClassLoader(options.get(Option.PROCESSOR), workingPath) )\n-                handleException(key, e);\n-\n-        } else {\n-            handleException(key, e);\n-        }\n-\n-        return Collections.emptyIterator();\n-    }\n-\n-    \/**\n-     * Handle a security exception thrown during initializing the\n-     * Processor iterator.\n-     *\/\n-    private void handleException(String key, Exception e) {\n-        if (e != null) {\n-            log.error(key, e.getLocalizedMessage());\n-            throw new Abort(e);\n-        } else {\n-            log.error(key);\n-            throw new Abort();\n-        }\n-    }\n-\n@@ -421,7 +360,2 @@\n-                try {\n-                    loader = ServiceLoader.load(Processor.class, classLoader);\n-                    this.iterator = loader.iterator();\n-                } catch (Exception e) {\n-                    \/\/ Fail softly if a loader is not actually needed.\n-                    this.iterator = handleServiceLoaderUnavailability(\"proc.no.service\", null);\n-                }\n+                loader = ServiceLoader.load(Processor.class, classLoader);\n+                this.iterator = loader.iterator();\n@@ -1552,26 +1486,0 @@\n-    \/*\n-     * Called retroactively to determine if a class loader was required,\n-     * after we have failed to create one.\n-     *\/\n-    private boolean needClassLoader(String procNames, Iterable<? extends Path> workingpath) {\n-        if (procNames != null)\n-            return true;\n-\n-        URL[] urls = new URL[1];\n-        for(Path pathElement : workingpath) {\n-            try {\n-                urls[0] = pathElement.toUri().toURL();\n-                if (ServiceProxy.hasService(Processor.class, urls))\n-                    return true;\n-            } catch (MalformedURLException ex) {\n-                throw new AssertionError(ex);\n-            }\n-            catch (ServiceProxy.ServiceConfigurationError e) {\n-                log.error(Errors.ProcBadConfigFile(e.getLocalizedMessage()));\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":35,"deletions":127,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -890,0 +890,4 @@\n+# 0: symbol\n+compiler.err.annotation.array.too.large=\\\n+    Annotation array element too large in \\\"{0}\\\"\n+\n@@ -920,4 +924,0 @@\n-# 0: name\n-compiler.err.modifier.not.allowed.here=\\\n-    modifier {0} not allowed here\n-\n@@ -1098,5 +1098,0 @@\n-# 0: symbol, 1: list of type, 2: type\n-compiler.misc.cant.access.inner.cls.constr=\\\n-    cannot access constructor {0}({1})\\n\\\n-    an enclosing instance of type {2} is not in scope\n-\n@@ -1187,3 +1182,0 @@\n-compiler.err.proc.no.service=\\\n-    A ServiceLoader was not usable and is required for annotation processing.\n-\n@@ -2246,0 +2238,1 @@\n+\n@@ -2893,0 +2886,5 @@\n+## The first argument ({0}) is a \"kindname\".\n+# 0: symbol kind, 1: symbol\n+compiler.err.local.cant.be.inst.static=\\\n+    local {0} {1} cannot be instantiated from a static context\n+\n@@ -3258,0 +3256,3 @@\n+compiler.misc.feature.java.base.transitive=\\\n+    transitive modifier for java.base\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+        \/** A scope for all single module imports. *\/\n+        public StarImportScope moduleImportScope;\n@@ -2285,0 +2287,2 @@\n+        public Type erasedExprOriginalType;\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,2 @@\n-    :jdk_jpackage\n+    :jdk_jpackage \\\n+    :jdk_since_checks\n@@ -384,1 +385,2 @@\n-    -java\/foreign\/TestMatrix.java\n+    -java\/foreign\/TestMatrix.java \\\n+    -java\/foreign\/TestUpcallStress.java\n@@ -424,2 +426,1 @@\n-    javax\/accessibility \\\n-    com\/sun\/java\/accessibility\n+    javax\/accessibility\n@@ -631,2 +632,0 @@\n-    sun\/security\/provider\/PolicyFile\/GrantAllPermToExtWhenNoPolicy.java \\\n-    sun\/security\/provider\/PolicyParser\/PrincipalExpansionError.java \\\n@@ -655,1 +654,0 @@\n-    java\/security\/Policy\/Root\/Root.java \\\n@@ -669,0 +667,4 @@\n+# Set of tests for `@since` checks in source code documentation\n+jdk_since_checks = \\\n+   tools\/sincechecker\/\n+\n","filename":"test\/jdk\/TEST.groups","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n@@ -32,0 +31,1 @@\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -38,1 +38,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code java.base\/jdk.internal.classfile.components\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBranchCompactor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n@@ -46,0 +45,1 @@\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -56,1 +56,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code java.base\/jdk.internal.classfile.components\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestBytecode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.classfile.components.ClassPrinter;\n@@ -38,0 +37,1 @@\n+import jdk.internal.classfile.components.ClassPrinter;\n@@ -52,1 +52,1 @@\n- * @modules jdk.incubator.code\n+ * @modules jdk.incubator.code java.base\/jdk.internal.classfile.components\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/bytecode\/TestSmallCorpus.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+compiler.err.annotation.array.too.large                 # Code\n@@ -36,1 +37,0 @@\n-compiler.err.proc.no.service                            # JavacProcessingEnvironment: no service loader available\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}