{"files":[{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import hat.buffer.Buffer;\n+import hat.buffer.CompleteBuffer;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+public interface Cascade extends CompleteBuffer {\n+    interface Feature extends Buffer.StructChild{\n+\n+        interface Rect extends Buffer.StructChild {\n+            StructLayout layout = MemoryLayout.structLayout(\n+                    JAVA_BYTE.withName(\"x\"),\n+                    JAVA_BYTE.withName(\"y\"),\n+                    JAVA_BYTE.withName(\"width\"),\n+                    JAVA_BYTE.withName(\"height\"),\n+                    JAVA_FLOAT.withName(\"weight\")\n+            ).withName(\"Rect\");\n+            Schema schema = Schema.of(Rect.class,rect->rect\n+                    .primitive(\"x\")\n+                    .primitive( \"y\")\n+                    .primitive(\"width\")\n+                    .primitive(\"height\")\n+                    .primitive(\"weight\")\n+            );\n+\n+            byte x();\n+\n+            byte y();\n+\n+            byte width();\n+\n+            byte height();\n+\n+            float weight();\n+\n+            void x(byte x);\n+\n+            void y(byte y);\n+\n+            void width(byte width);\n+\n+            void height(byte height);\n+\n+            void weight(float height);\n+        }\n+\n+\n+        interface LinkOrValue extends Buffer.StructChild {\n+            interface Anon extends Buffer.UnionChild  {\n+                MemoryLayout layout = MemoryLayout.unionLayout(\n+                        JAVA_INT.withName(\"featureId\"),\n+                        JAVA_FLOAT.withName(\"value\")\n+                ).withName(\"Anon\");\n+                Schema schema = Schema.of(Anon.class,anon-> anon\n+                        .primitive(\"featureId\")\n+                        .primitive( \"value\"));\n+                int featureId();\n+                void featureId(int featureId);\n+                float value();\n+                void value(float value);\n+            }\n+\n+            StructLayout layout = MemoryLayout.structLayout(\n+                    JAVA_BOOLEAN.withName(\"hasValue\"),\n+                    MemoryLayout.paddingLayout(3),\n+                    Anon.layout.withName(\"anon\")\n+            ).withName(\"LinkOrValue\");\n+            Schema schema = Schema.of(LinkOrValue.class,linkOrValue-> linkOrValue\n+                    .primitive(\"hasValue\")\n+                    .primitive( \"anon\")\n+            );\n+            boolean hasValue();\n+            void hasValue(boolean hasValue);\n+            Anon anon();\n+        }\n+\n+        StructLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"id\"),\n+                JAVA_FLOAT.withName(\"threshold\"),\n+                LinkOrValue.layout.withName(\"left\"),\n+                LinkOrValue.layout.withName(\"right\"),\n+                MemoryLayout.sequenceLayout(3, Rect.layout).withName(\"rect\")\n+        ).withName(Feature.class.getSimpleName());\n+        Schema schema = Schema.of(Feature.class,feature->feature\n+                .primitive(\"id\")\n+                .primitive( \"threshold\")\n+                .primitive(\"left\")\n+                .primitive(\"right\")\n+                .array(\"rect\", 3 )\n+        );\n+        int id();\n+\n+\n+        float threshold();\n+\n+\n+        void id(int id);\n+\n+\n+        void threshold(float threshold);\n+\n+        LinkOrValue left();\n+\n+        LinkOrValue right();\n+\n+        Rect rect(long idx);\n+\n+\n+    }\n+\n+    interface Stage extends Buffer.StructChild{\n+        StructLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"id\"),\n+                JAVA_FLOAT.withName(\"threshold\"),\n+                JAVA_SHORT.withName(\"firstTreeId\"),\n+                JAVA_SHORT.withName(\"treeCount\")\n+        ).withName(Stage.class.getSimpleName());\n+\n+        float threshold();\n+\n+        short firstTreeId();\n+\n+        short treeCount();\n+\n+        int id();\n+\n+        void id(int id);\n+\n+        void threshold(float threshold);\n+\n+        void firstTreeId(short firstTreeId);\n+\n+        void treeCount(short treeCount);\n+\n+        Schema schema = Schema.of(Stage.class,b->\n+                b.primitive(\"id\").primitive( \"threshold\").primitive(\"treeCount\").primitive(\"firstTreeId\")\n+        );\n+    }\n+\n+    interface Tree extends Buffer.StructChild{\n+        StructLayout layout = MemoryLayout.structLayout(\n+                JAVA_INT.withName(\"id\"),\n+                JAVA_SHORT.withName(\"firstFeatureId\"),\n+                JAVA_SHORT.withName(\"featureCount\")\n+        ).withName(Tree.class.getSimpleName());\n+\n+        void id(int id);\n+\n+        void firstFeatureId(short firstFeatureId);\n+\n+\n+        void featureCount(short featureCount);\n+\n+        int id();\n+\n+\n+        short firstFeatureId();\n+\n+        short featureCount();\n+\n+        Schema schema = Schema.of(Tree.class,b->\n+                b.primitive(\"id\").primitive(\"featureCount\").primitive(\"firstFeatureId\")\n+        );\n+    }\n+\/*\n+    static Cascade create(BufferAllocator bufferAllocator, XMLHaarCascadeModel haarCascade) {\n+\n+        Cascade cascade = bufferAllocator.allocate(SegmentMapper.of(MethodHandles.lookup(), Cascade.class,\n+                JAVA_INT.withName(\"width\"),\n+                JAVA_INT.withName(\"height\"),\n+                JAVA_INT.withName(\"featureCount\"),\n+                sequenceLayout(haarCascade.features.size(), Feature.layout.withName(Feature.class.getSimpleName())).withName(\"feature\"),\n+                JAVA_INT.withName(\"stageCount\"),\n+                sequenceLayout(haarCascade.stages.size(), Stage.layout.withName(Stage.class.getSimpleName())).withName(\"stage\"),\n+                JAVA_INT.withName(\"treeCount\"),\n+                sequenceLayout(haarCascade.trees.size(), Tree.layout.withName(Tree.class.getSimpleName())).withName(\"tree\")\n+        ));\n+        cascade.width(haarCascade.width());\n+        cascade.height(haarCascade.height());\n+        cascade.featureCount(haarCascade.features.size());\n+        cascade.stageCount(haarCascade.stages.size());\n+        cascade.treeCount(haarCascade.trees.size());\n+        for (int idx = 0; idx < haarCascade.features.size(); idx++) {\n+            Feature cascadeFeature = cascade.feature(idx);\n+            var haarfeature = haarCascade.features.get(idx);\n+            cascadeFeature.id(haarfeature.id());\n+            cascadeFeature.threshold(haarfeature.threshold());\n+            Feature.LinkOrValue cascadeLeft = cascadeFeature.left();\n+            cascadeLeft.hasValue(haarfeature.left.hasValue());\n+            if (haarfeature.left.hasValue()) {\n+                cascadeLeft.anon().value(haarfeature.left.value());\n+            } else {\n+                cascadeLeft.anon().value(haarfeature.left.featureId());\n+            }\n+            Feature.LinkOrValue cascadeRight = cascadeFeature.right();\n+            cascadeRight.hasValue(haarfeature.right.hasValue());\n+            if (haarfeature.right.hasValue()) {\n+                cascadeRight.anon().value(haarfeature.right.value());\n+            } else {\n+                cascadeRight.anon().featureId(haarfeature.right.featureId());\n+            }\n+            for (int r = 0; r < 3; r++) {\n+                var haarrect = haarfeature.rects[r];\n+                if (haarrect != null) {\n+                    Feature.Rect cascadeRect = cascadeFeature.rect(r);\n+                    cascadeRect.x(haarrect.x());\n+                    cascadeRect.y(haarrect.y());\n+                    cascadeRect.width(haarrect.width());\n+                    cascadeRect.height(haarrect.height());\n+                    cascadeRect.weight(haarrect.weight());\n+                }\n+            }\n+        }\n+\n+\n+        for (XMLHaarCascadeModel.Stage haarstage : haarCascade.stages) {\n+            Stage cascadeStage = cascade.stage(haarstage.id);\n+            cascadeStage.id(haarstage.id());\n+            cascadeStage.threshold(haarstage.threshold());\n+            cascadeStage.firstTreeId(haarstage.firstTreeId());\n+            cascadeStage.treeCount(haarstage.treeCount());\n+        }\n+\n+        for (XMLHaarCascadeModel.Tree haarTree : haarCascade.trees) {\n+            Tree cascadeTree = cascade.tree(haarTree.id());\n+            cascadeTree.id(haarTree.id());\n+            cascadeTree.firstFeatureId(haarTree.firstFeatureId());\n+            cascadeTree.featureCount(haarTree.featureCount());\n+        }\n+        return cascade;\n+    } *\/\n+Schema schema = Schema.of(Cascade.class,b-> b\n+        .primitive(\"width\")\n+        .primitive(\"height\")\n+        .arrayLen(\"featureCount\").array(\"feature\")\n+        .arrayLen(\"treeCount\").array(\"tree\")\n+        .fieldControlledArray(\"stageCount\", \"stage\")\n+);\n+    Feature feature(long idx);\n+\n+    int featureCount();\n+\n+    void featureCount(int featureCount);\n+\n+    Stage stage(long idx);\n+\n+    int stageCount();\n+\n+    void stageCount(int stageCount);\n+\n+    Tree tree(long idx);\n+\n+    int treeCount();\n+\n+    void treeCount(int treeCount);\n+\n+    int width();\n+\n+    void width(int width);\n+\n+    int height();\n+\n+    void height(int height);\n+\n+  \/*  Schema schema2 = Schema.buffer(Cascade.class,cascade-> cascade\n+            .value(\"width\")\n+            .value(\"height\")\n+            .fieldConstrainedArray(\"feature\", a->a.lenField(\"featureCount\"), featureArray-> featureArray\n+                    .struct(feature-> feature\n+                            .value(\"id\")\n+                            .value(\"threshold\")\n+                            .struct(\"left\", l->{})\n+                            .struct(\"right\", r->{})\n+                            .fixedArray(\"rect\", 3, rect->rect\n+                                    .struct()\n+                            )\n+                    )\n+            .fieldConstrainedArray(\"tree\",a->a.lenField(\"treeCount\"))\n+            .fieldConstrainedArray(\"stage\", a->a.lenField(\"stageCount\"))\n+    ); *\/\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Cascade.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024 Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package experiments;\n+\n+\n+public class CascadeSchemaLayoutTest {\n+\n+    public static void main(String[] args) {\n+\n+        Cascade.schema.field.toText(0, t->System.out.print(t));\n+\n+        \/\/var layout = Cascade.schema.field.layout();\n+\n+   \/\/     System.out.println(layout);\n+    }\n+}\n+\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/CascadeSchemaLayoutTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -51,91 +51,0 @@\n-    public static class Schema {\n-        private static final Map<Class<?>, MemoryLayout> typeToLayout = new HashMap<>();\n-\n-        static {\n-            typeToLayout.put(Integer.TYPE, ValueLayout.JAVA_INT);\n-            typeToLayout.put(Float.TYPE, ValueLayout.JAVA_FLOAT);\n-            typeToLayout.put(Long.TYPE, ValueLayout.JAVA_LONG);\n-            typeToLayout.put(Double.TYPE, ValueLayout.JAVA_DOUBLE);\n-            typeToLayout.put(Character.TYPE, ValueLayout.JAVA_CHAR);\n-            typeToLayout.put(Short.TYPE, ValueLayout.JAVA_SHORT);\n-            typeToLayout.put(Byte.TYPE, ValueLayout.JAVA_BYTE);\n-            typeToLayout.put(Boolean.TYPE, ValueLayout.JAVA_BOOLEAN);\n-        }\n-\n-        private GroupLayout layout;\n-\n-        Schema(GroupLayout layout) {\n-            this.layout = layout;\n-        }\n-\n-        public GroupLayout layout() {\n-            return layout;\n-        }\n-\n-        private static MemoryLayout typeToLayout(Class<?> clazz) {\n-            if (typeToLayout.containsKey(clazz)) {\n-                return typeToLayout.get(clazz);\n-            } else if (clazz.isInterface()) {\n-                if (clazz.isAnnotationPresent(Buffer.Struct.class) || clazz.isAnnotationPresent(Buffer.Union.class)) {\n-                    try {\n-                        if (clazz.getDeclaredField(\"schema\") instanceof Field field) {\n-                            return ((Schema) field.get(null)).layout();\n-                        } else {\n-                            throw new RuntimeException(\"no Schema field found\");\n-                        }\n-                    } catch (NoSuchFieldException e) {\n-                        throw new RuntimeException(e);\n-                    } catch (IllegalAccessException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                } else {\n-                    throw new IllegalStateException(\"no Struct or Union found for \" + clazz);\n-                }\n-            } else {\n-                throw new IllegalStateException(\"wtft\");\n-            }\n-        }\n-\n-        private static Schema _layoutOf(Class bufferClass, String... order) {\n-            List<MemoryLayout> memoryLayouts = new ArrayList<>();\n-            Map<String, Integer> orderMap = new LinkedHashMap<>();\n-            Arrays.stream(order).forEach(s -> orderMap.put(s, orderMap.size())); \/\/ order[0] -> 0, order[1] -> r\n-            Set<String> done = new HashSet<>();\n-            Arrays.stream(bufferClass.getDeclaredMethods())\n-                    .filter(m -> orderMap.containsKey(m.getName()))                        \/\/only methods named in array\n-                    .sorted(Comparator.comparingInt(lhs -> orderMap.get(lhs.getName()))) \/\/ sort by order in the array\n-                    .forEach(m -> {\n-                        String name = m.getName();\n-                        if (!done.contains(name)) {\n-                            MemoryLayout layout = null;\n-                            var rt = m.getReturnType();\n-                            if (rt == Void.TYPE) {\n-                                if (m.getParameterCount() == 1) {\n-                                    layout = typeToLayout(m.getParameterTypes()[0]);\n-                                } else if (m.getParameterCount() == 2) {\n-                                    throw new IllegalStateException(\"never\");\n-                                }\n-                            } else {\n-                                layout = typeToLayout(rt);\n-                            }\n-                            if (layout instanceof ValueLayout) {\n-                                memoryLayouts.add(layout.withName(name));\n-                            } else if (layout instanceof StructLayout) {\n-                                memoryLayouts.add(layout.withName(name + \"::struct\"));\n-                            }\n-                            done.add(name);\n-                        }\n-\n-                    });\n-\n-            return new Schema(MemoryLayout.structLayout(memoryLayouts.toArray(new MemoryLayout[0])).withName(bufferClass.getName()));\n-        }\n-\n-        public static <T extends Buffer> Schema layoutOf(Class<T> clazz, String... order) {\n-            return _layoutOf(clazz, order);\n-        }\n-\n-        public static <T extends Buffer.Child> Schema childLayoutOf(Class<T> clazz, String... order) {\n-            return _layoutOf(clazz, order);\n-        }\n-    }\n@@ -148,10 +57,5 @@\n-     @Buffer.Struct\n-        public interface StructOne extends Buffer {\n-        \/*\n-         struct {\n-             int i;\n-             float f;\n-         }\n-        *\/\n-        @Buffer.Struct\n-            interface StructTwo extends Buffer.StructChild {\n+\n+        public interface Outer extends Buffer {\n+\n+\n+            interface Inner extends Buffer.StructChild  {\n@@ -166,1 +70,1 @@\n-                Schema schema = Schema.childLayoutOf(StructTwo.class, \"i\", \"f\");\n+                Schema schema = Schema.of(Inner.class, b->b.primitive(\"i\").primitive(\"f\"));\n@@ -169,2 +73,2 @@\n-            StructTwo struct();\n-\n+            Inner right();\n+            Inner left();\n@@ -172,1 +76,0 @@\n-\n@@ -175,1 +78,9 @@\n-            Schema schema = Schema.layoutOf(StructOne.class, \"struct\", \"i\");\n+\n+            Schema schema = Schema.of(Outer.class, b->b\n+                            .struct(\"left\", left->left\n+                                    .primitive(\"i\")\n+                                    .primitive(\"f\")\n+                            )\n+                            .struct(\"right\", Inner.schema)\n+                            .primitive(\"i\")\n+            );\n@@ -180,1 +91,1 @@\n-    static float m(StructOne s1) {\n+    static float m(Outer s1) {\n@@ -185,1 +96,1 @@\n-        StructOne.StructTwo s2 = s1.struct();\n+        Outer.Inner s2 = s1.left();\n@@ -195,9 +106,0 @@\n-        CoreOp.FuncOp m = getFuncOp(\"m\");\n-        m = SSA.transform(m);\n-        System.out.println(m.toText());\n-\n-        CoreOp.FuncOp pm = transformInvokesToPtrs(MethodHandles.lookup(), m);\n-        System.out.println(pm.toText());\n-    }\n-\n-    static CoreOp.FuncOp getFuncOp(String name) {\n@@ -205,1 +107,1 @@\n-                .filter(m -> m.getName().equals(name))\n+                .filter(m -> m.getName().equals(\"m\"))\n@@ -208,2 +110,8 @@\n-        Method m = om.get();\n-        return m.getCodeModel().get();\n+        Method m = om.orElseThrow();\n+        CoreOp.FuncOp f= m.getCodeModel().orElseThrow();\n+        f = SSA.transform(f);\n+        System.out.println(f.toText());\n+        FunctionType functionType = transformStructClassToPtr(MethodHandles.lookup(), f);\n+        System.out.println(f.toText());\n+        CoreOp.FuncOp pm = transformInvokesToPtrs(MethodHandles.lookup(), f, functionType);\n+        System.out.println(pm.toText());\n@@ -211,5 +119,1 @@\n-\n-    \/\/\n-\n-\n-    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n+    static FunctionType transformStructClassToPtr(MethodHandles.Lookup l,\n@@ -221,4 +125,10 @@\n-        FunctionType functionType = FunctionType.functionType(\n-                transformStructClassToPtr(l, f.invokableType().returnType()),\n-                pTypes);\n-        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n+        return FunctionType.functionType(\n+                transformStructClassToPtr(l, f.invokableType().returnType()), pTypes);\n+    }\n+\n+    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n+                                                CoreOp.FuncOp f, FunctionType functionType) {\n+\n+        var builder= CoreOp.func(f.funcName(), functionType);\n+\n+        var funcOp = builder.body(funcBlock -> {\n@@ -226,3 +136,4 @@\n-                if (op instanceof CoreOp.InvokeOp iop && iop.hasReceiver()) {\n-                    Value receiver = iop.operands().getFirst();\n-                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n+                if (op instanceof CoreOp.InvokeOp invokeOp\n+                        && invokeOp.hasReceiver()\n+                        && invokeOp.operands().getFirst() instanceof Value receiver) {\n+                    if (bufferOrBufferChildClass(l, receiver.type()) != null) {\n@@ -230,1 +141,1 @@\n-                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n+                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, invokeOp.invokeDescriptor().name());\n@@ -233,1 +144,1 @@\n-                        if (iop.operands().size() == 1) {\n+                        if (invokeOp.operands().size() == 1) {\n@@ -237,1 +148,1 @@\n-                                b.context().mapValue(iop.result(), v);\n+                                b.context().mapValue(invokeOp.result(), v);\n@@ -239,1 +150,1 @@\n-                                b.context().mapValue(iop.result(), memberPtr);\n+                                b.context().mapValue(invokeOp.result(), memberPtr);\n@@ -255,1 +166,2 @@\n-    };\n+        return funcOp;\n+    }\n@@ -258,7 +170,0 @@\n-    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n-        if (structClass(l, type) instanceof Class<?> sc) {\n-            return new PtrType(structClassLayout(l, sc));\n-        } else {\n-            return type;\n-        }\n-    }\n@@ -266,2 +171,9 @@\n-    static MemoryLayout structClassLayout(MethodHandles.Lookup l, Class<?> c) {\n-        if (!c.isAnnotationPresent(Buffer.Struct.class)) {\n+    static boolean isBufferOrBufferChild(Class<?> maybeIface) {\n+        return  maybeIface.isInterface() && (\n+                Buffer.class.isAssignableFrom(maybeIface)\n+                        || Buffer.Child.class.isAssignableFrom(maybeIface)\n+        );\n+\n+    }\n+    static Schema bufferOrBufferChildSchema(MethodHandles.Lookup l, Class<?> maybeBufferOrBufferChild) {\n+        if (isBufferOrBufferChild(maybeBufferOrBufferChild)) {\n@@ -272,2 +184,2 @@\n-            schemaField = c.getField(\"schema\");\n-           return  ((Schema)schemaField.get(null)).layout();\n+            schemaField = maybeBufferOrBufferChild.getField(\"schema\");\n+           return  (Schema)schemaField.get(null);\n@@ -278,2 +190,1 @@\n-\n-    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n+    static Class<?> bufferOrBufferChildClass(MethodHandles.Lookup l, TypeElement t) {\n@@ -281,1 +192,4 @@\n-            return _structClass(l, t);\n+            if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n+                return null;\n+            }\n+            return isBufferOrBufferChild(c) ? c : null;\n@@ -286,3 +200,5 @@\n-    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n-        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n-            return null;\n+    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n+        if (bufferOrBufferChildClass(l, type) instanceof Class<?> sc) {\n+            return new PtrType(bufferOrBufferChildSchema(l, sc));\n+        } else {\n+            return type;\n@@ -290,1 +206,0 @@\n-        return c.isInterface() && c.isAnnotationPresent(hat.buffer.Buffer.Struct.class) ? c : null;\n@@ -293,1 +208,0 @@\n-\n@@ -296,2 +210,3 @@\n-        final MemoryLayout layout;\n-        final JavaType rType;\n+        MemoryLayout layout;\n+        Schema schema;\n+        final JavaType returnType;\n@@ -301,1 +216,11 @@\n-            this.rType = switch (layout) {\n+            this.returnType = switch (layout) {\n+                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n+                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n+                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+            };\n+        }\n+        public PtrType(Schema schema) {\n+            this.schema = schema;\n+            this.layout= null;\/\/schema.layout();\n+            this.returnType = switch (layout) {\n@@ -309,2 +234,2 @@\n-        public JavaType rType() {\n-            return rType;\n+        public JavaType returnType() {\n+            return returnType;\n@@ -316,0 +241,3 @@\n+        public Schema schema() {\n+            return schema;\n+        }\n@@ -332,1 +260,1 @@\n-            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+            return new ExternalizedTypeElement(NAME, List.of(returnType.externalize()));\n@@ -502,1 +430,1 @@\n-            this.resultType = ptrType.rType();\n+            this.resultType = ptrType.returnType();\n@@ -537,1 +465,1 @@\n-            if (!(ptrType.rType().equals(v.type()))) {\n+            if (!(ptrType.returnType().equals(v.type()))) {\n@@ -539,1 +467,1 @@\n-                        + ptrType.rType() + \" \" + v.type());\n+                        + ptrType.returnType() + \" \" + v.type());\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LayoutExample.java","additions":93,"deletions":165,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+package experiments;\n+\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import java.io.File;\n+import java.util.*;\n+import java.util.regex.*;\n+public class PomChecker {\n+\/\/ XML facade to offer modern access to org.w3x.dom artifacts\n+\n+    public static class XMLNode {\n+        org.w3c.dom.Element element;\n+        List<XMLNode> children = new ArrayList<>();\n+        Map<String, String> attrMap =  new HashMap<>();\n+\n+        XMLNode(org.w3c.dom.Element element) {\n+            this.element = element;\n+            this.element.normalize();\n+            for (int i = 0; i < this.element.getChildNodes().getLength(); i++) {\n+                if (this.element.getChildNodes().item(i) instanceof org.w3c.dom.Element e){\n+                    this.children.add(new XMLNode(e));\n+                }\n+            }\n+            for (int i = 0; i < element.getAttributes().getLength(); i++) {\n+                if (element.getAttributes().item(i) instanceof org.w3c.dom.Attr attr){\n+                    this.attrMap.put(attr.getName(),attr.getValue());\n+                }\n+            }\n+        }\n+        public boolean hasAttr(String name) { return attrMap.containsKey(name); }\n+        public String attr(String name) { return attrMap.get(name); }\n+        XMLNode(File file) throws Throwable {\n+           this(javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(file).getDocumentElement());\n+        }\n+        void write(File file) throws Throwable {\n+            var  transformer = TransformerFactory.newInstance().newTransformer();\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n+            transformer.setOutputProperty(\"{http:\/\/xml.apache.org\/xslt}indent-amount\", \"4\");\n+            transformer.transform(new DOMSource(element.getOwnerDocument()), new StreamResult(file));\n+        }\n+    }\n+\n+\n+\n+\n+\n+    static Pattern varPattern=Pattern.compile(\"\\\\$\\\\{([^}]*)\\\\}\");\n+\n+    static String varExpand(Map<String,String> props, String value){ \/\/ recurse\n+        String result = value;\n+        if (varPattern.matcher(value) instanceof Matcher matcher && matcher.find()) {\n+            var v = matcher.group(1);\n+            result = varExpand(props,value.substring(0, matcher.start())\n+                    +(v.startsWith(\"env\")\n+                    ?System.getenv(v.substring(4))\n+                    :props.get(v))\n+                    +value.substring(matcher.end()));\n+            \/\/System.out.println(\"incomming ='\"+value+\"'  v= '\"+v+\"' value='\"+value+\"'->'\"+result+\"'\");\n+        }\n+        return result;\n+    }\n+\n+    public static void main(String[] args) throws Throwable{\n+         var props = new LinkedHashMap<String,String>();\n+\n+        var dir = new File(\"\/Users\/grfrost\/github\/babylon-grfrost-fork\/hat\");\n+\n+        var topPom = new XMLNode(new File(dir,\"pom.xml\"));\n+        topPom.write( new File(dir,\"gramminet.xml\"));\n+        topPom.children.stream()\n+                .filter(e->e.element.getNodeName().equals(\"properties\")).\n+                forEach(properties ->\n+                        properties .children.stream() .forEach(property ->\n+                                props.put(property.element.getNodeName(),varExpand(props,property.element.getTextContent()))\n+                        )\n+                );\n+        \/\/props.forEach((k,v)->System.out.println(k+\"->\"+v));\n+        var spirvDirKey = \"beehive.spirv.toolkit.dir\";\n+        var hatDirKey = \"hat.dir\";\n+        var dirKeys = new String[]{spirvDirKey, hatDirKey};\n+        var requiredDirKeys = new String[]{hatDirKey};\n+        var dirKeyToDirMap = new HashMap<String,File>();\n+        for (var dirKey:dirKeys){\n+            if (props.containsKey(dirKey)){\n+                dirKeyToDirMap.put(dirKey,new File(props.get(dirKey)));\n+            }\n+        }\n+        for (var dirKey:requiredDirKeys){\n+            if (props.containsKey(dirKey)){\n+                if (!dirKeyToDirMap.get(dirKey).exists()){\n+                    System.out.println(\"pom.xml has key'\"+dirKey+\"' but dir does not exists\");\n+                    System.exit(1);\n+                }\n+            }\n+        }\n+\n+        var hatDir = dirKeyToDirMap.get(hatDirKey);\n+        var hereDir = new File(System.getProperty(\"user.dir\"));\n+        if (!hatDir.equals(hereDir)){\n+            System.out.println(\"hat.dir='\"+hatDir+\"' != ${PWD}='\"+hereDir+\"'\");\n+        } else{\n+            System.out.println(\"hat.dir='\"+hatDir+\"' looks good\");\n+            var backendsPom = new XMLNode(new File(dir,\"backends\/pom.xml\"));\n+            var modules = backendsPom.children.stream().filter(e->e.element.getNodeName().equals(\"modules\")).findFirst().get();\n+            var spirvModule = modules.children.stream().filter(e->e.element.getTextContent().equals(\"spirv\")).findFirst();\n+\n+            if (spirvModule.isPresent()){\n+\n+                if (dirKeyToDirMap.containsKey(spirvDirKey)) {\n+                    var spirvDir = dirKeyToDirMap.get(spirvDirKey);\n+                    if (spirvDir.exists()) {\n+                        System.out.println(\"OK \"+spirvDirKey + \" -> '\" + spirvDir + \"' dir exists and module included in backends\");\n+                    } else {\n+                        System.out.println(\"ERR \"+spirvDirKey + \" -> '\" + spirvDir + \"' dir does not exists but module included in backends \");\n+                    }\n+                }else{\n+                    System.out.println(\"ERR \"+spirvDirKey + \" -> variable dir does not exists but module included in backends \");\n+                }\n+            } else{\n+                if (dirKeyToDirMap.containsKey(spirvDirKey)) {\n+                    var spirvDir = dirKeyToDirMap.get(spirvDirKey);\n+                if (spirvDir.exists()){\n+                    System.out.println(\"ERR \"+spirvDirKey+\" -> '\"+spirvDir+\"' dir exists but spirv module not included in backends \");\n+                }else{\n+                    System.out.println(\"WARN \"+spirvDirKey+\" -> '\"+spirvDir+\"' dir does not exist and not included in backends \");\n+                }\n+                }else{\n+                    System.out.println(\"OK \"+ spirvDirKey + \" -> variable dir does not exist and module not included in backends \");\n+                }\n+            }\n+        }\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/PomChecker.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,470 @@\n+package experiments;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.constant.ClassDesc;\n+import java.lang.foreign.*;\n+        import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.code.*;\n+        import java.lang.reflect.code.analysis.SSA;\n+import java.lang.reflect.code.op.CoreOp;\n+import java.lang.reflect.code.op.ExternalizableOp;\n+import java.lang.reflect.code.op.OpFactory;\n+import java.lang.reflect.code.type.FunctionType;\n+import java.lang.reflect.code.type.JavaType;\n+import java.lang.reflect.code.type.PrimitiveType;\n+import java.lang.runtime.CodeReflection;\n+import java.util.*;\n+        import java.util.stream.Stream;\n+\n+public class RawLayout {\n+\n+    \/*\n+    struct {\n+      StructTwo struct;\n+      int i;\n+    }\n+     *\/\n+    @Struct\n+    public interface StructOne {\n+        StructTwo struct();\n+\n+        int i();\n+\n+        void i(int v);\n+\n+        static MemoryLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                        StructTwo.layout().withName(StructTwo.layout().name().orElseThrow() + \"::struct\"),\n+                        ValueLayout.JAVA_INT.withName(\"i\"))\n+                \/\/ Symbolic reference to interface\n+                \/\/ @@@ Use externalized type element form?\n+                .withName(\"layouts.LayoutExample$StructOne\");\n+    }\n+\n+    \/*\n+    struct {\n+      int i;\n+      float f;\n+    }\n+     *\/\n+    @Struct\n+    public interface StructTwo {\n+        int i();\n+\n+        void i(int v);\n+\n+        float f();\n+\n+        void f(float v);\n+\n+        static MemoryLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"i\"),\n+                        ValueLayout.JAVA_FLOAT.withName(\"f\"))\n+                \/\/ Symbolic reference to interface\n+                \/\/ @@@ Use externalized type element form?\n+                .withName(\"layouts.LayoutExample$StructTwo\");\n+    }\n+\n+    @CodeReflection\n+    static float m(StructOne s1) {\n+        \/\/ StructOne* s1\n+        \/\/ s1 -> i\n+        int i = s1.i();\n+        \/\/ s1 -> *s2\n+        StructTwo s2 = s1.struct();\n+        \/\/ s2 -> i\n+        i += s2.i();\n+        \/\/ s2 -> f\n+        float f = s2.f();\n+        return i + f;\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        CoreOp.FuncOp m = getFuncOp(\"m\");\n+        m = SSA.transform(m);\n+        System.out.println(m.toText());\n+\n+        CoreOp.FuncOp pm = transformInvokesToPtrs(MethodHandles.lookup(), m);\n+        System.out.println(pm.toText());\n+    }\n+\n+    static CoreOp.FuncOp getFuncOp(String name) {\n+        Optional<Method> om = Stream.of(LayoutExample.class.getDeclaredMethods())\n+                .filter(m -> m.getName().equals(name))\n+                .findFirst();\n+\n+        Method m = om.get();\n+        return m.getCodeModel().get();\n+    }\n+\n+    \/\/\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    public @interface Struct {\n+    }\n+\n+    static CoreOp.FuncOp transformInvokesToPtrs(MethodHandles.Lookup l,\n+                                                CoreOp.FuncOp f) {\n+        List<TypeElement> pTypes = new ArrayList<>();\n+        for (Block.Parameter p : f.parameters()) {\n+            pTypes.add(transformStructClassToPtr(l, p.type()));\n+        }\n+        FunctionType functionType = FunctionType.functionType(\n+                transformStructClassToPtr(l, f.invokableType().returnType()),\n+                pTypes);\n+        return CoreOp.func(f.funcName(), functionType).body(funcBlock -> {\n+            funcBlock.transformBody(f.body(), funcBlock.parameters(), (b, op) -> {\n+                if (op instanceof CoreOp.InvokeOp iop && iop.hasReceiver()) {\n+                    Value receiver = iop.operands().getFirst();\n+                    if (structClass(l, receiver.type()) instanceof Class<?> _) {\n+                        Value ptr = b.context().getValue(receiver);\n+                        PtrToMember ptrToMemberOp = new PtrToMember(ptr, iop.invokeDescriptor().name());\n+                        Op.Result memberPtr = b.op(ptrToMemberOp);\n+\n+                        if (iop.operands().size() == 1) {\n+                            \/\/ Pointer access and (possibly) value load\n+                            if (ptrToMemberOp.resultType().layout() instanceof ValueLayout) {\n+                                Op.Result v = b.op(new PtrLoadValue(memberPtr));\n+                                b.context().mapValue(iop.result(), v);\n+                            } else {\n+                                b.context().mapValue(iop.result(), memberPtr);\n+                            }\n+                        } else {\n+                            \/\/ @@@\n+                            \/\/ Value store\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    } else {\n+                        b.op(op);\n+                    }\n+                } else {\n+                    b.op(op);\n+                }\n+                return b;\n+            });\n+        });\n+    };\n+\n+\n+    static TypeElement transformStructClassToPtr(MethodHandles.Lookup l, TypeElement type) {\n+        if (structClass(l, type) instanceof Class<?> sc) {\n+            return new PtrType(structClassLayout(l, sc));\n+        } else {\n+            return type;\n+        }\n+    }\n+\n+    static MemoryLayout structClassLayout(MethodHandles.Lookup l,\n+                                          Class<?> c) {\n+        if (!c.isAnnotationPresent(Struct.class)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        Method layoutMethod;\n+        try {\n+            layoutMethod = c.getMethod(\"layout\");\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+        MethodHandle layoutHandle;\n+        try {\n+            layoutHandle = l.unreflect(layoutMethod);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+        try {\n+            return (MemoryLayout) layoutHandle.invoke();\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static Class<?> structClass(MethodHandles.Lookup l, TypeElement t) {\n+        try {\n+            return _structClass(l, t);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    static Class<?> _structClass(MethodHandles.Lookup l, TypeElement t) throws ReflectiveOperationException {\n+        if (!(t instanceof JavaType jt) || !(jt.resolve(l) instanceof Class<?> c)) {\n+            return null;\n+        }\n+\n+        return c.isInterface() && c.isAnnotationPresent(Struct.class) ? c : null;\n+    }\n+\n+\n+    public static final class PtrType implements TypeElement {\n+        static final String NAME = \"ptr\";\n+        final MemoryLayout layout;\n+        final JavaType rType;\n+\n+        public PtrType(MemoryLayout layout) {\n+            this.layout = layout;\n+            this.rType = switch (layout) {\n+                case StructLayout _ -> JavaType.type(ClassDesc.of(layout.name().orElseThrow()));\n+                case AddressLayout _ -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+                case ValueLayout valueLayout -> JavaType.type(valueLayout.carrier());\n+                default -> throw new UnsupportedOperationException(\"Unsupported member layout: \" + layout);\n+            };\n+        }\n+\n+        public JavaType rType() {\n+            return rType;\n+        }\n+\n+        public MemoryLayout layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PtrType ptrType = (PtrType) o;\n+            return Objects.equals(layout, ptrType.layout);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(layout);\n+        }\n+\n+        @Override\n+        public ExternalizedTypeElement externalize() {\n+            return new ExternalizedTypeElement(NAME, List.of(rType.externalize()));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return externalize().toString();\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrToMember extends ExternalizableOp {\n+        public static final String NAME = \"ptr.to.member\";\n+        public static final String ATTRIBUTE_OFFSET = \"offset\";\n+        public static final String ATTRIBUTE_NAME = \"name\";\n+\n+        final String simpleMemberName;\n+        final long memberOffset;\n+        final PtrType resultType;\n+\n+        PtrToMember(PtrToMember that, CopyContext cc) {\n+            super(that, cc);\n+            this.simpleMemberName = that.simpleMemberName;\n+            this.memberOffset = that.memberOffset;\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public PtrToMember transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrToMember(this, cc);\n+        }\n+\n+        public PtrToMember(Value ptr, String simpleMemberName) {\n+            super(NAME, List.of(ptr));\n+            this.simpleMemberName = simpleMemberName;\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            \/\/ @@@ Support group layout\n+            if (!(ptrType.layout() instanceof StructLayout structLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a struct layout: \" + ptrType.layout());\n+            }\n+\n+            \/\/ Find the actual member name from the simple member name\n+            String memberName = findMemberName(structLayout, simpleMemberName);\n+            MemoryLayout.PathElement p = MemoryLayout.PathElement.groupElement(memberName);\n+            this.memberOffset = structLayout.byteOffset(p);\n+            MemoryLayout memberLayout = structLayout.select(p);\n+            \/\/ Remove any simple member name from the layout\n+            MemoryLayout ptrLayout = memberLayout instanceof StructLayout\n+                    ? memberLayout.withName(className(memberName))\n+                    : memberLayout.withoutName();\n+            this.resultType = new PtrType(ptrLayout);\n+        }\n+\n+        \/\/ @@@ Change to return member index\n+        static String findMemberName(StructLayout sl, String simpleMemberName) {\n+            for (MemoryLayout layout : sl.memberLayouts()) {\n+                String memberName = layout.name().orElseThrow();\n+                if (simpleMemberName(memberName).equals(simpleMemberName)) {\n+                    return memberName;\n+                }\n+            }\n+            throw new NoSuchElementException(\"No member found: \" + simpleMemberName + \" \" + sl);\n+        }\n+\n+        static String simpleMemberName(String memberName) {\n+            int i = memberName.indexOf(\"::\");\n+            return i != -1\n+                    ? memberName.substring(i + 2)\n+                    : memberName;\n+        }\n+\n+        static String className(String memberName) {\n+            int i = memberName.indexOf(\"::\");\n+            return i != -1\n+                    ? memberName.substring(0, i)\n+                    : null;\n+        }\n+\n+        @Override\n+        public PtrType resultType() {\n+            return resultType;\n+        }\n+\n+        @Override\n+        public Map<String, Object> attributes() {\n+            HashMap<String, Object> attrs = new HashMap<>(super.attributes());\n+            attrs.put(\"\", simpleMemberName);\n+            attrs.put(ATTRIBUTE_OFFSET, memberOffset);\n+            return attrs;\n+        }\n+\n+        public String simpleMemberName() {\n+            return simpleMemberName;\n+        }\n+\n+        public long memberOffset() {\n+            return memberOffset;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrAddOffset extends Op {\n+        public static final String NAME = \"ptr.add.offset\";\n+\n+        PtrAddOffset(PtrAddOffset that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrAddOffset transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrAddOffset(this, cc);\n+        }\n+\n+        public PtrAddOffset(Value ptr, Value offset) {\n+            super(NAME, List.of(ptr, offset));\n+\n+            if (!(ptr.type() instanceof PtrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(offset.type() instanceof PrimitiveType pt && pt.equals(JavaType.LONG))) {\n+                throw new IllegalArgumentException(\"Offset value is not of primitve long type: \" + offset.type());\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return ptrValue().type();\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+\n+        public Value offsetValue() {\n+            return operands().get(1);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrLoadValue extends Op {\n+        public static final String NAME = \"ptr.load.value\";\n+\n+        final JavaType resultType;\n+\n+        PtrLoadValue(PtrLoadValue that, CopyContext cc) {\n+            super(that, cc);\n+            this.resultType = that.resultType;\n+        }\n+\n+        @Override\n+        public PtrLoadValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrLoadValue(this, cc);\n+        }\n+\n+        public PtrLoadValue(Value ptr) {\n+            super(NAME, List.of(ptr));\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(ptrType.layout() instanceof ValueLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n+            }\n+            this.resultType = ptrType.rType();\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return resultType;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+\n+    @OpFactory.OpDeclaration(PtrToMember.NAME)\n+    public static final class PtrStoreValue extends Op {\n+        public static final String NAME = \"ptr.store.value\";\n+\n+        PtrStoreValue(PtrStoreValue that, CopyContext cc) {\n+            super(that, cc);\n+        }\n+\n+        @Override\n+        public PtrStoreValue transform(CopyContext cc, OpTransformer ot) {\n+            return new PtrStoreValue(this, cc);\n+        }\n+\n+        public PtrStoreValue(Value ptr, Value v) {\n+            super(NAME, List.of(ptr));\n+\n+            if (!(ptr.type() instanceof PtrType ptrType)) {\n+                throw new IllegalArgumentException(\"Pointer value is not of pointer type: \" + ptr.type());\n+            }\n+            if (!(ptrType.layout() instanceof ValueLayout)) {\n+                throw new IllegalArgumentException(\"Pointer type layout is not a value layout: \" + ptrType.layout());\n+            }\n+            if (!(ptrType.rType().equals(v.type()))) {\n+                throw new IllegalArgumentException(\"Pointer reference type is not same as value to store type: \"\n+                        + ptrType.rType() + \" \" + v.type());\n+            }\n+        }\n+\n+        @Override\n+        public TypeElement resultType() {\n+            return JavaType.VOID;\n+        }\n+\n+        public Value ptrValue() {\n+            return operands().get(0);\n+        }\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/RawLayout.java","additions":470,"deletions":0,"binary":false,"changes":470,"status":"added"},{"patch":"@@ -0,0 +1,392 @@\n+package experiments;\n+\n+import hat.buffer.Buffer;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+\n+public class Schema  {\n+\n+    public static abstract class Field<T extends MemoryLayout> {\n+        private static final Map<Class<?>, MemoryLayout> typeToLayout = new HashMap<>();\n+        static {\n+            typeToLayout.put(Integer.TYPE, ValueLayout.JAVA_INT);\n+            typeToLayout.put(Float.TYPE, ValueLayout.JAVA_FLOAT);\n+            typeToLayout.put(Long.TYPE, ValueLayout.JAVA_LONG);\n+            typeToLayout.put(Double.TYPE, ValueLayout.JAVA_DOUBLE);\n+            typeToLayout.put(Character.TYPE, ValueLayout.JAVA_CHAR);\n+            typeToLayout.put(Short.TYPE, ValueLayout.JAVA_SHORT);\n+            typeToLayout.put(Byte.TYPE, ValueLayout.JAVA_BYTE);\n+            typeToLayout.put(Boolean.TYPE, ValueLayout.JAVA_BOOLEAN);\n+        }\n+\n+        private static MemoryLayout typeToLayout(Class<?> clazz) {\n+            if (typeToLayout.containsKey(clazz)) {\n+                return typeToLayout.get(clazz);\n+            } else if (clazz.isInterface()) {\n+                if (clazz.isAssignableFrom(Buffer.StructChild.class) || clazz.isAssignableFrom(Buffer.UnionChild.class)) {\n+                    try {\n+                        if (clazz.getDeclaredField(\"schema\") instanceof java.lang.reflect.Field field) {\n+                           throw new IllegalStateException(\"schema ref\");\n+                          \/\/  return ((Schema) field.get(null)).field;\n+                        } else {\n+                            throw new RuntimeException(\"no Schema field found\");\n+                        }\n+                    } catch (NoSuchFieldException e) {\n+                        throw new RuntimeException(e);\n+                  \/\/  } catch (IllegalAccessException e) {\n+                   \/\/     throw new RuntimeException(e);\n+                    }\n+                } else {\n+                    throw new IllegalStateException(\"no Struct or Union found for \" + clazz);\n+                }\n+            } else {\n+                throw new IllegalStateException(\"wtft\");\n+            }\n+        }\n+\n+        FieldHolder parent;\n+        String name;\n+        T layout;\n+\n+        Field(FieldHolder parent, String name) {\n+            this.parent = parent;\n+            this.name = name;\n+        }\n+\n+        public abstract void toText(int depth, Consumer<String> stringConsumer);\n+\n+        public static class Builder implements FieldHolder {\n+            Class<?> iface;\n+            List<Field<?>> children = new LinkedList<>();\n+            FieldHolder parent;\n+\n+\n+            public Class<?> iface() {\n+                return iface;\n+            }\n+\n+            public List<Field<?>> children() {\n+                return children;\n+            }\n+\n+            public FieldHolder parent() {\n+                return parent;\n+            }\n+\n+            Class<?> getTypeForName(String name) {\n+                Class<?>[] clazz = new Class[]{null};\n+                Arrays.stream(iface().getDeclaredMethods()).filter(m -> m.getName().equals(name)).forEach(m -> {\n+                    if (m.getParameterCount() == 0 && m.getReturnType().isInterface()) {\n+                        clazz[0] = m.getReturnType();\n+                    }\n+                });\n+                return clazz[0];\n+            }\n+\n+            MemoryLayout layout() {\n+                return null;\n+            }\n+            \/*\n+                List<MemoryLayout> memoryLayouts = new ArrayList<>();\n+                Map<String, Integer> orderMap = new LinkedHashMap<>();\n+                Arrays.stream(order).forEach(s -> orderMap.put(s, orderMap.size())); \/\/ order[0] -> 0, order[1] -> r\n+                Set<String> done = new HashSet<>();\n+                Arrays.stream(bufferClass.getDeclaredMethods())\n+                        .filter(m -> orderMap.containsKey(m.getName()))                        \/\/only methods named in array\n+                        .sorted(Comparator.comparingInt(lhs -> orderMap.get(lhs.getName()))) \/\/ sort by order in the array\n+                        .forEach(m -> {\n+                            String name = m.getName();\n+                            if (!done.contains(name)) {\n+                                MemoryLayout layout = null;\n+                                var rt = m.getReturnType();\n+                                if (rt == Void.TYPE) {\n+                                    if (m.getParameterCount() == 1) {\n+                                        layout = typeToLayout(m.getParameterTypes()[0]);\n+                                    } else if (m.getParameterCount() == 2) {\n+                                        throw new IllegalStateException(\"never\");\n+                                    }\n+                                } else {\n+                                    layout = typeToLayout(rt);\n+                                }\n+                                if (layout instanceof ValueLayout) {\n+                                    memoryLayouts.add(layout.withName(name));\n+                                } else if (layout instanceof StructLayout) {\n+                                    memoryLayouts.add(layout.withName(name + \"::struct\"));\n+                                }\n+                                done.add(name);\n+                            }\n+\n+                        });\n+\n+                MemoryLayout.structLayout(memoryLayouts.toArray(new MemoryLayout[0])).withName(bufferClass.getName());\n+            } *\/\n+\n+            public Builder struct(String name, Class<?> clazz, Consumer<Builder> fb) {\n+                Builder builder = new Builder(clazz);\n+                fb.accept(builder);\n+                children.add(new Struct(this, name, clazz, builder.children));\n+                return this;\n+            }\n+\n+            public Builder struct(String name, Consumer<Builder> fb) {\n+                return struct(name, getTypeForName(name), fb);\n+            }\n+\n+            public Builder struct(String name, FieldHolder schemaFieldHolder) {\n+                children.add(new Struct(this, name, getTypeForName(name), schemaFieldHolder.children()));\n+                return this;\n+            }\n+\n+            public Builder struct(String name, Schema schema) {\n+                children.add(new Struct(this, name, getTypeForName(name), schema.field.children()));\n+                return this;\n+            }\n+\n+            public Builder union(String name, Class<?> clazz, Consumer<Builder> fb) {\n+                Builder builder = new Builder(clazz);\n+                fb.accept(builder);\n+                children.add(new Struct(this, name, clazz, builder.children));\n+                return this;\n+            }\n+\n+            public Builder union(String name, Consumer<Builder> fb) {\n+                return union(name, getTypeForName(name), fb);\n+            }\n+\n+            public Builder union(String name, FieldHolder fieldHolder) {\n+                children.add(new Struct(this, name, getTypeForName(name), fieldHolder.children()));\n+                return this;\n+            }\n+\n+            public Builder union(String name, Schema schema) {\n+                children.add(new Struct(this, name, getTypeForName(name), schema.field.children()));\n+                return this;\n+            }\n+\n+            public Builder primitive(String name) {\n+                children.add(new Primitive(this, name));\n+                return this;\n+            }\n+\n+            public Builder array(String name, int len) {\n+                children.add(new FixedArray(this, name, getTypeForName(name), len));\n+                return this;\n+            }\n+\n+            public Builder fieldControlledArray(String name, Primitive primitive) {\n+                children.add(new FieldControlledArray(this, name, getTypeForName(name), primitive));\n+                return this;\n+            }\n+\n+            public Builder fieldControlledArray(String name, String controllingFieldName) {\n+                var primitiveField = new Primitive(this, controllingFieldName);\n+                children.add(primitiveField);\n+                return fieldControlledArray(name, primitiveField);\n+            }\n+\n+            public class ArrayLen {\n+                Builder builder;\n+                Primitive controllingField;\n+\n+                Builder array(String name) {\n+                    return builder.fieldControlledArray(name, controllingField);\n+                }\n+\n+                ArrayLen(Builder builder, Primitive controllingField) {\n+                    this.builder = builder;\n+                    this.controllingField = controllingField;\n+                }\n+            }\n+\n+            public ArrayLen arrayLen(String controllingFieldName) {\n+\n+                var primitiveField = new Primitive(this, controllingFieldName);\n+                children.add(primitiveField);\n+                return new ArrayLen(this, primitiveField);\n+            }\n+\n+            public void flexArray(String name) {\n+                children.add(new FlexArray(this, name, null));\n+            }\n+\n+\n+            Builder(Class<?> iface) {\n+                this.iface = iface;\n+            }\n+\n+            void toText(int depth, Consumer<String> stringConsumer) {\n+                children.stream().forEach(c -> c.toText(depth + 1, stringConsumer));\n+            }\n+        }\n+\n+        public static interface FieldHolder {\n+            List<Field<?>> children();\n+        }\n+\n+        public static class Padding<T extends PaddingLayout> extends Field<T> {\n+            Padding(FieldHolder parent, String name) {\n+                super(parent, name);\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"padding \");\n+            }\n+        }\n+\n+        public static class Primitive extends Field<ValueLayout> {\n+\n+            Primitive(FieldHolder parent, String name) {\n+                super(parent, name);\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"primitive \" + name);\n+            }\n+        }\n+\n+        public static abstract class StructOrUnion<T extends GroupLayout> extends Field<T> implements Field.FieldHolder {\n+            Class<?> iface;\n+            List<Field<?>> children;\n+            FieldHolder parent;\n+\n+            public Class<?> iface() {\n+                return iface;\n+            }\n+\n+            public List<Field<?>> children() {\n+                return children;\n+            }\n+\n+            public FieldHolder parent() {\n+                return parent;\n+            }\n+\n+            StructOrUnion(FieldHolder parent, String name, Class<?> iface, List<Field<?>> children) {\n+                super(parent, name);\n+                this.iface = iface;\n+                this.children = children;\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                children.forEach(c -> {\n+                    c.toText(depth + 1, stringConsumer);\n+                    stringConsumer.accept(\"\\n\");\n+                });\n+            }\n+\n+        }\n+\n+        public static class Struct extends StructOrUnion<StructLayout> {\n+            Struct(FieldHolder parent, String name, Class<?> iface, List<Field<?>> schemaFields) {\n+                super(parent, name, iface, schemaFields);\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"struct \" + name);\n+                super.toText(depth + 1, stringConsumer);\n+            }\n+        }\n+\n+        public static class Union extends StructOrUnion<UnionLayout> {\n+            Union(FieldHolder parent, String name, Class<?> iface, List<Field<?>> schemaFields) {\n+                super(parent, name, iface, schemaFields);\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"union name\");\n+                super.toText(depth + 1, stringConsumer);\n+            }\n+        }\n+\n+        public abstract static class Array extends Field<SequenceLayout> {\n+            Class<?> elementClass;\n+\n+            Array(FieldHolder parent, String name, Class<?> elementClass) {\n+                super(parent, name);\n+                this.elementClass = elementClass;\n+            }\n+        }\n+\n+        public static class FixedArray extends Array {\n+            int len;\n+\n+            FixedArray(FieldHolder parent, String name, Class<?> elementClass, int len) {\n+                super(parent, name, elementClass);\n+                this.len = len;\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"array [\" + len + \"]\");\n+            }\n+        }\n+\n+        public static class FlexArray extends Array {\n+\n+            FlexArray(FieldHolder parent, String name, Class<?> elementClass) {\n+                super(parent, name, elementClass);\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"array [?] \");\n+            }\n+        }\n+\n+        public static class FieldControlledArray extends Array {\n+            Primitive primitive;\n+\n+            FieldControlledArray(FieldHolder parent, String name, Class<?> elementClass, Primitive primitive) {\n+                super(parent, name, elementClass);\n+                this.primitive = primitive;\n+            }\n+\n+            @Override\n+            public void toText(int depth, Consumer<String> stringConsumer) {\n+                IntStream.range(0, depth).forEach(_ -> stringConsumer.accept(\" \"));\n+                stringConsumer.accept(\"field controlled \" + primitive.name + \" \" + name);\n+            }\n+        }\n+    }\n+\n+    Field.StructOrUnion field;\n+    Schema(Field.StructOrUnion field) {\n+        this.field = field;\n+    }\n+\n+    public static <T extends Buffer> Schema of(Class<?> iface, Consumer<Field.Builder> fb) {\n+        Field.Builder builder = new Field.Builder(iface);\n+        fb.accept(builder);\n+        if (Buffer.class.isAssignableFrom(iface) || Buffer.StructChild.class.isAssignableFrom(iface)){\n+            return new Schema(new Field.Struct(null, iface.getSimpleName(),iface,builder.children));\n+        }else if (Buffer.StructChild.class.isAssignableFrom(iface)){\n+            return new Schema(new Field.Union(null, iface.getSimpleName(),iface,builder.children));\n+        }\n+        throw new IllegalStateException(\"must be a Sturct, Union or Buffer\");\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/Schema.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"},{"patch":"@@ -37,0 +37,6 @@\n+    @CodeReflection\n+    public static int sq(int v) {\n+        return  v * v;\n+\n+    }\n+\n@@ -41,1 +47,1 @@\n-           s32Array.array(kc.x, value * value);  \/\/ arr[cc.x]=value*value\n+           s32Array.array(kc.x, sq(value));  \/\/ arr[cc.x]=value*value\n@@ -54,1 +60,1 @@\n-        var accelerator = new Accelerator(lookup, new JavaMultiThreadedBackend());\n+        var accelerator = new Accelerator(lookup, Backend.FIRST);\/\/new JavaMultiThreadedBackend());\n","filename":"hat\/examples\/squares\/src\/main\/java\/squares\/Squares.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,4 +41,4 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Struct {\n-    }\n+    \/\/@Retention(RetentionPolicy.RUNTIME)\n+    \/\/@Target(ElementType.TYPE)\n+    \/\/public @interface Struct {\n+   \/\/ }\n@@ -46,4 +46,4 @@\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @Target(ElementType.TYPE)\n-    public @interface Union {\n-    }\n+    \/\/@Retention(RetentionPolicy.RUNTIME)\n+    \/\/@Target(ElementType.TYPE)\n+    \/\/public @interface Union {\n+   \/\/ }\n@@ -54,1 +54,1 @@\n-    @Union\n+    \/\/@Union\n@@ -58,1 +58,1 @@\n-    @Struct\n+    \/\/@Struct\n","filename":"hat\/hat\/src\/main\/java\/hat\/buffer\/Buffer.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}