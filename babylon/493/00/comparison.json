{"files":[{"patch":"@@ -12,0 +12,1 @@\n+import jdk.incubator.code.analysis.Inliner;\n@@ -138,1 +139,1 @@\n-                    bb.inline(mapOrInline(fo, funcs, doNotInline), bb.context().getValues(io.operands()), (_, v) -> bb.context().mapValue(io.result(), v));\n+                    Inliner.inline(bb, mapOrInline(fo, funcs, doNotInline), bb.context().getValues(io.operands()), (_, v) -> bb.context().mapValue(io.result(), v));\n","filename":"cr-examples\/onnx\/src\/main\/java\/oracle\/code\/onnx\/compiler\/OnnxTransformer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -30,3 +29,0 @@\n-import java.util.function.BiConsumer;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n@@ -35,3 +31,0 @@\n-import static jdk.incubator.code.dialect.core.CoreOp.return_;\n-import static jdk.incubator.code.dialect.core.CoreOp.branch;\n-\n@@ -313,1 +306,1 @@\n-        return predecessors.stream().flatMap(p -> successors().stream())\n+        return predecessors.stream().flatMap(p -> p.successors().stream())\n@@ -328,2 +321,1 @@\n-        Op lopr = ops.get(ops.size() - 1);\n-        return lopr.successors();\n+        return ops.getLast().successors();\n@@ -616,113 +608,0 @@\n-        \/**\n-         * An inline consumer that inserts a return operation with a value, if non-null.\n-         *\/\n-        public static final BiConsumer<Block.Builder, Value> INLINE_RETURN = (block, value) -> {\n-            block.op(value != null ? return_(value) : CoreOp.return_());\n-        };\n-\n-        \/**\n-         * Inlines the invokable operation into this block and returns the block builder from which to\n-         * continue building.\n-         * <p>\n-         * This method {@link #transformBody(Body, List, CopyContext, OpTransformer) transforms} the body of the\n-         * invokable operation with the given arguments, a new context, and an operation transformer that\n-         * replaces return operations by applying the given consumer to a block builder and a return value.\n-         * <p>\n-         * The operation transformer copies all operations except return operations whose nearest invokable operation\n-         * ancestor is the given the invokable operation. When such a return operation is encountered, then on\n-         * first encounter of its grandparent body a return block builder is computed and used for this return operation\n-         * and encounters of subsequent return operations with the same grandparent body.\n-         * <p>\n-         * If the grandparent body has only one block then operation transformer's block builder is the return\n-         * block builder. Otherwise, if the grandparent body has one or more blocks then the return block builder is\n-         * created from the operation transformer's block builder. The created return block builder will have a block\n-         * parameter whose type corresponds to the return type, or will have no parameter for void return.\n-         * The computation finishes by applying the return block builder and a return value to the inlining consumer.\n-         * If the grandparent body has only one block then the return value is the value mapped from the return\n-         * operation's operand, or is null for void return. Otherwise, if the grandparent body has one or more blocks\n-         * then the value is the block parameter of the created return block builder, or is null for void return.\n-         * <p>\n-         * For every encounter of a return operation the associated return block builder is compared against the\n-         * operation transformer's block builder. If they are not equal then a branch operation is added to the\n-         * operation transformer's block builder whose successor is the return block builder with a block argument\n-         * that is the value mapped from the return operation's operand, or with no block argument for void return.\n-         * @apiNote\n-         * It is easier to inline an invokable op if its body is in lowered form (there are no operations in the blocks\n-         * of the body that are lowerable). This ensures a single exit point can be created (paired with the single\n-         * entry point). If there are one or more nested return operations, then there is unlikely to be a single exit.\n-         * Transforming the model to create a single exit point while preserving nested structure is in general\n-         * non-trivial and outside the scope of this method. In such cases the invokable operation can be transformed\n-         * with a lowering transformation after which it can then be inlined.\n-         *\n-         * @param invokableOp the invokable operation\n-         * @param args the arguments to map to the invokable operation's parameters\n-         * @param inlineConsumer the consumer applied to process the return from the invokable operation.\n-         *                       This is called once for each grandparent body of a return operation, with a block to\n-         *                       build replacement operations and the return value, or null for void return.\n-         * @return the block builder to continue building from\n-         * @param <O> The invokable type\n-         *\/\n-        public <O extends Op & Op.Invokable> Block.Builder inline(O invokableOp, List<? extends Value> args,\n-                                                                  BiConsumer<Block.Builder, Value> inlineConsumer) {\n-            Map<Body, Block.Builder> returnBlocks = new HashMap<>();\n-            \/\/ Create new context, ensuring inlining is isolated\n-            transformBody(invokableOp.body(), args, CopyContext.create(), (block, op) -> {\n-                \/\/ If the return operation is associated with the invokable operation\n-                if (op instanceof CoreOp.ReturnOp rop && getNearestInvokeableAncestorOp(op) == invokableOp) {\n-                    \/\/ Compute the return block\n-                    Block.Builder returnBlock = returnBlocks.computeIfAbsent(rop.ancestorBody(), _body -> {\n-                        Block.Builder rb;\n-                        \/\/ If the body has one block we know there is just one return op declared, otherwise there may\n-                        \/\/ one or more. If so, create a new block that joins all the returns.\n-                        \/\/ Note: we could count all return op in a body to avoid creating a new block for a body\n-                        \/\/ with two or more blocks with only one returnOp is declared.\n-                        Value r;\n-                        if (rop.ancestorBody().blocks().size() != 1) {\n-                            List<TypeElement> param = rop.returnValue() != null\n-                                    ? List.of(invokableOp.invokableType().returnType())\n-                                    : List.of();\n-                            rb = block.block(param);\n-                            r = !param.isEmpty()\n-                                    ? rb.parameters().get(0)\n-                                    : null;\n-                        } else {\n-                            r = rop.returnValue() != null\n-                                    ? block.context().getValue(rop.returnValue())\n-                                    : null;\n-                            rb = block;\n-                        }\n-\n-                        \/\/ Inline the return\n-                        inlineConsumer.accept(rb, r);\n-\n-                        return rb;\n-                    });\n-\n-                    \/\/ Replace the return op with a branch to the return block, if needed\n-                    if (!returnBlock.equals(block)) {\n-                        \/\/ Replace return op with branch to return block, with given return value\n-                        List<Value> arg = rop.returnValue() != null\n-                                ? List.of(block.context().getValue(rop.returnValue()))\n-                                : List.of();\n-                        block.op(branch(returnBlock.successor(arg)));\n-                    }\n-\n-                    return block;\n-                }\n-\n-                block.op(op);\n-                return block;\n-            });\n-\n-\n-            Builder builder = returnBlocks.get(invokableOp.body());\n-            return builder != null ? builder : this;\n-        }\n-\n-        private static Op getNearestInvokeableAncestorOp(Op op) {\n-            do {\n-                op = op.ancestorOp();\n-            } while (!(op instanceof Op.Invokable));\n-            return op;\n-        }\n-\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/Block.java","additions":2,"deletions":123,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+package jdk.incubator.code.analysis;\n+\n+import jdk.incubator.code.*;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+\n+import static jdk.incubator.code.dialect.core.CoreOp.branch;\n+import static jdk.incubator.code.dialect.core.CoreOp.return_;\n+\n+\/**\n+ * Functionality for inlining code.\n+ *\/\n+public final class Inliner {\n+\n+    private Inliner() {}\n+\n+    \/**\n+     * An inline consumer that inserts a return operation with a value, if non-null.\n+     *\/\n+    public static final BiConsumer<Block.Builder, Value> INLINE_RETURN = (block, value) -> {\n+        block.op(value != null ? return_(value) : CoreOp.return_());\n+    };\n+\n+    \/**\n+     * Inlines the invokable operation into the given block builder and returns the block builder from which to\n+     * continue building.\n+     * <p>\n+     * This method {@link Block.Builder#transformBody(Body, List, CopyContext, OpTransformer) transforms} the\n+     * body of the invokable operation with the given arguments, a new context, and an operation transformer that\n+     * replaces return operations by applying the given consumer to a block builder and a return value.\n+     * <p>\n+     * The operation transformer copies all operations except return operations whose nearest invokable operation\n+     * ancestor is the given the invokable operation. When such a return operation is encountered, then on\n+     * first encounter of its grandparent body a return block builder is computed and used for this return operation\n+     * and encounters of subsequent return operations with the same grandparent body.\n+     * <p>\n+     * If the grandparent body has only one block then operation transformer's block builder is the return\n+     * block builder. Otherwise, if the grandparent body has one or more blocks then the return block builder is\n+     * created from the operation transformer's block builder. The created return block builder will have a block\n+     * parameter whose type corresponds to the return type, or will have no parameter for void return.\n+     * The computation finishes by applying the return block builder and a return value to the inlining consumer.\n+     * If the grandparent body has only one block then the return value is the value mapped from the return\n+     * operation's operand, or is null for void return. Otherwise, if the grandparent body has one or more blocks\n+     * then the value is the block parameter of the created return block builder, or is null for void return.\n+     * <p>\n+     * For every encounter of a return operation the associated return block builder is compared against the\n+     * operation transformer's block builder. If they are not equal then a branch operation is added to the\n+     * operation transformer's block builder whose successor is the return block builder with a block argument\n+     * that is the value mapped from the return operation's operand, or with no block argument for void return.\n+     * @apiNote\n+     * It is easier to inline an invokable op if its body is in lowered form (there are no operations in the blocks\n+     * of the body that are lowerable). This ensures a single exit point can be created (paired with the single\n+     * entry point). If there are one or more nested return operations, then there is unlikely to be a single exit.\n+     * Transforming the model to create a single exit point while preserving nested structure is in general\n+     * non-trivial and outside the scope of this method. In such cases the invokable operation can be transformed\n+     * with a lowering transformation after which it can then be inlined.\n+     *\n+     * @param _this the block builder\n+     * @param invokableOp the invokable operation\n+     * @param args the arguments to map to the invokable operation's parameters\n+     * @param inlineConsumer the consumer applied to process the return from the invokable operation.\n+     *                       This is called once for each grandparent body of a return operation, with a block to\n+     *                       build replacement operations and the return value, or null for void return.\n+     * @return the block builder to continue building from\n+     * @param <O> The invokable type\n+     *\/\n+    public static <O extends Op & Op.Invokable>\n+    Block.Builder inline(Block.Builder _this, O invokableOp, List<? extends Value> args,\n+                         BiConsumer<Block.Builder, Value> inlineConsumer) {\n+        Map<Body, Block.Builder> returnBlocks = new HashMap<>();\n+        \/\/ Create new context, ensuring inlining is isolated\n+        _this.transformBody(invokableOp.body(), args, CopyContext.create(), (block, op) -> {\n+            \/\/ If the return operation is associated with the invokable operation\n+            if (op instanceof CoreOp.ReturnOp rop && getNearestInvokeableAncestorOp(op) == invokableOp) {\n+                \/\/ Compute the return block\n+                Block.Builder returnBlock = returnBlocks.computeIfAbsent(rop.ancestorBody(), _body -> {\n+                    Block.Builder rb;\n+                    \/\/ If the body has one block we know there is just one return op declared, otherwise there may\n+                    \/\/ one or more. If so, create a new block that joins all the returns.\n+                    \/\/ Note: we could count all return op in a body to avoid creating a new block for a body\n+                    \/\/ with two or more blocks with only one returnOp is declared.\n+                    Value r;\n+                    if (rop.ancestorBody().blocks().size() != 1) {\n+                        List<TypeElement> param = rop.returnValue() != null\n+                                ? List.of(invokableOp.invokableType().returnType())\n+                                : List.of();\n+                        rb = block.block(param);\n+                        r = !param.isEmpty()\n+                                ? rb.parameters().get(0)\n+                                : null;\n+                    } else {\n+                        r = rop.returnValue() != null\n+                                ? block.context().getValue(rop.returnValue())\n+                                : null;\n+                        rb = block;\n+                    }\n+\n+                    \/\/ Inline the return\n+                    inlineConsumer.accept(rb, r);\n+\n+                    return rb;\n+                });\n+\n+                \/\/ Replace the return op with a branch to the return block, if needed\n+                if (!returnBlock.equals(block)) {\n+                    \/\/ Replace return op with branch to return block, with given return value\n+                    List<Value> arg = rop.returnValue() != null\n+                            ? List.of(block.context().getValue(rop.returnValue()))\n+                            : List.of();\n+                    block.op(branch(returnBlock.successor(arg)));\n+                }\n+\n+                return block;\n+            }\n+\n+            block.op(op);\n+            return block;\n+        });\n+\n+\n+        Block.Builder builder = returnBlocks.get(invokableOp.body());\n+        return builder != null ? builder : _this;\n+    }\n+\n+    private static Op getNearestInvokeableAncestorOp(Op op) {\n+        do {\n+            op = op.ancestorOp();\n+        } while (!(op instanceof Op.Invokable));\n+        return op;\n+    }\n+}\n","filename":"src\/jdk.incubator.code\/share\/classes\/jdk\/incubator\/code\/analysis\/Inliner.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.analysis.Inliner;\n@@ -59,1 +60,1 @@\n-                    var cb = fblock.inline(cop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    var cb = Inliner.inline(fblock, cop, List.of(i, fortyTwo), Inliner.INLINE_RETURN);\n@@ -83,1 +84,1 @@\n-                    var cb = fblock.inline(cop, List.of(i, fortyTwo), (b, value) -> {\n+                    var cb = Inliner.inline(fblock, cop, List.of(i, fortyTwo), (b, value) -> {\n@@ -118,1 +119,1 @@\n-                    var cb = fblock.inline(lcop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    var cb = Inliner.inline(fblock, lcop, List.of(i, fortyTwo), Inliner.INLINE_RETURN);\n@@ -149,1 +150,1 @@\n-                    var cb = fblock.inline(lcop, List.of(i, fortyTwo), (b, value) -> {\n+                    var cb = Inliner.inline(fblock, lcop, List.of(i, fortyTwo), (b, value) -> {\n@@ -179,1 +180,1 @@\n-                    var cb = fblock.inline(cop, List.of(i, fortyTwo), Block.Builder.INLINE_RETURN);\n+                    var cb = Inliner.inline(fblock, cop, List.of(i, fortyTwo), Inliner.INLINE_RETURN);\n@@ -204,1 +205,1 @@\n-                    var cb = fblock.inline(cop, List.of(a), Block.Builder.INLINE_RETURN);\n+                    var cb = Inliner.inline(fblock, cop, List.of(a), Inliner.INLINE_RETURN);\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestInline.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.code.analysis.Inliner;\n@@ -121,1 +122,1 @@\n-                    .body(b -> b.inline(currentQueryExpression, b.parameters(), (block, query) -> {\n+                    .body(b -> Inliner.inline(b, currentQueryExpression, b.parameters(), (block, query) -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/TestLinqUsingQuoted.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.code.analysis.Inliner;\n@@ -66,1 +67,1 @@\n-                .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                .body(b -> Inliner.inline(b, queryExpression, b.parameters(), (block, query) -> {\n@@ -97,1 +98,1 @@\n-                .body(b -> b.inline(queryExpression, b.parameters(), (block, query) -> {\n+                .body(b -> Inliner.inline(b, queryExpression, b.parameters(), (block, query) -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/linq\/Queryable.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.code.analysis.Inliner;\n@@ -144,1 +145,1 @@\n-                body.inline(sop.op(), List.of(element), (block, value) -> {\n+                Inliner.inline(body, sop.op(), List.of(element), (block, value) -> {\n@@ -148,1 +149,1 @@\n-                body.inline(sop.op(), List.of(element), (block, p) -> {\n+                Inliner.inline(body, sop.op(), List.of(element), (block, p) -> {\n@@ -161,1 +162,1 @@\n-                body.inline(sop.op(), List.of(element), (block, iterable) -> {\n+                Inliner.inline(body, sop.op(), List.of(element), (block, iterable) -> {\n@@ -195,1 +196,1 @@\n-                                        terminalBlock.inline(consumer, List.of(resultValue),\n+                                        Inliner.inline(terminalBlock, consumer, List.of(resultValue),\n@@ -221,1 +222,1 @@\n-                        b.inline(supplier, List.of(), (block, collect) -> {\n+                        Inliner.inline(b, supplier, List.of(), (block, collect) -> {\n@@ -225,1 +226,1 @@\n-                                            terminalBlock.inline(accumulator, List.of(collect, resultValue),\n+                                            Inliner.inline(terminalBlock, accumulator, List.of(collect, resultValue),\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuser.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.code.analysis.Inliner;\n@@ -161,1 +162,1 @@\n-                body.inline(sop.op(), List.of(element), (block, value) -> {\n+                Inliner.inline(body, sop.op(), List.of(element), (block, value) -> {\n@@ -165,1 +166,1 @@\n-                body.inline(sop.op(), List.of(element), (block, p) -> {\n+                Inliner.inline(body, sop.op(), List.of(element), (block, p) -> {\n@@ -178,1 +179,1 @@\n-                body.inline(sop.op(), List.of(element), (block, iterable) -> {\n+                Inliner.inline(body, sop.op(), List.of(element), (block, iterable) -> {\n@@ -215,1 +216,1 @@\n-                                        terminalBlock.inline(consumer, List.of(resultValue),\n+                                        Inliner.inline(terminalBlock, consumer, List.of(resultValue),\n@@ -246,1 +247,1 @@\n-                        b.inline(supplier, List.of(), (block, collect) -> {\n+                        Inliner.inline(b, supplier, List.of(), (block, collect) -> {\n@@ -250,1 +251,1 @@\n-                                            terminalBlock.inline(accumulator, List.of(collect, resultValue),\n+                                            Inliner.inline(terminalBlock, accumulator, List.of(collect, resultValue),\n","filename":"test\/jdk\/java\/lang\/reflect\/code\/stream\/StreamFuserUsingQuotable.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"}]}