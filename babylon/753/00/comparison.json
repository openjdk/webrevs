{"files":[{"patch":"@@ -387,1 +387,0 @@\n-\n","filename":"hat\/backends\/ffi\/cuda\/src\/main\/java\/hat\/backend\/ffi\/CudaBackend.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,3 +34,2 @@\n-\n-    public OpenCLBackend(String configSpec) {\n-        this(Config.fromSpec(configSpec));\n+    public OpenCLBackend(Config config) {\n+        super(\"opencl_backend\", config);\n@@ -38,1 +37,0 @@\n-\n@@ -42,6 +40,0 @@\n-\n-    public OpenCLBackend(Config config) {\n-        super(\"opencl_backend\", config);\n-    }\n-\n-\n","filename":"hat\/backends\/ffi\/opencl\/src\/main\/java\/hat\/backend\/ffi\/OpenCLBackend.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-                    } else if (OpTk.isComputeContextMethod(lookup,invokeOp) || OpTk.isKernelContextMethod(lookup,invokeOp)) { \/\/dispatchKernel\n+                    } else if (OpTk.isComputeContextMethod(lookup,invokeOp) || OpTk.isKernelContextInvokeOp(lookup,invokeOp,OpTk.AnyInvoke)) { \/\/dispatchKernel\n","filename":"hat\/backends\/ffi\/shared\/src\/main\/java\/hat\/backend\/ffi\/FFIBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-                } else if (OpTk.isComputeContextMethod(lookup, invokeOp) || OpTk.isKernelContextMethod(lookup, invokeOp)) { \/\/dispatchKernel\n+                } else if (OpTk.isComputeContextMethod(lookup, invokeOp) || OpTk.isKernelContextInvokeOp(lookup, invokeOp,OpTk.AnyInvoke)) { \/\/dispatchKernel\n","filename":"hat\/backends\/jextracted\/shared\/src\/main\/java\/hat\/backend\/jextracted\/JExtractedBackend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -339,0 +340,2 @@\n+    static Pattern atomicInc = Pattern.compile(\"(atomic.*)Inc\");\n+\n@@ -342,1 +345,1 @@\n-                || OpTk.isInvokeDescriptorSubtypeOfAnyMatch(invokeOp, List.of(HAType.class, DeviceType.class))) {\n+                || OpTk.isInvokeDescriptorSubtypeOfAnyMatch(buildContext.lookup,invokeOp, HAType.class, DeviceType.class)) {\n@@ -344,3 +347,2 @@\n-                    && OpTk.funcName(invokeOp) instanceof String funcName\n-                    && funcName.startsWith(\"atomic\")\n-                    && funcName.endsWith(\"Inc\")\n+                   \/\/ && OpTk.funcName(invokeOp) instanceof String funcName\n+                    && atomicInc.matcher(OpTk.funcName(invokeOp)) instanceof Matcher matcher && matcher.matches()\n@@ -348,1 +350,0 @@\n-                \/\/ this is a bit of a hack for atomics.\n@@ -350,1 +351,1 @@\n-                    atomicInc(buildContext, instanceResult, funcName.substring(0, funcName.length() - \"Inc\".length()));\n+                    atomicInc(buildContext, instanceResult, matcher.group(1));\n","filename":"hat\/core\/src\/main\/java\/hat\/codebuilders\/C99HATCodeBuilderContext.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import hat.KernelContext;\n@@ -29,1 +30,0 @@\n-import hat.buffer.KernelBufferContext;\n@@ -34,0 +34,1 @@\n+import hat.types._V;\n@@ -64,0 +65,1 @@\n+import java.util.Objects;\n@@ -65,1 +67,1 @@\n-import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -67,1 +69,0 @@\n-import java.util.regex.Pattern;\n@@ -70,1 +71,1 @@\n-public class OpTk {\n+public interface OpTk {\n@@ -72,2 +73,61 @@\n-    public static boolean isKernelContextAccess(JavaOp.FieldAccessOp fieldAccessOp) {\n-        return fieldAccessOp.fieldDescriptor().refType() instanceof ClassType classType && classType.toClassName().equals(\"hat.KernelContext\");\n+\n+   static boolean isKernelContext(MethodHandles.Lookup lookup,TypeElement typeElement){\n+       return isAssignable(lookup,typeElement,KernelContext.class);\n+   }\n+\n+    Predicate<JavaOp.InvokeOp> AnyInvoke = _->true;\n+    static JavaOp.InvokeOp asKernelContextInvokeOpOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n+        if (ce instanceof JavaOp.InvokeOp invokeOp) {\n+            if (isKernelContext(lookup, invokeOp.invokeDescriptor().refType())) {\n+                return predicate.test(invokeOp) ? invokeOp : null;\n+            } else if (invokeOp.operands().size() > 1\n+                    && invokeOp.operands().getFirst() instanceof Value value\n+                    && isKernelContext(lookup, value.type())) {\n+            \/\/    throw new IllegalStateException(\"did you mean to check if the first arg is KernelContext ?\");\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static boolean isKernelContextInvokeOp(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.InvokeOp> predicate) {\n+        return Objects.nonNull(asKernelContextInvokeOpOrNull(lookup,ce, predicate));\n+    }\n+\n+    Predicate<JavaOp.FieldAccessOp> AnyFieldAccess = _->true;\n+    static boolean isVarAccessFromKernelContextFieldOp(MethodHandles.Lookup lookup,CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+        return isKernelContextFieldAccessOp(lookup, varLoadOp, AnyFieldAccess);\/\/varLoadOp.resultType());\n+    }\n+ static JavaOp.FieldAccessOp asKernelContextFieldAccessOrNull(MethodHandles.Lookup lookup, CodeElement<?,?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n+     if (ce instanceof JavaOp.FieldAccessOp fieldAccessOp && isKernelContext(lookup,fieldAccessOp.fieldDescriptor().refType())){\n+         return predicate.test(fieldAccessOp)?fieldAccessOp:null;\n+     }\n+     return null;\n+ }\n+    static boolean isKernelContextFieldAccessOp(MethodHandles.Lookup lookup,CodeElement<?, ?> ce, Predicate<JavaOp.FieldAccessOp> predicate) {\n+        return Objects.nonNull(asKernelContextFieldAccessOrNull(lookup,ce, predicate));\n+    }\n+\n+    static boolean isKernelContextFieldAccessOp(MethodHandles.Lookup lookup,CodeElement<?, ?> ce) {\n+        return isKernelContextFieldAccessOp(lookup,ce, AnyFieldAccess);\n+    }\n+\n+\n+    static boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n+    }\n+\n+    static boolean isHatType(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return (isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class));\n+    }\n+\n+\n+\n+    static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n+        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n+    }\n+\n+\n+\n+    static <F extends Op, T extends Op> T copyLocation(F from, T to ){\n+        to.setLocation(from.location());\n+        return to;\n@@ -76,1 +136,2 @@\n-    public static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n+\n+    static String fieldName(JavaOp.FieldAccessOp fieldAccessOp) {\n@@ -80,1 +141,1 @@\n-    public static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n+    static Object getStaticFinalPrimitiveValue(MethodHandles.Lookup lookup, JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp) {\n@@ -95,1 +156,1 @@\n-    public static Stream<Op> statements(Op.Loop op) {\n+    static Stream<Op> statements(Op.Loop op) {\n@@ -103,1 +164,1 @@\n-    public static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n+    static CoreOp.ModuleOp createTransitiveInvokeModule(MethodHandles.Lookup lookup,\n@@ -107,2 +168,1 @@\n-        record RefAndFunc(MethodRef r, CoreOp.FuncOp f) {\n-        }\n+        record RefAndFunc(MethodRef r, CoreOp.FuncOp f) {}\n@@ -165,1 +225,1 @@\n-    public static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n+    static Type classTypeToTypeOrThrow(MethodHandles.Lookup lookup, ClassType classType) {\n@@ -173,2 +233,2 @@\n-    public static boolean isAssignable(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n-        if (javaType instanceof ClassType classType) {\n+    static boolean isAssignable(MethodHandles.Lookup lookup, TypeElement typeElement, Class<?>... classes) {\n+        if (typeElement instanceof ClassType classType) {\n@@ -182,1 +242,1 @@\n-    public static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n+    static boolean isAssignableTo(MethodHandles.Lookup lookup, JavaType javaType, Class<?>... classes) {\n@@ -192,1 +252,1 @@\n-    public static JavaOp.InvokeOp getTargetInvokeOp(JavaOp.LambdaOp lambdaOp) {\n+    static JavaOp.InvokeOp getTargetInvokeOp(JavaOp.LambdaOp lambdaOp) {\n@@ -199,1 +259,1 @@\n-    public static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n+    static Object[] getQuotedCapturedValues(JavaOp.LambdaOp lambdaOp, Quoted quoted, Method method) {\n@@ -231,5 +291,1 @@\n-    \/\/ public static Stream<Op> statements(CoreOp.FuncOp op) {\n-    \/\/   return statements(op.bodies().getFirst().entryBlock());\n-    \/\/ }\n-\n-    static public Stream<Op> statements(Block block) {\n+    static Stream<Op> statements(Block block) {\n@@ -239,3 +295,1 @@\n-                        || (op instanceof HATMemoryOp)\n-                        || (op instanceof HATVectorVarOp)\n-                        || (op instanceof HATF16VarOp)\n+                        || op instanceof HATOp\n@@ -247,1 +301,1 @@\n-    public static JavaType javaRefType(JavaOp.InvokeOp op) {\n+    static JavaType javaRefType(JavaOp.InvokeOp op) {\n@@ -251,20 +305,1 @@\n-    public static boolean isIfaceBufferMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return (isAssignable(lookup, javaRefType(invokeOp), MappableIface.class));\n-    }\n-\n-    public static boolean isHatType(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return (isAssignableTo(lookup, javaRefType(invokeOp), DeviceType.class, MappableIface.class, HAType.class));\n-    }\n-\n-    public static boolean isKernelContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-        return (op.operands().size() > 1 && op.operands().getFirst() instanceof Value value\n-                && value.type() instanceof JavaType javaType\n-                && (isAssignable(lookup, javaType, hat.KernelContext.class) || isAssignable(lookup, javaType, KernelBufferContext.class))\n-        );\n-    }\n-\n-    public static boolean isComputeContextMethod(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        return isAssignable(lookup, javaRefType(invokeOp), ComputeContext.class);\n-    }\n-\n-    public static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n+    static JavaType javaReturnType(JavaOp.InvokeOp invokeOp) {\n@@ -273,1 +308,1 @@\n-    public static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n+    static boolean javaReturnTypeIsVoid(JavaOp.InvokeOp invokeOp) {\n@@ -277,1 +312,1 @@\n-    public static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+    static Method methodOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n@@ -284,8 +319,0 @@\n-\/*\n-    public static Optional<Class<?>> javaReturnClass(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n-        if (javaReturnType(op) instanceof ClassType classType) {\n-            return Optional.of((Class<?>) classTypeToTypeOrThrow(lookup, classType));\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n@@ -293,9 +320,0 @@\n-    public static boolean isIfaceAccessor(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp) {\n-        if (isIfaceBufferMethod(lookup, invokeOp) && !javaReturnType(invokeOp).equals(JavaType.VOID)) {\n-            Optional<Class<?>> optionalClazz = javaReturnClass(lookup, invokeOp);\n-            return optionalClazz.isPresent() && Buffer.class.isAssignableFrom(optionalClazz.get());\n-        } else {\n-            return false;\n-        }\n-    }\n-*\/\n@@ -303,1 +321,1 @@\n-    public static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n+    static Class<?> javaRefClassOrThrow(MethodHandles.Lookup lookup, JavaOp.InvokeOp op) {\n@@ -381,1 +399,1 @@\n-    public static boolean needsParenthesis(Op parent, Op child) {\n+    static boolean needsParenthesis(Op parent, Op child) {\n@@ -385,1 +403,1 @@\n-    public static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n+    static Op.Result lhsResult(JavaOp.BinaryOp binaryOp){\n@@ -389,1 +407,1 @@\n-    public static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n+    static Op.Result rhsResult(JavaOp.BinaryOp binaryOp){\n@@ -393,1 +411,1 @@\n-    public static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n+    static List<Op> ops(JavaOp.JavaConditionalOp javaConditionalOp, int idx){\n@@ -397,1 +415,1 @@\n-    public static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+    static List<Op> lhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n@@ -401,1 +419,1 @@\n-    public static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n+    static List<Op> rhsOps(JavaOp.JavaConditionalOp javaConditionalOp){\n@@ -405,1 +423,1 @@\n-    public static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n+    static Op.Result result(JavaOp.BinaryTestOp binaryTestOp, int idx){\n@@ -409,1 +427,1 @@\n-    public static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+    static Op.Result lhsResult(JavaOp.BinaryTestOp binaryTestOp){\n@@ -413,1 +431,1 @@\n-    public static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n+    static Op.Result rhsResult(JavaOp.BinaryTestOp binaryTestOp){\n@@ -417,1 +435,1 @@\n-    public static Op.Result result(JavaOp.ConvOp convOp){\n+    static Op.Result result(JavaOp.ConvOp convOp){\n@@ -421,1 +439,1 @@\n-    public static Op.Result result(CoreOp.ReturnOp returnOp){\n+    static Op.Result result(CoreOp.ReturnOp returnOp){\n@@ -425,1 +443,1 @@\n-    public static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n+    static Block block(JavaOp.ConditionalExpressionOp ternaryOp, int idx){\n@@ -429,1 +447,1 @@\n-    public static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+    static Block condBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n@@ -433,1 +451,1 @@\n-    public static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+    static Block thenBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n@@ -437,1 +455,1 @@\n-    public static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n+    static Block elseBlock(JavaOp.ConditionalExpressionOp ternaryOp){\n@@ -441,1 +459,1 @@\n-    public static String funcName(JavaOp.InvokeOp invokeOp) {\n+    static String funcName(JavaOp.InvokeOp invokeOp) {\n@@ -445,1 +463,1 @@\n-    public static Value operandOrNull(Op op, int idx) {\n+    static Value operandOrNull(Op op, int idx) {\n@@ -449,1 +467,1 @@\n-    public static Op.Result resultOrNull(Op op, int idx) {\n+    static Op.Result resultOrNull(Op op, int idx) {\n@@ -453,1 +471,1 @@\n-    public static Block block(JavaOp.ForOp forOp, int idx){\n+    static Block block(JavaOp.ForOp forOp, int idx){\n@@ -457,1 +475,1 @@\n-    public static Block mutateBlock(JavaOp.ForOp forOp){\n+    static Block mutateBlock(JavaOp.ForOp forOp){\n@@ -461,1 +479,1 @@\n-    public static Block loopBlock(JavaOp.ForOp forOp){\n+    static Block loopBlock(JavaOp.ForOp forOp){\n@@ -465,1 +483,1 @@\n-    public static Block condBlock(JavaOp.ForOp forOp){\n+    static Block condBlock(JavaOp.ForOp forOp){\n@@ -469,1 +487,1 @@\n-    public static Block initBlock(JavaOp.ForOp forOp){\n+    static Block initBlock(JavaOp.ForOp forOp){\n@@ -473,1 +491,1 @@\n-    public static Block block(JavaOp.WhileOp whileOp, int idx){\n+    static Block block(JavaOp.WhileOp whileOp, int idx){\n@@ -477,1 +495,1 @@\n-    public static Block condBlock(JavaOp.WhileOp whileOp){\n+    static Block condBlock(JavaOp.WhileOp whileOp){\n@@ -481,1 +499,1 @@\n-    public static Block loopBlock(JavaOp.WhileOp whileOp){\n+    static Block loopBlock(JavaOp.WhileOp whileOp){\n@@ -485,1 +503,1 @@\n-    public static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n+    static Block blockOrNull(JavaOp.IfOp ifOp, int idx ){\n@@ -489,5 +507,3 @@\n-    public static boolean fieldNameIs(JavaOp.FieldAccessOp.FieldAccessOp fieldAccessOp, String name) {\n-        return fieldName(fieldAccessOp).equals(name);\n-    }\n-    public static boolean fieldNameMatches(JavaOp.FieldAccessOp.FieldAccessOp fieldAccessOp, Pattern pattern) {\n-        return pattern.matcher(fieldName(fieldAccessOp)).matches();\n+    static JavaOp.FieldAccessOp fieldAccessOpNameMatches(CodeElement<?,?> codeElement, Predicate<String> namePredicate) {\n+        return codeElement instanceof JavaOp.FieldAccessOp fieldAccessOp\n+                && namePredicate.test(fieldName(fieldAccessOp))?fieldAccessOp:null;\n@@ -496,1 +512,2 @@\n-    public static void inspectNewLevel(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n+\n+    static void inspectNewLevelWhy(Class<?> interfaceClass, Set<Class<?>> interfaceSet) {\n@@ -500,1 +517,25 @@\n-                    .forEach(superInterface -> inspectNewLevel(superInterface, interfaceSet));\n+                    .forEach(superInterface -> inspectNewLevelWhy(superInterface, interfaceSet));\n+        }\n+    }\n+    static boolean  isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue, Predicate<String> namePredicate) {\n+        \/\/ is Assignble\n+        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n+            TypeElement typeElement = varLoadOp.resultType();\n+            Set<Class<?>> interfaces = Set.of();\n+            try {\n+                Class<?> aClass = Class.forName(typeElement.toString());\n+                interfaces = OpTk.inspectAllInterfacesWhy(aClass);\n+            } catch (ClassNotFoundException _) {\n+            }\n+            return interfaces.contains(_V.class) && OpTk.isMethod(invokeOp, namePredicate);\n+        }\n+        return false;\n+    }\n+    static boolean isVectorOperation(JavaOp.InvokeOp invokeOp, boolean laneOk) {\n+        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n+        Set<Class<?>> interfaces;\n+        try {\n+            Class<?> aClass = Class.forName(typeElement);\n+            interfaces = OpTk.inspectAllInterfacesWhy(aClass);\n+        } catch (ClassNotFoundException _) {\n+            return false;\n@@ -502,0 +543,1 @@\n+        return interfaces.contains(_V.class) && laneOk;\n@@ -504,1 +546,1 @@\n-    public static Set<Class<?>> inspectAllInterfaces(Class<?> klass) {\n+    static Set<Class<?>> inspectAllInterfacesWhy(Class<?> klass) {\n@@ -508,1 +550,1 @@\n-                    .forEach(interfaceClass -> inspectNewLevel(interfaceClass, interfaceSet));\n+                    .forEach(interfaceClass -> inspectNewLevelWhy(interfaceClass, interfaceSet));\n@@ -514,10 +556,0 @@\n-    public static boolean isDeviceType(JavaOp.InvokeOp invokeOp) {\n-        TypeElement typeElement = invokeOp.resultType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        return interfaces.contains(DeviceType.class);\n-    }\n@@ -525,1 +557,4 @@\n-    public static boolean isInvokeDescriptorSubtypeOf(JavaOp.InvokeOp invokeOp, Class<?> klass) {\n+    static boolean isInvokeDescriptorSubtypeOf(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Class<?> klass) {\n+\n+        var wouldReturn =  (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt,klass));\n+\n@@ -530,1 +565,1 @@\n-            interfaces = inspectAllInterfaces(aClass);\n+            interfaces = inspectAllInterfacesWhy(aClass);\n@@ -533,1 +568,6 @@\n-        return interfaces.contains(klass);\n+        var butReturns =  interfaces.contains(klass);\n+        if (butReturns != wouldReturn){\n+           \/\/ System.out.print(\"isInvokeDescriptorSubtypeOf\");\n+        }\n+        return butReturns;\n+\n@@ -536,1 +576,4 @@\n-    public static boolean isInvokeDescriptorSubtypeOfAnyMatch(JavaOp.InvokeOp invokeOp, List<Class<?>> klasses) {\n+    static boolean isInvokeDescriptorSubtypeOfAnyMatch(MethodHandles.Lookup lookup,JavaOp.InvokeOp invokeOp, Class<?> ... klasses) {\n+\n+        boolean wouldReturn=  (invokeOp.resultType() instanceof JavaType jt && isAssignable(lookup, jt,klasses));\n+       boolean butReturns = false;\n@@ -541,1 +584,1 @@\n-            interfaces = inspectAllInterfaces(aClass);\n+            interfaces = inspectAllInterfacesWhy(aClass);\n@@ -546,1 +589,1 @@\n-                return true;\n+                butReturns =  true;\n@@ -549,1 +592,4 @@\n-        return false;\n+        if (butReturns != wouldReturn){\n+         \/\/   System.out.print(\"isInvokeDescriptorSubtypeOfAnyMatch\");\n+        }\n+        return butReturns;\n@@ -552,1 +598,1 @@\n-    public static PrimitiveType asPrimitiveResultOrNull(Value v){\n+    static PrimitiveType asPrimitiveResultOrNull(Value v){\n@@ -560,1 +606,1 @@\n-    public static boolean isPrimitiveResult(Value v){\n+    static boolean isPrimitiveResult(Value v){\n@@ -564,1 +610,1 @@\n-    public static Op.Result asResultOrThrow(Value value) {\n+    static Op.Result asResultOrThrow(Value value) {\n@@ -572,1 +618,13 @@\n-    public  record CallSite(Class<?> clazz,String methodName, boolean tracing){\n+    static Stream<Op.Result> operandsAsResults(CodeElement<?,?> codeElement) {\n+        return codeElement instanceof Op ?\n+                ((Op)codeElement).operands().stream().filter(o-> o instanceof Op.Result).map(o->(Op.Result)o)\n+                :Stream.of();\n+    }\n+    static Op.Result operandAsResult(CodeElement<?,?> codeElement, int n) {\n+        return codeElement instanceof Op op  && op.operands().size()>n && op.operands().get(n) instanceof Op.Result result?result:null;\n+    }\n+    static Op opFromOperandAsResult(CodeElement<?,?> codeElement, int n) {\n+        return operandAsResult(codeElement,n) instanceof Op.Result result?result.op():null;\n+    }\n+\n+      record CallSite(Class<?> clazz,String methodName, boolean tracing){\n@@ -576,0 +634,8 @@\n+        public static CallSite of(Class<?> clazz) {\n+            for (StackTraceElement ste : Thread.currentThread().getStackTrace()) {\n+                if (ste.getClassName().equals(clazz.getName())) {\n+                    new CallSite(ste.getClass(),ste.getMethodName(), Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+                }\n+            }\n+            return new CallSite(clazz,\"???\", Boolean.getBoolean(\"TRACE_CALLSITES\"));\n+        }\n@@ -581,1 +647,1 @@\n-    public static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n+    static CoreOp.FuncOp lower(CallSite callSite, CoreOp.FuncOp funcOp) {\n@@ -587,1 +653,1 @@\n-    public static Stream<CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n+    static Stream<CodeElement<?,?>> elements(CallSite callSite, CoreOp.FuncOp funcOp) {\n@@ -593,0 +659,12 @@\n+    static <T extends Op> Stream<T> ops(CallSite callSite, CoreOp.FuncOp funcOp,\n+                                             Predicate<CodeElement<?,?>> predicate,\n+                                             Function<CodeElement<?,?>,T> mapper\n+    ) {\n+        if (callSite.tracing){\n+            System.out.println(callSite);\n+        }\n+        return funcOp.elements().filter(predicate).map(mapper);\n+    }\n+    static <T> Stream<T> opstream(CoreOp.FuncOp funcOp, Function<CodeElement<?,?>,T> mapper) {\n+        return funcOp.elements().map(mapper).filter(Objects::nonNull);\n+    }\n@@ -594,1 +672,2 @@\n-    public static CoreOp.FuncOp SSATransformLower(CallSite callSite, CoreOp.FuncOp funcOp){\n+\n+    static CoreOp.FuncOp SSATransformLower(CallSite callSite, CoreOp.FuncOp funcOp){\n@@ -600,1 +679,1 @@\n-    public static CoreOp.FuncOp SSATransform(CallSite callSite, CoreOp.FuncOp funcOp){\n+    static CoreOp.FuncOp SSATransform(CallSite callSite, CoreOp.FuncOp funcOp){\n@@ -607,1 +686,1 @@\n-    public static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, Predicate<Op> predicate, CodeTransformer CodeTransformer) {\n@@ -624,1 +703,1 @@\n-    public static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n+    static CoreOp.FuncOp transform(CallSite callSite, CoreOp.FuncOp funcOp, CodeTransformer CodeTransformer) {\n@@ -631,1 +710,1 @@\n-    public record  OpMap(CoreOp.FuncOp fromFuncOp, CoreOp.FuncOp toFuncOp,  Map<Op,Op> fromToOpMap){}\n+     record  OpMap(CoreOp.FuncOp fromFuncOp, CoreOp.FuncOp toFuncOp,  Map<Op,Op> fromToOpMap){}\n@@ -633,1 +712,1 @@\n-    public  static <InOp extends Op, OutOp extends Op> OutOp replaceOp(Block.Builder blockBuilder, InOp inOp,java.util.function.Function<List<Value>, OutOp> factory) {\n+    static <InOp extends Op, OutOp extends Op> OutOp replaceOp(Block.Builder blockBuilder, InOp inOp,java.util.function.Function<List<Value>, OutOp> factory) {\n@@ -644,1 +723,1 @@\n-    public static < OutOp extends Op> OpMap simpleOpMappingTransform(OpTk.CallSite here, CoreOp.FuncOp fromFuncOp, Predicate<Op> opPredicate,\n+    static < OutOp extends Op> OpMap simpleOpMappingTransform(OpTk.CallSite here, CoreOp.FuncOp fromFuncOp, Predicate<Op> opPredicate,\n@@ -661,1 +740,1 @@\n-    public record ParamVar(CoreOp.VarOp varOp, Block.Parameter parameter, CoreOp.FuncOp funcOp) {\n+     record ParamVar(CoreOp.VarOp varOp, Block.Parameter parameter, CoreOp.FuncOp funcOp) {\n@@ -664,1 +743,1 @@\n-    public static ParamVar paramVar(CoreOp.VarOp varOp) {\n+    static ParamVar paramVar(CoreOp.VarOp varOp) {\n@@ -670,1 +749,1 @@\n-    public static boolean returnIsVoid(JavaOp.InvokeOp invokeOp){\n+    static boolean returnIsVoid(JavaOp.InvokeOp invokeOp){\n@@ -684,1 +763,1 @@\n-    public static boolean needExtraParenthesis(JavaOp.InvokeOp invokeOp) {\n+    static boolean needExtraParenthesis(JavaOp.InvokeOp invokeOp) {\n@@ -696,0 +775,35 @@\n+\n+\n+    static boolean isMethod(JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+        return namePredicate.test(invokeOp.invokeDescriptor().name());\n+    }\n+    static boolean isIfaceBufferInvokeOpWithName(MethodHandles.Lookup lookup, JavaOp.InvokeOp invokeOp, Predicate<String> namePredicate) {\n+        return OpTk.isIfaceBufferMethod(lookup, invokeOp) && OpTk.isMethod(invokeOp, namePredicate)\n+                || OpTk.isHatType(lookup, invokeOp) && OpTk.isMethod(invokeOp, namePredicate);\n+    }\n+\n+    static  Class<?> typeElementToClass(MethodHandles.Lookup lookup,TypeElement type) {\n+        class PrimitiveHolder {\n+            static final Map<PrimitiveType, Class<?>> primitiveToClass = Map.of(\n+                    JavaType.BYTE, byte.class,\n+                    JavaType.SHORT, short.class,\n+                    JavaType.INT, int.class,\n+                    JavaType.LONG, long.class,\n+                    JavaType.FLOAT, float.class,\n+                    JavaType.DOUBLE, double.class,\n+                    JavaType.CHAR, char.class,\n+                    JavaType.BOOLEAN, boolean.class\n+            );\n+        }\n+        try {\n+            if (type instanceof PrimitiveType primitiveType) {\n+                return PrimitiveHolder.primitiveToClass.get(primitiveType);\n+            } else if (type instanceof ClassType classType) {\n+                return ((Class<?>) classType.resolve(lookup));\n+            } else {\n+                throw new IllegalArgumentException(\"given type cannot be converted to class\");\n+            }\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"given type cannot be converted to class\");\n+        }\n+    }\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/OpTk.java","additions":251,"deletions":137,"binary":false,"changes":388,"status":"modified"},{"patch":"@@ -0,0 +1,373 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package hat.optools;\n+\n+import jdk.incubator.code.Block;\n+import jdk.incubator.code.CodeElement;\n+import jdk.incubator.code.CodeTransformer;\n+import jdk.incubator.code.Op;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.core.CoreOp;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+\n+public class Trxfmr {\n+    interface HATTransformerCarrier{\n+        Trxfmr hatTransformer();\n+    }\n+    interface CursorCarrier<T extends Cursor>{\n+        T cursor();\n+    }\n+\n+    public interface  Walker extends HATTransformerCarrier {\n+        void op(Op op);\n+        Op op();\n+        void funcOp(CoreOp.FuncOp funcOp);\n+        CoreOp.FuncOp funcOp();\n+              class Impl implements  HATTransformerCarrier,Walker {\n+                private final Trxfmr trxfmr;\n+                public Trxfmr hatTransformer() {\n+                    return trxfmr;\n+                }\n+                private Op op;\n+                private CoreOp.FuncOp funcOp;\n+                @Override\n+                public void op(Op op) {\n+                    this.op = op;\n+                }\n+\n+                @Override\n+                public Op op() {\n+                    return this.op;\n+                }\n+\n+                @Override\n+                public void funcOp(CoreOp.FuncOp funcOp) {\n+                    this.funcOp = funcOp;\n+                }\n+\n+                @Override\n+                public CoreOp.FuncOp funcOp() {\n+                    return this.funcOp;\n+                }\n+\n+                Impl(Trxfmr trxfmr, CoreOp.FuncOp funcOp) {\n+                    this.trxfmr = trxfmr;\n+                    this.funcOp = funcOp;\n+                }\n+            }\n+        static Walker of(Trxfmr trxfmr, CoreOp.FuncOp funcOp){\n+            return new Impl(trxfmr,funcOp);\n+        }\n+    }\n+\n+    public interface  Cursor extends HATTransformerCarrier, Walker {\n+        void builder(Block.Builder builder);\n+        Block.Builder builder();\n+        void handled(boolean handled);\n+        boolean handled();\n+        Op.Result replace(Op op, Consumer<Mapper<?>> mapperConsumer);\n+        default Op.Result replace(Op op){\n+            return replace(op, (m)->{});\n+        }\n+         default void remove(Consumer<Mapper<?>> mapperConsumer) {\n+            mapperConsumer.accept(Mapper.of(this));\n+        }\n+        default void remove() {\n+            remove(_->{});\n+        }\n+        default Op.Result remove(Op op){\n+            return replace(op, (m)->{});\n+        }\n+        static Cursor of(Trxfmr trxfmr, CoreOp.FuncOp funcOp, Block.Builder builder, Op op){\n+            class Impl extends Walker.Impl implements Cursor {\n+                private Block.Builder builder;\n+                private boolean handled;\n+                @Override\n+                public void handled(boolean handled) {\n+                    this.handled = handled;\n+                }\n+\n+                @Override\n+                public boolean  handled() {\n+                    return this.handled;\n+                }\n+\n+                @Override\n+                public void builder(Block.Builder builder) {\n+                    this.builder = builder;\n+                }\n+\n+                @Override\n+                public Block.Builder builder() {\n+                    return this.builder;\n+                }\n+                @Override\n+                public Op.Result replace(Op replacement, Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+\n+                    Op.Result result = builder().op(OpTk.copyLocation(op(), replacement));\n+                    trxfmr.opToOp(op(),result.op());\n+                    mapperConsumer.accept(Mapper.of(this).map(op().result(),result));\n+                    return result;\n+                }\n+                @Override\n+                public void remove( Consumer<Mapper<?>> mapperConsumer) {\n+                    handled(true);\n+                    mapperConsumer.accept(Mapper.of(this));\n+                }\n+                Impl(Trxfmr hatTransformer, CoreOp.FuncOp funcOp, Block.Builder builder, Op op) {\n+                    super(hatTransformer,funcOp);\n+                    builder(builder);\n+                    op(op);\n+                }\n+            }\n+            return new Impl(trxfmr,funcOp, builder,op);\n+        }\n+    }\n+\n+    public interface Selector<T extends Selector<T>> extends HATTransformerCarrier{\n+        default T  select(Op...ops){\n+            hatTransformer().selected.addAll(List.of(ops));\n+            return (T)this;\n+        }\n+       static Selector<?> of(Trxfmr trxfmr){\n+            record SelectorImpl(Trxfmr hatTransformer) implements Selector<SelectorImpl>{}\n+            return  new SelectorImpl(trxfmr);\n+        }\n+    }\n+\n+\n+    public interface Mapper<T extends Mapper<T>> extends CursorCarrier{\n+        default  T map(Value from, Value to) {\n+            cursor().builder().context().mapValue(from, to);\n+            return (T)this;\n+        }\n+        default  T map(Op fromOp, Value to) {\n+            map(fromOp.result(), to);\n+            return (T)this;\n+        }\n+        default  T mapOperand(Op fromOp, List<Value> operands, int n) {\n+           return map(fromOp,operands.get(n));\n+        }\n+        default  T mapOperands(Op fromOp, List<Value> operands) {\n+            operands.forEach(v -> {\n+                map(fromOp,v);\n+            });\n+            return (T)this;\n+        }\n+        default  T mapOperands(Op fromOp, Op to) {\n+            return mapOperands(fromOp,to.operands());\n+        }\n+        default  T mapOperand(Op fromOp, Op to, int index) {\n+            return map(fromOp,to.operands().get(index));\n+        }\n+        static Mapper<?> of(Cursor cursor){\n+            record MapperImpl(Cursor cursor) implements Mapper<MapperImpl> { }\n+            return new MapperImpl(cursor);\n+        }\n+    }\n+\n+    public final Set<Op> selected = new LinkedHashSet<>();\n+    public final Map<Op, Op> opmap = new HashMap<>();\n+    public final OpTk.CallSite callSite;\n+    public CoreOp.FuncOp funcOp;\n+\n+    public CoreOp.FuncOp funcOp(){\n+        return funcOp;\n+    }\n+    public CoreOp.FuncOp funcOp(CoreOp.FuncOp funcOp){\n+        return this.funcOp=funcOp;\n+    }\n+\n+    public Trxfmr(OpTk.CallSite callSite, CoreOp.FuncOp funcOp) {\n+        this.callSite = callSite;\n+        this.funcOp =  funcOp;\n+        if (callSite!=null && callSite.tracing()) {\n+            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() + \"]: \" + System.lineSeparator() + funcOp.toText());\n+        }\n+    }\n+    public Trxfmr select(Predicate<Op> codeElementPredicate, BiConsumer<Selector<?>,Op> selectorConsumer) {\n+        Selector<?> selector = Selector.of(this);\n+        funcOp().elements().filter(ce->ce instanceof Op).map(ce->(Op)ce).filter(codeElementPredicate).forEach(op->\n+                selectorConsumer.accept(selector,op)\n+        );\n+        return this;\n+    }\n+\n+\n+    public Trxfmr done() {\n+        if (callSite!=null && callSite.tracing()) {\n+            IO.println(\"[INFO] Code model after [\" + callSite.clazz().getSimpleName() + \"#\" + callSite.methodName() + \"]: \" + System.lineSeparator()\n+                    +funcOp().toText());\n+        }\n+        return this;\n+    }\n+\n+\n+\n+    private void opToOp(Op from, Op to){\n+        opmap.put(from,to);\n+    }\n+\n+    private void update(){\n+        opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n+    }\n+\n+\n+    public Trxfmr transform(Predicate<Op> predicate, Consumer<Cursor> cursorConsumer) {\n+        if (callSite != null && callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+\n+\n+        var newFuncOp = funcOp().transform((blockBuilder, op) -> {\n+            Cursor cursor = Cursor.of(this, funcOp, blockBuilder,op);\n+            cursor.builder(blockBuilder);\n+            cursor.op(op);\n+            cursor.handled(false);\n+            if ((selected.isEmpty() || selected.contains(op)) &&  predicate.test(op)) {\n+                cursorConsumer.accept(cursor);\n+                if (!cursor.handled()){\n+\n+                    opToOp(op,cursor.builder().op(op).op());\n+                }\n+            } else {\n+                opToOp(op,cursor.builder().op(op).op());\n+            }\n+            return blockBuilder;\n+        });\n+        funcOp(newFuncOp);\n+        update();\n+        return this;\n+    }\n+    public Trxfmr transform(Edge.Selector<?,?> selector,Consumer<Cursor> transformer) {\n+        return transform(selector::contains,transformer);\n+    }\n+    public Trxfmr transform(Consumer<Cursor> transformer) {\n+        return transform(_->true,transformer);\n+    }\n+\n+    public Trxfmr transform(Predicate<Op> predicate, CodeTransformer codeTransformer) {\n+        if (callSite != null && callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        var currentFuncOp = funcOp();\n+        var newFuncOp = currentFuncOp.transform((blockBuilder, op) -> {\n+            Cursor cursor = Cursor.of(this,funcOp,blockBuilder,op);\n+\n+            if ((selected.isEmpty() || selected.contains(op)) &&  predicate.test(op)) {\n+                codeTransformer.acceptOp(cursor.builder(),op);\n+            } else {\n+                opToOp(op,cursor.builder().op(op).op());\n+            }\n+            return cursor.builder();\n+        });\n+        opmap.put(currentFuncOp, newFuncOp);\n+        funcOp(newFuncOp);\n+        opmap.forEach((from, to) -> { selected.remove(from);selected.add(to);});\n+        return this;\n+    }\n+\n+    public Trxfmr transform(CodeTransformer codeTransformer ) {\n+        if (callSite != null && callSite.tracing()) {\n+            System.out.println(callSite);\n+        }\n+        funcOp(funcOp().transform(codeTransformer));\n+        return this;\n+    }\n+\n+\n+    public interface Edge<F extends Op, T extends Op> {\n+        F f();\n+\n+        T t();\n+\n+        Set<Op> ops();\n+\n+        static Edge<JavaOp.FieldAccessOp.FieldLoadOp, CoreOp.VarAccessOp.VarLoadOp> kernelContextFieldVarLoad(\n+                MethodHandles.Lookup lookup,JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp, Predicate<String> fieldNamePredicate) {\n+            record FieldVarLoadEdge<\n+                    F extends JavaOp.FieldAccessOp.FieldLoadOp,\n+                    T extends CoreOp.VarAccessOp.VarLoadOp>(F f, T t, Set<Op> ops) implements Edge<F, T> {\n+            }\n+            return (\n+                    OpTk.fieldAccessOpNameMatches(fieldLoadOp, fieldNamePredicate) instanceof JavaOp.FieldAccessOp.FieldLoadOp\n+                            && OpTk.opFromOperandAsResult(fieldLoadOp, 0) instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp\n+                            && OpTk.isVarAccessFromKernelContextFieldOp(lookup,varLoadOp))\n+                    ? new FieldVarLoadEdge<>(fieldLoadOp, varLoadOp, Set.of(fieldLoadOp, varLoadOp)) : null;\n+        }\n+\n+\n+         class Selector<F extends Op, T extends Op> {\n+            Map<F, Edge<F, T>> fromMap = new HashMap<>();\n+            Map<T, Edge<F, T>> toMap = new HashMap<>();\n+\n+            public Selector<F, T> add(Edge<F, T> edge) {\n+                fromMap.put(edge.f(), edge);\n+                toMap.put(edge.t(), edge);\n+                return this;\n+            }\n+\n+            Edge<F, T> from(F f) {\n+                return fromMap.get(f);\n+            }\n+\n+            Edge<F, T> to(T t) {\n+                return toMap.get(t);\n+            }\n+\n+            Predicate<Op> predicate =op->fromMap.containsKey((F) op) || toMap.containsKey((T) op);\n+\n+            public boolean contains(Op op) {\n+                return predicate.test(op);\n+            }\n+\n+             public Selector<F, T> select(CoreOp.FuncOp funcOp, Function<CodeElement<?,?>,Edge<F,T>> mapper) {\n+                 OpTk.opstream(funcOp,mapper).forEach(e->this.add((Edge<F, T>) e));\n+                 return this;\n+             }\n+\n+             public CoreOp.FuncOp transform(CoreOp.FuncOp funcOp, Consumer<Cursor> c) {\n+                 return new Trxfmr(OpTk.CallSite.of(this.getClass()), funcOp)\n+                         .transform(this.predicate,c).done().funcOp();\n+             }\n+         }\n+    }\n+\n+\n+}\n","filename":"hat\/core\/src\/main\/java\/hat\/optools\/Trxfmr.java","additions":373,"deletions":0,"binary":false,"changes":373,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.code.Op;\n@@ -31,1 +30,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -36,1 +34,0 @@\n-\n@@ -39,19 +36,2 @@\n-    default boolean isMethodFromHatKernelContext(JavaOp.InvokeOp invokeOp) {\n-        String kernelContextCanonicalName = hat.KernelContext.class.getName();\/\/ URRH Strings\n-        return invokeOp.invokeDescriptor().refType().toString().equals(kernelContextCanonicalName);\n-    }\n-\n-    default boolean isMethod(JavaOp.InvokeOp invokeOp, String methodName) {\n-        return invokeOp.invokeDescriptor().name().equals(methodName);\n-    }\n-\n-    default boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp, String methodName) {\n-        if (OpTk.isIfaceBufferMethod(accelerator().lookup, invokeOp) && isMethod(invokeOp, methodName)) {\n-            return true;\n-        } else return OpTk.isHatType(accelerator().lookup, invokeOp) && isMethod(invokeOp, methodName);\n-    }\n-\n-    default boolean isKernelContextInvokeWithName(Op op, String methodName) {\n-        return op instanceof JavaOp.InvokeOp invokeOp\n-                && isMethodFromHatKernelContext(invokeOp)\n-                && isMethod(invokeOp,methodName);\n+    default boolean tracing(){\n+        return accelerator().backend.config().showCompilationPhases();\n@@ -61,1 +41,1 @@\n-        if (accelerator().backend.config().showCompilationPhases()) {\n+        if (tracing()) {\n@@ -67,1 +47,1 @@\n-        if (accelerator().backend.config().showCompilationPhases()) {\n+        if (tracing()) {\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialect.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,11 +45,1 @@\n-public class HATDialectifyArrayViewPhase implements HATDialect {\n-\n-    protected final Accelerator accelerator;\n-    @Override\n-    public Accelerator accelerator() {\n-        return this.accelerator;\n-    }\n-\n-    public HATDialectifyArrayViewPhase(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n-    }\n+public record HATDialectifyArrayViewPhase(Accelerator accelerator) implements HATDialect {\n@@ -154,15 +144,15 @@\n-                        \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                        \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                        \/\/     List<Value> operands = new ArrayList<>();\n-                        \/\/     operands.add(info.buffer);\n-                        \/\/     operands.addAll(info.indices);\n-                        \/\/     HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n-                        \/\/             arrayLoadOp.resultType(),\n-                        \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n-                        \/\/             info.indices(),\n-                        \/\/             bb.context().getValues(operands)\n-                        \/\/     );\n-                        \/\/     ptrLoadOp.setLocation(arrayLoadOp.location());\n-                        \/\/     Op.Result res = bb.op(ptrLoadOp);\n-                        \/\/     bb.context().mapValue(arrayLoadOp.result(), res);\n-                        \/\/ }\n+                            \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                            \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                            \/\/     List<Value> operands = new ArrayList<>();\n+                            \/\/     operands.add(info.buffer);\n+                            \/\/     operands.addAll(info.indices);\n+                            \/\/     HATPtrLoadOp ptrLoadOp = new HATPtrLoadOp(\n+                            \/\/             arrayLoadOp.resultType(),\n+                            \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                            \/\/             info.indices(),\n+                            \/\/             bb.context().getValues(operands)\n+                            \/\/     );\n+                            \/\/     ptrLoadOp.setLocation(arrayLoadOp.location());\n+                            \/\/     Op.Result res = bb.op(ptrLoadOp);\n+                            \/\/     bb.context().mapValue(arrayLoadOp.result(), res);\n+                            \/\/ }\n@@ -190,1 +180,1 @@\n-                                Class<?> storedClass = typeElementToClass(arrayLoadOp.result().type());\n+                                Class<?> storedClass = OpTk.typeElementToClass(accelerator.lookup,arrayLoadOp.result().type());\n@@ -199,1 +189,1 @@\n-                                Class<?> storedClass = typeElementToClass(arrayLoadOp.result().type());\n+                                Class<?> storedClass = OpTk.typeElementToClass(accelerator.lookup,arrayLoadOp.result().type());\n@@ -229,18 +219,18 @@\n-                        \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n-                        \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n-                        \/\/     List<Value> operands = new ArrayList<>();\n-                        \/\/     operands.add(info.buffer());\n-                        \/\/     \/\/ operands.add(arrayStoreOp.operands().getLast());\n-                        \/\/     operands.addAll(info.indices);\n-                        \/\/     HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n-                        \/\/             arrayStoreOp.resultType(),\n-                        \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n-                        \/\/             info.indices(),\n-                        \/\/             getValue(bb, arrayStoreOp.operands().getLast()),\n-                        \/\/             bb.context().getValues(operands)\n-                        \/\/             \/\/ bb.context().getValues(List.of(info.buffer(), arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n-                        \/\/     );\n-                        \/\/     ptrLoadOp.setLocation(arrayStoreOp.location());\n-                        \/\/     Op.Result res = bb.op(ptrLoadOp);\n-                        \/\/     bb.context().mapValue(arrayStoreOp.result(), res);\n-                        \/\/ }\n+                            \/\/ } else if (((ArrayType) firstOperand(op).type()).dimensions() == 1) { \/\/ we only use the last array load\n+                            \/\/     ArrayAccessInfo info = arrayAccessInfo(op.result(), replaced);\n+                            \/\/     List<Value> operands = new ArrayList<>();\n+                            \/\/     operands.add(info.buffer());\n+                            \/\/     \/\/ operands.add(arrayStoreOp.operands().getLast());\n+                            \/\/     operands.addAll(info.indices);\n+                            \/\/     HATPtrStoreOp ptrLoadOp = new HATPtrStoreOp(\n+                            \/\/             arrayStoreOp.resultType(),\n+                            \/\/             (Class<Buffer>) OpTk.classTypeToTypeOrThrow(l, (ClassType) info.buffer().type()),\n+                            \/\/             info.indices(),\n+                            \/\/             getValue(bb, arrayStoreOp.operands().getLast()),\n+                            \/\/             bb.context().getValues(operands)\n+                            \/\/             \/\/ bb.context().getValues(List.of(info.buffer(), arrayStoreOp.operands().getLast(), arrayStoreOp.operands().get(1)))\n+                            \/\/     );\n+                            \/\/     ptrLoadOp.setLocation(arrayStoreOp.location());\n+                            \/\/     Op.Result res = bb.op(ptrLoadOp);\n+                            \/\/     bb.context().mapValue(arrayStoreOp.result(), res);\n+                            \/\/ }\n@@ -424,1 +414,1 @@\n-                        || OpTk.isAssignable(accelerator.lookup, javaType, DeviceType.class))));\n+                                || OpTk.isAssignable(accelerator.lookup, javaType, DeviceType.class))));\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyArrayViewPhase.java","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import hat.Config;\n@@ -31,5 +30,0 @@\n-import jdk.incubator.code.Block;\n-import jdk.incubator.code.CodeContext;\n-import jdk.incubator.code.CodeElement;\n-import jdk.incubator.code.Op;\n-import jdk.incubator.code.Value;\n@@ -37,1 +31,0 @@\n-import jdk.incubator.code.dialect.java.JavaOp;\n@@ -39,17 +32,1 @@\n-import java.util.List;\n-import java.util.Set;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-public class HATDialectifyBarrierPhase implements HATDialect {\n-\n-    protected final Accelerator accelerator;\n-    @Override  public Accelerator accelerator(){\n-        return this.accelerator;\n-    }\n-    public HATDialectifyBarrierPhase(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n-    }\n+public record HATDialectifyBarrierPhase(Accelerator accelerator) implements HATDialect {\n@@ -59,1 +36,1 @@\n-        var here =  OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n+        var here = OpTk.CallSite.of(HATDialectifyBarrierPhase.class, \"apply\");\n@@ -66,1 +43,2 @@\n-                \/* filter op                    *\/ op->isKernelContextInvokeWithName(op,HATBarrierOp.INTRINSIC_NAME),\n+                \/* filter op                    *\/ ce -> OpTk.isKernelContextInvokeOp(accelerator.lookup, ce,\n+                                                    invokeOp->invokeOp.invokeDescriptor().name().equals(HATBarrierOp.INTRINSIC_NAME)),\n@@ -69,1 +47,1 @@\n-        after(here,opMap.toFuncOp());\n+        after(here, opMap.toFuncOp());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyBarrierPhase.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -60,3 +60,1 @@\n-public class HATDialectifyFP16Phase implements HATDialect {\n-\n-    private final Accelerator accelerator;\n+public record HATDialectifyFP16Phase(Accelerator accelerator) implements HATDialect {\n@@ -76,4 +74,0 @@\n-    public HATDialectifyFP16Phase(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n-    }\n-\n@@ -212,2 +206,2 @@\n-        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Ops\" );\n-        before(here,funcOp);\n+        var here = OpTk.CallSite.of(this.getClass(), \"dialectifyF16Ops\");\n+        before(here, funcOp);\n@@ -248,1 +242,1 @@\n-        after(here,funcOp);\n+        after(here, funcOp);\n@@ -254,1 +248,1 @@\n-        before(here,funcOp);\n+        before(here, funcOp);\n@@ -302,1 +296,1 @@\n-        before(here,funcOp);\n+        before(here, funcOp);\n@@ -312,7 +306,6 @@\n-                                if (result.op() instanceof CoreOp.VarOp varOp) {\n-                                    consumer.accept(varOp);\n-                                    consumer.accept(invokeOp);\n-                                    ReducedFloatType reducedFloatType = categorizeReducedFloat(invokeOp);\n-                                    reducedFloatsType.put(varOp, reducedFloatType);\n-                                    reducedFloatsType.put(invokeOp, reducedFloatType);\n-                                }\n+                            if (result.op() instanceof CoreOp.VarOp varOp) {\n+                                consumer.accept(varOp);\n+                                consumer.accept(invokeOp);\n+                                ReducedFloatType reducedFloatType = categorizeReducedFloat(invokeOp);\n+                                reducedFloatsType.put(varOp, reducedFloatType);\n+                                reducedFloatsType.put(invokeOp, reducedFloatType);\n@@ -321,0 +314,1 @@\n+                        }\n@@ -341,1 +335,1 @@\n-        before(here,funcOp);\n+        before(here, funcOp);\n@@ -348,1 +342,1 @@\n-                        if ((isMethod(invokeOp, \"f16ToFloat\") || isMethod(invokeOp, \"bfloat162float\"))\n+                        if ((OpTk.isMethod(invokeOp, n->n.equals(\"f16ToFloat\")||n.equals(\"bfloat162float\")))\n@@ -397,5 +391,0 @@\n-\n-    @Override\n-    public Accelerator accelerator() {\n-        return accelerator;\n-    }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyFP16Phase.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -107,2 +107,1 @@\n-                        .filter(r->r.op() instanceof CoreOp.VarOp)\n-                        .map(r->(CoreOp.VarOp)r.op())\n+                        .filter(r->r.op() instanceof CoreOp.VarOp).map(r->(CoreOp.VarOp)r.op())\n@@ -110,1 +109,1 @@\n-                                blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n+                            blockBuilder.context().mapValue(invokeOp.result(), blockBuilder.op(factory(blockBuilder, varOp, invokeOp)))\n@@ -113,1 +112,1 @@\n-                blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n+                      blockBuilder.context().mapValue(varOp.result(), blockBuilder.context().getValue(varOp.operands().getFirst()));\n@@ -130,2 +129,2 @@\n-        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp){\n-            if (isIfaceBufferInvokeWithName(invokeOp, HATPrivateVarOp.INTRINSIC_NAME)) {\n+        protected boolean isIfaceBufferInvokeWithName(JavaOp.InvokeOp invokeOp) {\n+            if (OpTk.isIfaceBufferInvokeOpWithName(accelerator.lookup, invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))) {\n@@ -134,1 +133,2 @@\n-                return isMethod(invokeOp, HATPrivateVarOp.INTRINSIC_NAME) && OpTk.isDeviceType(invokeOp);\n+                return OpTk.isMethod(invokeOp, n->n.equals(HATPrivateVarOp.INTRINSIC_NAME))\n+                        && OpTk.isAssignable(accelerator.lookup,invokeOp.invokeDescriptor().refType(),DeviceType.class);\n@@ -160,1 +160,1 @@\n-            if (isIfaceBufferInvokeWithName(invokeOp, HATLocalVarOp.INTRINSIC_NAME)) {\n+            if (OpTk.isIfaceBufferInvokeOpWithName(accelerator.lookup,invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))) {\n@@ -163,1 +163,3 @@\n-                return (isMethod(invokeOp, HATLocalVarOp.INTRINSIC_NAME) &&  OpTk.isDeviceType(invokeOp));\n+                return (OpTk.isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+                        && invokeOp.resultType() instanceof JavaType javaType &&\n+                        OpTk.isAssignable(accelerator.lookup,javaType,DeviceType.class));\n@@ -189,5 +191,4 @@\n-            if (isIfaceBufferInvokeWithName(invokeOp, HATLocalVarOp.INTRINSIC_NAME)) {\n-                return true;\n-            } else {\n-                return (isMethod(invokeOp, HATLocalVarOp.INTRINSIC_NAME) &&  OpTk.isDeviceType(invokeOp));\n-            }\n+            return OpTk.isIfaceBufferInvokeOpWithName(accelerator.lookup,invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+               || (OpTk.isMethod(invokeOp, n->n.equals(HATLocalVarOp.INTRINSIC_NAME))\n+                    && invokeOp.resultType() instanceof JavaType javaType &&\n+                    OpTk.isAssignable(accelerator.lookup,javaType,DeviceType.class));\n@@ -196,1 +197,1 @@\n-        private boolean isDeviceTypeReservedMethod(JavaOp.InvokeOp invokeOp){\n+         private boolean isDeviceTypeReservedMethod(JavaOp.InvokeOp invokeOp){\n@@ -201,1 +202,1 @@\n-            return OpTk.isInvokeDescriptorSubtypeOf(invokeOp, DeviceType.class)\n+            return OpTk.isInvokeDescriptorSubtypeOf(accelerator.lookup,invokeOp, DeviceType.class)\n@@ -239,0 +240,1 @@\n+\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyMemoryPhase.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import hat.optools.Trxfmr;\n@@ -47,1 +48,0 @@\n-\n@@ -69,1 +69,1 @@\n-                .filter(fieldLoadOp -> OpTk.fieldNameMatches(fieldLoadOp,pattern() ))\n+                .filter(fieldLoadOp -> pattern().matcher(fieldLoadOp.fieldDescriptor().name()).matches())\n@@ -71,8 +71,8 @@\n-                        fieldLoadOp.operands().stream()\n-                                .filter(o->o instanceof Op.Result result && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n-                                .map(o->( CoreOp.VarAccessOp.VarLoadOp)((Op.Result)o).op())\n-                                .filter(this::isMethodFromHatKernelContext)\n-                                .forEach(varLoadOp -> {\n-                                    consumer.accept(fieldLoadOp);\n-                                    consumer.accept(varLoadOp);\n-                                })\n+                            fieldLoadOp.operands().stream()\n+                                    .filter(o -> o instanceof Op.Result result && result.op() instanceof CoreOp.VarAccessOp.VarLoadOp)\n+                                    .map(o -> (CoreOp.VarAccessOp.VarLoadOp) ((Op.Result) o).op())\n+                                    .filter(this::isMethodFromHatKernelContext)\n+                                    .forEach(varLoadOp -> {\n+                                        consumer.accept(fieldLoadOp);\n+                                        consumer.accept(varLoadOp);\n+                                    })\n@@ -93,4 +93,4 @@\n-                                HATThreadOp threadOp = factory(fieldLoadOp);\n-                                Op.Result threadResult = blockBuilder.op(threadOp);\n-                                threadOp.setLocation(fieldLoadOp.location()); \/\/ update location\n-                                context.mapValue(fieldLoadOp.result(), threadResult);\n+                            HATThreadOp threadOp = factory(fieldLoadOp);\n+                            Op.Result threadResult = blockBuilder.op(threadOp);\n+                            threadOp.setLocation(fieldLoadOp.location()); \/\/ update location\n+                            context.mapValue(fieldLoadOp.result(), threadResult);\n@@ -104,0 +104,14 @@\n+    public CoreOp.FuncOp applyTxfmr(CoreOp.FuncOp funcOp) {\n+        return new Trxfmr.Edge.Selector<JavaOp.FieldAccessOp.FieldLoadOp, CoreOp.VarAccessOp.VarLoadOp>()\n+        .select(funcOp, ce->ce instanceof JavaOp.FieldAccessOp.FieldLoadOp fieldLoadOp\n+                        && Trxfmr.Edge.kernelContextFieldVarLoad(accelerator.lookup,fieldLoadOp, fieldName->pattern().matcher(fieldName).matches())\n+                        instanceof Trxfmr.Edge<JavaOp.FieldAccessOp.FieldLoadOp,CoreOp.VarAccessOp.VarLoadOp> e? e:null)\n+        .transform(funcOp,c->{\n+            switch (c.op()){\n+                case JavaOp.FieldAccessOp.FieldLoadOp $  -> c.replace(factory($));\n+                case CoreOp.VarAccessOp.VarLoadOp _ -> c.remove();\n+                default -> {}\n+            }\n+        });\n+    }\n+\n@@ -135,1 +149,1 @@\n-            return Pattern.compile(\"([xyz]|gi[xyz])\");\n+            return Pattern.compile(\"(gi[xyz])\");\n@@ -152,1 +166,1 @@\n-            return Pattern.compile(\"(gs[xyz]|max[XYZ])\");\n+            return Pattern.compile(\"(gs[xyz])\");\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyThreadsPhase.java","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.incubator.code.dialect.java.JavaType;\n@@ -57,0 +58,1 @@\n+import java.util.regex.Pattern;\n@@ -109,8 +111,16 @@\n-        TypeElement typeElement = invokeOp.resultType();\n-        Set<Class<?>> interfaces = Set.of();\n-        try {\n-            Class<?> aClass = Class.forName(typeElement.toString());\n-            interfaces = OpTk.inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-        }\n-        return interfaces.contains(_V.class) && isMethod(invokeOp, vectorOperation.methodName);\n+       \/\/ boolean letsUseOpTk=false;\n+      \/\/ if (letsUseOpTk) {\n+           return (invokeOp.resultType() instanceof JavaType jt\n+                   && OpTk.isAssignable(accelerator.lookup, jt, _V.class)\n+                   && OpTk.isMethod(invokeOp, n->n.equals(vectorOperation.methodName))\n+           );\n+      \/\/ }else {\n+        \/\/   TypeElement typeElement = invokeOp.resultType();\n+        \/\/   Set<Class<?>> interfaces = Set.of();\n+        \/\/   try {\n+        \/\/       Class<?> aClass = Class.forName(typeElement.toString());\n+        \/\/       interfaces = OpTk.inspectAllInterfaces(aClass);\n+        \/\/   } catch (ClassNotFoundException _) {\n+        \/\/   }\n+        \/\/   return interfaces.contains(_V.class) && OpTk.isMethod(invokeOp, vectorOperation.methodName);\n+      \/\/ }\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorOpPhase.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import hat.types._V;\n@@ -43,0 +42,1 @@\n+import java.util.regex.Pattern;\n@@ -46,9 +46,2 @@\n-public class HATDialectifyVectorSelectPhase implements HATDialect {\n-\n-    protected final Accelerator accelerator;\n-    @Override  public Accelerator accelerator(){\n-        return this.accelerator;\n-    }\n-    public HATDialectifyVectorSelectPhase(Accelerator accelerator) {\n-        this.accelerator = accelerator;\n-    }\n+public record HATDialectifyVectorSelectPhase(Accelerator accelerator) implements HATDialect {\n+    static Pattern xyzw = Pattern.compile(\"[xyzw]\");\n@@ -57,4 +50,1 @@\n-        return isMethod(invokeOp, \"x\")\n-                || isMethod(invokeOp, \"y\")\n-                || isMethod(invokeOp, \"z\")\n-                || isMethod(invokeOp, \"w\");\n+        return OpTk.isMethod(invokeOp, n->xyzw.matcher(n).matches());\n@@ -73,16 +63,1 @@\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp) {\n-        String typeElement = invokeOp.invokeDescriptor().refType().toString();\n-        Set<Class<?>> interfaces;\n-        try {\n-            Class<?> aClass = Class.forName(typeElement);\n-            interfaces = OpTk.inspectAllInterfaces(aClass);\n-        } catch (ClassNotFoundException _) {\n-            return false;\n-        }\n-        return interfaces.contains(_V.class) && isVectorLane(invokeOp);\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n+    \/\/ recursive\n@@ -91,6 +66,3 @@\n-            return findNameVector(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp vectorViewOp) {\n-                return vectorViewOp.varName();\n-            }\n-            return null;\n+            return findNameVector(varLoadOp.operands().getFirst());\n+        } else if (v instanceof CoreOp.Result r && r.op() instanceof HATVectorOp vectorViewOp) {\n+            return vectorViewOp.varName();\n@@ -98,1 +70,1 @@\n-    }\n+        throw new IllegalStateException(\"recurse fail findNameVector\");\n@@ -100,2 +72,0 @@\n-    private CoreOp.VarOp findVarOp(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findVarOp(varLoadOp.operands().get(0));\n@@ -104,0 +74,2 @@\n+\n+    \/\/recursive\n@@ -106,6 +78,3 @@\n-            return findVarOp(varLoadOp);\n-        } else {\n-            if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n-                return varOp;\n-            }\n-            return null;\n+            return findVarOp(varLoadOp.operands().getFirst());\n+        } else if (v instanceof CoreOp.Result r && r.op() instanceof CoreOp.VarOp varOp) {\n+            return varOp;\n@@ -113,0 +82,2 @@\n+        return null;\/\/throw new IllegalStateException(\"recurse fail findVarOp\");\n+\n@@ -124,1 +95,1 @@\n-                        if (isVectorOperation(invokeOp) && (invokeOp.resultType() != JavaType.VOID)) {\n+                        if (OpTk.isVectorOperation(invokeOp, isVectorLane(invokeOp)) && (invokeOp.resultType() != JavaType.VOID)) {\n@@ -146,1 +117,1 @@\n-                        String name = findNameVector(varLoadOp);\n+                        String name = findNameVector(varLoadOp.operands().getFirst());\n@@ -173,4 +144,4 @@\n-        var here = OpTk.CallSite.of(this.getClass(),\"vstoreSelectPhase\");\n-         before(here, funcOp);\n-          \/\/TODO is this side table safe?\n-        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTk.elements(here,funcOp)\n+        var here = OpTk.CallSite.of(this.getClass(), \"vstoreSelectPhase\");\n+        before(here, funcOp);\n+        \/\/TODO is this side table safe?\n+        Stream<CodeElement<?, ?>> float4NodesInvolved = OpTk.elements(here, funcOp)\n@@ -179,1 +150,1 @@\n-                        if (isVectorOperation(invokeOp)) {\n+                        if (OpTk.isVectorOperation(invokeOp, isVectorLane(invokeOp))) {\n@@ -203,1 +174,1 @@\n-                    String name = findNameVector(varLoadOp);\n+                    String name = findNameVector(varLoadOp.operands().getFirst());\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorSelectPhase.java","additions":24,"deletions":53,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.regex.Pattern;\n@@ -69,19 +70,1 @@\n-\n-    private boolean isVectorOperation(JavaOp.InvokeOp invokeOp, Value varValue) {\n-        if (varValue instanceof Op.Result r && r.op() instanceof CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-            TypeElement typeElement = varLoadOp.resultType();\n-            Set<Class<?>> interfaces = Set.of();\n-            try {\n-                Class<?> aClass = Class.forName(typeElement.toString());\n-                interfaces = OpTk.inspectAllInterfaces(aClass);\n-            } catch (ClassNotFoundException _) {\n-            }\n-            return interfaces.contains(_V.class) && isMethod(invokeOp, vectorOperation.methodName);\n-        }\n-        return false;\n-    }\n-\n-    private String findNameVector(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findNameVector(varLoadOp.operands().get(0));\n-    }\n-\n+    \/\/recursive\n@@ -90,1 +73,1 @@\n-            return findNameVector(varLoadOp);\n+            return findNameVector(varLoadOp.operands().getFirst());\n@@ -94,1 +77,1 @@\n-            return null;\n+            throw new IllegalStateException(\"no name\");\n@@ -98,4 +81,1 @@\n-    private boolean findIsSharedOrPrivateSpace(CoreOp.VarAccessOp.VarLoadOp varLoadOp) {\n-        return findIsSharedOrPrivateSpace(varLoadOp.operands().get(0));\n-    }\n-\n+    \/\/recursive\n@@ -104,5 +84,3 @@\n-            return findIsSharedOrPrivateSpace(varLoadOp);\n-        } else  if (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp)) {\n-            return true;\n-        }else{\n-            return false;\n+            return findIsSharedOrPrivateSpace(varLoadOp.operands().getFirst());\n+        } else{\n+            return (v instanceof CoreOp.Result r && (r.op() instanceof HATLocalVarOp || r.op() instanceof HATPrivateVarOp));\n@@ -118,2 +96,3 @@\n-                    if (codeElement instanceof JavaOp.InvokeOp invokeOp) {\n-                        if ((invokeOp.operands().size() >= 3) && (isVectorOperation(invokeOp, invokeOp.operands().get(1)))) {\n+                    if (codeElement instanceof JavaOp.InvokeOp invokeOp\n+                        && (invokeOp.operands().size() >= 3) &&\n+                            (OpTk.isVectorOperation(invokeOp, invokeOp.operands().get(1),n->n.equals(vectorOperation.methodName)))) {\n@@ -122,1 +101,0 @@\n-                    }\n@@ -134,3 +112,0 @@\n-                \/\/ Find the name of the vector view variable\n-                String name = findNameVector(invokeOp.operands().get(1));\n-\n@@ -141,1 +116,2 @@\n-                HATVectorOp storeView = new HATVectorStoreView(name, invokeOp.resultType(), vectorMetaData.lanes(), vectorElementType, isSharedOrPrivate,  outputOperandsVarOp);\n+                HATVectorOp storeView = new HATVectorStoreView(findNameVector(invokeOp.operands().get(1)), invokeOp.resultType(), vectorMetaData.lanes(),\n+                        vectorElementType, isSharedOrPrivate,  outputOperandsVarOp);\n","filename":"hat\/core\/src\/main\/java\/hat\/phases\/HATDialectifyVectorStorePhase.java","additions":13,"deletions":37,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        if (OpTk.isKernelContextAccess(fieldLoadOp)) {\n+        if (OpTk.isKernelContextFieldAccessOp(buildContext.lookup,fieldLoadOp,_->true)) {\n","filename":"hat\/tools\/src\/main\/java\/hat\/tools\/text\/JavaHATCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}