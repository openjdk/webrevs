{"files":[{"patch":"@@ -52,1 +52,1 @@\n-import static optkl.OpHelper.Lambda.lambdaOpHelper;\n+import static optkl.OpHelper.Lambda.lambda;\n@@ -203,1 +203,1 @@\n-        Object[] args = lambdaOpHelper(lookup,lambda).getQuotedCapturedValues( quoted, method);\n+        Object[] args = lambda(lookup,lambda).getQuotedCapturedValues( quoted, method);\n","filename":"hat\/core\/src\/main\/java\/hat\/Accelerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import static optkl.OpHelper.Lambda.lambdaOpHelper;\n+import static optkl.OpHelper.Lambda.lambda;\n@@ -170,1 +170,1 @@\n-        Object[] args = lambdaOpHelper(lookup(),kernelCallSite.lambdaOp).getQuotedCapturedValues(kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n+        Object[] args = lambda(lookup(),kernelCallSite.lambdaOp).getQuotedCapturedValues(kernelCallSite.quoted, kernelCallSite.kernelCallGraph.entrypoint.method);\n","filename":"hat\/core\/src\/main\/java\/hat\/ComputeContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.code.Value;\n-import jdk.incubator.code.dialect.core.CoreOp;\n@@ -35,2 +33,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n@@ -38,2 +34,1 @@\n-import java.util.Arrays;\n-import java.util.Optional;\n+import static experiments.LanewiseUtils.createBinaryOp;\n@@ -41,32 +36,0 @@\n-public class LanewiseBinaryOpExtraction {\n-\n-    public record XY(int x, int y) {\n-        @Reflect\n-        static XY of(int x, int y) {\n-            return new XY(x, y);\n-        }\n-\n-        @Reflect\n-        static XY addEm(XY lhs, XY rhs) { \/\/ We don't have to call this add.\n-            return new XY(lhs.x + rhs.x, lhs.y + rhs.y);\n-        }\n-\n-        @Reflect\n-        static XY sub(XY lhs, XY rhs) {\n-            return new XY(lhs.x - rhs.x, lhs.y - rhs.y);\n-        }\n-\n-        @Reflect\n-        static XY div(XY lhs, XY rhs) {\n-            return new XY(lhs.x \/ rhs.x, lhs.y \/ rhs.y);\n-        }\n-\n-        @Reflect\n-        static XY mod(XY lhs, XY rhs) {\n-            return new XY(lhs.x % rhs.x, lhs.y % rhs.y);\n-        }\n-\n-        @Reflect\n-        static XY mul(XY lhs, XY rhs) {\n-            return new XY(lhs.x * rhs.x, lhs.y * rhs.y);\n-        }\n@@ -74,99 +37,1 @@\n-        @Reflect\n-        public XY mul(XY xy) {\n-            return mul(this, xy);\n-        }\n-\n-        @Reflect\n-        public XY mul(int scalar) {\n-            return mul(this, XY.of(scalar, scalar));\n-        }\n-\n-        @Reflect\n-        public XY addEm(XY xy) { \/\/ we don't have to call this add either\n-            return addEm(this, xy);\n-        }\n-\n-        @Reflect\n-        public XY sub(XY xy) {\n-            return sub(this, xy);\n-        }\n-\n-        @Reflect\n-        public XY div(XY xy) {\n-            return div(this, xy);\n-        }\n-\n-        @Reflect\n-        public XY mod(XY xy) {\n-            return mod(this, xy);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Look for first real BinaryOp by recursively decending through nested invokes until we find a BinaryOp\n-     *\n-     * We first test if the target of the invoke has a binary op, if it does we return it\n-     * If not then we find the first invoke in the target of this invoke that returns a binary Op and return that one\n-     *\n-     * So if we had\n-     *   @Reflect\n-     *   static XY mul(XY lhs, XY rhs) { #1\n-     *        return new XY(lhs.x * rhs.x, lhs.y * rhs.y);\n-     *   }\n-     *\n-     *   @Reflect\n-     *   public XY mul(XY xy) { \/\/ #2\n-     *       return mul(this, xy);\n-     *   }\n-     *\n-     *   And our invoke was #1 we would return MulOp\n-     *\n-     *   If the invoke was #2 we would recurse inside and then end up at #1 and return Mul Op.\n-     * @return The binaryOp from one of the reachable methods\n-     *\/\n-\n-    static JavaOp.BinaryOp getLaneWiseOp(Invoke invoke) {\n-        if (invoke.targetMethodModelOrThrow().elements().filter(o -> o instanceof JavaOp.BinaryOp).map(o -> (JavaOp.BinaryOp) o).findFirst()\n-                instanceof Optional<JavaOp.BinaryOp> optionalBinaryOp && optionalBinaryOp.isPresent()) {\n-            return optionalBinaryOp.get();\n-        } else {\n-           return  Invoke.stream(invoke.lookup(),invoke.targetMethodModelOrThrow()).map(LanewiseBinaryOpExtraction::getLaneWiseOp).findFirst().get();\n-        }\n-    }\n-\n-    \/*\n-     Create a binary Op by reflecting over code model of the reftype of the invoke method and determining the lanewise op.\n-    *\/\n-\n-    \/**\n-     * Reflectively a Replacement for\n-     * static JavaOp.BinaryOp createBinaryOp(String name, Value lhs, Value rhs){\n-     * return switch (name) {\n-     * case \"add\" -> JavaOp.add(lhs, rhs);\n-     * case \"sub\" -> JavaOp.sub(lhs, rhs);\n-     * case \"mul\" -> JavaOp.mul(lhs, rhs);\n-     * case \"div\" -> JavaOp.div(lhs, rhs);\n-     * case \"mod\" -> JavaOp.mod(lhs, rhs);\n-     * default -> throw new IllegalStateException(\"missed one\");\n-     * }\n-     * }\n-     *\/\n-\n-    static JavaOp.BinaryOp createBinaryOp(String name, Value lhs, Value rhs) {\n-        var opMethod = Arrays.stream(JavaOp.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get();\n-        try {\n-            return (JavaOp.BinaryOp) opMethod.invoke(null, lhs, rhs);\n-        } catch (IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-\n-    static JavaOp.BinaryOp createBinaryOpFromCodeModel(Invoke invoke, Value lhs, Value rhs) {\n-        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n-        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n-        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n-        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n-        return createBinaryOp(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n-    }\n+public class LanewiseBinaryOpExtraction {\n@@ -175,3 +40,2 @@\n-    public static XY center(XY min, XY max) {\n-        var two = XY.of(2, 2);\n-        return min.addEm(max).div(two).addEm(XY.of(1,1)).mul(XY.of(15,15));\n+    public static S32x2 center(S32x2 min, S32x2 max) {\n+        return min.add(max).div(S32x2.of(2,2));\n@@ -183,1 +47,1 @@\n-        Trxfmr.of(lookup, LanewiseBinaryOpExtraction.class, \"center\", XY.class, XY.class)\n+        Trxfmr.of(lookup, LanewiseBinaryOpExtraction.class, \"center\", S32x2.class, S32x2.class)\n@@ -186,2 +50,3 @@\n-                    if (binaryOpQuery.matches(c, $ -> \/\/ does it look like a fluent binary op we don't care about the name\n-                            $.returns(XY.class) && $.isInstance() && $.receives( XY.class)\n+                    if (binaryOpQuery.matches(c, $ ->\n+                            \/\/ does it look like a fluent binary op we don't care about the name\n+                            $.returns(S32x2.class) && $.isInstance() && $.receives( S32x2.class)\n@@ -189,1 +54,1 @@\n-                        c.replace(createBinaryOpFromCodeModel(match.helper(), c.mappedOperand(0), c.mappedOperand(1)));\n+                        c.replace(createBinaryOp(match.helper(), c.mappedOperand(0), c.mappedOperand(1)));\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseBinaryOpExtraction.java","additions":9,"deletions":144,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import jdk.incubator.code.Reflect;\n+import jdk.incubator.code.Value;\n+import jdk.incubator.code.dialect.java.JavaOp;\n+import optkl.InvokeQuery;\n+import optkl.OpHelper.Named.NamedStaticOrInstance.Invoke;\n+import optkl.Trxfmr;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+public class LanewiseUtils {\n+    \/**\n+     * Look for first real BinaryOp by recursively decending through nested invokes until we find a BinaryOp\n+     *\n+     * We first test if the target of the invoke has a binary op, if it does we return it\n+     * If not then we find the first invoke in the target of this invoke that returns a binary Op and return that one\n+     *\n+     * So if we had\n+     *   @Reflect\n+     *   static S32x2 mul(S32x2 lhs, S32x2 rhs) { #1\n+     *        return new S32x2(lhs.x * rhs.x, lhs.y * rhs.y);\n+     *   }\n+     *\n+     *   @Reflect\n+     *   public S32x2 mul(S32x2 rhs) { \/\/ #2\n+     *       return mul(this, rhs);\n+     *   }\n+     *\n+     *   And our invoke was #1 we would return MulOp\n+     *\n+     *   If the invoke was #2 we would recurse inside and then end up at #1 and return Mul Op.\n+     * @return The binaryOp from one of the reachable methods\n+     *\/\n+\n+    static JavaOp.BinaryOp getLaneWiseOp(Invoke invoke) {\n+        if (invoke.targetMethodModelOrThrow().elements().filter(o -> o instanceof JavaOp.BinaryOp).map(o -> (JavaOp.BinaryOp) o).findFirst()\n+                instanceof Optional<JavaOp.BinaryOp> optionalBinaryOp && optionalBinaryOp.isPresent()) {\n+            return optionalBinaryOp.get();\n+        } else {\n+           return  Invoke.stream(invoke.lookup(),invoke.targetMethodModelOrThrow()).map(LanewiseUtils::getLaneWiseOp).findFirst().get();\n+        }\n+    }\n+\n+    static JavaOp.BinaryOp createBinaryOpViaNameSwitch(String name, Value lhs, Value rhs) {\n+        return switch (name) {\n+           case \"add\" -> JavaOp.add(lhs, rhs);\n+           case \"sub\" -> JavaOp.sub(lhs, rhs);\n+           case \"div\" -> JavaOp.div(lhs, rhs);\n+            case \"mul\" -> JavaOp.mul(lhs, rhs);\n+           case \"mod\" -> JavaOp.mod(lhs, rhs);\n+           default -> throw new IllegalStateException(\"missed one\");\n+      };\n+    }\n+\n+    static JavaOp.BinaryOp createBinaryOpFromNameViaReflection(String name, Value lhs, Value rhs) {\n+        var opMethod = Arrays.stream(JavaOp.class.getDeclaredMethods()).filter(m -> m.getName().equals(name)).findFirst().get();\n+        try {\n+            return (JavaOp.BinaryOp) opMethod.invoke(null, lhs, rhs);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    static <T extends JavaOp.BinaryOp> T createBinaryOpViaClass(Class<T> clazz, Value lhs, Value rhs) {\n+        String name = clazz.getName();\n+\n+        var opMethod = Arrays.stream(JavaOp.class.getDeclaredMethods())\n+                .filter(m -> {\n+                    Class<?> returnType =  m.getReturnType();\n+                    String returnTypeName = returnType.getName();\n+                    boolean sameName = returnTypeName.equals(name);\n+                    if (sameName){\n+                        sameName=sameName;\n+                    }\n+                    return returnType.isAssignableFrom(clazz) && sameName;\n+                }).findFirst().get();\n+        try {\n+            return (T) opMethod.invoke(null, lhs, rhs);\n+        } catch (IllegalAccessException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    static JavaOp.BinaryOp createBinaryOpFromCodeModelViaClass(Invoke invoke, Value lhs, Value rhs) {\n+        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);\n+        Class<JavaOp.BinaryOp> clazz = (Class<JavaOp.BinaryOp>) laneWiseBinaryOp.getClass();\n+        return createBinaryOpViaClass(clazz, lhs, rhs);\n+    }\n+\n+    static JavaOp.BinaryOp createBinaryOpFromCodeModelFromNameViaReflectedName(Invoke invoke, Value lhs, Value rhs) {\n+        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n+        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n+        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n+        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n+        return createBinaryOpFromNameViaReflection(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n+    }\n+    static JavaOp.BinaryOp createBinaryOpFromCodeModelFromNameViaNameSwitch(Invoke invoke, Value lhs, Value rhs) {\n+        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n+        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n+        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n+        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n+        return createBinaryOpViaNameSwitch(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n+    }\n+    static JavaOp.BinaryOp createBinaryOp(Invoke invoke, Value lhs, Value rhs) {\n+        JavaOp.BinaryOp laneWiseBinaryOp =getLaneWiseOp(invoke);                                          \/\/ search for lanewise Op..\n+        String nameWithOpSuffix = laneWiseBinaryOp.getClass().getSimpleName();                            \/\/ CoreOp.AddOp -> AddOp\n+        String nameSansOp = nameWithOpSuffix.substring(0, nameWithOpSuffix.length() - \"Op\".length());     \/\/ AddOp -> Add\n+        String simpleName = nameSansOp.substring(0, 1).toLowerCase() + nameSansOp.substring(1); \/\/ Add->add\n+        return createBinaryOpViaNameSwitch(simpleName, lhs, rhs);                                                     \/\/ now we can reflectifly create a new AddOp.\n+    }\n+\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/LanewiseUtils.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024-26, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package experiments;\n+\n+import jdk.incubator.code.Reflect;\n+\n+public record S32x2(int x, int y) {\n+    @Reflect\n+    static S32x2 of(int x, int y) {\n+        return new S32x2(x, y);\n+    }\n+\n+    @Reflect\n+    static S32x2 add(S32x2 lhs, S32x2 rhs) { \/\/ We don't have to call this add.\n+        return new S32x2(lhs.x + rhs.x, lhs.y + rhs.y);\n+    }\n+\n+    @Reflect\n+    static S32x2 sub(S32x2 lhs, S32x2 rhs) {\n+        return new S32x2(lhs.x - rhs.x, lhs.y - rhs.y);\n+    }\n+\n+    @Reflect\n+    static S32x2 div(S32x2 lhs, S32x2 rhs) {\n+        return new S32x2(lhs.x \/ rhs.x, lhs.y \/ rhs.y);\n+    }\n+\n+    @Reflect\n+    static S32x2 mod(S32x2 lhs, S32x2 rhs) {\n+        return new S32x2(lhs.x % rhs.x, lhs.y % rhs.y);\n+    }\n+\n+    @Reflect\n+    static S32x2 mul(S32x2 lhs, S32x2 rhs) {\n+        return new S32x2(lhs.x * rhs.x, lhs.y * rhs.y);\n+    }\n+\n+    @Reflect\n+    public S32x2 mul(S32x2 s32x2) {\n+        return mul(this, s32x2);\n+    }\n+\n+    @Reflect\n+    public S32x2 mul(int scalar) {\n+        return mul(this, S32x2.of(scalar, scalar));\n+    }\n+\n+    @Reflect\n+    public S32x2 add(S32x2 s32x2) { \/\/ we don't have to call this add either\n+        return add(this, s32x2);\n+    }\n+\n+    @Reflect\n+    public S32x2 sub(S32x2 s32x2) {\n+        return sub(this, s32x2);\n+    }\n+\n+    @Reflect\n+    public S32x2 div(S32x2 s32x2) {\n+        return div(this, s32x2);\n+    }\n+\n+    @Reflect\n+    public S32x2 mod(S32x2 s32x2) {\n+        return mod(this, s32x2);\n+    }\n+}\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/S32x2.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -36,5 +36,0 @@\n-    public static class XY {\n-        private XY(int x, int y) {\n-            this.x = x;\n-            this.y = y;\n-        }\n@@ -42,47 +37,0 @@\n-        private int x, y;\n-\n-        static XY of(int x, int y) {\n-            return new XY(x, y);\n-        }\n-\n-        static XY mul(XY lhs, XY rhs) {\n-            return new XY(lhs.x * rhs.x, lhs.y * rhs.y);\n-        }\n-\n-        static XY add(XY lhs, XY rhs) {\n-            return new XY(lhs.x + rhs.x, lhs.y + rhs.y);\n-        }\n-\n-        static XY sub(XY lhs, XY rhs) {\n-            return new XY(lhs.x - rhs.x, lhs.y - rhs.y);\n-        }\n-\n-        static XY div(XY lhs, XY rhs) {\n-            return new XY(lhs.x \/ rhs.x, lhs.y \/ rhs.y);\n-        }\n-\n-        static XY mod(XY lhs, XY rhs) {\n-            return new XY(lhs.x % rhs.x, lhs.y % rhs.y);\n-        }\n-\n-        public XY mul(XY xy) {\n-            return mul(this, xy);\n-        }\n-\n-        public XY add(XY xy) {\n-            return add(this, xy);\n-        }\n-\n-        public XY sub(XY xy) {\n-            return sub(this, xy);\n-        }\n-\n-        public XY div(XY xy) {\n-            return div(this, xy);\n-        }\n-\n-        public XY mod(XY xy) {\n-            return mod(this, xy);\n-        }\n-\n-    }\n@@ -91,2 +39,2 @@\n-    public static XY center(XY min, XY max) {\n-        var two = XY.of(2, 2);\n+    public static S32x2 center(S32x2 min, S32x2 max) {\n+        var two = S32x2.of(2, 2);\n@@ -100,2 +48,1 @@\n-         Trxfmr.of(lookup,\n-                        UnpackingFluentBinaryOps.class, \"center\", XY.class, XY.class)\n+         Trxfmr.of(lookup, UnpackingFluentBinaryOps.class, \"center\", S32x2.class, S32x2.class)\n","filename":"hat\/examples\/experiments\/src\/main\/java\/experiments\/UnpackingFluentBinaryOps.java","additions":3,"deletions":56,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Lambda, OpHelper.Named, OpHelper.Ternary {\n+public sealed interface OpHelper<T extends Op> extends LookupCarrier permits OpHelper.Binary, OpHelper.Lambda, OpHelper.Named, OpHelper.Ternary {\n@@ -218,0 +218,3 @@\n+    static Op asOpFromResultOrNull(Value operand) {\n+        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n+    }\n@@ -232,5 +235,0 @@\n-\n-    static Op asOpFromResultOrNull(Value operand) {\n-        return asResultOrNull(operand) instanceof Op.Result r && r.op() instanceof Op op ? op : null;\n-    }\n-\n@@ -401,0 +399,22 @@\n+            sealed interface Func extends NamedStaticOrInstance<CoreOp.FuncOp> {\n+                @Override default boolean isStatic() {\n+                    throw new RuntimeException(\"implement Func.isStatic\");\n+                }\n+\n+                @Override default boolean isInstance() {\n+                     throw new RuntimeException(\"implement Func.isInstance\");\n+                }\n+\n+                @Override\n+                default String name() {\n+                    return op().funcName();\n+                }\n+\n+                record Impl(MethodHandles.Lookup lookup, CoreOp.FuncOp op) implements Func {\n+                }\n+\n+                static Func invoke(MethodHandles.Lookup lookup, CodeElement<?, ?> codeElement) {\n+                    return codeElement instanceof CoreOp.FuncOp funcOp ? new Func.Impl(lookup, funcOp) : null;\n+                }\n+\n+            }\n@@ -403,3 +423,0 @@\n-              \/\/  static Stream<Invoke> stream(MethodHandles.Lookup lookup, CoreOp.FuncOp funcOp) {\n-                \/\/    return funcOp.elements().filter(ce -> ce instanceof JavaOp.InvokeOp).map(ce -> invoke(lookup, ce));\n-               \/\/ }\n@@ -432,10 +449,7 @@\n-                    if (isInstance()){\n-                        for (int i =  0; assignable && i < classes.length && i< op().operands().size()-1; i++) {\n-                            var operand = op().operands().get(i+1);\n-                            TypeElement resultType = operand.type() ;\/\/instanceof VarType varType ? varType.valueType() : null;\n-                            assignable &= isAssignable((JavaType) resultType, classes[i]);\n-                        }\n-                    }else{\n-                        for (int i = 0; assignable && i < classes.length; i++) {\n-                            var operand = op().operands().get(i);\n-                            TypeElement resultType = operand.type() instanceof VarType varType ? varType.valueType() : null;\n+                    int adj=isInstance()?1:0;\/\/ for instance we compare op().operands(1..N) (0..N) for static\n+                    if (classes.length!= op().operands().size()-adj){\n+                        assignable=false;\n+                    }else {\n+                        for (int i = 0; assignable && i < classes.length && i < op().operands().size() - adj; i++) {\n+                            var operand = op().operands().get(i + adj);\n+                            TypeElement resultType = operand.type();\/\/instanceof VarType varType ? varType.valueType() : null;\n@@ -581,0 +595,2 @@\n+\n+\n@@ -652,1 +668,1 @@\n-        static Lambda lambdaOpHelper(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+        static Lambda lambda(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n@@ -687,0 +703,12 @@\n+\n+\n+    sealed interface Binary extends OpHelper<JavaOp.BinaryOp>{\n+        default  <T>boolean of(Class<T> clazz){\n+            return isAssignable((JavaType) op().resultType(),clazz);\n+        }\n+        record Impl(MethodHandles.Lookup lookup, JavaOp.BinaryOp op) implements Binary {}\n+        static Binary binary(MethodHandles.Lookup lookup, CodeElement<?,?> codeElement){\n+            return codeElement instanceof JavaOp.BinaryOp binaryOp? new Impl(lookup,binaryOp): null;\n+        }\n+    }\n+\n","filename":"hat\/optkl\/src\/main\/java\/optkl\/OpHelper.java","additions":48,"deletions":20,"binary":false,"changes":68,"status":"modified"}]}